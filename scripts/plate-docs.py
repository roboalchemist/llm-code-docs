#!/usr/bin/env python3
"""
Plate Documentation Scraper
Downloads Plate documentation from platejs.org and converts to markdown.
Plate is a rich-text editor framework for React built on Slate.
"""

import os
import sys
import requests
from pathlib import Path
import time
from bs4 import BeautifulSoup
import re

BASE_URL = "https://platejs.org"

# Known documentation sections based on platejs.org site structure
DOC_PAGES = [
    # Installation
    "installation",
    "installation/mcp",
    "installation/docs",
    "installation/manual",

    # Core concepts
    "introduction",
    "getting-started",
    "components",
    "plugins",

    # Components
    "components/editor",
    "components/fixed-toolbar",
    "components/fixed-toolbar-buttons",
    "components/floating-toolbar",
    "components/floating-toolbar-buttons",
    "components/block-menu",

    # API
    "api",
    "api/core",
    "api/core/plate-editor",
    "api/core/plate-plugin",
    "api/core/plate-components",
    "api/core/plate-controller",
    "api/core/plate-store",
    "api/slate",
    "api/slate/editor-api",
    "api/slate/editor-transforms",
    "api/slate/element",
    "api/slate/node",
    "api/slate/text",
    "api/slate/location",
    "api/slate/path",
    "api/slate/point",
    "api/slate/range",
    "api/slate/operation",
    "api/utils",
    "api/react-utils",
    "api/floating",
    "api/resizable",

    # Plugins - Basic Elements
    "basic-blocks",
    "heading",
    "blockquote",
    "code-block",
    "horizontal-rule",
    "link",
    "list",
    "media",
    "media/image",
    "media/video",
    "media/audio",
    "media/file",
    "table",
    "column",
    "caption",
    "toggle",
    "date",
    "equation",
    "excalidraw",

    # Plugins - Basic Marks
    "basic-marks",
    "bold",
    "italic",
    "underline",
    "strikethrough",
    "code",
    "subscript",
    "superscript",
    "font-color",
    "font-size",
    "font-family",
    "font-background-color",
    "font-weight",
    "highlight",
    "kbd",

    # Plugins - Functionality
    "ai",
    "autoformat",
    "alignment",
    "block-selection",
    "block-menu",
    "callout",
    "clipboard",
    "combobox",
    "comment",
    "cursor-overlay",
    "dnd",
    "emoji",
    "exit-break",
    "find-replace",
    "floating-toolbar",
    "ghost-text",
    "history",
    "html",
    "indent",
    "line-height",
    "link",
    "markdown",
    "mention",
    "node-id",
    "normalize-types",
    "reset-node",
    "select-on-backspace",
    "single-line",
    "slash-command",
    "soft-break",
    "suggestion",
    "tabbable",
    "trailing-block",

    # Other
    "cli",
]


def clean_html_to_markdown(html_content, url):
    """Convert HTML content to clean markdown."""
    soup = BeautifulSoup(html_content, 'html.parser')

    # Try to find the main content area
    # Fumadocs typically uses main tag or article
    main_content = soup.find('main') or soup.find('article') or soup.find('div', class_=re.compile(r'content|article|prose'))

    if not main_content:
        # Fallback to body if no main content found
        main_content = soup.find('body')

    if not main_content:
        return None

    # Remove script tags, style tags, nav, header, footer
    for tag in main_content.find_all(['script', 'style', 'nav', 'header', 'footer']):
        tag.decompose()

    # Get text content
    text = main_content.get_text(separator='\n', strip=True)

    # Clean up excessive newlines
    text = re.sub(r'\n{3,}', '\n\n', text)

    # Add source header
    header = f"""# Plate Documentation
# Source: {url}
# Generated by llm-code-docs plate-docs.py scraper

"""

    return header + text


def download_page(page_path, output_dir):
    """Download a single documentation page."""
    url = f"{BASE_URL}/docs/{page_path}"

    try:
        print(f"  Downloading: {url}")

        response = requests.get(url, timeout=15)

        if response.status_code == 404:
            print(f"    -> Not found (404)")
            return False

        response.raise_for_status()

        # Convert HTML to markdown
        markdown_content = clean_html_to_markdown(response.text, url)

        if not markdown_content or len(markdown_content) < 200:
            print(f"    -> No content extracted")
            return False

        # Create output filename
        output_filename = page_path.replace('/', '-') + '.md'
        output_path = output_dir / output_filename

        # Write to file
        output_path.parent.mkdir(parents=True, exist_ok=True)
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(markdown_content)

        file_size = len(markdown_content)
        print(f"    -> Saved: {output_filename} ({file_size:,} bytes)")
        return True

    except requests.exceptions.RequestException as e:
        print(f"    -> Error downloading: {e}")
        return False
    except Exception as e:
        print(f"    -> Error processing: {e}")
        return False


def main():
    """Main function to download all Plate documentation."""
    print("=" * 60)
    print("Plate Documentation Scraper")
    print("=" * 60)
    print()

    # Output directory
    script_dir = Path(__file__).parent.parent
    output_dir = script_dir / "docs" / "web-scraped" / "plate"
    output_dir.mkdir(parents=True, exist_ok=True)

    print(f"Output directory: {output_dir}")
    print(f"Total pages to download: {len(DOC_PAGES)}")
    print()

    successful = 0
    failed = 0
    start_time = time.time()

    for idx, page_path in enumerate(DOC_PAGES, 1):
        print(f"[{idx:3d}/{len(DOC_PAGES)}] ", end="")

        if download_page(page_path, output_dir):
            successful += 1
        else:
            failed += 1

        # Be respectful with rate limiting
        time.sleep(0.5)

    elapsed = time.time() - start_time

    print()
    print("=" * 60)
    print("Download Summary")
    print("=" * 60)
    print(f"Successful: {successful}")
    print(f"Failed: {failed}")
    print(f"Time: {elapsed:.1f} seconds")
    print(f"Output: {output_dir}")

    # Calculate total size
    total_size = sum(f.stat().st_size for f in output_dir.glob("*.md") if f.is_file())
    print(f"Total size: {total_size:,} bytes ({total_size/1024:.1f} KB)")

    print()
    if successful == 0:
        print("Error: No files downloaded successfully!")
        sys.exit(1)
    elif failed > successful:
        print(f"Warning: More failures ({failed}) than successes ({successful})")
        sys.exit(1)
    else:
        print(f"Documentation downloaded successfully! ({successful} files)")
        sys.exit(0)


if __name__ == "__main__":
    main()
