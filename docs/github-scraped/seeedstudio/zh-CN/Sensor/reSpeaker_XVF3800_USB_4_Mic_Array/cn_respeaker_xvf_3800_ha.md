---
description: ä½“éªŒ ReSpeaker XVF3800 USB 4-Mic Array çš„å¼ºå¤§åŠŸèƒ½â€”â€”è¿™æ˜¯ä¸€æ¬¾å…ˆè¿›çš„åœ†å½¢éº¦å…‹é£é˜µåˆ—ï¼Œå…·æœ‰ AECã€æ³¢æŸæˆå½¢ã€å™ªå£°æŠ‘åˆ¶å’Œ 360Â° è¯­éŸ³æ•è·åŠŸèƒ½ã€‚ä¸ç´§å‡‘çš„ XIAO ESP32S3 é…å¯¹ï¼Œä¸ºæ™ºèƒ½è®¾å¤‡ã€æœºå™¨äººå’Œç‰©è”ç½‘åº”ç”¨æä¾›é«˜æ€§èƒ½è¯­éŸ³æ§åˆ¶ã€‚åŠ å…¥æˆ‘ä»¬ï¼Œæ¼”ç¤ºä¸ Home Assistant çš„æ— ç¼é›†æˆï¼Œä½¿ç”¨è¯­éŸ³å‘½ä»¤æ§åˆ¶è®¾å¤‡ã€‚

title: ä½¿ç”¨ Home Assistant çš„æ™ºèƒ½å®¶å±…è¯­éŸ³æ§åˆ¶

keywords:
- reSpeaker
- XIAO
- ESP32S3
- Home Assistant
image: https://files.seeedstudio.com/wiki/respeaker_xvf3800_usb/respeaker-xvf3800-4-mic-array-with-xiao-esp32s3.webp
slug: /cn/respeaker_xvf3800_xiao_home_assistant
last_update:
  date: 9/17/2025
  author: Kasun Thushara
---

## æ¦‚è¿°

ä½¿ç”¨å…¨æ–°çš„ **ReSpeaker XMOS XVF3800 with XIAO ESP32S3** ä¸æ™ºèƒ½ç©ºé—´å¯¹è¯ï¼Œé€šè¿‡è¯­éŸ³å¼€å…³ç¯å…‰ã€æ’­æ”¾éŸ³ä¹ï¼Œç”šè‡³è¯¢é—®å¤©æ°”

åœ¨æœ¬ç« ä¸­ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨ ReSpeaker XMOS XVF3800 with XIAO ESP32S3 HA è¯­éŸ³åŠ©æ‰‹è¿æ¥ Sonoff æ™ºèƒ½å¼€å…³ï¼Œå®ç°è¯­éŸ³æ§åˆ¶ç¯å…‰å¼€å…³ã€‚

<div class="video-container">
  <iframe width="800" height="400"
          src="https://www.youtube.com/embed/iqlsNezHYuE"
          title="ReSpeaker XVF3800 with XIAO ESP32S3 Home Assistant"
          frameborder="0"
          allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
          referrerpolicy="strict-origin-when-cross-origin"
          allowfullscreen>
  </iframe>
</div>

## æ‰€éœ€ç¡¬ä»¶

<table align="center">
  <tr>
      <th>ReSpeaker XVF3800 with XIAO ESP32S3</th>
        <th>Home Assistant è®¾å¤‡</th>
        <th>Sonoff BASICR2</th>
  </tr>
  <tr>
      <td><div style={{textAlign:'center'}}><img src="https://files.seeedstudio.com/wiki/respeaker_xvf3800_usb/front-xiao.jpg" style={{width:500, height:'auto'}}/></div></td>
        <td><div style={{textAlign:'center'}}><img src="https://files.seeedstudio.com/wiki/Home_Assistant_Green/HAyellow.png" style={{width:500, height:'auto'}}/></div></td>
        <td><div style={{textAlign:'center'}}><img src="https://media-cdn.seeedstudio.com/media/catalog/product/cache/bb49d3ec4ee05b6f018e93f896b8a25d/1/-/1-113991074-sonoff-basicr2-45font.jpg" style={{width:500, height:'auto'}}/></div></td>
  </tr>
    <tr>
      <td><div class="get_one_now_container" style={{textAlign: 'center'}}>
        <a class="get_one_now_item" href="https://www.seeedstudio.com/ReSpeaker-XVF3800-4-Mic-Array-With-XIAO-ESP32S3-p-6489.html" target="_blank">
            <strong><span><font color={'FFFFFF'} size={"4"}> ç«‹å³è·å– ğŸ–±ï¸</font></span></strong>
        </a>
    </div></td>
        <td><div class="get_one_now_container" style={{textAlign: 'center'}}>
        <a class="get_one_now_item" href="https://www.seeedstudio.com/Home-Assistant-Yellow-Standard-Version-with-CM4-p-5809.html" target="_blank">
            <strong><span><font color={'FFFFFF'} size={"4"}> ç«‹å³è·å– ğŸ–±ï¸</font></span></strong>
        </a>
    </div></td>
        <td><div class="get_one_now_container" style={{textAlign: 'center'}}>
        <a class="get_one_now_item" href="https://www.seeedstudio.com/Sonoff-BasicR2-p-5514.html" target="_blank">
            <strong><span><font color={'FFFFFF'} size={"4"}> ç«‹å³è·å– ğŸ–±ï¸</font></span></strong>
        </a>
    </div></td>
  </tr>
</table>

## å›ºä»¶æ›´æ–°

ä¸ºäº†è·å¾—æœ€ä½³çš„æ’­æ”¾ä½“éªŒï¼Œæˆ‘ä»¬éœ€è¦å°† XMOS å›ºä»¶æ›´æ–°åˆ°
ä»è¿™é‡Œä¸‹è½½å›ºä»¶ã€‚åœ¨æ‚¨çš„è®¡ç®—æœºä¸Šï¼Œæ’å…¥ ReSpeaker XMOS XVF3800 with XIAO ESP32S3 å¹¶è¿è¡Œæˆ‘ä»¬æŒ‡å—ä¸­çš„ï¼š

<p style={{textAlign: 'center'}}><img src="https://files.seeedstudio.com/wiki/respeaker_xvf3800_usb/HA/firmware_1.png" alt="pir" width={800} height="auto" /></p>

:::note
XVF3800 éº¦å…‹é£é˜µåˆ—éœ€è¦ 12.288 MHz MCLK æ‰èƒ½å·¥ä½œï¼Œä½† ESPHomeï¼ˆåœ¨ Home Assistant ä¸­ä½¿ç”¨ï¼‰ç”±äº API é™åˆ¶æ— æ³•ç”Ÿæˆå®ƒã€‚æ­¤å›ºä»¶ä½¿ XVF3800 å……å½“ I2S ä¸»è®¾å¤‡ï¼Œå› æ­¤å®ƒå¯ä»¥ç”Ÿæˆè‡ªå·±çš„æ—¶é’Ÿï¼Œè€Œæ— éœ€æ¥è‡ª ESP32 çš„ MCLKã€‚
æˆ‘ä»¬çš„å›ºä»¶ä¿®å¤äº†è¿™ä¸ªé™åˆ¶ï¼Œå› æ­¤éº¦å…‹é£å¯ä»¥ä¸ Home Assistant æ­£å¸¸å·¥ä½œã€‚
:::

æ‚¨å¯ä»¥ä»[è¿™é‡Œ](https://github.com/respeaker/reSpeaker_XVF3800_USB_4MIC_ARRAY/tree/master/xmos_firmwares/i2s)ä¸‹è½½å›ºä»¶

å®‰è£…æŒ‡å—åœ¨[è¿™é‡Œ](https://wiki.seeedstudio.com/cn/respeaker_xvf3800_introduction/#update-firmware)

## å‡†å¤‡ ReSpeaker XMOS XVF3800 with XIAO ESP32S3

è½¬åˆ° **Home Assistant > Settings > Add-ons**ã€‚

<p style={{textAlign: 'center'}}><img src="https://files.seeedstudio.com/wiki/respeaker_xvf3800_usb/HA/HA_Settings.PNG" alt="pir" width={800} height="auto" /></p>

ç‚¹å‡» **Add-on Store**ï¼ˆé€šå¸¸åœ¨å³ä¸‹è§’ï¼‰

<p style={{textAlign: 'center'}}><img src="https://files.seeedstudio.com/wiki/respeaker_xvf3800_usb/HA/HA_addon.PNG" alt="pir" width={800} height="auto" /></p>

åœ¨ **Official add-ons** ä¸‹ï¼Œæœç´¢å¹¶å®‰è£… **ESPHome Device Builder**ã€‚

<p style={{textAlign: 'center'}}><img src="https://files.seeedstudio.com/wiki/respeaker_xvf3800_usb/HA/HA_esphome.PNG" alt="pir" width={800} height="auto" /></p>

å®‰è£…åï¼Œç‚¹å‡» **Start** è¿è¡Œ ESPHome æ’ä»¶ã€‚

<p style={{textAlign: 'center'}}><img src="https://files.seeedstudio.com/wiki/respeaker_xvf3800_usb/HA/HA_esphome_Start.PNG" alt="pir" width={800} height="auto" /></p>

å¯ç”¨ **Start on Boot, Watchdog, and Show in Sidebar** ä»¥ä¾¿æ›´å®¹æ˜“è®¿é—®ã€‚

ä» Home Assistant ä¾§è¾¹æ ï¼Œè½¬åˆ° **ESPHome Builder**ã€‚

ç‚¹å‡» **+ NEW DEVICE**ã€‚

<p style={{textAlign: 'center'}}><img src="https://files.seeedstudio.com/wiki/respeaker_xvf3800_usb/HA/HA_esphome_add_new.PNG" alt="pir" width={800} height="auto" /></p>

<p style={{textAlign: 'center'}}><img src="https://files.seeedstudio.com/wiki/respeaker_xvf3800_usb/HA/HA_esphome_device.PNG" alt="pir" width={500} height="auto" /></p>

å½“æç¤ºæ—¶ï¼Œç‚¹å‡» **SKIP** â€“ æˆ‘ä»¬å°†æ‰‹åŠ¨åˆ›å»ºé…ç½®ã€‚

<p style={{textAlign: 'center'}}><img src="https://files.seeedstudio.com/wiki/respeaker_xvf3800_usb/HA/HA_esphome_skip.PNG" alt="pir" width={500} height="auto" /></p>

é€‰æ‹©æ‚¨çš„æ–°è®¾å¤‡æ¡ç›®å¹¶ç‚¹å‡» **EDIT**ã€‚

<p style={{textAlign: 'center'}}><img src="https://files.seeedstudio.com/wiki/respeaker_xvf3800_usb/HA/HA_esphome_respeaker_device.PNG" alt="pir" width={800} height="auto" /></p>

ç”¨æ‚¨çš„è‡ªå®šä¹‰ **YAML é…ç½®**æ›¿æ¢å†…å®¹

:::important
æ‚¨å¯ä»¥ä»[è¿™é‡Œ](https://github.com/formatBCE/Respeaker-XVF3800-ESPHome-integration/tree/main/config)æ‰¾åˆ° YAML æ–‡ä»¶
:::

ä¿å­˜ YAML åï¼Œç‚¹å‡» **INSTALL**ã€‚

<p style={{textAlign: 'center'}}><img src="https://files.seeedstudio.com/wiki/respeaker_xvf3800_usb/HA/HA_esphome_yaml.PNG" alt="pir" width={800} height="auto" /></p>

é€‰æ‹© **Manual Download**

<p style={{textAlign: 'center'}}><img src="https://files.seeedstudio.com/wiki/respeaker_xvf3800_usb/HA/HA_esphome_manual.PNG" alt="pir" width={800} height="auto" /></p>

ç­‰å¾…å›ºä»¶ç¼–è¯‘ã€‚

å°†ç”Ÿæˆçš„ .bin å›ºä»¶æ–‡ä»¶ä¸‹è½½åˆ°æ‚¨çš„è®¡ç®—æœºã€‚

<p style={{textAlign: 'center'}}><img src="https://files.seeedstudio.com/wiki/respeaker_xvf3800_usb/HA/HA_esphome_factory.PNG" alt="pir" width={800} height="auto" /></p>

ä½¿ç”¨ **USB Type-C çº¿ç¼†**å°† **ESP32-S3** æ¿ï¼ˆè¿æ¥ XVF3800ï¼‰è¿æ¥åˆ°æ‚¨çš„ PCã€‚

åœ¨ Chrome æˆ– Edge ä¸­æ‰“å¼€ [**Web-ESPHome**](https://web.esphome.io/?dashboard_wizard)ã€‚

ç‚¹å‡» **CONNECT** å¹¶é€‰æ‹©é€‚å½“çš„ä¸²è¡Œç«¯å£

<p style={{textAlign: 'center'}}><img src="https://files.seeedstudio.com/wiki/respeakerv3/connect-port.png" alt="pir" width={800} height="auto" /></p>

è¿æ¥åï¼Œç‚¹å‡» **INSTALL**

<p style={{textAlign: 'center'}}><img src="https://files.seeedstudio.com/wiki/respeaker_xvf3800_usb/HA/HA_esphome_install.PNG" alt="pir" width={500} height="auto" /></p>

é€‰æ‹©æ‚¨åˆšåˆšä¸‹è½½çš„ .bin æ–‡ä»¶ã€‚

<p style={{textAlign: 'center'}}><img src="https://files.seeedstudio.com/wiki/respeaker_xvf3800_usb/HA/HA_esphome_bin_write.PNG" alt="pir" width={500} height="auto" /></p>

ç­‰å¾…å®‰è£…å®Œæˆï¼ˆå¯èƒ½éœ€è¦å‡ åˆ†é’Ÿï¼‰ã€‚

æˆåŠŸåï¼Œæ‚¨å°†çœ‹åˆ°ç¡®è®¤æ¶ˆæ¯ã€‚

<p style={{textAlign: 'center'}}><img src="https://files.seeedstudio.com/wiki/respeaker_xvf3800_usb/HA/HA_esphome_congrats.PNG" alt="pir" width={500} height="auto" /></p>

è¿”å› **Home Assistant > Settings > Devices & Services**ã€‚

æ‚¨åº”è¯¥çœ‹åˆ° **ESPHome** åˆ—ä¸ºå·²å‘ç°çš„é›†æˆã€‚

ç‚¹å‡» **CONFIGURE**ï¼Œç„¶åç‚¹å‡» **Submit** å®Œæˆè®¾ç½®ã€‚

<p style={{textAlign: 'center'}}><img src="https://files.seeedstudio.com/wiki/respeaker_xvf3800_usb/HA/HA_esphome_discover.PNG" alt="pir" width={800} height="auto" /></p>

## æ·»åŠ æ‚¨çš„æ™ºèƒ½è®¾å¤‡

æ ¹æ®åˆ¶é€ å•†çš„ç”¨æˆ·æ‰‹å†Œè®¾ç½® **Sonoff BASICR2** è®¾å¤‡ã€‚æ‚¨éœ€è¦åˆ›å»º eWELink è´¦æˆ·ã€‚

### å®‰è£… HACS

å¦‚æœå°šæœªå®‰è£…ï¼Œè¯·æŒ‰ç…§å®˜æ–¹æŒ‡å—è®¾ç½® [**Home Assistant Community Store**](https://hacs.xyz/docs/use/)ï¼š

ä»ä¾§è¾¹æ æ‰“å¼€ **HACS**ã€‚
åœ¨æœç´¢éƒ¨åˆ†æœç´¢ **Sonoff LAN**ã€‚

<p style={{textAlign: 'center'}}><img src="https://files.seeedstudio.com/wiki/respeaker_xvf3800_usb/HA/HA_HACS.PNG" alt="pir" width={800} height="auto" /></p>

ç‚¹å‡» **Install** æ·»åŠ é›†æˆã€‚
é‡å¯ Home Assistant ä»¥åº”ç”¨æ›´æ”¹ã€‚

### Sonoff

å¯¼èˆªåˆ° **Settings â†’ Devices & Services**ã€‚
ç‚¹å‡» **Add Integration**ã€‚
æœç´¢å¹¶é€‰æ‹© **Sonoff**ã€‚

<p style={{textAlign: 'center'}}><img src="https://files.seeedstudio.com/wiki/respeaker_xvf3800_usb/HA/HA_esphome_sonoff.PNG" alt="pir" width={800} height="auto" /></p>

è¾“å…¥æ‚¨çš„ **eWeLink è´¦æˆ·å‡­æ®**è¿›è¡Œèº«ä»½éªŒè¯ã€‚

<p style={{textAlign: 'center'}}><img src="https://files.seeedstudio.com/wiki/SenseCAP/respeaker/credentials.png" alt="pir" width={500} height="auto" /></p>

æˆåŠŸè¿æ¥åï¼Œæ‚¨å°†åœ¨ä»¥ä¸‹ä½ç½®çœ‹åˆ°å…³è”çš„å®ä½“åˆ—è¡¨ï¼š
**Settings â†’ Devices & Services â†’ Entities**

<p style={{textAlign: 'center'}}><img src="https://files.seeedstudio.com/wiki/SenseCAP/respeaker/sonoff-id.png" alt="pir" width={800} height="auto" /></p>

## ä½¿ç”¨ Nabu Cloud çš„è¯­éŸ³åŠ©æ‰‹

åœ¨æ­¤æ¼”ç¤ºä¸­ï¼Œæˆ‘ä»¬å±•ç¤ºå¦‚ä½•ä½¿ç”¨è¯­éŸ³è¿æ¥ **Home Assistant Cloud (Nabu Casa)**ã€‚è®¾ç½®ç®€å•ï¼Œæ‚¨å¯ä»¥åˆ©ç”¨ **ä¸€ä¸ªæœˆå…è´¹è¯•ç”¨**æ¥æ¢ç´¢å…¶å…¨éƒ¨åŠŸèƒ½ã€‚
ä½¿ç”¨å†…ç½®çš„ **å”¤é†’è¯**ï¼š"Okay Nabu"ï¼Œæ‚¨å¯ä»¥è½»æ¾è§¦å‘è¯­éŸ³å‘½ä»¤å¹¶ä¸è®¾å¤‡å’ŒæœåŠ¡**æ— ç¼é›†æˆ**ï¼Œ**éšæ—¶éšåœ°** â€” æ— éœ€å¤æ‚é…ç½®ã€‚

<p style={{textAlign: 'center'}}><img src="https://files.seeedstudio.com/wiki/respeaker_xvf3800_usb/HA/HA_voice.PNG" alt="pir" width={800} height="auto" /></p>

<p style={{textAlign: 'center'}}><img src="https://files.seeedstudio.com/wiki/respeaker_xvf3800_usb/HA/HA_voice_nabu.PNG" alt="pir" width={800} height="auto" /></p>

## YAML æè¿°

### WiFi

æ­¤éƒ¨åˆ†è®¾ç½®è®¾å¤‡å¦‚ä½•è¿æ¥åˆ° Wi-Fiã€‚

```yml
wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
```

- **ssid & password**ï¼šä» secrets.yaml æ–‡ä»¶ä¸­è·å–ï¼Œå› æ­¤æ‚¨çš„å¯†ç ä¸ä¼šä»¥æ˜æ–‡å½¢å¼æ˜¾ç¤ºã€‚
- **Events**ï¼šåœ¨ Wi-Fi è¿æ¥æˆ–æ–­å¼€æ—¶è¿è¡Œæ“ä½œï¼š
  - on_connect:
    - åœæ­¢ BLE improv è®¾ç½®ã€‚
    - è¿è¡Œ control_leds è„šæœ¬ï¼ˆWi-Fi è¿æ¥çš„ LED æ•ˆæœï¼‰ã€‚

  - on_disconnect:
    - è¿è¡Œ control_leds è„šæœ¬ï¼ˆWi-Fi æ–­å¼€çš„ LED æ•ˆæœï¼‰ã€‚

### IÂ²C æ€»çº¿

IÂ²C æ˜¯ä¸€æ¡é€šä¿¡çº¿è·¯ï¼Œè®©æ‚¨çš„ ESP32 ä¸å…¶ä»–èŠ¯ç‰‡ï¼ˆå¦‚éº¦å…‹é£æˆ–éŸ³é¢‘ç¼–è§£ç å™¨ï¼‰è¿›è¡Œé€šä¿¡ã€‚

```yml
i2c:
  id: internal_i2c
  sda: GPIO5
  scl: GPIO6
  scan: true
  frequency: 100kHz
```

- **id**ï¼šåœ¨å…¶ä»–åœ°æ–¹å¼•ç”¨æ­¤æ€»çº¿çš„åç§°ã€‚
- **sda** / sclï¼šç”¨äºæ•°æ®å’Œæ—¶é’Ÿçš„å¼•è„šã€‚
- **scan**ï¼šåœ¨å¯åŠ¨æ—¶æ£€æŸ¥è¿æ¥çš„è®¾å¤‡ã€‚
- **frequency**ï¼šé€šä¿¡é€Ÿåº¦ï¼ˆ100kHz æ˜¯æ ‡å‡†é€Ÿåº¦ï¼‰ã€‚

### å¼€å…³

<details>
<summary>å¼€å…³</summary>

```yml
switch:
  # Mute Sound Switch.
  - platform: template
    id: mute_sound
    name: Mute/unmute sound
    icon: "mdi:bullhorn"
    entity_category: config
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
  # Wake Word Sound Switch.
  - platform: template
    id: wake_sound
    name: Wake sound
    icon: "mdi:bullhorn"
    entity_category: config
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
  # Internal switch to track when a timer is ringing on the device.
  - platform: template
    id: timer_ringing
    optimistic: true
    internal: true
    restore_mode: ALWAYS_OFF
    on_turn_off:
      # Disable stop wake word
      - micro_wake_word.disable_model: stop
      - script.execute: disable_repeat
      # Stop any current annoucement (ie: stop the timer ring mid playback)
      - if:
          condition:
            media_player.is_announcing:
          then:
            media_player.stop:
              announcement: true
      # Set back ducking ratio to zero
      - mixer_speaker.apply_ducking:
          id: media_mixing_input
          decibel_reduction: 0
          duration: 1.0s
      # Refresh the LED ring
      - script.execute: control_leds
    on_turn_on:
      # Duck audio
      - mixer_speaker.apply_ducking:
          id: media_mixing_input
          decibel_reduction: 20
          duration: 0.0s
      # Enable stop wake word
      - micro_wake_word.enable_model: stop
      # Ring timer
      - script.execute: ring_timer
      # Refresh LED
      - script.execute: control_leds
      # If 15 minutes have passed and the timer is still ringing, stop it.
      - delay: 15min
      - switch.turn_off: timer_ringing
  # Defines if alarm is active
  - platform: template
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    id: alarm_on
    icon: mdi:bell-badge
    name: "Alarm on"
    on_turn_on:
      - script.execute: control_leds
    on_turn_off:
      - script.execute: control_leds
```

</details>

å¼€å…³æ˜¯ Home Assistant ä¸­è½¯ä»¶æ§åˆ¶çš„"æŒ‰é’®"ã€‚å®ƒä»¬æ§åˆ¶å£°éŸ³ã€å®šæ—¶å™¨æˆ–é—¹é’Ÿç­‰åŠŸèƒ½ã€‚

**å”¤é†’è¯å£°éŸ³å¼€å…³**ï¼šæ§åˆ¶å”¤é†’è¯éŸ³é¢‘ã€‚

```yml
# Wake Word Sound Switch.
  - platform: template
    id: wake_sound
    name: Wake sound
    icon: "mdi:bullhorn"
    entity_category: config
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
```

**å®šæ—¶å™¨å“é“ƒå†…éƒ¨å¼€å…³**ï¼š

- è·Ÿè¸ªå®šæ—¶å™¨æ˜¯å¦å¤„äºæ´»åŠ¨çŠ¶æ€ã€‚
- on_turn_onï¼šå°†å…¶ä»–éŸ³é¢‘é™ä½ -20dBï¼Œå¯åŠ¨å®šæ—¶å™¨å£°éŸ³ï¼Œæ›´æ–° LEDï¼Œ15 åˆ†é’Ÿåè‡ªåŠ¨åœæ­¢ã€‚
- on_turn_offï¼šåœæ­¢å®šæ—¶å™¨ï¼Œæ¢å¤éŸ³é‡ï¼Œæ›´æ–° LEDã€‚

```yml
# Internal switch to track when a timer is ringing on the device.
  - platform: template
    id: timer_ringing
    optimistic: true
    internal: true
    restore_mode: ALWAYS_OFF
    ...
    ...
```

**é—¹é’Ÿå¼€å¯å¼€å…³**ï¼š

```yml
# Defines if alarm is active
  - platform: template
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    id: alarm_on
    ...
    ...
```

- è·Ÿè¸ªé—¹é’ŸçŠ¶æ€ã€‚
- åœ¨å¼€å¯/å…³é—­æ—¶è¿è¡Œ LED è„šæœ¬ã€‚

### ä¼ æ„Ÿå™¨

<details>
<summary>ä¼ æ„Ÿå™¨</summary>

```yml
number:
  - platform: template
    id: led_ring_brightness
    name: "LED Ring Brightness"
    icon: mdi:brightness-6
    entity_category: config
    optimistic: true
    restore_value: true
    min_value: 0.4
    max_value: 1.0
    step: 0.05
    initial_value: 0.8
    mode: slider

sensor:
  - platform: template
    id: next_timer
    name: "Next timer"
    update_interval: never
    disabled_by_default: true
    device_class: duration
    unit_of_measurement: s
    icon: "mdi:timer"
    accuracy_decimals: 0

text_sensor:
  - platform: template
    id: next_timer_name
    name: "Next timer name"
    icon: "mdi:timer"
    disabled_by_default: true
  - platform: template
    name: "Alarm time"
    id: alarm_time
    icon: mdi:bell-ring
  - platform: template
    name: "Current device time"
    id: current_time
    icon: mdi:clock
```

</details>

æ­¤ YAML å—ä¸ºå®šæ—¶å™¨ã€é—¹é’Ÿå’Œ LED äº®åº¦æ·»åŠ æ§åˆ¶å’Œä¼ æ„Ÿå™¨ã€‚å®ƒè®©æ‚¨å¯ä»¥ä½¿ç”¨æ»‘å—è°ƒæ•´ LED ç¯äº®åº¦ï¼Œè·Ÿè¸ªä¸‹ä¸€ä¸ªå®šæ—¶å™¨ï¼ˆæ—¶é—´ + åç§°ï¼‰ï¼Œå¹¶åœ¨ Home Assistant ä¸­æ˜¾ç¤ºé—¹é’Ÿæ—¶é—´å’Œè®¾å¤‡çš„å½“å‰æ—¶é—´ã€‚

**LED ç¯äº®åº¦**ï¼š

```yml
number:
  - platform: template
    id: led_ring_brightness
    name: "LED Ring Brightness"
    icon: mdi:brightness-6
    ...
```

- è®©ç”¨æˆ·ä½¿ç”¨æ»‘å—è°ƒæ•´äº®åº¦ã€‚
- min_value / max_value å®šä¹‰é™åˆ¶ã€‚
- restore_value åœ¨é‡å¯åä¿æŒä¹‹å‰çš„è®¾ç½®ã€‚

**ä¸‹ä¸€ä¸ªå®šæ—¶å™¨**

```yml
sensor:
  - platform: template
    id: next_timer
    name: "Next timer"
    update_interval: never
    ...
```

- æ˜¾ç¤ºä¸‹ä¸€ä¸ªå®šæ—¶å™¨çš„å‰©ä½™æ—¶é—´ã€‚
- ä»…åœ¨å®šæ—¶å™¨æ›´æ”¹æ—¶æ›´æ–°ï¼ˆèŠ‚çœèµ„æºï¼‰ã€‚

**é—¹é’Ÿæ—¶é—´å’Œè®¾å¤‡æ—¶é—´**

```yml
text_sensor:
  - platform: template
    id: next_timer_name
    name: "Next timer name"
    icon: "mdi:timer"
    ...
```

- æ˜¾ç¤ºå½“å‰é—¹é’Ÿå’Œ ESP32 ç³»ç»Ÿæ—¶é—´ã€‚

### é—´éš” LED æ•ˆæœ

```yml
interval:
  - interval: 50ms
    id: led_animation_interval
    then:
      - lambda: |-
          if (id(volume_display_active)) {
            id(update_volume_display_effect).execute();
            return;
          }
          std::string effect = id(current_led_effect);
          if (effect == "off") {
            return;
          } else if (effect == "breathe") {
            id(update_breathe_effect).execute();
          } else if (effect == "rainbow") {
            id(update_rainbow_effect).execute();
          } else if (effect == "comet_cw") {
            id(update_comet_cw_effect).execute();
          } else if (effect == "comet_ccw") {
            id(update_comet_ccw_effect).execute();
          } else if (effect == "twinkle") {
            id(update_twinkle_effect).execute();
          } else if (effect == "timer_tick") {
            id(update_timer_tick_effect).execute();
          } else if (effect == "led_beam") {
            id(update_led_beam_effect).execute();
          }
```

- é—´éš”åœ¨åå°é‡å¤è¿è¡Œä»£ç ã€‚
- 50msï¼šæ¯ç§’è¿è¡Œä»£ç  20 æ¬¡ã€‚
- æ ¹æ®ç³»ç»ŸçŠ¶æ€æˆ–é€‰å®šæ•ˆæœæ§åˆ¶ LED åŠ¨ç”»ã€‚

### LED æ§åˆ¶

<details>
<summary>LED æ§åˆ¶</summary>

```yml
 script:
  # =========================================================================
  # == Centralized script to control all LED effects ==
  # =========================================================================
  - id: led_set_effect
    mode: restart
    parameters:
      effect: std::string
      r: float
      g: float
      b: float
      speed: float
    then:
      - lambda: |-
          // Update global variables with the new parameters
          id(led_ring_color_r) = r;
          id(led_ring_color_g) = g;
          id(led_ring_color_b) = b;
          id(led_ring_speed) = speed;
          id(current_led_effect) = effect;

          // Handle the two types of effects: Off and Animated
          if (effect == "off") {
            uint32_t colors[12] = {0};
            id(respeaker).set_led_ring(colors);
          } else {
            id(last_led_update_time) = millis(); // Reset timer for smooth animation start
          }

  # Individual update scripts for each animated effect
  - id: update_breathe_effect
    then:
      - lambda: |-
          static float phase = 0.0f;
          uint32_t now = millis();
          float dt = (now - id(last_led_update_time)) / 1000.0f;
          id(last_led_update_time) = now;

          phase += dt * id(led_ring_speed);
          while (phase >= 1.0f) phase -= 1.0f;

          float master_brightness = id(led_ring_brightness).state;
          float breath_brightness = 0.5f * (1.0f + sinf(phase * 2.0f * M_PI)) * master_brightness;

          uint8_t r = (uint8_t)(id(led_ring_color_r) * 255.0f * breath_brightness);
          uint8_t g = (uint8_t)(id(led_ring_color_g) * 255.0f * breath_brightness);
          uint8_t b = (uint8_t)(id(led_ring_color_b) * 255.0f * breath_brightness);
          uint32_t current_color = (r << 16) | (g << 8) | b;

          uint32_t colors[12];
          for (int i = 0; i < 12; i++) colors[i] = current_color;
          id(respeaker).set_led_ring(colors);

  - id: update_rainbow_effect
    then:
      - lambda: |-
          static float hue_offset = 0.0f;
          uint32_t now = millis();
          float dt = (now - id(last_led_update_time)) / 1000.0f;
          id(last_led_update_time) = now;

          hue_offset += dt * id(led_ring_speed);
          if (hue_offset >= 1.0f) hue_offset -= 1.0f;

          constexpr int NUM_LEDS = 12;
          constexpr float HUE_STEP = 1.0f / NUM_LEDS;
          uint32_t colors[NUM_LEDS];
          float brightness = id(led_ring_brightness).state;

          float current_hue = hue_offset;
          for (int i = 0; i < NUM_LEDS; i++) {
            float r, g, b;
            if (current_hue >= 1.0f) current_hue -= 1.0f;
            hsv_to_rgb((int)(current_hue * 360.0f), 1.0f, brightness, r, g, b);
            colors[i] = ((uint8_t)(r * 255.0f) << 16) | ((uint8_t)(g * 255.0f) << 8) | ((uint8_t)(b * 255.0f));
            current_hue += HUE_STEP;
          }
          id(respeaker).set_led_ring(colors);

  - id: update_comet_cw_effect
    then:
      - lambda: |-
          static float comet_pos = 0.0f;
          uint32_t now = millis();
          float dt = (now - id(last_led_update_time)) / 1000.0f;
          id(last_led_update_time) = now;

          constexpr int NUM_LEDS = 12;
          constexpr int BASE_TAIL = 3;

          float leds_per_sec = id(led_ring_speed) * NUM_LEDS;
          comet_pos += dt * leds_per_sec;
          while (comet_pos >= NUM_LEDS) comet_pos -= NUM_LEDS;

          int head_index = (int)comet_pos;
          int tail_length = BASE_TAIL + (int)(id(led_ring_speed));
          if (tail_length > NUM_LEDS - 1) tail_length = NUM_LEDS - 1;

          uint32_t colors[NUM_LEDS] = {0};
          float brightness = id(led_ring_brightness).state;

          uint8_t head_r = (uint8_t)(id(led_ring_color_r) * 255.0f * brightness);
          uint8_t head_g = (uint8_t)(id(led_ring_color_g) * 255.0f * brightness);
          uint8_t head_b = (uint8_t)(id(led_ring_color_b) * 255.0f * brightness);

          colors[head_index % NUM_LEDS] = (head_r << 16) | (head_g << 8) | head_b;

          for (int i = 1; i <= tail_length; i++) {
            float tail_factor = (float)i / (tail_length + 1);
            float tail_brightness = (1.0f - tail_factor) * brightness;
            uint8_t r = (uint8_t)(id(led_ring_color_r) * 255.0f * tail_brightness);
            uint8_t g = (uint8_t)(id(led_ring_color_g) * 255.0f * tail_brightness);
            uint8_t b = (uint8_t)(id(led_ring_color_b) * 255.0f * tail_brightness);
            int tail_index = (head_index - i + NUM_LEDS) % NUM_LEDS;
            colors[tail_index] = (r << 16) | (g << 8) | b;
          }
          id(respeaker).set_led_ring(colors);

  - id: update_comet_ccw_effect
    then:
      - lambda: |-
          static float comet_pos = 0.0f;
          uint32_t now = millis();
          float dt = (now - id(last_led_update_time)) / 1000.0f;
          id(last_led_update_time) = now;

          constexpr int NUM_LEDS = 12;
          constexpr int BASE_TAIL = 3;

          float leds_per_sec = id(led_ring_speed) * NUM_LEDS;
          comet_pos -= dt * leds_per_sec;
          while (comet_pos < 0.0f) comet_pos += NUM_LEDS;

          int head_index = (int)comet_pos;
          int tail_length = BASE_TAIL + (int)(id(led_ring_speed));
          if (tail_length > NUM_LEDS - 1) tail_length = NUM_LEDS - 1;

          uint32_t colors[NUM_LEDS] = {0};
          float brightness = id(led_ring_brightness).state;

          uint8_t head_r = (uint8_t)(id(led_ring_color_r) * 255.0f * brightness);
          uint8_t head_g = (uint8_t)(id(led_ring_color_g) * 255.0f * brightness);
          uint8_t head_b = (uint8_t)(id(led_ring_color_b) * 255.0f * brightness);

          colors[head_index % NUM_LEDS] = (head_r << 16) | (head_g << 8) | head_b;

          for (int i = 1; i <= tail_length; i++) {
            float tail_factor = (float)i / (tail_length + 1);
            float tail_brightness = (1.0f - tail_factor) * brightness;
            uint8_t r = (uint8_t)(id(led_ring_color_r) * 255.0f * tail_brightness);
            uint8_t g = (uint8_t)(id(led_ring_color_g) * 255.0f * tail_brightness);
            uint8_t b = (uint8_t)(id(led_ring_color_b) * 255.0f * tail_brightness);
            int tail_index = (head_index + i) % NUM_LEDS;
            colors[tail_index] = (r << 16) | (g << 8) | b;
          }
          id(respeaker).set_led_ring(colors);

  - id: update_twinkle_effect
    then:
      - lambda: |-
          constexpr int NUM_LEDS = 12;
          static float led_brightness[NUM_LEDS] = {0.0f};
          static float led_fade_speed[NUM_LEDS] = {0.0f};

          uint32_t now = millis();
          float dt = (now - id(last_led_update_time)) / 1000.0f;
          id(last_led_update_time) = now;

          // Update existing twinkles
          for (int i = 0; i < NUM_LEDS; i++) {
            if (led_fade_speed[i] != 0.0f) {
              led_brightness[i] += led_fade_speed[i] * dt;
              if (led_fade_speed[i] > 0.0f && led_brightness[i] >= 1.0f) {
                led_brightness[i] = 1.0f;
                led_fade_speed[i] *= -1.0f;
              } else if (led_fade_speed[i] < 0.0f && led_brightness[i] <= 0.0f) {
                led_brightness[i] = 0.0f;
                led_fade_speed[i] = 0.0f;
              }
            }
          }

          // Start new twinkles
          float twinkle_chance = dt * id(led_ring_speed);
          if (random_float() < twinkle_chance) {
            int led_to_start = (int)(random_float() * NUM_LEDS);
            if (led_fade_speed[led_to_start] == 0.0f) {
              led_brightness[led_to_start] = 0.0f;
              float min_speed = 1.5f, max_speed = 3.0f;
              led_fade_speed[led_to_start] = min_speed + (random_float() * (max_speed - min_speed));
            }
          }

          // Render colors
          uint32_t colors[NUM_LEDS];
          float master_brightness = id(led_ring_brightness).state;
          uint8_t base_r = (uint8_t)(id(led_ring_color_r) * 255.0f);
          uint8_t base_g = (uint8_t)(id(led_ring_color_g) * 255.0f);
          uint8_t base_b = (uint8_t)(id(led_ring_color_b) * 255.0f);

          for (int i = 0; i < NUM_LEDS; i++) {
            float current_led_brightness = led_brightness[i] * master_brightness;
            uint8_t r = (uint8_t)(base_r * current_led_brightness);
            uint8_t g = (uint8_t)(base_g * current_led_brightness);
            uint8_t b = (uint8_t)(base_b * current_led_brightness);
            colors[i] = (r << 16) | (g << 8) | b;
          }
          id(respeaker).set_led_ring(colors);

  - id: update_timer_tick_effect
    then:
      - lambda: |-
          constexpr int NUM_LEDS = 12;
          static int tick_index = 0;

          uint32_t now = millis();
          // Only update tick position every 100ms to reduce I2C traffic
          static uint32_t last_tick_update = 0;
          if (now - last_tick_update >= 100) {
            tick_index = (tick_index - 1 + NUM_LEDS) % NUM_LEDS;
            last_tick_update = now;
          }

          uint32_t colors[NUM_LEDS] = {0};
          uint32_t seconds_left = id(first_active_timer).seconds_left;
          uint32_t total_seconds = id(first_active_timer).total_seconds;

          float timer_ratio = (float)NUM_LEDS * seconds_left / std::max(total_seconds, (uint32_t)1);

          float master_brightness = id(led_ring_brightness).state;
          uint8_t base_r = (uint8_t)(id(led_ring_color_r) * 255.0f);
          uint8_t base_g = (uint8_t)(id(led_ring_color_g) * 255.0f);
          uint8_t base_b = (uint8_t)(id(led_ring_color_b) * 255.0f);

          for (int i = 0; i < NUM_LEDS; i++) {
            float bar_brightness = clamp(timer_ratio - i, 0.0f, 1.0f);
            if (bar_brightness > 0.0f) {
              float tick_dip = (i == tick_index) ? 0.9f : 1.0f;
              float final_brightness = bar_brightness * tick_dip * master_brightness;
              uint8_t r = (uint8_t)(base_r * final_brightness);
              uint8_t g = (uint8_t)(base_g * final_brightness);
              uint8_t b = (uint8_t)(base_b * final_brightness);
              colors[i] = (r << 16) | (g << 8) | b;
            }
          }
          id(respeaker).set_led_ring(colors);

  - id: update_volume_display_effect
    then:
      - lambda: |-
          constexpr int NUM_LEDS = 12;
          uint32_t colors[NUM_LEDS] = {0};

          if (id(external_media_player).is_ready()) {
            bool is_muted = id(external_media_player).is_muted();
            float volume = id(external_media_player).volume;

            if (is_muted || volume == 0.0f) {
              uint32_t mute_color = (255 << 16); // Red
              colors[0] = mute_color;
              colors[6] = mute_color;
            } else {
              float num_leds_on = volume * NUM_LEDS;
              float master_brightness = id(led_ring_brightness).state;
              uint8_t base_r = (uint8_t)(id(led_ring_color_r) * 255.0f);
              uint8_t base_g = (uint8_t)(id(led_ring_color_g) * 255.0f);
              uint8_t base_b = (uint8_t)(id(led_ring_color_b) * 255.0f);

              for (int i = 0; i < NUM_LEDS; i++) {
                float brightness = clamp(num_leds_on - i, 0.0f, 1.0f);
                if (brightness > 0.0f) {
                  uint8_t r = (uint8_t)(base_r * brightness * master_brightness);
                  uint8_t g = (uint8_t)(base_g * brightness * master_brightness);
                  uint8_t b = (uint8_t)(base_b * brightness * master_brightness);
                  colors[i] = (r << 16) | (g << 8) | b;
                }
              }
            }
          }
          id(respeaker).set_led_ring(colors);

  - id: update_led_beam_effect
    then:
      - lambda: |-
          constexpr int NUM_LEDS = 12;
          constexpr int FADE_LEDS = 3;
          constexpr float TRANSITION_DURATION = 0.5f; // Duration of the smooth transition
          uint32_t colors[NUM_LEDS] = {0};

          uint32_t now = millis();
          float dt = (now - id(last_led_update_time)) / 1000.0f;
          id(last_led_update_time) = now;

          if (id(beam_direction).has_state()) {
            // CORRECTING THE OFFSET: add 5 from the sensor reading
            float target_pos = ((int)id(beam_direction).state + 5) % NUM_LEDS;
            float current_pos = id(animated_beam_position);

            // Calculate the shortest path around the circle
            float diff = target_pos - current_pos;
            if (diff > NUM_LEDS / 2.0f) {
              diff -= NUM_LEDS;
            } else if (diff < -NUM_LEDS / 2.0f) {
              diff += NUM_LEDS;
            }

            // Move current position towards target
            if (abs(diff) > 0.01f) {
              float move_speed = diff / TRANSITION_DURATION;
              current_pos += move_speed * dt;
            } else {
              current_pos = target_pos;
            }

            // Handle wrap-around for the animated position
            if (current_pos >= NUM_LEDS) current_pos -= NUM_LEDS;
            if (current_pos < 0.0f) current_pos += NUM_LEDS;

            id(animated_beam_position) = current_pos;

            // Render the smoothed beam
            float master_brightness = id(led_ring_brightness).state;
            uint8_t base_r = (uint8_t)(id(led_ring_color_r) * 255.0f);
            uint8_t base_g = (uint8_t)(id(led_ring_color_g) * 255.0f);
            uint8_t base_b = (uint8_t)(id(led_ring_color_b) * 255.0f);

            for (int i = 0; i < NUM_LEDS; i++) {
              // Calculate circular distance from current LED to the animated position
              float dist = abs(i - current_pos);
              if (dist > NUM_LEDS / 2.0f) {
                dist = NUM_LEDS - dist;
              }

              // Calculate brightness based on distance (linear falloff)
              float brightness_factor = 1.0f - (dist / (FADE_LEDS + 1.0f));
              brightness_factor = std::max(0.0f, brightness_factor);

              if (brightness_factor > 0.0f) {
                float final_brightness = brightness_factor * master_brightness;
                uint8_t r = (uint8_t)(base_r * final_brightness);
                uint8_t g = (uint8_t)(base_g * final_brightness);
                uint8_t b = (uint8_t)(base_b * final_brightness);
                colors[i] = (r << 16) | (g << 8) | b;
              }
            }
          }
          id(respeaker).set_led_ring(colors);

  # Master script controlling the LEDs, based on different conditions : initialization in progress, wifi and api connected and voice assistant phase.
  # For the sake of simplicity and re-usability, the script calls child scripts defined below.
  # This script will be called every time one of these conditions is changing.
  - id: control_leds
    mode: single  # Prevent multiple simultaneous executions
    then:
      - lambda: |
          // Cache expensive component checks
          static bool last_respeaker_failed = false;
          static bool last_wifi_connected = false;
          static bool last_api_connected = false;
          static int last_voice_phase = -1;
          static bool last_timer_ringing = false;
          static bool last_timer_active = false;
          static bool last_improv_ble = false;
          static bool last_init_progress = false;

          bool respeaker_failed = id(respeaker).is_failed();
          bool wifi_connected = id(wifi_id).is_connected();
          bool api_connected = id(api_id).is_connected();
          int voice_phase = id(voice_assistant_phase);
          bool new_timer_ringing = id(timer_ringing).state;
          bool improv_ble = id(improv_ble_in_progress);
          bool init_progress = id(init_in_progress);

          // Only update if something actually changed
          bool needs_update = (
            respeaker_failed != last_respeaker_failed ||
            wifi_connected != last_wifi_connected ||
            api_connected != last_api_connected ||
            voice_phase != last_voice_phase ||
            new_timer_ringing != last_timer_ringing ||
            improv_ble != last_improv_ble ||
            init_progress != last_init_progress
          );

          if (!needs_update) return;

          // Update cache
          last_respeaker_failed = respeaker_failed;
          last_wifi_connected = wifi_connected;
          last_api_connected = api_connected;
          last_voice_phase = voice_phase;
          last_timer_ringing = new_timer_ringing;
          last_improv_ble = improv_ble;
          last_init_progress = init_progress;

          if (respeaker_failed) {
            id(control_leds_respeaker_startup_failed).execute();
            return;
          }

          // Only check timers if we need to
          id(check_if_timers_active).execute();
          if (id(is_timer_active)){
            id(fetch_first_active_timer).execute();
          }

          // Continue with existing logic...
          if (improv_ble) {
            id(control_leds_improv_ble_state).execute();
          } else if (init_progress) {
            id(control_leds_init_state).execute();
          } else if (!wifi_connected || !api_connected){
            id(control_leds_no_ha_connection_state).execute();
          } else if (new_timer_ringing) {
            id(control_leds_timer_ringing).execute();
          } else if (voice_phase == ${voice_assist_waiting_for_command_phase_id}) {
            id(control_leds_voice_assistant_waiting_for_command_phase).execute();
          } else if (voice_phase == ${voice_assist_listening_for_command_phase_id}) {
            id(control_leds_voice_assistant_listening_for_command_phase).execute();
          } else if (voice_phase == ${voice_assist_thinking_phase_id}) {
            id(control_leds_voice_assistant_thinking_phase).execute();
          } else if (voice_phase == ${voice_assist_replying_phase_id}) {
            id(control_leds_voice_assistant_replying_phase).execute();
          } else if (voice_phase == ${voice_assist_error_phase_id}) {
            id(control_leds_voice_assistant_error_phase).execute();
          } else if (voice_phase == ${voice_assist_not_ready_phase_id}) {
            id(control_leds_voice_assistant_not_ready_phase).execute();
          } else if (id(is_timer_active)) {
            id(control_leds_timer_ticking).execute();
          } else if (voice_phase == ${voice_assist_idle_phase_id}) {
            id(control_leds_voice_assistant_idle_phase).execute();
          }

  # Script executed if respeaker startup failed
  - id: control_leds_respeaker_startup_failed
    then:
      - script.execute:
          id: led_set_effect
          effect: "breathe"
          r: 0.7
          g: 0.0
          b: 0.0
          speed: 0.5

  # Script executed during Improv BLE
  - id: control_leds_improv_ble_state
    then:
      - script.execute:
          id: led_set_effect
          effect: "twinkle"
          r: 1.0
          g: 0.89
          b: 0.71
          speed: 10.0

  # Script executed during initialization
  - id: control_leds_init_state
    then:
      - if:
          condition:
            wifi.connected:
          then:
            - script.execute:
                id: led_set_effect
                effect: "twinkle"
                r: 0.09
                g: 0.73
                b: 0.95
                speed: 20.0
          else:
            - script.execute:
                id: led_set_effect
                effect: "twinkle"
                r: 0.09
                g: 0.73
                b: 0.95
                speed: 4.0

  # Script executed when the device has no connection to Home Assistant
  - id: control_leds_no_ha_connection_state
    then:
      - script.execute:
          id: led_set_effect
          effect: "twinkle"
          r: 1.0
          g: 0.0
          b: 0.0
          speed: 10.0

  # Script executed when the voice assistant is waiting for a command (After the wake word)
  - id: control_leds_voice_assistant_waiting_for_command_phase
    then:
      - lambda: |
          id(animated_beam_position) = id(beam_direction).state;
      - script.execute:
          id: led_set_effect
          effect: "led_beam"
          r: 0.5
          g: 0.0
          b: 0.5
          speed: 0.0

  # Script executed when the voice assistant is listening to a command
  - id: control_leds_voice_assistant_listening_for_command_phase
    then:
      - script.execute:
          id: led_set_effect
          effect: "led_beam"
          r: 0.8
          g: 0.0
          b: 0.8
          speed: 0.0

  # Script executed when the voice assistant is thinking to a command
  - id: control_leds_voice_assistant_thinking_phase
    then:
      - script.execute:
          id: led_set_effect
          effect: "breathe"
          r: 0.6
          g: 0.0
          b: 0.6
          speed: 1.0

  # Script executed when the voice assistant is replying to a command
  - id: control_leds_voice_assistant_replying_phase
    then:
      - script.execute:
          id: led_set_effect
          effect: "comet_ccw"
          r: 0.6
          g: 0.0
          b: 0.6
          speed: 1.0

  # Script executed when the voice assistant is in error
  - id: control_leds_voice_assistant_error_phase
    then:
      - script.execute:
          id: led_set_effect
          effect: "breathe"
          r: 1.0
          g: 0.0
          b: 0.0
          speed: 3.0

  # Script executed when the voice assistant is not ready
  - id: control_leds_voice_assistant_not_ready_phase
    then:
      - script.execute:
          id: led_set_effect
          effect: "twinkle"
          r: 1.0
          g: 0.0
          b: 0.0
          speed: 5.0

  # Script executed when the volume is changed
  - id: control_leds_volume_changed
    mode: restart
    then:
      - lambda: |-
          id(volume_display_active) = true;
      - delay: 2s
      - lambda: |-
          id(volume_display_active) = false;

  # Script executed when the timer is ringing, to control the LEDs
  - id: control_leds_timer_ringing
    then:
      - script.execute:
          id: led_set_effect
          effect: "breathe"
          r: 0.6
          g: 0.0
          b: 0.6
          speed: 5.0

  # Script executed when the timer is ticking, to control the LEDs
  - id: control_leds_timer_ticking
    then:
      - script.execute:
          id: led_set_effect
          effect: "timer_tick"
          r: 0.6
          g: 0.0
          b: 0.6
          speed: 1.0

  # Script executed when the voice assistant is idle (waiting for a wake word)
  - id: control_leds_voice_assistant_idle_phase
    then:
      - script.execute:
          id: led_set_effect
          effect: "off"
          r: 0.0
          g: 0.0
          b: 0.0
          speed: 0.0

  # Script executed when the timer is ringing, to playback sounds.
  - id: ring_timer
    then:
      - script.execute: enable_repeat_one
      - script.execute:
          id: play_sound
          priority: true
          sound_file: !lambda return id(timer_finished_sound);

  # Script executed when the timer is ringing, to repeat the timer finished sound.
  - id: enable_repeat_one
    then:
      # Turn on the repeat mode and pause for 500 ms between playlist items/repeats
      - lambda: |-
            id(external_media_player)
              ->make_call()
              .set_command(media_player::MediaPlayerCommand::MEDIA_PLAYER_COMMAND_REPEAT_ONE)
              .set_announcement(true)
              .perform();
            id(external_media_player)->set_playlist_delay_ms(speaker::AudioPipelineType::ANNOUNCEMENT, 500);

  # Script execute when the timer is done ringing, to disable repeat mode.
  - id: disable_repeat
    then:
      # Turn off the repeat mode and pause for 0 ms between playlist items/repeats
      - lambda: |-
            id(external_media_player)
              ->make_call()
              .set_command(media_player::MediaPlayerCommand::MEDIA_PLAYER_COMMAND_REPEAT_OFF)
              .set_announcement(true)
              .perform();
            id(external_media_player)->set_playlist_delay_ms(speaker::AudioPipelineType::ANNOUNCEMENT, 0);

  # Script executed when we want to play sounds on the device.
  - id: play_sound
    parameters:
      priority: bool
      sound_file: "audio::AudioFile*"
    then:
      - lambda: |-
          if (priority) {
            id(external_media_player)
              ->make_call()
              .set_command(media_player::MediaPlayerCommand::MEDIA_PLAYER_COMMAND_STOP)
              .set_announcement(true)
              .perform();
          }
          if ( (id(external_media_player).state != media_player::MediaPlayerState::MEDIA_PLAYER_STATE_ANNOUNCING ) || priority) {
            id(external_media_player)
              ->play_file(sound_file, true, false);
          }

  # Script used to fetch the first active timer (Stored in global first_active_timer)
  - id: fetch_first_active_timer
    mode: single
    then:
      - lambda: |
          static uint32_t last_fetch_time = 0;
          uint32_t now = millis();

          // Only fetch every 500ms to reduce overhead
          if (now - last_fetch_time < 500) return;
          last_fetch_time = now;

          const auto timers = id(va).get_timers();
          if (timers.empty()) return;

          auto output_timer = timers.begin()->second;
          for (auto &iterable_timer : timers) {
            if (iterable_timer.second.is_active && 
                iterable_timer.second.seconds_left <= output_timer.seconds_left) {
              output_timer = iterable_timer.second;
            }
          }
          id(first_active_timer) = output_timer;

  # Script used to check if a timer is active (Stored in global is_timer_active)
  - id: check_if_timers_active
    then:
      - lambda: |
          const auto timers = id(va).get_timers();
          bool output = false;
          if (timers.size() > 0) {
            for (auto &iterable_timer : timers) {
              if(iterable_timer.second.is_active) {
                output = true;
              }
            }
          }
          id(is_timer_active) = output;

  # Script used activate the stop word if the TTS step is long.
  # Why is this wrapped on a script?
  #   Becasue we want to stop the sequence if the TTS step is faster than that.
  #   This allows us to prevent having the deactivation of the stop word before its own activation.
  - id: activate_stop_word_once
    then:
      - delay: 1s
      # Enable stop wake word
      - if:
          condition:
            switch.is_off: timer_ringing
          then:
            - micro_wake_word.enable_model: stop
            - wait_until:
                not:
                  media_player.is_announcing:
            - if:
                condition:
                  switch.is_off: timer_ringing
                then:
                  - micro_wake_word.disable_model: stop

  - id: check_alarm
    then:
      - lambda: |-
          id(publish_current_time).execute();
          // Check alarm
          if (id(alarm_on).state && id(alarm_time).has_state()) {
            // Get the stored alarm time from the sensor
            auto set_alarm_time = id(alarm_time).state;
            if (set_alarm_time.length() == 5 &&
              isdigit(set_alarm_time[0]) && isdigit(set_alarm_time[1]) &&
              isdigit(set_alarm_time[3]) && isdigit(set_alarm_time[4])) {
              auto alarm_hour = std::stoi(set_alarm_time.substr(0, 2));
              auto alarm_minute = std::stoi(set_alarm_time.substr(3, 2));

              // Trigger action if current time matches alarm time
              auto time_now = id(homeassistant_time).now();
              if (time_now.hour == alarm_hour && time_now.minute == alarm_minute) {
                auto action = id(alarm_action).state;
                if (action == "Play sound") {
                  id(timer_ringing).turn_on();
                } else if (action == "Send event") {
                  id(send_alarm_event).execute();
                } else if (action == "Sound and event") {
                  id(timer_ringing).turn_on();
                  id(send_alarm_event).execute();
                } 
              }
            } else {
              ESP_LOGW("alarm", "Incorrect alarm time setting");
            }
          }
  - id: send_alarm_event
    then:
      - homeassistant.event:
          event: esphome.alarm_ringing
  - id: send_tts_uri_event
    parameters:
      tts_uri: string
    then:
      - homeassistant.event:
          event: esphome.tts_uri
          data:
            uri: !lambda return tts_uri;
  - id: send_stt_text_event
    parameters:
      stt_text: string
    then:
      - homeassistant.event:
          event: esphome.stt_text
          data:
            text: !lambda return stt_text;
  - id: publish_current_time
    mode: single
    then:
      - lambda: |-
          static std::string last_time_string = "";
          auto time_now = id(homeassistant_time).now();
          std::string current_time_string = time_now.strftime("%H:%M");

          // Only publish if time actually changed
          if (current_time_string != last_time_string) {
            id(current_time).publish_state(current_time_string);
            last_time_string = current_time_string;
          }
```

</details>

**ä¸­å¤®æ§åˆ¶å™¨ (led_set_effect)**

```yml
script:
  # =========================================================================
  # == Centralized script to control all LED effects ==
  # =========================================================================
  - id: led_set_effect
    mode: restart
    parameters:
      effect: std::string
      r: float
      g: float
      b: float
      speed: float
      ....
```

- åœ¨ä¸€ä¸ªåœ°æ–¹ç®¡ç†æ‰€æœ‰ LED æ•ˆæœã€‚
- å¯ä»¥åŠ¨æ€è®¾ç½®æ•ˆæœç±»å‹ã€é¢œè‰²ï¼ˆR/G/Bï¼‰å’Œé€Ÿåº¦ã€‚
- ä½¿ç”¨æ›´æ–°è„šæœ¬å®ç°å¹³æ»‘è¿åŠ¨ã€‚
- å…³é—­æ•ˆæœä¼šç«‹å³å…³é—­ LEDã€‚

**ç‹¬ç«‹è„šæœ¬**

- æ¯ä¸ªåŠ¨ç”»ï¼ˆå‘¼å¸ã€å½©è™¹ã€å½—æ˜Ÿã€é—ªçƒã€è®¡æ—¶å™¨æ»´ç­”ã€éŸ³é‡æ˜¾ç¤ºã€LED å…‰æŸï¼‰éƒ½æœ‰è‡ªå·±çš„è„šæœ¬ã€‚
- ä½¿ç³»ç»Ÿæ¨¡å—åŒ–ä¸”æ˜“äºç»´æŠ¤ã€‚
- ç”± led_animation_interval å®šæœŸè§¦å‘æˆ–ç”±ä¸­å¤®æ§åˆ¶å™¨è§¦å‘ã€‚

| è®¾å¤‡çŠ¶æ€           | LED æ•ˆæœ             |
|------------------------|----------------------|
| å¯åŠ¨å¤±è´¥         | çº¢è‰²å‘¼å¸           |
| Improv BLE æ¨¡å¼        | æš–è‰²é—ªçƒ          |
| åˆå§‹åŒ–         | è“è‰²é—ªçƒ          |
| æ—  HA è¿æ¥       | çº¢è‰²é—ªçƒ           |
| è¯­éŸ³åŠ©æ‰‹ç­‰å¾…             | ç´«è‰²å…‰æŸ           |
| è¯­éŸ³åŠ©æ‰‹ç›‘å¬           | äº®ç´«è‰²å…‰æŸ    |
| è¯­éŸ³åŠ©æ‰‹æ€è€ƒ            | ç´«è‰²å‘¼å¸        |
| è¯­éŸ³åŠ©æ‰‹å›å¤            | ç´«è‰²å½—æ˜Ÿ          |
| è¯­éŸ³åŠ©æ‰‹é”™è¯¯               | çº¢è‰²å‘¼å¸           |
| è¯­éŸ³åŠ©æ‰‹ç©ºé—²                | LED å…³é—­              |
| è®¡æ—¶å™¨å“é“ƒ          | ç´«è‰²å¿«é€Ÿå‘¼å¸   |
| éŸ³é‡å˜åŒ–          | ä¸´æ—¶æ˜¾ç¤º     |

#### LED æ§åˆ¶å·¥ä½œåŸç†ï¼ˆæµç¨‹æ¦‚è¿°ï¼‰

1. **è§¦å‘æ•ˆæœ**

   - å½“æŸäº›äº‹ä»¶å‘ç”Ÿæ—¶ï¼ˆä¾‹å¦‚ï¼Œå¯åŠ¨å¤±è´¥ã€è¯­éŸ³åŠ©æ‰‹ç›‘å¬ã€è®¡æ—¶å™¨å“é“ƒï¼‰ï¼Œè„šæœ¬ä¼šè¿è¡Œã€‚
   - è¯¥è„šæœ¬è°ƒç”¨**ä¸­å¤® LED æ§åˆ¶å™¨**ï¼ˆ`led_set_effect`ï¼‰å¹¶å‘Šè¯‰å®ƒï¼š

     - **è¿è¡Œå“ªä¸ªæ•ˆæœ**ï¼ˆä¾‹å¦‚ï¼Œå‘¼å¸ã€å½©è™¹ã€å½—æ˜Ÿï¼‰
     - **ä»€ä¹ˆé¢œè‰²**ï¼ˆRã€Gã€B å€¼ï¼‰
     - **å¤šå¿«**ï¼ˆé€Ÿåº¦ï¼‰ã€‚

   å¦‚æœå¯åŠ¨å¤±è´¥ â†’ è°ƒç”¨`led_set_effect`ï¼Œæ•ˆæœ = *å‘¼å¸*ï¼Œé¢œè‰² = çº¢è‰²ã€‚

2. **ä¸­å¤®æ§åˆ¶å™¨ï¼ˆé—´éš”å¾ªç¯ï¼‰**

   - æ¯**50 æ¯«ç§’**ï¼ˆæ¯ç§’ 20 æ¬¡ï¼‰ï¼Œ`led_animation_interval`å¾ªç¯æ£€æŸ¥**å½“å‰æ•ˆæœ**æ˜¯ä»€ä¹ˆã€‚
   - æ ¹æ®è¯¥æ•ˆæœåç§°ï¼Œå®ƒ**å°†æ§åˆ¶è½¬å‘**åˆ°åŒ¹é…çš„æ›´æ–°è„šæœ¬ã€‚

     - å¦‚æœæ•ˆæœ = *å‘¼å¸* â†’ è¿è¡Œ`update_breathe_effect`ã€‚
     - å¦‚æœæ•ˆæœ = *å½©è™¹* â†’ è¿è¡Œ`update_rainbow_effect`ã€‚
     - å¯¹äºé—ªçƒã€å½—æ˜Ÿã€è®¡æ—¶å™¨æ»´ç­”ã€LED å…‰æŸç­‰ä¹Ÿæ˜¯å¦‚æ­¤ã€‚

è¿™ä¸ªå¾ªç¯å°±åƒä¸€ä¸ª**è°ƒåº¦å™¨**ï¼šå®ƒå†³å®š*ä¸‹ä¸€æ­¥è¿è¡Œå“ªä¸ªåŠ¨ç”»è„šæœ¬*ã€‚

```yml

interval:
  - interval: 50ms
    id: led_animation_interval
    then:
      - lambda: |-
          if (id(volume_display_active)) {
            id(update_volume_display_effect).execute();
            return;
          }
          std::string effect = id(current_led_effect);
          if (effect == "off") {
            return;
          } else if (effect == "breathe") {
            id(update_breathe_effect).execute();
          } else if (effect == "rainbow") {
            id(update_rainbow_effect).execute();
          } else if (effect == "comet_cw") {
            id(update_comet_cw_effect).execute();
          } else if (effect == "comet_ccw") {
            id(update_comet_ccw_effect).execute();
          } else if (effect == "twinkle") {
            id(update_twinkle_effect).execute();
          } else if (effect == "timer_tick") {
            id(update_timer_tick_effect).execute();
          } else if (effect == "led_beam") {
            id(update_led_beam_effect).execute();
          }

```

3. **æ•ˆæœæ›´æ–°è„šæœ¬**

   - æ¯ä¸ªæ•ˆæœéƒ½æœ‰è‡ªå·±çš„è„šæœ¬ï¼Œé€å¸§è®¡ç®— LED é¢œè‰²ã€‚
   - ç¤ºä¾‹ï¼š**å‘¼å¸æ•ˆæœ**

     - ä½¿ç”¨æ­£å¼¦æ³¢å¹³æ»‘åœ°ä¸Šä¸‹æ·¡åŒ–äº®åº¦ã€‚
     - å°†äº®åº¦ä¹˜ä»¥ LED ç¯çš„å…¨å±€è®¾ç½®ï¼ˆé€Ÿåº¦ã€äº®åº¦æ»‘å—ã€R/G/B é¢œè‰²ï¼‰ã€‚
     - ä¸ºæ‰€æœ‰ 12 ä¸ª LED æ„å»ºé¢œè‰²æ•°ç»„ã€‚
     - å°†é¢œè‰²å‘é€åˆ° Respeaker LED ç¯ã€‚

ç¤ºä¾‹ï¼š

```yml

 # Individual update scripts for each animated effect
  - id: update_breathe_effect
    then:
      - lambda: |-
          static float phase = 0.0f;
          uint32_t now = millis();
          float dt = (now - id(last_led_update_time)) / 1000.0f;
          id(last_led_update_time) = now;

          phase += dt * id(led_ring_speed);
          while (phase >= 1.0f) phase -= 1.0f;

          float master_brightness = id(led_ring_brightness).state;
          float breath_brightness = 0.5f * (1.0f + sinf(phase * 2.0f * M_PI)) * master_brightness;

          uint8_t r = (uint8_t)(id(led_ring_color_r) * 255.0f * breath_brightness);
          uint8_t g = (uint8_t)(id(led_ring_color_g) * 255.0f * breath_brightness);
          uint8_t b = (uint8_t)(id(led_ring_color_b) * 255.0f * breath_brightness);
          uint32_t current_color = (r << 16) | (g << 8) | b;

          uint32_t colors[12];
          for (int i = 0; i < 12; i++) colors[i] = current_color;
          id(respeaker).set_led_ring(colors);

```

è¿™ä½¿å¾—åŠ¨ç”»å¹³æ»‘ã€åŠ¨æ€ä¸”å¯å®šåˆ¶ã€‚

### éŸ³é¢‘é…ç½®

**IÂ²S è¾“å…¥/è¾“å‡º**

IÂ²Sï¼ˆInter-IC Soundï¼‰æ˜¯ä¸€ç§æ•°å­—è¿æ¥ï¼Œè®© ESP32 èƒ½å¤Ÿå‘ç¼–è§£ç å™¨ã€éº¦å…‹é£å’Œæ‰¬å£°å™¨ç­‰èŠ¯ç‰‡å‘é€å’Œæ¥æ”¶é«˜è´¨é‡éŸ³é¢‘ã€‚

```yml
i2s_audio:
  - id: i2s_output
    i2s_lrclk_pin: 
      number: GPIO7
      allow_other_uses: true
    i2s_bclk_pin:  
      number: GPIO8
      allow_other_uses: true
    # i2s_mclk_pin:  
    #   number: GPIO9
    #   allow_other_uses: true

  - id: i2s_input
    i2s_lrclk_pin:  
      number: GPIO7
      allow_other_uses: true
    i2s_bclk_pin:  
      number: GPIO8
      allow_other_uses: true
    # i2s_mclk_pin:  
    #   number: GPIO9
    #   allow_other_uses: true

```

**éº¦å…‹é£**

- ä» IÂ²S éº¦å…‹é£é˜µåˆ—/ç¼–è§£ç å™¨æ•è·éŸ³é¢‘ã€‚
- GPIO43ï¼šéº¦å…‹é£éŸ³é¢‘æ•°æ®è¿›å…¥çš„å¼•è„šã€‚
- é‡‡æ ·ç‡ 48 kHzï¼Œ32 ä½ï¼šé«˜è´¨é‡å½•éŸ³ï¼ˆç«‹ä½“å£°ï¼Œ2 é€šé“ï¼‰ã€‚
- adc_type: externalï¼šä½¿ç”¨å¤–éƒ¨ç¼–è§£ç å™¨ï¼ˆä¸æ˜¯ ESP32 çš„å†…ç½® ADCï¼‰ã€‚
- i2s_mode: secondaryï¼šESP32 è·Ÿéšç¼–è§£ç å™¨çš„æ—¶é’Ÿï¼ˆä»æ¨¡å¼ï¼‰ã€‚

```yml
microphone:
  - platform: i2s_audio
    id: i2s_mics
    i2s_din_pin: GPIO43
    adc_type: external
    pdm: false
    sample_rate: 48000
    bits_per_sample: 32bit
    i2s_mode: secondary
    i2s_audio_id: i2s_input
    channel: stereo
```

**æ‰¬å£°å™¨**

- é€šè¿‡ç¼–è§£ç å™¨ï¼ˆAIC3104 DACï¼‰å‘æ‰¬å£°å™¨å‘é€éŸ³é¢‘ã€‚
- GPIO44ï¼šæ•°å­—éŸ³é¢‘è¾“å‡ºçš„å¼•è„šã€‚
- 48 kHzï¼Œ32 ä½ç«‹ä½“å£°ï¼šé«˜è´¨é‡æ’­æ”¾ã€‚
- buffer_duration 100msï¼šä¿æŒéŸ³é¢‘å¹³æ»‘ï¼ˆé˜²æ­¢æ•…éšœï¼‰ã€‚
- timeout: neverï¼šä¿æŒæ‰¬å£°å™¨é€šé“æ´»è·ƒï¼ˆä¸ä¼šå…³é—­ï¼‰ã€‚

```yml
speaker:
  # Hardware speaker output
  - platform: i2s_audio
    id: i2s_audio_speaker
    sample_rate: 48000
    i2s_mode: secondary
    i2s_dout_pin: GPIO44
    bits_per_sample: 32bit
    i2s_audio_id: i2s_output
    dac_type: external
    channel: stereo
    timeout: never
    buffer_duration: 100ms
    audio_dac: aic3104_dac
```

**æ··éŸ³å™¨**

- å°†å¤šä¸ªéŸ³é¢‘æµï¼ˆåª’ä½“+å…¬å‘Šï¼‰åˆå¹¶ä¸ºä¸€ä¸ªè¾“å‡ºã€‚

```yml
  # Virtual speakers to combine the announcement and media streams together into one output
  - platform: mixer
    id: mixing_speaker
    output_speaker: i2s_audio_speaker
    num_channels: 2
    source_speakers:
      - id: announcement_mixing_input
        timeout: never
      - id: media_mixing_input
        timeout: never
```

**é‡é‡‡æ ·å™¨**

- ç¡®ä¿æ‰€æœ‰éŸ³é¢‘æºåŒ¹é…é‡‡æ ·ç‡å’Œä½æ·±åº¦ã€‚

```yml
  # Vritual speakers to resample each pipelines' audio, if necessary, as the mixer speaker requires the same sample rate
  - platform: resampler
    id: announcement_resampling_speaker
    output_speaker: announcement_mixing_input
    sample_rate: 48000
    bits_per_sample: 16
  - platform: resampler
    id: media_resampling_speaker
    output_speaker: media_mixing_input
    sample_rate: 48000
    bits_per_sample: 16
```

**åª’ä½“æ’­æ”¾å™¨**

- æ§åˆ¶éŸ³é‡ã€é™éŸ³ã€æ’­æ”¾å’Œé—ªé¿ï¼ˆåœ¨å…¬å‘ŠæœŸé—´é™ä½åª’ä½“éŸ³é‡ï¼‰ã€‚
- ä¸ºäº‹ä»¶é¢„åŠ è½½å£°éŸ³ï¼ˆè®¡æ—¶å™¨ã€å”¤é†’è¯ã€é”™è¯¯ï¼‰ã€‚

```yml
media_player:
  - platform: speaker
    id: external_media_player
    name: None
    internal: False
    volume_increment: 0.05
    volume_min: 0.0
    volume_max: 1.0
    ...
    ...
```

### Respeaker XVF3800 é›†æˆ

- i2c åœ°å€ï¼š0x2C
- IDï¼šrespeaker
- éº¦å…‹é£é™éŸ³å¼€å…³ï¼šæ¯ 1 ç§’æ›´æ–°ä¸€æ¬¡ï¼Œåˆ‡æ¢æ—¶æ’­æ”¾å£°éŸ³ã€‚
- DFU ç‰ˆæœ¬æŠ¥å‘Šï¼šæ¯ 120 ç§’æŠ¥å‘Šå›ºä»¶ã€‚
- æ³¢æŸæ–¹å‘ä¼ æ„Ÿå™¨ï¼šè·Ÿè¸ªè¯­éŸ³æ³¢æŸï¼ˆä»…å†…éƒ¨ï¼‰ã€‚
- å›ºä»¶ç®¡ç†ï¼šå¦‚éœ€è¦è‡ªåŠ¨åˆ·å†™ XVF3800 å›ºä»¶ã€‚

```yml
respeaker_xvf3800:
  id: respeaker
  address: 0x2C
  mute_switch:
    id: mic_mute_switch
    name: "Microphone Mute"
    update_interval: 1s
    on_turn_on:
    ...
    ...
```

### å‚è€ƒèµ„æ–™/ä»“åº“

```yml
external_components:
  - source:
      type: git
      url: https://github.com/formatBCE/esphome
      ref: respeaker_microphone
    components:
      - i2s_audio
    refresh: 0s
  - source:
      type: git
      url: https://github.com/formatBCE/Respeaker-XVF3800-ESPHome-integration
      ref: main
    components: 
      - respeaker_xvf3800
      - aic3104
    refresh: 0s

```

- formatBCE/esphomeï¼šè‡ªå®šä¹‰ IÂ²S éŸ³é¢‘ç»„ä»¶ã€‚
- formatBCE/Respeaker-XVF3800-ESPHome-integrationï¼š
- XVF3800 é©±åŠ¨ç¨‹åº
- AIC3104 éŸ³é¢‘ç¼–è§£ç å™¨é©±åŠ¨ç¨‹åº
- refresh: 0sï¼šå§‹ç»ˆä»ä»“åº“è·å–æœ€æ–°ä»£ç ã€‚

### å¾®å”¤é†’è¯

```yml
micro_wake_word:
  id: mww
  microphone:
    microphone: i2s_mics
    channels: 1
    # gain_factor: 4
  stop_after_detection: false
  ....
  ....
```

æ£€æµ‹æ‚¨çš„å”¤é†’è¯ï¼ˆå¦‚"Okay Nabu"ï¼‰å¹¶å¯åŠ¨è¯­éŸ³åŠ©æ‰‹ã€‚

- id: mww â†’ å¼•ç”¨åç§°ã€‚
- microphone: i2s_micsï¼Œ1 é€šé“ã€‚
- stop_after_detection: false â†’ æŒç»­ç›‘å¬ã€‚
- okay_nabu, kenobi, hey_jarvis, hey_mycroft, stopï¼ˆå†…éƒ¨åœæ­¢å‘½ä»¤ï¼›æ‚¨å¯ä»¥æ·»åŠ è‡ªå·±çš„å‘½ä»¤ï¼‰ã€‚
- vad probability_cutoff: 0.05 â†’ è¯­éŸ³æ•æ„Ÿåº¦ã€‚

**æ£€æµ‹æ—¶ï¼ˆå¦‚æœéº¦å…‹é£æœªé™éŸ³ï¼‰**

- åœæ­¢è®¡æ—¶å™¨ã€å…¬å‘Šæˆ–è¯­éŸ³åŠ©æ‰‹ï¼ˆå¦‚æœå¤„äºæ´»åŠ¨çŠ¶æ€ï¼‰ã€‚
- æ’­æ”¾å”¤é†’å£°éŸ³ï¼ˆå¦‚æœå¯ç”¨ï¼‰ã€‚
- å¯åŠ¨è¯­éŸ³åŠ©æ‰‹ä»¥æ¥æ”¶å‘½ä»¤ã€‚

### è¯­éŸ³åŠ©æ‰‹

```yml
voice_assistant:
  id: va
  microphone:
    microphone: i2s_mics
    channels: 0
  media_player: external_media_player
  micro_wake_word: mww
  use_wake_word: false
  noise_suppression_level: 0
  ....
  ....
```

æ§åˆ¶æ‚¨çš„è¯­éŸ³åŠ©æ‰‹ï¼ˆVAï¼‰è¡Œä¸ºå’Œäº¤äº’ã€‚

- **éº¦å…‹é£å’Œåª’ä½“**ï¼šä½¿ç”¨ i2s_mics å’Œå¤–éƒ¨åª’ä½“æ’­æ”¾å™¨ã€‚
- **å”¤é†’è¯**ï¼šé“¾æ¥åˆ° mww ä½†ä¸éœ€è¦å”¤é†’è¯ï¼ˆuse_wake_word: falseï¼‰ã€‚
- **éŸ³é¢‘è®¾ç½®**ï¼šå™ªå£°æŠ‘åˆ¶å…³é—­ï¼Œè‡ªåŠ¨å¢ç›Š 0 dBï¼Œæ­£å¸¸éŸ³é‡ã€‚

#### äº‹ä»¶ / å‘ç”Ÿçš„æƒ…å†µ

- **on_client_connected**ï¼šå¯åŠ¨ VAï¼ŒLED æ›´æ–°ï¼Œå¦‚éœ€è¦åˆ™å–æ¶ˆéº¦å…‹é£é™éŸ³ã€‚
- **on_client_disconnected**ï¼šåœæ­¢ VAï¼Œé‡ç½® LEDã€‚
- **on_errorï¼šåœ¨ LED ä¸Šæ˜¾ç¤ºé”™è¯¯çŠ¶æ€**ï¼›å¦‚æœäº‘è®¤è¯å¤±è´¥åˆ™æ’­æ”¾æœ¬åœ°å£°éŸ³ã€‚
- **on_start**ï¼šVA å¯åŠ¨æ—¶é™ä½åª’ä½“éŸ³é‡ï¼ˆé—ªé¿ï¼‰ã€‚
- **on_listening / on_stt_vad_start / on_stt_vad_end**ï¼šåœ¨è†å¬å’Œæ€è€ƒæœŸé—´æ›´æ–° VA é˜¶æ®µå’Œ LEDã€‚
- **on_intent_progress / on_tts_start / on_tts_end**ï¼šå¤„ç†è¯­éŸ³ï¼Œæ›´æ–° LEDï¼Œå¯è§¦å‘åœæ­¢è¯è„šæœ¬ã€‚
- **on_stt_end**ï¼šå‘é€è¯†åˆ«æ–‡æœ¬äº‹ä»¶ã€‚
- **on_end**ï¼šåœæ­¢ VAï¼Œé‡ç½® LEDï¼Œç»“æŸé—ªé¿ã€‚

#### è®¡æ—¶å™¨äº‹ä»¶

- on_timer_started / on_timer_updated / on_timer_cancelled / on_timer_finished / on_timer_tick:
  - æ›´æ–°è®¡æ—¶å™¨çŠ¶æ€å’Œåç§°ã€‚
  - æ›´æ–° LEDã€‚
  - å¯¹äºæ»´ç­”è®¡æ—¶å™¨ï¼Œå°† LED æ›´æ–°å‡å°‘åˆ°æ¯ 5 ç§’ä¸€æ¬¡ã€‚

## ç‰¹åˆ«æ„Ÿè°¢

æˆ‘ä»¬è¦æ„Ÿè°¢ FormatBCE ä¸º Seeed Studio ReSpeaker XVF3800 åˆ›å»ºäº†è¿™ä¸ªå‡ºè‰²çš„ YAML æ–‡ä»¶ã€‚
åœ¨ä»–çš„ [GitHub](https://github.com/formatBCE/Respeaker-XVF3800-ESPHome-integration) ä¸Šæ”¯æŒä»–

## æŠ€æœ¯æ”¯æŒä¸äº§å“è®¨è®º

æ„Ÿè°¢æ‚¨é€‰æ‹©æˆ‘ä»¬çš„äº§å“ï¼æˆ‘ä»¬åœ¨è¿™é‡Œä¸ºæ‚¨æä¾›ä¸åŒçš„æ”¯æŒï¼Œä»¥ç¡®ä¿æ‚¨ä½¿ç”¨æˆ‘ä»¬äº§å“çš„ä½“éªŒå°½å¯èƒ½é¡ºç•…ã€‚æˆ‘ä»¬æä¾›å¤šç§æ²Ÿé€šæ¸ é“ï¼Œä»¥æ»¡è¶³ä¸åŒçš„åå¥½å’Œéœ€æ±‚ã€‚

<div class="button_tech_support_container">
<a href="https://forum.seeedstudio.com/" class="button_forum"></a>
<a href="https://www.seeedstudio.com/contacts" class="button_email"></a>
</div>

<div class="button_tech_support_container">
<a href="https://discord.gg/eWkprNDMU7" class="button_discord"></a>
<a href="https://github.com/Seeed-Studio/wiki-documents/discussions/69" class="button_discussion"></a>
</div>
