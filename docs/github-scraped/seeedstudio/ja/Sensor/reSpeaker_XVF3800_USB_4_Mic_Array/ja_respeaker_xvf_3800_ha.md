---
description: ReSpeaker XVF3800 USB 4-Mic Arrayã®åŠ›ã‚’ä½“é¨“ã—ã¦ãã ã•ã„â€”AECã€ãƒ“ãƒ¼ãƒ ãƒ•ã‚©ãƒ¼ãƒŸãƒ³ã‚°ã€ãƒã‚¤ã‚ºæŠ‘åˆ¶ã€360Â°éŸ³å£°ã‚­ãƒ£ãƒ—ãƒãƒ£ã‚’å‚™ãˆãŸé«˜åº¦ãªå††å½¢ãƒã‚¤ã‚¯ã‚¢ãƒ¬ã‚¤ã§ã™ã€‚ã‚³ãƒ³ãƒ‘ã‚¯ãƒˆãªXIAO ESP32S3ã¨çµ„ã¿åˆã‚ã›ã‚‹ã“ã¨ã§ã€ã‚¹ãƒãƒ¼ãƒˆãƒ‡ãƒã‚¤ã‚¹ã€ãƒ­ãƒœãƒ†ã‚£ã‚¯ã‚¹ã€IoTã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³å‘ã‘ã®é«˜æ€§èƒ½éŸ³å£°åˆ¶å¾¡ã‚’å®Ÿç¾ã—ã¾ã™ã€‚éŸ³å£°ã‚³ãƒãƒ³ãƒ‰ã‚’ä½¿ç”¨ã—ã¦ãƒ‡ãƒã‚¤ã‚¹ã‚’åˆ¶å¾¡ã™ã‚‹Home Assistantã¨ã®ã‚·ãƒ¼ãƒ ãƒ¬ã‚¹ãªçµ±åˆã‚’ãƒ‡ãƒ¢ãƒ³ã‚¹ãƒˆãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã—ã¾ã™ã€‚

title: Home Assistantã«ã‚ˆã‚‹ã‚¹ãƒãƒ¼ãƒˆãƒ›ãƒ¼ãƒ éŸ³å£°åˆ¶å¾¡

keywords:
- reSpeaker
- XIAO
- ESP32S3
- Home Assistant
image: https://files.seeedstudio.com/wiki/respeaker_xvf3800_usb/respeaker-xvf3800-4-mic-array-with-xiao-esp32s3.webp
slug: /ja/respeaker_xvf3800_xiao_home_assistant
last_update:
  date: 9/17/2025
  author: Kasun Thushara
---

## æ¦‚è¦

æ–°ã—ã„**ReSpeaker XMOS XVF3800 with XIAO ESP32S3**ã§ã‚¹ãƒãƒ¼ãƒˆã‚¹ãƒšãƒ¼ã‚¹ã¨ä¼šè©±ã—ã¾ã—ã‚‡ã†ã€‚éŸ³å£°ã‚’ä½¿ã£ã¦ç…§æ˜ã‚’ã¤ã‘ãŸã‚Šã€éŸ³æ¥½ã‚’å¤§ããã—ãŸã‚Šã€å¤©æ°—ã‚’èã„ãŸã‚Šã§ãã¾ã™ã€‚

ã“ã®ç« ã§ã¯ã€ReSpeaker XMOS XVF3800 with XIAO ESP32S3 HA Voice Assistantã¨Sonoffã‚¹ãƒãƒ¼ãƒˆã‚¹ã‚¤ãƒƒãƒã‚’æ¥ç¶šã—ã¦ã€éŸ³å£°ã«ã‚ˆã‚‹ç…§æ˜ã‚¹ã‚¤ãƒƒãƒã®åˆ¶å¾¡ã‚’å®Ÿç¾ã—ã¾ã™ã€‚

<div class="video-container">
  <iframe width="800" height="400"
          src="https://www.youtube.com/embed/iqlsNezHYuE"
          title="ReSpeaker XVF3800 with XIAO ESP32S3 Home Assistant"
          frameborder="0"
          allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
          referrerpolicy="strict-origin-when-cross-origin"
          allowfullscreen>
  </iframe>
</div>

## å¿…è¦ãªãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢

<table align="center">
  <tr>
      <th>ReSpeaker XVF3800 with XIAO ESP32S3</th>
        <th>Home Assistantãƒ‡ãƒã‚¤ã‚¹</th>
        <th>Sonoff BASICR2</th>
  </tr>
  <tr>
      <td><div style={{textAlign:'center'}}><img src="https://files.seeedstudio.com/wiki/respeaker_xvf3800_usb/front-xiao.jpg" style={{width:500, height:'auto'}}/></div></td>
        <td><div style={{textAlign:'center'}}><img src="https://files.seeedstudio.com/wiki/Home_Assistant_Green/HAyellow.png" style={{width:500, height:'auto'}}/></div></td>
        <td><div style={{textAlign:'center'}}><img src="https://media-cdn.seeedstudio.com/media/catalog/product/cache/bb49d3ec4ee05b6f018e93f896b8a25d/1/-/1-113991074-sonoff-basicr2-45font.jpg" style={{width:500, height:'auto'}}/></div></td>
  </tr>
    <tr>
      <td><div class="get_one_now_container" style={{textAlign: 'center'}}>
        <a class="get_one_now_item" href="https://www.seeedstudio.com/ReSpeaker-XVF3800-4-Mic-Array-With-XIAO-ESP32S3-p-6489.html" target="_blank">
            <strong><span><font color={'FFFFFF'} size={"4"}> ä»Šã™ãè³¼å…¥å– ğŸ–±ï¸</font></span></strong>
        </a>
    </div></td>
        <td><div class="get_one_now_container" style={{textAlign: 'center'}}>
        <a class="get_one_now_item" href="https://www.seeedstudio.com/Home-Assistant-Yellow-Standard-Version-with-CM4-p-5809.html" target="_blank">
            <strong><span><font color={'FFFFFF'} size={"4"}> ä»Šã™ãè³¼å…¥å– ğŸ–±ï¸</font></span></strong>
        </a>
    </div></td>
        <td><div class="get_one_now_container" style={{textAlign: 'center'}}>
        <a class="get_one_now_item" href="https://www.seeedstudio.com/Sonoff-BasicR2-p-5514.html" target="_blank">
            <strong><span><font color={'FFFFFF'} size={"4"}> ä»Šã™ãè³¼å…¥å– ğŸ–±ï¸</font></span></strong>
        </a>
    </div></td>
  </tr>
</table>

## ãƒ•ã‚¡ãƒ¼ãƒ ã‚¦ã‚§ã‚¢ã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ãƒˆ

æœ€é«˜ã®å†ç”Ÿä½“é¨“ã‚’å¾—ã‚‹ãŸã‚ã«ã€XMOSãƒ•ã‚¡ãƒ¼ãƒ ã‚¦ã‚§ã‚¢ã‚’ã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ãƒˆã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚
ãƒ•ã‚¡ãƒ¼ãƒ ã‚¦ã‚§ã‚¢ã‚’ã“ã“ã‹ã‚‰ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ã¦ãã ã•ã„ã€‚ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ãƒ¼ã§ReSpeaker XMOS XVF3800 with XIAO ESP32S3ã‚’æ¥ç¶šã—ã€ã‚¬ã‚¤ãƒ‰ã«å¾“ã£ã¦å®Ÿè¡Œã—ã¦ãã ã•ã„ï¼š

<p style={{textAlign: 'center'}}><img src="https://files.seeedstudio.com/wiki/respeaker_xvf3800_usb/HA/firmware_1.png" alt="pir" width={800} height="auto" /></p>

:::note
XVF3800ãƒã‚¤ã‚¯ã‚¢ãƒ¬ã‚¤ã¯å‹•ä½œã™ã‚‹ãŸã‚ã«12.288 MHz MCLKãŒå¿…è¦ã§ã™ãŒã€ESPHomeï¼ˆHome Assistantã§ä½¿ç”¨ï¼‰ã¯APIåˆ¶é™ã®ãŸã‚ãã‚Œã‚’ç”Ÿæˆã§ãã¾ã›ã‚“ã€‚ã“ã®ãƒ•ã‚¡ãƒ¼ãƒ ã‚¦ã‚§ã‚¢ã¯XVF3800ã‚’I2Sãƒã‚¹ã‚¿ãƒ¼ã¨ã—ã¦å‹•ä½œã•ã›ã‚‹ãŸã‚ã€ESP32ã‹ã‚‰ã®MCLKã‚’å¿…è¦ã¨ã›ãšã«ç‹¬è‡ªã®ã‚¯ãƒ­ãƒƒã‚¯ã‚’ç”Ÿæˆã§ãã¾ã™ã€‚
ç§ãŸã¡ã®ãƒ•ã‚¡ãƒ¼ãƒ ã‚¦ã‚§ã‚¢ã¯ã“ã®åˆ¶é™ã‚’ä¿®æ­£ã—ã€ãƒã‚¤ã‚¯ãŒHome Assistantã§æ­£å¸¸ã«å‹•ä½œã™ã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚
:::

ãƒ•ã‚¡ãƒ¼ãƒ ã‚¦ã‚§ã‚¢ã¯[ã“ã¡ã‚‰](https://github.com/respeaker/reSpeaker_XVF3800_USB_4MIC_ARRAY/tree/master/xmos_firmwares/i2s)ã‹ã‚‰ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã§ãã¾ã™

ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã‚¬ã‚¤ãƒ‰ã¯[ã“ã¡ã‚‰](https://wiki.seeedstudio.com/ja/respeaker_xvf3800_introduction/#update-firmware)ã§ã™

## ReSpeaker XMOS XVF3800 with XIAO ESP32S3ã®æº–å‚™

**Home Assistant > Settings > Add-ons**ã«ç§»å‹•ã—ã¾ã™ã€‚

<p style={{textAlign: 'center'}}><img src="https://files.seeedstudio.com/wiki/respeaker_xvf3800_usb/HA/HA_Settings.PNG" alt="pir" width={800} height="auto" /></p>

**Add-on Store**ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¾ã™ï¼ˆé€šå¸¸ã¯å³ä¸‹ã«ã‚ã‚Šã¾ã™ï¼‰

<p style={{textAlign: 'center'}}><img src="https://files.seeedstudio.com/wiki/respeaker_xvf3800_usb/HA/HA_addon.PNG" alt="pir" width={800} height="auto" /></p>

**Official add-ons**ã®ä¸‹ã§ã€**ESPHome Device Builder**ã‚’æ¤œç´¢ã—ã¦ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã—ã¾ã™ã€‚

<p style={{textAlign: 'center'}}><img src="https://files.seeedstudio.com/wiki/respeaker_xvf3800_usb/HA/HA_esphome.PNG" alt="pir" width={800} height="auto" /></p>

ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«å¾Œã€**Start**ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ESPHomeã‚¢ãƒ‰ã‚ªãƒ³ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚

<p style={{textAlign: 'center'}}><img src="https://files.seeedstudio.com/wiki/respeaker_xvf3800_usb/HA/HA_esphome_Start.PNG" alt="pir" width={800} height="auto" /></p>

ç°¡å˜ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã‚‹ã‚ˆã†ã«ã€**Start on Bootã€Watchdogã€Show in Sidebar**ã‚’æœ‰åŠ¹ã«ã—ã¾ã™ã€‚

Home Assistantã®ã‚µã‚¤ãƒ‰ãƒãƒ¼ã‹ã‚‰ã€**ESPHome Builder**ã«ç§»å‹•ã—ã¾ã™ã€‚

**+ NEW DEVICE**ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¾ã™ã€‚

<p style={{textAlign: 'center'}}><img src="https://files.seeedstudio.com/wiki/respeaker_xvf3800_usb/HA/HA_esphome_add_new.PNG" alt="pir" width={800} height="auto" /></p>

<p style={{textAlign: 'center'}}><img src="https://files.seeedstudio.com/wiki/respeaker_xvf3800_usb/HA/HA_esphome_device.PNG" alt="pir" width={500} height="auto" /></p>

ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆãŒè¡¨ç¤ºã•ã‚ŒãŸã‚‰ã€**SKIP**ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¾ã™ â€“ è¨­å®šã‚’æ‰‹å‹•ã§ä½œæˆã—ã¾ã™ã€‚

<p style={{textAlign: 'center'}}><img src="https://files.seeedstudio.com/wiki/respeaker_xvf3800_usb/HA/HA_esphome_skip.PNG" alt="pir" width={500} height="auto" /></p>

æ–°ã—ã„ãƒ‡ãƒã‚¤ã‚¹ã‚¨ãƒ³ãƒˆãƒªã‚’é¸æŠã—ã€**EDIT**ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¾ã™ã€‚

<p style={{textAlign: 'center'}}><img src="https://files.seeedstudio.com/wiki/respeaker_xvf3800_usb/HA/HA_esphome_respeaker_device.PNG" alt="pir" width={800} height="auto" /></p>

å†…å®¹ã‚’ã‚«ã‚¹ã‚¿ãƒ **YAMLè¨­å®š**ã«ç½®ãæ›ãˆã¾ã™

:::important
YAMLãƒ•ã‚¡ã‚¤ãƒ«ã¯[ã“ã¡ã‚‰](https://github.com/formatBCE/Respeaker-XVF3800-ESPHome-integration/tree/main/config)ã‹ã‚‰è¦‹ã¤ã‘ã‚‹ã“ã¨ãŒã§ãã¾ã™
:::

YAMLãŒä¿å­˜ã•ã‚ŒãŸã‚‰ã€**INSTALL**ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¾ã™ã€‚

<p style={{textAlign: 'center'}}><img src="https://files.seeedstudio.com/wiki/respeaker_xvf3800_usb/HA/HA_esphome_yaml.PNG" alt="pir" width={800} height="auto" /></p>

**Manual Download**ã‚’é¸æŠã—ã¾ã™

<p style={{textAlign: 'center'}}><img src="https://files.seeedstudio.com/wiki/respeaker_xvf3800_usb/HA/HA_esphome_manual.PNG" alt="pir" width={800} height="auto" /></p>

ãƒ•ã‚¡ãƒ¼ãƒ ã‚¦ã‚§ã‚¢ã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚’å¾…ã¡ã¾ã™ã€‚

ç”Ÿæˆã•ã‚ŒãŸ.binãƒ•ã‚¡ãƒ¼ãƒ ã‚¦ã‚§ã‚¢ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ãƒ¼ã«ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ã¾ã™ã€‚

<p style={{textAlign: 'center'}}><img src="https://files.seeedstudio.com/wiki/respeaker_xvf3800_usb/HA/HA_esphome_factory.PNG" alt="pir" width={800} height="auto" /></p>

**ESP32-S3**ãƒœãƒ¼ãƒ‰ï¼ˆXVF3800ãŒæ¥ç¶šã•ã‚ŒãŸçŠ¶æ…‹ï¼‰ã‚’**USB Type-Cã‚±ãƒ¼ãƒ–ãƒ«**ã‚’ä½¿ç”¨ã—ã¦PCã«æ¥ç¶šã—ã¾ã™ã€‚

Chromeã¾ãŸã¯Edgeã§[**Web-ESPHome**](https://web.esphome.io/?dashboard_wizard)ã‚’é–‹ãã¾ã™ã€‚

**CONNECT**ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã€é©åˆ‡ãªã‚·ãƒªã‚¢ãƒ«ãƒãƒ¼ãƒˆã‚’é¸æŠã—ã¾ã™

<p style={{textAlign: 'center'}}><img src="https://files.seeedstudio.com/wiki/respeakerv3/connect-port.png" alt="pir" width={800} height="auto" /></p>

æ¥ç¶šã•ã‚ŒãŸã‚‰ã€**INSTALL**ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¾ã™

<p style={{textAlign: 'center'}}><img src="https://files.seeedstudio.com/wiki/respeaker_xvf3800_usb/HA/HA_esphome_install.PNG" alt="pir" width={500} height="auto" /></p>

å…ˆã»ã©ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ãŸ.binãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¾ã™ã€‚

<p style={{textAlign: 'center'}}><img src="https://files.seeedstudio.com/wiki/respeaker_xvf3800_usb/HA/HA_esphome_bin_write.PNG" alt="pir" width={500} height="auto" /></p>

ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ãŒå®Œäº†ã™ã‚‹ã¾ã§å¾…ã¡ã¾ã™ï¼ˆæ•°åˆ†ã‹ã‹ã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ï¼‰ã€‚

æˆåŠŸã™ã‚‹ã¨ã€ç¢ºèªãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒè¡¨ç¤ºã•ã‚Œã¾ã™ã€‚

<p style={{textAlign: 'center'}}><img src="https://files.seeedstudio.com/wiki/respeaker_xvf3800_usb/HA/HA_esphome_congrats.PNG" alt="pir" width={500} height="auto" /></p>

**Home Assistant > Settings > Devices & Services**ã«æˆ»ã‚Šã¾ã™ã€‚

ç™ºè¦‹ã•ã‚ŒãŸçµ±åˆã¨ã—ã¦**ESPHome**ãŒãƒªã‚¹ãƒˆã•ã‚Œã¦ã„ã‚‹ã¯ãšã§ã™ã€‚

**CONFIGURE**ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã€æ¬¡ã«**Submit**ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã‚’å®Œäº†ã—ã¾ã™ã€‚

<p style={{textAlign: 'center'}}><img src="https://files.seeedstudio.com/wiki/respeaker_xvf3800_usb/HA/HA_esphome_discover.PNG" alt="pir" width={800} height="auto" /></p>

## ã‚¹ãƒãƒ¼ãƒˆãƒ‡ãƒã‚¤ã‚¹ã®è¿½åŠ 

ãƒ¡ãƒ¼ã‚«ãƒ¼ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒãƒ‹ãƒ¥ã‚¢ãƒ«ã«å¾“ã£ã¦**Sonoff BASICR2**ãƒ‡ãƒã‚¤ã‚¹ã‚’ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã—ã¾ã™ã€‚eWeLinkã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚’ä½œæˆã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

### HACSã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«

ã¾ã ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã•ã‚Œã¦ã„ãªã„å ´åˆã¯ã€å…¬å¼ã‚¬ã‚¤ãƒ‰ã«å¾“ã£ã¦[**Home Assistant Community Store**](https://hacs.xyz/docs/use/)ã‚’ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã—ã¦ãã ã•ã„ï¼š

ã‚µã‚¤ãƒ‰ãƒãƒ¼ã‹ã‚‰**HACS**ã‚’é–‹ãã¾ã™ã€‚
æ¤œç´¢ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã§**Sonoff LAN**ã‚’æ¤œç´¢ã—ã¾ã™ã€‚

<p style={{textAlign: 'center'}}><img src="https://files.seeedstudio.com/wiki/respeaker_xvf3800_usb/HA/HA_HACS.PNG" alt="pir" width={800} height="auto" /></p>

**Install**ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦çµ±åˆã‚’è¿½åŠ ã—ã¾ã™ã€‚
å¤‰æ›´ã‚’é©ç”¨ã™ã‚‹ãŸã‚ã«Home Assistantã‚’å†èµ·å‹•ã—ã¾ã™ã€‚

### Sonoff

**Settings â†’ Devices & Services**ã«ç§»å‹•ã—ã¾ã™ã€‚
**Add Integration**ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¾ã™ã€‚
**Sonoff**ã‚’æ¤œç´¢ã—ã¦é¸æŠã—ã¾ã™ã€‚

<p style={{textAlign: 'center'}}><img src="https://files.seeedstudio.com/wiki/respeaker_xvf3800_usb/HA/HA_esphome_sonoff.PNG" alt="pir" width={800} height="auto" /></p>

èªè¨¼ã®ãŸã‚ã«**eWeLinkã‚¢ã‚«ã‚¦ãƒ³ãƒˆèªè¨¼æƒ…å ±**ã‚’å…¥åŠ›ã—ã¾ã™ã€‚

<p style={{textAlign: 'center'}}><img src="https://files.seeedstudio.com/wiki/SenseCAP/respeaker/credentials.png" alt="pir" width={500} height="auto" /></p>

æ­£å¸¸ã«æ¥ç¶šã•ã‚Œã‚‹ã¨ã€é–¢é€£ã™ã‚‹ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ãŒä»¥ä¸‹ã®å ´æ‰€ã«ãƒªã‚¹ãƒˆã•ã‚Œã¾ã™ï¼š
**Settings â†’ Devices & Services â†’ Entities**

<p style={{textAlign: 'center'}}><img src="https://files.seeedstudio.com/wiki/SenseCAP/respeaker/sonoff-id.png" alt="pir" width={800} height="auto" /></p>

## Nabu Cloudã«ã‚ˆã‚‹éŸ³å£°ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ

ã“ã®ãƒ‡ãƒ¢ã§ã¯ã€éŸ³å£°ã‚’ä½¿ç”¨ã—ã¦**Home Assistant Cloud (Nabu Casa)**ã«æ¥ç¶šã™ã‚‹æ–¹æ³•ã‚’ç´¹ä»‹ã—ã¦ã„ã¾ã™ã€‚ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã¯ç°¡å˜ã§ã€**1ãƒ¶æœˆé–“ã®ç„¡æ–™ãƒˆãƒ©ã‚¤ã‚¢ãƒ«**ã‚’åˆ©ç”¨ã—ã¦ãã®å…¨æ©Ÿèƒ½ã‚’æ¢ç´¢ã§ãã¾ã™ã€‚
å†…è”µã®**ã‚¦ã‚§ã‚¤ã‚¯ãƒ¯ãƒ¼ãƒ‰**ã€ŒOkay Nabuã€ã‚’ä½¿ç”¨ã—ã¦ã€éŸ³å£°ã‚³ãƒãƒ³ãƒ‰ã‚’ç°¡å˜ã«ãƒˆãƒªã‚¬ãƒ¼ã—ã€è¤‡é›‘ãªè¨­å®šãªã—ã«**ã„ã¤ã§ã‚‚ã€ã©ã“ã§ã‚‚**ãƒ‡ãƒã‚¤ã‚¹ã‚„ã‚µãƒ¼ãƒ“ã‚¹ã¨**ã‚·ãƒ¼ãƒ ãƒ¬ã‚¹ã«çµ±åˆ**ã§ãã¾ã™ã€‚

<p style={{textAlign: 'center'}}><img src="https://files.seeedstudio.com/wiki/respeaker_xvf3800_usb/HA/HA_voice.PNG" alt="pir" width={800} height="auto" /></p>

<p style={{textAlign: 'center'}}><img src="https://files.seeedstudio.com/wiki/respeaker_xvf3800_usb/HA/HA_voice_nabu.PNG" alt="pir" width={800} height="auto" /></p>

## YAML ã®èª¬æ˜

### WiFi

ã“ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã§ã¯ã€ãƒ‡ãƒã‚¤ã‚¹ãŒWi-Fiã«æ¥ç¶šã™ã‚‹æ–¹æ³•ã‚’è¨­å®šã—ã¾ã™ã€‚

```yml
wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
```

- **ssid & password**: secrets.yamlãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰å–å¾—ã•ã‚Œã‚‹ãŸã‚ã€ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãŒå¹³æ–‡ã§è¡¨ç¤ºã•ã‚Œã¾ã›ã‚“ã€‚
- **Events**: Wi-Fiæ¥ç¶šæ™‚ã¾ãŸã¯åˆ‡æ–­æ™‚ã«ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’å®Ÿè¡Œã—ã¾ã™ï¼š
  - on_connect:
    - BLE improvè¨­å®šã‚’åœæ­¢ã—ã¾ã™ã€‚
    - control_ledsã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’å®Ÿè¡Œã—ã¾ã™ï¼ˆWi-Fiæ¥ç¶šæ™‚ã®LEDåŠ¹æœï¼‰ã€‚

  - on_disconnect:
    - control_ledsã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’å®Ÿè¡Œã—ã¾ã™ï¼ˆWi-Fiåˆ‡æ–­æ™‚ã®LEDåŠ¹æœï¼‰ã€‚

### IÂ²C ãƒã‚¹

IÂ²Cã¯ã€ESP32ãŒãƒã‚¤ã‚¯ã‚„ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã‚³ãƒ¼ãƒ‡ãƒƒã‚¯ãªã©ã®ä»–ã®ãƒãƒƒãƒ—ã¨é€šä¿¡ã™ã‚‹ãŸã‚ã®é€šä¿¡ãƒ©ã‚¤ãƒ³ã§ã™ã€‚

```yml
i2c:
  id: internal_i2c
  sda: GPIO5
  scl: GPIO6
  scan: true
  frequency: 100kHz
```

- **id**: ä»–ã®å ´æ‰€ã§ã“ã®ãƒã‚¹ã‚’å‚ç…§ã™ã‚‹ãŸã‚ã®åå‰ã€‚
- **sda** / scl: ãƒ‡ãƒ¼ã‚¿ã¨ã‚¯ãƒ­ãƒƒã‚¯ã«ä½¿ç”¨ã•ã‚Œã‚‹ãƒ”ãƒ³ã€‚
- **scan**: èµ·å‹•æ™‚ã«æ¥ç¶šã•ã‚ŒãŸãƒ‡ãƒã‚¤ã‚¹ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¾ã™ã€‚
- **frequency**: é€šä¿¡é€Ÿåº¦ï¼ˆ100kHzãŒæ¨™æº–ï¼‰ã€‚

### ã‚¹ã‚¤ãƒƒãƒ

<details>
<summary>ã‚¹ã‚¤ãƒƒãƒ</summary>

```yml
switch:
  # Mute Sound Switch.
  - platform: template
    id: mute_sound
    name: Mute/unmute sound
    icon: "mdi:bullhorn"
    entity_category: config
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
  # Wake Word Sound Switch.
  - platform: template
    id: wake_sound
    name: Wake sound
    icon: "mdi:bullhorn"
    entity_category: config
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
  # Internal switch to track when a timer is ringing on the device.
  - platform: template
    id: timer_ringing
    optimistic: true
    internal: true
    restore_mode: ALWAYS_OFF
    on_turn_off:
      # Disable stop wake word
      - micro_wake_word.disable_model: stop
      - script.execute: disable_repeat
      # Stop any current annoucement (ie: stop the timer ring mid playback)
      - if:
          condition:
            media_player.is_announcing:
          then:
            media_player.stop:
              announcement: true
      # Set back ducking ratio to zero
      - mixer_speaker.apply_ducking:
          id: media_mixing_input
          decibel_reduction: 0
          duration: 1.0s
      # Refresh the LED ring
      - script.execute: control_leds
    on_turn_on:
      # Duck audio
      - mixer_speaker.apply_ducking:
          id: media_mixing_input
          decibel_reduction: 20
          duration: 0.0s
      # Enable stop wake word
      - micro_wake_word.enable_model: stop
      # Ring timer
      - script.execute: ring_timer
      # Refresh LED
      - script.execute: control_leds
      # If 15 minutes have passed and the timer is still ringing, stop it.
      - delay: 15min
      - switch.turn_off: timer_ringing
  # Defines if alarm is active
  - platform: template
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    id: alarm_on
    icon: mdi:bell-badge
    name: "Alarm on"
    on_turn_on:
      - script.execute: control_leds
    on_turn_off:
      - script.execute: control_leds
```

</details>

ã‚¹ã‚¤ãƒƒãƒã¯ã€Home Assistantã§ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢åˆ¶å¾¡ã•ã‚Œã‚‹ã€Œãƒœã‚¿ãƒ³ã€ã§ã™ã€‚éŸ³å£°ã€ã‚¿ã‚¤ãƒãƒ¼ã€ã‚¢ãƒ©ãƒ¼ãƒ ãªã©ã®æ©Ÿèƒ½ã‚’åˆ¶å¾¡ã—ã¾ã™ã€‚

**ã‚¦ã‚§ã‚¤ã‚¯ãƒ¯ãƒ¼ãƒ‰éŸ³å£°ã‚¹ã‚¤ãƒƒãƒ**: ã‚¦ã‚§ã‚¤ã‚¯ãƒ¯ãƒ¼ãƒ‰ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã‚’åˆ¶å¾¡ã—ã¾ã™ã€‚

```yml
# Wake Word Sound Switch.
  - platform: template
    id: wake_sound
    name: Wake sound
    icon: "mdi:bullhorn"
    entity_category: config
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
```

**ã‚¿ã‚¤ãƒãƒ¼é³´å‹•å†…éƒ¨ã‚¹ã‚¤ãƒƒãƒ**:

- ã‚¿ã‚¤ãƒãƒ¼ãŒã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‹ã©ã†ã‹ã‚’è¿½è·¡ã—ã¾ã™ã€‚
- on_turn_on: ä»–ã®ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã‚’-20dBãƒ€ãƒƒã‚­ãƒ³ã‚°ã€ã‚¿ã‚¤ãƒãƒ¼éŸ³é–‹å§‹ã€LEDæ›´æ–°ã€15åˆ†å¾Œã«è‡ªå‹•åœæ­¢ã€‚
- on_turn_off: ã‚¿ã‚¤ãƒãƒ¼åœæ­¢ã€éŸ³é‡å¾©å…ƒã€LEDæ›´æ–°ã€‚

```yml
# Internal switch to track when a timer is ringing on the device.
  - platform: template
    id: timer_ringing
    optimistic: true
    internal: true
    restore_mode: ALWAYS_OFF
    ...
    ...
```

**ã‚¢ãƒ©ãƒ¼ãƒ ã‚ªãƒ³ã‚¹ã‚¤ãƒƒãƒ**:

```yml
# Defines if alarm is active
  - platform: template
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    id: alarm_on
    ...
    ...
```

- ã‚¢ãƒ©ãƒ¼ãƒ ã®çŠ¶æ…‹ã‚’è¿½è·¡ã—ã¾ã™ã€‚
- ã‚ªãƒ³/ã‚ªãƒ•æ™‚ã«LEDã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’å®Ÿè¡Œã—ã¾ã™ã€‚

### ã‚»ãƒ³ã‚µãƒ¼

<details>
<summary>ã‚»ãƒ³ã‚µãƒ¼</summary>

```yml
number:
  - platform: template
    id: led_ring_brightness
    name: "LED Ring Brightness"
    icon: mdi:brightness-6
    entity_category: config
    optimistic: true
    restore_value: true
    min_value: 0.4
    max_value: 1.0
    step: 0.05
    initial_value: 0.8
    mode: slider

sensor:
  - platform: template
    id: next_timer
    name: "Next timer"
    update_interval: never
    disabled_by_default: true
    device_class: duration
    unit_of_measurement: s
    icon: "mdi:timer"
    accuracy_decimals: 0

text_sensor:
  - platform: template
    id: next_timer_name
    name: "Next timer name"
    icon: "mdi:timer"
    disabled_by_default: true
  - platform: template
    name: "Alarm time"
    id: alarm_time
    icon: mdi:bell-ring
  - platform: template
    name: "Current device time"
    id: current_time
    icon: mdi:clock
```

</details>

ã“ã®YAMLãƒ–ãƒ­ãƒƒã‚¯ã¯ã€ã‚¿ã‚¤ãƒãƒ¼ã€ã‚¢ãƒ©ãƒ¼ãƒ ã€LEDè¼åº¦ã®ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã¨ã‚»ãƒ³ã‚µãƒ¼ã‚’è¿½åŠ ã—ã¾ã™ã€‚ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã§LEDãƒªãƒ³ã‚°ã®è¼åº¦ã‚’èª¿æ•´ã—ã€æ¬¡ã®ã‚¿ã‚¤ãƒãƒ¼ï¼ˆæ™‚é–“+åå‰ï¼‰ã‚’è¿½è·¡ã—ã€Home Assistantã§ã‚¢ãƒ©ãƒ¼ãƒ æ™‚é–“ã¨ãƒ‡ãƒã‚¤ã‚¹ã®ç¾åœ¨æ™‚åˆ»ã‚’è¡¨ç¤ºã§ãã¾ã™ã€‚

**LEDãƒªãƒ³ã‚°è¼åº¦**:

```yml
number:
  - platform: template
    id: led_ring_brightness
    name: "LED Ring Brightness"
    icon: mdi:brightness-6
    ...
```

- ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã§è¼åº¦ã‚’èª¿æ•´ã§ãã¾ã™ã€‚
- min_value / max_valueã§åˆ¶é™ã‚’å®šç¾©ã—ã¾ã™ã€‚
- restore_valueã§å†èµ·å‹•å¾Œã‚‚å‰ã®è¨­å®šã‚’ä¿æŒã—ã¾ã™ã€‚

**æ¬¡ã®ã‚¿ã‚¤ãƒãƒ¼**

```yml
sensor:
  - platform: template
    id: next_timer
    name: "Next timer"
    update_interval: never
    ...
```

- æ¬¡ã®ã‚¿ã‚¤ãƒãƒ¼ã®æ®‹ã‚Šæ™‚é–“ã‚’è¡¨ç¤ºã—ã¾ã™ã€‚
- ã‚¿ã‚¤ãƒãƒ¼ãŒå¤‰æ›´ã•ã‚ŒãŸæ™‚ã®ã¿æ›´æ–°ã—ã¾ã™ï¼ˆãƒªã‚½ãƒ¼ã‚¹ã‚’ç¯€ç´„ï¼‰ã€‚

**ã‚¢ãƒ©ãƒ¼ãƒ æ™‚é–“ã¨ãƒ‡ãƒã‚¤ã‚¹æ™‚é–“**

```yml
text_sensor:
  - platform: template
    id: next_timer_name
    name: "Next timer name"
    icon: "mdi:timer"
    ...
```

- ç¾åœ¨ã®ã‚¢ãƒ©ãƒ¼ãƒ ã¨ESP32ã‚·ã‚¹ãƒ†ãƒ æ™‚é–“ã‚’è¡¨ç¤ºã—ã¾ã™ã€‚

### ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«ã§ã®LEDåŠ¹æœ

```yml
interval:
  - interval: 50ms
    id: led_animation_interval
    then:
      - lambda: |-
          if (id(volume_display_active)) {
            id(update_volume_display_effect).execute();
            return;
          }
          std::string effect = id(current_led_effect);
          if (effect == "off") {
            return;
          } else if (effect == "breathe") {
            id(update_breathe_effect).execute();
          } else if (effect == "rainbow") {
            id(update_rainbow_effect).execute();
          } else if (effect == "comet_cw") {
            id(update_comet_cw_effect).execute();
          } else if (effect == "comet_ccw") {
            id(update_comet_ccw_effect).execute();
          } else if (effect == "twinkle") {
            id(update_twinkle_effect).execute();
          } else if (effect == "timer_tick") {
            id(update_timer_tick_effect).execute();
          } else if (effect == "led_beam") {
            id(update_led_beam_effect).execute();
          }
```

- ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«ã¯ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã§ã‚³ãƒ¼ãƒ‰ã‚’ç¹°ã‚Šè¿”ã—å®Ÿè¡Œã—ã¾ã™ã€‚
- 50ms: 1ç§’é–“ã«20å›ã‚³ãƒ¼ãƒ‰ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚
- ã‚·ã‚¹ãƒ†ãƒ çŠ¶æ…‹ã¾ãŸã¯é¸æŠã•ã‚ŒãŸåŠ¹æœã«åŸºã¥ã„ã¦LEDã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’åˆ¶å¾¡ã—ã¾ã™ã€‚

### LEDåˆ¶å¾¡

<details>
<summary>LEDåˆ¶å¾¡</summary>

```yml
 script:
  # =========================================================================
  # == Centralized script to control all LED effects ==
  # =========================================================================
  - id: led_set_effect
    mode: restart
    parameters:
      effect: std::string
      r: float
      g: float
      b: float
      speed: float
    then:
      - lambda: |-
          // Update global variables with the new parameters
          id(led_ring_color_r) = r;
          id(led_ring_color_g) = g;
          id(led_ring_color_b) = b;
          id(led_ring_speed) = speed;
          id(current_led_effect) = effect;

          // Handle the two types of effects: Off and Animated
          if (effect == "off") {
            uint32_t colors[12] = {0};
            id(respeaker).set_led_ring(colors);
          } else {
            id(last_led_update_time) = millis(); // Reset timer for smooth animation start
          }

  # Individual update scripts for each animated effect
  - id: update_breathe_effect
    then:
      - lambda: |-
          static float phase = 0.0f;
          uint32_t now = millis();
          float dt = (now - id(last_led_update_time)) / 1000.0f;
          id(last_led_update_time) = now;

          phase += dt * id(led_ring_speed);
          while (phase >= 1.0f) phase -= 1.0f;

          float master_brightness = id(led_ring_brightness).state;
          float breath_brightness = 0.5f * (1.0f + sinf(phase * 2.0f * M_PI)) * master_brightness;

          uint8_t r = (uint8_t)(id(led_ring_color_r) * 255.0f * breath_brightness);
          uint8_t g = (uint8_t)(id(led_ring_color_g) * 255.0f * breath_brightness);
          uint8_t b = (uint8_t)(id(led_ring_color_b) * 255.0f * breath_brightness);
          uint32_t current_color = (r << 16) | (g << 8) | b;

          uint32_t colors[12];
          for (int i = 0; i < 12; i++) colors[i] = current_color;
          id(respeaker).set_led_ring(colors);

  - id: update_rainbow_effect
    then:
      - lambda: |-
          static float hue_offset = 0.0f;
          uint32_t now = millis();
          float dt = (now - id(last_led_update_time)) / 1000.0f;
          id(last_led_update_time) = now;

          hue_offset += dt * id(led_ring_speed);
          if (hue_offset >= 1.0f) hue_offset -= 1.0f;

          constexpr int NUM_LEDS = 12;
          constexpr float HUE_STEP = 1.0f / NUM_LEDS;
          uint32_t colors[NUM_LEDS];
          float brightness = id(led_ring_brightness).state;

          float current_hue = hue_offset;
          for (int i = 0; i < NUM_LEDS; i++) {
            float r, g, b;
            if (current_hue >= 1.0f) current_hue -= 1.0f;
            hsv_to_rgb((int)(current_hue * 360.0f), 1.0f, brightness, r, g, b);
            colors[i] = ((uint8_t)(r * 255.0f) << 16) | ((uint8_t)(g * 255.0f) << 8) | ((uint8_t)(b * 255.0f));
            current_hue += HUE_STEP;
          }
          id(respeaker).set_led_ring(colors);

  - id: update_comet_cw_effect
    then:
      - lambda: |-
          static float comet_pos = 0.0f;
          uint32_t now = millis();
          float dt = (now - id(last_led_update_time)) / 1000.0f;
          id(last_led_update_time) = now;

          constexpr int NUM_LEDS = 12;
          constexpr int BASE_TAIL = 3;

          float leds_per_sec = id(led_ring_speed) * NUM_LEDS;
          comet_pos += dt * leds_per_sec;
          while (comet_pos >= NUM_LEDS) comet_pos -= NUM_LEDS;

          int head_index = (int)comet_pos;
          int tail_length = BASE_TAIL + (int)(id(led_ring_speed));
          if (tail_length > NUM_LEDS - 1) tail_length = NUM_LEDS - 1;

          uint32_t colors[NUM_LEDS] = {0};
          float brightness = id(led_ring_brightness).state;

          uint8_t head_r = (uint8_t)(id(led_ring_color_r) * 255.0f * brightness);
          uint8_t head_g = (uint8_t)(id(led_ring_color_g) * 255.0f * brightness);
          uint8_t head_b = (uint8_t)(id(led_ring_color_b) * 255.0f * brightness);

          colors[head_index % NUM_LEDS] = (head_r << 16) | (head_g << 8) | head_b;

          for (int i = 1; i <= tail_length; i++) {
            float tail_factor = (float)i / (tail_length + 1);
            float tail_brightness = (1.0f - tail_factor) * brightness;
            uint8_t r = (uint8_t)(id(led_ring_color_r) * 255.0f * tail_brightness);
            uint8_t g = (uint8_t)(id(led_ring_color_g) * 255.0f * tail_brightness);
            uint8_t b = (uint8_t)(id(led_ring_color_b) * 255.0f * tail_brightness);
            int tail_index = (head_index - i + NUM_LEDS) % NUM_LEDS;
            colors[tail_index] = (r << 16) | (g << 8) | b;
          }
          id(respeaker).set_led_ring(colors);

  - id: update_comet_ccw_effect
    then:
      - lambda: |-
          static float comet_pos = 0.0f;
          uint32_t now = millis();
          float dt = (now - id(last_led_update_time)) / 1000.0f;
          id(last_led_update_time) = now;

          constexpr int NUM_LEDS = 12;
          constexpr int BASE_TAIL = 3;

          float leds_per_sec = id(led_ring_speed) * NUM_LEDS;
          comet_pos -= dt * leds_per_sec;
          while (comet_pos < 0.0f) comet_pos += NUM_LEDS;

          int head_index = (int)comet_pos;
          int tail_length = BASE_TAIL + (int)(id(led_ring_speed));
          if (tail_length > NUM_LEDS - 1) tail_length = NUM_LEDS - 1;

          uint32_t colors[NUM_LEDS] = {0};
          float brightness = id(led_ring_brightness).state;

          uint8_t head_r = (uint8_t)(id(led_ring_color_r) * 255.0f * brightness);
          uint8_t head_g = (uint8_t)(id(led_ring_color_g) * 255.0f * brightness);
          uint8_t head_b = (uint8_t)(id(led_ring_color_b) * 255.0f * brightness);

          colors[head_index % NUM_LEDS] = (head_r << 16) | (head_g << 8) | head_b;

          for (int i = 1; i <= tail_length; i++) {
            float tail_factor = (float)i / (tail_length + 1);
            float tail_brightness = (1.0f - tail_factor) * brightness;
            uint8_t r = (uint8_t)(id(led_ring_color_r) * 255.0f * tail_brightness);
            uint8_t g = (uint8_t)(id(led_ring_color_g) * 255.0f * tail_brightness);
            uint8_t b = (uint8_t)(id(led_ring_color_b) * 255.0f * tail_brightness);
            int tail_index = (head_index + i) % NUM_LEDS;
            colors[tail_index] = (r << 16) | (g << 8) | b;
          }
          id(respeaker).set_led_ring(colors);

  - id: update_twinkle_effect
    then:
      - lambda: |-
          constexpr int NUM_LEDS = 12;
          static float led_brightness[NUM_LEDS] = {0.0f};
          static float led_fade_speed[NUM_LEDS] = {0.0f};

          uint32_t now = millis();
          float dt = (now - id(last_led_update_time)) / 1000.0f;
          id(last_led_update_time) = now;

          // Update existing twinkles
          for (int i = 0; i < NUM_LEDS; i++) {
            if (led_fade_speed[i] != 0.0f) {
              led_brightness[i] += led_fade_speed[i] * dt;
              if (led_fade_speed[i] > 0.0f && led_brightness[i] >= 1.0f) {
                led_brightness[i] = 1.0f;
                led_fade_speed[i] *= -1.0f;
              } else if (led_fade_speed[i] < 0.0f && led_brightness[i] <= 0.0f) {
                led_brightness[i] = 0.0f;
                led_fade_speed[i] = 0.0f;
              }
            }
          }

          // Start new twinkles
          float twinkle_chance = dt * id(led_ring_speed);
          if (random_float() < twinkle_chance) {
            int led_to_start = (int)(random_float() * NUM_LEDS);
            if (led_fade_speed[led_to_start] == 0.0f) {
              led_brightness[led_to_start] = 0.0f;
              float min_speed = 1.5f, max_speed = 3.0f;
              led_fade_speed[led_to_start] = min_speed + (random_float() * (max_speed - min_speed));
            }
          }

          // Render colors
          uint32_t colors[NUM_LEDS];
          float master_brightness = id(led_ring_brightness).state;
          uint8_t base_r = (uint8_t)(id(led_ring_color_r) * 255.0f);
          uint8_t base_g = (uint8_t)(id(led_ring_color_g) * 255.0f);
          uint8_t base_b = (uint8_t)(id(led_ring_color_b) * 255.0f);

          for (int i = 0; i < NUM_LEDS; i++) {
            float current_led_brightness = led_brightness[i] * master_brightness;
            uint8_t r = (uint8_t)(base_r * current_led_brightness);
            uint8_t g = (uint8_t)(base_g * current_led_brightness);
            uint8_t b = (uint8_t)(base_b * current_led_brightness);
            colors[i] = (r << 16) | (g << 8) | b;
          }
          id(respeaker).set_led_ring(colors);

  - id: update_timer_tick_effect
    then:
      - lambda: |-
          constexpr int NUM_LEDS = 12;
          static int tick_index = 0;

          uint32_t now = millis();
          // Only update tick position every 100ms to reduce I2C traffic
          static uint32_t last_tick_update = 0;
          if (now - last_tick_update >= 100) {
            tick_index = (tick_index - 1 + NUM_LEDS) % NUM_LEDS;
            last_tick_update = now;
          }

          uint32_t colors[NUM_LEDS] = {0};
          uint32_t seconds_left = id(first_active_timer).seconds_left;
          uint32_t total_seconds = id(first_active_timer).total_seconds;

          float timer_ratio = (float)NUM_LEDS * seconds_left / std::max(total_seconds, (uint32_t)1);

          float master_brightness = id(led_ring_brightness).state;
          uint8_t base_r = (uint8_t)(id(led_ring_color_r) * 255.0f);
          uint8_t base_g = (uint8_t)(id(led_ring_color_g) * 255.0f);
          uint8_t base_b = (uint8_t)(id(led_ring_color_b) * 255.0f);

          for (int i = 0; i < NUM_LEDS; i++) {
            float bar_brightness = clamp(timer_ratio - i, 0.0f, 1.0f);
            if (bar_brightness > 0.0f) {
              float tick_dip = (i == tick_index) ? 0.9f : 1.0f;
              float final_brightness = bar_brightness * tick_dip * master_brightness;
              uint8_t r = (uint8_t)(base_r * final_brightness);
              uint8_t g = (uint8_t)(base_g * final_brightness);
              uint8_t b = (uint8_t)(base_b * final_brightness);
              colors[i] = (r << 16) | (g << 8) | b;
            }
          }
          id(respeaker).set_led_ring(colors);

  - id: update_volume_display_effect
    then:
      - lambda: |-
          constexpr int NUM_LEDS = 12;
          uint32_t colors[NUM_LEDS] = {0};

          if (id(external_media_player).is_ready()) {
            bool is_muted = id(external_media_player).is_muted();
            float volume = id(external_media_player).volume;

            if (is_muted || volume == 0.0f) {
              uint32_t mute_color = (255 << 16); // Red
              colors[0] = mute_color;
              colors[6] = mute_color;
            } else {
              float num_leds_on = volume * NUM_LEDS;
              float master_brightness = id(led_ring_brightness).state;
              uint8_t base_r = (uint8_t)(id(led_ring_color_r) * 255.0f);
              uint8_t base_g = (uint8_t)(id(led_ring_color_g) * 255.0f);
              uint8_t base_b = (uint8_t)(id(led_ring_color_b) * 255.0f);

              for (int i = 0; i < NUM_LEDS; i++) {
                float brightness = clamp(num_leds_on - i, 0.0f, 1.0f);
                if (brightness > 0.0f) {
                  uint8_t r = (uint8_t)(base_r * brightness * master_brightness);
                  uint8_t g = (uint8_t)(base_g * brightness * master_brightness);
                  uint8_t b = (uint8_t)(base_b * brightness * master_brightness);
                  colors[i] = (r << 16) | (g << 8) | b;
                }
              }
            }
          }
          id(respeaker).set_led_ring(colors);

  - id: update_led_beam_effect
    then:
      - lambda: |-
          constexpr int NUM_LEDS = 12;
          constexpr int FADE_LEDS = 3;
          constexpr float TRANSITION_DURATION = 0.5f; // Duration of the smooth transition
          uint32_t colors[NUM_LEDS] = {0};

          uint32_t now = millis();
          float dt = (now - id(last_led_update_time)) / 1000.0f;
          id(last_led_update_time) = now;

          if (id(beam_direction).has_state()) {
            // CORRECTING THE OFFSET: add 5 from the sensor reading
            float target_pos = ((int)id(beam_direction).state + 5) % NUM_LEDS;
            float current_pos = id(animated_beam_position);

            // Calculate the shortest path around the circle
            float diff = target_pos - current_pos;
            if (diff > NUM_LEDS / 2.0f) {
              diff -= NUM_LEDS;
            } else if (diff < -NUM_LEDS / 2.0f) {
              diff += NUM_LEDS;
            }

            // Move current position towards target
            if (abs(diff) > 0.01f) {
              float move_speed = diff / TRANSITION_DURATION;
              current_pos += move_speed * dt;
            } else {
              current_pos = target_pos;
            }

            // Handle wrap-around for the animated position
            if (current_pos >= NUM_LEDS) current_pos -= NUM_LEDS;
            if (current_pos < 0.0f) current_pos += NUM_LEDS;

            id(animated_beam_position) = current_pos;

            // Render the smoothed beam
            float master_brightness = id(led_ring_brightness).state;
            uint8_t base_r = (uint8_t)(id(led_ring_color_r) * 255.0f);
            uint8_t base_g = (uint8_t)(id(led_ring_color_g) * 255.0f);
            uint8_t base_b = (uint8_t)(id(led_ring_color_b) * 255.0f);

            for (int i = 0; i < NUM_LEDS; i++) {
              // Calculate circular distance from current LED to the animated position
              float dist = abs(i - current_pos);
              if (dist > NUM_LEDS / 2.0f) {
                dist = NUM_LEDS - dist;
              }

              // Calculate brightness based on distance (linear falloff)
              float brightness_factor = 1.0f - (dist / (FADE_LEDS + 1.0f));
              brightness_factor = std::max(0.0f, brightness_factor);

              if (brightness_factor > 0.0f) {
                float final_brightness = brightness_factor * master_brightness;
                uint8_t r = (uint8_t)(base_r * final_brightness);
                uint8_t g = (uint8_t)(base_g * final_brightness);
                uint8_t b = (uint8_t)(base_b * final_brightness);
                colors[i] = (r << 16) | (g << 8) | b;
              }
            }
          }
          id(respeaker).set_led_ring(colors);

  # Master script controlling the LEDs, based on different conditions : initialization in progress, wifi and api connected and voice assistant phase.
  # For the sake of simplicity and re-usability, the script calls child scripts defined below.
  # This script will be called every time one of these conditions is changing.
  - id: control_leds
    mode: single  # Prevent multiple simultaneous executions
    then:
      - lambda: |
          // Cache expensive component checks
          static bool last_respeaker_failed = false;
          static bool last_wifi_connected = false;
          static bool last_api_connected = false;
          static int last_voice_phase = -1;
          static bool last_timer_ringing = false;
          static bool last_timer_active = false;
          static bool last_improv_ble = false;
          static bool last_init_progress = false;

          bool respeaker_failed = id(respeaker).is_failed();
          bool wifi_connected = id(wifi_id).is_connected();
          bool api_connected = id(api_id).is_connected();
          int voice_phase = id(voice_assistant_phase);
          bool new_timer_ringing = id(timer_ringing).state;
          bool improv_ble = id(improv_ble_in_progress);
          bool init_progress = id(init_in_progress);

          // Only update if something actually changed
          bool needs_update = (
            respeaker_failed != last_respeaker_failed ||
            wifi_connected != last_wifi_connected ||
            api_connected != last_api_connected ||
            voice_phase != last_voice_phase ||
            new_timer_ringing != last_timer_ringing ||
            improv_ble != last_improv_ble ||
            init_progress != last_init_progress
          );

          if (!needs_update) return;

          // Update cache
          last_respeaker_failed = respeaker_failed;
          last_wifi_connected = wifi_connected;
          last_api_connected = api_connected;
          last_voice_phase = voice_phase;
          last_timer_ringing = new_timer_ringing;
          last_improv_ble = improv_ble;
          last_init_progress = init_progress;

          if (respeaker_failed) {
            id(control_leds_respeaker_startup_failed).execute();
            return;
          }

          // Only check timers if we need to
          id(check_if_timers_active).execute();
          if (id(is_timer_active)){
            id(fetch_first_active_timer).execute();
          }

          // Continue with existing logic...
          if (improv_ble) {
            id(control_leds_improv_ble_state).execute();
          } else if (init_progress) {
            id(control_leds_init_state).execute();
          } else if (!wifi_connected || !api_connected){
            id(control_leds_no_ha_connection_state).execute();
          } else if (new_timer_ringing) {
            id(control_leds_timer_ringing).execute();
          } else if (voice_phase == ${voice_assist_waiting_for_command_phase_id}) {
            id(control_leds_voice_assistant_waiting_for_command_phase).execute();
          } else if (voice_phase == ${voice_assist_listening_for_command_phase_id}) {
            id(control_leds_voice_assistant_listening_for_command_phase).execute();
          } else if (voice_phase == ${voice_assist_thinking_phase_id}) {
            id(control_leds_voice_assistant_thinking_phase).execute();
          } else if (voice_phase == ${voice_assist_replying_phase_id}) {
            id(control_leds_voice_assistant_replying_phase).execute();
          } else if (voice_phase == ${voice_assist_error_phase_id}) {
            id(control_leds_voice_assistant_error_phase).execute();
          } else if (voice_phase == ${voice_assist_not_ready_phase_id}) {
            id(control_leds_voice_assistant_not_ready_phase).execute();
          } else if (id(is_timer_active)) {
            id(control_leds_timer_ticking).execute();
          } else if (voice_phase == ${voice_assist_idle_phase_id}) {
            id(control_leds_voice_assistant_idle_phase).execute();
          }

  # Script executed if respeaker startup failed
  - id: control_leds_respeaker_startup_failed
    then:
      - script.execute:
          id: led_set_effect
          effect: "breathe"
          r: 0.7
          g: 0.0
          b: 0.0
          speed: 0.5

  # Script executed during Improv BLE
  - id: control_leds_improv_ble_state
    then:
      - script.execute:
          id: led_set_effect
          effect: "twinkle"
          r: 1.0
          g: 0.89
          b: 0.71
          speed: 10.0

  # Script executed during initialization
  - id: control_leds_init_state
    then:
      - if:
          condition:
            wifi.connected:
          then:
            - script.execute:
                id: led_set_effect
                effect: "twinkle"
                r: 0.09
                g: 0.73
                b: 0.95
                speed: 20.0
          else:
            - script.execute:
                id: led_set_effect
                effect: "twinkle"
                r: 0.09
                g: 0.73
                b: 0.95
                speed: 4.0

  # Script executed when the device has no connection to Home Assistant
  - id: control_leds_no_ha_connection_state
    then:
      - script.execute:
          id: led_set_effect
          effect: "twinkle"
          r: 1.0
          g: 0.0
          b: 0.0
          speed: 10.0

  # Script executed when the voice assistant is waiting for a command (After the wake word)
  - id: control_leds_voice_assistant_waiting_for_command_phase
    then:
      - lambda: |
          id(animated_beam_position) = id(beam_direction).state;
      - script.execute:
          id: led_set_effect
          effect: "led_beam"
          r: 0.5
          g: 0.0
          b: 0.5
          speed: 0.0

  # Script executed when the voice assistant is listening to a command
  - id: control_leds_voice_assistant_listening_for_command_phase
    then:
      - script.execute:
          id: led_set_effect
          effect: "led_beam"
          r: 0.8
          g: 0.0
          b: 0.8
          speed: 0.0

  # Script executed when the voice assistant is thinking to a command
  - id: control_leds_voice_assistant_thinking_phase
    then:
      - script.execute:
          id: led_set_effect
          effect: "breathe"
          r: 0.6
          g: 0.0
          b: 0.6
          speed: 1.0

  # Script executed when the voice assistant is replying to a command
  - id: control_leds_voice_assistant_replying_phase
    then:
      - script.execute:
          id: led_set_effect
          effect: "comet_ccw"
          r: 0.6
          g: 0.0
          b: 0.6
          speed: 1.0

  # Script executed when the voice assistant is in error
  - id: control_leds_voice_assistant_error_phase
    then:
      - script.execute:
          id: led_set_effect
          effect: "breathe"
          r: 1.0
          g: 0.0
          b: 0.0
          speed: 3.0

  # Script executed when the voice assistant is not ready
  - id: control_leds_voice_assistant_not_ready_phase
    then:
      - script.execute:
          id: led_set_effect
          effect: "twinkle"
          r: 1.0
          g: 0.0
          b: 0.0
          speed: 5.0

  # Script executed when the volume is changed
  - id: control_leds_volume_changed
    mode: restart
    then:
      - lambda: |-
          id(volume_display_active) = true;
      - delay: 2s
      - lambda: |-
          id(volume_display_active) = false;

  # Script executed when the timer is ringing, to control the LEDs
  - id: control_leds_timer_ringing
    then:
      - script.execute:
          id: led_set_effect
          effect: "breathe"
          r: 0.6
          g: 0.0
          b: 0.6
          speed: 5.0

  # Script executed when the timer is ticking, to control the LEDs
  - id: control_leds_timer_ticking
    then:
      - script.execute:
          id: led_set_effect
          effect: "timer_tick"
          r: 0.6
          g: 0.0
          b: 0.6
          speed: 1.0

  # Script executed when the voice assistant is idle (waiting for a wake word)
  - id: control_leds_voice_assistant_idle_phase
    then:
      - script.execute:
          id: led_set_effect
          effect: "off"
          r: 0.0
          g: 0.0
          b: 0.0
          speed: 0.0

  # Script executed when the timer is ringing, to playback sounds.
  - id: ring_timer
    then:
      - script.execute: enable_repeat_one
      - script.execute:
          id: play_sound
          priority: true
          sound_file: !lambda return id(timer_finished_sound);

  # Script executed when the timer is ringing, to repeat the timer finished sound.
  - id: enable_repeat_one
    then:
      # Turn on the repeat mode and pause for 500 ms between playlist items/repeats
      - lambda: |-
            id(external_media_player)
              ->make_call()
              .set_command(media_player::MediaPlayerCommand::MEDIA_PLAYER_COMMAND_REPEAT_ONE)
              .set_announcement(true)
              .perform();
            id(external_media_player)->set_playlist_delay_ms(speaker::AudioPipelineType::ANNOUNCEMENT, 500);

  # Script execute when the timer is done ringing, to disable repeat mode.
  - id: disable_repeat
    then:
      # Turn off the repeat mode and pause for 0 ms between playlist items/repeats
      - lambda: |-
            id(external_media_player)
              ->make_call()
              .set_command(media_player::MediaPlayerCommand::MEDIA_PLAYER_COMMAND_REPEAT_OFF)
              .set_announcement(true)
              .perform();
            id(external_media_player)->set_playlist_delay_ms(speaker::AudioPipelineType::ANNOUNCEMENT, 0);

  # Script executed when we want to play sounds on the device.
  - id: play_sound
    parameters:
      priority: bool
      sound_file: "audio::AudioFile*"
    then:
      - lambda: |-
          if (priority) {
            id(external_media_player)
              ->make_call()
              .set_command(media_player::MediaPlayerCommand::MEDIA_PLAYER_COMMAND_STOP)
              .set_announcement(true)
              .perform();
          }
          if ( (id(external_media_player).state != media_player::MediaPlayerState::MEDIA_PLAYER_STATE_ANNOUNCING ) || priority) {
            id(external_media_player)
              ->play_file(sound_file, true, false);
          }

  # Script used to fetch the first active timer (Stored in global first_active_timer)
  - id: fetch_first_active_timer
    mode: single
    then:
      - lambda: |
          static uint32_t last_fetch_time = 0;
          uint32_t now = millis();

          // Only fetch every 500ms to reduce overhead
          if (now - last_fetch_time < 500) return;
          last_fetch_time = now;

          const auto timers = id(va).get_timers();
          if (timers.empty()) return;

          auto output_timer = timers.begin()->second;
          for (auto &iterable_timer : timers) {
            if (iterable_timer.second.is_active && 
                iterable_timer.second.seconds_left <= output_timer.seconds_left) {
              output_timer = iterable_timer.second;
            }
          }
          id(first_active_timer) = output_timer;

  # Script used to check if a timer is active (Stored in global is_timer_active)
  - id: check_if_timers_active
    then:
      - lambda: |
          const auto timers = id(va).get_timers();
          bool output = false;
          if (timers.size() > 0) {
            for (auto &iterable_timer : timers) {
              if(iterable_timer.second.is_active) {
                output = true;
              }
            }
          }
          id(is_timer_active) = output;

  # Script used activate the stop word if the TTS step is long.
  # Why is this wrapped on a script?
  #   Becasue we want to stop the sequence if the TTS step is faster than that.
  #   This allows us to prevent having the deactivation of the stop word before its own activation.
  - id: activate_stop_word_once
    then:
      - delay: 1s
      # Enable stop wake word
      - if:
          condition:
            switch.is_off: timer_ringing
          then:
            - micro_wake_word.enable_model: stop
            - wait_until:
                not:
                  media_player.is_announcing:
            - if:
                condition:
                  switch.is_off: timer_ringing
                then:
                  - micro_wake_word.disable_model: stop

  - id: check_alarm
    then:
      - lambda: |-
          id(publish_current_time).execute();
          // Check alarm
          if (id(alarm_on).state && id(alarm_time).has_state()) {
            // Get the stored alarm time from the sensor
            auto set_alarm_time = id(alarm_time).state;
            if (set_alarm_time.length() == 5 &&
              isdigit(set_alarm_time[0]) && isdigit(set_alarm_time[1]) &&
              isdigit(set_alarm_time[3]) && isdigit(set_alarm_time[4])) {
              auto alarm_hour = std::stoi(set_alarm_time.substr(0, 2));
              auto alarm_minute = std::stoi(set_alarm_time.substr(3, 2));

              // Trigger action if current time matches alarm time
              auto time_now = id(homeassistant_time).now();
              if (time_now.hour == alarm_hour && time_now.minute == alarm_minute) {
                auto action = id(alarm_action).state;
                if (action == "Play sound") {
                  id(timer_ringing).turn_on();
                } else if (action == "Send event") {
                  id(send_alarm_event).execute();
                } else if (action == "Sound and event") {
                  id(timer_ringing).turn_on();
                  id(send_alarm_event).execute();
                } 
              }
            } else {
              ESP_LOGW("alarm", "Incorrect alarm time setting");
            }
          }
  - id: send_alarm_event
    then:
      - homeassistant.event:
          event: esphome.alarm_ringing
  - id: send_tts_uri_event
    parameters:
      tts_uri: string
    then:
      - homeassistant.event:
          event: esphome.tts_uri
          data:
            uri: !lambda return tts_uri;
  - id: send_stt_text_event
    parameters:
      stt_text: string
    then:
      - homeassistant.event:
          event: esphome.stt_text
          data:
            text: !lambda return stt_text;
  - id: publish_current_time
    mode: single
    then:
      - lambda: |-
          static std::string last_time_string = "";
          auto time_now = id(homeassistant_time).now();
          std::string current_time_string = time_now.strftime("%H:%M");

          // Only publish if time actually changed
          if (current_time_string != last_time_string) {
            id(current_time).publish_state(current_time_string);
            last_time_string = current_time_string;
          }
```

</details>

**ä¸­å¤®ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ (led_set_effect)**

```yml
script:
  # =========================================================================
  # == Centralized script to control all LED effects ==
  # =========================================================================
  - id: led_set_effect
    mode: restart
    parameters:
      effect: std::string
      r: float
      g: float
      b: float
      speed: float
      ....
```

- ã™ã¹ã¦ã®LEDã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’ä¸€ç®‡æ‰€ã§ç®¡ç†ã—ã¾ã™ã€‚
- ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚¿ã‚¤ãƒ—ã€è‰²ï¼ˆR/G/Bï¼‰ã€é€Ÿåº¦ã‚’å‹•çš„ã«è¨­å®šã§ãã¾ã™ã€‚
- ã‚¹ãƒ ãƒ¼ã‚ºãªãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã®ãŸã‚ã«ã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ãƒˆã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’ä½¿ç”¨ã—ã¾ã™ã€‚
- ã‚ªãƒ•ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã¯å³åº§ã«LEDã‚’æ¶ˆç¯ã—ã¾ã™ã€‚

**å€‹åˆ¥ã‚¹ã‚¯ãƒªãƒ—ãƒˆ**

- å„ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆãƒ–ãƒªãƒ¼ã‚ºã€ãƒ¬ã‚¤ãƒ³ãƒœãƒ¼ã€ã‚³ãƒ¡ãƒƒãƒˆã€ãƒˆã‚¥ã‚¤ãƒ³ã‚¯ãƒ«ã€ã‚¿ã‚¤ãƒãƒ¼ãƒ†ã‚£ãƒƒã‚¯ã€ãƒœãƒªãƒ¥ãƒ¼ãƒ è¡¨ç¤ºã€LEDãƒ“ãƒ¼ãƒ ï¼‰ã«ã¯ç‹¬è‡ªã®ã‚¹ã‚¯ãƒªãƒ—ãƒˆãŒã‚ã‚Šã¾ã™ã€‚
- ã‚·ã‚¹ãƒ†ãƒ ã‚’ãƒ¢ã‚¸ãƒ¥ãƒ©ãƒ¼åŒ–ã—ã€ä¿å®ˆã—ã‚„ã™ãã—ã¾ã™ã€‚
- led_animation_intervalã¾ãŸã¯ä¸­å¤®ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã«ã‚ˆã£ã¦å®šæœŸçš„ã«ãƒˆãƒªã‚¬ãƒ¼ã•ã‚Œã¾ã™ã€‚

| ãƒ‡ãƒã‚¤ã‚¹çŠ¶æ…‹           | LEDã‚¨ãƒ•ã‚§ã‚¯ãƒˆ             |
|------------------------|----------------------|
| èµ·å‹•å¤±æ•—         | èµ¤ãƒ–ãƒªãƒ¼ã‚º           |
| Improv BLEãƒ¢ãƒ¼ãƒ‰        | æš–è‰²ãƒˆã‚¥ã‚¤ãƒ³ã‚¯ãƒ«          |
| åˆæœŸåŒ–         | é’ãƒˆã‚¥ã‚¤ãƒ³ã‚¯ãƒ«          |
| HAæ¥ç¶šãªã—       | èµ¤ãƒˆã‚¥ã‚¤ãƒ³ã‚¯ãƒ«           |
| éŸ³å£°ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆå¾…æ©Ÿ             | ç´«ãƒ“ãƒ¼ãƒ            |
| éŸ³å£°ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆèãå–ã‚Šä¸­           | æ˜ã‚‹ã„ç´«ãƒ“ãƒ¼ãƒ     |
| éŸ³å£°ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆæ€è€ƒä¸­            | ç´«ãƒ–ãƒªãƒ¼ã‚º        |
| éŸ³å£°ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆå¿œç­”ä¸­            | ç´«ã‚³ãƒ¡ãƒƒãƒˆ          |
| éŸ³å£°ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆã‚¨ãƒ©ãƒ¼               | èµ¤ãƒ–ãƒªãƒ¼ã‚º           |
| éŸ³å£°ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆã‚¢ã‚¤ãƒ‰ãƒ«                | LEDæ¶ˆç¯              |
| ã‚¿ã‚¤ãƒãƒ¼é³´å‹•          | ç´«é«˜é€Ÿãƒ–ãƒªãƒ¼ã‚º   |
| ãƒœãƒªãƒ¥ãƒ¼ãƒ å¤‰æ›´          | ä¸€æ™‚è¡¨ç¤º     |

#### LEDåˆ¶å¾¡ã®ä»•çµ„ã¿ï¼ˆãƒ•ãƒ­ãƒ¼æ¦‚è¦ï¼‰

1. **ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ãƒˆãƒªã‚¬ãƒ¼**

   - ä½•ã‹ãŒèµ·ã“ã£ãŸã¨ãï¼ˆä¾‹ï¼šèµ·å‹•å¤±æ•—ã€éŸ³å£°ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆèãå–ã‚Šä¸­ã€ã‚¿ã‚¤ãƒãƒ¼é³´å‹•ï¼‰ã€ã‚¹ã‚¯ãƒªãƒ—ãƒˆãŒå®Ÿè¡Œã•ã‚Œã¾ã™ã€‚
   - ãã®ã‚¹ã‚¯ãƒªãƒ—ãƒˆã¯**ä¸­å¤®LEDã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼**ï¼ˆ`led_set_effect`ï¼‰ã‚’å‘¼ã³å‡ºã—ã€ä»¥ä¸‹ã‚’æŒ‡ç¤ºã—ã¾ã™ï¼š

     - **ã©ã®ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ**ã‚’å®Ÿè¡Œã™ã‚‹ã‹ï¼ˆä¾‹ï¼šãƒ–ãƒªãƒ¼ã‚ºã€ãƒ¬ã‚¤ãƒ³ãƒœãƒ¼ã€ã‚³ãƒ¡ãƒƒãƒˆï¼‰
     - **ä½•è‰²**ã‹ï¼ˆRã€Gã€Bå€¤ï¼‰
     - **ã©ã®é€Ÿåº¦**ã‹ï¼ˆé€Ÿåº¦ï¼‰ã€‚

   èµ·å‹•ãŒå¤±æ•—ã—ãŸå ´åˆ â†’ `led_set_effect`ãŒã‚¨ãƒ•ã‚§ã‚¯ãƒˆ = *ãƒ–ãƒªãƒ¼ã‚º*ã€è‰² = èµ¤ã§å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚

2. **ä¸­å¤®ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ï¼ˆã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«ãƒ«ãƒ¼ãƒ—ï¼‰**

   - **50ms**ã”ã¨ï¼ˆ1ç§’é–“ã«20å›ï¼‰ã€`led_animation_interval`ãƒ«ãƒ¼ãƒ—ãŒ**ç¾åœ¨ã®ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ**ãŒä½•ã‹ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¾ã™ã€‚
   - ãã®ã‚¨ãƒ•ã‚§ã‚¯ãƒˆåã«åŸºã¥ã„ã¦ã€å¯¾å¿œã™ã‚‹ã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ãƒˆã‚¹ã‚¯ãƒªãƒ—ãƒˆã«**åˆ¶å¾¡ã‚’è»¢é€**ã—ã¾ã™ã€‚

     - ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ = *ãƒ–ãƒªãƒ¼ã‚º* â†’ `update_breathe_effect`ã‚’å®Ÿè¡Œã€‚
     - ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ = *ãƒ¬ã‚¤ãƒ³ãƒœãƒ¼* â†’ `update_rainbow_effect`ã‚’å®Ÿè¡Œã€‚
     - ãƒˆã‚¥ã‚¤ãƒ³ã‚¯ãƒ«ã€ã‚³ãƒ¡ãƒƒãƒˆã€ã‚¿ã‚¤ãƒãƒ¼ãƒ†ã‚£ãƒƒã‚¯ã€LEDãƒ“ãƒ¼ãƒ ãªã©ã‚‚åŒæ§˜ã€‚

ã“ã®ãƒ«ãƒ¼ãƒ—ã¯**ãƒ‡ã‚£ã‚¹ãƒ‘ãƒƒãƒãƒ£ãƒ¼**ã¨ã—ã¦æ©Ÿèƒ½ã—ã¾ã™ï¼š*æ¬¡ã«ã©ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’å®Ÿè¡Œã™ã‚‹ã‹*ã‚’æ±ºå®šã—ã¾ã™ã€‚

```yml

interval:
  - interval: 50ms
    id: led_animation_interval
    then:
      - lambda: |-
          if (id(volume_display_active)) {
            id(update_volume_display_effect).execute();
            return;
          }
          std::string effect = id(current_led_effect);
          if (effect == "off") {
            return;
          } else if (effect == "breathe") {
            id(update_breathe_effect).execute();
          } else if (effect == "rainbow") {
            id(update_rainbow_effect).execute();
          } else if (effect == "comet_cw") {
            id(update_comet_cw_effect).execute();
          } else if (effect == "comet_ccw") {
            id(update_comet_ccw_effect).execute();
          } else if (effect == "twinkle") {
            id(update_twinkle_effect).execute();
          } else if (effect == "timer_tick") {
            id(update_timer_tick_effect).execute();
          } else if (effect == "led_beam") {
            id(update_led_beam_effect).execute();
          }

```

3. **ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ãƒˆã‚¹ã‚¯ãƒªãƒ—ãƒˆ**

   - å„ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã«ã¯ã€ãƒ•ãƒ¬ãƒ¼ãƒ ã”ã¨ã«LEDã®è‰²ã‚’è¨ˆç®—ã™ã‚‹ç‹¬è‡ªã®ã‚¹ã‚¯ãƒªãƒ—ãƒˆãŒã‚ã‚Šã¾ã™ã€‚
   - ä¾‹ï¼š**ãƒ–ãƒªãƒ¼ã‚ºã‚¨ãƒ•ã‚§ã‚¯ãƒˆ**

     - ã‚µã‚¤ãƒ³æ³¢ã‚’ä½¿ç”¨ã—ã¦æ˜åº¦ã‚’ã‚¹ãƒ ãƒ¼ã‚ºã«ä¸Šä¸‹ã«ãƒ•ã‚§ãƒ¼ãƒ‰ã—ã¾ã™ã€‚
     - LEDãƒªãƒ³ã‚°ã®ã‚°ãƒ­ãƒ¼ãƒãƒ«è¨­å®šï¼ˆé€Ÿåº¦ã€æ˜åº¦ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã€R/G/Bè‰²ï¼‰ã§æ˜åº¦ã‚’ä¹—ç®—ã—ã¾ã™ã€‚
     - 12å€‹ã™ã¹ã¦ã®LEDã®è‰²é…åˆ—ã‚’æ§‹ç¯‰ã—ã¾ã™ã€‚
     - è‰²ã‚’Respeaker LEDãƒªãƒ³ã‚°ã«é€ä¿¡ã—ã¾ã™ã€‚

ä¾‹ï¼š

```yml

 # Individual update scripts for each animated effect
  - id: update_breathe_effect
    then:
      - lambda: |-
          static float phase = 0.0f;
          uint32_t now = millis();
          float dt = (now - id(last_led_update_time)) / 1000.0f;
          id(last_led_update_time) = now;

          phase += dt * id(led_ring_speed);
          while (phase >= 1.0f) phase -= 1.0f;

          float master_brightness = id(led_ring_brightness).state;
          float breath_brightness = 0.5f * (1.0f + sinf(phase * 2.0f * M_PI)) * master_brightness;

          uint8_t r = (uint8_t)(id(led_ring_color_r) * 255.0f * breath_brightness);
          uint8_t g = (uint8_t)(id(led_ring_color_g) * 255.0f * breath_brightness);
          uint8_t b = (uint8_t)(id(led_ring_color_b) * 255.0f * breath_brightness);
          uint32_t current_color = (r << 16) | (g << 8) | b;

          uint32_t colors[12];
          for (int i = 0; i < 12; i++) colors[i] = current_color;
          id(respeaker).set_led_ring(colors);

```

ã“ã‚Œã«ã‚ˆã‚Šã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãŒã‚¹ãƒ ãƒ¼ã‚ºã§å‹•çš„ã€ã‹ã¤ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºå¯èƒ½ã«ãªã‚Šã¾ã™ã€‚

### ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªè¨­å®š

**IÂ²Så…¥åŠ›/å‡ºåŠ›**

IÂ²Sï¼ˆInter-IC Soundï¼‰ã¯ã€ESP32ãŒã‚³ãƒ¼ãƒ‡ãƒƒã‚¯ã€ãƒã‚¤ã‚¯ãƒ­ãƒ•ã‚©ãƒ³ã€ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼ãªã©ã®ãƒãƒƒãƒ—ã«é«˜å“è³ªã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã‚’é€å—ä¿¡ã§ãã‚‹ãƒ‡ã‚¸ã‚¿ãƒ«æ¥ç¶šã§ã™ã€‚

```yml
i2s_audio:
  - id: i2s_output
    i2s_lrclk_pin: 
      number: GPIO7
      allow_other_uses: true
    i2s_bclk_pin:  
      number: GPIO8
      allow_other_uses: true
    # i2s_mclk_pin:  
    #   number: GPIO9
    #   allow_other_uses: true

  - id: i2s_input
    i2s_lrclk_pin:  
      number: GPIO7
      allow_other_uses: true
    i2s_bclk_pin:  
      number: GPIO8
      allow_other_uses: true
    # i2s_mclk_pin:  
    #   number: GPIO9
    #   allow_other_uses: true

```

**ãƒã‚¤ã‚¯ãƒ­ãƒ•ã‚©ãƒ³**

- IÂ²Sãƒã‚¤ã‚¯ãƒ­ãƒ•ã‚©ãƒ³ã‚¢ãƒ¬ã‚¤/ã‚³ãƒ¼ãƒ‡ãƒƒã‚¯ã‹ã‚‰ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã‚’ã‚­ãƒ£ãƒ—ãƒãƒ£ã—ã¾ã™ã€‚
- GPIO43ï¼šãƒã‚¤ã‚¯ãƒ­ãƒ•ã‚©ãƒ³ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªãƒ‡ãƒ¼ã‚¿ãŒå…¥åŠ›ã•ã‚Œã‚‹ãƒ”ãƒ³ã€‚
- ã‚µãƒ³ãƒ—ãƒ«ãƒ¬ãƒ¼ãƒˆ48 kHzã€32ãƒ“ãƒƒãƒˆï¼šé«˜å“è³ªéŒ²éŸ³ï¼ˆã‚¹ãƒ†ãƒ¬ã‚ªã€2ãƒãƒ£ãƒ³ãƒãƒ«ï¼‰ã€‚
- adc_type: externalï¼šå¤–éƒ¨ã‚³ãƒ¼ãƒ‡ãƒƒã‚¯ã‚’ä½¿ç”¨ï¼ˆESP32ã®å†…è”µADCã§ã¯ãªã„ï¼‰ã€‚
- i2s_mode: secondaryï¼šESP32ã¯ã‚³ãƒ¼ãƒ‡ãƒƒã‚¯ã®ã‚¯ãƒ­ãƒƒã‚¯ã«å¾“ã„ã¾ã™ï¼ˆã‚¹ãƒ¬ãƒ¼ãƒ–ãƒ¢ãƒ¼ãƒ‰ï¼‰ã€‚

```yml
microphone:
  - platform: i2s_audio
    id: i2s_mics
    i2s_din_pin: GPIO43
    adc_type: external
    pdm: false
    sample_rate: 48000
    bits_per_sample: 32bit
    i2s_mode: secondary
    i2s_audio_id: i2s_input
    channel: stereo
```

**ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼**

- ã‚³ãƒ¼ãƒ‡ãƒƒã‚¯ï¼ˆAIC3104 DACï¼‰çµŒç”±ã§ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼ã«ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã‚’é€ä¿¡ã—ã¾ã™ã€‚
- GPIO44ï¼šãƒ‡ã‚¸ã‚¿ãƒ«ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªãŒå‡ºåŠ›ã•ã‚Œã‚‹ãƒ”ãƒ³ã€‚
- 48 kHzã€32ãƒ“ãƒƒãƒˆã‚¹ãƒ†ãƒ¬ã‚ªï¼šé«˜å“è³ªå†ç”Ÿã€‚
- buffer_duration 100msï¼šã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã‚’ã‚¹ãƒ ãƒ¼ã‚ºã«ä¿ã¡ã¾ã™ï¼ˆã‚°ãƒªãƒƒãƒã‚’é˜²æ­¢ï¼‰ã€‚
- timeout: neverï¼šã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼ãƒãƒ£ãƒ³ãƒãƒ«ã‚’ç”Ÿã‹ã—ç¶šã‘ã¾ã™ï¼ˆã‚·ãƒ£ãƒƒãƒˆã‚ªãƒ•ã—ã¾ã›ã‚“ï¼‰ã€‚

```yml
speaker:
  # Hardware speaker output
  - platform: i2s_audio
    id: i2s_audio_speaker
    sample_rate: 48000
    i2s_mode: secondary
    i2s_dout_pin: GPIO44
    bits_per_sample: 32bit
    i2s_audio_id: i2s_output
    dac_type: external
    channel: stereo
    timeout: never
    buffer_duration: 100ms
    audio_dac: aic3104_dac
```

**ãƒŸã‚­ã‚µãƒ¼**

- è¤‡æ•°ã®ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã‚¹ãƒˆãƒªãƒ¼ãƒ ï¼ˆãƒ¡ãƒ‡ã‚£ã‚¢ + ã‚¢ãƒŠã‚¦ãƒ³ã‚¹ï¼‰ã‚’1ã¤ã®å‡ºåŠ›ã«çµåˆã—ã¾ã™ã€‚

```yml
  # Virtual speakers to combine the announcement and media streams together into one output
  - platform: mixer
    id: mixing_speaker
    output_speaker: i2s_audio_speaker
    num_channels: 2
    source_speakers:
      - id: announcement_mixing_input
        timeout: never
      - id: media_mixing_input
        timeout: never
```

**ãƒªã‚µãƒ³ãƒ—ãƒ©ãƒ¼**

- ã™ã¹ã¦ã®ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã‚½ãƒ¼ã‚¹ãŒã‚µãƒ³ãƒ—ãƒ«ãƒ¬ãƒ¼ãƒˆã¨ãƒ“ãƒƒãƒˆæ·±åº¦ã«ä¸€è‡´ã™ã‚‹ã“ã¨ã‚’ä¿è¨¼ã—ã¾ã™ã€‚

```yml
  # Vritual speakers to resample each pipelines' audio, if necessary, as the mixer speaker requires the same sample rate
  - platform: resampler
    id: announcement_resampling_speaker
    output_speaker: announcement_mixing_input
    sample_rate: 48000
    bits_per_sample: 16
  - platform: resampler
    id: media_resampling_speaker
    output_speaker: media_mixing_input
    sample_rate: 48000
    bits_per_sample: 16
```

**ãƒ¡ãƒ‡ã‚£ã‚¢ãƒ—ãƒ¬ãƒ¼ãƒ¤ãƒ¼**

- ãƒœãƒªãƒ¥ãƒ¼ãƒ ã€ãƒŸãƒ¥ãƒ¼ãƒˆã€å†ç”Ÿã€ãƒ€ãƒƒã‚­ãƒ³ã‚°ï¼ˆã‚¢ãƒŠã‚¦ãƒ³ã‚¹ä¸­ã®ãƒ¡ãƒ‡ã‚£ã‚¢ãƒœãƒªãƒ¥ãƒ¼ãƒ å‰Šæ¸›ï¼‰ã‚’åˆ¶å¾¡ã—ã¾ã™ã€‚
- ã‚¤ãƒ™ãƒ³ãƒˆç”¨ã®ãƒ—ãƒªãƒ­ãƒ¼ãƒ‰ã‚µã‚¦ãƒ³ãƒ‰ï¼ˆã‚¿ã‚¤ãƒãƒ¼ã€ã‚¦ã‚§ã‚¤ã‚¯ãƒ¯ãƒ¼ãƒ‰ã€ã‚¨ãƒ©ãƒ¼ï¼‰ã€‚

```yml
media_player:
  - platform: speaker
    id: external_media_player
    name: None
    internal: False
    volume_increment: 0.05
    volume_min: 0.0
    volume_max: 1.0
    ...
    ...
```

### Respeaker XVF3800çµ±åˆ

- i2cã‚¢ãƒ‰ãƒ¬ã‚¹ï¼š0x2C
- IDï¼šrespeaker
- ãƒã‚¤ã‚¯ãƒ­ãƒ•ã‚©ãƒ³ãƒŸãƒ¥ãƒ¼ãƒˆã‚¹ã‚¤ãƒƒãƒï¼š1ç§’ã”ã¨ã«æ›´æ–°ã€ãƒˆã‚°ãƒ«æ™‚ã«ã‚µã‚¦ãƒ³ãƒ‰å†ç”Ÿã€‚
- DFUãƒãƒ¼ã‚¸ãƒ§ãƒ³ãƒ¬ãƒãƒ¼ãƒˆï¼š120ç§’ã”ã¨ã«ãƒ•ã‚¡ãƒ¼ãƒ ã‚¦ã‚§ã‚¢ã‚’ãƒ¬ãƒãƒ¼ãƒˆã€‚
- ãƒ“ãƒ¼ãƒ æ–¹å‘ã‚»ãƒ³ã‚µãƒ¼ï¼šéŸ³å£°ãƒ“ãƒ¼ãƒ ã‚’è¿½è·¡ï¼ˆå†…éƒ¨ã®ã¿ï¼‰ã€‚
- ãƒ•ã‚¡ãƒ¼ãƒ ã‚¦ã‚§ã‚¢ç®¡ç†ï¼šå¿…è¦ã«å¿œã˜ã¦XVF3800ãƒ•ã‚¡ãƒ¼ãƒ ã‚¦ã‚§ã‚¢ã‚’è‡ªå‹•ãƒ•ãƒ©ãƒƒã‚·ãƒ¥ã€‚

```yml
respeaker_xvf3800:
  id: respeaker
  address: 0x2C
  mute_switch:
    id: mic_mute_switch
    name: "Microphone Mute"
    update_interval: 1s
    on_turn_on:
    ...
    ...
```

### å‚è€ƒè³‡æ–™/ãƒªãƒã‚¸ãƒˆãƒª

```yml
external_components:
  - source:
      type: git
      url: https://github.com/formatBCE/esphome
      ref: respeaker_microphone
    components:
      - i2s_audio
    refresh: 0s
  - source:
      type: git
      url: https://github.com/formatBCE/Respeaker-XVF3800-ESPHome-integration
      ref: main
    components: 
      - respeaker_xvf3800
      - aic3104
    refresh: 0s

```

- formatBCE/esphomeï¼šã‚«ã‚¹ã‚¿ãƒ IÂ²Sã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã€‚
- formatBCE/Respeaker-XVF3800-ESPHome-integrationï¼š
- XVF3800ãƒ‰ãƒ©ã‚¤ãƒãƒ¼
- AIC3104ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã‚³ãƒ¼ãƒ‡ãƒƒã‚¯ãƒ‰ãƒ©ã‚¤ãƒãƒ¼
- refresh: 0sï¼šå¸¸ã«ãƒªãƒã‚¸ãƒˆãƒªã‹ã‚‰æœ€æ–°ã‚³ãƒ¼ãƒ‰ã‚’å–å¾—ã€‚

### ãƒã‚¤ã‚¯ãƒ­ã‚¦ã‚§ã‚¤ã‚¯ãƒ¯ãƒ¼ãƒ‰

```yml
micro_wake_word:
  id: mww
  microphone:
    microphone: i2s_mics
    channels: 1
    # gain_factor: 4
  stop_after_detection: false
  ....
  ....
```

ã‚¦ã‚§ã‚¤ã‚¯ãƒ¯ãƒ¼ãƒ‰ï¼ˆã€ŒOkay Nabuã€ãªã©ï¼‰ã‚’æ¤œå‡ºã—ã€éŸ³å£°ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆã‚’é–‹å§‹ã—ã¾ã™ã€‚

- id: mww â†’ å‚ç…§åã€‚
- microphone: i2s_micsã€1ãƒãƒ£ãƒ³ãƒãƒ«ã€‚
- stop_after_detection: false â†’ ç¶™ç¶šçš„ã«èãç¶šã‘ã¾ã™ã€‚
- okay_nabu, kenobi, hey_jarvis, hey_mycroft, stopï¼ˆå†…éƒ¨åœæ­¢ã‚³ãƒãƒ³ãƒ‰ï¼›ç‹¬è‡ªã®ã‚³ãƒãƒ³ãƒ‰ã‚’è¿½åŠ å¯èƒ½ï¼‰ã€‚
- vad probability_cutoff: 0.05 â†’ éŸ³å£°æ„Ÿåº¦ã€‚

**æ¤œå‡ºæ™‚ï¼ˆãƒã‚¤ã‚¯ãŒãƒŸãƒ¥ãƒ¼ãƒˆã•ã‚Œã¦ã„ãªã„å ´åˆï¼‰**

- ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªã‚¿ã‚¤ãƒãƒ¼ã€ã‚¢ãƒŠã‚¦ãƒ³ã‚¹ã€ã¾ãŸã¯éŸ³å£°ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆã‚’åœæ­¢ã—ã¾ã™ã€‚
- ã‚¦ã‚§ã‚¤ã‚¯ã‚µã‚¦ãƒ³ãƒ‰ã‚’å†ç”Ÿã—ã¾ã™ï¼ˆæœ‰åŠ¹ãªå ´åˆï¼‰ã€‚
- ã‚³ãƒãƒ³ãƒ‰ç”¨ã®éŸ³å£°ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆã‚’é–‹å§‹ã—ã¾ã™ã€‚

### éŸ³å£°ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ

```yml
voice_assistant:
  id: va
  microphone:
    microphone: i2s_mics
    channels: 0
  media_player: external_media_player
  micro_wake_word: mww
  use_wake_word: false
  noise_suppression_level: 0
  ....
  ....
```

éŸ³å£°ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆï¼ˆVAï¼‰ã®å‹•ä½œã¨ç›¸äº’ä½œç”¨ã‚’åˆ¶å¾¡ã—ã¾ã™ã€‚

- **ãƒã‚¤ã‚¯ã¨ãƒ¡ãƒ‡ã‚£ã‚¢**: i2s_micsã¨å¤–éƒ¨ãƒ¡ãƒ‡ã‚£ã‚¢ãƒ—ãƒ¬ãƒ¼ãƒ¤ãƒ¼ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚
- **ã‚¦ã‚§ã‚¤ã‚¯ãƒ¯ãƒ¼ãƒ‰**: mwwã«ãƒªãƒ³ã‚¯ã•ã‚Œã¦ã„ã¾ã™ãŒã€ã‚¦ã‚§ã‚¤ã‚¯ãƒ¯ãƒ¼ãƒ‰ã¯ä¸è¦ã§ã™ï¼ˆuse_wake_word: falseï¼‰ã€‚
- **ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªè¨­å®š**: ãƒã‚¤ã‚ºæŠ‘åˆ¶ã‚ªãƒ•ã€è‡ªå‹•ã‚²ã‚¤ãƒ³0 dBã€é€šå¸¸éŸ³é‡ã€‚

#### ã‚¤ãƒ™ãƒ³ãƒˆ / ä½•ãŒèµ·ã“ã‚‹ã‹

- **on_client_connected**: VAã‚’é–‹å§‹ã€LEDã‚’æ›´æ–°ã€å¿…è¦ã«å¿œã˜ã¦ãƒã‚¤ã‚¯ã®ãƒŸãƒ¥ãƒ¼ãƒˆã‚’è§£é™¤ã€‚
- **on_client_disconnected**: VAã‚’åœæ­¢ã€LEDã‚’ãƒªã‚»ãƒƒãƒˆã€‚
- **on_error: LEDã«ã‚¨ãƒ©ãƒ¼çŠ¶æ…‹ã‚’è¡¨ç¤º**ï¼›ã‚¯ãƒ©ã‚¦ãƒ‰èªè¨¼ãŒå¤±æ•—ã—ãŸå ´åˆã¯ãƒ­ãƒ¼ã‚«ãƒ«ã‚µã‚¦ãƒ³ãƒ‰ã‚’å†ç”Ÿã€‚
- **on_start**: VAé–‹å§‹æ™‚ã«ãƒ¡ãƒ‡ã‚£ã‚¢éŸ³é‡ã‚’ä¸‹ã’ã¾ã™ï¼ˆãƒ€ãƒƒã‚­ãƒ³ã‚°ï¼‰ã€‚
- **on_listening / on_stt_vad_start / on_stt_vad_end**: ãƒªã‚¹ãƒ‹ãƒ³ã‚°ã¨æ€è€ƒä¸­ã«VAãƒ•ã‚§ãƒ¼ã‚ºã¨LEDã‚’æ›´æ–°ã€‚
- **on_intent_progress / on_tts_start / on_tts_end**: ç™ºè©±ã‚’å‡¦ç†ã€LEDã‚’æ›´æ–°ã€åœæ­¢ãƒ¯ãƒ¼ãƒ‰ã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’ãƒˆãƒªã‚¬ãƒ¼å¯èƒ½ã€‚
- **on_stt_end**: èªè­˜ã•ã‚ŒãŸãƒ†ã‚­ã‚¹ãƒˆã‚¤ãƒ™ãƒ³ãƒˆã‚’é€ä¿¡ã€‚
- **on_end**: VAã‚’åœæ­¢ã€LEDã‚’ãƒªã‚»ãƒƒãƒˆã€ãƒ€ãƒƒã‚­ãƒ³ã‚°ã‚’çµ‚äº†ã€‚

#### ã‚¿ã‚¤ãƒãƒ¼ã‚¤ãƒ™ãƒ³ãƒˆ

- on_timer_started / on_timer_updated / on_timer_cancelled / on_timer_finished / on_timer_tick:
  - ã‚¿ã‚¤ãƒãƒ¼ã®çŠ¶æ…‹ã¨åå‰ã‚’æ›´æ–°ã€‚
  - LEDã‚’æ›´æ–°ã€‚
  - ãƒ†ã‚£ãƒƒã‚­ãƒ³ã‚°ã‚¿ã‚¤ãƒãƒ¼ã®LEDæ›´æ–°ã‚’5ç§’ã”ã¨ã«å‰Šæ¸›ã€‚

## ç‰¹åˆ¥ãªè¬è¾

Seeed Studio ReSpeaker XVF3800ç”¨ã®ã“ã®ç´ æ™´ã‚‰ã—ã„YAMLãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆã—ã¦ãã‚ŒãŸFormatBCEã«æ„Ÿè¬ã„ãŸã—ã¾ã™ã€‚
å½¼ã®[GitHub](https://github.com/formatBCE/Respeaker-XVF3800-ESPHome-integration)ã§ã‚µãƒãƒ¼ãƒˆã—ã¦ãã ã•ã„

## æŠ€è¡“ã‚µãƒãƒ¼ãƒˆã¨è£½å“ãƒ‡ã‚£ã‚¹ã‚«ãƒƒã‚·ãƒ§ãƒ³

å¼Šç¤¾è£½å“ã‚’ãŠé¸ã³ã„ãŸã ãã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã™ï¼å¼Šç¤¾è£½å“ã§ã®ä½“é¨“ãŒå¯èƒ½ãªé™ã‚Šã‚¹ãƒ ãƒ¼ã‚ºã«ãªã‚‹ã‚ˆã†ã€ã•ã¾ã–ã¾ãªã‚µãƒãƒ¼ãƒˆã‚’æä¾›ã„ãŸã—ã¾ã™ã€‚ã•ã¾ã–ã¾ãªå¥½ã¿ã‚„ãƒ‹ãƒ¼ã‚ºã«å¯¾å¿œã™ã‚‹ãŸã‚ã€è¤‡æ•°ã®ã‚³ãƒŸãƒ¥ãƒ‹ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãƒãƒ£ãƒãƒ«ã‚’æä¾›ã—ã¦ã„ã¾ã™ã€‚

<div class="button_tech_support_container">
<a href="https://forum.seeedstudio.com/" class="button_forum"></a>
<a href="https://www.seeedstudio.com/contacts" class="button_email"></a>
</div>

<div class="button_tech_support_container">
<a href="https://discord.gg/eWkprNDMU7" class="button_discord"></a>
<a href="https://github.com/Seeed-Studio/wiki-documents/discussions/69" class="button_discussion"></a>
</div>
