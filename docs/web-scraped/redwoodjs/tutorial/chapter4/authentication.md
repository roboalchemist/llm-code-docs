# Source: https://docs.redwoodjs.com/docs/tutorial/chapter4/authentication

-   [![](data:image/svg+xml;base64,PHN2ZyB2aWV3Ym94PSIwIDAgMjQgMjQiIGNsYXNzPSJicmVhZGNydW1iSG9tZUljb25fWU5GVCI+PHBhdGggZD0iTTEwIDE5di01aDR2NWMwIC41NS40NSAxIDEgMWgzYy41NSAwIDEtLjQ1IDEtMXYtN2gxLjdjLjQ2IDAgLjY4LS41Ny4zMy0uODdMMTIuNjcgMy42Yy0uMzgtLjM0LS45Ni0uMzQtMS4zNCAwbC04LjM2IDcuNTNjLS4zNC4zLS4xMy44Ny4zMy44N0g1djdjMCAuNTUuNDUgMSAxIDFoM2MuNTUgMCAxLS40NSAxLTF6IiBmaWxsPSJjdXJyZW50Q29sb3IiPjwvcGF0aD48L3N2Zz4=)](/)
-   [Tutorial]
-   [Chapter 4]
-   [Authentication]

[Version: 8.8]

On this page

<div>

# Authentication

</div>

## An Admin Section[​](#an-admin-section "Direct link to An Admin Section") 

Having the admin screens at `/admin` is a reasonable thing to do. Let\'s update the routes to make that happen by updating the four routes where the URL begins with `/posts` to start with `/admin/posts` instead:

-   JavaScript
-   TypeScript

web/src/Routes.jsx

``` 
import  from '@redwoodjs/router'
import ScaffoldLayout from 'src/layouts/ScaffoldLayout'
import BlogLayout from 'src/layouts/BlogLayout'

const Routes = () =>  title="Posts" titleTo="posts" buttonLabel="New Post" buttonTo="newPost">
        <Route path="/admin/posts/new" page= name="newPost" />
        <Route path="/admin/posts//edit" page= name="editPost" />
        <Route path="/admin/posts/" page= name="post" />
        <Route path="/admin/posts" page= name="posts" />
      </Set>
      <Set wrap=>
        <Route path="/article/" page= name="article" />
        <Route path="/contact" page= name="contact" />
        <Route path="/about" page= name="about" />
        <Route path="/" page= name="home" />
      </Set>
      <Route notfound page= />
    </Router>
  )
}

export default Routes
```

web/src/Routes.tsx

``` 
import  from '@redwoodjs/router'
import ScaffoldLayout from 'src/layouts/ScaffoldLayout'
import BlogLayout from 'src/layouts/BlogLayout'

const Routes = () =>  title="Posts" titleTo="posts" buttonLabel="New Post" buttonTo="newPost">
        <Route path="/admin/posts/new" page= name="newPost" />
        <Route path="/admin/posts//edit" page= name="editPost" />
        <Route path="/admin/posts/" page= name="post" />
        <Route path="/admin/posts" page= name="posts" />
      </Set>
      <Set wrap=>
        <Route path="/article/" page= name="article" />
        <Route path="/contact" page= name="contact" />
        <Route path="/about" page= name="about" />
        <Route path="/" page= name="home" />
      </Set>
      <Route notfound page= />
    </Router>
  )
}

export default Routes
```

Head to [http://localhost:8910/admin/posts](http://localhost:8910/admin/posts) and our generated scaffold page should come up. Thanks to named routes we don\'t have to update any of the `<Link>`s that were generated by the scaffolds since the `name`s of the pages didn\'t change!

Having the admin at a different path is great, but nothing is stopping someone from just browsing to that new path and messing with our blog posts. How do we keep prying eyes away?

## Authentication[​](#authentication-1 "Direct link to Authentication") 

\"Authentication\" is a blanket term for all of the stuff that goes into making sure that a user, often identified with an email address and password, is allowed to access something. Authentication can be [famously fickle](https://www.rdegges.com/2017/authentication-still-sucks/) to do right both from a technical and developer-happiness standpoint.

\"Credentials\" are the pieces of information a user provides to prove they are who they say they are: commonly a username (usually email) and password.

Redwood includes two authentication paths out of the box:

-   Self-hosted, where user credentials are stored in your own database
-   Third-party hosted, where user credentials are stored with the third party

In both cases you end up with an authenticated user that you can access in both the web and api sides of your app.

Redwood includes [integrations](/docs/authentication) for several of the most popular third-party auth providers:

-   [Auth0](https://auth0.com/)
-   [Clerk](https://clerk.dev/)
-   [Netlify Identity](https://docs.netlify.com/visitor-access/identity/)
-   [Firebase\'s GoogleAuthProvider](https://firebase.google.com/docs/reference/js/v8/firebase.auth.GoogleAuthProvider)
-   [Supabase](https://supabase.io/docs/guides/auth)
-   [SuperTokens](https://supertokens.com)

As for our blog, we\'re going to use self-hosted authentication (named *dbAuth* in Redwood) since it\'s the simplest to get started with and doesn\'t involve any third party signups.

[![](data:image/svg+xml;base64,PHN2ZyB2aWV3Ym94PSIwIDAgMTQgMTYiPjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgZD0iTTcgMi4zYzMuMTQgMCA1LjcgMi41NiA1LjcgNS43cy0yLjU2IDUuNy01LjcgNS43QTUuNzEgNS43MSAwIDAgMSAxLjMgOGMwLTMuMTQgMi41Ni01LjcgNS43LTUuN3pNNyAxQzMuMTQgMSAwIDQuMTQgMCA4czMuMTQgNyA3IDcgNy0zLjE0IDctNy0zLjE0LTctNy03em0xIDNINnY1aDJWNHptMCA2SDZ2Mmgydi0yeiI+PC9wYXRoPjwvc3ZnPg==)]Authentication vs. Authorization

There are two terms which contain a lot of letters, starting with an \"A\" and ending in \"ation\" (which means you could rhyme them if you wanted to) that become involved in most discussions about login:

-   Authentication
-   Authorization

Here is how Redwood uses these terms:

-   **Authentication** deals with determining whether someone is who they say they are, generally by \"logging in\" with an email and password, or a third party provider like Auth0.
-   **Authorization** is whether a user (who has usually already been authenticated) is allowed to do something they want to do. This generally involves some combination of roles and permission checking before allowing access to a URL or feature of your site.

This section of the tutorial focuses on **Authentication** only. See [chapter 7 of the tutorial](/docs/tutorial/chapter7/rbac) to learn about Authorization in Redwood.

## Auth Setup[​](#auth-setup "Direct link to Auth Setup") 

As you probably have guessed, Redwood has a couple of generators to get you going. One installs the backend components needed for dbAuth, the other creates login, signup and forgot password pages.

Run this setup command to get the internals of dbAuth added to our app:

``` 
yarn rw setup auth dbAuth
```

When prompted to \"Enable WebAuthn support\", pick no---this is a separate piece of functionality we won\'t need for the tutorial. You\'ll see that the process creates several files and includes some post-install instructions for the last couple of customizations you\'ll need to make. Let\'s go through them now.

### Create a User Model[​](#create-a-user-model "Direct link to Create a User Model") 

First we\'ll need to add a couple of fields to our `User` model. We don\'t even have a `User` model yet, so we\'ll create one along with the required fields at the same time.

Open up `schema.prisma` and add:

api/db/schema.prisma

``` 
datasource db 

generator client 

model Post 

model Contact 

model User 
```

This gives us a user with a name and email, as well as four fields that dbAuth will control:

-   **hashedPassword**: stores the result of combining the user\'s password with a `salt` and then [hashed](https://searchsqlserver.techtarget.com/definition/hashing)
-   **salt**: a unique string that combines with the hashedPassword to prevent [rainbow table attacks](https://dev.to/salothom/rainbow-tables-why-to-add-salt-45l9)
-   **resetToken**: if the user forgets their password, dbAuth inserts a token in here that must be present when the user returns to reset their password
-   **resetTokenExpiresAt**: a timestamp after which the `resetToken` will be considered expired and no longer valid (the user will need to fill out the forgot password form again)

Let\'s create the user model by migrating the database, naming it something like \"create user\":

``` 
yarn rw prisma migrate dev
```

That\'s it for the database setup!

## Private Routes[​](#private-routes "Direct link to Private Routes") 

Try reloading the Posts admin and we\'ll see something that\'s 50% correct:

![image](https://user-images.githubusercontent.com/300/146462761-d21c93f0-289a-4e11-bccf-8e4e68f21438.png)

Going to the admin section now prevents a non-logged in user from seeing posts, great! This is the result of the `@requireAuth` directive in `api/src/graphql/posts.sdl.ts`: you\'re not authenticated so GraphQL will not respond to your request for data. But, ideally they wouldn\'t be able to see the admin pages themselves. Let\'s fix that with a new component in the Routes file, `<PrivateSet>`:

-   JavaScript
-   TypeScript

web/src/Routes.jsx

``` 
import  from '@redwoodjs/router'

import ScaffoldLayout from 'src/layouts/ScaffoldLayout'
import BlogLayout from 'src/layouts/BlogLayout'

import  from './auth'

const Routes = () => >
      <PrivateSet unauthenticated="home">
        <Set wrap= title="Posts" titleTo="posts" buttonLabel="New Post" buttonTo="newPost">
          <Route path="/admin/posts/new" page= name="newPost" />
          <Route path="/admin/posts//edit" page= name="editPost" />
          <Route path="/admin/posts/" page= name="post" />
          <Route path="/admin/posts" page= name="posts" />
        </Set>
      </PrivateSet>
      <Set wrap=>
        <Route path="/article/" page= name="article" />
        <Route path="/contact" page= name="contact" />
        <Route path="/about" page= name="about" />
        <Route path="/" page= name="home" />
      </Set>
      <Route notfound page= />
    </Router>
  )
}

export default Routes
```

web/src/Routes.tsx

``` 
import  from '@redwoodjs/router'

import ScaffoldLayout from 'src/layouts/ScaffoldLayout'
import BlogLayout from 'src/layouts/BlogLayout'

import  from './auth'

const Routes = () => >
      <PrivateSet unauthenticated="home">
        <Set wrap= title="Posts" titleTo="posts" buttonLabel="New Post" buttonTo="newPost">
          <Route path="/admin/posts/new" page= name="newPost" />
          <Route path="/admin/posts//edit" page= name="editPost" />
          <Route path="/admin/posts/" page= name="post" />
          <Route path="/admin/posts" page= name="posts" />
        </Set>
      </PrivateSet>
      <Set wrap=>
        <Route path="/article/" page= name="article" />
        <Route path="/contact" page= name="contact" />
        <Route path="/about" page= name="about" />
        <Route path="/" page= name="home" />
      </Set>
      <Route notfound page= />
    </Router>
  )
}

export default Routes
```

We wrap the routes we want to be private (that is, only accessible when logged in) in the `<PrivateSet>` component, and tell our app where to send them if they are unauthenticated. In this case they should go to the `home` route.

Try going back to [http://localhost:8910/admin/posts](http://localhost:8910/admin/posts) now and---yikes!

![Homepage showing user does not have permission to view](https://user-images.githubusercontent.com/300/146463430-f7bc7fc9-a966-4149-9cb6-382d89d9d636.png)

Well, we couldn\'t get to the admin pages, but we also can\'t see our blog posts any more. Do you know why we\'re seeing the same message here that we saw in the posts admin page?

It\'s because the `posts` query in `posts.sdl.ts` is used by both the homepage *and* the posts admin page. Since it has the `@requireAuth` directive, it\'s locked down and can only be accessed when logged in. But we *do* want people that aren\'t logged in to be able to view the posts on the homepage!

Now that our admin pages are behind a `<PrivateSet>` route, what if we set the `posts` query to be `@skipAuth` instead? Let\'s try:

-   JavaScript
-   TypeScript

api/src/graphql/posts.sdl.js

``` 
export const schema = gql`
  type Post 

  type Query 

  input CreatePostInput 

  input UpdatePostInput 

  type Mutation 
`
```

api/src/graphql/posts.sdl.ts

``` 
export const schema = gql`
  type Post 

  type Query 

  input CreatePostInput 

  input UpdatePostInput 

  type Mutation 
`
```

Reload the homepage and:

![image](https://user-images.githubusercontent.com/300/146463788-7ab8afbb-8cd8-4c16-b8d2-02a00bcd7b46.png)

They\'re back! Let\'s just check that if we click on one of our posts that we can see it\... UGH:

![image](https://user-images.githubusercontent.com/300/146463841-cb9c95b6-3cc8-4697-9056-97fdebb49c51.png)

This page shows a single post, using the `post` query, not `posts`! So, we need to `@skipAuth` on that one as well:

-   JavaScript
-   TypeScript

api/src/graphql/posts.sdl.js

``` 
export const schema = gql`
  type Post 

  type Query 

  input CreatePostInput 

  input UpdatePostInput 

  type Mutation 
`
```

api/src/graphql/posts.sdl.ts

``` 
export const schema = gql`
  type Post 

  type Query 

  input CreatePostInput 

  input UpdatePostInput 

  type Mutation 
`
```

Cross your fingers and reload!

![image](https://user-images.githubusercontent.com/300/146463959-c59c8721-484f-45de-a663-e6ab3b2591dc.png)

We\'re back in business! Once you add authentication into your app you\'ll probably run into several situations like this where you need to go back and forth, re-allowing access to some pages or queries that inadvertently got locked down by default. Remember, Redwood is secure by default---we\'d rather you accidentally expose too *little* of your app than too *much*!

Now that our pages are behind login, let\'s actually create a login page so that we can see them again.

[![](data:image/svg+xml;base64,PHN2ZyB2aWV3Ym94PSIwIDAgMTQgMTYiPjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgZD0iTTcgMi4zYzMuMTQgMCA1LjcgMi41NiA1LjcgNS43cy0yLjU2IDUuNy01LjcgNS43QTUuNzEgNS43MSAwIDAgMSAxLjMgOGMwLTMuMTQgMi41Ni01LjcgNS43LTUuN3pNNyAxQzMuMTQgMSAwIDQuMTQgMCA4czMuMTQgNyA3IDcgNy0zLjE0IDctNy0zLjE0LTctNy03em0xIDNINnY1aDJWNHptMCA2SDZ2Mmgydi0yeiI+PC9wYXRoPjwvc3ZnPg==)]Skipping auth altogether for `posts` and `post` feels bad somehow\...

Ahh, good eye. While posts don\'t currently expose any particularly secret information, what if we eventually add a field like `publishStatus` where you could mark a post as `draft` so that it doesn\'t show on the homepage. But, if you knew enough about GraphQL, you could easily request all posts in the database and be able to read all the drafts!

It would be more future-proof to create a *new* endpoint for public display of posts, something like `publicPosts` and `publicPost` that will have built-in logic to only ever return a minimal amount of data and leave the default `posts` and `post` queries returning all the data for a post, something that only the admin will have access to. (Or do the opposite: keep `posts` and `post` as public and create new `adminPosts` and `adminPost` endpoints that can contain sensitive information.)

## Login & Signup Pages[​](#login--signup-pages "Direct link to Login & Signup Pages") 

Yet another generator is here for you, this time one that will create pages for login, signup and forgot password pages:

``` 
yarn rw g dbAuth
```

[![](data:image/svg+xml;base64,PHN2ZyB2aWV3Ym94PSIwIDAgMTYgMTYiPjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgZD0iTTguODkzIDEuNWMtLjE4My0uMzEtLjUyLS41LS44ODctLjVzLS43MDMuMTktLjg4Ni41TC4xMzggMTMuNDk5YS45OC45OCAwIDAgMCAwIDEuMDAxYy4xOTMuMzEuNTMuNTAxLjg4Ni41MDFoMTMuOTY0Yy4zNjcgMCAuNzA0LS4xOS44NzctLjVhMS4wMyAxLjAzIDAgMCAwIC4wMS0xLjAwMkw4Ljg5MyAxLjV6bS4xMzMgMTEuNDk3SDYuOTg3di0yLjAwM2gyLjAzOXYyLjAwM3ptMC0zLjAwNEg2Ljk4N1Y1Ljk4N2gyLjAzOXY0LjAwNnoiPjwvcGF0aD48L3N2Zz4=)]warning

In the dbAuth setup steps you will see the option for \"Querying WebAuthn addition\...\" For now, either press enter to keep the default as \'false\' or type \'no\'. WebAuthn works, and is great, but we do not want to add it as part of the tutorial.

Again several pages will be created and some post-install instructions will describe next steps. But for now, try going to [http://localhost:8910/login](http://localhost:8910/login):

![Generated login page](https://user-images.githubusercontent.com/300/146464693-a8fc4cf9-7fed-474f-8335-bb4c80fe0a5e.png)

That was easy! We don\'t have a user to login with, so try going to the signup page instead (there\'s a link under the Login button, or just head to [http://localhost:8910/signup](http://localhost:8910/signup)):

![Generated signup page](https://user-images.githubusercontent.com/300/146464785-a5996b19-27c5-493c-8fb3-1c753add31a6.png)

dbAuth defaults to the generic \"Username\" for the first field, but in our case the username will be an email address (we can change that label in a moment). Create yourself a user with email and password:

![image](https://user-images.githubusercontent.com/300/146464870-cb859f8b-175f-4170-8da4-5286facd1fe5.png)

And after clicking \"Signup\" you should end up back on the homepage, where everything looks the same! Yay? But now try going to [http://localhost:8910/admin/posts](http://localhost:8910/admin/posts):

![Posts admin](https://user-images.githubusercontent.com/300/146465485-c169a4b8-f398-47ec-8412-4fc15a666976.png)

Awesome! Signing up will automatically log you in (although this behavior [can be changed](/docs/auth/dbauth#signuphandler)) and if you look in the code for the `SignupPage` you\'ll see where the redirect to the homepage takes place (hint: check out line 21).

## Add a Logout Link[​](#add-a-logout-link "Direct link to Add a Logout Link") 

Now that we\'re logged in, how do we log out? Let\'s add a link to the `BlogLayout` so that it\'s present on all pages, and also include an indicator of who you\'re actually logged in as.

Redwood provides a [hook](/docs/authentication#destructuring-the-useauth-hook) `useAuth` which we can use in our components to determine the state of the user\'s login-ness, get their user info, and more. In `BlogLayout` we want to destructure the `isAuthenticated`, `currentUser` and `logOut` properties from `useAuth()`:

-   JavaScript
-   TypeScript

web/src/layouts/BlogLayout/BlogLayout.jsx

``` 
import  from '@redwoodjs/router'

import  from 'src/auth'

const BlogLayout = () =>  = useAuth()

  return (
    <>
      <header>
        <h1>
          <Link to=>Redwood Blog</Link>
        </h1>
        <nav>
          <ul>
            <li>
              <Link to=>Home</Link>
            </li>
            <li>
              <Link to=>About</Link>
            </li>
            <li>
              <Link to=>Contact</Link>
            </li>
          </ul>
        </nav>
      </header>
      <main></main>
    </>
  )
}

export default BlogLayout
```

web/src/layouts/BlogLayout/BlogLayout.tsx

``` 
import  from '@redwoodjs/router'

import  from 'src/auth'

type BlogLayoutProps = 

const BlogLayout = (: BlogLayoutProps) =>  = useAuth()

  return (
    <>
      <header>
        <h1>
          <Link to=>Redwood Blog</Link>
        </h1>
        <nav>
          <ul>
            <li>
              <Link to=>Home</Link>
            </li>
            <li>
              <Link to=>About</Link>
            </li>
            <li>
              <Link to=>Contact</Link>
            </li>
          </ul>
        </nav>
      </header>
      <main></main>
    </>
  )
}

export default BlogLayout
```

As you can probably tell by the names:

-   **isAuthenticated**: a boolean as to whether or not a user is logged in
-   **currentUser**: any details the app has on that user (more on this in a moment)
-   **logOut**: removes the user\'s session and logs them out

At the top right of the page, let\'s show the email address of the user (if they\'re logged in) as well as a link to log out. If they\'re not logged in, let\'s show a link to do just that:

-   JavaScript
-   TypeScript

web/src/layouts/BlogLayout/BlogLayout.jsx

``` 
import  from '@redwoodjs/router'

import  from 'src/auth'

const BlogLayout = () =>  = useAuth()

  return (
    <>
      <header>
        <div className="flex-between">
          <h1>
            <Link to=>Redwood Blog</Link>
          </h1>
          </span>
              <button type="button" onClick=>
                Logout
              </button>
            </div>
          ) : (
            <Link to=>Login</Link>
          )}
        </div>
        <nav>
          <ul>
            <li>
              <Link to=>Home</Link>
            </li>
            <li>
              <Link to=>About</Link>
            </li>
            <li>
              <Link to=>Contact</Link>
            </li>
          </ul>
        </nav>
      </header>
      <main></main>
    </>
  )
}

export default BlogLayout
```

web/src/layouts/BlogLayout/BlogLayout.tsx

``` 
import  from '@redwoodjs/router'

import  from 'src/auth'

type BlogLayoutProps = 

const BlogLayout = (: BlogLayoutProps) =>  = useAuth()

  return (
    <>
      <header>
        <div className="flex-between">
          <h1>
            <Link to=>Redwood Blog</Link>
          </h1>
          </span>
              <button type="button" onClick=>
                Logout
              </button>
            </div>
          ) : (
            <Link to=>Login</Link>
          )}
        </div>
        <nav>
          <ul>
            <li>
              <Link to=>Home</Link>
            </li>
            <li>
              <Link to=>About</Link>
            </li>
            <li>
              <Link to=>Contact</Link>
            </li>
          </ul>
        </nav>
      </header>
      <main></main>
    </>
  )
}

export default BlogLayout
```

![image](https://user-images.githubusercontent.com/300/146466685-cd91d9e6-e341-4698-81a6-cc404d6b3098.png)

Well, it\'s almost right! Where\'s our email address? By default, the function that determines what\'s in `currentUser` only returns that user\'s `id` field for security reasons (better to expose too little than too much, remember!). To add email to that list, check out `api/src/lib/auth.ts`:

-   JavaScript
-   TypeScript

api/src/lib/auth.js

``` 
import  from '@redwoodjs/graphql-server'
import  from './db'

export const getCurrentUser = async (session) => ,
    select: ,
  })
}

export const isAuthenticated = () => 

export const hasRole = (roles) => 

  const currentUserRoles = context.currentUser?.roles

  if (typeof roles === 'string')  else if (Array.isArray(currentUserRoles)) 
  }

  if (Array.isArray(roles))  else if (typeof currentUserRoles === 'string') 
  }

  // roles not found
  return false
}

export const requireAuth = ( = ) => 

  if (roles && !hasRole(roles)) 
}
```

api/src/lib/auth.ts

``` 
import  from '@redwoodjs/graphql-server'
import  from './db'

import type  from '@redwoodjs/api'

export const getCurrentUser = async (session: DbAuthSession<number>) => ,
    select: ,
  })
}

export const isAuthenticated = (): boolean => 

type AllowedRoles = string | string[] | undefined

export const hasRole = (roles: AllowedRoles): boolean => 

  const currentUserRoles = context.currentUser?.roles

  if (typeof roles === 'string')  else if (Array.isArray(currentUserRoles)) 
  }

  if (Array.isArray(roles))  else if (typeof currentUserRoles === 'string') 
  }

  // roles not found
  return false
}

export const requireAuth = (:  = ) => 

  if (roles && !hasRole(roles)) 
}
```

The `getCurrentUser()` function is where the magic happens: whatever is returned by this function is the content of `currentUser`, in both the web and api sides! In the case of dbAuth, the single argument passed in, `session`, contains the `id` of the user that\'s logged in. It then looks up the user in the database with Prisma, selecting just the `id`. Let\'s add `email` to this list:

-   JavaScript
-   TypeScript

api/src/lib/auth.js

``` 
export const getCurrentUser = async (session) => ,
    select: ,
  })
}
```

api/src/lib/auth.ts

``` 
export const getCurrentUser = async (session) => ,
    select: ,
  })
}
```

Now our email should be present at the upper right on the homepage:

![image](https://user-images.githubusercontent.com/300/146467129-c0446c1a-3648-4787-9675-d66eb80b8ab6.png)

Before we leave this file, take a look at `requireAuth()`. Remember when we talked about the `@requireAuth` directive and how when we first installed authentication we saw the message \"You don\'t have permission to do that.\"? This is where that came from!

## Session Secret[​](#session-secret "Direct link to Session Secret") 

After the initial `setup` command, which installed dbAuth, you may have noticed that an edit was made to the `.env` file in the root of your project. The `setup` script appended a new ENV var called `SESSION_SECRET` along with a big random string of numbers and letters. This is the encryption key for the cookies that are stored in the user\'s browser when they log in. This secret should never be shared, never checked into your repo, and should be re-generated for each environment you deploy to.

You can generate a new value with the `yarn rw g secret` command. It only outputs it to the terminal, you\'ll need to copy/paste to your `.env` file. Note that if you change this secret in a production environment, all users will be logged out on their next request because the cookie they currently have cannot be decrypted with the new key! They\'ll need to log in again to a new cookie encrypted with the new key.

## Wrapping Up[​](#wrapping-up "Direct link to Wrapping Up") 

Believe it or not, that\'s pretty much it for authentication! You can use the combination of `@requireAuth` and `@skipAuth` directives to lock down access to GraphQL query/mutations, and the `<PrivateSet>` component to restrict access to entire pages of your app. If you only want to restrict access to certain components, or certain parts of a component, you can always get `isAuthenticated` from the `useAuth()` hook and then render one thing or another.

Head over to the Redwood docs to read more about [self-hosted](/docs/auth/dbauth) and [third-party authentication](/docs/authentication#official-integrations).

## One More Thing[​](#one-more-thing "Direct link to One More Thing") 

Remember the GraphQL Playground exercise at the end of [Creating a Contact](/docs/tutorial/chapter3/saving-data#creating-a-contact)? Try to run that again now that authentication is in place and you should get that error we\'ve been talking about because of the `@requireAuth` directive! But, creating a *new* contact should still work just fine (because we\'re using `@skipAuth` on that mutation).

However, simulating a logged-in user through the GraphQL Playground is no picnic. But, we\'re working on improving the experience!

[![](data:image/svg+xml;base64,PHN2ZyBmaWxsPSJjdXJyZW50Q29sb3IiIGhlaWdodD0iMjAiIHdpZHRoPSIyMCIgdmlld2JveD0iMCAwIDQwIDQwIiBjbGFzcz0iaWNvbkVkaXRfWjlTdyIgYXJpYS1oaWRkZW49InRydWUiPjxnPjxwYXRoIGQ9Im0zNC41IDExLjdsLTMgMy4xLTYuMy02LjMgMy4xLTNxMC41LTAuNSAxLjItMC41dDEuMSAwLjVsMy45IDMuOXEwLjUgMC40IDAuNSAxLjF0LTAuNSAxLjJ6IG0tMjkuNSAxNy4xbDE4LjQtMTguNSA2LjMgNi4zLTE4LjQgMTguNGgtNi4zdi02LjJ6Ij48L3BhdGg+PC9nPjwvc3ZnPg==)Edit the latest version of this page](https://github.com/redwoodjs/graphql/blob/main/docs/docs/tutorial/chapter4/authentication.md)