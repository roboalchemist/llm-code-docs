DowntimesRead the 2025 State of Containers and Serverless Report!
Read the State of Containers and Serverless Report!

Home

Docs

API- 
- Agent
- API
- APM Tracing
- ContainersAutodiscovery
- Datadog Operator
- Dashboards
- Database Monitoring
- Datadog
- Datadog Site
- DevSecOps
- Incident Management
- IntegrationsAWS
- Azure
- Google Cloud
- Terraform
- Internal Developer Portal
- Logs
- Monitors
- Notebooks
- OpenTelemetry
- Profiler
- SearchProduct-Specific Search
- Session Replay
- SecurityApp and API Protection
- Cloud Security
- Cloud SIEM
- Code Security
- Serverless for AWS Lambda
- Software DeliveryCI Visibility
- Feature Flags
- Test Optimization
- Test Impact Analysis
- Synthetic Monitoring and TestingAPI Tests
- Browser Tests
- Mobile App Tests
- Continuous Testing
- Private Locations
- TagsAssigning Tags
- Unified Service Tagging
- Using Tags
- Workflow Automation
- Learning Center
- Support
- 
- 
- 
- Architecture
- IoT
- Supported PlatformsAIX
- Linux
- Ansible
- Chef
- Heroku
- MacOS
- Puppet
- SaltStack
- SCCM
- Windows
- From Source
- Log CollectionLog Agent tags
- Advanced Configurations
- Proxy
- Transport
- Multi-Line Detection
- ConfigurationCommands
- Configuration Files
- Log Files
- Status Page
- Network Traffic
- Proxy Configuration
- FIPS Compliance
- Dual Shipping
- Secrets Management
- Fleet AutomationRemote Agent Management
- TroubleshootingContainer Hostname Detection
- Debug Mode
- Agent Flare
- Agent Check Status
- NTP Issues
- Permission Issues
- Integrations Issues
- Site Issues
- Autodiscovery Issues
- Windows Container Issues
- Agent Runtime Configuration
- High CPU or Memory Consumption
- Guides
- Data Security
- Guides
- AuthorizationOAuth2 in Datadog
- Authorization Endpoints
- DogStatsDDatagram Format
- Unix Domain Socket
- High Throughput Data
- Data Aggregation
- DogStatsD Mapper
- Custom ChecksWriting a Custom Agent Check
- Writing a Custom OpenMetrics Check
- IntegrationsBuild an Integration with Datadog
- Create an Agent-based Integration
- Create an API-based Integration
- Create a Log Pipeline
- Integration Assets Reference
- Build a Marketplace Offering
- Create an Integration Dashboard
- Create a Monitor Template
- Create a Cloud SIEM Detection Rule
- Install Agent Integration Developer Tool
- Service ChecksSubmission - Agent Check
- Submission - DogStatsD
- Submission - API
- IDE PluginsJetBrains IDEs
- VS Code & Cursor
- CommunityLibraries
- Guides
- Getting StartedDatadog Example Application
- OpenTelemetry Demo Application
- Feature Compatibility
- Instrument Your ApplicationsOTel SDKs
- OTel APIs with Datadog SDKs
- OTel Instrumentation Libraries
- Configuration
- Send Data to DatadogDDOT Collector (Recommended)
- Other Setup Options
- Semantic MappingResource Attribute Mapping
- Metrics Mapping
- Infrastructure Host Mapping
- Hostname Mapping
- Service-entry Spans Mapping
- Ingestion Sampling
- Correlate DataLogs and Traces
- Metrics and Traces
- RUM and Traces
- DBM and Traces
- IntegrationsApache Metrics
- Apache Spark Metrics
- Collector Health Metrics
- Datadog Extension
- Docker Metrics
- HAProxy Metrics
- Host Metrics
- IIS Metrics
- Kafka Metrics
- Kubernetes Metrics
- MySQL Metrics
- NGINX Metrics
- Podman Metrics
- Runtime Metrics
- Trace Metrics
- Troubleshooting
- Guides and ResourcesProduce Delta Temporality Metrics
- Visualize Histograms as Heatmaps
- Migration Guides
- ReferenceTerms and Concepts
- Trace Context Propagation
- Trace IDs
- OTLP Metric Types
- Getting Started
- Plan
- Build
- Run
- 
- 
- Enterprise Configuration
- Datadog for Intune
- Shortcut Configurations
- Push Notifications
- Widgets
- Guides
- Data Directory
- Troubleshooting
- Install
- Using CoTerm
- Configuration Rules
- 
- Getting Started
- Account Management
- Components: Common
- Components: Azure
- Components: AWS
- Advanced
- FAQ
- APIAWS Accounts
- Azure Accounts
- Blueprints
- Budgets
- Teams
- Users
- Configure
- Dashboard List
- WidgetsConfiguration
- Widget Types
- Querying
- FunctionsAlgorithms
- Arithmetic
- Count
- Exclusion
- Interpolation
- Rank
- Rate
- Regression
- Rollup
- Smoothing
- Timeshift
- Beta
- Graph InsightsMetric Correlations
- Watchdog Explains
- Template Variables
- Overlays
- Annotations
- Guides
- SharingShared Dashboards
- Share Graphs
- Scheduled Reports
- Analysis FeaturesGetting Started
- Guides
- 
- 
- Functions and Operators
- Guides
- Draft Monitors
- Configure Monitors
- Monitor Templates
- Monitor TypesHost
- Metric
- Analysis
- Anomaly
- APM
- Audit Trail
- Change
- CI/CD & Test
- Cloud Cost
- Composite
- Database Monitoring
- Error Tracking
- Event
- Forecast
- Integration
- Live Process
- Logs
- Network
- Cloud Network Monitoring
- NetFlow
- Outlier
- Process Check
- Real User Monitoring
- Service Check
- SLO Alerts
- Synthetic Monitoring
- Watchdog
- NotificationsNotification Rules
- Variables
- DowntimesExamples
- Manage MonitorsSearch Monitors
- Check Summary
- Monitor StatusStatus Graphs
- Status Events
- Monitor Settings
- Monitor Quality
- Guides
- Monitor-based SLOs
- Metric-based SLOs
- Time Slice SLOs
- Error Budget Alerts
- Burn Rate Alerts
- Guides
- Custom MetricsMetric Type Modifiers
- Historical Metrics Ingestion
- Submission - Agent Check
- Submission - DogStatsD
- Submission - Powershell
- Submission - API
- OpenTelemetry MetricsOTLP Metric Types
- Query OpenTelemetry Metrics
- Metrics Types
- Distributions
- Overview
- ExplorerMetrics Units
- Summary
- Volume
- Advanced Filtering
- Nested Queries
- Composite Metrics Queries
- Derived Metrics
- Metrics Without Limits™
- Guides
- Alerts
- Impact Analysis
- RCA
- Insights
- Faulty Deployment Detection
- Faulty Cloud & SaaS API Detection
- Bits AI SREInvestigate issues
- Remediate issues
- Bits AI SRE integrations and settings
- Help Bits learn
- Chat with Bits AI SRE
- Bits AI Dev AgentSetup
- Chat with Bits AI
- MCP Server
- Software CatalogSet Up
- Entity Model
- Troubleshooting
- ScorecardsScorecard Configuration
- Custom Rules
- Using Scorecards
- Self-Service ActionsSoftware Templates
- Engineering ReportsReliability Overview
- Scorecards Performance
- DORA Metrics
- Custom Reports
- Developer Homepage
- Campaigns
- External Provider Status
- Plugins
- Integrations
- Use CasesAPI Management
- Cloud Cost Management
- App and API Protection
- Developer Onboarding
- Dependency Management
- Production Readiness
- Incident Response
- CI Pipeline Visibility
- Onboarding Guide
- Explorer
- Issue States
- Regression Detection
- Suspected Causes
- Error Grouping
- Bits AI Dev Agent
- Monitors
- Issue Correlation
- Identify Suspect Commits
- Auto Assign
- Issue Team Ownership
- Track Browser and Mobile ErrorsBrowser Error Tracking
- Collecting Browser Errors
- Mobile Crash Tracking
- Replay Errors
- Real User Monitoring
- Logs
- Track Backend ErrorsGetting Started
- Exception Replay
- Capturing Handled Errors
- APM
- Logs
- Manage Data Collection
- Troubleshooting
- Guides
- Feature Flags
- Ingest Events
- Pipelines and ProcessorsAggregation Key Processor
- Arithmetic Processor
- Date Remapper
- Category Processor
- Grok Parser
- Lookup Processor
- Remapper
- Service Remapper
- Status Remapper
- String Builder Processor
- ExplorerSearching
- Navigate the Explorer
- Customization
- Facets
- Attributes
- Notifications
- Analytics
- Saved Views
- Triage Inbox
- CorrelationConfiguration
- Triaging & Notifying
- Analytics
- Guides
- Declare an Incident
- Describe an Incident
- Response Team
- Notification
- Investigate an IncidentTimeline
- Follow-ups
- Incident AI
- Incident SettingsInformation
- Property Fields
- Responder Types
- Integrations
- Notification Rules
- Templates
- Incident Analytics
- IntegrationsSlack
- Microsoft Teams
- Jira
- ServiceNow
- Status Pages
- Atlassian Statuspage
- Datadog Clipboard
- Onboard a Team
- Trigger a PageLive Call Routing
- Routing Rules
- Escalation Policies
- Schedules
- Automations
- Profile Settings
- Guides
- 
- ProjectsSettings
- Create a Case
- Customization
- View and Manage Cases
- Notifications and Integrations
- Case Automation Rules
- Troubleshooting
- 
- Build Workflows
- Access and Authentication
- Trigger Workflows
- Variables and parameters
- ActionsWorkflow Logic
- Save and Reuse Actions
- Test and Debug
- JavaScript Expressions
- Track Workflows
- Limits
- Build Apps
- Access and Authentication
- Queries
- Variables
- Events
- ComponentsCustom Charts
- React Renderer
- Tables
- Reusable Modules
- JavaScript Expressions
- Embedded AppsInput Parameters
- Save and Reuse Actions
- Create and Manage Datastores
- Use Datastores with Apps and Workflows
- Automation Rules
- Access and Authentication
- 
- ConnectionsAWS Integration
- HTTP Request
- Private ActionsUse Private Actions
- Run a Script
- Update the Private Action Runner
- Private Action Credentials
- OverlaysInfrastructure
- Observability
- Security
- Cloud Cost Management
- Cloud Resources Schema
- Policies
- Resource Changes
- Setup
- Guides
- Setup
- Host List
- Monitoring ContainersConfiguration
- Container Images View
- Orchestrator Explorer
- Kubernetes Resource Utilization
- Kubernetes Autoscaling
- Amazon Elastic Container Explorer
- Autoscaling
- Docker and other runtimesAPM
- Log collection
- Tag extraction
- Integrations
- Prometheus
- Data Collected
- KubernetesInstallation
- Further Configuration
- Distributions
- APM
- Log collection
- Tag extraction
- Integrations
- Prometheus & OpenMetrics
- Control plane monitoring
- Data collected
- kubectl Plugin
- Datadog CSI Driver
- Data security
- Cluster AgentSetup
- Commands & Options
- Cluster Checks
- Endpoint Checks
- Admission Controller
- Amazon ECSAPM
- Log collection
- Tag extraction
- Data collected
- Managed Instances
- AWS Fargate with ECS
- Datadog OperatorAdvanced Install
- Configuration
- Custom Checks
- Data Collected
- Secret Management
- DatadogDashboard CRD
- DatadogMonitor CRD
- DatadogSLO CRD
- TroubleshootingDuplicate hosts
- Cluster Agent
- Cluster Checks
- HPA and Metrics Provider
- Admission Controller
- Log Collection
- Guides
- Increase Process Retention
- AWS LambdaInstrumentation
- Managed Instances
- Lambda Metrics
- Distributed Tracing
- Log Collection
- Remote Instrumentation
- Advanced Configuration
- Continuous Profiler
- Securing Functions
- Deployment Tracking
- OpenTelemetry
- Troubleshooting
- Lambda Web Adapter
- FIPS Compliance
- AWS Step FunctionsInstallation
- Merge Step Functions and Lambda Traces
- Enhanced Metrics
- Redrive Executions
- Distributed Map States
- Troubleshooting
- AWS Fargate
- Azure App ServiceLinux - Code
- Linux - Container
- Windows - Code
- Azure Container AppsIn-Container
- Sidecar
- Azure Functions
- Google Cloud RunContainers
- Functions
- Functions (1st generation)
- Libraries & Integrations
- Glossary
- Guides
- Cloud Network MonitoringSetup
- Network Health
- Network Analytics
- Network Map
- Guides
- Supported Cloud Services
- Terms and Concepts
- DNS Monitoring
- Network Device MonitoringSetup
- Integrations
- Profiles
- Configuration Management
- Maps
- SNMP Metrics Reference
- Troubleshooting
- Guides
- Terms and Concepts
- NetFlow MonitoringMonitors
- Network PathSetup
- List View
- Path View
- Guides
- Terms and Concepts
- Amazon S3
- Google Cloud Storage
- Azure Blob Storage
- Datadog Costs
- SetupAWS
- Azure
- Google Cloud
- Oracle
- SaaS Integrations
- Custom
- TagsTag Explorer
- Multisource Querying
- AllocationTag Pipelines
- Container Cost Allocation
- BigQuery Costs
- Custom Allocation Rules
- ReportingExplorer
- Scheduled Reports
- RecommendationsCustom Recommendations
- PlanningBudgets
- Commitment Programs
- Cost ChangesMonitors
- Anomalies
- Real-Time Costs
- APM Terms and Concepts
- Application InstrumentationSingle Step Instrumentation
- Manually managed SDKs
- Code-based Custom Instrumentation
- Dynamic Instrumentation
- Library Compatibility
- Library Configuration
- Configuration at Runtime
- Trace Context Propagation
- Serverless Application Tracing
- Proxy Tracing
- Span Tag Semantics
- Span Links
- APM Metrics CollectionTrace Metrics
- Runtime Metrics
- Trace Pipeline ConfigurationIngestion Mechanisms
- Ingestion Controls
- Adaptive Sampling
- Generate Metrics
- Trace Retention
- Usage Metrics
- Correlate Traces with Other TelemetryCorrelate DBM and Traces
- Correlate Logs and Traces
- Correlate RUM and Traces
- Correlate Synthetics and Traces
- Correlate Profiles and Traces
- Trace ExplorerSearch Spans
- Query Syntax
- Trace Queries
- Span Tags and Attributes
- Span Visualizations
- Trace View
- Tag Analysis
- Recommendations
- Code Origin for Spans
- Service ObservabilitySoftware Catalog
- Service Page
- Resource Page
- Deployment Tracking
- Service Map
- Inferred Services
- Remapping Rules for Inferred Entities
- Service Remapping Rules
- Service Override Removal
- APM Monitors
- Endpoint ObservabilityExplore Endpoints
- Monitor Endpoints
- Live Debugger
- Error TrackingIssue States
- Error Tracking Explorer
- Error Grouping
- Monitors
- Identify Suspect Commits
- Exception Replay
- Troubleshooting
- Data Security
- Guides
- TroubleshootingAgent Rate Limits
- Agent APM metrics
- Agent Resource Usage
- Correlated Logs
- PHP 5 Deep Call Stacks
- .NET diagnostic tool
- APM Quantization
- Go Compile-Time Instrumentation
- Tracer Startup Logs
- Tracer Debug Logs
- Connection Errors
- Enabling the ProfilerSupported Language and Tracer Versions
- Java
- Python
- Go
- Ruby
- Node.js
- .NET
- PHP
- C/C++/Rust
- Profile Types
- Profile Visualizations
- Investigate Slow Traces or Endpoints
- Compare Profiles
- Automated Analysis
- Profiler TroubleshootingJava
- Python
- Go
- Ruby
- Node.js
- .NET
- PHP
- C/C++/Rust
- Guides
- Agent Integration Overhead
- Setup Architectures
- Setting Up PostgresSelf-hosted
- RDS
- Aurora
- Google Cloud SQL
- AlloyDB
- Azure
- Supabase
- Heroku
- Advanced Configuration
- Troubleshooting
- Setting Up MySQLSelf-hosted
- RDS
- Aurora
- Google Cloud SQL
- Azure
- Advanced Configuration
- Troubleshooting
- Setting Up SQL ServerSelf-hosted
- RDS
- Azure
- Google Cloud SQL
- Troubleshooting
- Setting Up OracleSelf-hosted
- RDS
- RAC
- Exadata
- Autonomous Database
- Troubleshooting
- Setting Up Amazon DocumentDBAmazon DocumentDB
- Setting Up MongoDBSelf-hosted
- MongoDB Atlas
- Troubleshooting
- Connecting DBM and Traces
- Data Collected
- Exploring Database Hosts
- Exploring Query Metrics
- Exploring Query Samples
- Exploring Database Schemas
- Exploring Recommendations
- Troubleshooting
- Guides
- Setup
- Kafka Messages
- Schema Tracking
- Dead Letter Queues
- Metrics and Tags
- 
- Data WarehousesSnowflake
- Databricks
- BigQuery
- Business Intelligence IntegrationsTableau
- Sigma
- Metabase
- Power BI
- Databricks
- Airflow
- dbt
- Spark on Kubernetes
- Spark on Amazon EMR
- Spark on Google Dataproc
- Custom Jobs (OpenLineage)Datadog Agent for OpenLineage Proxy
- Application MonitoringBrowser
- Android and Android TV
- iOS and tvOS
- Flutter
- Kotlin Multiplatform
- React Native
- Roku
- Unity
- PlatformDashboards
- Monitors
- Generate Custom Metrics
- Exploring RUM DataSearch RUM Events
- Search Syntax
- Group
- Visualize
- Events
- Export
- Saved Views
- Watchdog Insights for RUM
- Correlate RUM with Other TelemetryCorrelate LLM with RUM
- Correlate Logs with RUM
- Correlate Profiling with RUM
- Correlate Synthetics with RUM
- Correlate Traces with RUM
- Feature Flag TrackingSetup
- Using Feature Flags
- Error TrackingExplorer
- Issue States
- Track Browser Errors
- Track Mobile Errors
- Error Grouping
- Monitors
- Identify Suspect Commits
- Troubleshooting
- RUM Without LimitsMetrics
- Retention Filters
- Operations Monitoring
- Ownership of Views
- Guides
- Data Security
- API TestingHTTP
- SSL
- DNS
- WebSocket
- TCP
- UDP
- ICMP
- GRPC
- Error codes
- Multistep API Testing
- Browser TestingRecording Steps
- Browser Testing Results
- Advanced Options for Steps
- Authentication in Browser Testing
- Network Path TestingTerms and Concepts
- Mobile Application TestingTesting Steps
- Testing Results
- Advanced Options for Steps
- Supported Devices
- Restricted Networks
- Settings
- Test Suites
- PlatformDashboards
- Metrics
- Test Coverage
- Private Locations
- Connect APM
- Settings
- Exploring Synthetics DataSaved Views
- Results Explorer
- Guides
- NotificationsTemplate Variables
- Conditional Alerting
- Advanced Notifications
- Integrate with Statuspage
- Troubleshooting
- Data Security
- Local and Staging EnvironmentsTesting Multiple Environments
- Testing With Proxy, Firewall, or VPN
- CI/CD IntegrationsConfiguration
- Azure DevOps Extension
- CircleCI Orb
- GitHub Actions
- GitLab
- Jenkins
- Bitrise (Upload Application)
- Bitrise (Run Tests)
- Settings
- Results Explorer
- Metrics
- Guides
- Troubleshooting
- Vizualizing with ChartsChart Basics
- Pathways Diagram
- Funnel Analysis
- Retention Analysis
- Analytics Explorer
- Dashboards
- Segments
- Managing Profiles
- ExperimentsDefine Metrics
- Reading Experiment Results
- Minimum Detectable Effects
- Guides
- Troubleshooting
- BrowserSetup
- Privacy Options
- Developer Tools
- Troubleshooting
- MobileSetup and Configuration
- Privacy Options
- Developer Tools
- Impact on App Performance
- Troubleshooting
- Playlists
- Heatmaps
- Pipeline VisibilityAWS CodePipeline
- Azure Pipelines
- Buildkite
- CircleCI
- Codefresh
- GitHub Actions
- GitLab
- Jenkins
- TeamCity
- Other CI Providers
- Custom Commands
- Custom Tags and Measures
- Search and Manage
- ExplorerSearch Syntax
- Search Pipeline Executions
- Export
- Saved Views
- [Monitors](https://docs.datadoghq.com/monitors/types/ci/?tab=pipelines)
- Guides
- Troubleshooting
- Deployment VisibilityArgo CD
- CI Providers
- Explore DeploymentsSearch Syntax
- Facets
- Saved Views
- FeaturesCode Changes Detection
- Rollback Detection
- [Monitors](https://docs.datadoghq.com/monitors/types/ci/?tab=deployments)
- Setup
- Explore
- Setup.NET
- Java and JVM Languages
- JavaScript and TypeScript
- Python
- Ruby
- Swift
- Go
- JUnit Report Uploads
- Network Settings
- Tests in Containers
- Repositories
- ExplorerSearch Syntax
- Search Test Runs
- Export
- Saved Views
- [Monitors](https://docs.datadoghq.com/monitors/types/ci/?tab=tests)
- Test Health
- Flaky Test Management
- Working with Flaky TestsEarly Flake Detection
- Auto Test Retries
- Test Impact AnalysisSetup
- How It Works
- Troubleshooting
- Developer Workflows
- Code Coverage
- Instrument Browser Tests with RUM
- Instrument Swift Tests with RUM
- Correlate Logs and Tests
- Guides
- Troubleshooting
- Setup
- Data Collected
- Setup
- SetupDeployment Data Sources
- Failure Data Sources
- Change Failure Detection
- Data Collected
- Client SDKsAndroid and Android TV
- iOS and tvOS
- JavaScript
- React
- Server SDKsGo
- Java
- Node.js
- Python
- Ruby
- MCP Server
- Guides
- Detection RulesOOTB Rules
- NotificationsRules
- Variables
- Suppressions
- Automation PipelinesMute
- Add to Security Inbox
- Set Due Date Rules
- Security Inbox
- Threat Intelligence
- Audit Trail
- Access Control
- Account Takeover Protection
- Ticketing Integrations
- Research Feed
- Guides
- Ingest and EnrichContent Packs
- Bring Your Own Threat Intelligence
- Open Cybersecurity Schema Framework
- Detect and MonitorOOTB Rules
- Custom Detection Rules
- Version History
- Suppressions
- Historical Jobs
- MITRE ATT&CK Map
- Triage and InvestigateInvestigate Security Signals
- Risk Insights
- IOC Explorer
- Investigator
- Respond and ReportSecurity Operational Metrics
- Guides
- Data Security
- Static Code Analysis (SAST)Setup
- GitHub Actions
- Generic CI Providers
- AI-Enhanced Static Code Analysis
- SAST Custom Rule Creation Tutorial
- SAST Custom Rules
- SAST Custom Rules Guide
- Static Code Analysis (SAST) rules
- Software Composition Analysis (SCA)Static Setup
- Runtime Setup
- Library Inventory
- Secret ScanningGitHub Actions
- Generic CI Providers
- Secret Validation
- Runtime Code Analysis (IAST)Setup
- Security Controls
- Infrastructure as Code (IaC) SecuritySetup
- Exclusions
- Rules
- Developer Tool IntegrationsPull Request Comments
- PR Gates
- IDE Plugins
- Git Hooks
- Troubleshooting
- Guides
- SetupSupported Deployment Types
- Agentless Scanning
- Deploy the Agent
- Set Up CloudTrail Logs
- Set Up without Infrastructure Monitoring
- Deploy via Cloud Integrations
- Security Graph
- MisconfigurationsManage Compliance Rules
- Create Custom Rules
- Manage Compliance Posture
- Explore Misconfigurations
- Kubernetes Security Posture Management
- Identity Risks
- VulnerabilitiesHosts and Containers Compatibility
- OOTB Rules
- Review and RemediateMute Issues
- Automate Security Workflows
- Create Jira Issues
- Severity Scoring
- Guides
- TroubleshootingVulnerabilities
- Terms and Concepts
- How It WorksThreat Intelligence
- Trace Qualification
- User Monitoring and Protection
- Setup
- Overview
- Security SignalsAttackers Explorer
- Attacker Fingerprint
- Attacker Clustering
- Users Explorer
- PoliciesCustom Rules
- OOTB Rules
- In-App WAF Rules
- Tracing Library Configuration
- Exploit Prevention
- WAF Integrations
- API Security Inventory
- Guides
- Troubleshooting
- SetupDeploy the Agent
- Workload Protection Agent Variables
- Detection RulesOOTB Rules
- Custom Rules
- Investigate Security Signals
- Investigate Agent Events
- Creating Agent Rule ExpressionsWriting Custom Rule Expressions
- Linux Syntax
- Windows Syntax
- Coverage and Posture ManagementHosts and Containers
- Serverless
- Coverage
- Guides
- Troubleshooting
- SetupTelemetry Data
- Cloud Storage
- Scanning RulesLibrary Rules
- Custom Rules
- Guides
- Quickstart
- InstrumentationAutomatic
- SDK Reference
- HTTP API
- OpenTelemetry
- MonitoringQuerying spans and traces
- Correlate with APM
- Cluster Map
- Agent Monitoring
- MCP Clients
- Prompt Tracking
- Metrics
- Cost
- EvaluationsManaged Evaluations
- Custom LLM-as-a-Judge
- External Evaluations
- Compatibility
- Export API
- Experiments
- Data Security and RBAC
- Terms and Concepts
- Guides
- ConfigurationExplore Templates
- Set Up Pipelines
- Install the Worker
- Live Capture
- Update Existing Pipelines
- Access Control
- SourcesAkamai DataStream
- Amazon Data Firehose
- Amazon S3
- Azure Event Hubs
- Datadog Agent
- Datadog Lambda Extension
- Datadog Lambda Forwarder
- Filebeat
- Fluent
- Google Pub/Sub
- HTTP Client
- HTTP Server
- OpenTelemetry
- Kafka
- Logstash
- Socket
- Splunk HEC
- Splunk TCP
- Sumo Logic Hosted Collector
- Syslog
- ProcessorsAdd Environment Variables
- Add hostname
- Custom Processor
- Deduplicate
- Edit fields
- Enrichment Table
- Filter
- Generate Metrics
- Grok Parser
- Parse JSON
- Parse XML
- Quota
- Reduce
- Remap to OCSF
- Sample
- Sensitive Data Scanner
- Split Array
- Tag Control
- Throttle
- DestinationsAmazon OpenSearch
- Amazon S3
- Amazon Security Lake
- Azure Storage
- CrowdStrike NG-SIEM
- Datadog CloudPrem
- Datadog Logs
- Datadog Metrics
- Elasticsearch
- Google Cloud Storage
- Google Pub/Sub
- Google SecOps
- HTTP Client
- Kafka
- Microsoft Sentinel
- New Relic
- OpenSearch
- SentinelOne
- Socket
- Splunk HEC
- Sumo Logic Hosted Collector
- Syslog
- PacksAkamai CDN
- Amazon CloudFront
- Amazon VPC Flow Logs
- AWS CloudTrail
- Cisco ASA
- Cloudflare
- F5
- Fastly
- Fortinet Firewall
- HAProxy Ingress
- Istio Proxy
- Netskope
- NGINX
- Okta
- Palo Alto Firewall
- Windows XML
- ZScaler ZIA DNS
- Zscaler ZIA Firewall
- Zscaler ZIA Tunnel
- Zscaler ZIA Web Logs
- Search Syntax
- Scaling and PerformanceHandling Load and Backpressure
- Scaling Best Practices
- Monitoring and TroubleshootingWorker CLI Commands
- Monitoring Pipelines
- Pipeline Usage Metrics
- Troubleshooting
- Guides and ResourcesUpgrade Worker Guide
- Log Collection & IntegrationsBrowser
- Android
- iOS
- Flutter
- React Native
- Roku
- Kotlin Multiplatform
- C#
- Go
- Java
- Node.js
- PHP
- Python
- Ruby
- OpenTelemetry
- Agent Integrations
- Other Integrations
- Log ConfigurationPipelines
- Processors
- Parsing
- Pipeline Scanner
- Attributes and Aliasing
- Generate Metrics
- Indexes
- Flex Logs
- Archives
- Rehydrate from Archives
- Archive Search
- Forwarding
- Log ExplorerLive Tail
- Search Logs
- Search Syntax
- Advanced Search
- Facets
- Calculated Fields
- Analytics
- Patterns
- Transactions
- Visualize
- Log Side Panel
- Export
- Watchdog Insights for Logs
- Saved Views
- Error TrackingError Tracking Explorer
- Issue States
- Track Browser and Mobile Errors
- Track Backend Errors
- Error Grouping
- Manage Data Collection
- Dynamic Sampling
- Monitors
- Identify Suspect Commits
- Troubleshooting
- Reports
- Guides
- Data Security
- TroubleshootingLive Tail
- Quickstart
- Architecture
- InstallationAWS EKS
- Azure AKS
- Install Locally with Docker
- Log IngestionDatadog Agent
- Observability Pipelines
- REST API
- ConfigurationDatadog Account
- AWS Configuration
- Azure Configuration
- Cluster Sizing
- Ingress
- Processing
- Reverse Connection
- Management
- Supported Features
- Troubleshooting
- Switching Between Orgs
- Organization SettingsUser Management
- Login Methods
- OAuth Apps
- Custom Organization Landing Page
- Service Accounts
- IP Allowlist
- Domain Allowlist
- Cross-Organization Visibility
- Access ControlGranular Access
- Permissions
- Data Access
- SSO with SAMLConfiguring SAML
- User Group Mapping
- Active Directory
- Auth0
- Entra ID
- Google
- LastPass
- Okta
- SafeNet
- Troubleshooting
- SCIMOkta
- Microsoft Entra ID
- API and Application Keys
- TeamsTeam Management
- Provision with GitHub
- Governance Console
- Multi-Factor Authentication
- Audit TrailEvents
- Forwarding
- Guides
- Safety Center
- Plan and UsageCost Details
- Usage Details
- BillingPricing
- Credit Card
- Product Allotments
- Usage Metrics
- Usage Attribution
- Custom Metrics
- Containers
- Log Management
- APM
- Serverless
- Real User Monitoring
- CI Visibility
- Incident Response
- AWS Integration
- Azure Integration
- Google Cloud Integration
- Alibaba Integration
- vSphere Integration
- Workflow Automation
- Multi-org Accounts
- Guides
- Cloud-based Authentication
- Agent
- Cloud SIEM
- Kubernetes
- Log Management
- Real User Monitoring
- Synthetic Monitoring
- Tracing
- PCI Compliance
- HIPAA Compliance
- Data Retention Periods
- Guides
- 
Docs > 
API Reference > 
DowntimesLanguage

English[English](https://docs.datadoghq.com/api/latest/downtimes/?lang_pref=en)
[Français](https://docs.datadoghq.com/fr/api/latest/downtimes/?lang_pref=fr)
[日本語](https://docs.datadoghq.com/ja/api/latest/downtimes/?lang_pref=ja)
[한국어](https://docs.datadoghq.com/ko/api/latest/downtimes/?lang_pref=ko)
[Español](https://docs.datadoghq.com/es/api/latest/downtimes/?lang_pref=es)Datadog Site

US1
US3
US5
EU
AP1
AP2
US1-FED# DowntimesDowntiming gives
you greater control over monitor notifications by allowing you to globally exclude
scopes from alerting. Downtime settings, which can be scheduled with start and
end times, prevent all alerting related to specified Datadog tags.**Note:** `curl` commands require url encoding.
## Get all downtimes- v1
- v2 (latest)
GET https://api.ap1.datadoghq.com/api/v1/downtimehttps://api.ap2.datadoghq.com/api/v1/downtimehttps://api.datadoghq.eu/api/v1/downtimehttps://api.ddog-gov.com/api/v1/downtimehttps://api.datadoghq.com/api/v1/downtimehttps://api.us3.datadoghq.com/api/v1/downtimehttps://api.us5.datadoghq.com/api/v1/downtime
### OverviewGet all scheduled downtimes. **Note:** This endpoint has been deprecated. Please use v2 endpoints.
This endpoint requires the `monitors_read` permission.OAuth apps require the `monitors_read` authorization scope to access this endpoint.
### Arguments#### Query StringsName
Type
Description
current_only
boolean
Only return downtimes that are active when the request is made.
with_creator
boolean
Return creator information.
### Response- 200
- 403
- 429
OK
- Model
- Example
Expand All
Field
Type
Description
active
boolean
If a scheduled downtime currently exists.
active_child
object
The downtime object definition of the active child for the original parent recurring downtime. This
field will only exist on recurring downtimes.active
boolean
If a scheduled downtime currently exists.
canceled
int64
If a scheduled downtime is canceled.
creator_id
int32
User ID of the downtime creator.
disabled
boolean
If a downtime has been disabled.
downtime_type
int32
`0` for a downtime applied on `*` or all,
`1` when the downtime is only scoped to hosts,
or `2` when the downtime is scoped to anything but hosts.end
int64
POSIX timestamp to end the downtime. If not provided,
the downtime is in effect indefinitely until you cancel it.id
int64
The downtime ID.
message
string
A message to include with notifications for this downtime.
Email notifications can be sent to specific users by using the same `@username` notation as events.monitor_id
int64
A single monitor to which the downtime applies.
If not provided, the downtime applies to all monitors.monitor_tags
[string]
A comma-separated list of monitor tags. For example, tags that are applied directly to monitors,
not tags that are used in monitor queries (which are filtered by the scope parameter), to which the downtime applies.
The resulting downtime applies to monitors that match ALL provided monitor tags.
For example, `service:postgres` **AND** `team:frontend`.mute_first_recovery_notification
boolean
If the first recovery notification during a downtime should be muted.
notify_end_states
[string]
States for which `notify_end_types` sends out notifications for.
default: `alert,no data,warn`
notify_end_types
[string]
If set, notifies if a monitor is in an alert-worthy state (`ALERT`, `WARNING`, or `NO DATA`)
when this downtime expires or is canceled. Applied to monitors that change states during
the downtime (such as from `OK` to `ALERT`, `WARNING`, or `NO DATA`), and to monitors that
already have an alert-worthy state when downtime begins.default: `expired`
parent_id
int64
ID of the parent Downtime.
recurrence
object
An object defining the recurrence of the downtime.
period
int32
How often to repeat as an integer.
For example, to repeat every 3 days, select a type of `days` and a period of `3`.rrule
string
The `RRULE` standard for defining recurring events (**requires to set "type" to rrule**)
For example, to have a recurring event on the first day of each month, set the type to `rrule` and set the `FREQ` to `MONTHLY` and `BYMONTHDAY` to `1`.
Most common `rrule` options from the iCalendar Spec are supported.**Note**: Attributes specifying the duration in `RRULE` are not supported (for example, `DTSTART`, `DTEND`, `DURATION`).
More examples available in this [downtime guide](https://docs.datadoghq.com/monitors/guide/suppress-alert-with-downtimes/?tab=api)type
string
The type of recurrence. Choose from `days`, `weeks`, `months`, `years`, `rrule`.
until_date
int64
The date at which the recurrence should end as a POSIX timestamp.
`until_occurences` and `until_date` are mutually exclusive.until_occurrences
int32
How many times the downtime is rescheduled.
`until_occurences` and `until_date` are mutually exclusive.week_days
[string]
A list of week days to repeat on. Choose from `Mon`, `Tue`, `Wed`, `Thu`, `Fri`, `Sat` or `Sun`.
Only applicable when type is weeks. First letter must be capitalized.scope
[string]
The scope(s) to which the downtime applies and must be in `key:value` format. For example, `host:app2`.
Provide multiple scopes as a comma-separated list like `env:dev,env:prod`.
The resulting downtime applies to sources that matches ALL provided scopes (`env:dev` **AND** `env:prod`).start
int64
POSIX timestamp to start the downtime.
If not provided, the downtime starts the moment it is created.timezone
string
The timezone in which to display the downtime's start and end times in Datadog applications.
updater_id
int32
ID of the last user that updated the downtime.
canceled
int64
If a scheduled downtime is canceled.
creator_id
int32
User ID of the downtime creator.
disabled
boolean
If a downtime has been disabled.
downtime_type
int32
`0` for a downtime applied on `*` or all,
`1` when the downtime is only scoped to hosts,
or `2` when the downtime is scoped to anything but hosts.end
int64
POSIX timestamp to end the downtime. If not provided,
the downtime is in effect indefinitely until you cancel it.id
int64
The downtime ID.
message
string
A message to include with notifications for this downtime.
Email notifications can be sent to specific users by using the same `@username` notation as events.monitor_id
int64
A single monitor to which the downtime applies.
If not provided, the downtime applies to all monitors.monitor_tags
[string]
A comma-separated list of monitor tags. For example, tags that are applied directly to monitors,
not tags that are used in monitor queries (which are filtered by the scope parameter), to which the downtime applies.
The resulting downtime applies to monitors that match ALL provided monitor tags.
For example, `service:postgres` **AND** `team:frontend`.mute_first_recovery_notification
boolean
If the first recovery notification during a downtime should be muted.
notify_end_states
[string]
States for which `notify_end_types` sends out notifications for.
default: `alert,no data,warn`
notify_end_types
[string]
If set, notifies if a monitor is in an alert-worthy state (`ALERT`, `WARNING`, or `NO DATA`)
when this downtime expires or is canceled. Applied to monitors that change states during
the downtime (such as from `OK` to `ALERT`, `WARNING`, or `NO DATA`), and to monitors that
already have an alert-worthy state when downtime begins.default: `expired`
parent_id
int64
ID of the parent Downtime.
recurrence
object
An object defining the recurrence of the downtime.
period
int32
How often to repeat as an integer.
For example, to repeat every 3 days, select a type of `days` and a period of `3`.rrule
string
The `RRULE` standard for defining recurring events (**requires to set "type" to rrule**)
For example, to have a recurring event on the first day of each month, set the type to `rrule` and set the `FREQ` to `MONTHLY` and `BYMONTHDAY` to `1`.
Most common `rrule` options from the iCalendar Spec are supported.**Note**: Attributes specifying the duration in `RRULE` are not supported (for example, `DTSTART`, `DTEND`, `DURATION`).
More examples available in this [downtime guide](https://docs.datadoghq.com/monitors/guide/suppress-alert-with-downtimes/?tab=api)type
string
The type of recurrence. Choose from `days`, `weeks`, `months`, `years`, `rrule`.
until_date
int64
The date at which the recurrence should end as a POSIX timestamp.
`until_occurences` and `until_date` are mutually exclusive.until_occurrences
int32
How many times the downtime is rescheduled.
`until_occurences` and `until_date` are mutually exclusive.week_days
[string]
A list of week days to repeat on. Choose from `Mon`, `Tue`, `Wed`, `Thu`, `Fri`, `Sat` or `Sun`.
Only applicable when type is weeks. First letter must be capitalized.scope
[string]
The scope(s) to which the downtime applies and must be in `key:value` format. For example, `host:app2`.
Provide multiple scopes as a comma-separated list like `env:dev,env:prod`.
The resulting downtime applies to sources that matches ALL provided scopes (`env:dev` **AND** `env:prod`).start
int64
POSIX timestamp to start the downtime.
If not provided, the downtime starts the moment it is created.timezone
string
The timezone in which to display the downtime's start and end times in Datadog applications.
updater_id
int32
ID of the last user that updated the downtime.
```
{
"active": true,
"active_child": {
"active": true,
"canceled": 1412799983,
"creator_id": 123456,
"disabled": false,
"downtime_type": 2,
"end": 1412793983,
"id": 1626,
"message": "Message on the downtime",
"monitor_id": 123456,
"monitor_tags": [
"*"
],
"mute_first_recovery_notification": false,
"notify_end_states": [
"alert",
"no data",
"warn"
],
"notify_end_types": [
"canceled",
"expired"
],
"parent_id": 123,
"recurrence": {
"period": 1,
"rrule": "FREQ=MONTHLY;BYSETPOS=3;BYDAY=WE;INTERVAL=1",
"type": "weeks",
"until_date": 1447786293,
"until_occurrences": 2,
"week_days": [
"Mon",
"Tue"
]
},
"scope": [
"env:staging"
],
"start": 1412792983,
"timezone": "America/New_York",
"updater_id": 123456
},
"canceled": 1412799983,
"creator_id": 123456,
"disabled": false,
"downtime_type": 2,
"end": 1412793983,
"id": 1625,
"message": "Message on the downtime",
"monitor_id": 123456,
"monitor_tags": [
"*"
],
"mute_first_recovery_notification": false,
"notify_end_states": [
"alert",
"no data",
"warn"
],
"notify_end_types": [
"canceled",
"expired"
],
"parent_id": 123,
"recurrence": {
"period": 1,
"rrule": "FREQ=MONTHLY;BYSETPOS=3;BYDAY=WE;INTERVAL=1",
"type": "weeks",
"until_date": 1447786293,
"until_occurrences": 2,
"week_days": [
"Mon",
"Tue"
]
},
"scope": [
"env:staging"
],
"start": 1412792983,
"timezone": "America/New_York",
"updater_id": 123456
}
```Forbidden
- Model
- Example
Error response object.
Expand All
Field
Type
Description
errors [*required*]
[string]
Array of errors returned by the API.
```
{
"errors": [
"Bad Request"
]
}
```Too many requests
- Model
- Example
Error response object.
Expand All
Field
Type
Description
errors [*required*]
[string]
Array of errors returned by the API.
```
{
"errors": [
"Bad Request"
]
}
```### Code Example- [Curl](?code-lang=curl#)
- [Python](?code-lang=python#)
- [Ruby](?code-lang=ruby#)
- [Rust](?code-lang=rust#)
- [Go](?code-lang=go#)
- [Java](?code-lang=java#)
- [Typescript](?code-lang=typescript#)
- [Ruby [legacy]](?code-lang=ruby-legacy#)
- [Python [legacy]](?code-lang=python-legacy#)

Get all downtimesCopy```

# Curl commandcurl -X GET "https://api.ap1.datadoghq.com"https://api.ap2.datadoghq.com"https://api.datadoghq.eu"https://api.ddog-gov.com"https://api.datadoghq.com"https://api.us3.datadoghq.com"https://api.us5.datadoghq.com/api/v1/downtime" \
-H "Accept: application/json" \
-H "DD-API-KEY: ${DD_API_KEY}" \
-H "DD-APPLICATION-KEY: ${DD_APP_KEY}"

```
Get all downtimes```
"""
Get all downtimes returns "OK" response
"""

from datadog_api_client import ApiClient, Configuration
from datadog_api_client.v1.api.downtimes_api import DowntimesApi

configuration = Configuration()
with ApiClient(configuration) as api_client:
api_instance = DowntimesApi(api_client)
response = api_instance.list_downtimes(
with_creator=True,
)

print(response)

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=python) and then save the example to `example.py` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" python3 "example.py"`
```
Get all downtimes```
# Get all downtimes returns "OK" response

require "datadog_api_client"
api_instance = DatadogAPIClient::V1::DowntimesAPI.new
opts = {
with_creator: true,
}
p api_instance.list_downtimes(opts)

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=ruby) and then save the example to `example.rb` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" rb "example.rb"`
```
Get all downtimes```
require 'dogapi'

api_key = '<DATADOG_API_KEY>'
app_key = '<DATADOG_APPLICATION_KEY>'

dog = Dogapi::Client.new(api_key, app_key)

# Get all downtimes
dog.get_all_downtimes

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=ruby-legacy) and then save the example to `example.rb` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" rb "example.rb"`
```
Get all downtimes```
// Get all downtimes returns "OK" response
use datadog_api_client::datadog;
use datadog_api_client::datadogV1::api_downtimes::DowntimesAPI;
use datadog_api_client::datadogV1::api_downtimes::ListDowntimesOptionalParams;

#[tokio::main]
async fn main() {
let configuration = datadog::Configuration::new();
let api = DowntimesAPI::with_config(configuration);
let resp = api
.list_downtimes(ListDowntimesOptionalParams::default().with_creator(true))
.await;
if let Ok(value) = resp {
println!("{:#?}", value);
} else {
println!("{:#?}", resp.unwrap_err());
}
}

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=rust) and then save the example to `src/main.rs` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" cargo run`
```
Get all downtimes```
// Get all downtimes returns "OK" response

package main

import (
	"context"
	"encoding/json"
	"fmt"
	"os"

	"github.com/DataDog/datadog-api-client-go/v2/api/datadog"
	"github.com/DataDog/datadog-api-client-go/v2/api/datadogV1"
)

func main() {
	ctx := datadog.NewDefaultContext(context.Background())
	configuration := datadog.NewConfiguration()
	apiClient := datadog.NewAPIClient(configuration)
	api := datadogV1.NewDowntimesApi(apiClient)
	resp, r, err := api.ListDowntimes(ctx, *datadogV1.NewListDowntimesOptionalParameters().WithWithCreator(true))

	if err != nil {
		fmt.Fprintf(os.Stderr, "Error when calling `DowntimesApi.ListDowntimes`: %v\n", err)
		fmt.Fprintf(os.Stderr, "Full HTTP response: %v\n", r)
	}

	responseContent, _ := json.MarshalIndent(resp, "", " ")
	fmt.Fprintf(os.Stdout, "Response from `DowntimesApi.ListDowntimes`:\n%s\n", responseContent)
}

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=go) and then save the example to `main.go` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" go run "main.go"`
```
Get all downtimes```
// Get all downtimes returns "OK" response

import com.datadog.api.client.ApiClient;
import com.datadog.api.client.ApiException;
import com.datadog.api.client.v1.api.DowntimesApi;
import com.datadog.api.client.v1.api.DowntimesApi.ListDowntimesOptionalParameters;
import com.datadog.api.client.v1.model.Downtime;
import java.util.List;

public class Example {
public static void main(String[] args) {
ApiClient defaultClient = ApiClient.getDefaultApiClient();
DowntimesApi apiInstance = new DowntimesApi(defaultClient);

try {
List<Downtime> result =
apiInstance.listDowntimes(new ListDowntimesOptionalParameters().withCreator(true));
System.out.println(result);
} catch (ApiException e) {
System.err.println("Exception when calling DowntimesApi#listDowntimes");
System.err.println("Status code: " + e.getCode());
System.err.println("Reason: " + e.getResponseBody());
System.err.println("Response headers: " + e.getResponseHeaders());
e.printStackTrace();
}
}
}

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=java) and then save the example to `Example.java` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" java "Example.java"`
```
Get all downtimes```
from datadog import initialize, api

options = {
'api_key': '<DATADOG_API_KEY>',
'app_key': '<DATADOG_APPLICATION_KEY>'
}

initialize(**options)

# Get all downtimes
print(api.Downtime.get_all())

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=python-legacy) and then save the example to `example.py` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" python "example.py"`
```
Get all downtimes```
/**
* Get all downtimes returns "OK" response
*/

import { client, v1 } from "@datadog/datadog-api-client";

const configuration = client.createConfiguration();
const apiInstance = new v1.DowntimesApi(configuration);

const params: v1.DowntimesApiListDowntimesRequest = {
withCreator: true,
};

apiInstance
.listDowntimes(params)
.then((data: v1.Downtime[]) => {
console.log(
"API called successfully. Returned data: " + JSON.stringify(data)
);
})
.catch((error: any) => console.error(error));

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=typescript) and then save the example to `example.ts` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" tsc "example.ts"`
```GET https://api.ap1.datadoghq.com/api/v2/downtimehttps://api.ap2.datadoghq.com/api/v2/downtimehttps://api.datadoghq.eu/api/v2/downtimehttps://api.ddog-gov.com/api/v2/downtimehttps://api.datadoghq.com/api/v2/downtimehttps://api.us3.datadoghq.com/api/v2/downtimehttps://api.us5.datadoghq.com/api/v2/downtime
### OverviewGet all scheduled downtimes.
This endpoint requires the `monitors_downtime` permission.OAuth apps require the `monitors_downtime` authorization scope to access this endpoint.
### Arguments#### Query StringsName
Type
Description
current_only
boolean
Only return downtimes that are active when the request is made.
include
string
Comma-separated list of resource paths for related resources to include in the response. Supported resource
paths are `created_by` and `monitor`.page[offset]
integer
Specific offset to use as the beginning of the returned page.
page[limit]
integer
Maximum number of downtimes in the response.
### Response- 200
- 403
- 429
OK
- Model
- Example
Response for retrieving all downtimes.
Expand All
Field
Type
Description
data
[object]
An array of downtimes.
attributes
object
Downtime details.
canceled
date-time
Time that the downtime was canceled.
created
date-time
Creation time of the downtime.
display_timezone
string
The timezone in which to display the downtime's start and end times in Datadog applications. This is not used
as an offset for scheduling.default: `UTC`
message
string
A message to include with notifications for this downtime. Email notifications can be sent to specific users
by using the same `@username` notation as events.modified
date-time
Time that the downtime was last modified.
monitor_identifier
 <oneOf>
Monitor identifier for the downtime.
Option 1
object
Object of the monitor identifier.
monitor_id [*required*]
int64
ID of the monitor to prevent notifications.
Option 2
object
Object of the monitor tags.
monitor_tags [*required*]
[string]
A list of monitor tags. For example, tags that are applied directly to monitors,
not tags that are used in monitor queries (which are filtered by the scope parameter), to which the downtime applies.
The resulting downtime applies to monitors that match **all** provided monitor tags. Setting `monitor_tags`
to `[*]` configures the downtime to mute all monitors for the given scope.mute_first_recovery_notification
boolean
If the first recovery notification during a downtime should be muted.
notify_end_states
[string]
States that will trigger a monitor notification when the `notify_end_types` action occurs.
notify_end_types
[string]
Actions that will trigger a monitor notification if the downtime is in the `notify_end_types` state.
schedule
 <oneOf>
The schedule that defines when the monitor starts, stops, and recurs. There are two types of schedules:
one-time and recurring. Recurring schedules may have up to five RRULE-based recurrences. If no schedules are
provided, the downtime will begin immediately and never end. Option 1
object
A recurring downtime schedule definition.
current_downtime
object
The most recent actual start and end dates for a recurring downtime. For a canceled downtime,
this is the previously occurring downtime. For active downtimes, this is the ongoing downtime, and for scheduled
downtimes it is the upcoming downtime.end
date-time
The end of the current downtime.
start
date-time
The start of the current downtime.
recurrences [*required*]
[object]
A list of downtime recurrences.
duration
string
The length of the downtime. Must begin with an integer and end with one of 'm', 'h', d', or 'w'.
rrule
string
The `RRULE` standard for defining recurring events.
For example, to have a recurring event on the first day of each month, set the type to `rrule` and set the `FREQ` to `MONTHLY` and `BYMONTHDAY` to `1`.
Most common `rrule` options from the iCalendar Spec are supported.**Note**: Attributes specifying the duration in `RRULE` are not supported (for example, `DTSTART`, `DTEND`, `DURATION`).
More examples available in this [downtime guide](https://docs.datadoghq.com/monitors/guide/suppress-alert-with-downtimes/?tab=api).start
string
ISO-8601 Datetime to start the downtime. Must not include a UTC offset. If not provided, the
downtime starts the moment it is created.timezone
string
The timezone in which to schedule the downtime. This affects recurring start and end dates.
Must match `display_timezone`.default: `UTC`
Option 2
object
A one-time downtime definition.
end
date-time
ISO-8601 Datetime to end the downtime.
start [*required*]
date-time
ISO-8601 Datetime to start the downtime.
scope
string
The scope to which the downtime applies. Must follow the common search syntax.
status
enum
The current status of the downtime.
Allowed enum values: `active,canceled,ended,scheduled`id
string
The downtime ID.
relationships
object
All relationships associated with downtime.
created_by
object
The user who created the downtime.
data
object
Data for the user who created the downtime.
id
string
User ID of the downtime creator.
type
enum
Users resource type.
Allowed enum values: `users`default: `users`
monitor
object
The monitor identified by the downtime.
data
object
Data for the monitor.
id
string
Monitor ID of the downtime.
type
enum
Monitor resource type.
Allowed enum values: `monitors`default: `monitors`
type
enum
Downtime resource type.
Allowed enum values: `downtime`default: `downtime`
included
[ <oneOf>]
Array of objects related to the downtimes.
Option 1
object
User object returned by the API.
attributes
object
Attributes of user object returned by the API.
created_at
date-time
Creation time of the user.
disabled
boolean
Whether the user is disabled.
email
string
Email of the user.
handle
string
Handle of the user.
icon
string
URL of the user's icon.
last_login_time
date-time
The last time the user logged in.
mfa_enabled
boolean
If user has MFA enabled.
modified_at
date-time
Time that the user was last modified.
name
string
Name of the user.
service_account
boolean
Whether the user is a service account.
status
string
Status of the user.
title
string
Title of the user.
verified
boolean
Whether the user is verified.
id
string
ID of the user.
relationships
object
Relationships of the user object returned by the API.
org
object
Relationship to an organization.
data [*required*]
object
Relationship to organization object.
id [*required*]
string
ID of the organization.
type [*required*]
enum
Organizations resource type.
Allowed enum values: `orgs`default: `orgs`
other_orgs
object
Relationship to organizations.
data [*required*]
[object]
Relationships to organization objects.
id [*required*]
string
ID of the organization.
type [*required*]
enum
Organizations resource type.
Allowed enum values: `orgs`default: `orgs`
other_users
object
Relationship to users.
data [*required*]
[object]
Relationships to user objects.
id [*required*]
string
A unique identifier that represents the user.
type [*required*]
enum
Users resource type.
Allowed enum values: `users`default: `users`
roles
object
Relationship to roles.
data
[object]
An array containing type and the unique identifier of a role.
id
string
The unique identifier of the role.
type
enum
Roles type.
Allowed enum values: `roles`default: `roles`
type
enum
Users resource type.
Allowed enum values: `users`default: `users`
Option 2
object
Information about the monitor identified by the downtime.
attributes
object
Attributes of the monitor identified by the downtime.
name
string
The name of the monitor identified by the downtime.
id
int64
ID of the monitor identified by the downtime.
type
enum
Monitor resource type.
Allowed enum values: `monitors`default: `monitors`
meta
object
Pagination metadata returned by the API.
page
object
Object containing the total filtered count.
total_filtered_count
int64
Total count of elements matched by the filter.
```
{
"data": [
{
"attributes": {
"canceled": "2020-01-02T03:04:05.282979+0000",
"created": "2020-01-02T03:04:05.282979+0000",
"display_timezone": "America/New_York",
"message": "Message about the downtime",
"modified": "2020-01-02T03:04:05.282979+0000",
"monitor_identifier": {
"monitor_id": 123
},
"mute_first_recovery_notification": false,
"notify_end_states": [
"alert",
"warn"
],
"notify_end_types": [
"canceled",
"expired"
],
"schedule": {
"current_downtime": {
"end": "2020-01-02T03:04:00.000Z",
"start": "2020-01-02T03:04:00.000Z"
},
"recurrences": [
{
"duration": "123d",
"rrule": "FREQ=MONTHLY;BYSETPOS=3;BYDAY=WE;INTERVAL=1",
"start": "2020-01-02T03:04"
}
],
"timezone": "America/New_York"
},
"scope": "env:(staging OR prod) AND datacenter:us-east-1",
"status": "active"
},
"id": "00000000-0000-1234-0000-000000000000",
"relationships": {
"created_by": {
"data": {
"id": "00000000-0000-1234-0000-000000000000",
"type": "users"
}
},
"monitor": {
"data": {
"id": "12345",
"type": "monitors"
}
}
},
"type": "downtime"
}
],
"included": [
{
"attributes": {
"created_at": "2019-09-19T10:00:00.000Z",
"disabled": false,
"email": "string",
"handle": "string",
"icon": "string",
"last_login_time": "2019-09-19T10:00:00.000Z",
"mfa_enabled": false,
"modified_at": "2019-09-19T10:00:00.000Z",
"name": "string",
"service_account": false,
"status": "string",
"title": "string",
"verified": false
},
"id": "string",
"relationships": {
"org": {
"data": {
"id": "00000000-0000-beef-0000-000000000000",
"type": "orgs"
}
},
"other_orgs": {
"data": [
{
"id": "00000000-0000-beef-0000-000000000000",
"type": "orgs"
}
]
},
"other_users": {
"data": [
{
"id": "00000000-0000-0000-2345-000000000000",
"type": "users"
}
]
},
"roles": {
"data": [
{
"id": "3653d3c6-0c75-11ea-ad28-fb5701eabc7d",
"type": "roles"
}
]
}
},
"type": "users"
}
],
"meta": {
"page": {
"total_filtered_count": "integer"
}
}
}
```Forbidden
- Model
- Example
API error response.
Expand All
Field
Type
Description
errors [*required*]
[string]
A list of errors.
```
{
"errors": [
"Bad Request"
]
}
```Too many requests
- Model
- Example
API error response.
Expand All
Field
Type
Description
errors [*required*]
[string]
A list of errors.
```
{
"errors": [
"Bad Request"
]
}
```### Code Example- [Curl](?code-lang=curl#)
- [Python](?code-lang=python#)
- [Ruby](?code-lang=ruby#)
- [Go](?code-lang=go#)
- [Java](?code-lang=java#)
- [Rust](?code-lang=rust#)
- [Typescript](?code-lang=typescript#)

Get all downtimesCopy```

# Curl commandcurl -X GET "https://api.ap1.datadoghq.com"https://api.ap2.datadoghq.com"https://api.datadoghq.eu"https://api.ddog-gov.com"https://api.datadoghq.com"https://api.us3.datadoghq.com"https://api.us5.datadoghq.com/api/v2/downtime" \
-H "Accept: application/json" \
-H "DD-API-KEY: ${DD_API_KEY}" \
-H "DD-APPLICATION-KEY: ${DD_APP_KEY}"

```
Get all downtimes```
"""
Get all downtimes returns "OK" response
"""

from datadog_api_client import ApiClient, Configuration
from datadog_api_client.v2.api.downtimes_api import DowntimesApi

configuration = Configuration()
with ApiClient(configuration) as api_client:
api_instance = DowntimesApi(api_client)
response = api_instance.list_downtimes()

print(response)

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=python) and then save the example to `example.py` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" python3 "example.py"`
```
Get all downtimes```
# Get all downtimes returns "OK" response

require "datadog_api_client"
api_instance = DatadogAPIClient::V2::DowntimesAPI.new
p api_instance.list_downtimes()

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=ruby) and then save the example to `example.rb` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" rb "example.rb"`
```
Get all downtimes```
// Get all downtimes returns "OK" response

package main

import (
	"context"
	"encoding/json"
	"fmt"
	"os"

	"github.com/DataDog/datadog-api-client-go/v2/api/datadog"
	"github.com/DataDog/datadog-api-client-go/v2/api/datadogV2"
)

func main() {
	ctx := datadog.NewDefaultContext(context.Background())
	configuration := datadog.NewConfiguration()
	apiClient := datadog.NewAPIClient(configuration)
	api := datadogV2.NewDowntimesApi(apiClient)
	resp, r, err := api.ListDowntimes(ctx, *datadogV2.NewListDowntimesOptionalParameters())

	if err != nil {
		fmt.Fprintf(os.Stderr, "Error when calling `DowntimesApi.ListDowntimes`: %v\n", err)
		fmt.Fprintf(os.Stderr, "Full HTTP response: %v\n", r)
	}

	responseContent, _ := json.MarshalIndent(resp, "", " ")
	fmt.Fprintf(os.Stdout, "Response from `DowntimesApi.ListDowntimes`:\n%s\n", responseContent)
}

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=go) and then save the example to `main.go` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" go run "main.go"`
```
Get all downtimes```
// Get all downtimes returns "OK" response

import com.datadog.api.client.ApiClient;
import com.datadog.api.client.ApiException;
import com.datadog.api.client.v2.api.DowntimesApi;
import com.datadog.api.client.v2.model.ListDowntimesResponse;

public class Example {
public static void main(String[] args) {
ApiClient defaultClient = ApiClient.getDefaultApiClient();
DowntimesApi apiInstance = new DowntimesApi(defaultClient);

try {
ListDowntimesResponse result = apiInstance.listDowntimes();
System.out.println(result);
} catch (ApiException e) {
System.err.println("Exception when calling DowntimesApi#listDowntimes");
System.err.println("Status code: " + e.getCode());
System.err.println("Reason: " + e.getResponseBody());
System.err.println("Response headers: " + e.getResponseHeaders());
e.printStackTrace();
}
}
}

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=java) and then save the example to `Example.java` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" java "Example.java"`
```
Get all downtimes```
// Get all downtimes returns "OK" response
use datadog_api_client::datadog;
use datadog_api_client::datadogV2::api_downtimes::DowntimesAPI;
use datadog_api_client::datadogV2::api_downtimes::ListDowntimesOptionalParams;

#[tokio::main]
async fn main() {
let configuration = datadog::Configuration::new();
let api = DowntimesAPI::with_config(configuration);
let resp = api
.list_downtimes(ListDowntimesOptionalParams::default())
.await;
if let Ok(value) = resp {
println!("{:#?}", value);
} else {
println!("{:#?}", resp.unwrap_err());
}
}

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=rust) and then save the example to `src/main.rs` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" cargo run`
```
Get all downtimes```
/**
* Get all downtimes returns "OK" response
*/

import { client, v2 } from "@datadog/datadog-api-client";

const configuration = client.createConfiguration();
const apiInstance = new v2.DowntimesApi(configuration);

apiInstance
.listDowntimes()
.then((data: v2.ListDowntimesResponse) => {
console.log(
"API called successfully. Returned data: " + JSON.stringify(data)
);
})
.catch((error: any) => console.error(error));

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=typescript) and then save the example to `example.ts` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" tsc "example.ts"`
```## Schedule a downtime- v1
- v2 (latest)
POST https://api.ap1.datadoghq.com/api/v1/downtimehttps://api.ap2.datadoghq.com/api/v1/downtimehttps://api.datadoghq.eu/api/v1/downtimehttps://api.ddog-gov.com/api/v1/downtimehttps://api.datadoghq.com/api/v1/downtimehttps://api.us3.datadoghq.com/api/v1/downtimehttps://api.us5.datadoghq.com/api/v1/downtime
### OverviewSchedule a downtime. **Note:** This endpoint has been deprecated. Please use v2 endpoints.
This endpoint requires the `monitors_downtime` permission.OAuth apps require the `monitors_downtime` authorization scope to access this endpoint.
### Request#### Body Data (required)Schedule a downtime request body.
- Model
- Example
Expand All
Field
Type
Description
active
boolean
If a scheduled downtime currently exists.
active_child
object
The downtime object definition of the active child for the original parent recurring downtime. This
field will only exist on recurring downtimes.active
boolean
If a scheduled downtime currently exists.
canceled
int64
If a scheduled downtime is canceled.
creator_id
int32
User ID of the downtime creator.
disabled
boolean
If a downtime has been disabled.
downtime_type
int32
`0` for a downtime applied on `*` or all,
`1` when the downtime is only scoped to hosts,
or `2` when the downtime is scoped to anything but hosts.end
int64
POSIX timestamp to end the downtime. If not provided,
the downtime is in effect indefinitely until you cancel it.id
int64
The downtime ID.
message
string
A message to include with notifications for this downtime.
Email notifications can be sent to specific users by using the same `@username` notation as events.monitor_id
int64
A single monitor to which the downtime applies.
If not provided, the downtime applies to all monitors.monitor_tags
[string]
A comma-separated list of monitor tags. For example, tags that are applied directly to monitors,
not tags that are used in monitor queries (which are filtered by the scope parameter), to which the downtime applies.
The resulting downtime applies to monitors that match ALL provided monitor tags.
For example, `service:postgres` **AND** `team:frontend`.mute_first_recovery_notification
boolean
If the first recovery notification during a downtime should be muted.
notify_end_states
[string]
States for which `notify_end_types` sends out notifications for.
default: `alert,no data,warn`
notify_end_types
[string]
If set, notifies if a monitor is in an alert-worthy state (`ALERT`, `WARNING`, or `NO DATA`)
when this downtime expires or is canceled. Applied to monitors that change states during
the downtime (such as from `OK` to `ALERT`, `WARNING`, or `NO DATA`), and to monitors that
already have an alert-worthy state when downtime begins.default: `expired`
parent_id
int64
ID of the parent Downtime.
recurrence
object
An object defining the recurrence of the downtime.
period
int32
How often to repeat as an integer.
For example, to repeat every 3 days, select a type of `days` and a period of `3`.rrule
string
The `RRULE` standard for defining recurring events (**requires to set "type" to rrule**)
For example, to have a recurring event on the first day of each month, set the type to `rrule` and set the `FREQ` to `MONTHLY` and `BYMONTHDAY` to `1`.
Most common `rrule` options from the iCalendar Spec are supported.**Note**: Attributes specifying the duration in `RRULE` are not supported (for example, `DTSTART`, `DTEND`, `DURATION`).
More examples available in this [downtime guide](https://docs.datadoghq.com/monitors/guide/suppress-alert-with-downtimes/?tab=api)type
string
The type of recurrence. Choose from `days`, `weeks`, `months`, `years`, `rrule`.
until_date
int64
The date at which the recurrence should end as a POSIX timestamp.
`until_occurences` and `until_date` are mutually exclusive.until_occurrences
int32
How many times the downtime is rescheduled.
`until_occurences` and `until_date` are mutually exclusive.week_days
[string]
A list of week days to repeat on. Choose from `Mon`, `Tue`, `Wed`, `Thu`, `Fri`, `Sat` or `Sun`.
Only applicable when type is weeks. First letter must be capitalized.scope
[string]
The scope(s) to which the downtime applies and must be in `key:value` format. For example, `host:app2`.
Provide multiple scopes as a comma-separated list like `env:dev,env:prod`.
The resulting downtime applies to sources that matches ALL provided scopes (`env:dev` **AND** `env:prod`).start
int64
POSIX timestamp to start the downtime.
If not provided, the downtime starts the moment it is created.timezone
string
The timezone in which to display the downtime's start and end times in Datadog applications.
updater_id
int32
ID of the last user that updated the downtime.
canceled
int64
If a scheduled downtime is canceled.
creator_id
int32
User ID of the downtime creator.
disabled
boolean
If a downtime has been disabled.
downtime_type
int32
`0` for a downtime applied on `*` or all,
`1` when the downtime is only scoped to hosts,
or `2` when the downtime is scoped to anything but hosts.end
int64
POSIX timestamp to end the downtime. If not provided,
the downtime is in effect indefinitely until you cancel it.id
int64
The downtime ID.
message
string
A message to include with notifications for this downtime.
Email notifications can be sent to specific users by using the same `@username` notation as events.monitor_id
int64
A single monitor to which the downtime applies.
If not provided, the downtime applies to all monitors.monitor_tags
[string]
A comma-separated list of monitor tags. For example, tags that are applied directly to monitors,
not tags that are used in monitor queries (which are filtered by the scope parameter), to which the downtime applies.
The resulting downtime applies to monitors that match ALL provided monitor tags.
For example, `service:postgres` **AND** `team:frontend`.mute_first_recovery_notification
boolean
If the first recovery notification during a downtime should be muted.
notify_end_states
[string]
States for which `notify_end_types` sends out notifications for.
default: `alert,no data,warn`
notify_end_types
[string]
If set, notifies if a monitor is in an alert-worthy state (`ALERT`, `WARNING`, or `NO DATA`)
when this downtime expires or is canceled. Applied to monitors that change states during
the downtime (such as from `OK` to `ALERT`, `WARNING`, or `NO DATA`), and to monitors that
already have an alert-worthy state when downtime begins.default: `expired`
parent_id
int64
ID of the parent Downtime.
recurrence
object
An object defining the recurrence of the downtime.
period
int32
How often to repeat as an integer.
For example, to repeat every 3 days, select a type of `days` and a period of `3`.rrule
string
The `RRULE` standard for defining recurring events (**requires to set "type" to rrule**)
For example, to have a recurring event on the first day of each month, set the type to `rrule` and set the `FREQ` to `MONTHLY` and `BYMONTHDAY` to `1`.
Most common `rrule` options from the iCalendar Spec are supported.**Note**: Attributes specifying the duration in `RRULE` are not supported (for example, `DTSTART`, `DTEND`, `DURATION`).
More examples available in this [downtime guide](https://docs.datadoghq.com/monitors/guide/suppress-alert-with-downtimes/?tab=api)type
string
The type of recurrence. Choose from `days`, `weeks`, `months`, `years`, `rrule`.
until_date
int64
The date at which the recurrence should end as a POSIX timestamp.
`until_occurences` and `until_date` are mutually exclusive.until_occurrences
int32
How many times the downtime is rescheduled.
`until_occurences` and `until_date` are mutually exclusive.week_days
[string]
A list of week days to repeat on. Choose from `Mon`, `Tue`, `Wed`, `Thu`, `Fri`, `Sat` or `Sun`.
Only applicable when type is weeks. First letter must be capitalized.scope
[string]
The scope(s) to which the downtime applies and must be in `key:value` format. For example, `host:app2`.
Provide multiple scopes as a comma-separated list like `env:dev,env:prod`.
The resulting downtime applies to sources that matches ALL provided scopes (`env:dev` **AND** `env:prod`).start
int64
POSIX timestamp to start the downtime.
If not provided, the downtime starts the moment it is created.timezone
string
The timezone in which to display the downtime's start and end times in Datadog applications.
updater_id
int32
ID of the last user that updated the downtime.

Schedule a downtime once a year```
{
"message": "Example-Downtime",
"recurrence": {
"period": 1,
"type": "years"
},
"scope": [
"*"
],
"start": 1636629071,
"end": 1636632671,
"timezone": "Etc/UTC",
"mute_first_recovery_notification": true,
"monitor_tags": [
"tag0"
],
"notify_end_states": [
"alert",
"warn"
],
"notify_end_types": [
"expired"
]
}
```
Schedule a downtime returns "OK" response```
{
"message": "Example-Downtime",
"start": 1636629071,
"end": 1636632671,
"timezone": "Etc/UTC",
"scope": [
"test:exampledowntime"
],
"recurrence": {
"type": "weeks",
"period": 1,
"week_days": [
"Mon",
"Tue",
"Wed",
"Thu",
"Fri"
],
"until_date": 1638443471
},
"notify_end_states": [
"alert",
"no data",
"warn"
],
"notify_end_types": [
"canceled",
"expired"
]
}
```
Schedule a downtime until date```
{
"message": "Example-Downtime",
"recurrence": {
"period": 1,
"type": "weeks",
"until_date": 1638443471,
"week_days": [
"Mon",
"Tue",
"Wed",
"Thu",
"Fri"
]
},
"scope": [
"*"
],
"start": 1636629071,
"end": 1636632671,
"timezone": "Etc/UTC",
"mute_first_recovery_notification": true,
"monitor_tags": [
"tag0"
],
"notify_end_states": [
"alert"
],
"notify_end_types": [
"canceled"
]
}
```### Response- 200
- 400
- 403
- 429
OK
- Model
- Example
Downtiming gives you greater control over monitor notifications by
allowing you to globally exclude scopes from alerting.
Downtime settings, which can be scheduled with start and end times,
prevent all alerting related to specified Datadog tags.Expand All
Field
Type
Description
active
boolean
If a scheduled downtime currently exists.
active_child
object
The downtime object definition of the active child for the original parent recurring downtime. This
field will only exist on recurring downtimes.active
boolean
If a scheduled downtime currently exists.
canceled
int64
If a scheduled downtime is canceled.
creator_id
int32
User ID of the downtime creator.
disabled
boolean
If a downtime has been disabled.
downtime_type
int32
`0` for a downtime applied on `*` or all,
`1` when the downtime is only scoped to hosts,
or `2` when the downtime is scoped to anything but hosts.end
int64
POSIX timestamp to end the downtime. If not provided,
the downtime is in effect indefinitely until you cancel it.id
int64
The downtime ID.
message
string
A message to include with notifications for this downtime.
Email notifications can be sent to specific users by using the same `@username` notation as events.monitor_id
int64
A single monitor to which the downtime applies.
If not provided, the downtime applies to all monitors.monitor_tags
[string]
A comma-separated list of monitor tags. For example, tags that are applied directly to monitors,
not tags that are used in monitor queries (which are filtered by the scope parameter), to which the downtime applies.
The resulting downtime applies to monitors that match ALL provided monitor tags.
For example, `service:postgres` **AND** `team:frontend`.mute_first_recovery_notification
boolean
If the first recovery notification during a downtime should be muted.
notify_end_states
[string]
States for which `notify_end_types` sends out notifications for.
default: `alert,no data,warn`
notify_end_types
[string]
If set, notifies if a monitor is in an alert-worthy state (`ALERT`, `WARNING`, or `NO DATA`)
when this downtime expires or is canceled. Applied to monitors that change states during
the downtime (such as from `OK` to `ALERT`, `WARNING`, or `NO DATA`), and to monitors that
already have an alert-worthy state when downtime begins.default: `expired`
parent_id
int64
ID of the parent Downtime.
recurrence
object
An object defining the recurrence of the downtime.
period
int32
How often to repeat as an integer.
For example, to repeat every 3 days, select a type of `days` and a period of `3`.rrule
string
The `RRULE` standard for defining recurring events (**requires to set "type" to rrule**)
For example, to have a recurring event on the first day of each month, set the type to `rrule` and set the `FREQ` to `MONTHLY` and `BYMONTHDAY` to `1`.
Most common `rrule` options from the iCalendar Spec are supported.**Note**: Attributes specifying the duration in `RRULE` are not supported (for example, `DTSTART`, `DTEND`, `DURATION`).
More examples available in this [downtime guide](https://docs.datadoghq.com/monitors/guide/suppress-alert-with-downtimes/?tab=api)type
string
The type of recurrence. Choose from `days`, `weeks`, `months`, `years`, `rrule`.
until_date
int64
The date at which the recurrence should end as a POSIX timestamp.
`until_occurences` and `until_date` are mutually exclusive.until_occurrences
int32
How many times the downtime is rescheduled.
`until_occurences` and `until_date` are mutually exclusive.week_days
[string]
A list of week days to repeat on. Choose from `Mon`, `Tue`, `Wed`, `Thu`, `Fri`, `Sat` or `Sun`.
Only applicable when type is weeks. First letter must be capitalized.scope
[string]
The scope(s) to which the downtime applies and must be in `key:value` format. For example, `host:app2`.
Provide multiple scopes as a comma-separated list like `env:dev,env:prod`.
The resulting downtime applies to sources that matches ALL provided scopes (`env:dev` **AND** `env:prod`).start
int64
POSIX timestamp to start the downtime.
If not provided, the downtime starts the moment it is created.timezone
string
The timezone in which to display the downtime's start and end times in Datadog applications.
updater_id
int32
ID of the last user that updated the downtime.
canceled
int64
If a scheduled downtime is canceled.
creator_id
int32
User ID of the downtime creator.
disabled
boolean
If a downtime has been disabled.
downtime_type
int32
`0` for a downtime applied on `*` or all,
`1` when the downtime is only scoped to hosts,
or `2` when the downtime is scoped to anything but hosts.end
int64
POSIX timestamp to end the downtime. If not provided,
the downtime is in effect indefinitely until you cancel it.id
int64
The downtime ID.
message
string
A message to include with notifications for this downtime.
Email notifications can be sent to specific users by using the same `@username` notation as events.monitor_id
int64
A single monitor to which the downtime applies.
If not provided, the downtime applies to all monitors.monitor_tags
[string]
A comma-separated list of monitor tags. For example, tags that are applied directly to monitors,
not tags that are used in monitor queries (which are filtered by the scope parameter), to which the downtime applies.
The resulting downtime applies to monitors that match ALL provided monitor tags.
For example, `service:postgres` **AND** `team:frontend`.mute_first_recovery_notification
boolean
If the first recovery notification during a downtime should be muted.
notify_end_states
[string]
States for which `notify_end_types` sends out notifications for.
default: `alert,no data,warn`
notify_end_types
[string]
If set, notifies if a monitor is in an alert-worthy state (`ALERT`, `WARNING`, or `NO DATA`)
when this downtime expires or is canceled. Applied to monitors that change states during
the downtime (such as from `OK` to `ALERT`, `WARNING`, or `NO DATA`), and to monitors that
already have an alert-worthy state when downtime begins.default: `expired`
parent_id
int64
ID of the parent Downtime.
recurrence
object
An object defining the recurrence of the downtime.
period
int32
How often to repeat as an integer.
For example, to repeat every 3 days, select a type of `days` and a period of `3`.rrule
string
The `RRULE` standard for defining recurring events (**requires to set "type" to rrule**)
For example, to have a recurring event on the first day of each month, set the type to `rrule` and set the `FREQ` to `MONTHLY` and `BYMONTHDAY` to `1`.
Most common `rrule` options from the iCalendar Spec are supported.**Note**: Attributes specifying the duration in `RRULE` are not supported (for example, `DTSTART`, `DTEND`, `DURATION`).
More examples available in this [downtime guide](https://docs.datadoghq.com/monitors/guide/suppress-alert-with-downtimes/?tab=api)type
string
The type of recurrence. Choose from `days`, `weeks`, `months`, `years`, `rrule`.
until_date
int64
The date at which the recurrence should end as a POSIX timestamp.
`until_occurences` and `until_date` are mutually exclusive.until_occurrences
int32
How many times the downtime is rescheduled.
`until_occurences` and `until_date` are mutually exclusive.week_days
[string]
A list of week days to repeat on. Choose from `Mon`, `Tue`, `Wed`, `Thu`, `Fri`, `Sat` or `Sun`.
Only applicable when type is weeks. First letter must be capitalized.scope
[string]
The scope(s) to which the downtime applies and must be in `key:value` format. For example, `host:app2`.
Provide multiple scopes as a comma-separated list like `env:dev,env:prod`.
The resulting downtime applies to sources that matches ALL provided scopes (`env:dev` **AND** `env:prod`).start
int64
POSIX timestamp to start the downtime.
If not provided, the downtime starts the moment it is created.timezone
string
The timezone in which to display the downtime's start and end times in Datadog applications.
updater_id
int32
ID of the last user that updated the downtime.
```
{
"active": true,
"active_child": {
"active": true,
"canceled": 1412799983,
"creator_id": 123456,
"disabled": false,
"downtime_type": 2,
"end": 1412793983,
"id": 1626,
"message": "Message on the downtime",
"monitor_id": 123456,
"monitor_tags": [
"*"
],
"mute_first_recovery_notification": false,
"notify_end_states": [
"alert",
"no data",
"warn"
],
"notify_end_types": [
"canceled",
"expired"
],
"parent_id": 123,
"recurrence": {
"period": 1,
"rrule": "FREQ=MONTHLY;BYSETPOS=3;BYDAY=WE;INTERVAL=1",
"type": "weeks",
"until_date": 1447786293,
"until_occurrences": 2,
"week_days": [
"Mon",
"Tue"
]
},
"scope": [
"env:staging"
],
"start": 1412792983,
"timezone": "America/New_York",
"updater_id": 123456
},
"canceled": 1412799983,
"creator_id": 123456,
"disabled": false,
"downtime_type": 2,
"end": 1412793983,
"id": 1625,
"message": "Message on the downtime",
"monitor_id": 123456,
"monitor_tags": [
"*"
],
"mute_first_recovery_notification": false,
"notify_end_states": [
"alert",
"no data",
"warn"
],
"notify_end_types": [
"canceled",
"expired"
],
"parent_id": 123,
"recurrence": {
"period": 1,
"rrule": "FREQ=MONTHLY;BYSETPOS=3;BYDAY=WE;INTERVAL=1",
"type": "weeks",
"until_date": 1447786293,
"until_occurrences": 2,
"week_days": [
"Mon",
"Tue"
]
},
"scope": [
"env:staging"
],
"start": 1412792983,
"timezone": "America/New_York",
"updater_id": 123456
}
```Bad Request
- Model
- Example
Error response object.
Expand All
Field
Type
Description
errors [*required*]
[string]
Array of errors returned by the API.
```
{
"errors": [
"Bad Request"
]
}
```Forbidden
- Model
- Example
Error response object.
Expand All
Field
Type
Description
errors [*required*]
[string]
Array of errors returned by the API.
```
{
"errors": [
"Bad Request"
]
}
```Too many requests
- Model
- Example
Error response object.
Expand All
Field
Type
Description
errors [*required*]
[string]
Array of errors returned by the API.
```
{
"errors": [
"Bad Request"
]
}
```### Code Example- [Curl](?code-lang=curl#)
- [Go](?code-lang=go#)
- [Java](?code-lang=java#)
- [Python](?code-lang=python#)
- [Ruby](?code-lang=ruby#)
- [Rust](?code-lang=rust#)
- [Typescript](?code-lang=typescript#)
- [Python [legacy]](?code-lang=python-legacy#)
- [Ruby [legacy]](?code-lang=ruby-legacy#)

Schedule a downtime once a yearCopy```

# Curl commandcurl -X POST "https://api.ap1.datadoghq.com"https://api.ap2.datadoghq.com"https://api.datadoghq.eu"https://api.ddog-gov.com"https://api.datadoghq.com"https://api.us3.datadoghq.com"https://api.us5.datadoghq.com/api/v1/downtime" \
-H "Accept: application/json" \
-H "Content-Type: application/json" \
-H "DD-API-KEY: ${DD_API_KEY}" \
-H "DD-APPLICATION-KEY: ${DD_APP_KEY}" \
-d @- << EOF
{
"message": "Example-Downtime",
"recurrence": {
"period": 1,
"type": "years"
},
"scope": [
"*"
],
"start": 1636629071,
"end": 1636632671,
"timezone": "Etc/UTC",
"mute_first_recovery_notification": true,
"monitor_tags": [
"tag0"
],
"notify_end_states": [
"alert",
"warn"
],
"notify_end_types": [
"expired"
]
}
EOF

```
Schedule a downtime returns "OK" responseCopy```

# Curl commandcurl -X POST "https://api.ap1.datadoghq.com"https://api.ap2.datadoghq.com"https://api.datadoghq.eu"https://api.ddog-gov.com"https://api.datadoghq.com"https://api.us3.datadoghq.com"https://api.us5.datadoghq.com/api/v1/downtime" \
-H "Accept: application/json" \
-H "Content-Type: application/json" \
-H "DD-API-KEY: ${DD_API_KEY}" \
-H "DD-APPLICATION-KEY: ${DD_APP_KEY}" \
-d @- << EOF
{
"message": "Example-Downtime",
"start": 1636629071,
"end": 1636632671,
"timezone": "Etc/UTC",
"scope": [
"test:exampledowntime"
],
"recurrence": {
"type": "weeks",
"period": 1,
"week_days": [
"Mon",
"Tue",
"Wed",
"Thu",
"Fri"
],
"until_date": 1638443471
},
"notify_end_states": [
"alert",
"no data",
"warn"
],
"notify_end_types": [
"canceled",
"expired"
]
}
EOF

```
Schedule a downtime until dateCopy```

# Curl commandcurl -X POST "https://api.ap1.datadoghq.com"https://api.ap2.datadoghq.com"https://api.datadoghq.eu"https://api.ddog-gov.com"https://api.datadoghq.com"https://api.us3.datadoghq.com"https://api.us5.datadoghq.com/api/v1/downtime" \
-H "Accept: application/json" \
-H "Content-Type: application/json" \
-H "DD-API-KEY: ${DD_API_KEY}" \
-H "DD-APPLICATION-KEY: ${DD_APP_KEY}" \
-d @- << EOF
{
"message": "Example-Downtime",
"recurrence": {
"period": 1,
"type": "weeks",
"until_date": 1638443471,
"week_days": [
"Mon",
"Tue",
"Wed",
"Thu",
"Fri"
]
},
"scope": [
"*"
],
"start": 1636629071,
"end": 1636632671,
"timezone": "Etc/UTC",
"mute_first_recovery_notification": true,
"monitor_tags": [
"tag0"
],
"notify_end_states": [
"alert"
],
"notify_end_types": [
"canceled"
]
}
EOF

```
Schedule a downtime once a year
**```
// Schedule a downtime once a year

package main

import (
	"context"
	"encoding/json"
	"fmt"
	"os"
	"time"

	"github.com/DataDog/datadog-api-client-go/v2/api/datadog"
	"github.com/DataDog/datadog-api-client-go/v2/api/datadogV1"
)

func main() {
	body := datadogV1.Downtime{
		Message: *datadog.NewNullableString(datadog.PtrString("Example-Downtime")),
		Recurrence: *datadogV1.NewNullableDowntimeRecurrence(&datadogV1.DowntimeRecurrence{
			Period: datadog.PtrInt32(1),
			Type: datadog.PtrString("years"),
		}),
		Scope: []string{
			"*",
		},
		Start: datadog.PtrInt64(time.Now().Unix()),
		End: *datadog.NewNullableInt64(datadog.PtrInt64(time.Now().Add(time.Hour * 1).Unix())),
		Timezone: datadog.PtrString("Etc/UTC"),
		MuteFirstRecoveryNotification: datadog.PtrBool(true),
		MonitorTags: []string{
			"tag0",
		},
		NotifyEndStates: []datadogV1.NotifyEndState{
			datadogV1.NOTIFYENDSTATE_ALERT,
			datadogV1.NOTIFYENDSTATE_WARN,
		},
		NotifyEndTypes: []datadogV1.NotifyEndType{
			datadogV1.NOTIFYENDTYPE_EXPIRED,
		},
	}
	ctx := datadog.NewDefaultContext(context.Background())
	configuration := datadog.NewConfiguration()
	apiClient := datadog.NewAPIClient(configuration)
	api := datadogV1.NewDowntimesApi(apiClient)
	resp, r, err := api.CreateDowntime(ctx, body)

	if err != nil {
		fmt.Fprintf(os.Stderr, "Error when calling `DowntimesApi.CreateDowntime`: %v\n", err)
		fmt.Fprintf(os.Stderr, "Full HTTP response: %v\n", r)
	}

	responseContent, _ := json.MarshalIndent(resp, "", " ")
	fmt.Fprintf(os.Stdout, "Response from `DowntimesApi.CreateDowntime`:\n%s\n", responseContent)
}

```
Schedule a downtime returns "OK" response
**```
// Schedule a downtime returns "OK" response

package main

import (
	"context"
	"encoding/json"
	"fmt"
	"os"
	"time"

	"github.com/DataDog/datadog-api-client-go/v2/api/datadog"
	"github.com/DataDog/datadog-api-client-go/v2/api/datadogV1"
)

func main() {
	body := datadogV1.Downtime{
		Message: *datadog.NewNullableString(datadog.PtrString("Example-Downtime")),
		Start: datadog.PtrInt64(time.Now().Unix()),
		End: *datadog.NewNullableInt64(datadog.PtrInt64(time.Now().Add(time.Hour * 1).Unix())),
		Timezone: datadog.PtrString("Etc/UTC"),
		Scope: []string{
			"test:exampledowntime",
		},
		Recurrence: *datadogV1.NewNullableDowntimeRecurrence(&datadogV1.DowntimeRecurrence{
			Type: datadog.PtrString("weeks"),
			Period: datadog.PtrInt32(1),
			WeekDays: *datadog.NewNullableList(&[]string{
				"Mon",
				"Tue",
				"Wed",
				"Thu",
				"Fri",
			}),
			UntilDate: *datadog.NewNullableInt64(datadog.PtrInt64(time.Now().AddDate(0, 0, 21).Unix())),
		}),
		NotifyEndStates: []datadogV1.NotifyEndState{
			datadogV1.NOTIFYENDSTATE_ALERT,
			datadogV1.NOTIFYENDSTATE_NO_DATA,
			datadogV1.NOTIFYENDSTATE_WARN,
		},
		NotifyEndTypes: []datadogV1.NotifyEndType{
			datadogV1.NOTIFYENDTYPE_CANCELED,
			datadogV1.NOTIFYENDTYPE_EXPIRED,
		},
	}
	ctx := datadog.NewDefaultContext(context.Background())
	configuration := datadog.NewConfiguration()
	apiClient := datadog.NewAPIClient(configuration)
	api := datadogV1.NewDowntimesApi(apiClient)
	resp, r, err := api.CreateDowntime(ctx, body)

	if err != nil {
		fmt.Fprintf(os.Stderr, "Error when calling `DowntimesApi.CreateDowntime`: %v\n", err)
		fmt.Fprintf(os.Stderr, "Full HTTP response: %v\n", r)
	}

	responseContent, _ := json.MarshalIndent(resp, "", " ")
	fmt.Fprintf(os.Stdout, "Response from `DowntimesApi.CreateDowntime`:\n%s\n", responseContent)
}

```
Schedule a downtime until date
**```
// Schedule a downtime until date

package main

import (
	"context"
	"encoding/json"
	"fmt"
	"os"
	"time"

	"github.com/DataDog/datadog-api-client-go/v2/api/datadog"
	"github.com/DataDog/datadog-api-client-go/v2/api/datadogV1"
)

func main() {
	body := datadogV1.Downtime{
		Message: *datadog.NewNullableString(datadog.PtrString("Example-Downtime")),
		Recurrence: *datadogV1.NewNullableDowntimeRecurrence(&datadogV1.DowntimeRecurrence{
			Period: datadog.PtrInt32(1),
			Type: datadog.PtrString("weeks"),
			UntilDate: *datadog.NewNullableInt64(datadog.PtrInt64(time.Now().AddDate(0, 0, 21).Unix())),
			WeekDays: *datadog.NewNullableList(&[]string{
				"Mon",
				"Tue",
				"Wed",
				"Thu",
				"Fri",
			}),
		}),
		Scope: []string{
			"*",
		},
		Start: datadog.PtrInt64(time.Now().Unix()),
		End: *datadog.NewNullableInt64(datadog.PtrInt64(time.Now().Add(time.Hour * 1).Unix())),
		Timezone: datadog.PtrString("Etc/UTC"),
		MuteFirstRecoveryNotification: datadog.PtrBool(true),
		MonitorTags: []string{
			"tag0",
		},
		NotifyEndStates: []datadogV1.NotifyEndState{
			datadogV1.NOTIFYENDSTATE_ALERT,
		},
		NotifyEndTypes: []datadogV1.NotifyEndType{
			datadogV1.NOTIFYENDTYPE_CANCELED,
		},
	}
	ctx := datadog.NewDefaultContext(context.Background())
	configuration := datadog.NewConfiguration()
	apiClient := datadog.NewAPIClient(configuration)
	api := datadogV1.NewDowntimesApi(apiClient)
	resp, r, err := api.CreateDowntime(ctx, body)

	if err != nil {
		fmt.Fprintf(os.Stderr, "Error when calling `DowntimesApi.CreateDowntime`: %v\n", err)
		fmt.Fprintf(os.Stderr, "Full HTTP response: %v\n", r)
	}

	responseContent, _ := json.MarshalIndent(resp, "", " ")
	fmt.Fprintf(os.Stdout, "Response from `DowntimesApi.CreateDowntime`:\n%s\n", responseContent)
}

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=go) and then save the example to `main.go` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" go run "main.go"`
```
Schedule a downtime once a year
**```
// Schedule a downtime once a year
import com.datadog.api.client.ApiClient;
import com.datadog.api.client.ApiException;
import com.datadog.api.client.v1.api.DowntimesApi;
import com.datadog.api.client.v1.model.Downtime;
import com.datadog.api.client.v1.model.DowntimeRecurrence;
import com.datadog.api.client.v1.model.NotifyEndState;
import com.datadog.api.client.v1.model.NotifyEndType;
import java.time.OffsetDateTime;
import java.util.Arrays;
import java.util.Collections;

public class Example {
public static void main(String[] args) {
ApiClient defaultClient = ApiClient.getDefaultApiClient();
DowntimesApi apiInstance = new DowntimesApi(defaultClient);

Downtime body =
new Downtime()
.message("Example-Downtime")
.recurrence(new DowntimeRecurrence().period(1).type("years"))
.scope(Collections.singletonList("*"))
.start(OffsetDateTime.now().toInstant().getEpochSecond())
.end(OffsetDateTime.now().plusHours(1).toInstant().getEpochSecond())
.timezone("Etc/UTC")
.muteFirstRecoveryNotification(true)
.monitorTags(Collections.singletonList("tag0"))
.notifyEndStates(Arrays.asList(NotifyEndState.ALERT, NotifyEndState.WARN))
.notifyEndTypes(Collections.singletonList(NotifyEndType.EXPIRED));

try {
Downtime result = apiInstance.createDowntime(body);
System.out.println(result);
} catch (ApiException e) {
System.err.println("Exception when calling DowntimesApi#createDowntime");
System.err.println("Status code: " + e.getCode());
System.err.println("Reason: " + e.getResponseBody());
System.err.println("Response headers: " + e.getResponseHeaders());
e.printStackTrace();
}
}
}

```
Schedule a downtime returns "OK" response
**```
// Schedule a downtime returns "OK" response
import com.datadog.api.client.ApiClient;
import com.datadog.api.client.ApiException;
import com.datadog.api.client.v1.api.DowntimesApi;
import com.datadog.api.client.v1.model.Downtime;
import com.datadog.api.client.v1.model.DowntimeRecurrence;
import com.datadog.api.client.v1.model.NotifyEndState;
import com.datadog.api.client.v1.model.NotifyEndType;
import java.time.OffsetDateTime;
import java.util.Arrays;
import java.util.Collections;

public class Example {
public static void main(String[] args) {
ApiClient defaultClient = ApiClient.getDefaultApiClient();
DowntimesApi apiInstance = new DowntimesApi(defaultClient);

Downtime body =
new Downtime()
.message("Example-Downtime")
.start(OffsetDateTime.now().toInstant().getEpochSecond())
.end(OffsetDateTime.now().plusHours(1).toInstant().getEpochSecond())
.timezone("Etc/UTC")
.scope(Collections.singletonList("test:exampledowntime"))
.recurrence(
new DowntimeRecurrence()
.type("weeks")
.period(1)
.weekDays(Arrays.asList("Mon", "Tue", "Wed", "Thu", "Fri"))
.untilDate(OffsetDateTime.now().plusDays(21).toInstant().getEpochSecond()))
.notifyEndStates(
Arrays.asList(NotifyEndState.ALERT, NotifyEndState.NO_DATA, NotifyEndState.WARN))
.notifyEndTypes(Arrays.asList(NotifyEndType.CANCELED, NotifyEndType.EXPIRED));

try {
Downtime result = apiInstance.createDowntime(body);
System.out.println(result);
} catch (ApiException e) {
System.err.println("Exception when calling DowntimesApi#createDowntime");
System.err.println("Status code: " + e.getCode());
System.err.println("Reason: " + e.getResponseBody());
System.err.println("Response headers: " + e.getResponseHeaders());
e.printStackTrace();
}
}
}

```
Schedule a downtime until date
**```
// Schedule a downtime until date
import com.datadog.api.client.ApiClient;
import com.datadog.api.client.ApiException;
import com.datadog.api.client.v1.api.DowntimesApi;
import com.datadog.api.client.v1.model.Downtime;
import com.datadog.api.client.v1.model.DowntimeRecurrence;
import com.datadog.api.client.v1.model.NotifyEndState;
import com.datadog.api.client.v1.model.NotifyEndType;
import java.time.OffsetDateTime;
import java.util.Arrays;
import java.util.Collections;

public class Example {
public static void main(String[] args) {
ApiClient defaultClient = ApiClient.getDefaultApiClient();
DowntimesApi apiInstance = new DowntimesApi(defaultClient);

Downtime body =
new Downtime()
.message("Example-Downtime")
.recurrence(
new DowntimeRecurrence()
.period(1)
.type("weeks")
.untilDate(OffsetDateTime.now().plusDays(21).toInstant().getEpochSecond())
.weekDays(Arrays.asList("Mon", "Tue", "Wed", "Thu", "Fri")))
.scope(Collections.singletonList("*"))
.start(OffsetDateTime.now().toInstant().getEpochSecond())
.end(OffsetDateTime.now().plusHours(1).toInstant().getEpochSecond())
.timezone("Etc/UTC")
.muteFirstRecoveryNotification(true)
.monitorTags(Collections.singletonList("tag0"))
.notifyEndStates(Collections.singletonList(NotifyEndState.ALERT))
.notifyEndTypes(Collections.singletonList(NotifyEndType.CANCELED));

try {
Downtime result = apiInstance.createDowntime(body);
System.out.println(result);
} catch (ApiException e) {
System.err.println("Exception when calling DowntimesApi#createDowntime");
System.err.println("Status code: " + e.getCode());
System.err.println("Reason: " + e.getResponseBody());
System.err.println("Response headers: " + e.getResponseHeaders());
e.printStackTrace();
}
}
}

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=java) and then save the example to `Example.java` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" java "Example.java"`
```
Schedule a downtime returns "OK" response```
from datadog import initialize, api
import time

options = {
'api_key': '<DATADOG_API_KEY>',
'app_key': '<DATADOG_APPLICATION_KEY>'
}

initialize(**options)

# Repeat for 3 hours (starting now) on every week day for 4 weeks.
start_ts = int(time.time())
end_ts = start_ts + (3 * 60 * 60)
end_reccurrence_ts = start_ts + (4 * 7 * 24 * 60 * 60) # 4 weeks from now

recurrence = {
'type': 'weeks',
'period': 1,
'week_days': ['Mon', 'Tue', 'Wed', 'Thu', 'Fri'],
'until_date': end_reccurrence_ts
}

# Schedule downtime
api.Downtime.create(
scope='env:staging',
start=start_ts,
end=end_ts,
recurrence=recurrence
)

# OR use RRULE reccurence
rrule_recurrence = {
'type': 'rrule',
'rrule': 'FREQ=MONTHLY;BYSETPOS=3;BYDAY=WE;INTERVAL=1',
}

# Schedule downtime
api.Downtime.create(
scope='env:staging',
start=start_ts,
end=end_ts,
recurrence=rrule_recurrence
)

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=python-legacy) and then save the example to `example.py` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" python "example.py"`
```
Schedule a downtime once a year
**```
"""
Schedule a downtime once a year
"""

from datetime import datetime
from dateutil.relativedelta import relativedelta
from datadog_api_client import ApiClient, Configuration
from datadog_api_client.v1.api.downtimes_api import DowntimesApi
from datadog_api_client.v1.model.downtime import Downtime
from datadog_api_client.v1.model.downtime_recurrence import DowntimeRecurrence
from datadog_api_client.v1.model.notify_end_state import NotifyEndState
from datadog_api_client.v1.model.notify_end_type import NotifyEndType

body = Downtime(
message="Example-Downtime",
recurrence=DowntimeRecurrence(
period=1,
type="years",
),
scope=[
"*",
],
start=int(datetime.now().timestamp()),
end=int((datetime.now() + relativedelta(hours=1)).timestamp()),
timezone="Etc/UTC",
mute_first_recovery_notification=True,
monitor_tags=[
"tag0",
],
notify_end_states=[
NotifyEndState.ALERT,
NotifyEndState.WARN,
],
notify_end_types=[
NotifyEndType.EXPIRED,
],
)

configuration = Configuration()
with ApiClient(configuration) as api_client:
api_instance = DowntimesApi(api_client)
response = api_instance.create_downtime(body=body)

print(response)

```
Schedule a downtime returns "OK" response
**```
"""
Schedule a downtime returns "OK" response
"""

from datetime import datetime
from dateutil.relativedelta import relativedelta
from datadog_api_client import ApiClient, Configuration
from datadog_api_client.v1.api.downtimes_api import DowntimesApi
from datadog_api_client.v1.model.downtime import Downtime
from datadog_api_client.v1.model.downtime_recurrence import DowntimeRecurrence
from datadog_api_client.v1.model.notify_end_state import NotifyEndState
from datadog_api_client.v1.model.notify_end_type import NotifyEndType

body = Downtime(
message="Example-Downtime",
start=int(datetime.now().timestamp()),
end=int((datetime.now() + relativedelta(hours=1)).timestamp()),
timezone="Etc/UTC",
scope=[
"test:exampledowntime",
],
recurrence=DowntimeRecurrence(
type="weeks",
period=1,
week_days=[
"Mon",
"Tue",
"Wed",
"Thu",
"Fri",
],
until_date=int((datetime.now() + relativedelta(days=21)).timestamp()),
),
notify_end_states=[
NotifyEndState.ALERT,
NotifyEndState.NO_DATA,
NotifyEndState.WARN,
],
notify_end_types=[
NotifyEndType.CANCELED,
NotifyEndType.EXPIRED,
],
)

configuration = Configuration()
with ApiClient(configuration) as api_client:
api_instance = DowntimesApi(api_client)
response = api_instance.create_downtime(body=body)

print(response)

```
Schedule a downtime until date
**```
"""
Schedule a downtime until date
"""

from datetime import datetime
from dateutil.relativedelta import relativedelta
from datadog_api_client import ApiClient, Configuration
from datadog_api_client.v1.api.downtimes_api import DowntimesApi
from datadog_api_client.v1.model.downtime import Downtime
from datadog_api_client.v1.model.downtime_recurrence import DowntimeRecurrence
from datadog_api_client.v1.model.notify_end_state import NotifyEndState
from datadog_api_client.v1.model.notify_end_type import NotifyEndType

body = Downtime(
message="Example-Downtime",
recurrence=DowntimeRecurrence(
period=1,
type="weeks",
until_date=int((datetime.now() + relativedelta(days=21)).timestamp()),
week_days=[
"Mon",
"Tue",
"Wed",
"Thu",
"Fri",
],
),
scope=[
"*",
],
start=int(datetime.now().timestamp()),
end=int((datetime.now() + relativedelta(hours=1)).timestamp()),
timezone="Etc/UTC",
mute_first_recovery_notification=True,
monitor_tags=[
"tag0",
],
notify_end_states=[
NotifyEndState.ALERT,
],
notify_end_types=[
NotifyEndType.CANCELED,
],
)

configuration = Configuration()
with ApiClient(configuration) as api_client:
api_instance = DowntimesApi(api_client)
response = api_instance.create_downtime(body=body)

print(response)

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=python) and then save the example to `example.py` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" python3 "example.py"`
```
Schedule a downtime returns "OK" response```
require 'dogapi'

api_key = '<DATADOG_API_KEY>'
app_key = '<DATADOG_APPLICATION_KEY>'

dog = Dogapi::Client.new(api_key, app_key)

# Repeat for 3 hours (starting now) on every week day for 4 weeks.
start_ts = Time.now.to_i
end_ts = start_ts + (3 * 60 * 60)
end_reccurrence_ts = start_ts + (4 * 7 * 24 * 60 * 60) # 4 weeks from now

recurrence = {
'type' => 'weeks',
'period' => 1,
'week_days' => %w[Mon Tue Wed Thu Fri],
'until_date' => end_reccurrence_ts
}

# Schedule downtime
dog.Downtime.create(
'env:staging',
start: start_ts,
end: end_ts,
recurrence: recurrence
)

# OR use RRULE reccurence
rrule_recurrence = {
'type' => 'rrule',
'rrule' => 'FREQ=MONTHLY;BYSETPOS=3;BYDAY=WE;INTERVAL=1',
}

# Schedule downtime
dog.Downtime.create(
'env:staging',
start: start_ts,
end: end_ts,
recurrence: rrule_recurrence
)

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=ruby-legacy) and then save the example to `example.rb` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" rb "example.rb"`
```
Schedule a downtime once a year
**```
# Schedule a downtime once a year

require "datadog_api_client"
api_instance = DatadogAPIClient::V1::DowntimesAPI.new

body = DatadogAPIClient::V1::Downtime.new({
message: "Example-Downtime",
recurrence: DatadogAPIClient::V1::DowntimeRecurrence.new({
period: 1,
type: "years",
}),
scope: [
"*",
],
start: Time.now.to_i,
_end: (Time.now + 1 * 3600).to_i,
timezone: "Etc/UTC",
mute_first_recovery_notification: true,
monitor_tags: [
"tag0",
],
notify_end_states: [
DatadogAPIClient::V1::NotifyEndState::ALERT,
DatadogAPIClient::V1::NotifyEndState::WARN,
],
notify_end_types: [
DatadogAPIClient::V1::NotifyEndType::EXPIRED,
],
})
p api_instance.create_downtime(body)

```
Schedule a downtime returns "OK" response
**```
# Schedule a downtime returns "OK" response

require "datadog_api_client"
api_instance = DatadogAPIClient::V1::DowntimesAPI.new

body = DatadogAPIClient::V1::Downtime.new({
message: "Example-Downtime",
start: Time.now.to_i,
_end: (Time.now + 1 * 3600).to_i,
timezone: "Etc/UTC",
scope: [
"test:exampledowntime",
],
recurrence: DatadogAPIClient::V1::DowntimeRecurrence.new({
type: "weeks",
period: 1,
week_days: [
"Mon",
"Tue",
"Wed",
"Thu",
"Fri",
],
until_date: (Time.now + 21 * 86400).to_i,
}),
notify_end_states: [
DatadogAPIClient::V1::NotifyEndState::ALERT,
DatadogAPIClient::V1::NotifyEndState::NO_DATA,
DatadogAPIClient::V1::NotifyEndState::WARN,
],
notify_end_types: [
DatadogAPIClient::V1::NotifyEndType::CANCELED,
DatadogAPIClient::V1::NotifyEndType::EXPIRED,
],
})
p api_instance.create_downtime(body)

```
Schedule a downtime until date
**```
# Schedule a downtime until date

require "datadog_api_client"
api_instance = DatadogAPIClient::V1::DowntimesAPI.new

body = DatadogAPIClient::V1::Downtime.new({
message: "Example-Downtime",
recurrence: DatadogAPIClient::V1::DowntimeRecurrence.new({
period: 1,
type: "weeks",
until_date: (Time.now + 21 * 86400).to_i,
week_days: [
"Mon",
"Tue",
"Wed",
"Thu",
"Fri",
],
}),
scope: [
"*",
],
start: Time.now.to_i,
_end: (Time.now + 1 * 3600).to_i,
timezone: "Etc/UTC",
mute_first_recovery_notification: true,
monitor_tags: [
"tag0",
],
notify_end_states: [
DatadogAPIClient::V1::NotifyEndState::ALERT,
],
notify_end_types: [
DatadogAPIClient::V1::NotifyEndType::CANCELED,
],
})
p api_instance.create_downtime(body)

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=ruby) and then save the example to `example.rb` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" rb "example.rb"`
```
Schedule a downtime once a year
**```
// Schedule a downtime once a year
use datadog_api_client::datadog;
use datadog_api_client::datadogV1::api_downtimes::DowntimesAPI;
use datadog_api_client::datadogV1::model::Downtime;
use datadog_api_client::datadogV1::model::DowntimeRecurrence;
use datadog_api_client::datadogV1::model::NotifyEndState;
use datadog_api_client::datadogV1::model::NotifyEndType;

#[tokio::main]
async fn main() {
let body = Downtime::new()
.end(Some(1636632671))
.message(Some("Example-Downtime".to_string()))
.monitor_tags(vec!["tag0".to_string()])
.mute_first_recovery_notification(true)
.notify_end_states(vec![NotifyEndState::ALERT, NotifyEndState::WARN])
.notify_end_types(vec![NotifyEndType::EXPIRED])
.recurrence(Some(
DowntimeRecurrence::new()
.period(1)
.type_("years".to_string()),
))
.scope(vec!["*".to_string()])
.start(1636629071)
.timezone("Etc/UTC".to_string());
let configuration = datadog::Configuration::new();
let api = DowntimesAPI::with_config(configuration);
let resp = api.create_downtime(body).await;
if let Ok(value) = resp {
println!("{:#?}", value);
} else {
println!("{:#?}", resp.unwrap_err());
}
}

```
Schedule a downtime returns "OK" response
**```
// Schedule a downtime returns "OK" response
use datadog_api_client::datadog;
use datadog_api_client::datadogV1::api_downtimes::DowntimesAPI;
use datadog_api_client::datadogV1::model::Downtime;
use datadog_api_client::datadogV1::model::DowntimeRecurrence;
use datadog_api_client::datadogV1::model::NotifyEndState;
use datadog_api_client::datadogV1::model::NotifyEndType;

#[tokio::main]
async fn main() {
let body = Downtime::new()
.end(Some(1636632671))
.message(Some("Example-Downtime".to_string()))
.notify_end_states(vec![
NotifyEndState::ALERT,
NotifyEndState::NO_DATA,
NotifyEndState::WARN,
])
.notify_end_types(vec![NotifyEndType::CANCELED, NotifyEndType::EXPIRED])
.recurrence(Some(
DowntimeRecurrence::new()
.period(1)
.type_("weeks".to_string())
.until_date(Some(1638443471))
.week_days(Some(vec![
"Mon".to_string(),
"Tue".to_string(),
"Wed".to_string(),
"Thu".to_string(),
"Fri".to_string(),
])),
))
.scope(vec!["test:exampledowntime".to_string()])
.start(1636629071)
.timezone("Etc/UTC".to_string());
let configuration = datadog::Configuration::new();
let api = DowntimesAPI::with_config(configuration);
let resp = api.create_downtime(body).await;
if let Ok(value) = resp {
println!("{:#?}", value);
} else {
println!("{:#?}", resp.unwrap_err());
}
}

```
Schedule a downtime until date
**```
// Schedule a downtime until date
use datadog_api_client::datadog;
use datadog_api_client::datadogV1::api_downtimes::DowntimesAPI;
use datadog_api_client::datadogV1::model::Downtime;
use datadog_api_client::datadogV1::model::DowntimeRecurrence;
use datadog_api_client::datadogV1::model::NotifyEndState;
use datadog_api_client::datadogV1::model::NotifyEndType;

#[tokio::main]
async fn main() {
let body = Downtime::new()
.end(Some(1636632671))
.message(Some("Example-Downtime".to_string()))
.monitor_tags(vec!["tag0".to_string()])
.mute_first_recovery_notification(true)
.notify_end_states(vec![NotifyEndState::ALERT])
.notify_end_types(vec![NotifyEndType::CANCELED])
.recurrence(Some(
DowntimeRecurrence::new()
.period(1)
.type_("weeks".to_string())
.until_date(Some(1638443471))
.week_days(Some(vec![
"Mon".to_string(),
"Tue".to_string(),
"Wed".to_string(),
"Thu".to_string(),
"Fri".to_string(),
])),
))
.scope(vec!["*".to_string()])
.start(1636629071)
.timezone("Etc/UTC".to_string());
let configuration = datadog::Configuration::new();
let api = DowntimesAPI::with_config(configuration);
let resp = api.create_downtime(body).await;
if let Ok(value) = resp {
println!("{:#?}", value);
} else {
println!("{:#?}", resp.unwrap_err());
}
}

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=rust) and then save the example to `src/main.rs` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" cargo run`
```
Schedule a downtime once a year
**```
/**
* Schedule a downtime once a year
*/

import { client, v1 } from "@datadog/datadog-api-client";

const configuration = client.createConfiguration();
const apiInstance = new v1.DowntimesApi(configuration);

const params: v1.DowntimesApiCreateDowntimeRequest = {
body: {
message: "Example-Downtime",
recurrence: {
period: 1,
type: "years",
},
scope: ["*"],
start: Math.round(new Date().getTime() / 1000),
end: Math.round(
new Date(new Date().getTime() + 1 * 3600 * 1000).getTime() / 1000
),
timezone: "Etc/UTC",
muteFirstRecoveryNotification: true,
monitorTags: ["tag0"],
notifyEndStates: ["alert", "warn"],
notifyEndTypes: ["expired"],
},
};

apiInstance
.createDowntime(params)
.then((data: v1.Downtime) => {
console.log(
"API called successfully. Returned data: " + JSON.stringify(data)
);
})
.catch((error: any) => console.error(error));

```
Schedule a downtime returns "OK" response
**```
/**
* Schedule a downtime returns "OK" response
*/

import { client, v1 } from "@datadog/datadog-api-client";

const configuration = client.createConfiguration();
const apiInstance = new v1.DowntimesApi(configuration);

const params: v1.DowntimesApiCreateDowntimeRequest = {
body: {
message: "Example-Downtime",
start: Math.round(new Date().getTime() / 1000),
end: Math.round(
new Date(new Date().getTime() + 1 * 3600 * 1000).getTime() / 1000
),
timezone: "Etc/UTC",
scope: ["test:exampledowntime"],
recurrence: {
type: "weeks",
period: 1,
weekDays: ["Mon", "Tue", "Wed", "Thu", "Fri"],
untilDate: Math.round(
new Date(new Date().getTime() + 21 * 86400 * 1000).getTime() / 1000
),
},
notifyEndStates: ["alert", "no data", "warn"],
notifyEndTypes: ["canceled", "expired"],
},
};

apiInstance
.createDowntime(params)
.then((data: v1.Downtime) => {
console.log(
"API called successfully. Returned data: " + JSON.stringify(data)
);
})
.catch((error: any) => console.error(error));

```
Schedule a downtime until date
**```
/**
* Schedule a downtime until date
*/

import { client, v1 } from "@datadog/datadog-api-client";

const configuration = client.createConfiguration();
const apiInstance = new v1.DowntimesApi(configuration);

const params: v1.DowntimesApiCreateDowntimeRequest = {
body: {
message: "Example-Downtime",
recurrence: {
period: 1,
type: "weeks",
untilDate: Math.round(
new Date(new Date().getTime() + 21 * 86400 * 1000).getTime() / 1000
),
weekDays: ["Mon", "Tue", "Wed", "Thu", "Fri"],
},
scope: ["*"],
start: Math.round(new Date().getTime() / 1000),
end: Math.round(
new Date(new Date().getTime() + 1 * 3600 * 1000).getTime() / 1000
),
timezone: "Etc/UTC",
muteFirstRecoveryNotification: true,
monitorTags: ["tag0"],
notifyEndStates: ["alert"],
notifyEndTypes: ["canceled"],
},
};

apiInstance
.createDowntime(params)
.then((data: v1.Downtime) => {
console.log(
"API called successfully. Returned data: " + JSON.stringify(data)
);
})
.catch((error: any) => console.error(error));

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=typescript) and then save the example to `example.ts` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" tsc "example.ts"`
```POST https://api.ap1.datadoghq.com/api/v2/downtimehttps://api.ap2.datadoghq.com/api/v2/downtimehttps://api.datadoghq.eu/api/v2/downtimehttps://api.ddog-gov.com/api/v2/downtimehttps://api.datadoghq.com/api/v2/downtimehttps://api.us3.datadoghq.com/api/v2/downtimehttps://api.us5.datadoghq.com/api/v2/downtime
### OverviewSchedule a downtime.
This endpoint requires the `monitors_downtime` permission.OAuth apps require the `monitors_downtime` authorization scope to access this endpoint.
### Request#### Body Data (required)Schedule a downtime request body.
- Model
- Example
Expand All
Field
Type
Description
data [*required*]
object
Object to create a downtime.
attributes [*required*]
object
Downtime details.
display_timezone
string
The timezone in which to display the downtime's start and end times in Datadog applications. This is not used
as an offset for scheduling.default: `UTC`
message
string
A message to include with notifications for this downtime. Email notifications can be sent to specific users
by using the same `@username` notation as events. monitor_identifier [*required*]
 <oneOf>
Monitor identifier for the downtime.
Option 1
object
Object of the monitor identifier.
monitor_id [*required*]
int64
ID of the monitor to prevent notifications.
Option 2
object
Object of the monitor tags.
monitor_tags [*required*]
[string]
A list of monitor tags. For example, tags that are applied directly to monitors,
not tags that are used in monitor queries (which are filtered by the scope parameter), to which the downtime applies.
The resulting downtime applies to monitors that match **all** provided monitor tags. Setting `monitor_tags`
to `[*]` configures the downtime to mute all monitors for the given scope.mute_first_recovery_notification
boolean
If the first recovery notification during a downtime should be muted.
notify_end_states
[string]
States that will trigger a monitor notification when the `notify_end_types` action occurs.
notify_end_types
[string]
Actions that will trigger a monitor notification if the downtime is in the `notify_end_types` state.
schedule
 <oneOf>
Schedule for the downtime.
Option 1
object
A recurring downtime schedule definition.
recurrences [*required*]
[object]
A list of downtime recurrences.
duration [*required*]
string
The length of the downtime. Must begin with an integer and end with one of 'm', 'h', d', or 'w'.
rrule [*required*]
string
The `RRULE` standard for defining recurring events.
For example, to have a recurring event on the first day of each month, set the type to `rrule` and set the `FREQ` to `MONTHLY` and `BYMONTHDAY` to `1`.
Most common `rrule` options from the iCalendar Spec are supported.**Note**: Attributes specifying the duration in `RRULE` are not supported (for example, `DTSTART`, `DTEND`, `DURATION`).
More examples available in this [downtime guide](https://docs.datadoghq.com/monitors/guide/suppress-alert-with-downtimes/?tab=api).start
string
ISO-8601 Datetime to start the downtime. Must not include a UTC offset. If not provided, the
downtime starts the moment it is created.timezone
string
The timezone in which to schedule the downtime.
default: `UTC`
Option 2
object
A one-time downtime definition.
end
date-time
ISO-8601 Datetime to end the downtime. Must include a UTC offset of zero. If not provided, the
downtime continues forever.start
date-time
ISO-8601 Datetime to start the downtime. Must include a UTC offset of zero. If not provided, the
downtime starts the moment it is created.scope [*required*]
string
The scope to which the downtime applies. Must follow the common search syntax.
type [*required*]
enum
Downtime resource type.
Allowed enum values: `downtime`default: `downtime`
```
{
"data": {
"attributes": {
"message": "dark forest",
"monitor_identifier": {
"monitor_tags": [
"cat:hat"
]
},
"scope": "test:exampledowntime",
"schedule": {
"start": null
}
},
"type": "downtime"
}
}
```### Response- 200
- 400
- 403
- 429
OK
- Model
- Example
Downtiming gives you greater control over monitor notifications by
allowing you to globally exclude scopes from alerting.
Downtime settings, which can be scheduled with start and end times,
prevent all alerting related to specified Datadog tags.Expand All
Field
Type
Description
data
object
Downtime data.
attributes
object
Downtime details.
canceled
date-time
Time that the downtime was canceled.
created
date-time
Creation time of the downtime.
display_timezone
string
The timezone in which to display the downtime's start and end times in Datadog applications. This is not used
as an offset for scheduling.default: `UTC`
message
string
A message to include with notifications for this downtime. Email notifications can be sent to specific users
by using the same `@username` notation as events.modified
date-time
Time that the downtime was last modified.
monitor_identifier
 <oneOf>
Monitor identifier for the downtime.
Option 1
object
Object of the monitor identifier.
monitor_id [*required*]
int64
ID of the monitor to prevent notifications.
Option 2
object
Object of the monitor tags.
monitor_tags [*required*]
[string]
A list of monitor tags. For example, tags that are applied directly to monitors,
not tags that are used in monitor queries (which are filtered by the scope parameter), to which the downtime applies.
The resulting downtime applies to monitors that match **all** provided monitor tags. Setting `monitor_tags`
to `[*]` configures the downtime to mute all monitors for the given scope.mute_first_recovery_notification
boolean
If the first recovery notification during a downtime should be muted.
notify_end_states
[string]
States that will trigger a monitor notification when the `notify_end_types` action occurs.
notify_end_types
[string]
Actions that will trigger a monitor notification if the downtime is in the `notify_end_types` state.
schedule
 <oneOf>
The schedule that defines when the monitor starts, stops, and recurs. There are two types of schedules:
one-time and recurring. Recurring schedules may have up to five RRULE-based recurrences. If no schedules are
provided, the downtime will begin immediately and never end. Option 1
object
A recurring downtime schedule definition.
current_downtime
object
The most recent actual start and end dates for a recurring downtime. For a canceled downtime,
this is the previously occurring downtime. For active downtimes, this is the ongoing downtime, and for scheduled
downtimes it is the upcoming downtime.end
date-time
The end of the current downtime.
start
date-time
The start of the current downtime.
recurrences [*required*]
[object]
A list of downtime recurrences.
duration
string
The length of the downtime. Must begin with an integer and end with one of 'm', 'h', d', or 'w'.
rrule
string
The `RRULE` standard for defining recurring events.
For example, to have a recurring event on the first day of each month, set the type to `rrule` and set the `FREQ` to `MONTHLY` and `BYMONTHDAY` to `1`.
Most common `rrule` options from the iCalendar Spec are supported.**Note**: Attributes specifying the duration in `RRULE` are not supported (for example, `DTSTART`, `DTEND`, `DURATION`).
More examples available in this [downtime guide](https://docs.datadoghq.com/monitors/guide/suppress-alert-with-downtimes/?tab=api).start
string
ISO-8601 Datetime to start the downtime. Must not include a UTC offset. If not provided, the
downtime starts the moment it is created.timezone
string
The timezone in which to schedule the downtime. This affects recurring start and end dates.
Must match `display_timezone`.default: `UTC`
Option 2
object
A one-time downtime definition.
end
date-time
ISO-8601 Datetime to end the downtime.
start [*required*]
date-time
ISO-8601 Datetime to start the downtime.
scope
string
The scope to which the downtime applies. Must follow the common search syntax.
status
enum
The current status of the downtime.
Allowed enum values: `active,canceled,ended,scheduled`id
string
The downtime ID.
relationships
object
All relationships associated with downtime.
created_by
object
The user who created the downtime.
data
object
Data for the user who created the downtime.
id
string
User ID of the downtime creator.
type
enum
Users resource type.
Allowed enum values: `users`default: `users`
monitor
object
The monitor identified by the downtime.
data
object
Data for the monitor.
id
string
Monitor ID of the downtime.
type
enum
Monitor resource type.
Allowed enum values: `monitors`default: `monitors`
type
enum
Downtime resource type.
Allowed enum values: `downtime`default: `downtime`
included
[ <oneOf>]
Array of objects related to the downtime that the user requested.
Option 1
object
User object returned by the API.
attributes
object
Attributes of user object returned by the API.
created_at
date-time
Creation time of the user.
disabled
boolean
Whether the user is disabled.
email
string
Email of the user.
handle
string
Handle of the user.
icon
string
URL of the user's icon.
last_login_time
date-time
The last time the user logged in.
mfa_enabled
boolean
If user has MFA enabled.
modified_at
date-time
Time that the user was last modified.
name
string
Name of the user.
service_account
boolean
Whether the user is a service account.
status
string
Status of the user.
title
string
Title of the user.
verified
boolean
Whether the user is verified.
id
string
ID of the user.
relationships
object
Relationships of the user object returned by the API.
org
object
Relationship to an organization.
data [*required*]
object
Relationship to organization object.
id [*required*]
string
ID of the organization.
type [*required*]
enum
Organizations resource type.
Allowed enum values: `orgs`default: `orgs`
other_orgs
object
Relationship to organizations.
data [*required*]
[object]
Relationships to organization objects.
id [*required*]
string
ID of the organization.
type [*required*]
enum
Organizations resource type.
Allowed enum values: `orgs`default: `orgs`
other_users
object
Relationship to users.
data [*required*]
[object]
Relationships to user objects.
id [*required*]
string
A unique identifier that represents the user.
type [*required*]
enum
Users resource type.
Allowed enum values: `users`default: `users`
roles
object
Relationship to roles.
data
[object]
An array containing type and the unique identifier of a role.
id
string
The unique identifier of the role.
type
enum
Roles type.
Allowed enum values: `roles`default: `roles`
type
enum
Users resource type.
Allowed enum values: `users`default: `users`
Option 2
object
Information about the monitor identified by the downtime.
attributes
object
Attributes of the monitor identified by the downtime.
name
string
The name of the monitor identified by the downtime.
id
int64
ID of the monitor identified by the downtime.
type
enum
Monitor resource type.
Allowed enum values: `monitors`default: `monitors`
```
{
"data": {
"attributes": {
"canceled": "2020-01-02T03:04:05.282979+0000",
"created": "2020-01-02T03:04:05.282979+0000",
"display_timezone": "America/New_York",
"message": "Message about the downtime",
"modified": "2020-01-02T03:04:05.282979+0000",
"monitor_identifier": {
"monitor_id": 123
},
"mute_first_recovery_notification": false,
"notify_end_states": [
"alert",
"warn"
],
"notify_end_types": [
"canceled",
"expired"
],
"schedule": {
"current_downtime": {
"end": "2020-01-02T03:04:00.000Z",
"start": "2020-01-02T03:04:00.000Z"
},
"recurrences": [
{
"duration": "123d",
"rrule": "FREQ=MONTHLY;BYSETPOS=3;BYDAY=WE;INTERVAL=1",
"start": "2020-01-02T03:04"
}
],
"timezone": "America/New_York"
},
"scope": "env:(staging OR prod) AND datacenter:us-east-1",
"status": "active"
},
"id": "00000000-0000-1234-0000-000000000000",
"relationships": {
"created_by": {
"data": {
"id": "00000000-0000-1234-0000-000000000000",
"type": "users"
}
},
"monitor": {
"data": {
"id": "12345",
"type": "monitors"
}
}
},
"type": "downtime"
},
"included": [
{
"attributes": {
"created_at": "2019-09-19T10:00:00.000Z",
"disabled": false,
"email": "string",
"handle": "string",
"icon": "string",
"last_login_time": "2019-09-19T10:00:00.000Z",
"mfa_enabled": false,
"modified_at": "2019-09-19T10:00:00.000Z",
"name": "string",
"service_account": false,
"status": "string",
"title": "string",
"verified": false
},
"id": "string",
"relationships": {
"org": {
"data": {
"id": "00000000-0000-beef-0000-000000000000",
"type": "orgs"
}
},
"other_orgs": {
"data": [
{
"id": "00000000-0000-beef-0000-000000000000",
"type": "orgs"
}
]
},
"other_users": {
"data": [
{
"id": "00000000-0000-0000-2345-000000000000",
"type": "users"
}
]
},
"roles": {
"data": [
{
"id": "3653d3c6-0c75-11ea-ad28-fb5701eabc7d",
"type": "roles"
}
]
}
},
"type": "users"
}
]
}
```Bad Request
- Model
- Example
API error response.
Expand All
Field
Type
Description
errors [*required*]
[string]
A list of errors.
```
{
"errors": [
"Bad Request"
]
}
```Forbidden
- Model
- Example
API error response.
Expand All
Field
Type
Description
errors [*required*]
[string]
A list of errors.
```
{
"errors": [
"Bad Request"
]
}
```Too many requests
- Model
- Example
API error response.
Expand All
Field
Type
Description
errors [*required*]
[string]
A list of errors.
```
{
"errors": [
"Bad Request"
]
}
```### Code Example- [Curl](?code-lang=curl#)
- [Go](?code-lang=go#)
- [Java](?code-lang=java#)
- [Python](?code-lang=python#)
- [Ruby](?code-lang=ruby#)
- [Rust](?code-lang=rust#)
- [Typescript](?code-lang=typescript#)

Schedule a downtime returns "OK" responseCopy```

# Curl commandcurl -X POST "https://api.ap1.datadoghq.com"https://api.ap2.datadoghq.com"https://api.datadoghq.eu"https://api.ddog-gov.com"https://api.datadoghq.com"https://api.us3.datadoghq.com"https://api.us5.datadoghq.com/api/v2/downtime" \
-H "Accept: application/json" \
-H "Content-Type: application/json" \
-H "DD-API-KEY: ${DD_API_KEY}" \
-H "DD-APPLICATION-KEY: ${DD_APP_KEY}" \
-d @- << EOF
{
"data": {
"attributes": {
"message": "dark forest",
"monitor_identifier": {
"monitor_tags": [
"cat:hat"
]
},
"scope": "test:exampledowntime",
"schedule": {
"start": null
}
},
"type": "downtime"
}
}
EOF

```
Schedule a downtime returns "OK" response```
// Schedule a downtime returns "OK" response

package main

import (
	"context"
	"encoding/json"
	"fmt"
	"os"

	"github.com/DataDog/datadog-api-client-go/v2/api/datadog"
	"github.com/DataDog/datadog-api-client-go/v2/api/datadogV2"
)

func main() {
	body := datadogV2.DowntimeCreateRequest{
		Data: datadogV2.DowntimeCreateRequestData{
			Attributes: datadogV2.DowntimeCreateRequestAttributes{
				Message: *datadog.NewNullableString(datadog.PtrString("dark forest")),
				MonitorIdentifier: datadogV2.DowntimeMonitorIdentifier{
					DowntimeMonitorIdentifierTags: &datadogV2.DowntimeMonitorIdentifierTags{
						MonitorTags: []string{
							"cat:hat",
						},
					}},
				Scope: "test:exampledowntime",
				Schedule: &datadogV2.DowntimeScheduleCreateRequest{
					DowntimeScheduleOneTimeCreateUpdateRequest: &datadogV2.DowntimeScheduleOneTimeCreateUpdateRequest{
						Start: *datadog.NewNullableTime(nil),
					}},
			},
			Type: datadogV2.DOWNTIMERESOURCETYPE_DOWNTIME,
		},
	}
	ctx := datadog.NewDefaultContext(context.Background())
	configuration := datadog.NewConfiguration()
	apiClient := datadog.NewAPIClient(configuration)
	api := datadogV2.NewDowntimesApi(apiClient)
	resp, r, err := api.CreateDowntime(ctx, body)

	if err != nil {
		fmt.Fprintf(os.Stderr, "Error when calling `DowntimesApi.CreateDowntime`: %v\n", err)
		fmt.Fprintf(os.Stderr, "Full HTTP response: %v\n", r)
	}

	responseContent, _ := json.MarshalIndent(resp, "", " ")
	fmt.Fprintf(os.Stdout, "Response from `DowntimesApi.CreateDowntime`:\n%s\n", responseContent)
}

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=go) and then save the example to `main.go` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" go run "main.go"`
```
Schedule a downtime returns "OK" response```
// Schedule a downtime returns "OK" response

import com.datadog.api.client.ApiClient;
import com.datadog.api.client.ApiException;
import com.datadog.api.client.v2.api.DowntimesApi;
import com.datadog.api.client.v2.model.DowntimeCreateRequest;
import com.datadog.api.client.v2.model.DowntimeCreateRequestAttributes;
import com.datadog.api.client.v2.model.DowntimeCreateRequestData;
import com.datadog.api.client.v2.model.DowntimeMonitorIdentifier;
import com.datadog.api.client.v2.model.DowntimeMonitorIdentifierTags;
import com.datadog.api.client.v2.model.DowntimeResourceType;
import com.datadog.api.client.v2.model.DowntimeResponse;
import com.datadog.api.client.v2.model.DowntimeScheduleCreateRequest;
import com.datadog.api.client.v2.model.DowntimeScheduleOneTimeCreateUpdateRequest;
import java.util.Collections;

public class Example {
public static void main(String[] args) {
ApiClient defaultClient = ApiClient.getDefaultApiClient();
DowntimesApi apiInstance = new DowntimesApi(defaultClient);

DowntimeCreateRequest body =
new DowntimeCreateRequest()
.data(
new DowntimeCreateRequestData()
.attributes(
new DowntimeCreateRequestAttributes()
.message("dark forest")
.monitorIdentifier(
new DowntimeMonitorIdentifier(
new DowntimeMonitorIdentifierTags()
.monitorTags(Collections.singletonList("cat:hat"))))
.scope("test:exampledowntime")
.schedule(
new DowntimeScheduleCreateRequest(
new DowntimeScheduleOneTimeCreateUpdateRequest().start(null))))
.type(DowntimeResourceType.DOWNTIME));

try {
DowntimeResponse result = apiInstance.createDowntime(body);
System.out.println(result);
} catch (ApiException e) {
System.err.println("Exception when calling DowntimesApi#createDowntime");
System.err.println("Status code: " + e.getCode());
System.err.println("Reason: " + e.getResponseBody());
System.err.println("Response headers: " + e.getResponseHeaders());
e.printStackTrace();
}
}
}

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=java) and then save the example to `Example.java` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" java "Example.java"`
```
Schedule a downtime returns "OK" response```
"""
Schedule a downtime returns "OK" response
"""

from datadog_api_client import ApiClient, Configuration
from datadog_api_client.v2.api.downtimes_api import DowntimesApi
from datadog_api_client.v2.model.downtime_create_request import DowntimeCreateRequest
from datadog_api_client.v2.model.downtime_create_request_attributes import DowntimeCreateRequestAttributes
from datadog_api_client.v2.model.downtime_create_request_data import DowntimeCreateRequestData
from datadog_api_client.v2.model.downtime_monitor_identifier_tags import DowntimeMonitorIdentifierTags
from datadog_api_client.v2.model.downtime_resource_type import DowntimeResourceType
from datadog_api_client.v2.model.downtime_schedule_one_time_create_update_request import (
DowntimeScheduleOneTimeCreateUpdateRequest,
)

body = DowntimeCreateRequest(
data=DowntimeCreateRequestData(
attributes=DowntimeCreateRequestAttributes(
message="dark forest",
monitor_identifier=DowntimeMonitorIdentifierTags(
monitor_tags=[
"cat:hat",
],
),
scope="test:exampledowntime",
schedule=DowntimeScheduleOneTimeCreateUpdateRequest(
start=None,
),
),
type=DowntimeResourceType.DOWNTIME,
),
)

configuration = Configuration()
with ApiClient(configuration) as api_client:
api_instance = DowntimesApi(api_client)
response = api_instance.create_downtime(body=body)

print(response)

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=python) and then save the example to `example.py` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" python3 "example.py"`
```
Schedule a downtime returns "OK" response```
# Schedule a downtime returns "OK" response

require "datadog_api_client"
api_instance = DatadogAPIClient::V2::DowntimesAPI.new

body = DatadogAPIClient::V2::DowntimeCreateRequest.new({
data: DatadogAPIClient::V2::DowntimeCreateRequestData.new({
attributes: DatadogAPIClient::V2::DowntimeCreateRequestAttributes.new({
message: "dark forest",
monitor_identifier: DatadogAPIClient::V2::DowntimeMonitorIdentifierTags.new({
monitor_tags: [
"cat:hat",
],
}),
scope: "test:exampledowntime",
schedule: DatadogAPIClient::V2::DowntimeScheduleOneTimeCreateUpdateRequest.new({
start: nil,
}),
}),
type: DatadogAPIClient::V2::DowntimeResourceType::DOWNTIME,
}),
})
p api_instance.create_downtime(body)

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=ruby) and then save the example to `example.rb` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" rb "example.rb"`
```
Schedule a downtime returns "OK" response```
// Schedule a downtime returns "OK" response
use datadog_api_client::datadog;
use datadog_api_client::datadogV2::api_downtimes::DowntimesAPI;
use datadog_api_client::datadogV2::model::DowntimeCreateRequest;
use datadog_api_client::datadogV2::model::DowntimeCreateRequestAttributes;
use datadog_api_client::datadogV2::model::DowntimeCreateRequestData;
use datadog_api_client::datadogV2::model::DowntimeMonitorIdentifier;
use datadog_api_client::datadogV2::model::DowntimeMonitorIdentifierTags;
use datadog_api_client::datadogV2::model::DowntimeResourceType;
use datadog_api_client::datadogV2::model::DowntimeScheduleCreateRequest;
use datadog_api_client::datadogV2::model::DowntimeScheduleOneTimeCreateUpdateRequest;

#[tokio::main]
async fn main() {
let body = DowntimeCreateRequest::new(DowntimeCreateRequestData::new(
DowntimeCreateRequestAttributes::new(
DowntimeMonitorIdentifier::DowntimeMonitorIdentifierTags(Box::new(
DowntimeMonitorIdentifierTags::new(vec!["cat:hat".to_string()]),
)),
"test:exampledowntime".to_string(),
)
.message(Some("dark forest".to_string()))
.schedule(
DowntimeScheduleCreateRequest::DowntimeScheduleOneTimeCreateUpdateRequest(Box::new(
DowntimeScheduleOneTimeCreateUpdateRequest::new().start(None),
)),
),
DowntimeResourceType::DOWNTIME,
));
let configuration = datadog::Configuration::new();
let api = DowntimesAPI::with_config(configuration);
let resp = api.create_downtime(body).await;
if let Ok(value) = resp {
println!("{:#?}", value);
} else {
println!("{:#?}", resp.unwrap_err());
}
}

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=rust) and then save the example to `src/main.rs` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" cargo run`
```
Schedule a downtime returns "OK" response```
/**
* Schedule a downtime returns "OK" response
*/

import { client, v2 } from "@datadog/datadog-api-client";

const configuration = client.createConfiguration();
const apiInstance = new v2.DowntimesApi(configuration);

const params: v2.DowntimesApiCreateDowntimeRequest = {
body: {
data: {
attributes: {
message: "dark forest",
monitorIdentifier: {
monitorTags: ["cat:hat"],
},
scope: "test:exampledowntime",
schedule: {
start: undefined,
},
},
type: "downtime",
},
},
};

apiInstance
.createDowntime(params)
.then((data: v2.DowntimeResponse) => {
console.log(
"API called successfully. Returned data: " + JSON.stringify(data)
);
})
.catch((error: any) => console.error(error));

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=typescript) and then save the example to `example.ts` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" tsc "example.ts"`
```## Cancel downtimes by scope- v1 (deprecated)
POST https://api.ap1.datadoghq.com/api/v1/downtime/cancel/by_scopehttps://api.ap2.datadoghq.com/api/v1/downtime/cancel/by_scopehttps://api.datadoghq.eu/api/v1/downtime/cancel/by_scopehttps://api.ddog-gov.com/api/v1/downtime/cancel/by_scopehttps://api.datadoghq.com/api/v1/downtime/cancel/by_scopehttps://api.us3.datadoghq.com/api/v1/downtime/cancel/by_scopehttps://api.us5.datadoghq.com/api/v1/downtime/cancel/by_scope
### OverviewDelete all downtimes that match the scope of `X`. **Note:** This only interacts with Downtimes created using v1 endpoints. This endpoint has been deprecated and will not be replaced. Please use v2 endpoints to find and cancel downtimes.
This endpoint requires the `monitors_downtime` permission.OAuth apps require the `monitors_downtime` authorization scope to access this endpoint.
### Request#### Body Data (required)Scope to cancel downtimes for.
- Model
- Example
Expand All
Field
Type
Description
scope [*required*]
string
The scope(s) to which the downtime applies and must be in `key:value` format. For example, `host:app2`.
Provide multiple scopes as a comma-separated list like `env:dev,env:prod`.
The resulting downtime applies to sources that matches ALL provided scopes (`env:dev` **AND** `env:prod`).```
{
"scope": "string"
}
```### Response- 200
- 400
- 403
- 404
- 429
OK
- Model
- Example
Object containing array of IDs of canceled downtimes.
Expand All
Field
Type
Description
cancelled_ids
[integer]
ID of downtimes that were canceled.
```
{
"cancelled_ids": [
123456789,
123456790
]
}
```Bad Request
- Model
- Example
Error response object.
Expand All
Field
Type
Description
errors [*required*]
[string]
Array of errors returned by the API.
```
{
"errors": [
"Bad Request"
]
}
```Forbidden
- Model
- Example
Error response object.
Expand All
Field
Type
Description
errors [*required*]
[string]
Array of errors returned by the API.
```
{
"errors": [
"Bad Request"
]
}
```Downtimes not found
- Model
- Example
Error response object.
Expand All
Field
Type
Description
errors [*required*]
[string]
Array of errors returned by the API.
```
{
"errors": [
"Bad Request"
]
}
```Too many requests
- Model
- Example
Error response object.
Expand All
Field
Type
Description
errors [*required*]
[string]
Array of errors returned by the API.
```
{
"errors": [
"Bad Request"
]
}
```### Code Example- [Curl](?code-lang=curl#)
- [Go](?code-lang=go#)
- [Java](?code-lang=java#)
- [Python](?code-lang=python#)
- [Ruby](?code-lang=ruby#)
- [Rust](?code-lang=rust#)
- [Typescript](?code-lang=typescript#)
- [Python [legacy]](?code-lang=python-legacy#)
- [Ruby [legacy]](?code-lang=ruby-legacy#)

Cancel downtimes by scope returns "OK" responseCopy```

# Curl commandcurl -X POST "https://api.ap1.datadoghq.com"https://api.ap2.datadoghq.com"https://api.datadoghq.eu"https://api.ddog-gov.com"https://api.datadoghq.com"https://api.us3.datadoghq.com"https://api.us5.datadoghq.com/api/v1/downtime/cancel/by_scope" \
-H "Accept: application/json" \
-H "Content-Type: application/json" \
-H "DD-API-KEY: ${DD_API_KEY}" \
-H "DD-APPLICATION-KEY: ${DD_APP_KEY}" \
-d @- << EOF
{
"scope": "string"
}
EOF

```
Cancel downtimes by scope returns "OK" response```
// Cancel downtimes by scope returns "OK" response

package main

import (
	"context"
	"encoding/json"
	"fmt"
	"os"

	"github.com/DataDog/datadog-api-client-go/v2/api/datadog"
	"github.com/DataDog/datadog-api-client-go/v2/api/datadogV1"
)

func main() {
	// there is a valid "downtime" in the system
	DowntimeScope0 := os.Getenv("DOWNTIME_SCOPE_0")

	body := datadogV1.CancelDowntimesByScopeRequest{
		Scope: DowntimeScope0,
	}
	ctx := datadog.NewDefaultContext(context.Background())
	configuration := datadog.NewConfiguration()
	apiClient := datadog.NewAPIClient(configuration)
	api := datadogV1.NewDowntimesApi(apiClient)
	resp, r, err := api.CancelDowntimesByScope(ctx, body)

	if err != nil {
		fmt.Fprintf(os.Stderr, "Error when calling `DowntimesApi.CancelDowntimesByScope`: %v\n", err)
		fmt.Fprintf(os.Stderr, "Full HTTP response: %v\n", r)
	}

	responseContent, _ := json.MarshalIndent(resp, "", " ")
	fmt.Fprintf(os.Stdout, "Response from `DowntimesApi.CancelDowntimesByScope`:\n%s\n", responseContent)
}

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=go) and then save the example to `main.go` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" go run "main.go"`
```
Cancel downtimes by scope returns "OK" response```
// Cancel downtimes by scope returns "OK" response

import com.datadog.api.client.ApiClient;
import com.datadog.api.client.ApiException;
import com.datadog.api.client.v1.api.DowntimesApi;
import com.datadog.api.client.v1.model.CancelDowntimesByScopeRequest;
import com.datadog.api.client.v1.model.CanceledDowntimesIds;

public class Example {
public static void main(String[] args) {
ApiClient defaultClient = ApiClient.getDefaultApiClient();
DowntimesApi apiInstance = new DowntimesApi(defaultClient);

// there is a valid "downtime" in the system
String DOWNTIME_SCOPE_0 = System.getenv("DOWNTIME_SCOPE_0");

CancelDowntimesByScopeRequest body =
new CancelDowntimesByScopeRequest().scope(DOWNTIME_SCOPE_0);

try {
CanceledDowntimesIds result = apiInstance.cancelDowntimesByScope(body);
System.out.println(result);
} catch (ApiException e) {
System.err.println("Exception when calling DowntimesApi#cancelDowntimesByScope");
System.err.println("Status code: " + e.getCode());
System.err.println("Reason: " + e.getResponseBody());
System.err.println("Response headers: " + e.getResponseHeaders());
e.printStackTrace();
}
}
}

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=java) and then save the example to `Example.java` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" java "Example.java"`
```
Cancel downtimes by scope returns "OK" response```
from datadog import initialize, api

options = {
'api_key': '<DATADOG_API_KEY>',
'app_key': '<DATADOG_APPLICATION_KEY>'
}

initialize(**options)

# Cancel all downtimes with scope
api.Downtime.cancel_downtime_by_scope('env:testing')

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=python-legacy) and then save the example to `example.py` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" python "example.py"`
```
Cancel downtimes by scope returns "OK" response```
"""
Cancel downtimes by scope returns "OK" response
"""

from os import environ
from datadog_api_client import ApiClient, Configuration
from datadog_api_client.v1.api.downtimes_api import DowntimesApi
from datadog_api_client.v1.model.cancel_downtimes_by_scope_request import CancelDowntimesByScopeRequest

# there is a valid "downtime" in the system
DOWNTIME_SCOPE_0 = environ["DOWNTIME_SCOPE_0"]

body = CancelDowntimesByScopeRequest(
scope=DOWNTIME_SCOPE_0,
)

configuration = Configuration()
with ApiClient(configuration) as api_client:
api_instance = DowntimesApi(api_client)
response = api_instance.cancel_downtimes_by_scope(body=body)

print(response)

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=python) and then save the example to `example.py` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" python3 "example.py"`
```
Cancel downtimes by scope returns "OK" response```
require 'dogapi'

api_key = '<DATADOG_API_KEY>'
app_key = '<DATADOG_APPLICATION_KEY>'

dog = Dogapi::Client.new(api_key, app_key)

# Cancel all downtimes with the given scope
dog.cancel_downtime_by_scope('env:testing')

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=ruby-legacy) and then save the example to `example.rb` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" rb "example.rb"`
```
Cancel downtimes by scope returns "OK" response```
# Cancel downtimes by scope returns "OK" response

require "datadog_api_client"
api_instance = DatadogAPIClient::V1::DowntimesAPI.new

# there is a valid "downtime" in the system
DOWNTIME_SCOPE_0 = ENV["DOWNTIME_SCOPE_0"]

body = DatadogAPIClient::V1::CancelDowntimesByScopeRequest.new({
scope: DOWNTIME_SCOPE_0,
})
p api_instance.cancel_downtimes_by_scope(body)

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=ruby) and then save the example to `example.rb` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" rb "example.rb"`
```
Cancel downtimes by scope returns "OK" response```
// Cancel downtimes by scope returns "OK" response
use datadog_api_client::datadog;
use datadog_api_client::datadogV1::api_downtimes::DowntimesAPI;
use datadog_api_client::datadogV1::model::CancelDowntimesByScopeRequest;

#[tokio::main]
async fn main() {
// there is a valid "downtime" in the system
let downtime_scope_0 = std::env::var("DOWNTIME_SCOPE_0").unwrap();
let body = CancelDowntimesByScopeRequest::new(downtime_scope_0.clone());
let configuration = datadog::Configuration::new();
let api = DowntimesAPI::with_config(configuration);
let resp = api.cancel_downtimes_by_scope(body).await;
if let Ok(value) = resp {
println!("{:#?}", value);
} else {
println!("{:#?}", resp.unwrap_err());
}
}

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=rust) and then save the example to `src/main.rs` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" cargo run`
```
Cancel downtimes by scope returns "OK" response```
/**
* Cancel downtimes by scope returns "OK" response
*/

import { client, v1 } from "@datadog/datadog-api-client";

const configuration = client.createConfiguration();
const apiInstance = new v1.DowntimesApi(configuration);

// there is a valid "downtime" in the system
const DOWNTIME_SCOPE_0 = process.env.DOWNTIME_SCOPE_0 as string;

const params: v1.DowntimesApiCancelDowntimesByScopeRequest = {
body: {
scope: DOWNTIME_SCOPE_0,
},
};

apiInstance
.cancelDowntimesByScope(params)
.then((data: v1.CanceledDowntimesIds) => {
console.log(
"API called successfully. Returned data: " + JSON.stringify(data)
);
})
.catch((error: any) => console.error(error));

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=typescript) and then save the example to `example.ts` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" tsc "example.ts"`
```## Cancel a downtime- v1
- v2 (latest)
DELETE https://api.ap1.datadoghq.com/api/v1/downtime/{downtime_id}https://api.ap2.datadoghq.com/api/v1/downtime/{downtime_id}https://api.datadoghq.eu/api/v1/downtime/{downtime_id}https://api.ddog-gov.com/api/v1/downtime/{downtime_id}https://api.datadoghq.com/api/v1/downtime/{downtime_id}https://api.us3.datadoghq.com/api/v1/downtime/{downtime_id}https://api.us5.datadoghq.com/api/v1/downtime/{downtime_id}
### OverviewCancel a downtime. **Note:** This endpoint has been deprecated. Please use v2 endpoints.
This endpoint requires the `monitors_downtime` permission.OAuth apps require the `monitors_downtime` authorization scope to access this endpoint.
### Arguments#### Path ParametersName
Type
Description
downtime_id [*required*]
integer
ID of the downtime to cancel.
### Response- 204
- 403
- 404
- 429
OK
Forbidden
- Model
- Example
Error response object.
Expand All
Field
Type
Description
errors [*required*]
[string]
Array of errors returned by the API.
```
{
"errors": [
"Bad Request"
]
}
```Downtime not found
- Model
- Example
Error response object.
Expand All
Field
Type
Description
errors [*required*]
[string]
Array of errors returned by the API.
```
{
"errors": [
"Bad Request"
]
}
```Too many requests
- Model
- Example
Error response object.
Expand All
Field
Type
Description
errors [*required*]
[string]
Array of errors returned by the API.
```
{
"errors": [
"Bad Request"
]
}
```### Code Example- [Curl](?code-lang=curl#)
- [Python](?code-lang=python#)
- [Ruby](?code-lang=ruby#)
- [Go](?code-lang=go#)
- [Java](?code-lang=java#)
- [Rust](?code-lang=rust#)
- [Typescript](?code-lang=typescript#)

Cancel a downtimeCopy```

# Path parametersexport downtime_id="123456"# Curl commandcurl -X DELETE "https://api.ap1.datadoghq.com"https://api.ap2.datadoghq.com"https://api.datadoghq.eu"https://api.ddog-gov.com"https://api.datadoghq.com"https://api.us3.datadoghq.com"https://api.us5.datadoghq.com/api/v1/downtime/${downtime_id}" \
-H "DD-API-KEY: ${DD_API_KEY}" \
-H "DD-APPLICATION-KEY: ${DD_APP_KEY}"

```
Cancel a downtime```
"""
Cancel a downtime returns "OK" response
"""

from os import environ
from datadog_api_client import ApiClient, Configuration
from datadog_api_client.v1.api.downtimes_api import DowntimesApi

# there is a valid "downtime" in the system
DOWNTIME_ID = environ["DOWNTIME_ID"]

configuration = Configuration()
with ApiClient(configuration) as api_client:
api_instance = DowntimesApi(api_client)
api_instance.cancel_downtime(
downtime_id=int(DOWNTIME_ID),
)

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=python) and then save the example to `example.py` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" python3 "example.py"`
```
Cancel a downtime```
# Cancel a downtime returns "OK" response

require "datadog_api_client"
api_instance = DatadogAPIClient::V1::DowntimesAPI.new

# there is a valid "downtime" in the system
DOWNTIME_ID = ENV["DOWNTIME_ID"]
api_instance.cancel_downtime(DOWNTIME_ID.to_i)

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=ruby) and then save the example to `example.rb` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" rb "example.rb"`
```
Cancel a downtime```
// Cancel a downtime returns "OK" response

package main

import (
	"context"
	"fmt"
	"os"
	"strconv"

	"github.com/DataDog/datadog-api-client-go/v2/api/datadog"
	"github.com/DataDog/datadog-api-client-go/v2/api/datadogV1"
)

func main() {
	// there is a valid "downtime" in the system
	DowntimeID, _ := strconv.ParseInt(os.Getenv("DOWNTIME_ID"), 10, 64)

	ctx := datadog.NewDefaultContext(context.Background())
	configuration := datadog.NewConfiguration()
	apiClient := datadog.NewAPIClient(configuration)
	api := datadogV1.NewDowntimesApi(apiClient)
	r, err := api.CancelDowntime(ctx, DowntimeID)

	if err != nil {
		fmt.Fprintf(os.Stderr, "Error when calling `DowntimesApi.CancelDowntime`: %v\n", err)
		fmt.Fprintf(os.Stderr, "Full HTTP response: %v\n", r)
	}
}

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=go) and then save the example to `main.go` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" go run "main.go"`
```
Cancel a downtime```
// Cancel a downtime returns "OK" response

import com.datadog.api.client.ApiClient;
import com.datadog.api.client.ApiException;
import com.datadog.api.client.v1.api.DowntimesApi;

public class Example {
public static void main(String[] args) {
ApiClient defaultClient = ApiClient.getDefaultApiClient();
DowntimesApi apiInstance = new DowntimesApi(defaultClient);

// there is a valid "downtime" in the system
Long DOWNTIME_ID = Long.parseLong(System.getenv("DOWNTIME_ID"));

try {
apiInstance.cancelDowntime(DOWNTIME_ID);
} catch (ApiException e) {
System.err.println("Exception when calling DowntimesApi#cancelDowntime");
System.err.println("Status code: " + e.getCode());
System.err.println("Reason: " + e.getResponseBody());
System.err.println("Response headers: " + e.getResponseHeaders());
e.printStackTrace();
}
}
}

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=java) and then save the example to `Example.java` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" java "Example.java"`
```
Cancel a downtime```
// Cancel a downtime returns "OK" response
use datadog_api_client::datadog;
use datadog_api_client::datadogV1::api_downtimes::DowntimesAPI;

#[tokio::main]
async fn main() {
// there is a valid "downtime" in the system
let downtime_id: i64 = std::env::var("DOWNTIME_ID").unwrap().parse().unwrap();
let configuration = datadog::Configuration::new();
let api = DowntimesAPI::with_config(configuration);
let resp = api.cancel_downtime(downtime_id.clone()).await;
if let Ok(value) = resp {
println!("{:#?}", value);
} else {
println!("{:#?}", resp.unwrap_err());
}
}

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=rust) and then save the example to `src/main.rs` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" cargo run`
```
Cancel a downtime```
/**
* Cancel a downtime returns "OK" response
*/

import { client, v1 } from "@datadog/datadog-api-client";

const configuration = client.createConfiguration();
const apiInstance = new v1.DowntimesApi(configuration);

// there is a valid "downtime" in the system
const DOWNTIME_ID = parseInt(process.env.DOWNTIME_ID as string);

const params: v1.DowntimesApiCancelDowntimeRequest = {
downtimeId: DOWNTIME_ID,
};

apiInstance
.cancelDowntime(params)
.then((data: any) => {
console.log(
"API called successfully. Returned data: " + JSON.stringify(data)
);
})
.catch((error: any) => console.error(error));

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=typescript) and then save the example to `example.ts` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" tsc "example.ts"`
```DELETE https://api.ap1.datadoghq.com/api/v2/downtime/{downtime_id}https://api.ap2.datadoghq.com/api/v2/downtime/{downtime_id}https://api.datadoghq.eu/api/v2/downtime/{downtime_id}https://api.ddog-gov.com/api/v2/downtime/{downtime_id}https://api.datadoghq.com/api/v2/downtime/{downtime_id}https://api.us3.datadoghq.com/api/v2/downtime/{downtime_id}https://api.us5.datadoghq.com/api/v2/downtime/{downtime_id}
### OverviewCancel a downtime.
**Note**: Downtimes canceled through the API are no longer active, but are retained for approximately two days before being permanently removed. The downtime may still appear in search results until it is permanently removed.
This endpoint requires the `monitors_downtime` permission.OAuth apps require the `monitors_downtime` authorization scope to access this endpoint.
### Arguments#### Path ParametersName
Type
Description
downtime_id [*required*]
string
ID of the downtime to cancel.
### Response- 204
- 403
- 404
- 429
OK
Forbidden
- Model
- Example
API error response.
Expand All
Field
Type
Description
errors [*required*]
[string]
A list of errors.
```
{
"errors": [
"Bad Request"
]
}
```Downtime not found
- Model
- Example
API error response.
Expand All
Field
Type
Description
errors [*required*]
[string]
A list of errors.
```
{
"errors": [
"Bad Request"
]
}
```Too many requests
- Model
- Example
API error response.
Expand All
Field
Type
Description
errors [*required*]
[string]
A list of errors.
```
{
"errors": [
"Bad Request"
]
}
```### Code Example- [Curl](?code-lang=curl#)
- [Python](?code-lang=python#)
- [Ruby](?code-lang=ruby#)
- [Go](?code-lang=go#)
- [Java](?code-lang=java#)
- [Rust](?code-lang=rust#)
- [Typescript](?code-lang=typescript#)

Cancel a downtimeCopy```

# Path parametersexport downtime_id="00000000-0000-1234-0000-000000000000"# Curl commandcurl -X DELETE "https://api.ap1.datadoghq.com"https://api.ap2.datadoghq.com"https://api.datadoghq.eu"https://api.ddog-gov.com"https://api.datadoghq.com"https://api.us3.datadoghq.com"https://api.us5.datadoghq.com/api/v2/downtime/${downtime_id}" \
-H "DD-API-KEY: ${DD_API_KEY}" \
-H "DD-APPLICATION-KEY: ${DD_APP_KEY}"

```
Cancel a downtime```
"""
Cancel a downtime returns "OK" response
"""

from os import environ
from datadog_api_client import ApiClient, Configuration
from datadog_api_client.v2.api.downtimes_api import DowntimesApi

# there is a valid "downtime_v2" in the system
DOWNTIME_V2_DATA_ID = environ["DOWNTIME_V2_DATA_ID"]

configuration = Configuration()
with ApiClient(configuration) as api_client:
api_instance = DowntimesApi(api_client)
api_instance.cancel_downtime(
downtime_id=DOWNTIME_V2_DATA_ID,
)

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=python) and then save the example to `example.py` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" python3 "example.py"`
```
Cancel a downtime```
# Cancel a downtime returns "OK" response

require "datadog_api_client"
api_instance = DatadogAPIClient::V2::DowntimesAPI.new

# there is a valid "downtime_v2" in the system
DOWNTIME_V2_DATA_ID = ENV["DOWNTIME_V2_DATA_ID"]
api_instance.cancel_downtime(DOWNTIME_V2_DATA_ID)

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=ruby) and then save the example to `example.rb` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" rb "example.rb"`
```
Cancel a downtime```
// Cancel a downtime returns "OK" response

package main

import (
	"context"
	"fmt"
	"os"

	"github.com/DataDog/datadog-api-client-go/v2/api/datadog"
	"github.com/DataDog/datadog-api-client-go/v2/api/datadogV2"
)

func main() {
	// there is a valid "downtime_v2" in the system
	DowntimeV2DataID := os.Getenv("DOWNTIME_V2_DATA_ID")

	ctx := datadog.NewDefaultContext(context.Background())
	configuration := datadog.NewConfiguration()
	apiClient := datadog.NewAPIClient(configuration)
	api := datadogV2.NewDowntimesApi(apiClient)
	r, err := api.CancelDowntime(ctx, DowntimeV2DataID)

	if err != nil {
		fmt.Fprintf(os.Stderr, "Error when calling `DowntimesApi.CancelDowntime`: %v\n", err)
		fmt.Fprintf(os.Stderr, "Full HTTP response: %v\n", r)
	}
}

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=go) and then save the example to `main.go` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" go run "main.go"`
```
Cancel a downtime```
// Cancel a downtime returns "OK" response

import com.datadog.api.client.ApiClient;
import com.datadog.api.client.ApiException;
import com.datadog.api.client.v2.api.DowntimesApi;

public class Example {
public static void main(String[] args) {
ApiClient defaultClient = ApiClient.getDefaultApiClient();
DowntimesApi apiInstance = new DowntimesApi(defaultClient);

// there is a valid "downtime_v2" in the system
String DOWNTIME_V2_DATA_ID = System.getenv("DOWNTIME_V2_DATA_ID");

try {
apiInstance.cancelDowntime(DOWNTIME_V2_DATA_ID);
} catch (ApiException e) {
System.err.println("Exception when calling DowntimesApi#cancelDowntime");
System.err.println("Status code: " + e.getCode());
System.err.println("Reason: " + e.getResponseBody());
System.err.println("Response headers: " + e.getResponseHeaders());
e.printStackTrace();
}
}
}

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=java) and then save the example to `Example.java` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" java "Example.java"`
```
Cancel a downtime```
// Cancel a downtime returns "OK" response
use datadog_api_client::datadog;
use datadog_api_client::datadogV2::api_downtimes::DowntimesAPI;

#[tokio::main]
async fn main() {
// there is a valid "downtime_v2" in the system
let downtime_v2_data_id = std::env::var("DOWNTIME_V2_DATA_ID").unwrap();
let configuration = datadog::Configuration::new();
let api = DowntimesAPI::with_config(configuration);
let resp = api.cancel_downtime(downtime_v2_data_id.clone()).await;
if let Ok(value) = resp {
println!("{:#?}", value);
} else {
println!("{:#?}", resp.unwrap_err());
}
}

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=rust) and then save the example to `src/main.rs` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" cargo run`
```
Cancel a downtime```
/**
* Cancel a downtime returns "OK" response
*/

import { client, v2 } from "@datadog/datadog-api-client";

const configuration = client.createConfiguration();
const apiInstance = new v2.DowntimesApi(configuration);

// there is a valid "downtime_v2" in the system
const DOWNTIME_V2_DATA_ID = process.env.DOWNTIME_V2_DATA_ID as string;

const params: v2.DowntimesApiCancelDowntimeRequest = {
downtimeId: DOWNTIME_V2_DATA_ID,
};

apiInstance
.cancelDowntime(params)
.then((data: any) => {
console.log(
"API called successfully. Returned data: " + JSON.stringify(data)
);
})
.catch((error: any) => console.error(error));

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=typescript) and then save the example to `example.ts` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" tsc "example.ts"`
```## Get a downtime- v1
- v2 (latest)
GET https://api.ap1.datadoghq.com/api/v1/downtime/{downtime_id}https://api.ap2.datadoghq.com/api/v1/downtime/{downtime_id}https://api.datadoghq.eu/api/v1/downtime/{downtime_id}https://api.ddog-gov.com/api/v1/downtime/{downtime_id}https://api.datadoghq.com/api/v1/downtime/{downtime_id}https://api.us3.datadoghq.com/api/v1/downtime/{downtime_id}https://api.us5.datadoghq.com/api/v1/downtime/{downtime_id}
### OverviewGet downtime detail by `downtime_id`. **Note:** This endpoint has been deprecated. Please use v2 endpoints.
This endpoint requires the `monitors_read` permission.OAuth apps require the `monitors_read` authorization scope to access this endpoint.
### Arguments#### Path ParametersName
Type
Description
downtime_id [*required*]
integer
ID of the downtime to fetch.
### Response- 200
- 403
- 404
- 429
OK
- Model
- Example
Downtiming gives you greater control over monitor notifications by
allowing you to globally exclude scopes from alerting.
Downtime settings, which can be scheduled with start and end times,
prevent all alerting related to specified Datadog tags.Expand All
Field
Type
Description
active
boolean
If a scheduled downtime currently exists.
active_child
object
The downtime object definition of the active child for the original parent recurring downtime. This
field will only exist on recurring downtimes.active
boolean
If a scheduled downtime currently exists.
canceled
int64
If a scheduled downtime is canceled.
creator_id
int32
User ID of the downtime creator.
disabled
boolean
If a downtime has been disabled.
downtime_type
int32
`0` for a downtime applied on `*` or all,
`1` when the downtime is only scoped to hosts,
or `2` when the downtime is scoped to anything but hosts.end
int64
POSIX timestamp to end the downtime. If not provided,
the downtime is in effect indefinitely until you cancel it.id
int64
The downtime ID.
message
string
A message to include with notifications for this downtime.
Email notifications can be sent to specific users by using the same `@username` notation as events.monitor_id
int64
A single monitor to which the downtime applies.
If not provided, the downtime applies to all monitors.monitor_tags
[string]
A comma-separated list of monitor tags. For example, tags that are applied directly to monitors,
not tags that are used in monitor queries (which are filtered by the scope parameter), to which the downtime applies.
The resulting downtime applies to monitors that match ALL provided monitor tags.
For example, `service:postgres` **AND** `team:frontend`.mute_first_recovery_notification
boolean
If the first recovery notification during a downtime should be muted.
notify_end_states
[string]
States for which `notify_end_types` sends out notifications for.
default: `alert,no data,warn`
notify_end_types
[string]
If set, notifies if a monitor is in an alert-worthy state (`ALERT`, `WARNING`, or `NO DATA`)
when this downtime expires or is canceled. Applied to monitors that change states during
the downtime (such as from `OK` to `ALERT`, `WARNING`, or `NO DATA`), and to monitors that
already have an alert-worthy state when downtime begins.default: `expired`
parent_id
int64
ID of the parent Downtime.
recurrence
object
An object defining the recurrence of the downtime.
period
int32
How often to repeat as an integer.
For example, to repeat every 3 days, select a type of `days` and a period of `3`.rrule
string
The `RRULE` standard for defining recurring events (**requires to set "type" to rrule**)
For example, to have a recurring event on the first day of each month, set the type to `rrule` and set the `FREQ` to `MONTHLY` and `BYMONTHDAY` to `1`.
Most common `rrule` options from the iCalendar Spec are supported.**Note**: Attributes specifying the duration in `RRULE` are not supported (for example, `DTSTART`, `DTEND`, `DURATION`).
More examples available in this [downtime guide](https://docs.datadoghq.com/monitors/guide/suppress-alert-with-downtimes/?tab=api)type
string
The type of recurrence. Choose from `days`, `weeks`, `months`, `years`, `rrule`.
until_date
int64
The date at which the recurrence should end as a POSIX timestamp.
`until_occurences` and `until_date` are mutually exclusive.until_occurrences
int32
How many times the downtime is rescheduled.
`until_occurences` and `until_date` are mutually exclusive.week_days
[string]
A list of week days to repeat on. Choose from `Mon`, `Tue`, `Wed`, `Thu`, `Fri`, `Sat` or `Sun`.
Only applicable when type is weeks. First letter must be capitalized.scope
[string]
The scope(s) to which the downtime applies and must be in `key:value` format. For example, `host:app2`.
Provide multiple scopes as a comma-separated list like `env:dev,env:prod`.
The resulting downtime applies to sources that matches ALL provided scopes (`env:dev` **AND** `env:prod`).start
int64
POSIX timestamp to start the downtime.
If not provided, the downtime starts the moment it is created.timezone
string
The timezone in which to display the downtime's start and end times in Datadog applications.
updater_id
int32
ID of the last user that updated the downtime.
canceled
int64
If a scheduled downtime is canceled.
creator_id
int32
User ID of the downtime creator.
disabled
boolean
If a downtime has been disabled.
downtime_type
int32
`0` for a downtime applied on `*` or all,
`1` when the downtime is only scoped to hosts,
or `2` when the downtime is scoped to anything but hosts.end
int64
POSIX timestamp to end the downtime. If not provided,
the downtime is in effect indefinitely until you cancel it.id
int64
The downtime ID.
message
string
A message to include with notifications for this downtime.
Email notifications can be sent to specific users by using the same `@username` notation as events.monitor_id
int64
A single monitor to which the downtime applies.
If not provided, the downtime applies to all monitors.monitor_tags
[string]
A comma-separated list of monitor tags. For example, tags that are applied directly to monitors,
not tags that are used in monitor queries (which are filtered by the scope parameter), to which the downtime applies.
The resulting downtime applies to monitors that match ALL provided monitor tags.
For example, `service:postgres` **AND** `team:frontend`.mute_first_recovery_notification
boolean
If the first recovery notification during a downtime should be muted.
notify_end_states
[string]
States for which `notify_end_types` sends out notifications for.
default: `alert,no data,warn`
notify_end_types
[string]
If set, notifies if a monitor is in an alert-worthy state (`ALERT`, `WARNING`, or `NO DATA`)
when this downtime expires or is canceled. Applied to monitors that change states during
the downtime (such as from `OK` to `ALERT`, `WARNING`, or `NO DATA`), and to monitors that
already have an alert-worthy state when downtime begins.default: `expired`
parent_id
int64
ID of the parent Downtime.
recurrence
object
An object defining the recurrence of the downtime.
period
int32
How often to repeat as an integer.
For example, to repeat every 3 days, select a type of `days` and a period of `3`.rrule
string
The `RRULE` standard for defining recurring events (**requires to set "type" to rrule**)
For example, to have a recurring event on the first day of each month, set the type to `rrule` and set the `FREQ` to `MONTHLY` and `BYMONTHDAY` to `1`.
Most common `rrule` options from the iCalendar Spec are supported.**Note**: Attributes specifying the duration in `RRULE` are not supported (for example, `DTSTART`, `DTEND`, `DURATION`).
More examples available in this [downtime guide](https://docs.datadoghq.com/monitors/guide/suppress-alert-with-downtimes/?tab=api)type
string
The type of recurrence. Choose from `days`, `weeks`, `months`, `years`, `rrule`.
until_date
int64
The date at which the recurrence should end as a POSIX timestamp.
`until_occurences` and `until_date` are mutually exclusive.until_occurrences
int32
How many times the downtime is rescheduled.
`until_occurences` and `until_date` are mutually exclusive.week_days
[string]
A list of week days to repeat on. Choose from `Mon`, `Tue`, `Wed`, `Thu`, `Fri`, `Sat` or `Sun`.
Only applicable when type is weeks. First letter must be capitalized.scope
[string]
The scope(s) to which the downtime applies and must be in `key:value` format. For example, `host:app2`.
Provide multiple scopes as a comma-separated list like `env:dev,env:prod`.
The resulting downtime applies to sources that matches ALL provided scopes (`env:dev` **AND** `env:prod`).start
int64
POSIX timestamp to start the downtime.
If not provided, the downtime starts the moment it is created.timezone
string
The timezone in which to display the downtime's start and end times in Datadog applications.
updater_id
int32
ID of the last user that updated the downtime.
```
{
"active": true,
"active_child": {
"active": true,
"canceled": 1412799983,
"creator_id": 123456,
"disabled": false,
"downtime_type": 2,
"end": 1412793983,
"id": 1626,
"message": "Message on the downtime",
"monitor_id": 123456,
"monitor_tags": [
"*"
],
"mute_first_recovery_notification": false,
"notify_end_states": [
"alert",
"no data",
"warn"
],
"notify_end_types": [
"canceled",
"expired"
],
"parent_id": 123,
"recurrence": {
"period": 1,
"rrule": "FREQ=MONTHLY;BYSETPOS=3;BYDAY=WE;INTERVAL=1",
"type": "weeks",
"until_date": 1447786293,
"until_occurrences": 2,
"week_days": [
"Mon",
"Tue"
]
},
"scope": [
"env:staging"
],
"start": 1412792983,
"timezone": "America/New_York",
"updater_id": 123456
},
"canceled": 1412799983,
"creator_id": 123456,
"disabled": false,
"downtime_type": 2,
"end": 1412793983,
"id": 1625,
"message": "Message on the downtime",
"monitor_id": 123456,
"monitor_tags": [
"*"
],
"mute_first_recovery_notification": false,
"notify_end_states": [
"alert",
"no data",
"warn"
],
"notify_end_types": [
"canceled",
"expired"
],
"parent_id": 123,
"recurrence": {
"period": 1,
"rrule": "FREQ=MONTHLY;BYSETPOS=3;BYDAY=WE;INTERVAL=1",
"type": "weeks",
"until_date": 1447786293,
"until_occurrences": 2,
"week_days": [
"Mon",
"Tue"
]
},
"scope": [
"env:staging"
],
"start": 1412792983,
"timezone": "America/New_York",
"updater_id": 123456
}
```Forbidden
- Model
- Example
Error response object.
Expand All
Field
Type
Description
errors [*required*]
[string]
Array of errors returned by the API.
```
{
"errors": [
"Bad Request"
]
}
```Downtime not found
- Model
- Example
Error response object.
Expand All
Field
Type
Description
errors [*required*]
[string]
Array of errors returned by the API.
```
{
"errors": [
"Bad Request"
]
}
```Too many requests
- Model
- Example
Error response object.
Expand All
Field
Type
Description
errors [*required*]
[string]
Array of errors returned by the API.
```
{
"errors": [
"Bad Request"
]
}
```### Code Example- [Curl](?code-lang=curl#)
- [Python](?code-lang=python#)
- [Ruby](?code-lang=ruby#)
- [Go](?code-lang=go#)
- [Java](?code-lang=java#)
- [Rust](?code-lang=rust#)
- [Typescript](?code-lang=typescript#)
- [Ruby [legacy]](?code-lang=ruby-legacy#)
- [Python [legacy]](?code-lang=python-legacy#)

Get a downtimeCopy```

# Path parametersexport downtime_id="123456"# Curl commandcurl -X GET "https://api.ap1.datadoghq.com"https://api.ap2.datadoghq.com"https://api.datadoghq.eu"https://api.ddog-gov.com"https://api.datadoghq.com"https://api.us3.datadoghq.com"https://api.us5.datadoghq.com/api/v1/downtime/${downtime_id}" \
-H "Accept: application/json" \
-H "DD-API-KEY: ${DD_API_KEY}" \
-H "DD-APPLICATION-KEY: ${DD_APP_KEY}"

```
Get a downtime```
"""
Get a downtime returns "OK" response
"""

from os import environ
from datadog_api_client import ApiClient, Configuration
from datadog_api_client.v1.api.downtimes_api import DowntimesApi

# there is a valid "downtime" in the system
DOWNTIME_ID = environ["DOWNTIME_ID"]

configuration = Configuration()
with ApiClient(configuration) as api_client:
api_instance = DowntimesApi(api_client)
response = api_instance.get_downtime(
downtime_id=int(DOWNTIME_ID),
)

print(response)

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=python) and then save the example to `example.py` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" python3 "example.py"`
```
Get a downtime```
# Get a downtime returns "OK" response

require "datadog_api_client"
api_instance = DatadogAPIClient::V1::DowntimesAPI.new

# there is a valid "downtime" in the system
DOWNTIME_ID = ENV["DOWNTIME_ID"]
p api_instance.get_downtime(DOWNTIME_ID.to_i)

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=ruby) and then save the example to `example.rb` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" rb "example.rb"`
```
Get a downtime```
require 'dogapi'

api_key = '<DATADOG_API_KEY>'
app_key = '<DATADOG_APPLICATION_KEY>'

dog = Dogapi::Client.new(api_key, app_key)

# Get a downtime object
downtime_id = 1625
dog.get_downtime(downtime_id)

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=ruby-legacy) and then save the example to `example.rb` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" rb "example.rb"`
```
Get a downtime```
// Get a downtime returns "OK" response

package main

import (
	"context"
	"encoding/json"
	"fmt"
	"os"
	"strconv"

	"github.com/DataDog/datadog-api-client-go/v2/api/datadog"
	"github.com/DataDog/datadog-api-client-go/v2/api/datadogV1"
)

func main() {
	// there is a valid "downtime" in the system
	DowntimeID, _ := strconv.ParseInt(os.Getenv("DOWNTIME_ID"), 10, 64)

	ctx := datadog.NewDefaultContext(context.Background())
	configuration := datadog.NewConfiguration()
	apiClient := datadog.NewAPIClient(configuration)
	api := datadogV1.NewDowntimesApi(apiClient)
	resp, r, err := api.GetDowntime(ctx, DowntimeID)

	if err != nil {
		fmt.Fprintf(os.Stderr, "Error when calling `DowntimesApi.GetDowntime`: %v\n", err)
		fmt.Fprintf(os.Stderr, "Full HTTP response: %v\n", r)
	}

	responseContent, _ := json.MarshalIndent(resp, "", " ")
	fmt.Fprintf(os.Stdout, "Response from `DowntimesApi.GetDowntime`:\n%s\n", responseContent)
}

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=go) and then save the example to `main.go` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" go run "main.go"`
```
Get a downtime```
// Get a downtime returns "OK" response

import com.datadog.api.client.ApiClient;
import com.datadog.api.client.ApiException;
import com.datadog.api.client.v1.api.DowntimesApi;
import com.datadog.api.client.v1.model.Downtime;

public class Example {
public static void main(String[] args) {
ApiClient defaultClient = ApiClient.getDefaultApiClient();
DowntimesApi apiInstance = new DowntimesApi(defaultClient);

// there is a valid "downtime" in the system
Long DOWNTIME_ID = Long.parseLong(System.getenv("DOWNTIME_ID"));

try {
Downtime result = apiInstance.getDowntime(DOWNTIME_ID);
System.out.println(result);
} catch (ApiException e) {
System.err.println("Exception when calling DowntimesApi#getDowntime");
System.err.println("Status code: " + e.getCode());
System.err.println("Reason: " + e.getResponseBody());
System.err.println("Response headers: " + e.getResponseHeaders());
e.printStackTrace();
}
}
}

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=java) and then save the example to `Example.java` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" java "Example.java"`
```
Get a downtime```
from datadog import initialize, api

options = {
'api_key': '<DATADOG_API_KEY>',
'app_key': '<DATADOG_APPLICATION_KEY>'
}

initialize(**options)

# Get a downtime
api.Downtime.get(2910)

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=python-legacy) and then save the example to `example.py` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" python "example.py"`
```
Get a downtime```
// Get a downtime returns "OK" response
use datadog_api_client::datadog;
use datadog_api_client::datadogV1::api_downtimes::DowntimesAPI;

#[tokio::main]
async fn main() {
// there is a valid "downtime" in the system
let downtime_id: i64 = std::env::var("DOWNTIME_ID").unwrap().parse().unwrap();
let configuration = datadog::Configuration::new();
let api = DowntimesAPI::with_config(configuration);
let resp = api.get_downtime(downtime_id.clone()).await;
if let Ok(value) = resp {
println!("{:#?}", value);
} else {
println!("{:#?}", resp.unwrap_err());
}
}

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=rust) and then save the example to `src/main.rs` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" cargo run`
```
Get a downtime```
/**
* Get a downtime returns "OK" response
*/

import { client, v1 } from "@datadog/datadog-api-client";

const configuration = client.createConfiguration();
const apiInstance = new v1.DowntimesApi(configuration);

// there is a valid "downtime" in the system
const DOWNTIME_ID = parseInt(process.env.DOWNTIME_ID as string);

const params: v1.DowntimesApiGetDowntimeRequest = {
downtimeId: DOWNTIME_ID,
};

apiInstance
.getDowntime(params)
.then((data: v1.Downtime) => {
console.log(
"API called successfully. Returned data: " + JSON.stringify(data)
);
})
.catch((error: any) => console.error(error));

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=typescript) and then save the example to `example.ts` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" tsc "example.ts"`
```GET https://api.ap1.datadoghq.com/api/v2/downtime/{downtime_id}https://api.ap2.datadoghq.com/api/v2/downtime/{downtime_id}https://api.datadoghq.eu/api/v2/downtime/{downtime_id}https://api.ddog-gov.com/api/v2/downtime/{downtime_id}https://api.datadoghq.com/api/v2/downtime/{downtime_id}https://api.us3.datadoghq.com/api/v2/downtime/{downtime_id}https://api.us5.datadoghq.com/api/v2/downtime/{downtime_id}
### OverviewGet downtime detail by `downtime_id`.
This endpoint requires the `monitors_downtime` permission.OAuth apps require the `monitors_downtime` authorization scope to access this endpoint.
### Arguments#### Path ParametersName
Type
Description
downtime_id [*required*]
string
ID of the downtime to fetch.
#### Query StringsName
Type
Description
include
string
Comma-separated list of resource paths for related resources to include in the response. Supported resource
paths are `created_by` and `monitor`.### Response- 200
- 400
- 403
- 404
- 429
OK
- Model
- Example
Downtiming gives you greater control over monitor notifications by
allowing you to globally exclude scopes from alerting.
Downtime settings, which can be scheduled with start and end times,
prevent all alerting related to specified Datadog tags.Expand All
Field
Type
Description
data
object
Downtime data.
attributes
object
Downtime details.
canceled
date-time
Time that the downtime was canceled.
created
date-time
Creation time of the downtime.
display_timezone
string
The timezone in which to display the downtime's start and end times in Datadog applications. This is not used
as an offset for scheduling.default: `UTC`
message
string
A message to include with notifications for this downtime. Email notifications can be sent to specific users
by using the same `@username` notation as events.modified
date-time
Time that the downtime was last modified.
monitor_identifier
 <oneOf>
Monitor identifier for the downtime.
Option 1
object
Object of the monitor identifier.
monitor_id [*required*]
int64
ID of the monitor to prevent notifications.
Option 2
object
Object of the monitor tags.
monitor_tags [*required*]
[string]
A list of monitor tags. For example, tags that are applied directly to monitors,
not tags that are used in monitor queries (which are filtered by the scope parameter), to which the downtime applies.
The resulting downtime applies to monitors that match **all** provided monitor tags. Setting `monitor_tags`
to `[*]` configures the downtime to mute all monitors for the given scope.mute_first_recovery_notification
boolean
If the first recovery notification during a downtime should be muted.
notify_end_states
[string]
States that will trigger a monitor notification when the `notify_end_types` action occurs.
notify_end_types
[string]
Actions that will trigger a monitor notification if the downtime is in the `notify_end_types` state.
schedule
 <oneOf>
The schedule that defines when the monitor starts, stops, and recurs. There are two types of schedules:
one-time and recurring. Recurring schedules may have up to five RRULE-based recurrences. If no schedules are
provided, the downtime will begin immediately and never end. Option 1
object
A recurring downtime schedule definition.
current_downtime
object
The most recent actual start and end dates for a recurring downtime. For a canceled downtime,
this is the previously occurring downtime. For active downtimes, this is the ongoing downtime, and for scheduled
downtimes it is the upcoming downtime.end
date-time
The end of the current downtime.
start
date-time
The start of the current downtime.
recurrences [*required*]
[object]
A list of downtime recurrences.
duration
string
The length of the downtime. Must begin with an integer and end with one of 'm', 'h', d', or 'w'.
rrule
string
The `RRULE` standard for defining recurring events.
For example, to have a recurring event on the first day of each month, set the type to `rrule` and set the `FREQ` to `MONTHLY` and `BYMONTHDAY` to `1`.
Most common `rrule` options from the iCalendar Spec are supported.**Note**: Attributes specifying the duration in `RRULE` are not supported (for example, `DTSTART`, `DTEND`, `DURATION`).
More examples available in this [downtime guide](https://docs.datadoghq.com/monitors/guide/suppress-alert-with-downtimes/?tab=api).start
string
ISO-8601 Datetime to start the downtime. Must not include a UTC offset. If not provided, the
downtime starts the moment it is created.timezone
string
The timezone in which to schedule the downtime. This affects recurring start and end dates.
Must match `display_timezone`.default: `UTC`
Option 2
object
A one-time downtime definition.
end
date-time
ISO-8601 Datetime to end the downtime.
start [*required*]
date-time
ISO-8601 Datetime to start the downtime.
scope
string
The scope to which the downtime applies. Must follow the common search syntax.
status
enum
The current status of the downtime.
Allowed enum values: `active,canceled,ended,scheduled`id
string
The downtime ID.
relationships
object
All relationships associated with downtime.
created_by
object
The user who created the downtime.
data
object
Data for the user who created the downtime.
id
string
User ID of the downtime creator.
type
enum
Users resource type.
Allowed enum values: `users`default: `users`
monitor
object
The monitor identified by the downtime.
data
object
Data for the monitor.
id
string
Monitor ID of the downtime.
type
enum
Monitor resource type.
Allowed enum values: `monitors`default: `monitors`
type
enum
Downtime resource type.
Allowed enum values: `downtime`default: `downtime`
included
[ <oneOf>]
Array of objects related to the downtime that the user requested.
Option 1
object
User object returned by the API.
attributes
object
Attributes of user object returned by the API.
created_at
date-time
Creation time of the user.
disabled
boolean
Whether the user is disabled.
email
string
Email of the user.
handle
string
Handle of the user.
icon
string
URL of the user's icon.
last_login_time
date-time
The last time the user logged in.
mfa_enabled
boolean
If user has MFA enabled.
modified_at
date-time
Time that the user was last modified.
name
string
Name of the user.
service_account
boolean
Whether the user is a service account.
status
string
Status of the user.
title
string
Title of the user.
verified
boolean
Whether the user is verified.
id
string
ID of the user.
relationships
object
Relationships of the user object returned by the API.
org
object
Relationship to an organization.
data [*required*]
object
Relationship to organization object.
id [*required*]
string
ID of the organization.
type [*required*]
enum
Organizations resource type.
Allowed enum values: `orgs`default: `orgs`
other_orgs
object
Relationship to organizations.
data [*required*]
[object]
Relationships to organization objects.
id [*required*]
string
ID of the organization.
type [*required*]
enum
Organizations resource type.
Allowed enum values: `orgs`default: `orgs`
other_users
object
Relationship to users.
data [*required*]
[object]
Relationships to user objects.
id [*required*]
string
A unique identifier that represents the user.
type [*required*]
enum
Users resource type.
Allowed enum values: `users`default: `users`
roles
object
Relationship to roles.
data
[object]
An array containing type and the unique identifier of a role.
id
string
The unique identifier of the role.
type
enum
Roles type.
Allowed enum values: `roles`default: `roles`
type
enum
Users resource type.
Allowed enum values: `users`default: `users`
Option 2
object
Information about the monitor identified by the downtime.
attributes
object
Attributes of the monitor identified by the downtime.
name
string
The name of the monitor identified by the downtime.
id
int64
ID of the monitor identified by the downtime.
type
enum
Monitor resource type.
Allowed enum values: `monitors`default: `monitors`
```
{
"data": {
"attributes": {
"canceled": "2020-01-02T03:04:05.282979+0000",
"created": "2020-01-02T03:04:05.282979+0000",
"display_timezone": "America/New_York",
"message": "Message about the downtime",
"modified": "2020-01-02T03:04:05.282979+0000",
"monitor_identifier": {
"monitor_id": 123
},
"mute_first_recovery_notification": false,
"notify_end_states": [
"alert",
"warn"
],
"notify_end_types": [
"canceled",
"expired"
],
"schedule": {
"current_downtime": {
"end": "2020-01-02T03:04:00.000Z",
"start": "2020-01-02T03:04:00.000Z"
},
"recurrences": [
{
"duration": "123d",
"rrule": "FREQ=MONTHLY;BYSETPOS=3;BYDAY=WE;INTERVAL=1",
"start": "2020-01-02T03:04"
}
],
"timezone": "America/New_York"
},
"scope": "env:(staging OR prod) AND datacenter:us-east-1",
"status": "active"
},
"id": "00000000-0000-1234-0000-000000000000",
"relationships": {
"created_by": {
"data": {
"id": "00000000-0000-1234-0000-000000000000",
"type": "users"
}
},
"monitor": {
"data": {
"id": "12345",
"type": "monitors"
}
}
},
"type": "downtime"
},
"included": [
{
"attributes": {
"created_at": "2019-09-19T10:00:00.000Z",
"disabled": false,
"email": "string",
"handle": "string",
"icon": "string",
"last_login_time": "2019-09-19T10:00:00.000Z",
"mfa_enabled": false,
"modified_at": "2019-09-19T10:00:00.000Z",
"name": "string",
"service_account": false,
"status": "string",
"title": "string",
"verified": false
},
"id": "string",
"relationships": {
"org": {
"data": {
"id": "00000000-0000-beef-0000-000000000000",
"type": "orgs"
}
},
"other_orgs": {
"data": [
{
"id": "00000000-0000-beef-0000-000000000000",
"type": "orgs"
}
]
},
"other_users": {
"data": [
{
"id": "00000000-0000-0000-2345-000000000000",
"type": "users"
}
]
},
"roles": {
"data": [
{
"id": "3653d3c6-0c75-11ea-ad28-fb5701eabc7d",
"type": "roles"
}
]
}
},
"type": "users"
}
]
}
```Bad Request
- Model
- Example
API error response.
Expand All
Field
Type
Description
errors [*required*]
[string]
A list of errors.
```
{
"errors": [
"Bad Request"
]
}
```Forbidden
- Model
- Example
API error response.
Expand All
Field
Type
Description
errors [*required*]
[string]
A list of errors.
```
{
"errors": [
"Bad Request"
]
}
```Not Found
- Model
- Example
API error response.
Expand All
Field
Type
Description
errors [*required*]
[string]
A list of errors.
```
{
"errors": [
"Bad Request"
]
}
```Too many requests
- Model
- Example
API error response.
Expand All
Field
Type
Description
errors [*required*]
[string]
A list of errors.
```
{
"errors": [
"Bad Request"
]
}
```### Code Example- [Curl](?code-lang=curl#)
- [Python](?code-lang=python#)
- [Ruby](?code-lang=ruby#)
- [Go](?code-lang=go#)
- [Java](?code-lang=java#)
- [Rust](?code-lang=rust#)
- [Typescript](?code-lang=typescript#)

Get a downtimeCopy```

# Path parametersexport downtime_id="00000000-0000-1234-0000-000000000000"# Curl commandcurl -X GET "https://api.ap1.datadoghq.com"https://api.ap2.datadoghq.com"https://api.datadoghq.eu"https://api.ddog-gov.com"https://api.datadoghq.com"https://api.us3.datadoghq.com"https://api.us5.datadoghq.com/api/v2/downtime/${downtime_id}" \
-H "Accept: application/json" \
-H "DD-API-KEY: ${DD_API_KEY}" \
-H "DD-APPLICATION-KEY: ${DD_APP_KEY}"

```
Get a downtime```
"""
Get a downtime returns "OK" response
"""

from os import environ
from datadog_api_client import ApiClient, Configuration
from datadog_api_client.v2.api.downtimes_api import DowntimesApi

# there is a valid "downtime_v2" in the system
DOWNTIME_V2_DATA_ID = environ["DOWNTIME_V2_DATA_ID"]

configuration = Configuration()
with ApiClient(configuration) as api_client:
api_instance = DowntimesApi(api_client)
response = api_instance.get_downtime(
downtime_id=DOWNTIME_V2_DATA_ID,
)

print(response)

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=python) and then save the example to `example.py` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" python3 "example.py"`
```
Get a downtime```
# Get a downtime returns "OK" response

require "datadog_api_client"
api_instance = DatadogAPIClient::V2::DowntimesAPI.new

# there is a valid "downtime_v2" in the system
DOWNTIME_V2_DATA_ID = ENV["DOWNTIME_V2_DATA_ID"]
p api_instance.get_downtime(DOWNTIME_V2_DATA_ID)

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=ruby) and then save the example to `example.rb` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" rb "example.rb"`
```
Get a downtime```
// Get a downtime returns "OK" response

package main

import (
	"context"
	"encoding/json"
	"fmt"
	"os"

	"github.com/DataDog/datadog-api-client-go/v2/api/datadog"
	"github.com/DataDog/datadog-api-client-go/v2/api/datadogV2"
)

func main() {
	// there is a valid "downtime_v2" in the system
	DowntimeV2DataID := os.Getenv("DOWNTIME_V2_DATA_ID")

	ctx := datadog.NewDefaultContext(context.Background())
	configuration := datadog.NewConfiguration()
	apiClient := datadog.NewAPIClient(configuration)
	api := datadogV2.NewDowntimesApi(apiClient)
	resp, r, err := api.GetDowntime(ctx, DowntimeV2DataID, *datadogV2.NewGetDowntimeOptionalParameters())

	if err != nil {
		fmt.Fprintf(os.Stderr, "Error when calling `DowntimesApi.GetDowntime`: %v\n", err)
		fmt.Fprintf(os.Stderr, "Full HTTP response: %v\n", r)
	}

	responseContent, _ := json.MarshalIndent(resp, "", " ")
	fmt.Fprintf(os.Stdout, "Response from `DowntimesApi.GetDowntime`:\n%s\n", responseContent)
}

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=go) and then save the example to `main.go` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" go run "main.go"`
```
Get a downtime```
// Get a downtime returns "OK" response

import com.datadog.api.client.ApiClient;
import com.datadog.api.client.ApiException;
import com.datadog.api.client.v2.api.DowntimesApi;
import com.datadog.api.client.v2.model.DowntimeResponse;

public class Example {
public static void main(String[] args) {
ApiClient defaultClient = ApiClient.getDefaultApiClient();
DowntimesApi apiInstance = new DowntimesApi(defaultClient);

// there is a valid "downtime_v2" in the system
String DOWNTIME_V2_DATA_ID = System.getenv("DOWNTIME_V2_DATA_ID");

try {
DowntimeResponse result = apiInstance.getDowntime(DOWNTIME_V2_DATA_ID);
System.out.println(result);
} catch (ApiException e) {
System.err.println("Exception when calling DowntimesApi#getDowntime");
System.err.println("Status code: " + e.getCode());
System.err.println("Reason: " + e.getResponseBody());
System.err.println("Response headers: " + e.getResponseHeaders());
e.printStackTrace();
}
}
}

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=java) and then save the example to `Example.java` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" java "Example.java"`
```
Get a downtime```
// Get a downtime returns "OK" response
use datadog_api_client::datadog;
use datadog_api_client::datadogV2::api_downtimes::DowntimesAPI;
use datadog_api_client::datadogV2::api_downtimes::GetDowntimeOptionalParams;

#[tokio::main]
async fn main() {
// there is a valid "downtime_v2" in the system
let downtime_v2_data_id = std::env::var("DOWNTIME_V2_DATA_ID").unwrap();
let configuration = datadog::Configuration::new();
let api = DowntimesAPI::with_config(configuration);
let resp = api
.get_downtime(
downtime_v2_data_id.clone(),
GetDowntimeOptionalParams::default(),
)
.await;
if let Ok(value) = resp {
println!("{:#?}", value);
} else {
println!("{:#?}", resp.unwrap_err());
}
}

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=rust) and then save the example to `src/main.rs` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" cargo run`
```
Get a downtime```
/**
* Get a downtime returns "OK" response
*/

import { client, v2 } from "@datadog/datadog-api-client";

const configuration = client.createConfiguration();
const apiInstance = new v2.DowntimesApi(configuration);

// there is a valid "downtime_v2" in the system
const DOWNTIME_V2_DATA_ID = process.env.DOWNTIME_V2_DATA_ID as string;

const params: v2.DowntimesApiGetDowntimeRequest = {
downtimeId: DOWNTIME_V2_DATA_ID,
};

apiInstance
.getDowntime(params)
.then((data: v2.DowntimeResponse) => {
console.log(
"API called successfully. Returned data: " + JSON.stringify(data)
);
})
.catch((error: any) => console.error(error));

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=typescript) and then save the example to `example.ts` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" tsc "example.ts"`
```## Update a downtime- v1
- v2 (latest)
PUT https://api.ap1.datadoghq.com/api/v1/downtime/{downtime_id}https://api.ap2.datadoghq.com/api/v1/downtime/{downtime_id}https://api.datadoghq.eu/api/v1/downtime/{downtime_id}https://api.ddog-gov.com/api/v1/downtime/{downtime_id}https://api.datadoghq.com/api/v1/downtime/{downtime_id}https://api.us3.datadoghq.com/api/v1/downtime/{downtime_id}https://api.us5.datadoghq.com/api/v1/downtime/{downtime_id}
### OverviewUpdate a single downtime by `downtime_id`. **Note:** This endpoint has been deprecated. Please use v2 endpoints.
This endpoint requires the `monitors_downtime` permission.OAuth apps require the `monitors_downtime` authorization scope to access this endpoint.
### Arguments#### Path ParametersName
Type
Description
downtime_id [*required*]
integer
ID of the downtime to update.
### Request#### Body Data (required)Update a downtime request body.
- Model
- Example
Expand All
Field
Type
Description
active
boolean
If a scheduled downtime currently exists.
active_child
object
The downtime object definition of the active child for the original parent recurring downtime. This
field will only exist on recurring downtimes.active
boolean
If a scheduled downtime currently exists.
canceled
int64
If a scheduled downtime is canceled.
creator_id
int32
User ID of the downtime creator.
disabled
boolean
If a downtime has been disabled.
downtime_type
int32
`0` for a downtime applied on `*` or all,
`1` when the downtime is only scoped to hosts,
or `2` when the downtime is scoped to anything but hosts.end
int64
POSIX timestamp to end the downtime. If not provided,
the downtime is in effect indefinitely until you cancel it.id
int64
The downtime ID.
message
string
A message to include with notifications for this downtime.
Email notifications can be sent to specific users by using the same `@username` notation as events.monitor_id
int64
A single monitor to which the downtime applies.
If not provided, the downtime applies to all monitors.monitor_tags
[string]
A comma-separated list of monitor tags. For example, tags that are applied directly to monitors,
not tags that are used in monitor queries (which are filtered by the scope parameter), to which the downtime applies.
The resulting downtime applies to monitors that match ALL provided monitor tags.
For example, `service:postgres` **AND** `team:frontend`.mute_first_recovery_notification
boolean
If the first recovery notification during a downtime should be muted.
notify_end_states
[string]
States for which `notify_end_types` sends out notifications for.
default: `alert,no data,warn`
notify_end_types
[string]
If set, notifies if a monitor is in an alert-worthy state (`ALERT`, `WARNING`, or `NO DATA`)
when this downtime expires or is canceled. Applied to monitors that change states during
the downtime (such as from `OK` to `ALERT`, `WARNING`, or `NO DATA`), and to monitors that
already have an alert-worthy state when downtime begins.default: `expired`
parent_id
int64
ID of the parent Downtime.
recurrence
object
An object defining the recurrence of the downtime.
period
int32
How often to repeat as an integer.
For example, to repeat every 3 days, select a type of `days` and a period of `3`.rrule
string
The `RRULE` standard for defining recurring events (**requires to set "type" to rrule**)
For example, to have a recurring event on the first day of each month, set the type to `rrule` and set the `FREQ` to `MONTHLY` and `BYMONTHDAY` to `1`.
Most common `rrule` options from the iCalendar Spec are supported.**Note**: Attributes specifying the duration in `RRULE` are not supported (for example, `DTSTART`, `DTEND`, `DURATION`).
More examples available in this [downtime guide](https://docs.datadoghq.com/monitors/guide/suppress-alert-with-downtimes/?tab=api)type
string
The type of recurrence. Choose from `days`, `weeks`, `months`, `years`, `rrule`.
until_date
int64
The date at which the recurrence should end as a POSIX timestamp.
`until_occurences` and `until_date` are mutually exclusive.until_occurrences
int32
How many times the downtime is rescheduled.
`until_occurences` and `until_date` are mutually exclusive.week_days
[string]
A list of week days to repeat on. Choose from `Mon`, `Tue`, `Wed`, `Thu`, `Fri`, `Sat` or `Sun`.
Only applicable when type is weeks. First letter must be capitalized.scope
[string]
The scope(s) to which the downtime applies and must be in `key:value` format. For example, `host:app2`.
Provide multiple scopes as a comma-separated list like `env:dev,env:prod`.
The resulting downtime applies to sources that matches ALL provided scopes (`env:dev` **AND** `env:prod`).start
int64
POSIX timestamp to start the downtime.
If not provided, the downtime starts the moment it is created.timezone
string
The timezone in which to display the downtime's start and end times in Datadog applications.
updater_id
int32
ID of the last user that updated the downtime.
canceled
int64
If a scheduled downtime is canceled.
creator_id
int32
User ID of the downtime creator.
disabled
boolean
If a downtime has been disabled.
downtime_type
int32
`0` for a downtime applied on `*` or all,
`1` when the downtime is only scoped to hosts,
or `2` when the downtime is scoped to anything but hosts.end
int64
POSIX timestamp to end the downtime. If not provided,
the downtime is in effect indefinitely until you cancel it.id
int64
The downtime ID.
message
string
A message to include with notifications for this downtime.
Email notifications can be sent to specific users by using the same `@username` notation as events.monitor_id
int64
A single monitor to which the downtime applies.
If not provided, the downtime applies to all monitors.monitor_tags
[string]
A comma-separated list of monitor tags. For example, tags that are applied directly to monitors,
not tags that are used in monitor queries (which are filtered by the scope parameter), to which the downtime applies.
The resulting downtime applies to monitors that match ALL provided monitor tags.
For example, `service:postgres` **AND** `team:frontend`.mute_first_recovery_notification
boolean
If the first recovery notification during a downtime should be muted.
notify_end_states
[string]
States for which `notify_end_types` sends out notifications for.
default: `alert,no data,warn`
notify_end_types
[string]
If set, notifies if a monitor is in an alert-worthy state (`ALERT`, `WARNING`, or `NO DATA`)
when this downtime expires or is canceled. Applied to monitors that change states during
the downtime (such as from `OK` to `ALERT`, `WARNING`, or `NO DATA`), and to monitors that
already have an alert-worthy state when downtime begins.default: `expired`
parent_id
int64
ID of the parent Downtime.
recurrence
object
An object defining the recurrence of the downtime.
period
int32
How often to repeat as an integer.
For example, to repeat every 3 days, select a type of `days` and a period of `3`.rrule
string
The `RRULE` standard for defining recurring events (**requires to set "type" to rrule**)
For example, to have a recurring event on the first day of each month, set the type to `rrule` and set the `FREQ` to `MONTHLY` and `BYMONTHDAY` to `1`.
Most common `rrule` options from the iCalendar Spec are supported.**Note**: Attributes specifying the duration in `RRULE` are not supported (for example, `DTSTART`, `DTEND`, `DURATION`).
More examples available in this [downtime guide](https://docs.datadoghq.com/monitors/guide/suppress-alert-with-downtimes/?tab=api)type
string
The type of recurrence. Choose from `days`, `weeks`, `months`, `years`, `rrule`.
until_date
int64
The date at which the recurrence should end as a POSIX timestamp.
`until_occurences` and `until_date` are mutually exclusive.until_occurrences
int32
How many times the downtime is rescheduled.
`until_occurences` and `until_date` are mutually exclusive.week_days
[string]
A list of week days to repeat on. Choose from `Mon`, `Tue`, `Wed`, `Thu`, `Fri`, `Sat` or `Sun`.
Only applicable when type is weeks. First letter must be capitalized.scope
[string]
The scope(s) to which the downtime applies and must be in `key:value` format. For example, `host:app2`.
Provide multiple scopes as a comma-separated list like `env:dev,env:prod`.
The resulting downtime applies to sources that matches ALL provided scopes (`env:dev` **AND** `env:prod`).start
int64
POSIX timestamp to start the downtime.
If not provided, the downtime starts the moment it is created.timezone
string
The timezone in which to display the downtime's start and end times in Datadog applications.
updater_id
int32
ID of the last user that updated the downtime.
```
{
"message": "Example-Downtime-updated",
"mute_first_recovery_notification": true,
"notify_end_states": [
"alert",
"no data",
"warn"
],
"notify_end_types": [
"canceled",
"expired"
]
}
```### Response- 200
- 400
- 403
- 404
- 429
OK
- Model
- Example
Downtiming gives you greater control over monitor notifications by
allowing you to globally exclude scopes from alerting.
Downtime settings, which can be scheduled with start and end times,
prevent all alerting related to specified Datadog tags.Expand All
Field
Type
Description
active
boolean
If a scheduled downtime currently exists.
active_child
object
The downtime object definition of the active child for the original parent recurring downtime. This
field will only exist on recurring downtimes.active
boolean
If a scheduled downtime currently exists.
canceled
int64
If a scheduled downtime is canceled.
creator_id
int32
User ID of the downtime creator.
disabled
boolean
If a downtime has been disabled.
downtime_type
int32
`0` for a downtime applied on `*` or all,
`1` when the downtime is only scoped to hosts,
or `2` when the downtime is scoped to anything but hosts.end
int64
POSIX timestamp to end the downtime. If not provided,
the downtime is in effect indefinitely until you cancel it.id
int64
The downtime ID.
message
string
A message to include with notifications for this downtime.
Email notifications can be sent to specific users by using the same `@username` notation as events.monitor_id
int64
A single monitor to which the downtime applies.
If not provided, the downtime applies to all monitors.monitor_tags
[string]
A comma-separated list of monitor tags. For example, tags that are applied directly to monitors,
not tags that are used in monitor queries (which are filtered by the scope parameter), to which the downtime applies.
The resulting downtime applies to monitors that match ALL provided monitor tags.
For example, `service:postgres` **AND** `team:frontend`.mute_first_recovery_notification
boolean
If the first recovery notification during a downtime should be muted.
notify_end_states
[string]
States for which `notify_end_types` sends out notifications for.
default: `alert,no data,warn`
notify_end_types
[string]
If set, notifies if a monitor is in an alert-worthy state (`ALERT`, `WARNING`, or `NO DATA`)
when this downtime expires or is canceled. Applied to monitors that change states during
the downtime (such as from `OK` to `ALERT`, `WARNING`, or `NO DATA`), and to monitors that
already have an alert-worthy state when downtime begins.default: `expired`
parent_id
int64
ID of the parent Downtime.
recurrence
object
An object defining the recurrence of the downtime.
period
int32
How often to repeat as an integer.
For example, to repeat every 3 days, select a type of `days` and a period of `3`.rrule
string
The `RRULE` standard for defining recurring events (**requires to set "type" to rrule**)
For example, to have a recurring event on the first day of each month, set the type to `rrule` and set the `FREQ` to `MONTHLY` and `BYMONTHDAY` to `1`.
Most common `rrule` options from the iCalendar Spec are supported.**Note**: Attributes specifying the duration in `RRULE` are not supported (for example, `DTSTART`, `DTEND`, `DURATION`).
More examples available in this [downtime guide](https://docs.datadoghq.com/monitors/guide/suppress-alert-with-downtimes/?tab=api)type
string
The type of recurrence. Choose from `days`, `weeks`, `months`, `years`, `rrule`.
until_date
int64
The date at which the recurrence should end as a POSIX timestamp.
`until_occurences` and `until_date` are mutually exclusive.until_occurrences
int32
How many times the downtime is rescheduled.
`until_occurences` and `until_date` are mutually exclusive.week_days
[string]
A list of week days to repeat on. Choose from `Mon`, `Tue`, `Wed`, `Thu`, `Fri`, `Sat` or `Sun`.
Only applicable when type is weeks. First letter must be capitalized.scope
[string]
The scope(s) to which the downtime applies and must be in `key:value` format. For example, `host:app2`.
Provide multiple scopes as a comma-separated list like `env:dev,env:prod`.
The resulting downtime applies to sources that matches ALL provided scopes (`env:dev` **AND** `env:prod`).start
int64
POSIX timestamp to start the downtime.
If not provided, the downtime starts the moment it is created.timezone
string
The timezone in which to display the downtime's start and end times in Datadog applications.
updater_id
int32
ID of the last user that updated the downtime.
canceled
int64
If a scheduled downtime is canceled.
creator_id
int32
User ID of the downtime creator.
disabled
boolean
If a downtime has been disabled.
downtime_type
int32
`0` for a downtime applied on `*` or all,
`1` when the downtime is only scoped to hosts,
or `2` when the downtime is scoped to anything but hosts.end
int64
POSIX timestamp to end the downtime. If not provided,
the downtime is in effect indefinitely until you cancel it.id
int64
The downtime ID.
message
string
A message to include with notifications for this downtime.
Email notifications can be sent to specific users by using the same `@username` notation as events.monitor_id
int64
A single monitor to which the downtime applies.
If not provided, the downtime applies to all monitors.monitor_tags
[string]
A comma-separated list of monitor tags. For example, tags that are applied directly to monitors,
not tags that are used in monitor queries (which are filtered by the scope parameter), to which the downtime applies.
The resulting downtime applies to monitors that match ALL provided monitor tags.
For example, `service:postgres` **AND** `team:frontend`.mute_first_recovery_notification
boolean
If the first recovery notification during a downtime should be muted.
notify_end_states
[string]
States for which `notify_end_types` sends out notifications for.
default: `alert,no data,warn`
notify_end_types
[string]
If set, notifies if a monitor is in an alert-worthy state (`ALERT`, `WARNING`, or `NO DATA`)
when this downtime expires or is canceled. Applied to monitors that change states during
the downtime (such as from `OK` to `ALERT`, `WARNING`, or `NO DATA`), and to monitors that
already have an alert-worthy state when downtime begins.default: `expired`
parent_id
int64
ID of the parent Downtime.
recurrence
object
An object defining the recurrence of the downtime.
period
int32
How often to repeat as an integer.
For example, to repeat every 3 days, select a type of `days` and a period of `3`.rrule
string
The `RRULE` standard for defining recurring events (**requires to set "type" to rrule**)
For example, to have a recurring event on the first day of each month, set the type to `rrule` and set the `FREQ` to `MONTHLY` and `BYMONTHDAY` to `1`.
Most common `rrule` options from the iCalendar Spec are supported.**Note**: Attributes specifying the duration in `RRULE` are not supported (for example, `DTSTART`, `DTEND`, `DURATION`).
More examples available in this [downtime guide](https://docs.datadoghq.com/monitors/guide/suppress-alert-with-downtimes/?tab=api)type
string
The type of recurrence. Choose from `days`, `weeks`, `months`, `years`, `rrule`.
until_date
int64
The date at which the recurrence should end as a POSIX timestamp.
`until_occurences` and `until_date` are mutually exclusive.until_occurrences
int32
How many times the downtime is rescheduled.
`until_occurences` and `until_date` are mutually exclusive.week_days
[string]
A list of week days to repeat on. Choose from `Mon`, `Tue`, `Wed`, `Thu`, `Fri`, `Sat` or `Sun`.
Only applicable when type is weeks. First letter must be capitalized.scope
[string]
The scope(s) to which the downtime applies and must be in `key:value` format. For example, `host:app2`.
Provide multiple scopes as a comma-separated list like `env:dev,env:prod`.
The resulting downtime applies to sources that matches ALL provided scopes (`env:dev` **AND** `env:prod`).start
int64
POSIX timestamp to start the downtime.
If not provided, the downtime starts the moment it is created.timezone
string
The timezone in which to display the downtime's start and end times in Datadog applications.
updater_id
int32
ID of the last user that updated the downtime.
```
{
"active": true,
"active_child": {
"active": true,
"canceled": 1412799983,
"creator_id": 123456,
"disabled": false,
"downtime_type": 2,
"end": 1412793983,
"id": 1626,
"message": "Message on the downtime",
"monitor_id": 123456,
"monitor_tags": [
"*"
],
"mute_first_recovery_notification": false,
"notify_end_states": [
"alert",
"no data",
"warn"
],
"notify_end_types": [
"canceled",
"expired"
],
"parent_id": 123,
"recurrence": {
"period": 1,
"rrule": "FREQ=MONTHLY;BYSETPOS=3;BYDAY=WE;INTERVAL=1",
"type": "weeks",
"until_date": 1447786293,
"until_occurrences": 2,
"week_days": [
"Mon",
"Tue"
]
},
"scope": [
"env:staging"
],
"start": 1412792983,
"timezone": "America/New_York",
"updater_id": 123456
},
"canceled": 1412799983,
"creator_id": 123456,
"disabled": false,
"downtime_type": 2,
"end": 1412793983,
"id": 1625,
"message": "Message on the downtime",
"monitor_id": 123456,
"monitor_tags": [
"*"
],
"mute_first_recovery_notification": false,
"notify_end_states": [
"alert",
"no data",
"warn"
],
"notify_end_types": [
"canceled",
"expired"
],
"parent_id": 123,
"recurrence": {
"period": 1,
"rrule": "FREQ=MONTHLY;BYSETPOS=3;BYDAY=WE;INTERVAL=1",
"type": "weeks",
"until_date": 1447786293,
"until_occurrences": 2,
"week_days": [
"Mon",
"Tue"
]
},
"scope": [
"env:staging"
],
"start": 1412792983,
"timezone": "America/New_York",
"updater_id": 123456
}
```Bad Request
- Model
- Example
Error response object.
Expand All
Field
Type
Description
errors [*required*]
[string]
Array of errors returned by the API.
```
{
"errors": [
"Bad Request"
]
}
```Forbidden
- Model
- Example
Error response object.
Expand All
Field
Type
Description
errors [*required*]
[string]
Array of errors returned by the API.
```
{
"errors": [
"Bad Request"
]
}
```Downtime not found
- Model
- Example
Error response object.
Expand All
Field
Type
Description
errors [*required*]
[string]
Array of errors returned by the API.
```
{
"errors": [
"Bad Request"
]
}
```Too many requests
- Model
- Example
Error response object.
Expand All
Field
Type
Description
errors [*required*]
[string]
Array of errors returned by the API.
```
{
"errors": [
"Bad Request"
]
}
```### Code Example- [Curl](?code-lang=curl#)
- [Go](?code-lang=go#)
- [Java](?code-lang=java#)
- [Python](?code-lang=python#)
- [Ruby](?code-lang=ruby#)
- [Rust](?code-lang=rust#)
- [Typescript](?code-lang=typescript#)

Update a downtime returns "OK" responseCopy```

# Path parametersexport downtime_id="123456"# Curl commandcurl -X PUT "https://api.ap1.datadoghq.com"https://api.ap2.datadoghq.com"https://api.datadoghq.eu"https://api.ddog-gov.com"https://api.datadoghq.com"https://api.us3.datadoghq.com"https://api.us5.datadoghq.com/api/v1/downtime/${downtime_id}" \
-H "Accept: application/json" \
-H "Content-Type: application/json" \
-H "DD-API-KEY: ${DD_API_KEY}" \
-H "DD-APPLICATION-KEY: ${DD_APP_KEY}" \
-d @- << EOF
{
"message": "Example-Downtime-updated",
"mute_first_recovery_notification": true,
"notify_end_states": [
"alert",
"no data",
"warn"
],
"notify_end_types": [
"canceled",
"expired"
]
}
EOF

```
Update a downtime returns "OK" response```
// Update a downtime returns "OK" response

package main

import (
	"context"
	"encoding/json"
	"fmt"
	"os"
	"strconv"

	"github.com/DataDog/datadog-api-client-go/v2/api/datadog"
	"github.com/DataDog/datadog-api-client-go/v2/api/datadogV1"
)

func main() {
	// there is a valid "downtime" in the system
	DowntimeID, _ := strconv.ParseInt(os.Getenv("DOWNTIME_ID"), 10, 64)

	body := datadogV1.Downtime{
		Message: *datadog.NewNullableString(datadog.PtrString("Example-Downtime-updated")),
		MuteFirstRecoveryNotification: datadog.PtrBool(true),
		NotifyEndStates: []datadogV1.NotifyEndState{
			datadogV1.NOTIFYENDSTATE_ALERT,
			datadogV1.NOTIFYENDSTATE_NO_DATA,
			datadogV1.NOTIFYENDSTATE_WARN,
		},
		NotifyEndTypes: []datadogV1.NotifyEndType{
			datadogV1.NOTIFYENDTYPE_CANCELED,
			datadogV1.NOTIFYENDTYPE_EXPIRED,
		},
	}
	ctx := datadog.NewDefaultContext(context.Background())
	configuration := datadog.NewConfiguration()
	apiClient := datadog.NewAPIClient(configuration)
	api := datadogV1.NewDowntimesApi(apiClient)
	resp, r, err := api.UpdateDowntime(ctx, DowntimeID, body)

	if err != nil {
		fmt.Fprintf(os.Stderr, "Error when calling `DowntimesApi.UpdateDowntime`: %v\n", err)
		fmt.Fprintf(os.Stderr, "Full HTTP response: %v\n", r)
	}

	responseContent, _ := json.MarshalIndent(resp, "", " ")
	fmt.Fprintf(os.Stdout, "Response from `DowntimesApi.UpdateDowntime`:\n%s\n", responseContent)
}

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=go) and then save the example to `main.go` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" go run "main.go"`
```
Update a downtime returns "OK" response```
// Update a downtime returns "OK" response

import com.datadog.api.client.ApiClient;
import com.datadog.api.client.ApiException;
import com.datadog.api.client.v1.api.DowntimesApi;
import com.datadog.api.client.v1.model.Downtime;
import com.datadog.api.client.v1.model.NotifyEndState;
import com.datadog.api.client.v1.model.NotifyEndType;
import java.util.Arrays;

public class Example {
public static void main(String[] args) {
ApiClient defaultClient = ApiClient.getDefaultApiClient();
DowntimesApi apiInstance = new DowntimesApi(defaultClient);

// there is a valid "downtime" in the system
Long DOWNTIME_ID = Long.parseLong(System.getenv("DOWNTIME_ID"));

Downtime body =
new Downtime()
.message("Example-Downtime-updated")
.muteFirstRecoveryNotification(true)
.notifyEndStates(
Arrays.asList(NotifyEndState.ALERT, NotifyEndState.NO_DATA, NotifyEndState.WARN))
.notifyEndTypes(Arrays.asList(NotifyEndType.CANCELED, NotifyEndType.EXPIRED));

try {
Downtime result = apiInstance.updateDowntime(DOWNTIME_ID, body);
System.out.println(result);
} catch (ApiException e) {
System.err.println("Exception when calling DowntimesApi#updateDowntime");
System.err.println("Status code: " + e.getCode());
System.err.println("Reason: " + e.getResponseBody());
System.err.println("Response headers: " + e.getResponseHeaders());
e.printStackTrace();
}
}
}

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=java) and then save the example to `Example.java` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" java "Example.java"`
```
Update a downtime returns "OK" response```
"""
Update a downtime returns "OK" response
"""

from os import environ
from datadog_api_client import ApiClient, Configuration
from datadog_api_client.v1.api.downtimes_api import DowntimesApi
from datadog_api_client.v1.model.downtime import Downtime
from datadog_api_client.v1.model.notify_end_state import NotifyEndState
from datadog_api_client.v1.model.notify_end_type import NotifyEndType

# there is a valid "downtime" in the system
DOWNTIME_ID = environ["DOWNTIME_ID"]

body = Downtime(
message="Example-Downtime-updated",
mute_first_recovery_notification=True,
notify_end_states=[
NotifyEndState.ALERT,
NotifyEndState.NO_DATA,
NotifyEndState.WARN,
],
notify_end_types=[
NotifyEndType.CANCELED,
NotifyEndType.EXPIRED,
],
)

configuration = Configuration()
with ApiClient(configuration) as api_client:
api_instance = DowntimesApi(api_client)
response = api_instance.update_downtime(downtime_id=int(DOWNTIME_ID), body=body)

print(response)

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=python) and then save the example to `example.py` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" python3 "example.py"`
```
Update a downtime returns "OK" response```
# Update a downtime returns "OK" response

require "datadog_api_client"
api_instance = DatadogAPIClient::V1::DowntimesAPI.new

# there is a valid "downtime" in the system
DOWNTIME_ID = ENV["DOWNTIME_ID"]

body = DatadogAPIClient::V1::Downtime.new({
message: "Example-Downtime-updated",
mute_first_recovery_notification: true,
notify_end_states: [
DatadogAPIClient::V1::NotifyEndState::ALERT,
DatadogAPIClient::V1::NotifyEndState::NO_DATA,
DatadogAPIClient::V1::NotifyEndState::WARN,
],
notify_end_types: [
DatadogAPIClient::V1::NotifyEndType::CANCELED,
DatadogAPIClient::V1::NotifyEndType::EXPIRED,
],
})
p api_instance.update_downtime(DOWNTIME_ID.to_i, body)

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=ruby) and then save the example to `example.rb` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" rb "example.rb"`
```
Update a downtime returns "OK" response```
// Update a downtime returns "OK" response
use datadog_api_client::datadog;
use datadog_api_client::datadogV1::api_downtimes::DowntimesAPI;
use datadog_api_client::datadogV1::model::Downtime;
use datadog_api_client::datadogV1::model::NotifyEndState;
use datadog_api_client::datadogV1::model::NotifyEndType;

#[tokio::main]
async fn main() {
// there is a valid "downtime" in the system
let downtime_id: i64 = std::env::var("DOWNTIME_ID").unwrap().parse().unwrap();
let body = Downtime::new()
.message(Some("Example-Downtime-updated".to_string()))
.mute_first_recovery_notification(true)
.notify_end_states(vec![
NotifyEndState::ALERT,
NotifyEndState::NO_DATA,
NotifyEndState::WARN,
])
.notify_end_types(vec![NotifyEndType::CANCELED, NotifyEndType::EXPIRED]);
let configuration = datadog::Configuration::new();
let api = DowntimesAPI::with_config(configuration);
let resp = api.update_downtime(downtime_id.clone(), body).await;
if let Ok(value) = resp {
println!("{:#?}", value);
} else {
println!("{:#?}", resp.unwrap_err());
}
}

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=rust) and then save the example to `src/main.rs` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" cargo run`
```
Update a downtime returns "OK" response```
/**
* Update a downtime returns "OK" response
*/

import { client, v1 } from "@datadog/datadog-api-client";

const configuration = client.createConfiguration();
const apiInstance = new v1.DowntimesApi(configuration);

// there is a valid "downtime" in the system
const DOWNTIME_ID = parseInt(process.env.DOWNTIME_ID as string);

const params: v1.DowntimesApiUpdateDowntimeRequest = {
body: {
message: "Example-Downtime-updated",
muteFirstRecoveryNotification: true,
notifyEndStates: ["alert", "no data", "warn"],
notifyEndTypes: ["canceled", "expired"],
},
downtimeId: DOWNTIME_ID,
};

apiInstance
.updateDowntime(params)
.then((data: v1.Downtime) => {
console.log(
"API called successfully. Returned data: " + JSON.stringify(data)
);
})
.catch((error: any) => console.error(error));

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=typescript) and then save the example to `example.ts` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" tsc "example.ts"`
```PATCH https://api.ap1.datadoghq.com/api/v2/downtime/{downtime_id}https://api.ap2.datadoghq.com/api/v2/downtime/{downtime_id}https://api.datadoghq.eu/api/v2/downtime/{downtime_id}https://api.ddog-gov.com/api/v2/downtime/{downtime_id}https://api.datadoghq.com/api/v2/downtime/{downtime_id}https://api.us3.datadoghq.com/api/v2/downtime/{downtime_id}https://api.us5.datadoghq.com/api/v2/downtime/{downtime_id}
### OverviewUpdate a downtime by `downtime_id`.
This endpoint requires the `monitors_downtime` permission.OAuth apps require the `monitors_downtime` authorization scope to access this endpoint.
### Arguments#### Path ParametersName
Type
Description
downtime_id [*required*]
string
ID of the downtime to update.
### Request#### Body Data (required)Update a downtime request body.
- Model
- Example
Expand All
Field
Type
Description
data [*required*]
object
Object to update a downtime.
attributes [*required*]
object
Attributes of the downtime to update.
display_timezone
string
The timezone in which to display the downtime's start and end times in Datadog applications. This is not used
as an offset for scheduling.default: `UTC`
message
string
A message to include with notifications for this downtime. Email notifications can be sent to specific users
by using the same `@username` notation as events. monitor_identifier
 <oneOf>
Monitor identifier for the downtime.
Option 1
object
Object of the monitor identifier.
monitor_id [*required*]
int64
ID of the monitor to prevent notifications.
Option 2
object
Object of the monitor tags.
monitor_tags [*required*]
[string]
A list of monitor tags. For example, tags that are applied directly to monitors,
not tags that are used in monitor queries (which are filtered by the scope parameter), to which the downtime applies.
The resulting downtime applies to monitors that match **all** provided monitor tags. Setting `monitor_tags`
to `[*]` configures the downtime to mute all monitors for the given scope.mute_first_recovery_notification
boolean
If the first recovery notification during a downtime should be muted.
notify_end_states
[string]
States that will trigger a monitor notification when the `notify_end_types` action occurs.
notify_end_types
[string]
Actions that will trigger a monitor notification if the downtime is in the `notify_end_types` state.
schedule
 <oneOf>
Schedule for the downtime.
Option 1
object
A recurring downtime schedule definition.
recurrences
[object]
A list of downtime recurrences.
duration [*required*]
string
The length of the downtime. Must begin with an integer and end with one of 'm', 'h', d', or 'w'.
rrule [*required*]
string
The `RRULE` standard for defining recurring events.
For example, to have a recurring event on the first day of each month, set the type to `rrule` and set the `FREQ` to `MONTHLY` and `BYMONTHDAY` to `1`.
Most common `rrule` options from the iCalendar Spec are supported.**Note**: Attributes specifying the duration in `RRULE` are not supported (for example, `DTSTART`, `DTEND`, `DURATION`).
More examples available in this [downtime guide](https://docs.datadoghq.com/monitors/guide/suppress-alert-with-downtimes/?tab=api).start
string
ISO-8601 Datetime to start the downtime. Must not include a UTC offset. If not provided, the
downtime starts the moment it is created.timezone
string
The timezone in which to schedule the downtime.
default: `UTC`
Option 2
object
A one-time downtime definition.
end
date-time
ISO-8601 Datetime to end the downtime. Must include a UTC offset of zero. If not provided, the
downtime continues forever.start
date-time
ISO-8601 Datetime to start the downtime. Must include a UTC offset of zero. If not provided, the
downtime starts the moment it is created.scope
string
The scope to which the downtime applies. Must follow the common search syntax.
id [*required*]
string
ID of this downtime.
type [*required*]
enum
Downtime resource type.
Allowed enum values: `downtime`default: `downtime`
```
{
"data": {
"attributes": {
"message": "light speed"
},
"id": "00000000-0000-1234-0000-000000000000",
"type": "downtime"
}
}
```### Response- 200
- 400
- 403
- 404
- 429
OK
- Model
- Example
Downtiming gives you greater control over monitor notifications by
allowing you to globally exclude scopes from alerting.
Downtime settings, which can be scheduled with start and end times,
prevent all alerting related to specified Datadog tags.Expand All
Field
Type
Description
data
object
Downtime data.
attributes
object
Downtime details.
canceled
date-time
Time that the downtime was canceled.
created
date-time
Creation time of the downtime.
display_timezone
string
The timezone in which to display the downtime's start and end times in Datadog applications. This is not used
as an offset for scheduling.default: `UTC`
message
string
A message to include with notifications for this downtime. Email notifications can be sent to specific users
by using the same `@username` notation as events.modified
date-time
Time that the downtime was last modified.
monitor_identifier
 <oneOf>
Monitor identifier for the downtime.
Option 1
object
Object of the monitor identifier.
monitor_id [*required*]
int64
ID of the monitor to prevent notifications.
Option 2
object
Object of the monitor tags.
monitor_tags [*required*]
[string]
A list of monitor tags. For example, tags that are applied directly to monitors,
not tags that are used in monitor queries (which are filtered by the scope parameter), to which the downtime applies.
The resulting downtime applies to monitors that match **all** provided monitor tags. Setting `monitor_tags`
to `[*]` configures the downtime to mute all monitors for the given scope.mute_first_recovery_notification
boolean
If the first recovery notification during a downtime should be muted.
notify_end_states
[string]
States that will trigger a monitor notification when the `notify_end_types` action occurs.
notify_end_types
[string]
Actions that will trigger a monitor notification if the downtime is in the `notify_end_types` state.
schedule
 <oneOf>
The schedule that defines when the monitor starts, stops, and recurs. There are two types of schedules:
one-time and recurring. Recurring schedules may have up to five RRULE-based recurrences. If no schedules are
provided, the downtime will begin immediately and never end. Option 1
object
A recurring downtime schedule definition.
current_downtime
object
The most recent actual start and end dates for a recurring downtime. For a canceled downtime,
this is the previously occurring downtime. For active downtimes, this is the ongoing downtime, and for scheduled
downtimes it is the upcoming downtime.end
date-time
The end of the current downtime.
start
date-time
The start of the current downtime.
recurrences [*required*]
[object]
A list of downtime recurrences.
duration
string
The length of the downtime. Must begin with an integer and end with one of 'm', 'h', d', or 'w'.
rrule
string
The `RRULE` standard for defining recurring events.
For example, to have a recurring event on the first day of each month, set the type to `rrule` and set the `FREQ` to `MONTHLY` and `BYMONTHDAY` to `1`.
Most common `rrule` options from the iCalendar Spec are supported.**Note**: Attributes specifying the duration in `RRULE` are not supported (for example, `DTSTART`, `DTEND`, `DURATION`).
More examples available in this [downtime guide](https://docs.datadoghq.com/monitors/guide/suppress-alert-with-downtimes/?tab=api).start
string
ISO-8601 Datetime to start the downtime. Must not include a UTC offset. If not provided, the
downtime starts the moment it is created.timezone
string
The timezone in which to schedule the downtime. This affects recurring start and end dates.
Must match `display_timezone`.default: `UTC`
Option 2
object
A one-time downtime definition.
end
date-time
ISO-8601 Datetime to end the downtime.
start [*required*]
date-time
ISO-8601 Datetime to start the downtime.
scope
string
The scope to which the downtime applies. Must follow the common search syntax.
status
enum
The current status of the downtime.
Allowed enum values: `active,canceled,ended,scheduled`id
string
The downtime ID.
relationships
object
All relationships associated with downtime.
created_by
object
The user who created the downtime.
data
object
Data for the user who created the downtime.
id
string
User ID of the downtime creator.
type
enum
Users resource type.
Allowed enum values: `users`default: `users`
monitor
object
The monitor identified by the downtime.
data
object
Data for the monitor.
id
string
Monitor ID of the downtime.
type
enum
Monitor resource type.
Allowed enum values: `monitors`default: `monitors`
type
enum
Downtime resource type.
Allowed enum values: `downtime`default: `downtime`
included
[ <oneOf>]
Array of objects related to the downtime that the user requested.
Option 1
object
User object returned by the API.
attributes
object
Attributes of user object returned by the API.
created_at
date-time
Creation time of the user.
disabled
boolean
Whether the user is disabled.
email
string
Email of the user.
handle
string
Handle of the user.
icon
string
URL of the user's icon.
last_login_time
date-time
The last time the user logged in.
mfa_enabled
boolean
If user has MFA enabled.
modified_at
date-time
Time that the user was last modified.
name
string
Name of the user.
service_account
boolean
Whether the user is a service account.
status
string
Status of the user.
title
string
Title of the user.
verified
boolean
Whether the user is verified.
id
string
ID of the user.
relationships
object
Relationships of the user object returned by the API.
org
object
Relationship to an organization.
data [*required*]
object
Relationship to organization object.
id [*required*]
string
ID of the organization.
type [*required*]
enum
Organizations resource type.
Allowed enum values: `orgs`default: `orgs`
other_orgs
object
Relationship to organizations.
data [*required*]
[object]
Relationships to organization objects.
id [*required*]
string
ID of the organization.
type [*required*]
enum
Organizations resource type.
Allowed enum values: `orgs`default: `orgs`
other_users
object
Relationship to users.
data [*required*]
[object]
Relationships to user objects.
id [*required*]
string
A unique identifier that represents the user.
type [*required*]
enum
Users resource type.
Allowed enum values: `users`default: `users`
roles
object
Relationship to roles.
data
[object]
An array containing type and the unique identifier of a role.
id
string
The unique identifier of the role.
type
enum
Roles type.
Allowed enum values: `roles`default: `roles`
type
enum
Users resource type.
Allowed enum values: `users`default: `users`
Option 2
object
Information about the monitor identified by the downtime.
attributes
object
Attributes of the monitor identified by the downtime.
name
string
The name of the monitor identified by the downtime.
id
int64
ID of the monitor identified by the downtime.
type
enum
Monitor resource type.
Allowed enum values: `monitors`default: `monitors`
```
{
"data": {
"attributes": {
"canceled": "2020-01-02T03:04:05.282979+0000",
"created": "2020-01-02T03:04:05.282979+0000",
"display_timezone": "America/New_York",
"message": "Message about the downtime",
"modified": "2020-01-02T03:04:05.282979+0000",
"monitor_identifier": {
"monitor_id": 123
},
"mute_first_recovery_notification": false,
"notify_end_states": [
"alert",
"warn"
],
"notify_end_types": [
"canceled",
"expired"
],
"schedule": {
"current_downtime": {
"end": "2020-01-02T03:04:00.000Z",
"start": "2020-01-02T03:04:00.000Z"
},
"recurrences": [
{
"duration": "123d",
"rrule": "FREQ=MONTHLY;BYSETPOS=3;BYDAY=WE;INTERVAL=1",
"start": "2020-01-02T03:04"
}
],
"timezone": "America/New_York"
},
"scope": "env:(staging OR prod) AND datacenter:us-east-1",
"status": "active"
},
"id": "00000000-0000-1234-0000-000000000000",
"relationships": {
"created_by": {
"data": {
"id": "00000000-0000-1234-0000-000000000000",
"type": "users"
}
},
"monitor": {
"data": {
"id": "12345",
"type": "monitors"
}
}
},
"type": "downtime"
},
"included": [
{
"attributes": {
"created_at": "2019-09-19T10:00:00.000Z",
"disabled": false,
"email": "string",
"handle": "string",
"icon": "string",
"last_login_time": "2019-09-19T10:00:00.000Z",
"mfa_enabled": false,
"modified_at": "2019-09-19T10:00:00.000Z",
"name": "string",
"service_account": false,
"status": "string",
"title": "string",
"verified": false
},
"id": "string",
"relationships": {
"org": {
"data": {
"id": "00000000-0000-beef-0000-000000000000",
"type": "orgs"
}
},
"other_orgs": {
"data": [
{
"id": "00000000-0000-beef-0000-000000000000",
"type": "orgs"
}
]
},
"other_users": {
"data": [
{
"id": "00000000-0000-0000-2345-000000000000",
"type": "users"
}
]
},
"roles": {
"data": [
{
"id": "3653d3c6-0c75-11ea-ad28-fb5701eabc7d",
"type": "roles"
}
]
}
},
"type": "users"
}
]
}
```Bad Request
- Model
- Example
API error response.
Expand All
Field
Type
Description
errors [*required*]
[string]
A list of errors.
```
{
"errors": [
"Bad Request"
]
}
```Forbidden
- Model
- Example
API error response.
Expand All
Field
Type
Description
errors [*required*]
[string]
A list of errors.
```
{
"errors": [
"Bad Request"
]
}
```Downtime not found
- Model
- Example
API error response.
Expand All
Field
Type
Description
errors [*required*]
[string]
A list of errors.
```
{
"errors": [
"Bad Request"
]
}
```Too many requests
- Model
- Example
API error response.
Expand All
Field
Type
Description
errors [*required*]
[string]
A list of errors.
```
{
"errors": [
"Bad Request"
]
}
```### Code Example- [Curl](?code-lang=curl#)
- [Go](?code-lang=go#)
- [Java](?code-lang=java#)
- [Python](?code-lang=python#)
- [Ruby](?code-lang=ruby#)
- [Rust](?code-lang=rust#)
- [Typescript](?code-lang=typescript#)

Update a downtime returns "OK" responseCopy```

# Path parametersexport downtime_id="00e000000-0000-1234-0000-000000000000"# Curl commandcurl -X PATCH "https://api.ap1.datadoghq.com"https://api.ap2.datadoghq.com"https://api.datadoghq.eu"https://api.ddog-gov.com"https://api.datadoghq.com"https://api.us3.datadoghq.com"https://api.us5.datadoghq.com/api/v2/downtime/${downtime_id}" \
-H "Accept: application/json" \
-H "Content-Type: application/json" \
-H "DD-API-KEY: ${DD_API_KEY}" \
-H "DD-APPLICATION-KEY: ${DD_APP_KEY}" \
-d @- << EOF
{
"data": {
"attributes": {
"message": "light speed"
},
"id": "00000000-0000-1234-0000-000000000000",
"type": "downtime"
}
}
EOF

```
Update a downtime returns "OK" response```
// Update a downtime returns "OK" response

package main

import (
	"context"
	"encoding/json"
	"fmt"
	"os"

	"github.com/DataDog/datadog-api-client-go/v2/api/datadog"
	"github.com/DataDog/datadog-api-client-go/v2/api/datadogV2"
)

func main() {
	// there is a valid "downtime_v2" in the system
	DowntimeV2DataID := os.Getenv("DOWNTIME_V2_DATA_ID")

	body := datadogV2.DowntimeUpdateRequest{
		Data: datadogV2.DowntimeUpdateRequestData{
			Attributes: datadogV2.DowntimeUpdateRequestAttributes{
				Message: *datadog.NewNullableString(datadog.PtrString("light speed")),
			},
			Id: DowntimeV2DataID,
			Type: datadogV2.DOWNTIMERESOURCETYPE_DOWNTIME,
		},
	}
	ctx := datadog.NewDefaultContext(context.Background())
	configuration := datadog.NewConfiguration()
	apiClient := datadog.NewAPIClient(configuration)
	api := datadogV2.NewDowntimesApi(apiClient)
	resp, r, err := api.UpdateDowntime(ctx, DowntimeV2DataID, body)

	if err != nil {
		fmt.Fprintf(os.Stderr, "Error when calling `DowntimesApi.UpdateDowntime`: %v\n", err)
		fmt.Fprintf(os.Stderr, "Full HTTP response: %v\n", r)
	}

	responseContent, _ := json.MarshalIndent(resp, "", " ")
	fmt.Fprintf(os.Stdout, "Response from `DowntimesApi.UpdateDowntime`:\n%s\n", responseContent)
}

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=go) and then save the example to `main.go` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" go run "main.go"`
```
Update a downtime returns "OK" response```
// Update a downtime returns "OK" response

import com.datadog.api.client.ApiClient;
import com.datadog.api.client.ApiException;
import com.datadog.api.client.v2.api.DowntimesApi;
import com.datadog.api.client.v2.model.DowntimeResourceType;
import com.datadog.api.client.v2.model.DowntimeResponse;
import com.datadog.api.client.v2.model.DowntimeUpdateRequest;
import com.datadog.api.client.v2.model.DowntimeUpdateRequestAttributes;
import com.datadog.api.client.v2.model.DowntimeUpdateRequestData;

public class Example {
public static void main(String[] args) {
ApiClient defaultClient = ApiClient.getDefaultApiClient();
DowntimesApi apiInstance = new DowntimesApi(defaultClient);

// there is a valid "downtime_v2" in the system
String DOWNTIME_V2_DATA_ID = System.getenv("DOWNTIME_V2_DATA_ID");

DowntimeUpdateRequest body =
new DowntimeUpdateRequest()
.data(
new DowntimeUpdateRequestData()
.attributes(new DowntimeUpdateRequestAttributes().message("light speed"))
.id(DOWNTIME_V2_DATA_ID)
.type(DowntimeResourceType.DOWNTIME));

try {
DowntimeResponse result = apiInstance.updateDowntime(DOWNTIME_V2_DATA_ID, body);
System.out.println(result);
} catch (ApiException e) {
System.err.println("Exception when calling DowntimesApi#updateDowntime");
System.err.println("Status code: " + e.getCode());
System.err.println("Reason: " + e.getResponseBody());
System.err.println("Response headers: " + e.getResponseHeaders());
e.printStackTrace();
}
}
}

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=java) and then save the example to `Example.java` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" java "Example.java"`
```
Update a downtime returns "OK" response```
"""
Update a downtime returns "OK" response
"""

from os import environ
from datadog_api_client import ApiClient, Configuration
from datadog_api_client.v2.api.downtimes_api import DowntimesApi
from datadog_api_client.v2.model.downtime_resource_type import DowntimeResourceType
from datadog_api_client.v2.model.downtime_update_request import DowntimeUpdateRequest
from datadog_api_client.v2.model.downtime_update_request_attributes import DowntimeUpdateRequestAttributes
from datadog_api_client.v2.model.downtime_update_request_data import DowntimeUpdateRequestData

# there is a valid "downtime_v2" in the system
DOWNTIME_V2_DATA_ID = environ["DOWNTIME_V2_DATA_ID"]

body = DowntimeUpdateRequest(
data=DowntimeUpdateRequestData(
attributes=DowntimeUpdateRequestAttributes(
message="light speed",
),
id=DOWNTIME_V2_DATA_ID,
type=DowntimeResourceType.DOWNTIME,
),
)

configuration = Configuration()
with ApiClient(configuration) as api_client:
api_instance = DowntimesApi(api_client)
response = api_instance.update_downtime(downtime_id=DOWNTIME_V2_DATA_ID, body=body)

print(response)

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=python) and then save the example to `example.py` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" python3 "example.py"`
```
Update a downtime returns "OK" response```
# Update a downtime returns "OK" response

require "datadog_api_client"
api_instance = DatadogAPIClient::V2::DowntimesAPI.new

# there is a valid "downtime_v2" in the system
DOWNTIME_V2_DATA_ID = ENV["DOWNTIME_V2_DATA_ID"]

body = DatadogAPIClient::V2::DowntimeUpdateRequest.new({
data: DatadogAPIClient::V2::DowntimeUpdateRequestData.new({
attributes: DatadogAPIClient::V2::DowntimeUpdateRequestAttributes.new({
message: "light speed",
}),
id: DOWNTIME_V2_DATA_ID,
type: DatadogAPIClient::V2::DowntimeResourceType::DOWNTIME,
}),
})
p api_instance.update_downtime(DOWNTIME_V2_DATA_ID, body)

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=ruby) and then save the example to `example.rb` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" rb "example.rb"`
```
Update a downtime returns "OK" response```
// Update a downtime returns "OK" response
use datadog_api_client::datadog;
use datadog_api_client::datadogV2::api_downtimes::DowntimesAPI;
use datadog_api_client::datadogV2::model::DowntimeResourceType;
use datadog_api_client::datadogV2::model::DowntimeUpdateRequest;
use datadog_api_client::datadogV2::model::DowntimeUpdateRequestAttributes;
use datadog_api_client::datadogV2::model::DowntimeUpdateRequestData;

#[tokio::main]
async fn main() {
// there is a valid "downtime_v2" in the system
let downtime_v2_data_id = std::env::var("DOWNTIME_V2_DATA_ID").unwrap();
let body = DowntimeUpdateRequest::new(DowntimeUpdateRequestData::new(
DowntimeUpdateRequestAttributes::new().message(Some("light speed".to_string())),
downtime_v2_data_id.clone(),
DowntimeResourceType::DOWNTIME,
));
let configuration = datadog::Configuration::new();
let api = DowntimesAPI::with_config(configuration);
let resp = api.update_downtime(downtime_v2_data_id.clone(), body).await;
if let Ok(value) = resp {
println!("{:#?}", value);
} else {
println!("{:#?}", resp.unwrap_err());
}
}

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=rust) and then save the example to `src/main.rs` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" cargo run`
```
Update a downtime returns "OK" response```
/**
* Update a downtime returns "OK" response
*/

import { client, v2 } from "@datadog/datadog-api-client";

const configuration = client.createConfiguration();
const apiInstance = new v2.DowntimesApi(configuration);

// there is a valid "downtime_v2" in the system
const DOWNTIME_V2_DATA_ID = process.env.DOWNTIME_V2_DATA_ID as string;

const params: v2.DowntimesApiUpdateDowntimeRequest = {
body: {
data: {
attributes: {
message: "light speed",
},
id: DOWNTIME_V2_DATA_ID,
type: "downtime",
},
},
downtimeId: DOWNTIME_V2_DATA_ID,
};

apiInstance
.updateDowntime(params)
.then((data: v2.DowntimeResponse) => {
console.log(
"API called successfully. Returned data: " + JSON.stringify(data)
);
})
.catch((error: any) => console.error(error));

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=typescript) and then save the example to `example.ts` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" tsc "example.ts"`
```## Get active downtimes for a monitor- v1
- v2 (latest)
GET https://api.ap1.datadoghq.com/api/v1/monitor/{monitor_id}/downtimeshttps://api.ap2.datadoghq.com/api/v1/monitor/{monitor_id}/downtimeshttps://api.datadoghq.eu/api/v1/monitor/{monitor_id}/downtimeshttps://api.ddog-gov.com/api/v1/monitor/{monitor_id}/downtimeshttps://api.datadoghq.com/api/v1/monitor/{monitor_id}/downtimeshttps://api.us3.datadoghq.com/api/v1/monitor/{monitor_id}/downtimeshttps://api.us5.datadoghq.com/api/v1/monitor/{monitor_id}/downtimes
### OverviewGet all active v1 downtimes for the specified monitor. **Note:** This endpoint has been deprecated. Please use v2 endpoints.
This endpoint requires the `monitors_read` permission.OAuth apps require the `monitors_read` authorization scope to access this endpoint.
### Arguments#### Path ParametersName
Type
Description
monitor_id [*required*]
integer
The id of the monitor
### Response- 200
- 400
- 404
- 429
OK
- Model
- Example
Expand All
Field
Type
Description
active
boolean
If a scheduled downtime currently exists.
active_child
object
The downtime object definition of the active child for the original parent recurring downtime. This
field will only exist on recurring downtimes.active
boolean
If a scheduled downtime currently exists.
canceled
int64
If a scheduled downtime is canceled.
creator_id
int32
User ID of the downtime creator.
disabled
boolean
If a downtime has been disabled.
downtime_type
int32
`0` for a downtime applied on `*` or all,
`1` when the downtime is only scoped to hosts,
or `2` when the downtime is scoped to anything but hosts.end
int64
POSIX timestamp to end the downtime. If not provided,
the downtime is in effect indefinitely until you cancel it.id
int64
The downtime ID.
message
string
A message to include with notifications for this downtime.
Email notifications can be sent to specific users by using the same `@username` notation as events.monitor_id
int64
A single monitor to which the downtime applies.
If not provided, the downtime applies to all monitors.monitor_tags
[string]
A comma-separated list of monitor tags. For example, tags that are applied directly to monitors,
not tags that are used in monitor queries (which are filtered by the scope parameter), to which the downtime applies.
The resulting downtime applies to monitors that match ALL provided monitor tags.
For example, `service:postgres` **AND** `team:frontend`.mute_first_recovery_notification
boolean
If the first recovery notification during a downtime should be muted.
notify_end_states
[string]
States for which `notify_end_types` sends out notifications for.
default: `alert,no data,warn`
notify_end_types
[string]
If set, notifies if a monitor is in an alert-worthy state (`ALERT`, `WARNING`, or `NO DATA`)
when this downtime expires or is canceled. Applied to monitors that change states during
the downtime (such as from `OK` to `ALERT`, `WARNING`, or `NO DATA`), and to monitors that
already have an alert-worthy state when downtime begins.default: `expired`
parent_id
int64
ID of the parent Downtime.
recurrence
object
An object defining the recurrence of the downtime.
period
int32
How often to repeat as an integer.
For example, to repeat every 3 days, select a type of `days` and a period of `3`.rrule
string
The `RRULE` standard for defining recurring events (**requires to set "type" to rrule**)
For example, to have a recurring event on the first day of each month, set the type to `rrule` and set the `FREQ` to `MONTHLY` and `BYMONTHDAY` to `1`.
Most common `rrule` options from the iCalendar Spec are supported.**Note**: Attributes specifying the duration in `RRULE` are not supported (for example, `DTSTART`, `DTEND`, `DURATION`).
More examples available in this [downtime guide](https://docs.datadoghq.com/monitors/guide/suppress-alert-with-downtimes/?tab=api)type
string
The type of recurrence. Choose from `days`, `weeks`, `months`, `years`, `rrule`.
until_date
int64
The date at which the recurrence should end as a POSIX timestamp.
`until_occurences` and `until_date` are mutually exclusive.until_occurrences
int32
How many times the downtime is rescheduled.
`until_occurences` and `until_date` are mutually exclusive.week_days
[string]
A list of week days to repeat on. Choose from `Mon`, `Tue`, `Wed`, `Thu`, `Fri`, `Sat` or `Sun`.
Only applicable when type is weeks. First letter must be capitalized.scope
[string]
The scope(s) to which the downtime applies and must be in `key:value` format. For example, `host:app2`.
Provide multiple scopes as a comma-separated list like `env:dev,env:prod`.
The resulting downtime applies to sources that matches ALL provided scopes (`env:dev` **AND** `env:prod`).start
int64
POSIX timestamp to start the downtime.
If not provided, the downtime starts the moment it is created.timezone
string
The timezone in which to display the downtime's start and end times in Datadog applications.
updater_id
int32
ID of the last user that updated the downtime.
canceled
int64
If a scheduled downtime is canceled.
creator_id
int32
User ID of the downtime creator.
disabled
boolean
If a downtime has been disabled.
downtime_type
int32
`0` for a downtime applied on `*` or all,
`1` when the downtime is only scoped to hosts,
or `2` when the downtime is scoped to anything but hosts.end
int64
POSIX timestamp to end the downtime. If not provided,
the downtime is in effect indefinitely until you cancel it.id
int64
The downtime ID.
message
string
A message to include with notifications for this downtime.
Email notifications can be sent to specific users by using the same `@username` notation as events.monitor_id
int64
A single monitor to which the downtime applies.
If not provided, the downtime applies to all monitors.monitor_tags
[string]
A comma-separated list of monitor tags. For example, tags that are applied directly to monitors,
not tags that are used in monitor queries (which are filtered by the scope parameter), to which the downtime applies.
The resulting downtime applies to monitors that match ALL provided monitor tags.
For example, `service:postgres` **AND** `team:frontend`.mute_first_recovery_notification
boolean
If the first recovery notification during a downtime should be muted.
notify_end_states
[string]
States for which `notify_end_types` sends out notifications for.
default: `alert,no data,warn`
notify_end_types
[string]
If set, notifies if a monitor is in an alert-worthy state (`ALERT`, `WARNING`, or `NO DATA`)
when this downtime expires or is canceled. Applied to monitors that change states during
the downtime (such as from `OK` to `ALERT`, `WARNING`, or `NO DATA`), and to monitors that
already have an alert-worthy state when downtime begins.default: `expired`
parent_id
int64
ID of the parent Downtime.
recurrence
object
An object defining the recurrence of the downtime.
period
int32
How often to repeat as an integer.
For example, to repeat every 3 days, select a type of `days` and a period of `3`.rrule
string
The `RRULE` standard for defining recurring events (**requires to set "type" to rrule**)
For example, to have a recurring event on the first day of each month, set the type to `rrule` and set the `FREQ` to `MONTHLY` and `BYMONTHDAY` to `1`.
Most common `rrule` options from the iCalendar Spec are supported.**Note**: Attributes specifying the duration in `RRULE` are not supported (for example, `DTSTART`, `DTEND`, `DURATION`).
More examples available in this [downtime guide](https://docs.datadoghq.com/monitors/guide/suppress-alert-with-downtimes/?tab=api)type
string
The type of recurrence. Choose from `days`, `weeks`, `months`, `years`, `rrule`.
until_date
int64
The date at which the recurrence should end as a POSIX timestamp.
`until_occurences` and `until_date` are mutually exclusive.until_occurrences
int32
How many times the downtime is rescheduled.
`until_occurences` and `until_date` are mutually exclusive.week_days
[string]
A list of week days to repeat on. Choose from `Mon`, `Tue`, `Wed`, `Thu`, `Fri`, `Sat` or `Sun`.
Only applicable when type is weeks. First letter must be capitalized.scope
[string]
The scope(s) to which the downtime applies and must be in `key:value` format. For example, `host:app2`.
Provide multiple scopes as a comma-separated list like `env:dev,env:prod`.
The resulting downtime applies to sources that matches ALL provided scopes (`env:dev` **AND** `env:prod`).start
int64
POSIX timestamp to start the downtime.
If not provided, the downtime starts the moment it is created.timezone
string
The timezone in which to display the downtime's start and end times in Datadog applications.
updater_id
int32
ID of the last user that updated the downtime.
```
{
"active": true,
"active_child": {
"active": true,
"canceled": 1412799983,
"creator_id": 123456,
"disabled": false,
"downtime_type": 2,
"end": 1412793983,
"id": 1626,
"message": "Message on the downtime",
"monitor_id": 123456,
"monitor_tags": [
"*"
],
"mute_first_recovery_notification": false,
"notify_end_states": [
"alert",
"no data",
"warn"
],
"notify_end_types": [
"canceled",
"expired"
],
"parent_id": 123,
"recurrence": {
"period": 1,
"rrule": "FREQ=MONTHLY;BYSETPOS=3;BYDAY=WE;INTERVAL=1",
"type": "weeks",
"until_date": 1447786293,
"until_occurrences": 2,
"week_days": [
"Mon",
"Tue"
]
},
"scope": [
"env:staging"
],
"start": 1412792983,
"timezone": "America/New_York",
"updater_id": 123456
},
"canceled": 1412799983,
"creator_id": 123456,
"disabled": false,
"downtime_type": 2,
"end": 1412793983,
"id": 1625,
"message": "Message on the downtime",
"monitor_id": 123456,
"monitor_tags": [
"*"
],
"mute_first_recovery_notification": false,
"notify_end_states": [
"alert",
"no data",
"warn"
],
"notify_end_types": [
"canceled",
"expired"
],
"parent_id": 123,
"recurrence": {
"period": 1,
"rrule": "FREQ=MONTHLY;BYSETPOS=3;BYDAY=WE;INTERVAL=1",
"type": "weeks",
"until_date": 1447786293,
"until_occurrences": 2,
"week_days": [
"Mon",
"Tue"
]
},
"scope": [
"env:staging"
],
"start": 1412792983,
"timezone": "America/New_York",
"updater_id": 123456
}
```Bad Request
- Model
- Example
Error response object.
Expand All
Field
Type
Description
errors [*required*]
[string]
Array of errors returned by the API.
```
{
"errors": [
"Bad Request"
]
}
```Monitor Not Found error
- Model
- Example
Error response object.
Expand All
Field
Type
Description
errors [*required*]
[string]
Array of errors returned by the API.
```
{
"errors": [
"Bad Request"
]
}
```Too many requests
- Model
- Example
Error response object.
Expand All
Field
Type
Description
errors [*required*]
[string]
Array of errors returned by the API.
```
{
"errors": [
"Bad Request"
]
}
```### Code Example- [Curl](?code-lang=curl#)
- [Python](?code-lang=python#)
- [Ruby](?code-lang=ruby#)
- [Go](?code-lang=go#)
- [Java](?code-lang=java#)
- [Rust](?code-lang=rust#)
- [Typescript](?code-lang=typescript#)

Get active downtimes for a monitorCopy```

# Path parametersexport monitor_id="CHANGE_ME"# Curl commandcurl -X GET "https://api.ap1.datadoghq.com"https://api.ap2.datadoghq.com"https://api.datadoghq.eu"https://api.ddog-gov.com"https://api.datadoghq.com"https://api.us3.datadoghq.com"https://api.us5.datadoghq.com/api/v1/monitor/${monitor_id}/downtimes" \
-H "Accept: application/json" \
-H "DD-API-KEY: ${DD_API_KEY}" \
-H "DD-APPLICATION-KEY: ${DD_APP_KEY}"

```
Get active downtimes for a monitor```
"""
Get active downtimes for a monitor returns "OK" response
"""

from datadog_api_client import ApiClient, Configuration
from datadog_api_client.v1.api.downtimes_api import DowntimesApi

configuration = Configuration()
with ApiClient(configuration) as api_client:
api_instance = DowntimesApi(api_client)
response = api_instance.list_monitor_downtimes(
monitor_id=9223372036854775807,
)

print(response)

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=python) and then save the example to `example.py` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" python3 "example.py"`
```
Get active downtimes for a monitor```
# Get active downtimes for a monitor returns "OK" response

require "datadog_api_client"
api_instance = DatadogAPIClient::V1::DowntimesAPI.new
p api_instance.list_monitor_downtimes(9223372036854775807)

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=ruby) and then save the example to `example.rb` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" rb "example.rb"`
```
Get active downtimes for a monitor```
// Get active downtimes for a monitor returns "OK" response

package main

import (
	"context"
	"encoding/json"
	"fmt"
	"os"

	"github.com/DataDog/datadog-api-client-go/v2/api/datadog"
	"github.com/DataDog/datadog-api-client-go/v2/api/datadogV1"
)

func main() {
	ctx := datadog.NewDefaultContext(context.Background())
	configuration := datadog.NewConfiguration()
	apiClient := datadog.NewAPIClient(configuration)
	api := datadogV1.NewDowntimesApi(apiClient)
	resp, r, err := api.ListMonitorDowntimes(ctx, 9223372036854775807)

	if err != nil {
		fmt.Fprintf(os.Stderr, "Error when calling `DowntimesApi.ListMonitorDowntimes`: %v\n", err)
		fmt.Fprintf(os.Stderr, "Full HTTP response: %v\n", r)
	}

	responseContent, _ := json.MarshalIndent(resp, "", " ")
	fmt.Fprintf(os.Stdout, "Response from `DowntimesApi.ListMonitorDowntimes`:\n%s\n", responseContent)
}

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=go) and then save the example to `main.go` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" go run "main.go"`
```
Get active downtimes for a monitor```
// Get active downtimes for a monitor returns "OK" response

import com.datadog.api.client.ApiClient;
import com.datadog.api.client.ApiException;
import com.datadog.api.client.v1.api.DowntimesApi;
import com.datadog.api.client.v1.model.Downtime;
import java.util.List;

public class Example {
public static void main(String[] args) {
ApiClient defaultClient = ApiClient.getDefaultApiClient();
DowntimesApi apiInstance = new DowntimesApi(defaultClient);

try {
List<Downtime> result = apiInstance.listMonitorDowntimes(9223372036854775807L);
System.out.println(result);
} catch (ApiException e) {
System.err.println("Exception when calling DowntimesApi#listMonitorDowntimes");
System.err.println("Status code: " + e.getCode());
System.err.println("Reason: " + e.getResponseBody());
System.err.println("Response headers: " + e.getResponseHeaders());
e.printStackTrace();
}
}
}

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=java) and then save the example to `Example.java` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" java "Example.java"`
```
Get active downtimes for a monitor```
// Get active downtimes for a monitor returns "OK" response
use datadog_api_client::datadog;
use datadog_api_client::datadogV1::api_downtimes::DowntimesAPI;

#[tokio::main]
async fn main() {
let configuration = datadog::Configuration::new();
let api = DowntimesAPI::with_config(configuration);
let resp = api.list_monitor_downtimes(9223372036854775807).await;
if let Ok(value) = resp {
println!("{:#?}", value);
} else {
println!("{:#?}", resp.unwrap_err());
}
}

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=rust) and then save the example to `src/main.rs` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" cargo run`
```
Get active downtimes for a monitor```
/**
* Get active downtimes for a monitor returns "OK" response
*/

import { client, v1 } from "@datadog/datadog-api-client";

const configuration = client.createConfiguration();
const apiInstance = new v1.DowntimesApi(configuration);

const params: v1.DowntimesApiListMonitorDowntimesRequest = {
monitorId: 9223372036854775807,
};

apiInstance
.listMonitorDowntimes(params)
.then((data: v1.Downtime[]) => {
console.log(
"API called successfully. Returned data: " + JSON.stringify(data)
);
})
.catch((error: any) => console.error(error));

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=typescript) and then save the example to `example.ts` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" tsc "example.ts"`
```GET https://api.ap1.datadoghq.com/api/v2/monitor/{monitor_id}/downtime_matcheshttps://api.ap2.datadoghq.com/api/v2/monitor/{monitor_id}/downtime_matcheshttps://api.datadoghq.eu/api/v2/monitor/{monitor_id}/downtime_matcheshttps://api.ddog-gov.com/api/v2/monitor/{monitor_id}/downtime_matcheshttps://api.datadoghq.com/api/v2/monitor/{monitor_id}/downtime_matcheshttps://api.us3.datadoghq.com/api/v2/monitor/{monitor_id}/downtime_matcheshttps://api.us5.datadoghq.com/api/v2/monitor/{monitor_id}/downtime_matches
### OverviewGet all active downtimes for the specified monitor.
This endpoint requires the `monitors_downtime` permission.OAuth apps require the `monitors_downtime` authorization scope to access this endpoint.
### Arguments#### Path ParametersName
Type
Description
monitor_id [*required*]
integer
The id of the monitor.
#### Query StringsName
Type
Description
page[offset]
integer
Specific offset to use as the beginning of the returned page.
page[limit]
integer
Maximum number of downtimes in the response.
### Response- 200
- 404
- 429
OK
- Model
- Example
Response for retrieving all downtime matches for a monitor.
Expand All
Field
Type
Description
data
[object]
An array of downtime matches.
attributes
object
Downtime match details.
end
date-time
The end of the downtime.
groups
[string]
An array of groups associated with the downtime.
scope
string
The scope to which the downtime applies. Must follow the common search syntax.
start
date-time
The start of the downtime.
id
string
The downtime ID.
type
enum
Monitor Downtime Match resource type.
Allowed enum values: `downtime_match`default: `downtime_match`
meta
object
Pagination metadata returned by the API.
page
object
Object containing the total filtered count.
total_filtered_count
int64
Total count of elements matched by the filter.
```
{
"data": [
{
"attributes": {
"end": "2020-01-02T03:04:00.000Z",
"groups": [
"service:postgres",
"team:frontend"
],
"scope": "env:(staging OR prod) AND datacenter:us-east-1",
"start": "2020-01-02T03:04:00.000Z"
},
"id": "00000000-0000-1234-0000-000000000000",
"type": "downtime_match"
}
],
"meta": {
"page": {
"total_filtered_count": "integer"
}
}
}
```Monitor Not Found error
- Model
- Example
API error response.
Expand All
Field
Type
Description
errors [*required*]
[string]
A list of errors.
```
{
"errors": [
"Bad Request"
]
}
```Too many requests
- Model
- Example
API error response.
Expand All
Field
Type
Description
errors [*required*]
[string]
A list of errors.
```
{
"errors": [
"Bad Request"
]
}
```### Code Example- [Curl](?code-lang=curl#)
- [Python](?code-lang=python#)
- [Ruby](?code-lang=ruby#)
- [Go](?code-lang=go#)
- [Java](?code-lang=java#)
- [Rust](?code-lang=rust#)
- [Typescript](?code-lang=typescript#)

Get active downtimes for a monitorCopy```

# Path parametersexport monitor_id="CHANGE_ME"# Curl commandcurl -X GET "https://api.ap1.datadoghq.com"https://api.ap2.datadoghq.com"https://api.datadoghq.eu"https://api.ddog-gov.com"https://api.datadoghq.com"https://api.us3.datadoghq.com"https://api.us5.datadoghq.com/api/v2/monitor/${monitor_id}/downtime_matches" \
-H "Accept: application/json" \
-H "DD-API-KEY: ${DD_API_KEY}" \
-H "DD-APPLICATION-KEY: ${DD_APP_KEY}"

```
Get active downtimes for a monitor```
"""
Get active downtimes for a monitor returns "OK" response
"""

from datadog_api_client import ApiClient, Configuration
from datadog_api_client.v2.api.downtimes_api import DowntimesApi

configuration = Configuration()
with ApiClient(configuration) as api_client:
api_instance = DowntimesApi(api_client)
response = api_instance.list_monitor_downtimes(
monitor_id=35534610,
)

print(response)

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=python) and then save the example to `example.py` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" python3 "example.py"`
```
Get active downtimes for a monitor```
# Get active downtimes for a monitor returns "OK" response

require "datadog_api_client"
api_instance = DatadogAPIClient::V2::DowntimesAPI.new
p api_instance.list_monitor_downtimes(35534610)

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=ruby) and then save the example to `example.rb` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" rb "example.rb"`
```
Get active downtimes for a monitor```
// Get active downtimes for a monitor returns "OK" response

package main

import (
	"context"
	"encoding/json"
	"fmt"
	"os"

	"github.com/DataDog/datadog-api-client-go/v2/api/datadog"
	"github.com/DataDog/datadog-api-client-go/v2/api/datadogV2"
)

func main() {
	ctx := datadog.NewDefaultContext(context.Background())
	configuration := datadog.NewConfiguration()
	apiClient := datadog.NewAPIClient(configuration)
	api := datadogV2.NewDowntimesApi(apiClient)
	resp, r, err := api.ListMonitorDowntimes(ctx, 35534610, *datadogV2.NewListMonitorDowntimesOptionalParameters())

	if err != nil {
		fmt.Fprintf(os.Stderr, "Error when calling `DowntimesApi.ListMonitorDowntimes`: %v\n", err)
		fmt.Fprintf(os.Stderr, "Full HTTP response: %v\n", r)
	}

	responseContent, _ := json.MarshalIndent(resp, "", " ")
	fmt.Fprintf(os.Stdout, "Response from `DowntimesApi.ListMonitorDowntimes`:\n%s\n", responseContent)
}

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=go) and then save the example to `main.go` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" go run "main.go"`
```
Get active downtimes for a monitor```
// Get active downtimes for a monitor returns "OK" response

import com.datadog.api.client.ApiClient;
import com.datadog.api.client.ApiException;
import com.datadog.api.client.v2.api.DowntimesApi;
import com.datadog.api.client.v2.model.MonitorDowntimeMatchResponse;

public class Example {
public static void main(String[] args) {
ApiClient defaultClient = ApiClient.getDefaultApiClient();
DowntimesApi apiInstance = new DowntimesApi(defaultClient);

try {
MonitorDowntimeMatchResponse result = apiInstance.listMonitorDowntimes(35534610L);
System.out.println(result);
} catch (ApiException e) {
System.err.println("Exception when calling DowntimesApi#listMonitorDowntimes");
System.err.println("Status code: " + e.getCode());
System.err.println("Reason: " + e.getResponseBody());
System.err.println("Response headers: " + e.getResponseHeaders());
e.printStackTrace();
}
}
}

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=java) and then save the example to `Example.java` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" java "Example.java"`
```
Get active downtimes for a monitor```
// Get active downtimes for a monitor returns "OK" response
use datadog_api_client::datadog;
use datadog_api_client::datadogV2::api_downtimes::DowntimesAPI;
use datadog_api_client::datadogV2::api_downtimes::ListMonitorDowntimesOptionalParams;

#[tokio::main]
async fn main() {
let configuration = datadog::Configuration::new();
let api = DowntimesAPI::with_config(configuration);
let resp = api
.list_monitor_downtimes(35534610, ListMonitorDowntimesOptionalParams::default())
.await;
if let Ok(value) = resp {
println!("{:#?}", value);
} else {
println!("{:#?}", resp.unwrap_err());
}
}

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=rust) and then save the example to `src/main.rs` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" cargo run`
```
Get active downtimes for a monitor```
/**
* Get active downtimes for a monitor returns "OK" response
*/

import { client, v2 } from "@datadog/datadog-api-client";

const configuration = client.createConfiguration();
const apiInstance = new v2.DowntimesApi(configuration);

const params: v2.DowntimesApiListMonitorDowntimesRequest = {
monitorId: 35534610,
};

apiInstance
.listMonitorDowntimes(params)
.then((data: v2.MonitorDowntimeMatchResponse) => {
console.log(
"API called successfully. Returned data: " + JSON.stringify(data)
);
})
.catch((error: any) => console.error(error));

```#### InstructionsFirst [install the library and its dependencies](https://docs.datadoghq.com/api/latest/?code-lang=typescript) and then save the example to `example.ts` and run following commands:
```

`DD_SITE="datadoghq.comus3.datadoghq.comus5.datadoghq.comdatadoghq.euap1.datadoghq.comap2.datadoghq.comddog-gov.com" DD_API_KEY="<DD_API_KEY>" DD_APP_KEY="<DD_APP_KEY>" tsc "example.ts"`
```###### Request a personalized demo×##### Get Started with Datadog