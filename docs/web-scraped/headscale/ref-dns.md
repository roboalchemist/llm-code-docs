# Source: https://headscale.net/stable/ref/dns/

[![](data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdib3g9IjAgMCAyNCAyNCI+PHBhdGggZD0iTTEwIDIwSDZWNGg3djVoNXYzLjFsMi0yVjhsLTYtNkg2Yy0xLjEgMC0yIC45LTIgMnYxNmMwIDEuMS45IDIgMiAyaDR6bTEwLjItN2MuMSAwIC4zLjEuNC4ybDEuMyAxLjNjLjIuMi4yLjYgMCAuOGwtMSAxLTIuMS0yLjEgMS0xYy4xLS4xLjItLjIuNC0uMm0wIDMuOUwxNC4xIDIzSDEydi0yLjFsNi4xLTYuMXoiIC8+PC9zdmc+)](https://github.com/juanfont/headscale/blob/main/docs/ref/dns.md "Edit this page") [![](data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdib3g9IjAgMCAyNCAyNCI+PHBhdGggZD0iTTE3IDE4Yy41NiAwIDEgLjQ0IDEgMXMtLjQ0IDEtMSAxLTEtLjQ0LTEtMSAuNDQtMSAxLTFtMC0zYy0yLjczIDAtNS4wNiAxLjY2LTYgNCAuOTQgMi4zNCAzLjI3IDQgNiA0czUuMDYtMS42NiA2LTRjLS45NC0yLjM0LTMuMjctNC02LTRtMCA2LjVhMi41IDIuNSAwIDAgMS0yLjUtMi41IDIuNSAyLjUgMCAwIDEgMi41LTIuNSAyLjUgMi41IDAgMCAxIDIuNSAyLjUgMi41IDIuNSAwIDAgMS0yLjUgMi41TTkuMjcgMjBINlY0aDd2NWg1djQuMDdjLjcuMDggMS4zNi4yNSAyIC40OVY4bC02LTZINmEyIDIgMCAwIDAtMiAydjE2YTIgMiAwIDAgMCAyIDJoNC41YTguMiA4LjIgMCAwIDEtMS4yMy0yIiAvPjwvc3ZnPg==)](https://github.com/juanfont/headscale/raw/main/docs/ref/dns.md "View source of this page")

# DNS[¶](#dns "Permanent link")

Headscale supports [most DNS features](../../about/features/) from Tailscale. DNS related settings can be configured within the `dns` section of the [configuration file](../configuration/).

## Setting extra DNS records[¶](#setting-extra-dns-records "Permanent link")

Headscale allows to set extra DNS records which are made available via [MagicDNS](https://tailscale.com/kb/1081/magicdns). Extra DNS records can be configured either via static entries in the [configuration file](../configuration/) or from a JSON file that Headscale continuously watches for changes:

- Use the `dns.extra_records` option in the [configuration file](../configuration/) for entries that are static and don\'t change while Headscale is running. Those entries are processed when Headscale is starting up and changes to the configuration require a restart of Headscale.
- For dynamic DNS records that may be added, updated or removed while Headscale is running or DNS records that are generated by scripts the option `dns.extra_records_path` in the [configuration file](../configuration/) is useful. Set it to the absolute path of the JSON file containing DNS records and Headscale processes this file as it detects changes.

An example use case is to serve multiple apps on the same host via a reverse proxy like NGINX, in this case a Prometheus monitoring stack. This allows to nicely access the service with \"<http://grafana.myvpn.example.com>\" instead of the hostname and port combination \"<http://hostname-in-magic-dns.myvpn.example.com:3000>\".

Limitations

Currently, [only A and AAAA records are processed by Tailscale](https://github.com/tailscale/tailscale/blob/v1.86.5/ipn/ipnlocal/node_backend.go#L662).

1.  Configure extra DNS records using one of the available configuration options:

    :::::::::: 
    ::: tabbed-labels
    Static entries, via `dns.extra_records`Dynamic entries, via `dns.extra_records_path`
    :::

    :::::::: tabbed-content
    :::: tabbed-block
    ::: 
    [config.yaml]
        dns:
          ...
          extra_records:
            - name: "grafana.myvpn.example.com"
              type: "A"
              value: "100.64.0.3"

            - name: "prometheus.myvpn.example.com"
              type: "A"
              value: "100.64.0.3"
          ...
    :::

    Restart your headscale instance.
    ::::

    ::::: tabbed-block
    ::: 
    [extra-records.json]
        [
          ,
          
        ]
    :::

    Headscale picks up changes to the above JSON file automatically.

    ::: 
    Good to know

    - The `dns.extra_records_path` option in the [configuration file](../configuration/) needs to reference the JSON file containing extra DNS records.
    - Be sure to \"sort keys\" and produce a stable output in case you generate the JSON file with a script. Headscale uses a checksum to detect changes to the file and a stable output avoids unnecessary processing.
    :::
    :::::
    ::::::::
    ::::::::::

2.  Verify that DNS records are properly set using the DNS querying tool of your choice:

    ::::::::: 
    ::: tabbed-labels
    Query with digQuery with drill
    :::

    ::::::: tabbed-content
    :::: tabbed-block
    ::: 
        dig +short grafana.myvpn.example.com
        100.64.0.3
    :::
    ::::

    :::: tabbed-block
    ::: 
        drill -Q grafana.myvpn.example.com
        100.64.0.3
    :::
    ::::
    :::::::
    :::::::::

3.  Optional: Setup the reverse proxy

    The motivating example here was to be able to access internal monitoring services on the same host without specifying a port, depicted as NGINX configuration snippet:

    ::: 
    [nginx.conf]
        server 

        }
    :::