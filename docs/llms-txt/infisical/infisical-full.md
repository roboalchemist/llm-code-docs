# Infisical Documentation

Source: https://infisical.com/docs/llms-full.txt

---

# Bootstrap Instance
Source: https://infisical.com/docs/api-reference/endpoints/admin/bootstrap-instance

POST /api/v1/admin/bootstrap

<Note>
  For guidance, check out the docs for [Programmatic
  Provisioning](/self-hosting/guides/automated-bootstrapping).
</Note>


# Attach
Source: https://infisical.com/docs/api-reference/endpoints/alicloud-auth/attach

POST /api/v1/auth/alicloud-auth/identities/{identityId}
Attach Alibaba Cloud Auth configuration onto machine identity



# Login
Source: https://infisical.com/docs/api-reference/endpoints/alicloud-auth/login

POST /api/v1/auth/alicloud-auth/login
Login with Alibaba Cloud Auth for machine identity



# Retrieve
Source: https://infisical.com/docs/api-reference/endpoints/alicloud-auth/retrieve

GET /api/v1/auth/alicloud-auth/identities/{identityId}
Retrieve Alibaba Cloud Auth configuration on machine identity



# Revoke
Source: https://infisical.com/docs/api-reference/endpoints/alicloud-auth/revoke

DELETE /api/v1/auth/alicloud-auth/identities/{identityId}
Delete Alibaba Cloud Auth configuration on machine identity



# Update
Source: https://infisical.com/docs/api-reference/endpoints/alicloud-auth/update

PATCH /api/v1/auth/alicloud-auth/identities/{identityId}
Update Alibaba Cloud Auth configuration on machine identity



# Available
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/1password/available

GET /api/v1/app-connections/1password/available
List the 1Password Connections the current user has permission to establish connections within this project.



# Create
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/1password/create

POST /api/v1/app-connections/1password
Create a 1Password Connection.

<Note>
  Check out the configuration docs for [1Password Connections](/integrations/app-connections/1password) to learn how to obtain the required credentials.
</Note>


# Delete
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/1password/delete

DELETE /api/v1/app-connections/1password/{connectionId}
Delete the specified 1Password Connection.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/1password/get-by-id

GET /api/v1/app-connections/1password/{connectionId}
Get the specified 1Password Connection by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/1password/get-by-name

GET /api/v1/app-connections/1password/connection-name/{connectionName}
Get the specified 1Password Connection by name.



# List
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/1password/list

GET /api/v1/app-connections/1password
List the 1Password Connections for the current organization or project.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/1password/update

PATCH /api/v1/app-connections/1password/{connectionId}
Update the specified 1Password Connection.

<Note>
  Check out the configuration docs for [1Password Connections](/integrations/app-connections/1password) to learn how to obtain the required credentials.
</Note>


# Available
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/auth0/available

GET /api/v1/app-connections/auth0/available
List the Auth0 Connections the current user has permission to establish connections within this project.



# Create
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/auth0/create

POST /api/v1/app-connections/auth0
Create an Auth0 Connection.

<Note>
  Check out the configuration docs for [Auth0 Connections](/integrations/app-connections/auth0) to learn how to obtain the
  required credentials.
</Note>


# Delete
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/auth0/delete

DELETE /api/v1/app-connections/auth0/{connectionId}
Delete the specified Auth0 Connection.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/auth0/get-by-id

GET /api/v1/app-connections/auth0/{connectionId}
Get the specified Auth0 Connection by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/auth0/get-by-name

GET /api/v1/app-connections/auth0/connection-name/{connectionName}
Get the specified Auth0 Connection by name.



# List
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/auth0/list

GET /api/v1/app-connections/auth0
List the Auth0 Connections for the current organization or project.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/auth0/update

PATCH /api/v1/app-connections/auth0/{connectionId}
Update the specified Auth0 Connection.

<Note>
  Check out the configuration docs for [Auth0 Connections](/integrations/app-connections/auth0) to learn how to obtain the
  required credentials.
</Note>


# Available
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/aws/available

GET /api/v1/app-connections/aws/available
List the AWS Connections the current user has permission to establish connections within this project.



# Create
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/aws/create

POST /api/v1/app-connections/aws
Create an AWS Connection.

<Note>
  Check out the configuration docs for [AWS Connections](/integrations/app-connections/aws) to learn how to obtain
  the required credentials.
</Note>


# Delete
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/aws/delete

DELETE /api/v1/app-connections/aws/{connectionId}
Delete the specified AWS Connection.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/aws/get-by-id

GET /api/v1/app-connections/aws/{connectionId}
Get the specified AWS Connection by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/aws/get-by-name

GET /api/v1/app-connections/aws/connection-name/{connectionName}
Get the specified AWS Connection by name.



# List
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/aws/list

GET /api/v1/app-connections/aws
List the AWS Connections for the current organization or project.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/aws/update

PATCH /api/v1/app-connections/aws/{connectionId}
Update the specified AWS Connection.

<Note>
  Check out the configuration docs for [AWS Connections](/integrations/app-connections/aws) to learn how to obtain
  the required credentials.
</Note>


# Available
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/azure-adcs/available

GET /api/v1/app-connections/azure-adcs/available
List the Azure ADCS Connections the current user has permission to establish connections within this project.



# Create
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/azure-adcs/create

POST /api/v1/app-connections/azure-adcs
Create an Azure ADCS Connection.

<Note>
  Azure ADCS Connections must be created through the Infisical UI.
  Check out the configuration docs for [Azure ADCS Connections](/integrations/app-connections/azure-adcs) for a step-by-step
  guide.
</Note>


# Delete
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/azure-adcs/delete

DELETE /api/v1/app-connections/azure-adcs/{connectionId}
Delete the specified Azure ADCS Connection.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/azure-adcs/get-by-id

GET /api/v1/app-connections/azure-adcs/{connectionId}
Get the specified Azure ADCS Connection by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/azure-adcs/get-by-name

GET /api/v1/app-connections/azure-adcs/connection-name/{connectionName}
Get the specified Azure ADCS Connection by name.



# List
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/azure-adcs/list

GET /api/v1/app-connections/azure-adcs
List the Azure ADCS Connections for the current organization or project.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/azure-adcs/update

PATCH /api/v1/app-connections/azure-adcs/{connectionId}
Update the specified Azure ADCS Connection.

<Note>
  Azure ADCS Connections must be updated through the Infisical UI.
  Check out the configuration docs for [Azure ADCS Connections](/integrations/app-connections/azure-adcs) for a step-by-step
  guide.
</Note>


# Available
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/azure-app-configuration/available

GET /api/v1/app-connections/azure-app-configuration/available
List the Azure App Configuration Connections the current user has permission to establish connections within this project.



# Create
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/azure-app-configuration/create

POST /api/v1/app-connections/azure-app-configuration
Create an Azure App Configuration Connection.

<Note>
  Azure App Configuration Connections must be created through the Infisical UI.
  Check out the configuration docs for [Azure App Configuration Connections](/integrations/app-connections/azure-app-configuration) for a step-by-step
  guide.
</Note>


# Delete
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/azure-app-configuration/delete

DELETE /api/v1/app-connections/azure-app-configuration/{connectionId}
Delete the specified Azure App Configuration Connection.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/azure-app-configuration/get-by-id

GET /api/v1/app-connections/azure-app-configuration/{connectionId}
Get the specified Azure App Configuration Connection by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/azure-app-configuration/get-by-name

GET /api/v1/app-connections/azure-app-configuration/connection-name/{connectionName}
Get the specified Azure App Configuration Connection by name.



# List
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/azure-app-configuration/list

GET /api/v1/app-connections/azure-app-configuration
List the Azure App Configuration Connections for the current organization or project.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/azure-app-configuration/update

PATCH /api/v1/app-connections/azure-app-configuration/{connectionId}
Update the specified Azure App Configuration Connection.

<Note>
  Azure App Configuration Connections must be updated through the Infisical UI.
  Check out the configuration docs for [Azure App Configuration Connections](/integrations/app-connections/azure-app-configuration) for a step-by-step
  guide.
</Note>


# Available
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/azure-client-secret/available

GET /api/v1/app-connections/azure-client-secrets/available
List the Azure Client Secrets Connections the current user has permission to establish connections within this project.



# Create
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/azure-client-secret/create

POST /api/v1/app-connections/azure-client-secrets
Create an Azure Client Secrets Connection.

<Note>
  Azure Client Secret Connections must be created through the Infisical UI.
  Check out the configuration docs for [Azure Client Secret Connections](/integrations/app-connections/azure-client-secrets) for a step-by-step
  guide.
</Note>


# Delete
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/azure-client-secret/delete

DELETE /api/v1/app-connections/azure-client-secrets/{connectionId}
Delete the specified Azure Client Secrets Connection.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/azure-client-secret/get-by-id

GET /api/v1/app-connections/azure-client-secrets/{connectionId}
Get the specified Azure Client Secrets Connection by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/azure-client-secret/get-by-name

GET /api/v1/app-connections/azure-client-secrets/connection-name/{connectionName}
Get the specified Azure Client Secrets Connection by name.



# List
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/azure-client-secret/list

GET /api/v1/app-connections/azure-client-secrets
List the Azure Client Secrets Connections for the current organization or project.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/azure-client-secret/update

PATCH /api/v1/app-connections/azure-client-secrets/{connectionId}
Update the specified Azure Client Secrets Connection.

<Note>
  Azure Client Secret Connections must be updated through the Infisical UI.
  Check out the configuration docs for [Azure Client Secret Connections](/integrations/app-connections/azure-client-secrets) for a step-by-step
  guide.
</Note>


# Available
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/azure-devops/available

GET /api/v1/app-connections/azure-devops/available
List the Azure DevOps Connections the current user has permission to establish connections within this project.



# Create
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/azure-devops/create

POST /api/v1/app-connections/azure-devops
Create an Azure DevOps Connection.

<Note>
  Azure DevOps Connections must be created through the Infisical UI if you are using OAuth.
  Check out the configuration docs for [Azure DevOps Connections](/integrations/app-connections/azure-devops) for a step-by-step
  guide.
</Note>


# Delete
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/azure-devops/delete

DELETE /api/v1/app-connections/azure-devops/{connectionId}
Delete the specified Azure DevOps Connection.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/azure-devops/get-by-id

GET /api/v1/app-connections/azure-devops/{connectionId}
Get the specified Azure DevOps Connection by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/azure-devops/get-by-name

GET /api/v1/app-connections/azure-devops/connection-name/{connectionName}
Get the specified Azure DevOps Connection by name.



# List
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/azure-devops/list

GET /api/v1/app-connections/azure-devops
List the Azure DevOps Connections for the current organization or project.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/azure-devops/update

PATCH /api/v1/app-connections/azure-devops/{connectionId}
Update the specified Azure DevOps Connection.

<Note>
  Azure DevOps Connections must be updated through the Infisical UI if you are using OAuth.
  Check out the configuration docs for [Azure DevOps Connections](/integrations/app-connections/azure-devops) for a step-by-step
  guide.
</Note>


# Available
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/azure-key-vault/available

GET /api/v1/app-connections/azure-key-vault/available
List the Azure Key Vault Connections the current user has permission to establish connections within this project.



# Create
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/azure-key-vault/create

POST /api/v1/app-connections/azure-key-vault
Create an Azure Key Vault Connection.

<Note>
  Azure Key Vault Connections must be created through the Infisical UI.
  Check out the configuration docs for [Azure Key Vault Connections](/integrations/app-connections/azure-key-vault) for a step-by-step
  guide.
</Note>


# Delete
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/azure-key-vault/delete

DELETE /api/v1/app-connections/azure-key-vault/{connectionId}
Delete the specified Azure Key Vault Connection.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/azure-key-vault/get-by-id

GET /api/v1/app-connections/azure-key-vault/{connectionId}
Get the specified Azure Key Vault Connection by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/azure-key-vault/get-by-name

GET /api/v1/app-connections/azure-key-vault/connection-name/{connectionName}
Get the specified Azure Key Vault Connection by name.



# List
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/azure-key-vault/list

GET /api/v1/app-connections/azure-key-vault
List the Azure Key Vault Connections for the current organization or project.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/azure-key-vault/update

PATCH /api/v1/app-connections/azure-key-vault/{connectionId}
Update the specified Azure Key Vault Connection.

<Note>
  Azure Key Vault Connections must be updated through the Infisical UI.
  Check out the configuration docs for [Azure Key Vault Connections](/integrations/app-connections/azure-key-vault) for a step-by-step
  guide.
</Note>


# Available
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/bitbucket/available

GET /api/v1/app-connections/bitbucket/available
List the Bitbucket Connections the current user has permission to establish connections within this project.



# Create
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/bitbucket/create

POST /api/v1/app-connections/bitbucket
Create a Bitbucket Connection.

<Note>
  Check out the configuration docs for [Bitbucket Connections](/integrations/app-connections/bitbucket) to learn how to obtain the required credentials.
</Note>


# Delete
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/bitbucket/delete

DELETE /api/v1/app-connections/bitbucket/{connectionId}
Delete the specified Bitbucket Connection.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/bitbucket/get-by-id

GET /api/v1/app-connections/bitbucket/{connectionId}
Get the specified Bitbucket Connection by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/bitbucket/get-by-name

GET /api/v1/app-connections/bitbucket/connection-name/{connectionName}
Get the specified Bitbucket Connection by name.



# List
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/bitbucket/list

GET /api/v1/app-connections/bitbucket
List the Bitbucket Connections for the current organization or project.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/bitbucket/update

PATCH /api/v1/app-connections/bitbucket/{connectionId}
Update the specified Bitbucket Connection.

<Note>
  Check out the configuration docs for [Bitbucket Connections](/integrations/app-connections/bitbucket) to learn how to obtain the required credentials.
</Note>


# Available
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/camunda/available

GET /api/v1/app-connections/camunda/available
List the Camunda Connections the current user has permission to establish connections within this project.



# Create
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/camunda/create

POST /api/v1/app-connections/camunda
Create a Camunda Connection.



# Delete
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/camunda/delete

DELETE /api/v1/app-connections/camunda/{connectionId}
Delete the specified Camunda Connection.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/camunda/get-by-id

GET /api/v1/app-connections/camunda/{connectionId}
Get the specified Camunda Connection by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/camunda/get-by-name

GET /api/v1/app-connections/camunda/connection-name/{connectionName}
Get the specified Camunda Connection by name.



# List
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/camunda/list

GET /api/v1/app-connections/camunda
List the Camunda Connections for the current organization or project.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/camunda/update

PATCH /api/v1/app-connections/camunda/{connectionId}
Update the specified Camunda Connection.



# Create
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/checkly/create

POST /api/v1/app-connections/checkly
Create a Checkly Connection.

<Note>
  Check out the configuration docs for [Checkly Connections](/integrations/app-connections/checkly) to learn how to obtain the required credentials.
</Note>


# Delete
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/checkly/delete

DELETE /api/v1/app-connections/checkly/{connectionId}
Delete the specified Checkly Connection.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/checkly/get-by-id

GET /api/v1/app-connections/checkly/{connectionId}
Get the specified Checkly Connection by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/checkly/get-by-name

GET /api/v1/app-connections/checkly/connection-name/{connectionName}
Get the specified Checkly Connection by name.



# List
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/checkly/list

GET /api/v1/app-connections/checkly
List the Checkly Connections for the current organization or project.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/checkly/update

PATCH /api/v1/app-connections/checkly/{connectionId}
Update the specified Checkly Connection.

<Note>
  Check out the configuration docs for [Checkly Connections](/integrations/app-connections/checkly) to learn how to obtain the required credentials.
</Note>


# Available
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/chef/available

GET /api/v1/app-connections/chef/available
List the Chef Connections the current user has permission to establish connections within this project.



# Create
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/chef/create

POST /api/v1/app-connections/chef
Create a Chef Connection.

<Note>
  Check out the configuration docs for [Chef
  Connections](/integrations/app-connections/chef) to learn how to obtain the
  required credentials.
</Note>


# Delete
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/chef/delete

DELETE /api/v1/app-connections/chef/{connectionId}
Delete the specified Chef Connection.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/chef/get-by-id

GET /api/v1/app-connections/chef/{connectionId}
Get the specified Chef Connection by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/chef/get-by-name

GET /api/v1/app-connections/chef/connection-name/{connectionName}
Get the specified Chef Connection by name.



# List
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/chef/list

GET /api/v1/app-connections/chef
List the Chef Connections for the current organization or project.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/chef/update

PATCH /api/v1/app-connections/chef/{connectionId}
Update the specified Chef Connection.

<Note>
  Check out the configuration docs for [Chef
  Connections](/integrations/app-connections/chef) to learn how to obtain the
  required credentials.
</Note>


# Available
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/cloudflare/available

GET /api/v1/app-connections/cloudflare/available
List the Cloudflare Connections the current user has permission to establish connections within this project.



# Create
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/cloudflare/create

POST /api/v1/app-connections/cloudflare
Create a Cloudflare Connection.

<Note>
  Check out the configuration docs for [Cloudflare
  Connections](/integrations/app-connections/cloudflare) to learn how to obtain
  the required credentials.
</Note>


# Delete
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/cloudflare/delete

DELETE /api/v1/app-connections/cloudflare/{connectionId}
Delete the specified Cloudflare Connection.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/cloudflare/get-by-id

GET /api/v1/app-connections/cloudflare/{connectionId}
Get the specified Cloudflare Connection by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/cloudflare/get-by-name

GET /api/v1/app-connections/cloudflare/connection-name/{connectionName}
Get the specified Cloudflare Connection by name.



# List
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/cloudflare/list

GET /api/v1/app-connections/cloudflare
List the Cloudflare Connections for the current organization or project.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/cloudflare/update

PATCH /api/v1/app-connections/cloudflare/{connectionId}
Update the specified Cloudflare Connection.

<Note>
  Check out the configuration docs for [Cloudflare
  Connections](/integrations/app-connections/cloudflare) to learn how to obtain
  the required credentials.
</Note>


# Available
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/databricks/available

GET /api/v1/app-connections/databricks/available
List the Databricks Connections the current user has permission to establish connections within this project.



# Create
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/databricks/create

POST /api/v1/app-connections/databricks
Create a Databricks Connection.



# Delete
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/databricks/delete

DELETE /api/v1/app-connections/databricks/{connectionId}
Delete the specified Databricks Connection.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/databricks/get-by-id

GET /api/v1/app-connections/databricks/{connectionId}
Get the specified Databricks Connection by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/databricks/get-by-name

GET /api/v1/app-connections/databricks/connection-name/{connectionName}
Get the specified Databricks Connection by name.



# List
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/databricks/list

GET /api/v1/app-connections/databricks
List the Databricks Connections for the current organization or project.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/databricks/update

PATCH /api/v1/app-connections/databricks/{connectionId}
Update the specified Databricks Connection.



# Available
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/digital-ocean/available

GET /api/v1/app-connections/digital-ocean/available
List the DigitalOcean App Platform Connections the current user has permission to establish connections within this project.



# Create
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/digital-ocean/create

POST /api/v1/app-connections/digital-ocean
Create a DigitalOcean App Platform Connection.

<Note>
  Check out the configuration docs for [Digital Ocean Connections](/integrations/app-connections/digital-ocean) to learn how to obtain the required credentials.
</Note>


# Delete
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/digital-ocean/delete

DELETE /api/v1/app-connections/digital-ocean/{connectionId}
Delete the specified DigitalOcean App Platform Connection.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/digital-ocean/get-by-id

GET /api/v1/app-connections/digital-ocean/{connectionId}
Get the specified DigitalOcean App Platform Connection by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/digital-ocean/get-by-name

GET /api/v1/app-connections/digital-ocean/connection-name/{connectionName}
Get the specified DigitalOcean App Platform Connection by name.



# List
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/digital-ocean/list

GET /api/v1/app-connections/digital-ocean
List the DigitalOcean App Platform Connections for the current organization or project.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/digital-ocean/update

PATCH /api/v1/app-connections/digital-ocean/{connectionId}
Update the specified DigitalOcean App Platform Connection.

<Note>
  Check out the configuration docs for [Digital Ocean Connections](/integrations/app-connections/digital-ocean) to learn how to obtain the required credentials.
</Note>


# Available
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/flyio/available

GET /api/v1/app-connections/flyio/available
List the Fly.io Connections the current user has permission to establish connections within this project.



# Create
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/flyio/create

POST /api/v1/app-connections/flyio
Create a Fly.io Connection.

<Note>
  Check out the configuration docs for [Fly.io Connections](/integrations/app-connections/flyio) to learn how to obtain the required credentials.
</Note>


# Delete
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/flyio/delete

DELETE /api/v1/app-connections/flyio/{connectionId}
Delete the specified Fly.io Connection.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/flyio/get-by-id

GET /api/v1/app-connections/flyio/{connectionId}
Get the specified Fly.io Connection by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/flyio/get-by-name

GET /api/v1/app-connections/flyio/connection-name/{connectionName}
Get the specified Fly.io Connection by name.



# List
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/flyio/list

GET /api/v1/app-connections/flyio
List the Fly.io Connections for the current organization or project.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/flyio/update

PATCH /api/v1/app-connections/flyio/{connectionId}
Update the specified Fly.io Connection.

<Note>
  Check out the configuration docs for [Fly.io Connections](/integrations/app-connections/flyio) to learn how to obtain the required credentials.
</Note>


# Available
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/gcp/available

GET /api/v1/app-connections/gcp/available
List the GCP Connections the current user has permission to establish connections within this project.



# Create
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/gcp/create

POST /api/v1/app-connections/gcp
Create a GCP Connection.

<Note>
  Check out the configuration docs for [GCP
  Connections](/integrations/app-connections/gcp) to learn how to obtain the
  required credentials.
</Note>


# Delete
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/gcp/delete

DELETE /api/v1/app-connections/gcp/{connectionId}
Delete the specified GCP Connection.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/gcp/get-by-id

GET /api/v1/app-connections/gcp/{connectionId}
Get the specified GCP Connection by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/gcp/get-by-name

GET /api/v1/app-connections/gcp/connection-name/{connectionName}
Get the specified GCP Connection by name.



# List
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/gcp/list

GET /api/v1/app-connections/gcp
List the GCP Connections for the current organization or project.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/gcp/update

PATCH /api/v1/app-connections/gcp/{connectionId}
Update the specified GCP Connection.

<Note>
  Check out the configuration docs for [GCP
  Connections](/integrations/app-connections/gcp) to learn how to obtain the
  required credentials.
</Note>


# Available
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/github-radar/available

GET /api/v1/app-connections/github-radar/available
List the GitHub Radar Connections the current user has permission to establish connections within this project.



# Create
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/github-radar/create

POST /api/v1/app-connections/github-radar
Create a GitHub Radar Connection.

<Note>
  GitHub Radar Connections must be created through the Infisical UI.
  Check out the configuration docs for [GitHub Radar Connections](/integrations/app-connections/github-radar) for a step-by-step
  guide.
</Note>


# Delete
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/github-radar/delete

DELETE /api/v1/app-connections/github-radar/{connectionId}
Delete the specified GitHub Radar Connection.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/github-radar/get-by-id

GET /api/v1/app-connections/github-radar/{connectionId}
Get the specified GitHub Radar Connection by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/github-radar/get-by-name

GET /api/v1/app-connections/github-radar/connection-name/{connectionName}
Get the specified GitHub Radar Connection by name.



# List
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/github-radar/list

GET /api/v1/app-connections/github-radar
List the GitHub Radar Connections for the current organization or project.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/github-radar/update

PATCH /api/v1/app-connections/github-radar/{connectionId}
Update the specified GitHub Radar Connection.

<Note>
  GitHub Radar Connections must be updated through the Infisical UI.
  Check out the configuration docs for [GitHub Radar Connections](/integrations/app-connections/github-radar) for a step-by-step
  guide.
</Note>


# Available
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/github/available

GET /api/v1/app-connections/github/available
List the GitHub Connections the current user has permission to establish connections within this project.



# Create
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/github/create

POST /api/v1/app-connections/github
Create a GitHub Connection.

<Note>
  GitHub Connections must be created through the Infisical UI.
  Check out the configuration docs for [GitHub Connections](/integrations/app-connections/github) for a step-by-step
  guide.
</Note>


# Delete
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/github/delete

DELETE /api/v1/app-connections/github/{connectionId}
Delete the specified GitHub Connection.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/github/get-by-id

GET /api/v1/app-connections/github/{connectionId}
Get the specified GitHub Connection by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/github/get-by-name

GET /api/v1/app-connections/github/connection-name/{connectionName}
Get the specified GitHub Connection by name.



# List
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/github/list

GET /api/v1/app-connections/github
List the GitHub Connections for the current organization or project.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/github/update

PATCH /api/v1/app-connections/github/{connectionId}
Update the specified GitHub Connection.

<Note>
  GitHub Connections must be updated through the Infisical UI.
  Check out the configuration docs for [GitHub Connections](/integrations/app-connections/github) for a step-by-step
  guide.
</Note>


# Available
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/gitlab/available

GET /api/v1/app-connections/gitlab/available
List the GitLab Connections the current user has permission to establish connections within this project.



# Create
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/gitlab/create

POST /api/v1/app-connections/gitlab
Create a GitLab Connection.

<Note>
  Gitlab OAuth Connections must be created through the Infisical UI.
  Check out the configuration docs for [Gitlab OAuth Connections](/integrations/app-connections/gitlab) for a step-by-step
  guide.
</Note>


# Delete
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/gitlab/delete

DELETE /api/v1/app-connections/gitlab/{connectionId}
Delete the specified GitLab Connection.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/gitlab/get-by-id

GET /api/v1/app-connections/gitlab/{connectionId}
Get the specified GitLab Connection by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/gitlab/get-by-name

GET /api/v1/app-connections/gitlab/connection-name/{connectionName}
Get the specified GitLab Connection by name.



# List
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/gitlab/list

GET /api/v1/app-connections/gitlab
List the GitLab Connections for the current organization or project.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/gitlab/update

PATCH /api/v1/app-connections/gitlab/{connectionId}
Update the specified GitLab Connection.

<Note>
  Gitlab OAuth Connections must be updated through the Infisical UI.
  Check out the configuration docs for [Gitlab OAuth Connections](/integrations/app-connections/gitlab) for a step-by-step
  guide.
</Note>


# Available
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/hashicorp-vault/available

GET /api/v1/app-connections/hashicorp-vault/available
List the Hashicorp Vault Connections the current user has permission to establish connections within this project.



# Create
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/hashicorp-vault/create

POST /api/v1/app-connections/hashicorp-vault
Create a Hashicorp Vault Connection.

<Note>
  Check out the configuration docs for [Hashicorp Vault Connections](/integrations/app-connections/hashicorp-vault) to learn how to obtain the required credentials.
</Note>


# Delete
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/hashicorp-vault/delete

DELETE /api/v1/app-connections/hashicorp-vault/{connectionId}
Delete the specified Hashicorp Vault Connection.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/hashicorp-vault/get-by-id

GET /api/v1/app-connections/hashicorp-vault/{connectionId}
Get the specified Hashicorp Vault Connection by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/hashicorp-vault/get-by-name

GET /api/v1/app-connections/hashicorp-vault/connection-name/{connectionName}
Get the specified Hashicorp Vault Connection by name.



# List
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/hashicorp-vault/list

GET /api/v1/app-connections/hashicorp-vault
List the Hashicorp Vault Connections for the current organization or project.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/hashicorp-vault/update

PATCH /api/v1/app-connections/hashicorp-vault/{connectionId}
Update the specified Hashicorp Vault Connection.

<Note>
  Check out the configuration docs for [Hashicorp Vault Connections](/integrations/app-connections/hashicorp-vault) to learn how to obtain the required credentials.
</Note>


# Available
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/heroku/available

GET /api/v1/app-connections/heroku/available
List the Heroku Connections the current user has permission to establish connections within this project.



# Create
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/heroku/create

POST /api/v1/app-connections/heroku
Create a Heroku Connection.

<Note>
  Heroku OAuth Connections must be created through the Infisical UI.
  Check out the configuration docs for [Heroku OAuth Connections](/integrations/app-connections/heroku) for a step-by-step
  guide.
</Note>


# Delete
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/heroku/delete

DELETE /api/v1/app-connections/heroku/{connectionId}
Delete the specified Heroku Connection.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/heroku/get-by-id

GET /api/v1/app-connections/heroku/{connectionId}
Get the specified Heroku Connection by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/heroku/get-by-name

GET /api/v1/app-connections/heroku/connection-name/{connectionName}
Get the specified Heroku Connection by name.



# List
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/heroku/list

GET /api/v1/app-connections/heroku
List the Heroku Connections for the current organization or project.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/heroku/update

PATCH /api/v1/app-connections/heroku/{connectionId}
Update the specified Heroku Connection.

<Note>
  Heroku OAuth Connections must be updated through the Infisical UI.
  Check out the configuration docs for [Heroku OAuth Connections](/integrations/app-connections/heroku) for a step-by-step
  guide.
</Note>


# Available
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/humanitec/available

GET /api/v1/app-connections/humanitec/available
List the Humanitec Connections the current user has permission to establish connections within this project.



# Create
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/humanitec/create

POST /api/v1/app-connections/humanitec
Create a Humanitec Connection.



# Delete
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/humanitec/delete

DELETE /api/v1/app-connections/humanitec/{connectionId}
Delete the specified Humanitec Connection.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/humanitec/get-by-id

GET /api/v1/app-connections/humanitec/{connectionId}
Get the specified Humanitec Connection by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/humanitec/get-by-name

GET /api/v1/app-connections/humanitec/connection-name/{connectionName}
Get the specified Humanitec Connection by name.



# List
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/humanitec/list

GET /api/v1/app-connections/humanitec
List the Humanitec Connections for the current organization or project.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/humanitec/update

PATCH /api/v1/app-connections/humanitec/{connectionId}
Update the specified Humanitec Connection.



# Available
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/laravel-forge/available

GET /api/v1/app-connections/laravel-forge/available
List the Laravel Forge Connections the current user has permission to establish connections within this project.



# Create
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/laravel-forge/create

POST /api/v1/app-connections/laravel-forge
Create a Laravel Forge Connection.

<Note>
  Check out the configuration docs for [Laravel Forge
  Connections](/integrations/app-connections/laravel-forge) to learn how to
  obtain the required credentials.
</Note>


# Delete
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/laravel-forge/delete

DELETE /api/v1/app-connections/laravel-forge/{connectionId}
Delete the specified Laravel Forge Connection.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/laravel-forge/get-by-id

GET /api/v1/app-connections/laravel-forge/{connectionId}
Get the specified Laravel Forge Connection by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/laravel-forge/get-by-name

GET /api/v1/app-connections/laravel-forge/connection-name/{connectionName}
Get the specified Laravel Forge Connection by name.



# List
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/laravel-forge/list

GET /api/v1/app-connections/laravel-forge
List the Laravel Forge Connections for the current organization or project.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/laravel-forge/update

PATCH /api/v1/app-connections/laravel-forge/{connectionId}
Update the specified Laravel Forge Connection.

<Note>
  Check out the configuration docs for [Laravel Forge
  Connections](/integrations/app-connections/laravel-forge) to learn how to
  obtain the required credentials.
</Note>


# Available
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/ldap/available

GET /api/v1/app-connections/ldap/available
List the LDAP Connections the current user has permission to establish connections within this project.



# Create
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/ldap/create

POST /api/v1/app-connections/ldap
Create a LDAP Connection.

<Note>
  Check out the configuration docs for [LDAP Connections](/integrations/app-connections/ldap) to learn how to obtain
  the required credentials.
</Note>


# Delete
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/ldap/delete

DELETE /api/v1/app-connections/ldap/{connectionId}
Delete the specified LDAP Connection.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/ldap/get-by-id

GET /api/v1/app-connections/ldap/{connectionId}
Get the specified LDAP Connection by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/ldap/get-by-name

GET /api/v1/app-connections/ldap/connection-name/{connectionName}
Get the specified LDAP Connection by name.



# List
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/ldap/list

GET /api/v1/app-connections/ldap
List the LDAP Connections for the current organization or project.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/ldap/update

PATCH /api/v1/app-connections/ldap/{connectionId}
Update the specified LDAP Connection.

<Note>
  Check out the configuration docs for [LDAP Connections](/integrations/app-connections/ldap) to learn how to obtain
  the required credentials.
</Note>


# List
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/list

GET /api/v1/app-connections
List all the App Connections for the current organization or project.



# Available
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/mssql/available

GET /api/v1/app-connections/mssql/available
List the Microsoft SQL Server Connections the current user has permission to establish connections within this project.



# Create
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/mssql/create

POST /api/v1/app-connections/mssql
Create a Microsoft SQL Server Connection.

<Note>
  Check out the configuration docs for [Microsoft SQL Server
  Connections](/integrations/app-connections/mssql) to learn how to obtain the
  required credentials.
</Note>


# Delete
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/mssql/delete

DELETE /api/v1/app-connections/mssql/{connectionId}
Delete the specified Microsoft SQL Server Connection.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/mssql/get-by-id

GET /api/v1/app-connections/mssql/{connectionId}
Get the specified Microsoft SQL Server Connection by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/mssql/get-by-name

GET /api/v1/app-connections/mssql/connection-name/{connectionName}
Get the specified Microsoft SQL Server Connection by name.



# List
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/mssql/list

GET /api/v1/app-connections/mssql
List the Microsoft SQL Server Connections for the current organization or project.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/mssql/update

PATCH /api/v1/app-connections/mssql/{connectionId}
Update the specified Microsoft SQL Server Connection.

<Note>
  Check out the configuration docs for [Microsoft SQL Server
  Connections](/integrations/app-connections/mssql) to learn how to obtain the
  required credentials.
</Note>


# Available
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/mysql/available

GET /api/v1/app-connections/mysql/available
List the MySQL Connections the current user has permission to establish connections within this project.



# Create
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/mysql/create

POST /api/v1/app-connections/mysql
Create a MySQL Connection.

<Note>
  Check out the configuration docs for [MySQL Connections](/integrations/app-connections/mysql) to learn how to obtain the required credentials.
</Note>


# Delete
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/mysql/delete

DELETE /api/v1/app-connections/mysql/{connectionId}
Delete the specified MySQL Connection.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/mysql/get-by-id

GET /api/v1/app-connections/mysql/{connectionId}
Get the specified MySQL Connection by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/mysql/get-by-name

GET /api/v1/app-connections/mysql/connection-name/{connectionName}
Get the specified MySQL Connection by name.



# List
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/mysql/list

GET /api/v1/app-connections/mysql
List the MySQL Connections for the current organization or project.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/mysql/update

PATCH /api/v1/app-connections/mysql/{connectionId}
Update the specified MySQL Connection.

<Note>
  Check out the configuration docs for [MySQL Connections](/integrations/app-connections/mysql) to learn how to obtain the required credentials.
</Note>


# Available
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/netlify/available

GET /api/v1/app-connections/netlify/available
List the Netlify Connections the current user has permission to establish connections within this project.



# Create
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/netlify/create

POST /api/v1/app-connections/netlify
Create a Netlify Connection.

<Note>
  Check out the configuration docs for [Netlify Connections](/integrations/app-connections/netlify) to learn how to obtain the required credentials.
</Note>


# Delete
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/netlify/delete

DELETE /api/v1/app-connections/netlify/{connectionId}
Delete the specified Netlify Connection.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/netlify/get-by-id

GET /api/v1/app-connections/netlify/{connectionId}
Get the specified Netlify Connection by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/netlify/get-by-name

GET /api/v1/app-connections/netlify/connection-name/{connectionName}
Get the specified Netlify Connection by name.



# List
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/netlify/list

GET /api/v1/app-connections/netlify
List the Netlify Connections for the current organization or project.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/netlify/update

PATCH /api/v1/app-connections/netlify/{connectionId}
Update the specified Netlify Connection.

<Note>
  Check out the configuration docs for [Netlify Connections](/integrations/app-connections/netlify) to learn how to obtain the required credentials.
</Note>


# Available
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/northflank/available

GET /api/v1/app-connections/northflank/available
List the Northflank Connections the current user has permission to establish connections within this project.



# Create
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/northflank/create

POST /api/v1/app-connections/northflank
Create a Northflank Connection.

<Note>
  Check out the configuration docs for [Northflank Connections](/integrations/app-connections/northflank) to learn how to obtain the required credentials.
</Note>


# Delete
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/northflank/delete

DELETE /api/v1/app-connections/northflank/{connectionId}
Delete the specified Northflank Connection.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/northflank/get-by-id

GET /api/v1/app-connections/northflank/{connectionId}
Get the specified Northflank Connection by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/northflank/get-by-name

GET /api/v1/app-connections/northflank/connection-name/{connectionName}
Get the specified Northflank Connection by name.



# List
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/northflank/list

GET /api/v1/app-connections/northflank
List the Northflank Connections for the current organization or project.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/northflank/update

PATCH /api/v1/app-connections/northflank/{connectionId}
Update the specified Northflank Connection.



# Available
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/oci/available

GET /api/v1/app-connections/oci/available
List the OCI Connections the current user has permission to establish connections within this project.



# Create
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/oci/create

POST /api/v1/app-connections/oci
Create an OCI Connection.

<Note>
  Check out the configuration docs for [OCI Connections](/integrations/app-connections/oci) to learn how to obtain the required credentials.
</Note>


# Delete
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/oci/delete

DELETE /api/v1/app-connections/oci/{connectionId}
Delete the specified OCI Connection.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/oci/get-by-id

GET /api/v1/app-connections/oci/{connectionId}
Get the specified OCI Connection by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/oci/get-by-name

GET /api/v1/app-connections/oci/connection-name/{connectionName}
Get the specified OCI Connection by name.



# List
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/oci/list

GET /api/v1/app-connections/oci
List the OCI Connections for the current organization or project.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/oci/update

PATCH /api/v1/app-connections/oci/{connectionId}
Update the specified OCI Connection.

<Note>
  Check out the configuration docs for [OCI Connections](/integrations/app-connections/oci) to learn how to obtain the required credentials.
</Note>


# Available
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/okta/available

GET /api/v1/app-connections/okta/available
List the Okta Connections the current user has permission to establish connections within this project.



# Create
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/okta/create

POST /api/v1/app-connections/okta
Create an Okta Connection.

<Note>
  Check out the configuration docs for [Okta Connections](/integrations/app-connections/okta) to learn how to obtain the required credentials.
</Note>


# Delete
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/okta/delete

DELETE /api/v1/app-connections/okta/{connectionId}
Delete the specified Okta Connection.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/okta/get-by-id

GET /api/v1/app-connections/okta/{connectionId}
Get the specified Okta Connection by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/okta/get-by-name

GET /api/v1/app-connections/okta/connection-name/{connectionName}
Get the specified Okta Connection by name.



# List
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/okta/list

GET /api/v1/app-connections/okta
List the Okta Connections for the current organization or project.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/okta/update

PATCH /api/v1/app-connections/okta/{connectionId}
Update the specified Okta Connection.

<Note>
  Check out the configuration docs for [Okta Connections](/integrations/app-connections/okta) to learn how to obtain the required credentials.
</Note>


# Options
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/options

GET /api/v1/app-connections/options
List the available App Connection Options.



# Available
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/oracledb/available

GET /api/v1/app-connections/oracledb/available
List the OracleDB Connections the current user has permission to establish connections within this project.



# Create
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/oracledb/create

POST /api/v1/app-connections/oracledb
Create an OracleDB Connection.

<Note>
  Check out the configuration docs for [OracleDB Connections](/integrations/app-connections/oracledb) to learn how to obtain the required credentials.
</Note>


# Delete
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/oracledb/delete

DELETE /api/v1/app-connections/oracledb/{connectionId}
Delete the specified OracleDB Connection.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/oracledb/get-by-id

GET /api/v1/app-connections/oracledb/{connectionId}
Get the specified OracleDB Connection by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/oracledb/get-by-name

GET /api/v1/app-connections/oracledb/connection-name/{connectionName}
Get the specified OracleDB Connection by name.



# List
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/oracledb/list

GET /api/v1/app-connections/oracledb
List the OracleDB Connections for the current organization or project.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/oracledb/update

PATCH /api/v1/app-connections/oracledb/{connectionId}
Update the specified OracleDB Connection.

<Note>
  Check out the configuration docs for [OracleDB Connections](/integrations/app-connections/oracledb) to learn how to obtain the required credentials.
</Note>


# Available
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/postgres/available

GET /api/v1/app-connections/postgres/available
List the PostgreSQL Connections the current user has permission to establish connections within this project.



# Create
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/postgres/create

POST /api/v1/app-connections/postgres
Create a PostgreSQL Connection.

<Note>
  Check out the configuration docs for [PostgreSQL
  Connections](/integrations/app-connections/postgres) to learn how to obtain the
  required credentials.
</Note>


# Delete
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/postgres/delete

DELETE /api/v1/app-connections/postgres/{connectionId}
Delete the specified PostgreSQL Connection.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/postgres/get-by-id

GET /api/v1/app-connections/postgres/{connectionId}
Get the specified PostgreSQL Connection by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/postgres/get-by-name

GET /api/v1/app-connections/postgres/connection-name/{connectionName}
Get the specified PostgreSQL Connection by name.



# List
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/postgres/list

GET /api/v1/app-connections/postgres
List the PostgreSQL Connections for the current organization or project.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/postgres/update

PATCH /api/v1/app-connections/postgres/{connectionId}
Update the specified PostgreSQL Connection.

<Note>
  Check out the configuration docs for [PostgreSQL
  Connections](/integrations/app-connections/postgres) to learn how to obtain the
  required credentials.
</Note>


# Available
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/railway/available

GET /api/v1/app-connections/railway/available
List the Railway Connections the current user has permission to establish connections within this project.



# Create
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/railway/create

POST /api/v1/app-connections/railway
Create a Railway Connection.

<Note>
  Check out the configuration docs for [Railway Connections](/integrations/app-connections/railway) to learn how to obtain the required credentials.
</Note>


# Delete
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/railway/delete

DELETE /api/v1/app-connections/railway/{connectionId}
Delete the specified Railway Connection.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/railway/get-by-id

GET /api/v1/app-connections/railway/{connectionId}
Get the specified Railway Connection by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/railway/get-by-name

GET /api/v1/app-connections/railway/connection-name/{connectionName}
Get the specified Railway Connection by name.



# List
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/railway/list

GET /api/v1/app-connections/railway
List the Railway Connections for the current organization or project.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/railway/update

PATCH /api/v1/app-connections/railway/{connectionId}
Update the specified Railway Connection.

<Note>
  Check out the configuration docs for [Railway Connections](/integrations/app-connections/railway) to learn how to obtain the required credentials.
</Note>


# Available
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/redis/available

GET /api/v1/app-connections/redis/available
List the Redis Connections the current user has permission to establish connections within this project.



# Create
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/redis/create

POST /api/v1/app-connections/redis
Create a Redis Connection.

<Note>
  Check out the configuration docs for [Redis Connections](/integrations/app-connections/redis) to learn how to obtain
  the required credentials.
</Note>


# Delete
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/redis/delete

DELETE /api/v1/app-connections/redis/{connectionId}
Delete the specified Redis Connection.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/redis/get-by-id

GET /api/v1/app-connections/redis/{connectionId}
Get the specified Redis Connection by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/redis/get-by-name

GET /api/v1/app-connections/redis/connection-name/{connectionName}
Get the specified Redis Connection by name.



# List
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/redis/list

GET /api/v1/app-connections/redis
List the Redis Connections for the current organization or project.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/redis/update

PATCH /api/v1/app-connections/redis/{connectionId}
Update the specified Redis Connection.

<Note>
  Check out the configuration docs for [Redis Connections](/integrations/app-connections/redis) to learn how to obtain
  the required credentials.
</Note>


# Available
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/render/available

GET /api/v1/app-connections/render/available
List the Render Connections the current user has permission to establish connections within this project.



# Create
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/render/create

POST /api/v1/app-connections/render
Create a Render Connection.

<Note>
  Check out the configuration docs for [Render
  Connections](/integrations/app-connections/render) to learn how to obtain the
  required credentials.
</Note>


# Delete
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/render/delete

DELETE /api/v1/app-connections/render/{connectionId}
Delete the specified Render Connection.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/render/get-by-id

GET /api/v1/app-connections/render/{connectionId}
Get the specified Render Connection by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/render/get-by-name

GET /api/v1/app-connections/render/connection-name/{connectionName}
Get the specified Render Connection by name.



# List
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/render/list

GET /api/v1/app-connections/render
List the Render Connections for the current organization or project.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/render/update

PATCH /api/v1/app-connections/render/{connectionId}
Update the specified Render Connection.

<Note>
  Check out the configuration docs for [Render
  Connections](/integrations/app-connections/render) to learn how to obtain the
  required credentials.
</Note>


# Available
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/supabase/available

GET /api/v1/app-connections/supabase/available
List the Supabase Connections the current user has permission to establish connections within this project.



# Create
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/supabase/create

POST /api/v1/app-connections/supabase
Create a Supabase Connection.

<Note>
  Check out the configuration docs for [Supabase Connections](/integrations/app-connections/supabase) to learn how to obtain the required credentials.
</Note>


# Delete
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/supabase/delete

DELETE /api/v1/app-connections/supabase/{connectionId}
Delete the specified Supabase Connection.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/supabase/get-by-id

GET /api/v1/app-connections/supabase/{connectionId}
Get the specified Supabase Connection by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/supabase/get-by-name

GET /api/v1/app-connections/supabase/connection-name/{connectionName}
Get the specified Supabase Connection by name.



# List
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/supabase/list

GET /api/v1/app-connections/supabase
List the Supabase Connections for the current organization or project.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/supabase/update

PATCH /api/v1/app-connections/supabase/{connectionId}
Update the specified Supabase Connection.

<Note>
  Check out the configuration docs for [Supabase Connections](/integrations/app-connections/supabase) to learn how to obtain the required credentials.
</Note>


# Available
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/teamcity/available

GET /api/v1/app-connections/teamcity/available
List the TeamCity Connections the current user has permission to establish connections within this project.



# Create
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/teamcity/create

POST /api/v1/app-connections/teamcity
Create a TeamCity Connection.

<Note>
  Check out the configuration docs for [TeamCity Connections](/integrations/app-connections/teamcity) to learn how to obtain
  the required credentials.
</Note>


# Delete
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/teamcity/delete

DELETE /api/v1/app-connections/teamcity/{connectionId}
Delete the specified TeamCity Connection.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/teamcity/get-by-id

GET /api/v1/app-connections/teamcity/{connectionId}
Get the specified TeamCity Connection by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/teamcity/get-by-name

GET /api/v1/app-connections/teamcity/connection-name/{connectionName}
Get the specified TeamCity Connection by name.



# List
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/teamcity/list

GET /api/v1/app-connections/teamcity
List the TeamCity Connections for the current organization or project.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/teamcity/update

PATCH /api/v1/app-connections/teamcity/{connectionId}
Update the specified TeamCity Connection.

<Note>
  Check out the configuration docs for [TeamCity Connections](/integrations/app-connections/teamcity) to learn how to obtain
  the required credentials.
</Note>


# Available
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/terraform-cloud/available

GET /api/v1/app-connections/terraform-cloud/available
List the Terraform Cloud Connections the current user has permission to establish connections within this project.



# Create
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/terraform-cloud/create

POST /api/v1/app-connections/terraform-cloud
Create a Terraform Cloud Connection.

<Note>
  Check out the configuration docs for [Terraform Cloud Connections](/integrations/app-connections/terraform-cloud) to learn how to obtain
  the required credentials.
</Note>


# Delete
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/terraform-cloud/delete

DELETE /api/v1/app-connections/terraform-cloud/{connectionId}
Delete the specified Terraform Cloud Connection.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/terraform-cloud/get-by-id

GET /api/v1/app-connections/terraform-cloud/{connectionId}
Get the specified Terraform Cloud Connection by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/terraform-cloud/get-by-name

GET /api/v1/app-connections/terraform-cloud/connection-name/{connectionName}
Get the specified Terraform Cloud Connection by name.



# List
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/terraform-cloud/list

GET /api/v1/app-connections/terraform-cloud
List the Terraform Cloud Connections for the current organization or project.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/terraform-cloud/update

PATCH /api/v1/app-connections/terraform-cloud/{connectionId}
Update the specified Terraform Cloud Connection.

<Note>
  Check out the configuration docs for [Terraform Cloud Connections](/integrations/app-connections/terraform-cloud) to learn how to obtain
  the required credentials.
</Note>


# Available
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/vercel/available

GET /api/v1/app-connections/vercel/available
List the Vercel Connections the current user has permission to establish connections within this project.



# Create
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/vercel/create

POST /api/v1/app-connections/vercel
Create a Vercel Connection.

<Note>
  Check out the configuration docs for [Vercel Connections](/integrations/app-connections/vercel) to learn how to obtain
  the required credentials.
</Note>


# Delete
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/vercel/delete

DELETE /api/v1/app-connections/vercel/{connectionId}
Delete the specified Vercel Connection.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/vercel/get-by-id

GET /api/v1/app-connections/vercel/{connectionId}
Get the specified Vercel Connection by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/vercel/get-by-name

GET /api/v1/app-connections/vercel/connection-name/{connectionName}
Get the specified Vercel Connection by name.



# List
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/vercel/list

GET /api/v1/app-connections/vercel
List the Vercel Connections for the current organization or project.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/vercel/update

PATCH /api/v1/app-connections/vercel/{connectionId}
Update the specified Vercel Connection.

<Note>
  Check out the configuration docs for [Vercel Connections](/integrations/app-connections/vercel) to learn how to obtain
  the required credentials.
</Note>


# Available
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/windmill/available

GET /api/v1/app-connections/windmill/available
List the Windmill Connections the current user has permission to establish connections within this project.



# Create
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/windmill/create

POST /api/v1/app-connections/windmill
Create a Windmill Connection.

<Note>
  Check out the configuration docs for [Windmill Connections](/integrations/app-connections/windmill) to learn how to obtain
  the required credentials.
</Note>


# Delete
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/windmill/delete

DELETE /api/v1/app-connections/windmill/{connectionId}
Delete the specified Windmill Connection.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/windmill/get-by-id

GET /api/v1/app-connections/windmill/{connectionId}
Get the specified Windmill Connection by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/windmill/get-by-name

GET /api/v1/app-connections/windmill/connection-name/{connectionName}
Get the specified Windmill Connection by name.



# List
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/windmill/list

GET /api/v1/app-connections/windmill
List the Windmill Connections for the current organization or project.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/windmill/update

PATCH /api/v1/app-connections/windmill/{connectionId}
Update the specified Windmill Connection.

<Note>
  Check out the configuration docs for [Windmill Connections](/integrations/app-connections/windmill) to learn how to obtain
  the required credentials.
</Note>


# Available
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/zabbix/available

GET /api/v1/app-connections/zabbix/available
List the Zabbix Connections the current user has permission to establish connections within this project.



# Create
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/zabbix/create

POST /api/v1/app-connections/zabbix
Create a Zabbix Connection.

<Note>
  Check out the configuration docs for [Zabbix Connections](/integrations/app-connections/zabbix) to learn how to obtain the required credentials.
</Note>


# Delete
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/zabbix/delete

DELETE /api/v1/app-connections/zabbix/{connectionId}
Delete the specified Zabbix Connection.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/zabbix/get-by-id

GET /api/v1/app-connections/zabbix/{connectionId}
Get the specified Zabbix Connection by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/zabbix/get-by-name

GET /api/v1/app-connections/zabbix/connection-name/{connectionName}
Get the specified Zabbix Connection by name.



# List
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/zabbix/list

GET /api/v1/app-connections/zabbix
List the Zabbix Connections for the current organization or project.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/app-connections/zabbix/update

PATCH /api/v1/app-connections/zabbix/{connectionId}
Update the specified Zabbix Connection.

<Note>
  Check out the configuration docs for [Zabbix Connections](/integrations/app-connections/zabbix) to learn how to obtain the required credentials.
</Note>


# Export
Source: https://infisical.com/docs/api-reference/endpoints/audit-logs/export-audit-log

GET /api/v1/organization/audit-logs
Get all audit logs for an organization



# Attach
Source: https://infisical.com/docs/api-reference/endpoints/aws-auth/attach

POST /api/v1/auth/aws-auth/identities/{identityId}
Attach AWS Auth configuration onto machine identity



# Login
Source: https://infisical.com/docs/api-reference/endpoints/aws-auth/login

POST /api/v1/auth/aws-auth/login
Login with AWS Auth for machine identity



# Retrieve
Source: https://infisical.com/docs/api-reference/endpoints/aws-auth/retrieve

GET /api/v1/auth/aws-auth/identities/{identityId}
Retrieve AWS Auth configuration on machine identity



# Revoke
Source: https://infisical.com/docs/api-reference/endpoints/aws-auth/revoke

DELETE /api/v1/auth/aws-auth/identities/{identityId}
Delete AWS Auth configuration on machine identity



# Update
Source: https://infisical.com/docs/api-reference/endpoints/aws-auth/update

PATCH /api/v1/auth/aws-auth/identities/{identityId}
Update AWS Auth configuration on machine identity



# Attach
Source: https://infisical.com/docs/api-reference/endpoints/azure-auth/attach

POST /api/v1/auth/azure-auth/identities/{identityId}
Attach Azure Auth configuration onto machine identity



# Login
Source: https://infisical.com/docs/api-reference/endpoints/azure-auth/login

POST /api/v1/auth/azure-auth/login
Login with Azure Auth for machine identity



# Retrieve
Source: https://infisical.com/docs/api-reference/endpoints/azure-auth/retrieve

GET /api/v1/auth/azure-auth/identities/{identityId}
Retrieve Azure Auth configuration on machine identity



# Revoke
Source: https://infisical.com/docs/api-reference/endpoints/azure-auth/revoke

DELETE /api/v1/auth/azure-auth/identities/{identityId}
Delete Azure Auth configuration on machine identity



# Update
Source: https://infisical.com/docs/api-reference/endpoints/azure-auth/update

PATCH /api/v1/auth/azure-auth/identities/{identityId}
Update Azure Auth configuration on machine identity



# Create
Source: https://infisical.com/docs/api-reference/endpoints/certificate-authorities/acme/create

POST /api/v1/pki/ca/acme



# Delete
Source: https://infisical.com/docs/api-reference/endpoints/certificate-authorities/acme/delete

DELETE /api/v1/pki/ca/acme/{caName}



# List
Source: https://infisical.com/docs/api-reference/endpoints/certificate-authorities/acme/list

GET /api/v1/pki/ca/acme



# Read
Source: https://infisical.com/docs/api-reference/endpoints/certificate-authorities/acme/read

GET /api/v1/pki/ca/acme/{caName}



# Update
Source: https://infisical.com/docs/api-reference/endpoints/certificate-authorities/acme/update

PATCH /api/v1/pki/ca/acme/{caName}



# Retrieve certificate / chain
Source: https://infisical.com/docs/api-reference/endpoints/certificate-authorities/cert

GET /api/v1/pki/ca/{caId}/certificate
Get current CA cert and cert chain of a CA



# Create (Deprecated)
Source: https://infisical.com/docs/api-reference/endpoints/certificate-authorities/create

POST /api/v1/pki/ca
Create CA

<Note>
  This endpoint is deprecated. Please use the internal CA endpoint [here](/api-reference/endpoints/certificate-authorities/internal/create).
</Note>


# List CRLs
Source: https://infisical.com/docs/api-reference/endpoints/certificate-authorities/crl

GET /api/v1/pki/ca/{caId}/crls
Get list of CRLs of the CA



# Get CSR
Source: https://infisical.com/docs/api-reference/endpoints/certificate-authorities/csr

GET /api/v1/pki/ca/{caId}/csr
Get CA CSR



# Delete (Deprecated)
Source: https://infisical.com/docs/api-reference/endpoints/certificate-authorities/delete

DELETE /api/v1/pki/ca/{caId}
Delete CA

<Note>
  This endpoint is deprecated. Please use the internal CA endpoint [here](/api-reference/endpoints/certificate-authorities/internal/delete).
</Note>


# Import certificate
Source: https://infisical.com/docs/api-reference/endpoints/certificate-authorities/import-cert

POST /api/v1/pki/ca/{caId}/import-certificate
Import certificate and chain to CA



# Create
Source: https://infisical.com/docs/api-reference/endpoints/certificate-authorities/internal/create

POST /api/v1/pki/ca/internal



# Delete
Source: https://infisical.com/docs/api-reference/endpoints/certificate-authorities/internal/delete

DELETE /api/v1/pki/ca/internal/{caName}



# List
Source: https://infisical.com/docs/api-reference/endpoints/certificate-authorities/internal/list

GET /api/v1/pki/ca/internal



# Read
Source: https://infisical.com/docs/api-reference/endpoints/certificate-authorities/internal/read

GET /api/v1/pki/ca/internal/{caName}



# Update
Source: https://infisical.com/docs/api-reference/endpoints/certificate-authorities/internal/update

PATCH /api/v1/pki/ca/internal/{caName}



# List (Deprecated)
Source: https://infisical.com/docs/api-reference/endpoints/certificate-authorities/list

GET /api/v2/workspace/{slug}/cas

<Note>
  This endpoint is deprecated. Please use the internal CA endpoint [here](/api-reference/endpoints/certificate-authorities/internal/list).
</Note>


# List CA certificates
Source: https://infisical.com/docs/api-reference/endpoints/certificate-authorities/list-ca-certs

GET /api/v1/pki/ca/{caId}/ca-certificates
Get list of past and current CA certificates for a CA



# Retrieve (Deprecated)
Source: https://infisical.com/docs/api-reference/endpoints/certificate-authorities/read

GET /api/v1/pki/ca/{caId}
Get CA

<Note>
  This endpoint is deprecated. Please use the internal CA endpoint [here](/api-reference/endpoints/certificate-authorities/internal/read).
</Note>


# Renew
Source: https://infisical.com/docs/api-reference/endpoints/certificate-authorities/renew

POST /api/v1/pki/ca/{caId}/renew
Perform CA certificate renewal



# Sign intermediate certificate
Source: https://infisical.com/docs/api-reference/endpoints/certificate-authorities/sign-intermediate

POST /api/v1/pki/ca/{caId}/sign-intermediate
Create intermediate CA certificate from parent CA



# Update (Deprecated)
Source: https://infisical.com/docs/api-reference/endpoints/certificate-authorities/update

PATCH /api/v1/pki/ca/{caId}
Update CA

<Note>
  This endpoint is deprecated. Please use the internal CA endpoint [here](/api-reference/endpoints/certificate-authorities/internal/update).
</Note>


# Create
Source: https://infisical.com/docs/api-reference/endpoints/certificate-profiles/create

POST /api/v1/pki/certificate-profiles



# Delete
Source: https://infisical.com/docs/api-reference/endpoints/certificate-profiles/delete

DELETE /api/v1/pki/certificate-profiles/{id}



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/certificate-profiles/get-by-id

GET /api/v1/pki/certificate-profiles/{id}



# Get by Slug
Source: https://infisical.com/docs/api-reference/endpoints/certificate-profiles/get-by-slug

GET /api/v1/pki/certificate-profiles/slug/{slug}



# Get Latest Active Certificate Bundle
Source: https://infisical.com/docs/api-reference/endpoints/certificate-profiles/get-latest-active-bundle

GET /api/v1/pki/certificate-profiles/{id}/certificates/latest-active-bundle
Get latest active certificate bundle for a profile



# List
Source: https://infisical.com/docs/api-reference/endpoints/certificate-profiles/list

GET /api/v1/pki/certificate-profiles



# List Certificates
Source: https://infisical.com/docs/api-reference/endpoints/certificate-profiles/list-certificates

GET /api/v1/pki/certificate-profiles/{id}/certificates



# Update
Source: https://infisical.com/docs/api-reference/endpoints/certificate-profiles/update

PATCH /api/v1/pki/certificate-profiles/{id}



# Create
Source: https://infisical.com/docs/api-reference/endpoints/certificate-templates-v2/create

POST /api/v2/certificate-templates



# Delete
Source: https://infisical.com/docs/api-reference/endpoints/certificate-templates-v2/delete

DELETE /api/v2/certificate-templates/{id}



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/certificate-templates-v2/get-by-id

GET /api/v2/certificate-templates/{id}



# List
Source: https://infisical.com/docs/api-reference/endpoints/certificate-templates-v2/list

GET /api/v2/certificate-templates



# Update
Source: https://infisical.com/docs/api-reference/endpoints/certificate-templates-v2/update

PATCH /api/v2/certificate-templates/{id}



# Get Certificate Bundle
Source: https://infisical.com/docs/api-reference/endpoints/certificates/bundle

GET /api/v1/pki/certificates/{serialNumber}/bundle
Get certificate bundle including the certificate, chain, and private key.

<Note>
  You must have the certificate `read-private-key` permission in order to call this endpoint.
</Note>


# Get Certificate Body / Chain
Source: https://infisical.com/docs/api-reference/endpoints/certificates/cert-body

GET /api/v1/pki/certificates/{serialNumber}/certificate
Get certificate body of certificate



# Delete
Source: https://infisical.com/docs/api-reference/endpoints/certificates/delete

DELETE /api/v1/pki/certificates/{serialNumber}
Delete certificate



# Issue Certificate
Source: https://infisical.com/docs/api-reference/endpoints/certificates/issue-certificate

POST /api/v3/pki/certificates/issue-certificate



# List
Source: https://infisical.com/docs/api-reference/endpoints/certificates/list

GET /api/v2/workspace/{slug}/certificates



# Get Certificate Private Key
Source: https://infisical.com/docs/api-reference/endpoints/certificates/private-key

GET /api/v1/pki/certificates/{serialNumber}/private-key
Get certificate private key



# Retrieve
Source: https://infisical.com/docs/api-reference/endpoints/certificates/read

GET /api/v1/pki/certificates/{serialNumber}
Get certificate



# Renew Certificate
Source: https://infisical.com/docs/api-reference/endpoints/certificates/renew

POST /api/v3/pki/certificates/{certificateId}/renew



# Revoke
Source: https://infisical.com/docs/api-reference/endpoints/certificates/revoke

POST /api/v1/pki/certificates/{serialNumber}/revoke
Revoke



# Sign Certificate
Source: https://infisical.com/docs/api-reference/endpoints/certificates/sign-certificate

POST /api/v3/pki/certificates/sign-certificate



# Update Certificate Config
Source: https://infisical.com/docs/api-reference/endpoints/certificates/update-config

PATCH /api/v3/pki/certificates/{certificateId}/config



# Create
Source: https://infisical.com/docs/api-reference/endpoints/deprecated/environments/create

POST /api/v1/workspace/{workspaceId}/environments
Create environment



# Delete
Source: https://infisical.com/docs/api-reference/endpoints/deprecated/environments/delete

DELETE /api/v1/workspace/{workspaceId}/environments/{id}
Delete environment



# Update
Source: https://infisical.com/docs/api-reference/endpoints/deprecated/environments/update

PATCH /api/v1/workspace/{workspaceId}/environments/{id}
Update environment



# Create
Source: https://infisical.com/docs/api-reference/endpoints/deprecated/folders/create

POST /api/v1/folders
Create folders



# Delete
Source: https://infisical.com/docs/api-reference/endpoints/deprecated/folders/delete

DELETE /api/v1/folders/{folderIdOrName}
Delete a folder



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/deprecated/folders/get-by-id

GET /api/v1/folders/{id}
Get folder by id



# List
Source: https://infisical.com/docs/api-reference/endpoints/deprecated/folders/list

GET /api/v1/folders
Get folders



# Update
Source: https://infisical.com/docs/api-reference/endpoints/deprecated/folders/update

PATCH /api/v1/folders/{folderId}
Update folder



# Get Projects
Source: https://infisical.com/docs/api-reference/endpoints/deprecated/organizations/projects

GET /api/v2/organizations/{organizationId}/workspaces
Return projects in organization that user is apart of



# Create Project Membership
Source: https://infisical.com/docs/api-reference/endpoints/deprecated/project-groups/create

POST /api/v2/workspace/{projectId}/groups/{groupIdOrName}
Add group to project



# Delete Project Membership
Source: https://infisical.com/docs/api-reference/endpoints/deprecated/project-groups/delete

DELETE /api/v2/workspace/{projectId}/groups/{groupId}
Remove group from project



# Get Project Membership
Source: https://infisical.com/docs/api-reference/endpoints/deprecated/project-groups/get-by-id

GET /api/v2/workspace/{projectId}/groups/{groupId}
Return project group



# List Project Memberships
Source: https://infisical.com/docs/api-reference/endpoints/deprecated/project-groups/list

GET /api/v2/workspace/{projectId}/groups
Return list of groups in project



# Update Project Membership
Source: https://infisical.com/docs/api-reference/endpoints/deprecated/project-groups/update

PATCH /api/v2/workspace/{projectId}/groups/{groupId}
Update group in project



# Create Identity Membership
Source: https://infisical.com/docs/api-reference/endpoints/deprecated/project-identities-v2/add-identity-membership

POST /api/v1/projects/{projectId}/identity-memberships/{identityId}
Create project identity membership



# Delete Identity Membership
Source: https://infisical.com/docs/api-reference/endpoints/deprecated/project-identities-v2/delete-identity-membership

DELETE /api/v1/projects/{projectId}/identity-memberships/{identityId}
Delete project identity memberships



# Get Identity by ID
Source: https://infisical.com/docs/api-reference/endpoints/deprecated/project-identities-v2/get-by-id

GET /api/v1/projects/{projectId}/identity-memberships/{identityId}
Return project identity membership



# List Identity Memberships
Source: https://infisical.com/docs/api-reference/endpoints/deprecated/project-identities-v2/list-identity-memberships

GET /api/v1/projects/{projectId}/identity-memberships
Return project identity memberships



# Update Identity Membership
Source: https://infisical.com/docs/api-reference/endpoints/deprecated/project-identities-v2/update-identity-membership

PATCH /api/v1/projects/{projectId}/identity-memberships/{identityId}
Update project identity memberships



# Create
Source: https://infisical.com/docs/api-reference/endpoints/deprecated/project-roles/create

POST /api/v2/workspace/{projectId}/roles
Create a project role

<Note>
  You can read more about the permissions field in the [permissions
  documentation](/internals/permissions).
</Note>


# Delete
Source: https://infisical.com/docs/api-reference/endpoints/deprecated/project-roles/delete

DELETE /api/v2/workspace/{projectId}/roles/{roleId}
Delete a project role



# Get By Slug
Source: https://infisical.com/docs/api-reference/endpoints/deprecated/project-roles/get-by-slug

GET /api/v2/workspace/{projectId}/roles/slug/{roleSlug}



# List
Source: https://infisical.com/docs/api-reference/endpoints/deprecated/project-roles/list

GET /api/v2/workspace/{projectId}/roles
List project role



# Update
Source: https://infisical.com/docs/api-reference/endpoints/deprecated/project-roles/update

PATCH /api/v2/workspace/{projectId}/roles/{roleId}
Update a project role



# Get By Username
Source: https://infisical.com/docs/api-reference/endpoints/deprecated/project-users/get-by-username

POST /api/v1/workspace/{workspaceId}/memberships/details
Return project user memberships



# Invite Member
Source: https://infisical.com/docs/api-reference/endpoints/deprecated/project-users/invite-member-to-project

POST /api/v2/workspace/{projectId}/memberships
Invite members to project



# Get User Memberships
Source: https://infisical.com/docs/api-reference/endpoints/deprecated/project-users/memberships

GET /api/v1/workspace/{workspaceId}/memberships
Return project user memberships



# Remove Member
Source: https://infisical.com/docs/api-reference/endpoints/deprecated/project-users/remove-member-from-project

DELETE /api/v2/workspace/{projectId}/memberships
Remove members from project



# Update User Membership
Source: https://infisical.com/docs/api-reference/endpoints/deprecated/project-users/update-membership

PATCH /api/v1/workspace/{workspaceId}/memberships/{membershipId}
Update project user membership



# Create Project
Source: https://infisical.com/docs/api-reference/endpoints/deprecated/projects/create-project

POST /api/v2/workspace
Create a new project



# Delete Project
Source: https://infisical.com/docs/api-reference/endpoints/deprecated/projects/delete-project

DELETE /api/v1/workspace/{workspaceId}
Delete project

<Warning>
  This operation is irreversible. All data associated with the project will be deleted. Please use with caution.
</Warning>


# Get Project
Source: https://infisical.com/docs/api-reference/endpoints/deprecated/projects/get-project

GET /api/v1/workspace/{workspaceId}
Get project



# Get Project By Slug
Source: https://infisical.com/docs/api-reference/endpoints/deprecated/projects/get-project-by-slug

GET /api/v2/workspace/{slug}
Get project details by slug



# Get Snapshots
Source: https://infisical.com/docs/api-reference/endpoints/deprecated/projects/secret-snapshots

GET /api/v1/workspace/{workspaceId}/secret-snapshots
Return project secret snapshots ids



# Update Project
Source: https://infisical.com/docs/api-reference/endpoints/deprecated/projects/update-project

PATCH /api/v1/workspace/{workspaceId}
Update project



# Create
Source: https://infisical.com/docs/api-reference/endpoints/deprecated/secret-imports/create

POST /api/v1/secret-imports
Create secret imports



# Delete
Source: https://infisical.com/docs/api-reference/endpoints/deprecated/secret-imports/delete

DELETE /api/v1/secret-imports/{secretImportId}
Delete secret imports



# List
Source: https://infisical.com/docs/api-reference/endpoints/deprecated/secret-imports/list

GET /api/v1/secret-imports
Get secret imports



# Update
Source: https://infisical.com/docs/api-reference/endpoints/deprecated/secret-imports/update

PATCH /api/v1/secret-imports/{secretImportId}
Update secret imports



# Create
Source: https://infisical.com/docs/api-reference/endpoints/deprecated/secret-tags/create

POST /api/v1/workspace/{projectId}/tags



# Delete
Source: https://infisical.com/docs/api-reference/endpoints/deprecated/secret-tags/delete

DELETE /api/v1/workspace/{projectId}/tags/{tagId}



# Get By ID
Source: https://infisical.com/docs/api-reference/endpoints/deprecated/secret-tags/get-by-id

GET /api/v1/workspace/{projectId}/tags/{tagId}



# Get By Slug
Source: https://infisical.com/docs/api-reference/endpoints/deprecated/secret-tags/get-by-slug

GET /api/v1/workspace/{projectId}/tags/slug/{tagSlug}



# List
Source: https://infisical.com/docs/api-reference/endpoints/deprecated/secret-tags/list

GET /api/v1/workspace/{projectId}/tags



# Update
Source: https://infisical.com/docs/api-reference/endpoints/deprecated/secret-tags/update

PATCH /api/v1/workspace/{projectId}/tags/{tagId}



# Attach tags
Source: https://infisical.com/docs/api-reference/endpoints/deprecated/secrets/attach-tags

POST /api/v3/secrets/tags/{secretName}
Attach tags to a secret



# Create
Source: https://infisical.com/docs/api-reference/endpoints/deprecated/secrets/create

POST /api/v3/secrets/raw/{secretName}
Create secret



# Bulk Create
Source: https://infisical.com/docs/api-reference/endpoints/deprecated/secrets/create-many

POST /api/v3/secrets/batch/raw
Create many secrets



# Delete
Source: https://infisical.com/docs/api-reference/endpoints/deprecated/secrets/delete

DELETE /api/v3/secrets/raw/{secretName}
Delete secret



# Bulk Delete
Source: https://infisical.com/docs/api-reference/endpoints/deprecated/secrets/delete-many

DELETE /api/v3/secrets/batch/raw
Delete many secrets



# Detach tags
Source: https://infisical.com/docs/api-reference/endpoints/deprecated/secrets/detach-tags

DELETE /api/v3/secrets/tags/{secretName}
Detach tags from a secret



# List
Source: https://infisical.com/docs/api-reference/endpoints/deprecated/secrets/list

GET /api/v3/secrets/raw
List secrets



# Retrieve
Source: https://infisical.com/docs/api-reference/endpoints/deprecated/secrets/read

GET /api/v3/secrets/raw/{secretName}
Get a secret by name



# Update
Source: https://infisical.com/docs/api-reference/endpoints/deprecated/secrets/update

PATCH /api/v3/secrets/raw/{secretName}
Update secret



# Bulk Update
Source: https://infisical.com/docs/api-reference/endpoints/deprecated/secrets/update-many

PATCH /api/v3/secrets/batch/raw
Update many secrets



# Create
Source: https://infisical.com/docs/api-reference/endpoints/dynamic-secrets/create

POST /api/v1/dynamic-secrets



# Create Lease
Source: https://infisical.com/docs/api-reference/endpoints/dynamic-secrets/create-lease

POST /api/v1/dynamic-secrets/leases



# Delete
Source: https://infisical.com/docs/api-reference/endpoints/dynamic-secrets/delete

DELETE /api/v1/dynamic-secrets/{name}



# Delete Lease
Source: https://infisical.com/docs/api-reference/endpoints/dynamic-secrets/delete-lease

DELETE /api/v1/dynamic-secrets/leases/{leaseId}



# Get
Source: https://infisical.com/docs/api-reference/endpoints/dynamic-secrets/get

GET /api/v1/dynamic-secrets/{name}



# Get Lease
Source: https://infisical.com/docs/api-reference/endpoints/dynamic-secrets/get-lease

GET /api/v1/dynamic-secrets/leases/{leaseId}



# Create Kubernetes Lease
Source: https://infisical.com/docs/api-reference/endpoints/dynamic-secrets/kubernetes/create-lease

POST /api/v1/dynamic-secrets/leases/kubernetes



# List
Source: https://infisical.com/docs/api-reference/endpoints/dynamic-secrets/list

GET /api/v1/dynamic-secrets



# List Leases
Source: https://infisical.com/docs/api-reference/endpoints/dynamic-secrets/list-leases

GET /api/v1/dynamic-secrets/{name}/leases



# Renew Lease
Source: https://infisical.com/docs/api-reference/endpoints/dynamic-secrets/renew-lease

POST /api/v1/dynamic-secrets/leases/{leaseId}/renew



# Update
Source: https://infisical.com/docs/api-reference/endpoints/dynamic-secrets/update

PATCH /api/v1/dynamic-secrets/{name}



# Create
Source: https://infisical.com/docs/api-reference/endpoints/environments/create

POST /api/v1/projects/{projectId}/environments
Create environment



# Delete
Source: https://infisical.com/docs/api-reference/endpoints/environments/delete

DELETE /api/v1/projects/{projectId}/environments/{id}
Delete environment



# Update
Source: https://infisical.com/docs/api-reference/endpoints/environments/update

PATCH /api/v1/projects/{projectId}/environments/{id}
Update environment



# Project Events
Source: https://infisical.com/docs/api-reference/endpoints/events/project-events

POST /api/v1/events/subscribe/project-events
Subscribe to project events



# Create
Source: https://infisical.com/docs/api-reference/endpoints/folders/create

POST /api/v2/folders
Create folders



# Delete
Source: https://infisical.com/docs/api-reference/endpoints/folders/delete

DELETE /api/v2/folders/{folderIdOrName}
Delete a folder



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/folders/get-by-id

GET /api/v2/folders/{id}
Get folder by id



# List
Source: https://infisical.com/docs/api-reference/endpoints/folders/list

GET /api/v2/folders
Get folders



# Update
Source: https://infisical.com/docs/api-reference/endpoints/folders/update

PATCH /api/v2/folders/{folderId}
Update folder



# Attach
Source: https://infisical.com/docs/api-reference/endpoints/gcp-auth/attach

POST /api/v1/auth/gcp-auth/identities/{identityId}
Attach GCP Auth configuration onto machine identity



# Login
Source: https://infisical.com/docs/api-reference/endpoints/gcp-auth/login

POST /api/v1/auth/gcp-auth/login
Login with GCP Auth for machine identity



# Retrieve
Source: https://infisical.com/docs/api-reference/endpoints/gcp-auth/retrieve

GET /api/v1/auth/gcp-auth/identities/{identityId}
Retrieve GCP Auth configuration on machine identity



# Revoke
Source: https://infisical.com/docs/api-reference/endpoints/gcp-auth/revoke

DELETE /api/v1/auth/gcp-auth/identities/{identityId}
Delete GCP Auth configuration on machine identity



# Update
Source: https://infisical.com/docs/api-reference/endpoints/gcp-auth/update

PATCH /api/v1/auth/gcp-auth/identities/{identityId}
Update GCP Auth configuration on machine identity



# Add Group User
Source: https://infisical.com/docs/api-reference/endpoints/groups/add-group-user

POST /api/v1/groups/{id}/users/{username}



# Create
Source: https://infisical.com/docs/api-reference/endpoints/groups/create

POST /api/v1/groups



# Delete
Source: https://infisical.com/docs/api-reference/endpoints/groups/delete

DELETE /api/v1/groups/{id}



# Get Groups in Organization
Source: https://infisical.com/docs/api-reference/endpoints/groups/get

GET /api/v1/groups



# Get By ID
Source: https://infisical.com/docs/api-reference/endpoints/groups/get-by-id

GET /api/v1/groups/{id}



# List Group Users
Source: https://infisical.com/docs/api-reference/endpoints/groups/list-group-users

GET /api/v1/groups/{id}/users



# Remove Group User
Source: https://infisical.com/docs/api-reference/endpoints/groups/remove-group-user

DELETE /api/v1/groups/{id}/users/{username}



# Update
Source: https://infisical.com/docs/api-reference/endpoints/groups/update

PATCH /api/v1/groups/{id}



# Create
Source: https://infisical.com/docs/api-reference/endpoints/identities/create

POST /api/v1/identities
Create machine identity



# Delete
Source: https://infisical.com/docs/api-reference/endpoints/identities/delete

DELETE /api/v1/identities/{identityId}
Delete machine identity



# Get By ID
Source: https://infisical.com/docs/api-reference/endpoints/identities/get-by-id

GET /api/v1/identities/{identityId}
Get a machine identity by id



# List
Source: https://infisical.com/docs/api-reference/endpoints/identities/list

GET /api/v1/identities
List machine identities



# Search
Source: https://infisical.com/docs/api-reference/endpoints/identities/search

POST /api/v1/identities/search
Search machine identities



# Update
Source: https://infisical.com/docs/api-reference/endpoints/identities/update

PATCH /api/v1/identities/{identityId}
Update machine identity



# Create Permanent
Source: https://infisical.com/docs/api-reference/endpoints/identity-specific-privilege/v1/create-permanent

POST /api/v1/additional-privilege/identity/permanent
Create a permanent or a non expiry specific privilege for identity.



# Create Temporary
Source: https://infisical.com/docs/api-reference/endpoints/identity-specific-privilege/v1/create-temporary

POST /api/v1/additional-privilege/identity/temporary
Create a temporary or a expiring specific privilege for identity.



# Delete
Source: https://infisical.com/docs/api-reference/endpoints/identity-specific-privilege/v1/delete

DELETE /api/v1/additional-privilege/identity
Delete a specific privilege of an identity.



# Find By Slug
Source: https://infisical.com/docs/api-reference/endpoints/identity-specific-privilege/v1/find-by-slug

GET /api/v1/additional-privilege/identity/{privilegeSlug}
Retrieve details of a specific privilege by privilege slug.



# List
Source: https://infisical.com/docs/api-reference/endpoints/identity-specific-privilege/v1/list

GET /api/v1/additional-privilege/identity
List of a specific privilege of an identity in a project.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/identity-specific-privilege/v1/update

PATCH /api/v1/additional-privilege/identity
Update a specific privilege of an identity.



# Create
Source: https://infisical.com/docs/api-reference/endpoints/identity-specific-privilege/v2/create

POST /api/v2/identity-project-additional-privilege
Add an additional privilege for identity.



# Delete
Source: https://infisical.com/docs/api-reference/endpoints/identity-specific-privilege/v2/delete

DELETE /api/v2/identity-project-additional-privilege/{id}
Delete the specified identity privilege.



# Find By ID
Source: https://infisical.com/docs/api-reference/endpoints/identity-specific-privilege/v2/find-by-id

GET /api/v2/identity-project-additional-privilege/{id}
Retrieve details of a specific privilege by id.



# Find By Slug
Source: https://infisical.com/docs/api-reference/endpoints/identity-specific-privilege/v2/find-by-slug

GET /api/v2/identity-project-additional-privilege/slug/{privilegeSlug}
Retrieve details of a specific privilege by slug.



# List
Source: https://infisical.com/docs/api-reference/endpoints/identity-specific-privilege/v2/list

GET /api/v2/identity-project-additional-privilege
List privileges for the specified identity by project.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/identity-specific-privilege/v2/update

PATCH /api/v2/identity-project-additional-privilege/{id}
Update a specific identity privilege.



# Create
Source: https://infisical.com/docs/api-reference/endpoints/integrations/create

POST /api/v1/integration
Create an integration to sync secrets.

## Integration Parameters

The integration creation endpoint is generic and can be used for all native integrations.
For specific integration parameters for a given service, please review the respective documentation below.

<Tabs>
  <Tab title="AWS Secrets manager">
    <ParamField body="integrationAuthId" type="string" required>
      The ID of the integration auth object for authentication with AWS.
      Refer [Create Integration Auth](./create-auth) for more info
    </ParamField>

    <ParamField body="isActive" type="boolean">
      Whether the integration should be active or inactive
    </ParamField>

    <ParamField body="app" type="string" required>
      The secret name used when saving secret in AWS SSM. Used for naming and can be arbitrary.
    </ParamField>

    <ParamField body="region" type="string" required>
      The AWS region of the SSM. Example: `us-east-1`
    </ParamField>

    <ParamField body="sourceEnvironment" type="string" required>
      The Infisical environment slug from where secrets will be synced from. Example: `dev`
    </ParamField>

    <ParamField body="secretPath" type="string" required>
      The Infisical folder path from where secrets will be synced from. Example: `/some/path`. The root of the environment is `/`.
    </ParamField>
  </Tab>

  <Tab title="GCP Secrets manager">
    Coming Soon
  </Tab>

  <Tab title="Heroku">
    Coming Soon
  </Tab>
</Tabs>


# Create Auth
Source: https://infisical.com/docs/api-reference/endpoints/integrations/create-auth

POST /api/v1/integration-auth/access-token
Create the integration authentication object required for syncing secrets.

## Integration Authentication Parameters

The integration authentication endpoint is generic and can be used for all native integrations.
For specific integration parameters for a given service, please review the respective documentation below.

<Tabs>
  <Tab title="AWS Secrets manager">
    <ParamField body="integration" type="string" initialValue="aws-secret-manager" required>
      This value must be **aws-secret-manager**.
    </ParamField>

    <ParamField body="workspaceId" type="string" required>
      Infisical project id for the integration.
    </ParamField>

    <ParamField body="accessId" type="string" required>
      The AWS IAM User Access ID.
    </ParamField>

    <ParamField body="accessToken" type="string" required>
      The AWS IAM User Access Secret Key.
    </ParamField>
  </Tab>

  <Tab title="GCP Secrets manager">
    Coming Soon
  </Tab>

  <Tab title="Heroku">
    Coming Soon
  </Tab>
</Tabs>


# Delete
Source: https://infisical.com/docs/api-reference/endpoints/integrations/delete

DELETE /api/v1/integration/{integrationId}
Remove an integration using the integration object ID



# Delete Auth
Source: https://infisical.com/docs/api-reference/endpoints/integrations/delete-auth

DELETE /api/v1/integration-auth
Remove all integration's auth object from the project.



# Delete Auth By ID
Source: https://infisical.com/docs/api-reference/endpoints/integrations/delete-auth-by-id

DELETE /api/v1/integration-auth/{integrationAuthId}
Remove an integration auth object by object id.



# Get Auth By ID
Source: https://infisical.com/docs/api-reference/endpoints/integrations/find-auth

GET /api/v1/integration-auth/{integrationAuthId}
Get details of an integration authorization by auth object id.



# List Auth
Source: https://infisical.com/docs/api-reference/endpoints/integrations/list-auth

GET /api/v1/workspace/{workspaceId}/authorizations
List integration auth objects for a workspace.



# List Project Integrations
Source: https://infisical.com/docs/api-reference/endpoints/integrations/list-project-integrations

GET /api/v1/workspace/{workspaceId}/integrations
List integrations for a project.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/integrations/update

PATCH /api/v1/integration/{integrationId}
Update an integration by integration id



# Attach
Source: https://infisical.com/docs/api-reference/endpoints/jwt-auth/attach

POST /api/v1/auth/jwt-auth/identities/{identityId}
Attach JWT Auth configuration onto machine identity



# Login
Source: https://infisical.com/docs/api-reference/endpoints/jwt-auth/login

POST /api/v1/auth/jwt-auth/login
Login with JWT Auth for machine identity



# Retrieve
Source: https://infisical.com/docs/api-reference/endpoints/jwt-auth/retrieve

GET /api/v1/auth/jwt-auth/identities/{identityId}
Retrieve JWT Auth configuration on machine identity



# Revoke
Source: https://infisical.com/docs/api-reference/endpoints/jwt-auth/revoke

DELETE /api/v1/auth/jwt-auth/identities/{identityId}
Delete JWT Auth configuration on machine identity



# Update
Source: https://infisical.com/docs/api-reference/endpoints/jwt-auth/update

PATCH /api/v1/auth/jwt-auth/identities/{identityId}
Update JWT Auth configuration on machine identity



# Decrypt Data
Source: https://infisical.com/docs/api-reference/endpoints/kms/encryption/decrypt

POST /api/v1/kms/keys/{keyId}/decrypt
Decrypt data with KMS key



# Encrypt Data
Source: https://infisical.com/docs/api-reference/endpoints/kms/encryption/encrypt

POST /api/v1/kms/keys/{keyId}/encrypt
Encrypt data with KMS key



# Create Key
Source: https://infisical.com/docs/api-reference/endpoints/kms/keys/create

POST /api/v1/kms/keys
Create KMS key



# Delete Key
Source: https://infisical.com/docs/api-reference/endpoints/kms/keys/delete

DELETE /api/v1/kms/keys/{keyId}
Delete KMS key



# Get Key by ID
Source: https://infisical.com/docs/api-reference/endpoints/kms/keys/get-by-id

Get /api/v1/kms/keys/{keyId}
Get KMS key by ID



# Get Key by Name
Source: https://infisical.com/docs/api-reference/endpoints/kms/keys/get-by-name

Get /api/v1/kms/keys/key-name/{keyName}
Get KMS key by name



# List Keys
Source: https://infisical.com/docs/api-reference/endpoints/kms/keys/list

Get /api/v1/kms/keys
List KMS keys



# Update Key
Source: https://infisical.com/docs/api-reference/endpoints/kms/keys/update

PATCH /api/v1/kms/keys/{keyId}
Update KMS key



# Retrieve Public Key
Source: https://infisical.com/docs/api-reference/endpoints/kms/signing/public-key

GET /api/v1/kms/keys/{keyId}/public-key
Get the public key for a KMS key that is used for signing and verifying data. This endpoint is only available for asymmetric keys.



# Sign Data
Source: https://infisical.com/docs/api-reference/endpoints/kms/signing/sign

POST /api/v1/kms/keys/{keyId}/sign
Sign data with a KMS key.



# List Signing Algorithms
Source: https://infisical.com/docs/api-reference/endpoints/kms/signing/signing-algorithms

GET /api/v1/kms/keys/{keyId}/signing-algorithms
List all available signing algorithms for a KMS key



# Verify Signature
Source: https://infisical.com/docs/api-reference/endpoints/kms/signing/verify

POST /api/v1/kms/keys/{keyId}/verify
Verify data signatures with a KMS key.



# Attach
Source: https://infisical.com/docs/api-reference/endpoints/kubernetes-auth/attach

POST /api/v1/auth/kubernetes-auth/identities/{identityId}
Attach Kubernetes Auth configuration onto machine identity



# Login
Source: https://infisical.com/docs/api-reference/endpoints/kubernetes-auth/login

POST /api/v1/auth/kubernetes-auth/login
Login with Kubernetes Auth for machine identity



# Retrieve
Source: https://infisical.com/docs/api-reference/endpoints/kubernetes-auth/retrieve

GET /api/v1/auth/kubernetes-auth/identities/{identityId}
Retrieve Kubernetes Auth configuration on machine identity



# Revoke
Source: https://infisical.com/docs/api-reference/endpoints/kubernetes-auth/revoke

DELETE /api/v1/auth/kubernetes-auth/identities/{identityId}
Delete Kubernetes Auth configuration on machine identity



# Update
Source: https://infisical.com/docs/api-reference/endpoints/kubernetes-auth/update

PATCH /api/v1/auth/kubernetes-auth/identities/{identityId}
Update Kubernetes Auth configuration on machine identity



# Attach
Source: https://infisical.com/docs/api-reference/endpoints/ldap-auth/attach

POST /api/v1/auth/ldap-auth/identities/{identityId}
Attach LDAP Auth configuration onto machine identity



# Login
Source: https://infisical.com/docs/api-reference/endpoints/ldap-auth/login

POST /api/v1/auth/ldap-auth/login
Login with LDAP Auth for machine identity



# Retrieve
Source: https://infisical.com/docs/api-reference/endpoints/ldap-auth/retrieve

GET /api/v1/auth/ldap-auth/identities/{identityId}
Retrieve LDAP Auth configuration on machine identity



# Revoke
Source: https://infisical.com/docs/api-reference/endpoints/ldap-auth/revoke

DELETE /api/v1/auth/ldap-auth/identities/{identityId}
Delete LDAP Auth configuration on machine identity



# Update
Source: https://infisical.com/docs/api-reference/endpoints/ldap-auth/update

PATCH /api/v1/auth/ldap-auth/identities/{identityId}
Update LDAP Auth configuration on machine identity



# Attach
Source: https://infisical.com/docs/api-reference/endpoints/oci-auth/attach

POST /api/v1/auth/oci-auth/identities/{identityId}
Attach OCI Auth configuration onto machine identity



# Login
Source: https://infisical.com/docs/api-reference/endpoints/oci-auth/login

POST /api/v1/auth/oci-auth/login
Login with OCI Auth for machine identity



# Retrieve
Source: https://infisical.com/docs/api-reference/endpoints/oci-auth/retrieve

GET /api/v1/auth/oci-auth/identities/{identityId}
Retrieve OCI Auth configuration on machine identity



# Revoke
Source: https://infisical.com/docs/api-reference/endpoints/oci-auth/revoke

DELETE /api/v1/auth/oci-auth/identities/{identityId}
Delete OCI Auth configuration on machine identity



# Update
Source: https://infisical.com/docs/api-reference/endpoints/oci-auth/update

PATCH /api/v1/auth/oci-auth/identities/{identityId}
Update OCI Auth configuration on machine identity



# Attach
Source: https://infisical.com/docs/api-reference/endpoints/oidc-auth/attach

POST /api/v1/auth/oidc-auth/identities/{identityId}
Attach OIDC Auth configuration onto machine identity



# Login
Source: https://infisical.com/docs/api-reference/endpoints/oidc-auth/login

POST /api/v1/auth/oidc-auth/login
Login with OIDC Auth for machine identity



# Retrieve
Source: https://infisical.com/docs/api-reference/endpoints/oidc-auth/retrieve

GET /api/v1/auth/oidc-auth/identities/{identityId}
Retrieve OIDC Auth configuration on machine identity



# Revoke
Source: https://infisical.com/docs/api-reference/endpoints/oidc-auth/revoke

DELETE /api/v1/auth/oidc-auth/identities/{identityId}
Delete OIDC Auth configuration on machine identity



# Update
Source: https://infisical.com/docs/api-reference/endpoints/oidc-auth/update

PATCH /api/v1/auth/oidc-auth/identities/{identityId}
Update OIDC Auth configuration on machine identity



# Bulk Delete User Memberships
Source: https://infisical.com/docs/api-reference/endpoints/organizations/bulk-delete-memberships

DELETE /api/v2/organizations/{organizationId}/memberships
Bulk delete organization user memberships



# Delete User Membership
Source: https://infisical.com/docs/api-reference/endpoints/organizations/delete-membership

DELETE /api/v2/organizations/{organizationId}/memberships/{membershipId}
Delete organization user memberships



# Create LDAP SSO Config
Source: https://infisical.com/docs/api-reference/endpoints/organizations/ldap-sso/create-ldap-config

POST /api/v1/ldap/config
Create LDAP config



# Get LDAP SSO Config
Source: https://infisical.com/docs/api-reference/endpoints/organizations/ldap-sso/get-ldap-config

GET /api/v1/ldap/config
Get LDAP config



# Update LDAP SSO Config
Source: https://infisical.com/docs/api-reference/endpoints/organizations/ldap-sso/update-ldap-config

PATCH /api/v1/ldap/config
Update LDAP config



# List Identity Memberships
Source: https://infisical.com/docs/api-reference/endpoints/organizations/list-identity-memberships

GET /api/v2/organizations/{orgId}/identity-memberships
Return organization identity memberships



# Get User Memberships
Source: https://infisical.com/docs/api-reference/endpoints/organizations/memberships

GET /api/v2/organizations/{organizationId}/memberships
Return organization user memberships



# Create OIDC Config
Source: https://infisical.com/docs/api-reference/endpoints/organizations/oidc-sso/create-oidc-config

POST /api/v1/sso/oidc/config
Create OIDC config



# Get OIDC Config
Source: https://infisical.com/docs/api-reference/endpoints/organizations/oidc-sso/get-oidc-config

GET /api/v1/sso/oidc/config
Get OIDC config



# Update OIDC Config
Source: https://infisical.com/docs/api-reference/endpoints/organizations/oidc-sso/update-oidc-config

PATCH /api/v1/sso/oidc/config
Update OIDC config



# Create SAML SSO Config
Source: https://infisical.com/docs/api-reference/endpoints/organizations/saml-sso/create-saml-config

POST /api/v1/sso/config
Create SAML config



# Get SAML SSO Config
Source: https://infisical.com/docs/api-reference/endpoints/organizations/saml-sso/get-saml-config

GET /api/v1/sso/config
Get SAML config



# Update SAML SSO Config
Source: https://infisical.com/docs/api-reference/endpoints/organizations/saml-sso/update-saml-config

PATCH /api/v1/sso/config
Update SAML config



# Update User Membership
Source: https://infisical.com/docs/api-reference/endpoints/organizations/update-membership

PATCH /api/v2/organizations/{organizationId}/memberships/{membershipId}
Update organization user memberships



# Add Collection Item
Source: https://infisical.com/docs/api-reference/endpoints/pki-collections/add-item

POST /api/v1/pki/collections/{collectionId}/items
Add item to PKI collection



# Create
Source: https://infisical.com/docs/api-reference/endpoints/pki-collections/create

POST /api/v1/pki/collections
Create PKI collection



# Delete
Source: https://infisical.com/docs/api-reference/endpoints/pki-collections/delete

DELETE /api/v1/pki/collections/{collectionId}
Delete PKI collection



# Delete Collection Item
Source: https://infisical.com/docs/api-reference/endpoints/pki-collections/delete-item

DELETE /api/v1/pki/collections/{collectionId}/items/{collectionItemId}
Remove item from PKI collection



# Retrieve
Source: https://infisical.com/docs/api-reference/endpoints/pki-collections/list-items

GET /api/v1/pki/collections/{collectionId}/items
Get items in PKI collection



# Retrieve
Source: https://infisical.com/docs/api-reference/endpoints/pki-collections/read

GET /api/v1/pki/collections/{collectionId}
Get PKI collection



# Update
Source: https://infisical.com/docs/api-reference/endpoints/pki-collections/update

PATCH /api/v1/pki/collections/{collectionId}
Update PKI collection



# Add Certificates to Sync
Source: https://infisical.com/docs/api-reference/endpoints/pki/syncs/add-certificates

POST /api/v1/pki/syncs/{pkiSyncId}/certificates
Add certificates to a PKI Sync.



# Create AWS Certificate Manager PKI Sync
Source: https://infisical.com/docs/api-reference/endpoints/pki/syncs/aws-certificate-manager/create

POST /api/v1/pki/syncs/aws-certificate-manager
Create a AWS Certificate Manager PKI Sync for the specified project.



# Delete AWS Certificate Manager PKI Sync
Source: https://infisical.com/docs/api-reference/endpoints/pki/syncs/aws-certificate-manager/delete

DELETE /api/v1/pki/syncs/aws-certificate-manager/{pkiSyncId}
Delete the specified AWS Certificate Manager PKI Sync.



# Get AWS Certificate Manager PKI Sync by ID
Source: https://infisical.com/docs/api-reference/endpoints/pki/syncs/aws-certificate-manager/get-by-id

GET /api/v1/pki/syncs/aws-certificate-manager/{pkiSyncId}
Get the specified AWS Certificate Manager PKI Sync by ID.



# List AWS Certificate Manager PKI Syncs
Source: https://infisical.com/docs/api-reference/endpoints/pki/syncs/aws-certificate-manager/list

GET /api/v1/pki/syncs/aws-certificate-manager
List the AWS Certificate Manager PKI Syncs for the specified project.



# Remove Certificates from AWS Certificate Manager
Source: https://infisical.com/docs/api-reference/endpoints/pki/syncs/aws-certificate-manager/remove-certificates

POST /api/v1/pki/syncs/aws-certificate-manager/{pkiSyncId}/remove-certificates
Remove certificates from the specified AWS Certificate Manager PKI Sync destination.



# Sync Certificates to AWS Certificate Manager
Source: https://infisical.com/docs/api-reference/endpoints/pki/syncs/aws-certificate-manager/sync-certificates

POST /api/v1/pki/syncs/aws-certificate-manager/{pkiSyncId}/sync
Trigger a sync for the specified AWS Certificate Manager PKI Sync.



# Update AWS Certificate Manager PKI Sync
Source: https://infisical.com/docs/api-reference/endpoints/pki/syncs/aws-certificate-manager/update

PATCH /api/v1/pki/syncs/aws-certificate-manager/{pkiSyncId}
Update the specified AWS Certificate Manager PKI Sync.



# Create Azure Key Vault PKI Sync
Source: https://infisical.com/docs/api-reference/endpoints/pki/syncs/azure-key-vault/create

POST /api/v1/pki/syncs/azure-key-vault
Create a Azure Key Vault PKI Sync for the specified project.



# Delete Azure Key Vault PKI Sync
Source: https://infisical.com/docs/api-reference/endpoints/pki/syncs/azure-key-vault/delete

DELETE /api/v1/pki/syncs/azure-key-vault/{pkiSyncId}
Delete the specified Azure Key Vault PKI Sync.



# Get Azure Key Vault PKI Sync by ID
Source: https://infisical.com/docs/api-reference/endpoints/pki/syncs/azure-key-vault/get-by-id

GET /api/v1/pki/syncs/azure-key-vault/{pkiSyncId}
Get the specified Azure Key Vault PKI Sync by ID.



# List Azure Key Vault PKI Syncs
Source: https://infisical.com/docs/api-reference/endpoints/pki/syncs/azure-key-vault/list

GET /api/v1/pki/syncs/azure-key-vault
List the Azure Key Vault PKI Syncs for the specified project.



# Remove Certificates from Azure Key Vault
Source: https://infisical.com/docs/api-reference/endpoints/pki/syncs/azure-key-vault/remove-certificates

POST /api/v1/pki/syncs/azure-key-vault/{pkiSyncId}/remove-certificates
Remove certificates from the specified Azure Key Vault PKI Sync destination.



# Sync Certificates to Azure Key Vault
Source: https://infisical.com/docs/api-reference/endpoints/pki/syncs/azure-key-vault/sync-certificates

POST /api/v1/pki/syncs/azure-key-vault/{pkiSyncId}/sync
Trigger a sync for the specified Azure Key Vault PKI Sync.



# Update Azure Key Vault PKI Sync
Source: https://infisical.com/docs/api-reference/endpoints/pki/syncs/azure-key-vault/update

PATCH /api/v1/pki/syncs/azure-key-vault/{pkiSyncId}
Update the specified Azure Key Vault PKI Sync.



# Get PKI Sync by ID
Source: https://infisical.com/docs/api-reference/endpoints/pki/syncs/get-by-id

GET /api/v1/pki/syncs/{pkiSyncId}
Get a PKI Sync by ID.



# List PKI Syncs
Source: https://infisical.com/docs/api-reference/endpoints/pki/syncs/list

GET /api/v1/pki/syncs
List all the PKI Syncs for the specified project.



# List Sync Certificates
Source: https://infisical.com/docs/api-reference/endpoints/pki/syncs/list-certificates

GET /api/v1/pki/syncs/{pkiSyncId}/certificates
List all certificates associated with a PKI Sync.



# List PKI Sync Options
Source: https://infisical.com/docs/api-reference/endpoints/pki/syncs/options

GET /api/v1/pki/syncs/options
List the available PKI Sync Options.



# Remove Certificates from Sync
Source: https://infisical.com/docs/api-reference/endpoints/pki/syncs/remove-certificates

DELETE /api/v1/pki/syncs/{pkiSyncId}/certificates
Remove certificates from a PKI Sync.



# Create Project Membership
Source: https://infisical.com/docs/api-reference/endpoints/project-groups/create

POST /api/v1/projects/{projectId}/groups/{groupIdOrName}
Add group to project



# Delete Project Membership
Source: https://infisical.com/docs/api-reference/endpoints/project-groups/delete

DELETE /api/v1/projects/{projectId}/groups/{groupId}
Remove group from project



# Get Project Membership
Source: https://infisical.com/docs/api-reference/endpoints/project-groups/get-by-id

GET /api/v1/projects/{projectId}/groups/{groupId}
Return project group



# List Project Memberships
Source: https://infisical.com/docs/api-reference/endpoints/project-groups/list

GET /api/v1/projects/{projectId}/groups
Return list of groups in project



# Update Project Membership
Source: https://infisical.com/docs/api-reference/endpoints/project-groups/update

PATCH /api/v1/projects/{projectId}/groups/{groupId}
Update group in project



# Create Identity Membership
Source: https://infisical.com/docs/api-reference/endpoints/project-identities-membership/add-identity-membership

POST /api/v1/projects/{projectId}/memberships/identities/{identityId}
Create project identity membership



# Delete Identity Membership
Source: https://infisical.com/docs/api-reference/endpoints/project-identities-membership/delete-identity-membership

DELETE /api/v1/projects/{projectId}/memberships/identities/{identityId}
Delete project identity memberships



# Get Identity by ID
Source: https://infisical.com/docs/api-reference/endpoints/project-identities-membership/get-by-id

GET /api/v1/projects/{projectId}/memberships/identities/{identityId}
Get project identity membership by identity ID



# List Identity Memberships
Source: https://infisical.com/docs/api-reference/endpoints/project-identities-membership/list-identity-memberships

GET /api/v1/projects/{projectId}/memberships/identities
List project identity memberships



# Update Identity Membership
Source: https://infisical.com/docs/api-reference/endpoints/project-identities-membership/update-identity-membership

PATCH /api/v1/projects/{projectId}/memberships/identities/{identityId}
Update project identity memberships



# Create Identity
Source: https://infisical.com/docs/api-reference/endpoints/project-identities/add-identity

POST /api/v1/projects/{projectId}/identities
Create an identity in a project



# Delete Identity
Source: https://infisical.com/docs/api-reference/endpoints/project-identities/delete-identity

DELETE /api/v1/projects/{projectId}/identities/{identityId}
Delete an identity from a project



# Get Identity by ID
Source: https://infisical.com/docs/api-reference/endpoints/project-identities/get-by-id

GET /api/v1/projects/{projectId}/identities/{identityId}
Get an identity by ID in a project



# List Identities
Source: https://infisical.com/docs/api-reference/endpoints/project-identities/list-identity

GET /api/v1/projects/{projectId}/identities
List identities in a project



# Update Identity
Source: https://infisical.com/docs/api-reference/endpoints/project-identities/update-identity

PATCH /api/v1/projects/{projectId}/identities/{identityId}
Update an identity in a project



# Create
Source: https://infisical.com/docs/api-reference/endpoints/project-roles/create

POST /api/v1/projects/{projectId}/roles
Create a project role

<Note>
  You can read more about the permissions field in the [permissions
  documentation](/internals/permissions).
</Note>


# Delete
Source: https://infisical.com/docs/api-reference/endpoints/project-roles/delete

DELETE /api/v1/projects/{projectId}/roles/{roleId}
Delete a project role



# Get By Slug
Source: https://infisical.com/docs/api-reference/endpoints/project-roles/get-by-slug

GET /api/v1/projects/{projectId}/roles/slug/{roleSlug}



# List
Source: https://infisical.com/docs/api-reference/endpoints/project-roles/list

GET /api/v1/projects/{projectId}/roles
List project role



# Update
Source: https://infisical.com/docs/api-reference/endpoints/project-roles/update

PATCH /api/v1/projects/{projectId}/roles/{roleId}
Update a project role



# Create
Source: https://infisical.com/docs/api-reference/endpoints/project-templates/create

POST /api/v1/project-templates
Create a project template.

<Note>
  You can read more about the role's permissions field in the [permissions documentation](/internals/permissions).
</Note>


# Delete
Source: https://infisical.com/docs/api-reference/endpoints/project-templates/delete

DELETE /api/v1/project-templates/{templateId}
Delete a project template.



# Get By ID
Source: https://infisical.com/docs/api-reference/endpoints/project-templates/get-by-id

GET /api/v1/project-templates/{templateId}
Get a project template by ID.



# List
Source: https://infisical.com/docs/api-reference/endpoints/project-templates/list

GET /api/v1/project-templates
List project templates for the current organization.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/project-templates/update

PATCH /api/v1/project-templates/{templateId}
Update a project template.

<Note>
  You can read more about the role's permissions field in the [permissions documentation](/internals/permissions).
</Note>


# Get By Username
Source: https://infisical.com/docs/api-reference/endpoints/project-users/get-by-username

POST /api/v1/projects/{projectId}/memberships/details
Return project user memberships



# Invite Member
Source: https://infisical.com/docs/api-reference/endpoints/project-users/invite-member-to-project

POST /api/v1/projects/{projectId}/memberships
Invite members to project



# Get User Memberships
Source: https://infisical.com/docs/api-reference/endpoints/project-users/memberships

GET /api/v1/projects/{projectId}/memberships
Return project user memberships



# Remove Member
Source: https://infisical.com/docs/api-reference/endpoints/project-users/remove-member-from-project

DELETE /api/v1/projects/{projectId}/memberships
Remove members from project



# Update User Membership
Source: https://infisical.com/docs/api-reference/endpoints/project-users/update-membership

PATCH /api/v1/projects/{projectId}/memberships/{membershipId}
Update project user membership



# Create Project
Source: https://infisical.com/docs/api-reference/endpoints/projects/create-project

POST /api/v1/projects
Create a new project



# Delete Project
Source: https://infisical.com/docs/api-reference/endpoints/projects/delete-project

DELETE /api/v1/projects/{projectId}
Delete project

<Warning>
  This operation is irreversible. All data associated with the project will be deleted. Please use with caution.
</Warning>


# Get Project
Source: https://infisical.com/docs/api-reference/endpoints/projects/get-project

GET /api/v1/projects/{projectId}
Get project



# Get Project By Slug
Source: https://infisical.com/docs/api-reference/endpoints/projects/get-project-by-slug

GET /api/v1/projects/slug/{slug}
Get project details by slug



# List Projects
Source: https://infisical.com/docs/api-reference/endpoints/projects/list-projects

GET /api/v1/projects
List projects



# Get Snapshots
Source: https://infisical.com/docs/api-reference/endpoints/projects/secret-snapshots

GET /api/v1/projects/{projectId}/secret-snapshots
Return project secret snapshots ids



# Update Project
Source: https://infisical.com/docs/api-reference/endpoints/projects/update-project

PATCH /api/v1/projects/{projectId}
Update project



# Create
Source: https://infisical.com/docs/api-reference/endpoints/secret-imports/create

POST /api/v2/secret-imports
Create secret imports



# Delete
Source: https://infisical.com/docs/api-reference/endpoints/secret-imports/delete

DELETE /api/v2/secret-imports/{secretImportId}
Delete secret imports



# List
Source: https://infisical.com/docs/api-reference/endpoints/secret-imports/list

GET /api/v2/secret-imports
Get secret imports



# Update
Source: https://infisical.com/docs/api-reference/endpoints/secret-imports/update

PATCH /api/v2/secret-imports/{secretImportId}
Update secret imports



# Create
Source: https://infisical.com/docs/api-reference/endpoints/secret-rotations/auth0-client-secret/create

POST /api/v2/secret-rotations/auth0-client-secret
Create an Auth0 Client Secret Rotation for the specified project.

<Note>
  Check out the configuration docs for [Auth0 Client Secret Rotations](/documentation/platform/secret-rotation/auth0-client-secret) to learn how to obtain the
  required parameters.
</Note>


# Delete
Source: https://infisical.com/docs/api-reference/endpoints/secret-rotations/auth0-client-secret/delete

DELETE /api/v2/secret-rotations/auth0-client-secret/{rotationId}
Delete the specified Auth0 Client Secret Rotation.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/secret-rotations/auth0-client-secret/get-by-id

GET /api/v2/secret-rotations/auth0-client-secret/{rotationId}
Get the specified Auth0 Client Secret Rotation by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/secret-rotations/auth0-client-secret/get-by-name

GET /api/v2/secret-rotations/auth0-client-secret/rotation-name/{rotationName}
Get the specified Auth0 Client Secret Rotation by name, secret path, environment and project ID.



# Get Credentials by ID
Source: https://infisical.com/docs/api-reference/endpoints/secret-rotations/auth0-client-secret/get-generated-credentials-by-id

GET /api/v2/secret-rotations/auth0-client-secret/{rotationId}/generated-credentials
Get the generated credentials for the specified Auth0 Client Secret Rotation.



# List
Source: https://infisical.com/docs/api-reference/endpoints/secret-rotations/auth0-client-secret/list

GET /api/v2/secret-rotations/auth0-client-secret
List the Auth0 Client Secret Rotations for the specified project.



# Rotate Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-rotations/auth0-client-secret/rotate-secrets

POST /api/v2/secret-rotations/auth0-client-secret/{rotationId}/rotate-secrets
Rotate the generated credentials for the specified Auth0 Client Secret Rotation.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/secret-rotations/auth0-client-secret/update

PATCH /api/v2/secret-rotations/auth0-client-secret/{rotationId}
Update the specified Auth0 Client Secret Rotation.

<Note>
  Check out the configuration docs for [Auth0 Client Secret Rotations](/documentation/platform/secret-rotation/auth0-client-secret) to learn how to obtain the
  required parameters.
</Note>


# Create
Source: https://infisical.com/docs/api-reference/endpoints/secret-rotations/aws-iam-user-secret/create

POST /api/v2/secret-rotations/aws-iam-user-secret
Create an AWS IAM User Secret Rotation for the specified project.

<Note>
  Check out the configuration docs for [AWS IAM User Secret Rotations](/documentation/platform/secret-rotation/aws-iam-user-secret) to learn how to obtain the
  required parameters.
</Note>


# Delete
Source: https://infisical.com/docs/api-reference/endpoints/secret-rotations/aws-iam-user-secret/delete

DELETE /api/v2/secret-rotations/aws-iam-user-secret/{rotationId}
Delete the specified AWS IAM User Secret Rotation.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/secret-rotations/aws-iam-user-secret/get-by-id

GET /api/v2/secret-rotations/aws-iam-user-secret/{rotationId}
Get the specified AWS IAM User Secret Rotation by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/secret-rotations/aws-iam-user-secret/get-by-name

GET /api/v2/secret-rotations/aws-iam-user-secret/rotation-name/{rotationName}
Get the specified AWS IAM User Secret Rotation by name, secret path, environment and project ID.



# Get Credentials by ID
Source: https://infisical.com/docs/api-reference/endpoints/secret-rotations/aws-iam-user-secret/get-generated-credentials-by-id

GET /api/v2/secret-rotations/aws-iam-user-secret/{rotationId}/generated-credentials
Get the generated credentials for the specified AWS IAM User Secret Rotation.



# List
Source: https://infisical.com/docs/api-reference/endpoints/secret-rotations/aws-iam-user-secret/list

GET /api/v2/secret-rotations/aws-iam-user-secret
List the AWS IAM User Secret Rotations for the specified project.



# Rotate Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-rotations/aws-iam-user-secret/rotate-secrets

POST /api/v2/secret-rotations/aws-iam-user-secret/{rotationId}/rotate-secrets
Rotate the generated credentials for the specified AWS IAM User Secret Rotation.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/secret-rotations/aws-iam-user-secret/update

PATCH /api/v2/secret-rotations/aws-iam-user-secret/{rotationId}
Update the specified AWS IAM User Secret Rotation.

<Note>
  Check out the configuration docs for [AWS IAM User Secret Rotations](/documentation/platform/secret-rotation/aws-iam-user-secret) to learn how to obtain the
  required parameters.
</Note>


# Create
Source: https://infisical.com/docs/api-reference/endpoints/secret-rotations/azure-client-secret/create

POST /api/v2/secret-rotations/azure-client-secret
Create an Azure Client Secret Rotation for the specified project.

<Note>
  Check out the configuration docs for [Azure Client Secret Rotations](/documentation/platform/secret-rotation/azure-client-secret) to learn how to obtain the
  required parameters.
</Note>


# Delete
Source: https://infisical.com/docs/api-reference/endpoints/secret-rotations/azure-client-secret/delete

DELETE /api/v2/secret-rotations/azure-client-secret/{rotationId}
Delete the specified Azure Client Secret Rotation.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/secret-rotations/azure-client-secret/get-by-id

GET /api/v2/secret-rotations/azure-client-secret/{rotationId}
Get the specified Azure Client Secret Rotation by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/secret-rotations/azure-client-secret/get-by-name

GET /api/v2/secret-rotations/azure-client-secret/rotation-name/{rotationName}
Get the specified Azure Client Secret Rotation by name, secret path, environment and project ID.



# Get Credentials by ID
Source: https://infisical.com/docs/api-reference/endpoints/secret-rotations/azure-client-secret/get-generated-credentials-by-id

GET /api/v2/secret-rotations/azure-client-secret/{rotationId}/generated-credentials
Get the generated credentials for the specified Azure Client Secret Rotation.



# List
Source: https://infisical.com/docs/api-reference/endpoints/secret-rotations/azure-client-secret/list

GET /api/v2/secret-rotations/azure-client-secret
List the Azure Client Secret Rotations for the specified project.



# Rotate Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-rotations/azure-client-secret/rotate-secrets

POST /api/v2/secret-rotations/azure-client-secret/{rotationId}/rotate-secrets
Rotate the generated credentials for the specified Azure Client Secret Rotation.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/secret-rotations/azure-client-secret/update

PATCH /api/v2/secret-rotations/azure-client-secret/{rotationId}
Update the specified Azure Client Secret Rotation.

<Note>
  Check out the configuration docs for [Azure Client Secret Rotations](/documentation/platform/secret-rotation/azure-client-secret) to learn how to obtain the
  required parameters.
</Note>


# Create
Source: https://infisical.com/docs/api-reference/endpoints/secret-rotations/ldap-password/create

POST /api/v2/secret-rotations/ldap-password
Create a LDAP Password Rotation for the specified project.

<Note>
  Check out the configuration docs for [LDAP Password Rotations](/documentation/platform/secret-rotation/ldap-password) to learn how to obtain the
  required parameters.
</Note>


# Delete
Source: https://infisical.com/docs/api-reference/endpoints/secret-rotations/ldap-password/delete

DELETE /api/v2/secret-rotations/ldap-password/{rotationId}
Delete the specified LDAP Password Rotation.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/secret-rotations/ldap-password/get-by-id

GET /api/v2/secret-rotations/ldap-password/{rotationId}
Get the specified LDAP Password Rotation by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/secret-rotations/ldap-password/get-by-name

GET /api/v2/secret-rotations/ldap-password/rotation-name/{rotationName}
Get the specified LDAP Password Rotation by name, secret path, environment and project ID.



# Get Credentials by ID
Source: https://infisical.com/docs/api-reference/endpoints/secret-rotations/ldap-password/get-generated-credentials-by-id

GET /api/v2/secret-rotations/ldap-password/{rotationId}/generated-credentials
Get the generated credentials for the specified LDAP Password Rotation.



# List
Source: https://infisical.com/docs/api-reference/endpoints/secret-rotations/ldap-password/list

GET /api/v2/secret-rotations/ldap-password
List the LDAP Password Rotations for the specified project.



# Rotate Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-rotations/ldap-password/rotate-secrets

POST /api/v2/secret-rotations/ldap-password/{rotationId}/rotate-secrets
Rotate the generated credentials for the specified LDAP Password Rotation.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/secret-rotations/ldap-password/update

PATCH /api/v2/secret-rotations/ldap-password/{rotationId}
Update the specified LDAP Password Rotation.

<Note>
  Check out the configuration docs for [LDAP Rotations](/documentation/platform/secret-rotation/ldap-password) to learn how to obtain the
  required parameters.
</Note>


# List
Source: https://infisical.com/docs/api-reference/endpoints/secret-rotations/list

GET /api/v2/secret-rotations
List all the Secret Rotations for the specified project.



# Create
Source: https://infisical.com/docs/api-reference/endpoints/secret-rotations/mssql-credentials/create

POST /api/v2/secret-rotations/mssql-credentials
Create a Microsoft SQL Server Credentials Rotation for the specified project.

<Note>
  Check out the configuration docs for [Microsoft SQL Server
  Credentials Rotations](/documentation/platform/secret-rotation/mssql-credentials) to learn how to obtain the
  required parameters.
</Note>


# Delete
Source: https://infisical.com/docs/api-reference/endpoints/secret-rotations/mssql-credentials/delete

DELETE /api/v2/secret-rotations/mssql-credentials/{rotationId}
Delete the specified Microsoft SQL Server Credentials Rotation.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/secret-rotations/mssql-credentials/get-by-id

GET /api/v2/secret-rotations/mssql-credentials/{rotationId}
Get the specified Microsoft SQL Server Credentials Rotation by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/secret-rotations/mssql-credentials/get-by-name

GET /api/v2/secret-rotations/mssql-credentials/rotation-name/{rotationName}
Get the specified Microsoft SQL Server Credentials Rotation by name, secret path, environment and project ID.



# Get Credentials by ID
Source: https://infisical.com/docs/api-reference/endpoints/secret-rotations/mssql-credentials/get-generated-credentials-by-id

GET /api/v2/secret-rotations/mssql-credentials/{rotationId}/generated-credentials
Get the generated credentials for the specified Microsoft SQL Server Credentials Rotation.



# List
Source: https://infisical.com/docs/api-reference/endpoints/secret-rotations/mssql-credentials/list

GET /api/v2/secret-rotations/mssql-credentials
List the Microsoft SQL Server Credentials Rotations for the specified project.



# Rotate Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-rotations/mssql-credentials/rotate-secrets

POST /api/v2/secret-rotations/mssql-credentials/{rotationId}/rotate-secrets
Rotate the generated credentials for the specified Microsoft SQL Server Credentials Rotation.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/secret-rotations/mssql-credentials/update

PATCH /api/v2/secret-rotations/mssql-credentials/{rotationId}
Update the specified Microsoft SQL Server Credentials Rotation.

<Note>
  Check out the configuration docs for [Microsoft SQL Server
  Credentials Rotations](/documentation/platform/secret-rotation/mssql-credentials) to learn how to obtain the
  required parameters.
</Note>


# Create
Source: https://infisical.com/docs/api-reference/endpoints/secret-rotations/mysql-credentials/create

POST /api/v2/secret-rotations/mysql-credentials
Create a MySQL Credentials Rotation for the specified project.

<Note>
  Check out the configuration docs for [MySQL Credentials Rotations](/documentation/platform/secret-rotation/mysql-credentials) to learn how to obtain the required parameters.
</Note>


# Delete
Source: https://infisical.com/docs/api-reference/endpoints/secret-rotations/mysql-credentials/delete

DELETE /api/v2/secret-rotations/mysql-credentials/{rotationId}
Delete the specified MySQL Credentials Rotation.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/secret-rotations/mysql-credentials/get-by-id

GET /api/v2/secret-rotations/mysql-credentials/{rotationId}
Get the specified MySQL Credentials Rotation by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/secret-rotations/mysql-credentials/get-by-name

GET /api/v2/secret-rotations/mysql-credentials/rotation-name/{rotationName}
Get the specified MySQL Credentials Rotation by name, secret path, environment and project ID.



# Get Credentials by ID
Source: https://infisical.com/docs/api-reference/endpoints/secret-rotations/mysql-credentials/get-generated-credentials-by-id

GET /api/v2/secret-rotations/mysql-credentials/{rotationId}/generated-credentials
Get the generated credentials for the specified MySQL Credentials Rotation.



# List
Source: https://infisical.com/docs/api-reference/endpoints/secret-rotations/mysql-credentials/list

GET /api/v2/secret-rotations/mysql-credentials
List the MySQL Credentials Rotations for the specified project.



# Rotate Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-rotations/mysql-credentials/rotate-secrets

POST /api/v2/secret-rotations/mysql-credentials/{rotationId}/rotate-secrets
Rotate the generated credentials for the specified MySQL Credentials Rotation.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/secret-rotations/mysql-credentials/update

PATCH /api/v2/secret-rotations/mysql-credentials/{rotationId}
Update the specified MySQL Credentials Rotation.

<Note>
  Check out the configuration docs for [MySQL Credentials Rotations](/documentation/platform/secret-rotation/mysql-credentials) to learn how to obtain the required parameters.
</Note>


# Create
Source: https://infisical.com/docs/api-reference/endpoints/secret-rotations/okta-client-secret/create

POST /api/v2/secret-rotations/okta-client-secret
Create an Okta Client Secret Rotation for the specified project.

<Note>
  Check out the configuration docs for [Okta Client Secret Rotations](/documentation/platform/secret-rotation/okta-client-secret) to learn how to obtain the required parameters.
</Note>


# Delete
Source: https://infisical.com/docs/api-reference/endpoints/secret-rotations/okta-client-secret/delete

DELETE /api/v2/secret-rotations/okta-client-secret/{rotationId}
Delete the specified Okta Client Secret Rotation.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/secret-rotations/okta-client-secret/get-by-id

GET /api/v2/secret-rotations/okta-client-secret/{rotationId}
Get the specified Okta Client Secret Rotation by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/secret-rotations/okta-client-secret/get-by-name

GET /api/v2/secret-rotations/okta-client-secret/rotation-name/{rotationName}
Get the specified Okta Client Secret Rotation by name, secret path, environment and project ID.



# Get Credentials by ID
Source: https://infisical.com/docs/api-reference/endpoints/secret-rotations/okta-client-secret/get-generated-credentials-by-id

GET /api/v2/secret-rotations/okta-client-secret/{rotationId}/generated-credentials
Get the generated credentials for the specified Okta Client Secret Rotation.



# List
Source: https://infisical.com/docs/api-reference/endpoints/secret-rotations/okta-client-secret/list

GET /api/v2/secret-rotations/okta-client-secret
List the Okta Client Secret Rotations for the specified project.



# Rotate Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-rotations/okta-client-secret/rotate-secrets

POST /api/v2/secret-rotations/okta-client-secret/{rotationId}/rotate-secrets
Rotate the generated credentials for the specified Okta Client Secret Rotation.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/secret-rotations/okta-client-secret/update

PATCH /api/v2/secret-rotations/okta-client-secret/{rotationId}
Update the specified Okta Client Secret Rotation.

<Note>
  Check out the configuration docs for [Okta Client Secret Rotations](/documentation/platform/secret-rotation/okta-client-secret) to learn how to obtain the required parameters.
</Note>


# Options
Source: https://infisical.com/docs/api-reference/endpoints/secret-rotations/options

GET /api/v2/secret-rotations/options
List the available Secret Rotation Options.



# Create
Source: https://infisical.com/docs/api-reference/endpoints/secret-rotations/oracledb-credentials/create

POST /api/v2/secret-rotations/oracledb-credentials
Create an OracleDB Credentials Rotation for the specified project.

<Note>
  Check out the configuration docs for [OracleDB Credentials Rotations](/documentation/platform/secret-rotation/oracledb-credentials) to learn how to obtain the required parameters.
</Note>


# Delete
Source: https://infisical.com/docs/api-reference/endpoints/secret-rotations/oracledb-credentials/delete

DELETE /api/v2/secret-rotations/oracledb-credentials/{rotationId}
Delete the specified OracleDB Credentials Rotation.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/secret-rotations/oracledb-credentials/get-by-id

GET /api/v2/secret-rotations/oracledb-credentials/{rotationId}
Get the specified OracleDB Credentials Rotation by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/secret-rotations/oracledb-credentials/get-by-name

GET /api/v2/secret-rotations/oracledb-credentials/rotation-name/{rotationName}
Get the specified OracleDB Credentials Rotation by name, secret path, environment and project ID.



# Get Credentials by ID
Source: https://infisical.com/docs/api-reference/endpoints/secret-rotations/oracledb-credentials/get-generated-credentials-by-id

GET /api/v2/secret-rotations/oracledb-credentials/{rotationId}/generated-credentials
Get the generated credentials for the specified OracleDB Credentials Rotation.



# List
Source: https://infisical.com/docs/api-reference/endpoints/secret-rotations/oracledb-credentials/list

GET /api/v2/secret-rotations/oracledb-credentials
List the OracleDB Credentials Rotations for the specified project.



# Rotate Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-rotations/oracledb-credentials/rotate-secrets

POST /api/v2/secret-rotations/oracledb-credentials/{rotationId}/rotate-secrets
Rotate the generated credentials for the specified OracleDB Credentials Rotation.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/secret-rotations/oracledb-credentials/update

PATCH /api/v2/secret-rotations/oracledb-credentials/{rotationId}
Update the specified OracleDB Credentials Rotation.

<Note>
  Check out the configuration docs for [OracleDB Credentials Rotations](/documentation/platform/secret-rotation/oracledb-credentials) to learn how to obtain the required parameters.
</Note>


# Create
Source: https://infisical.com/docs/api-reference/endpoints/secret-rotations/postgres-credentials/create

POST /api/v2/secret-rotations/postgres-credentials
Create a PostgreSQL Credentials Rotation for the specified project.

<Note>
  Check out the configuration docs for [PostgreSQL
  Credentials Rotations](/documentation/platform/secret-rotation/postgres-credentials) to learn how to obtain the
  required parameters.
</Note>


# Delete
Source: https://infisical.com/docs/api-reference/endpoints/secret-rotations/postgres-credentials/delete

DELETE /api/v2/secret-rotations/postgres-credentials/{rotationId}
Delete the specified PostgreSQL Credentials Rotation.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/secret-rotations/postgres-credentials/get-by-id

GET /api/v2/secret-rotations/postgres-credentials/{rotationId}
Get the specified PostgreSQL Credentials Rotation by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/secret-rotations/postgres-credentials/get-by-name

GET /api/v2/secret-rotations/postgres-credentials/rotation-name/{rotationName}
Get the specified PostgreSQL Credentials Rotation by name, secret path, environment and project ID.



# Get Credentials by ID
Source: https://infisical.com/docs/api-reference/endpoints/secret-rotations/postgres-credentials/get-generated-credentials-by-id

GET /api/v2/secret-rotations/postgres-credentials/{rotationId}/generated-credentials
Get the generated credentials for the specified PostgreSQL Credentials Rotation.



# List
Source: https://infisical.com/docs/api-reference/endpoints/secret-rotations/postgres-credentials/list

GET /api/v2/secret-rotations/postgres-credentials
List the PostgreSQL Credentials Rotations for the specified project.



# Rotate Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-rotations/postgres-credentials/rotate-secrets

POST /api/v2/secret-rotations/postgres-credentials/{rotationId}/rotate-secrets
Rotate the generated credentials for the specified PostgreSQL Credentials Rotation.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/secret-rotations/postgres-credentials/update

PATCH /api/v2/secret-rotations/postgres-credentials/{rotationId}
Update the specified PostgreSQL Credentials Rotation.

<Note>
  Check out the configuration docs for [PostgreSQL
  Credentials Rotations](/documentation/platform/secret-rotation/postgres-credentials) to learn how to obtain the
  required parameters.
</Note>


# Create
Source: https://infisical.com/docs/api-reference/endpoints/secret-rotations/redis-credentials/create

POST /api/v2/secret-rotations/redis-credentials
Create a Redis Credentials Rotation for the specified project.

<Note>
  Check out the configuration docs for [Redis
  Credentials Rotations](/documentation/platform/secret-rotation/redis-credentials) to learn how to obtain the
  required parameters.
</Note>


# Delete
Source: https://infisical.com/docs/api-reference/endpoints/secret-rotations/redis-credentials/delete

DELETE /api/v2/secret-rotations/redis-credentials/{rotationId}
Delete the specified Redis Credentials Rotation.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/secret-rotations/redis-credentials/get-by-id

GET /api/v2/secret-rotations/redis-credentials/{rotationId}
Get the specified Redis Credentials Rotation by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/secret-rotations/redis-credentials/get-by-name

GET /api/v2/secret-rotations/redis-credentials/rotation-name/{rotationName}
Get the specified Redis Credentials Rotation by name, secret path, environment and project ID.



# Get Credentials by ID
Source: https://infisical.com/docs/api-reference/endpoints/secret-rotations/redis-credentials/get-generated-credentials-by-id

GET /api/v2/secret-rotations/redis-credentials/{rotationId}/generated-credentials
Get the generated credentials for the specified Redis Credentials Rotation.



# List
Source: https://infisical.com/docs/api-reference/endpoints/secret-rotations/redis-credentials/list

GET /api/v2/secret-rotations/redis-credentials
List the Redis Credentials Rotations for the specified project.



# Rotate Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-rotations/redis-credentials/rotate-secrets

POST /api/v2/secret-rotations/redis-credentials/{rotationId}/rotate-secrets
Rotate the generated credentials for the specified Redis Credentials Rotation.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/secret-rotations/redis-credentials/update

PATCH /api/v2/secret-rotations/redis-credentials/{rotationId}
Update the specified Redis Credentials Rotation.

<Note>
  Check out the configuration docs for [Redis
  Credentials Rotations](/documentation/platform/secret-rotation/redis-credentials) to learn how to obtain the
  required parameters.
</Note>


# Get by Project ID
Source: https://infisical.com/docs/api-reference/endpoints/secret-scanning/config/get-by-project-id

GET /api/v2/secret-scanning/configs
Get the Secret Scanning Config for the specified project.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/secret-scanning/config/update

PATCH /api/v2/secret-scanning/configs
Update the specified Secret Scanning Configuration.

<Note>
  Check out the [Configuration Docs](/documentation/platform/secret-scanning/overview#configuration) for an in-depth guide on custom configurations.
</Note>


# Create
Source: https://infisical.com/docs/api-reference/endpoints/secret-scanning/data-sources/bitbucket/create

POST /api/v2/secret-scanning/data-sources/bitbucket
Create a Bitbucket Data Source for the specified project.



# Delete
Source: https://infisical.com/docs/api-reference/endpoints/secret-scanning/data-sources/bitbucket/delete

DELETE /api/v2/secret-scanning/data-sources/bitbucket/{dataSourceId}
Delete the specified Bitbucket Data Source.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/secret-scanning/data-sources/bitbucket/get-by-id

GET /api/v2/secret-scanning/data-sources/bitbucket/{dataSourceId}
Get the specified Bitbucket Data Source by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/secret-scanning/data-sources/bitbucket/get-by-name

GET /api/v2/secret-scanning/data-sources/bitbucket/data-source-name/{dataSourceName}
Get the specified Bitbucket Data Source by name and project ID.



# List
Source: https://infisical.com/docs/api-reference/endpoints/secret-scanning/data-sources/bitbucket/list

GET /api/v2/secret-scanning/data-sources/bitbucket
List the Bitbucket Data Sources for the specified project.



# List Resources
Source: https://infisical.com/docs/api-reference/endpoints/secret-scanning/data-sources/bitbucket/list-resources

GET /api/v2/secret-scanning/data-sources/bitbucket/{dataSourceId}/resources
Get the resources associated with the specified Bitbucket Data Source by ID.



# List Scans
Source: https://infisical.com/docs/api-reference/endpoints/secret-scanning/data-sources/bitbucket/list-scans

GET /api/v2/secret-scanning/data-sources/bitbucket/{dataSourceId}/scans
Get the scans associated with the specified Bitbucket Data Source by ID.



# Scan
Source: https://infisical.com/docs/api-reference/endpoints/secret-scanning/data-sources/bitbucket/scan

POST /api/v2/secret-scanning/data-sources/bitbucket/{dataSourceId}/scan
Trigger a scan for the specified Bitbucket Data Source.



# Scan Resource
Source: https://infisical.com/docs/api-reference/endpoints/secret-scanning/data-sources/bitbucket/scan-resource

POST /api/v2/secret-scanning/data-sources/bitbucket/{dataSourceId}/resources/{resourceId}/scan
Trigger a scan for the specified Bitbucket Data Source resource.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/secret-scanning/data-sources/bitbucket/update

PATCH /api/v2/secret-scanning/data-sources/bitbucket/{dataSourceId}
Update the specified Bitbucket Data Source.



# Create
Source: https://infisical.com/docs/api-reference/endpoints/secret-scanning/data-sources/github/create

POST /api/v2/secret-scanning/data-sources/github
Create a GitHub Data Source for the specified project.



# Delete
Source: https://infisical.com/docs/api-reference/endpoints/secret-scanning/data-sources/github/delete

DELETE /api/v2/secret-scanning/data-sources/github/{dataSourceId}
Delete the specified GitHub Data Source.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/secret-scanning/data-sources/github/get-by-id

GET /api/v2/secret-scanning/data-sources/github/{dataSourceId}
Get the specified GitHub Data Source by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/secret-scanning/data-sources/github/get-by-name

GET /api/v2/secret-scanning/data-sources/github/data-source-name/{dataSourceName}
Get the specified GitHub Data Source by name and project ID.



# List
Source: https://infisical.com/docs/api-reference/endpoints/secret-scanning/data-sources/github/list

GET /api/v2/secret-scanning/data-sources/github
List the GitHub Data Sources for the specified project.



# List Resources
Source: https://infisical.com/docs/api-reference/endpoints/secret-scanning/data-sources/github/list-resources

GET /api/v2/secret-scanning/data-sources/github/{dataSourceId}/resources
Get the resources associated with the specified GitHub Data Source by ID.



# List Scans
Source: https://infisical.com/docs/api-reference/endpoints/secret-scanning/data-sources/github/list-scans

GET /api/v2/secret-scanning/data-sources/github/{dataSourceId}/scans
Get the scans associated with the specified GitHub Data Source by ID.



# Scan
Source: https://infisical.com/docs/api-reference/endpoints/secret-scanning/data-sources/github/scan

POST /api/v2/secret-scanning/data-sources/github/{dataSourceId}/scan
Trigger a scan for the specified GitHub Data Source.



# Scan Resource
Source: https://infisical.com/docs/api-reference/endpoints/secret-scanning/data-sources/github/scan-resource

POST /api/v2/secret-scanning/data-sources/github/{dataSourceId}/resources/{resourceId}/scan
Trigger a scan for the specified GitHub Data Source resource.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/secret-scanning/data-sources/github/update

PATCH /api/v2/secret-scanning/data-sources/github/{dataSourceId}
Update the specified GitHub Data Source.



# Create
Source: https://infisical.com/docs/api-reference/endpoints/secret-scanning/data-sources/gitlab/create

POST /api/v2/secret-scanning/data-sources/gitlab
Create a GitLab Data Source for the specified project.



# Delete
Source: https://infisical.com/docs/api-reference/endpoints/secret-scanning/data-sources/gitlab/delete

DELETE /api/v2/secret-scanning/data-sources/gitlab/{dataSourceId}
Delete the specified GitLab Data Source.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/secret-scanning/data-sources/gitlab/get-by-id

GET /api/v2/secret-scanning/data-sources/gitlab/{dataSourceId}
Get the specified GitLab Data Source by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/secret-scanning/data-sources/gitlab/get-by-name

GET /api/v2/secret-scanning/data-sources/gitlab/data-source-name/{dataSourceName}
Get the specified GitLab Data Source by name and project ID.



# List
Source: https://infisical.com/docs/api-reference/endpoints/secret-scanning/data-sources/gitlab/list

GET /api/v2/secret-scanning/data-sources/gitlab
List the GitLab Data Sources for the specified project.



# List Resources
Source: https://infisical.com/docs/api-reference/endpoints/secret-scanning/data-sources/gitlab/list-resources

GET /api/v2/secret-scanning/data-sources/gitlab/{dataSourceId}/resources
Get the resources associated with the specified GitLab Data Source by ID.



# List Scans
Source: https://infisical.com/docs/api-reference/endpoints/secret-scanning/data-sources/gitlab/list-scans

GET /api/v2/secret-scanning/data-sources/gitlab/{dataSourceId}/scans
Get the scans associated with the specified GitLab Data Source by ID.



# Scan
Source: https://infisical.com/docs/api-reference/endpoints/secret-scanning/data-sources/gitlab/scan

POST /api/v2/secret-scanning/data-sources/gitlab/{dataSourceId}/scan
Trigger a scan for the specified GitLab Data Source.



# Scan Resource
Source: https://infisical.com/docs/api-reference/endpoints/secret-scanning/data-sources/gitlab/scan-resource

POST /api/v2/secret-scanning/data-sources/gitlab/{dataSourceId}/resources/{resourceId}/scan
Trigger a scan for the specified GitLab Data Source resource.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/secret-scanning/data-sources/gitlab/update

PATCH /api/v2/secret-scanning/data-sources/gitlab/{dataSourceId}
Update the specified GitLab Data Source.



# List
Source: https://infisical.com/docs/api-reference/endpoints/secret-scanning/data-sources/list

GET /api/v2/secret-scanning/data-sources
List all the Secret Scanning Data Sources for the specified project.



# Options
Source: https://infisical.com/docs/api-reference/endpoints/secret-scanning/data-sources/options

GET /api/v2/secret-scanning/data-sources/options
List the available Secret Scanning Data Source Options.



# List
Source: https://infisical.com/docs/api-reference/endpoints/secret-scanning/findings/list

GET /api/v2/secret-scanning/findings
List all the Secret Scanning Findings for the specified project.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/secret-scanning/findings/update

PATCH /api/v2/secret-scanning/findings/{findingId}
Update the specified Secret Scanning Finding.



# Create
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/1password/create

POST /api/v1/secret-syncs/1password
Create a 1Password Sync for the specified project environment.



# Delete
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/1password/delete

DELETE /api/v1/secret-syncs/1password/{syncId}
Delete the specified 1Password Sync.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/1password/get-by-id

GET /api/v1/secret-syncs/1password/{syncId}
Get the specified 1Password Sync by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/1password/get-by-name

GET /api/v1/secret-syncs/1password/sync-name/{syncName}
Get the specified 1Password Sync by name and project ID.



# Import Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/1password/import-secrets

POST /api/v1/secret-syncs/1password/{syncId}/import-secrets
Import secrets from the specified 1Password Sync destination.



# List
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/1password/list

GET /api/v1/secret-syncs/1password
List the 1Password Syncs for the specified project.



# Remove Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/1password/remove-secrets

POST /api/v1/secret-syncs/1password/{syncId}/remove-secrets
Remove previously synced secrets from the specified 1Password Sync destination.



# Sync Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/1password/sync-secrets

POST /api/v1/secret-syncs/1password/{syncId}/sync-secrets
Trigger a sync for the specified 1Password Sync.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/1password/update

PATCH /api/v1/secret-syncs/1password/{syncId}
Update the specified 1Password Sync.



# Create
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/aws-parameter-store/create

POST /api/v1/secret-syncs/aws-parameter-store
Create an AWS Parameter Store Sync for the specified project environment.



# Delete
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/aws-parameter-store/delete

DELETE /api/v1/secret-syncs/aws-parameter-store/{syncId}
Delete the specified AWS Parameter Store Sync.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/aws-parameter-store/get-by-id

GET /api/v1/secret-syncs/aws-parameter-store/{syncId}
Get the specified AWS Parameter Store Sync by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/aws-parameter-store/get-by-name

GET /api/v1/secret-syncs/aws-parameter-store/sync-name/{syncName}
Get the specified AWS Parameter Store Sync by name and project ID.



# Import Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/aws-parameter-store/import-secrets

POST /api/v1/secret-syncs/aws-parameter-store/{syncId}/import-secrets
Import secrets from the specified AWS Parameter Store Sync destination.



# List
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/aws-parameter-store/list

GET /api/v1/secret-syncs/aws-parameter-store
List the AWS Parameter Store Syncs for the specified project.



# Remove Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/aws-parameter-store/remove-secrets

POST /api/v1/secret-syncs/aws-parameter-store/{syncId}/remove-secrets
Remove previously synced secrets from the specified AWS Parameter Store Sync destination.



# Sync Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/aws-parameter-store/sync-secrets

POST /api/v1/secret-syncs/aws-parameter-store/{syncId}/sync-secrets
Trigger a sync for the specified AWS Parameter Store Sync.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/aws-parameter-store/update

PATCH /api/v1/secret-syncs/aws-parameter-store/{syncId}
Update the specified AWS Parameter Store Sync.



# Create
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/aws-secrets-manager/create

POST /api/v1/secret-syncs/aws-secrets-manager
Create an AWS Secrets Manager Sync for the specified project environment.



# Delete
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/aws-secrets-manager/delete

DELETE /api/v1/secret-syncs/aws-secrets-manager/{syncId}
Delete the specified AWS Secrets Manager Sync.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/aws-secrets-manager/get-by-id

GET /api/v1/secret-syncs/aws-secrets-manager/{syncId}
Get the specified AWS Secrets Manager Sync by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/aws-secrets-manager/get-by-name

GET /api/v1/secret-syncs/aws-secrets-manager/sync-name/{syncName}
Get the specified AWS Secrets Manager Sync by name and project ID.



# Import Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/aws-secrets-manager/import-secrets

POST /api/v1/secret-syncs/aws-secrets-manager/{syncId}/import-secrets
Import secrets from the specified AWS Secrets Manager Sync destination.



# List
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/aws-secrets-manager/list

GET /api/v1/secret-syncs/aws-secrets-manager
List the AWS Secrets Manager Syncs for the specified project.



# Remove Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/aws-secrets-manager/remove-secrets

POST /api/v1/secret-syncs/aws-secrets-manager/{syncId}/remove-secrets
Remove previously synced secrets from the specified AWS Secrets Manager Sync destination.



# Sync Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/aws-secrets-manager/sync-secrets

POST /api/v1/secret-syncs/aws-secrets-manager/{syncId}/sync-secrets
Trigger a sync for the specified AWS Secrets Manager Sync.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/aws-secrets-manager/update

PATCH /api/v1/secret-syncs/aws-secrets-manager/{syncId}
Update the specified AWS Secrets Manager Sync.



# Create
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/azure-app-configuration/create

POST /api/v1/secret-syncs/azure-app-configuration
Create an Azure App Configuration Sync for the specified project environment.



# Delete
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/azure-app-configuration/delete

DELETE /api/v1/secret-syncs/azure-app-configuration/{syncId}
Delete the specified Azure App Configuration Sync.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/azure-app-configuration/get-by-id

GET /api/v1/secret-syncs/azure-app-configuration/{syncId}
Get the specified Azure App Configuration Sync by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/azure-app-configuration/get-by-name

GET /api/v1/secret-syncs/azure-app-configuration/sync-name/{syncName}
Get the specified Azure App Configuration Sync by name and project ID.



# Import Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/azure-app-configuration/import-secrets

POST /api/v1/secret-syncs/azure-app-configuration/{syncId}/import-secrets
Import secrets from the specified Azure App Configuration Sync destination.



# List
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/azure-app-configuration/list

GET /api/v1/secret-syncs/azure-app-configuration
List the Azure App Configuration Syncs for the specified project.



# Remove Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/azure-app-configuration/remove-secrets

POST /api/v1/secret-syncs/azure-app-configuration/{syncId}/remove-secrets
Remove previously synced secrets from the specified Azure App Configuration Sync destination.



# Sync Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/azure-app-configuration/sync-secrets

POST /api/v1/secret-syncs/azure-app-configuration/{syncId}/sync-secrets
Trigger a sync for the specified Azure App Configuration Sync.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/azure-app-configuration/update

PATCH /api/v1/secret-syncs/azure-app-configuration/{syncId}
Update the specified Azure App Configuration Sync.



# Create
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/azure-devops/create

POST /api/v1/secret-syncs/azure-devops
Create an Azure DevOps Sync for the specified project environment.



# Delete
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/azure-devops/delete

DELETE /api/v1/secret-syncs/azure-devops/{syncId}
Delete the specified Azure DevOps Sync.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/azure-devops/get-by-id

GET /api/v1/secret-syncs/azure-devops/{syncId}
Get the specified Azure DevOps Sync by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/azure-devops/get-by-name

GET /api/v1/secret-syncs/azure-devops/sync-name/{syncName}
Get the specified Azure DevOps Sync by name and project ID.



# Import Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/azure-devops/import-secrets

POST /api/v1/secret-syncs/azure-devops/{syncId}/import-secrets
Import secrets from the specified Azure DevOps Sync destination.



# List
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/azure-devops/list

GET /api/v1/secret-syncs/azure-devops
List the Azure DevOps Syncs for the specified project.



# Remove Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/azure-devops/remove-secrets

POST /api/v1/secret-syncs/azure-devops/{syncId}/remove-secrets
Remove previously synced secrets from the specified Azure DevOps Sync destination.



# Sync Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/azure-devops/sync-secrets

POST /api/v1/secret-syncs/azure-devops/{syncId}/sync-secrets
Trigger a sync for the specified Azure DevOps Sync.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/azure-devops/update

PATCH /api/v1/secret-syncs/azure-devops/{syncId}
Update the specified Azure DevOps Sync.



# Create
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/azure-key-vault/create

POST /api/v1/secret-syncs/azure-key-vault
Create an Azure Key Vault Sync for the specified project environment.



# Delete
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/azure-key-vault/delete

DELETE /api/v1/secret-syncs/azure-key-vault/{syncId}
Delete the specified Azure Key Vault Sync.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/azure-key-vault/get-by-id

GET /api/v1/secret-syncs/azure-key-vault/{syncId}
Get the specified Azure Key Vault Sync by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/azure-key-vault/get-by-name

GET /api/v1/secret-syncs/azure-key-vault/sync-name/{syncName}
Get the specified Azure Key Vault Sync by name and project ID.



# Import Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/azure-key-vault/import-secrets

POST /api/v1/secret-syncs/azure-key-vault/{syncId}/import-secrets
Import secrets from the specified Azure Key Vault Sync destination.



# List
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/azure-key-vault/list

GET /api/v1/secret-syncs/azure-key-vault
List the Azure Key Vault Syncs for the specified project.



# Remove Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/azure-key-vault/remove-secrets

POST /api/v1/secret-syncs/azure-key-vault/{syncId}/remove-secrets
Remove previously synced secrets from the specified Azure Key Vault Sync destination.



# Sync Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/azure-key-vault/sync-secrets

POST /api/v1/secret-syncs/azure-key-vault/{syncId}/sync-secrets
Trigger a sync for the specified Azure Key Vault Sync.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/azure-key-vault/update

PATCH /api/v1/secret-syncs/azure-key-vault/{syncId}
Update the specified Azure Key Vault Sync.



# Create
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/bitbucket/create

POST /api/v1/secret-syncs/bitbucket
Create a Bitbucket Sync for the specified project environment.



# Delete
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/bitbucket/delete

DELETE /api/v1/secret-syncs/bitbucket/{syncId}
Delete the specified Bitbucket Sync.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/bitbucket/get-by-id

GET /api/v1/secret-syncs/bitbucket/{syncId}
Get the specified Bitbucket Sync by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/bitbucket/get-by-name

GET /api/v1/secret-syncs/bitbucket/sync-name/{syncName}
Get the specified Bitbucket Sync by name and project ID.



# Import Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/bitbucket/import-secrets

POST /api/v1/secret-syncs/bitbucket/{syncId}/import-secrets
Import secrets from the specified Bitbucket Sync destination.



# List
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/bitbucket/list

GET /api/v1/secret-syncs/bitbucket
List the Bitbucket Syncs for the specified project.



# Remove Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/bitbucket/remove-secrets

POST /api/v1/secret-syncs/bitbucket/{syncId}/remove-secrets
Remove previously synced secrets from the specified Bitbucket Sync destination.



# Sync Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/bitbucket/sync-secrets

POST /api/v1/secret-syncs/bitbucket/{syncId}/sync-secrets
Trigger a sync for the specified Bitbucket Sync.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/bitbucket/update

PATCH /api/v1/secret-syncs/bitbucket/{syncId}
Update the specified Bitbucket Sync.



# Create
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/camunda/create

POST /api/v1/secret-syncs/camunda
Create a Camunda Sync for the specified project environment.



# Delete
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/camunda/delete

DELETE /api/v1/secret-syncs/camunda/{syncId}
Delete the specified Camunda Sync.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/camunda/get-by-id

GET /api/v1/secret-syncs/camunda/{syncId}
Get the specified Camunda Sync by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/camunda/get-by-name

GET /api/v1/secret-syncs/camunda/sync-name/{syncName}
Get the specified Camunda Sync by name and project ID.



# List
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/camunda/list

GET /api/v1/secret-syncs/camunda
List the Camunda Syncs for the specified project.



# Remove Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/camunda/remove-secrets

POST /api/v1/secret-syncs/camunda/{syncId}/remove-secrets
Remove previously synced secrets from the specified Camunda Sync destination.



# Sync Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/camunda/sync-secrets

POST /api/v1/secret-syncs/camunda/{syncId}/sync-secrets
Trigger a sync for the specified Camunda Sync.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/camunda/update

PATCH /api/v1/secret-syncs/camunda/{syncId}
Update the specified Camunda Sync.



# Create
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/checkly/create

POST /api/v1/secret-syncs/checkly
Create a Checkly Sync for the specified project environment.



# Delete
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/checkly/delete

DELETE /api/v1/secret-syncs/checkly/{syncId}
Delete the specified Checkly Sync.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/checkly/get-by-id

GET /api/v1/secret-syncs/checkly/{syncId}
Get the specified Checkly Sync by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/checkly/get-by-name

GET /api/v1/secret-syncs/checkly/sync-name/{syncName}
Get the specified Checkly Sync by name and project ID.



# List
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/checkly/list

GET /api/v1/secret-syncs/checkly
List the Checkly Syncs for the specified project.



# Remove Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/checkly/remove-secrets

POST /api/v1/secret-syncs/checkly/{syncId}/remove-secrets
Remove previously synced secrets from the specified Checkly Sync destination.



# Sync Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/checkly/sync-secrets

POST /api/v1/secret-syncs/checkly/{syncId}/sync-secrets
Trigger a sync for the specified Checkly Sync.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/checkly/update

PATCH /api/v1/secret-syncs/checkly/{syncId}
Update the specified Checkly Sync.



# Create
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/chef/create

POST /api/v1/secret-syncs/chef
Create a Chef Sync for the specified project environment.



# Delete
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/chef/delete

DELETE /api/v1/secret-syncs/chef/{syncId}
Delete the specified Chef Sync.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/chef/get-by-id

GET /api/v1/secret-syncs/chef/{syncId}
Get the specified Chef Sync by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/chef/get-by-name

GET /api/v1/secret-syncs/chef/sync-name/{syncName}
Get the specified Chef Sync by name and project ID.



# Import Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/chef/import-secrets

POST /api/v1/secret-syncs/chef/{syncId}/import-secrets
Import secrets from the specified Chef Sync destination.



# List
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/chef/list

GET /api/v1/secret-syncs/chef
List the Chef Syncs for the specified project.



# Remove Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/chef/remove-secrets

POST /api/v1/secret-syncs/chef/{syncId}/remove-secrets
Remove previously synced secrets from the specified Chef Sync destination.



# Sync Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/chef/sync-secrets

POST /api/v1/secret-syncs/chef/{syncId}/sync-secrets
Trigger a sync for the specified Chef Sync.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/chef/update

PATCH /api/v1/secret-syncs/chef/{syncId}
Update the specified Chef Sync.



# Create
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/cloudflare-pages/create

POST /api/v1/secret-syncs/cloudflare-pages
Create a Cloudflare Pages Sync for the specified project environment.



# Delete
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/cloudflare-pages/delete

DELETE /api/v1/secret-syncs/cloudflare-pages/{syncId}
Delete the specified Cloudflare Pages Sync.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/cloudflare-pages/get-by-id

GET /api/v1/secret-syncs/cloudflare-pages/{syncId}
Get the specified Cloudflare Pages Sync by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/cloudflare-pages/get-by-name

GET /api/v1/secret-syncs/cloudflare-pages/sync-name/{syncName}
Get the specified Cloudflare Pages Sync by name and project ID.



# List
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/cloudflare-pages/list

GET /api/v1/secret-syncs/cloudflare-pages
List the Cloudflare Pages Syncs for the specified project.



# Remove Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/cloudflare-pages/remove-secrets

POST /api/v1/secret-syncs/cloudflare-pages/{syncId}/remove-secrets
Remove previously synced secrets from the specified Cloudflare Pages Sync destination.



# Sync Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/cloudflare-pages/sync-secrets

POST /api/v1/secret-syncs/cloudflare-pages/{syncId}/sync-secrets
Trigger a sync for the specified Cloudflare Pages Sync.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/cloudflare-pages/update

PATCH /api/v1/secret-syncs/cloudflare-pages/{syncId}
Update the specified Cloudflare Pages Sync.



# Create
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/cloudflare-workers/create

POST /api/v1/secret-syncs/cloudflare-workers
Create a Cloudflare Workers Sync for the specified project environment.



# Delete
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/cloudflare-workers/delete

DELETE /api/v1/secret-syncs/cloudflare-workers/{syncId}
Delete the specified Cloudflare Workers Sync.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/cloudflare-workers/get-by-id

GET /api/v1/secret-syncs/cloudflare-workers/{syncId}
Get the specified Cloudflare Workers Sync by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/cloudflare-workers/get-by-name

GET /api/v1/secret-syncs/cloudflare-workers/sync-name/{syncName}
Get the specified Cloudflare Workers Sync by name and project ID.



# List
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/cloudflare-workers/list

GET /api/v1/secret-syncs/cloudflare-workers
List the Cloudflare Workers Syncs for the specified project.



# Remove Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/cloudflare-workers/remove-secrets

POST /api/v1/secret-syncs/cloudflare-workers/{syncId}/remove-secrets
Remove previously synced secrets from the specified Cloudflare Workers Sync destination.



# Sync Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/cloudflare-workers/sync-secrets

POST /api/v1/secret-syncs/cloudflare-workers/{syncId}/sync-secrets
Trigger a sync for the specified Cloudflare Workers Sync.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/cloudflare-workers/update

PATCH /api/v1/secret-syncs/cloudflare-workers/{syncId}
Update the specified Cloudflare Workers Sync.



# Create
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/databricks/create

POST /api/v1/secret-syncs/databricks
Create a Databricks Sync for the specified project environment.



# Delete
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/databricks/delete

DELETE /api/v1/secret-syncs/databricks/{syncId}
Delete the specified Databricks Sync.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/databricks/get-by-id

GET /api/v1/secret-syncs/databricks/{syncId}
Get the specified Databricks Sync by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/databricks/get-by-name

GET /api/v1/secret-syncs/databricks/sync-name/{syncName}
Get the specified Databricks Sync by name and project ID.



# List
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/databricks/list

GET /api/v1/secret-syncs/databricks
List the Databricks Syncs for the specified project.



# Remove Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/databricks/remove-secrets

POST /api/v1/secret-syncs/databricks/{syncId}/remove-secrets
Remove previously synced secrets from the specified Databricks Sync destination.



# Sync Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/databricks/sync-secrets

POST /api/v1/secret-syncs/databricks/{syncId}/sync-secrets
Trigger a sync for the specified Databricks Sync.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/databricks/update

PATCH /api/v1/secret-syncs/databricks/{syncId}
Update the specified Databricks Sync.



# Create
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/digital-ocean-app-platform/create

POST /api/v1/secret-syncs/digital-ocean-app-platform
Create a Digital Ocean App Platform Sync for the specified project environment.



# Delete
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/digital-ocean-app-platform/delete

DELETE /api/v1/secret-syncs/digital-ocean-app-platform/{syncId}
Delete the specified Digital Ocean App Platform Sync.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/digital-ocean-app-platform/get-by-id

GET /api/v1/secret-syncs/digital-ocean-app-platform/{syncId}
Get the specified Digital Ocean App Platform Sync by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/digital-ocean-app-platform/get-by-name

GET /api/v1/secret-syncs/digital-ocean-app-platform/sync-name/{syncName}
Get the specified Digital Ocean App Platform Sync by name and project ID.



# List
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/digital-ocean-app-platform/list

GET /api/v1/secret-syncs/digital-ocean-app-platform
List the Digital Ocean App Platform Syncs for the specified project.



# Remove Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/digital-ocean-app-platform/remove-secrets

POST /api/v1/secret-syncs/digital-ocean-app-platform/{syncId}/remove-secrets
Remove previously synced secrets from the specified Digital Ocean App Platform Sync destination.



# Sync Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/digital-ocean-app-platform/sync-secrets

POST /api/v1/secret-syncs/digital-ocean-app-platform/{syncId}/sync-secrets
Trigger a sync for the specified Digital Ocean App Platform Sync.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/digital-ocean-app-platform/update

PATCH /api/v1/secret-syncs/digital-ocean-app-platform/{syncId}
Update the specified Digital Ocean App Platform Sync.



# Create
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/flyio/create

POST /api/v1/secret-syncs/flyio
Create a Fly.io Sync for the specified project environment.



# Delete
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/flyio/delete

DELETE /api/v1/secret-syncs/flyio/{syncId}
Delete the specified Fly.io Sync.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/flyio/get-by-id

GET /api/v1/secret-syncs/flyio/{syncId}
Get the specified Fly.io Sync by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/flyio/get-by-name

GET /api/v1/secret-syncs/flyio/sync-name/{syncName}
Get the specified Fly.io Sync by name and project ID.



# List
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/flyio/list

GET /api/v1/secret-syncs/flyio
List the Fly.io Syncs for the specified project.



# Remove Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/flyio/remove-secrets

POST /api/v1/secret-syncs/flyio/{syncId}/remove-secrets
Remove previously synced secrets from the specified Fly.io Sync destination.



# Sync Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/flyio/sync-secrets

POST /api/v1/secret-syncs/flyio/{syncId}/sync-secrets
Trigger a sync for the specified Fly.io Sync.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/flyio/update

PATCH /api/v1/secret-syncs/flyio/{syncId}
Update the specified Fly.io Sync.



# Create
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/gcp-secret-manager/create

POST /api/v1/secret-syncs/gcp-secret-manager
Create a GCP Secret Manager Sync for the specified project environment.



# Delete
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/gcp-secret-manager/delete

DELETE /api/v1/secret-syncs/gcp-secret-manager/{syncId}
Delete the specified GCP Secret Manager Sync.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/gcp-secret-manager/get-by-id

GET /api/v1/secret-syncs/gcp-secret-manager/{syncId}
Get the specified GCP Secret Manager Sync by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/gcp-secret-manager/get-by-name

GET /api/v1/secret-syncs/gcp-secret-manager/sync-name/{syncName}
Get the specified GCP Secret Manager Sync by name and project ID.



# Import Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/gcp-secret-manager/import-secrets

POST /api/v1/secret-syncs/gcp-secret-manager/{syncId}/import-secrets
Import secrets from the specified GCP Secret Manager Sync destination.



# List
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/gcp-secret-manager/list

GET /api/v1/secret-syncs/gcp-secret-manager
List the GCP Secret Manager Syncs for the specified project.



# Remove Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/gcp-secret-manager/remove-secrets

POST /api/v1/secret-syncs/gcp-secret-manager/{syncId}/remove-secrets
Remove previously synced secrets from the specified GCP Secret Manager Sync destination.



# Sync Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/gcp-secret-manager/sync-secrets

POST /api/v1/secret-syncs/gcp-secret-manager/{syncId}/sync-secrets
Trigger a sync for the specified GCP Secret Manager Sync.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/gcp-secret-manager/update

PATCH /api/v1/secret-syncs/gcp-secret-manager/{syncId}
Update the specified GCP Secret Manager Sync.



# Create
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/github/create

POST /api/v1/secret-syncs/github
Create a GitHub Sync for the specified project environment.



# Delete
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/github/delete

DELETE /api/v1/secret-syncs/github/{syncId}
Delete the specified GitHub Sync.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/github/get-by-id

GET /api/v1/secret-syncs/github/{syncId}
Get the specified GitHub Sync by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/github/get-by-name

GET /api/v1/secret-syncs/github/sync-name/{syncName}
Get the specified GitHub Sync by name and project ID.



# List
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/github/list

GET /api/v1/secret-syncs/github
List the GitHub Syncs for the specified project.



# Remove Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/github/remove-secrets

POST /api/v1/secret-syncs/github/{syncId}/remove-secrets
Remove previously synced secrets from the specified GitHub Sync destination.



# Sync Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/github/sync-secrets

POST /api/v1/secret-syncs/github/{syncId}/sync-secrets
Trigger a sync for the specified GitHub Sync.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/github/update

PATCH /api/v1/secret-syncs/github/{syncId}
Update the specified GitHub Sync.



# Create
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/gitlab/create

POST /api/v1/secret-syncs/gitlab
Create a GitLab Sync for the specified project environment.



# Delete
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/gitlab/delete

DELETE /api/v1/secret-syncs/gitlab/{syncId}
Delete the specified GitLab Sync.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/gitlab/get-by-id

GET /api/v1/secret-syncs/gitlab/{syncId}
Get the specified GitLab Sync by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/gitlab/get-by-name

GET /api/v1/secret-syncs/gitlab/sync-name/{syncName}
Get the specified GitLab Sync by name and project ID.



# List
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/gitlab/list

GET /api/v1/secret-syncs/gitlab
List the GitLab Syncs for the specified project.



# Remove Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/gitlab/remove-secrets

POST /api/v1/secret-syncs/gitlab/{syncId}/remove-secrets
Remove previously synced secrets from the specified GitLab Sync destination.



# Sync Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/gitlab/sync-secrets

POST /api/v1/secret-syncs/gitlab/{syncId}/sync-secrets
Trigger a sync for the specified GitLab Sync.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/gitlab/update

PATCH /api/v1/secret-syncs/gitlab/{syncId}
Update the specified GitLab Sync.



# Create
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/hashicorp-vault/create

POST /api/v1/secret-syncs/hashicorp-vault
Create a Hashicorp Vault Sync for the specified project environment.



# Delete
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/hashicorp-vault/delete

DELETE /api/v1/secret-syncs/hashicorp-vault/{syncId}
Delete the specified Hashicorp Vault Sync.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/hashicorp-vault/get-by-id

GET /api/v1/secret-syncs/hashicorp-vault/{syncId}
Get the specified Hashicorp Vault Sync by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/hashicorp-vault/get-by-name

GET /api/v1/secret-syncs/hashicorp-vault/sync-name/{syncName}
Get the specified Hashicorp Vault Sync by name and project ID.



# Import Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/hashicorp-vault/import-secrets

POST /api/v1/secret-syncs/hashicorp-vault/{syncId}/import-secrets
Import secrets from the specified Hashicorp Vault Sync destination.



# List
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/hashicorp-vault/list

GET /api/v1/secret-syncs/hashicorp-vault
List the Hashicorp Vault Syncs for the specified project.



# Remove Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/hashicorp-vault/remove-secrets

POST /api/v1/secret-syncs/hashicorp-vault/{syncId}/remove-secrets
Remove previously synced secrets from the specified Hashicorp Vault Sync destination.



# Sync Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/hashicorp-vault/sync-secrets

POST /api/v1/secret-syncs/hashicorp-vault/{syncId}/sync-secrets
Trigger a sync for the specified Hashicorp Vault Sync.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/hashicorp-vault/update

PATCH /api/v1/secret-syncs/hashicorp-vault/{syncId}
Update the specified Hashicorp Vault Sync.



# Create
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/heroku/create

POST /api/v1/secret-syncs/heroku
Create a Heroku Sync for the specified project environment.



# Delete
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/heroku/delete

DELETE /api/v1/secret-syncs/heroku/{syncId}
Delete the specified Heroku Sync.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/heroku/get-by-id

GET /api/v1/secret-syncs/heroku/{syncId}
Get the specified Heroku Sync by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/heroku/get-by-name

GET /api/v1/secret-syncs/heroku/sync-name/{syncName}
Get the specified Heroku Sync by name and project ID.



# List
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/heroku/list

GET /api/v1/secret-syncs/heroku
List the Heroku Syncs for the specified project.



# Remove Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/heroku/remove-secrets

POST /api/v1/secret-syncs/heroku/{syncId}/remove-secrets
Remove previously synced secrets from the specified Heroku Sync destination.



# Sync Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/heroku/sync-secrets

POST /api/v1/secret-syncs/heroku/{syncId}/sync-secrets
Trigger a sync for the specified Heroku Sync.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/heroku/update

PATCH /api/v1/secret-syncs/heroku/{syncId}
Update the specified Heroku Sync.



# Create
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/humanitec/create

POST /api/v1/secret-syncs/humanitec
Create a Humanitec Sync for the specified project environment.



# Delete
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/humanitec/delete

DELETE /api/v1/secret-syncs/humanitec/{syncId}
Delete the specified Humanitec Sync.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/humanitec/get-by-id

GET /api/v1/secret-syncs/humanitec/{syncId}
Get the specified Humanitec Sync by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/humanitec/get-by-name

GET /api/v1/secret-syncs/humanitec/sync-name/{syncName}
Get the specified Humanitec Sync by name and project ID.



# List
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/humanitec/list

GET /api/v1/secret-syncs/humanitec
List the Humanitec Syncs for the specified project.



# Remove Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/humanitec/remove-secrets

POST /api/v1/secret-syncs/humanitec/{syncId}/remove-secrets
Remove previously synced secrets from the specified Humanitec Sync destination.



# Sync Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/humanitec/sync-secrets

POST /api/v1/secret-syncs/humanitec/{syncId}/sync-secrets
Trigger a sync for the specified Humanitec Sync.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/humanitec/update

PATCH /api/v1/secret-syncs/humanitec/{syncId}
Update the specified Humanitec Sync.



# Create
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/laravel-forge/create

POST /api/v1/secret-syncs/laravel-forge
Create a Laravel Forge Sync for the specified project environment.



# Delete
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/laravel-forge/delete

DELETE /api/v1/secret-syncs/laravel-forge/{syncId}
Delete the specified Laravel Forge Sync.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/laravel-forge/get-by-id

GET /api/v1/secret-syncs/laravel-forge/{syncId}
Get the specified Laravel Forge Sync by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/laravel-forge/get-by-name

GET /api/v1/secret-syncs/laravel-forge/sync-name/{syncName}
Get the specified Laravel Forge Sync by name and project ID.



# Import Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/laravel-forge/import-secrets

POST /api/v1/secret-syncs/laravel-forge/{syncId}/import-secrets
Import secrets from the specified Laravel Forge Sync destination.



# List
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/laravel-forge/list

GET /api/v1/secret-syncs/laravel-forge
List the Laravel Forge Syncs for the specified project.



# Remove Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/laravel-forge/remove-secrets

POST /api/v1/secret-syncs/laravel-forge/{syncId}/remove-secrets
Remove previously synced secrets from the specified Laravel Forge Sync destination.



# Sync Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/laravel-forge/sync-secrets

POST /api/v1/secret-syncs/laravel-forge/{syncId}/sync-secrets
Trigger a sync for the specified Laravel Forge Sync.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/laravel-forge/update

PATCH /api/v1/secret-syncs/laravel-forge/{syncId}
Update the specified Laravel Forge Sync.



# List
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/list

GET /api/v1/secret-syncs
List all the Secret Syncs for the specified project.



# Create
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/netlify/create

POST /api/v1/secret-syncs/netlify
Create a Netlify Sync for the specified project environment.



# Delete
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/netlify/delete

DELETE /api/v1/secret-syncs/netlify/{syncId}
Delete the specified Netlify Sync.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/netlify/get-by-id

GET /api/v1/secret-syncs/netlify/{syncId}
Get the specified Netlify Sync by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/netlify/get-by-name

GET /api/v1/secret-syncs/netlify/sync-name/{syncName}
Get the specified Netlify Sync by name and project ID.



# List
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/netlify/list

GET /api/v1/secret-syncs/netlify
List the Netlify Syncs for the specified project.



# Remove Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/netlify/remove-secrets

POST /api/v1/secret-syncs/netlify/{syncId}/remove-secrets
Remove previously synced secrets from the specified Netlify Sync destination.



# Sync Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/netlify/sync-secrets

POST /api/v1/secret-syncs/netlify/{syncId}/sync-secrets
Trigger a sync for the specified Netlify Sync.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/netlify/update

PATCH /api/v1/secret-syncs/netlify/{syncId}
Update the specified Netlify Sync.



# Create
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/northflank/create

POST /api/v1/secret-syncs/northflank
Create a Northflank Sync for the specified project environment.



# Delete
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/northflank/delete

DELETE /api/v1/secret-syncs/northflank/{syncId}
Delete the specified Northflank Sync.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/northflank/get-by-id

GET /api/v1/secret-syncs/northflank/{syncId}
Get the specified Northflank Sync by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/northflank/get-by-name

GET /api/v1/secret-syncs/northflank/sync-name/{syncName}
Get the specified Northflank Sync by name and project ID.



# Import Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/northflank/import-secrets

POST /api/v1/secret-syncs/northflank/{syncId}/import-secrets
Import secrets from the specified Northflank Sync destination.



# List
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/northflank/list

GET /api/v1/secret-syncs/northflank
List the Northflank Syncs for the specified project.



# Remove Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/northflank/remove-secrets

POST /api/v1/secret-syncs/northflank/{syncId}/remove-secrets
Remove previously synced secrets from the specified Northflank Sync destination.



# Sync Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/northflank/sync-secrets

POST /api/v1/secret-syncs/northflank/{syncId}/sync-secrets
Trigger a sync for the specified Northflank Sync.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/northflank/update

PATCH /api/v1/secret-syncs/northflank/{syncId}
Update the specified Northflank Sync.



# Create
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/oci-vault/create

POST /api/v1/secret-syncs/oci-vault
Create an OCI Vault Sync for the specified project environment.



# Delete
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/oci-vault/delete

DELETE /api/v1/secret-syncs/oci-vault/{syncId}
Delete the specified OCI Vault Sync.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/oci-vault/get-by-id

GET /api/v1/secret-syncs/oci-vault/{syncId}
Get the specified OCI Vault Sync by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/oci-vault/get-by-name

GET /api/v1/secret-syncs/oci-vault/sync-name/{syncName}
Get the specified OCI Vault Sync by name and project ID.



# Import Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/oci-vault/import-secrets

POST /api/v1/secret-syncs/oci-vault/{syncId}/import-secrets
Import secrets from the specified OCI Vault Sync destination.



# List
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/oci-vault/list

GET /api/v1/secret-syncs/oci-vault
List the OCI Vault Syncs for the specified project.



# Remove Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/oci-vault/remove-secrets

POST /api/v1/secret-syncs/oci-vault/{syncId}/remove-secrets
Remove previously synced secrets from the specified OCI Vault Sync destination.



# Sync Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/oci-vault/sync-secrets

POST /api/v1/secret-syncs/oci-vault/{syncId}/sync-secrets
Trigger a sync for the specified OCI Vault Sync.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/oci-vault/update

PATCH /api/v1/secret-syncs/oci-vault/{syncId}
Update the specified OCI Vault Sync.



# Options
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/options

GET /api/v1/secret-syncs/options
List the available Secret Sync Options.



# Create
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/railway/create

POST /api/v1/secret-syncs/railway
Create a Railway Sync for the specified project environment.



# Delete
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/railway/delete

DELETE /api/v1/secret-syncs/railway/{syncId}
Delete the specified Railway Sync.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/railway/get-by-id

GET /api/v1/secret-syncs/railway/{syncId}
Get the specified Railway Sync by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/railway/get-by-name

GET /api/v1/secret-syncs/railway/sync-name/{syncName}
Get the specified Railway Sync by name and project ID.



# Import Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/railway/import-secrets

POST /api/v1/secret-syncs/railway/{syncId}/import-secrets
Import secrets from the specified Railway Sync destination.



# List
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/railway/list

GET /api/v1/secret-syncs/railway
List the Railway Syncs for the specified project.



# Remove Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/railway/remove-secrets

POST /api/v1/secret-syncs/railway/{syncId}/remove-secrets
Remove previously synced secrets from the specified Railway Sync destination.



# Sync Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/railway/sync-secrets

POST /api/v1/secret-syncs/railway/{syncId}/sync-secrets
Trigger a sync for the specified Railway Sync.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/railway/update

PATCH /api/v1/secret-syncs/railway/{syncId}
Update the specified Railway Sync.



# Create
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/render/create

POST /api/v1/secret-syncs/render
Create a Render Sync for the specified project environment.



# Delete
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/render/delete

DELETE /api/v1/secret-syncs/render/{syncId}
Delete the specified Render Sync.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/render/get-by-id

GET /api/v1/secret-syncs/render/{syncId}
Get the specified Render Sync by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/render/get-by-name

GET /api/v1/secret-syncs/render/sync-name/{syncName}
Get the specified Render Sync by name and project ID.



# Import Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/render/import-secrets

POST /api/v1/secret-syncs/render/{syncId}/import-secrets
Import secrets from the specified Render Sync destination.



# List
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/render/list

GET /api/v1/secret-syncs/render
List the Render Syncs for the specified project.



# Remove Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/render/remove-secrets

POST /api/v1/secret-syncs/render/{syncId}/remove-secrets
Remove previously synced secrets from the specified Render Sync destination.



# Sync Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/render/sync-secrets

POST /api/v1/secret-syncs/render/{syncId}/sync-secrets
Trigger a sync for the specified Render Sync.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/render/update

PATCH /api/v1/secret-syncs/render/{syncId}
Update the specified Render Sync.



# Create
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/supabase/create

POST /api/v1/secret-syncs/supabase
Create a Supabase Sync for the specified project environment.



# Delete
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/supabase/delete

DELETE /api/v1/secret-syncs/supabase/{syncId}
Delete the specified Supabase Sync.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/supabase/get-by-id

GET /api/v1/secret-syncs/supabase/{syncId}
Get the specified Supabase Sync by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/supabase/get-by-name

GET /api/v1/secret-syncs/supabase/sync-name/{syncName}
Get the specified Supabase Sync by name and project ID.



# List
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/supabase/list

GET /api/v1/secret-syncs/supabase
List the Supabase Syncs for the specified project.



# Remove Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/supabase/remove-secrets

POST /api/v1/secret-syncs/supabase/{syncId}/remove-secrets
Remove previously synced secrets from the specified Supabase Sync destination.



# Sync Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/supabase/sync-secrets

POST /api/v1/secret-syncs/supabase/{syncId}/sync-secrets
Trigger a sync for the specified Supabase Sync.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/supabase/update

PATCH /api/v1/secret-syncs/supabase/{syncId}
Update the specified Supabase Sync.



# Create
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/teamcity/create

POST /api/v1/secret-syncs/teamcity
Create a TeamCity Sync for the specified project environment.



# Delete
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/teamcity/delete

DELETE /api/v1/secret-syncs/teamcity/{syncId}
Delete the specified TeamCity Sync.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/teamcity/get-by-id

GET /api/v1/secret-syncs/teamcity/{syncId}
Get the specified TeamCity Sync by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/teamcity/get-by-name

GET /api/v1/secret-syncs/teamcity/sync-name/{syncName}
Get the specified TeamCity Sync by name and project ID.



# Import Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/teamcity/import-secrets

POST /api/v1/secret-syncs/teamcity/{syncId}/import-secrets
Import secrets from the specified TeamCity Sync destination.



# List
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/teamcity/list

GET /api/v1/secret-syncs/teamcity
List the TeamCity Syncs for the specified project.



# Remove Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/teamcity/remove-secrets

POST /api/v1/secret-syncs/teamcity/{syncId}/remove-secrets
Remove previously synced secrets from the specified TeamCity Sync destination.



# Sync Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/teamcity/sync-secrets

POST /api/v1/secret-syncs/teamcity/{syncId}/sync-secrets
Trigger a sync for the specified TeamCity Sync.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/teamcity/update

PATCH /api/v1/secret-syncs/teamcity/{syncId}
Update the specified TeamCity Sync.



# Create
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/terraform-cloud/create

POST /api/v1/secret-syncs/terraform-cloud
Create a Terraform Cloud Sync for the specified project environment.



# Delete
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/terraform-cloud/delete

DELETE /api/v1/secret-syncs/terraform-cloud/{syncId}
Delete the specified Terraform Cloud Sync.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/terraform-cloud/get-by-id

GET /api/v1/secret-syncs/terraform-cloud/{syncId}
Get the specified Terraform Cloud Sync by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/terraform-cloud/get-by-name

GET /api/v1/secret-syncs/terraform-cloud/sync-name/{syncName}
Get the specified Terraform Cloud Sync by name and project ID.



# List
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/terraform-cloud/list

GET /api/v1/secret-syncs/terraform-cloud
List the Terraform Cloud Syncs for the specified project.



# Remove Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/terraform-cloud/remove-secrets

POST /api/v1/secret-syncs/terraform-cloud/{syncId}/remove-secrets
Remove previously synced secrets from the specified Terraform Cloud Sync destination.



# Sync Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/terraform-cloud/sync-secrets

POST /api/v1/secret-syncs/terraform-cloud/{syncId}/sync-secrets
Trigger a sync for the specified Terraform Cloud Sync.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/terraform-cloud/update

PATCH /api/v1/secret-syncs/terraform-cloud/{syncId}
Update the specified Terraform Cloud Sync.



# Create
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/vercel/create

POST /api/v1/secret-syncs/vercel
Create a Vercel Sync for the specified project environment.



# Delete
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/vercel/delete

DELETE /api/v1/secret-syncs/vercel/{syncId}
Delete the specified Vercel Sync.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/vercel/get-by-id

GET /api/v1/secret-syncs/vercel/{syncId}
Get the specified Vercel Sync by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/vercel/get-by-name

GET /api/v1/secret-syncs/vercel/sync-name/{syncName}
Get the specified Vercel Sync by name and project ID.



# Import Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/vercel/import-secrets

POST /api/v1/secret-syncs/vercel/{syncId}/import-secrets
Import secrets from the specified Vercel Sync destination.



# List
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/vercel/list

GET /api/v1/secret-syncs/vercel
List the Vercel Syncs for the specified project.



# Remove Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/vercel/remove-secrets

POST /api/v1/secret-syncs/vercel/{syncId}/remove-secrets
Remove previously synced secrets from the specified Vercel Sync destination.



# Sync Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/vercel/sync-secrets

POST /api/v1/secret-syncs/vercel/{syncId}/sync-secrets
Trigger a sync for the specified Vercel Sync.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/vercel/update

PATCH /api/v1/secret-syncs/vercel/{syncId}
Update the specified Vercel Sync.



# Create
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/windmill/create

POST /api/v1/secret-syncs/windmill
Create a Windmill Sync for the specified project environment.



# Delete
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/windmill/delete

DELETE /api/v1/secret-syncs/windmill/{syncId}
Delete the specified Windmill Sync.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/windmill/get-by-id

GET /api/v1/secret-syncs/windmill/{syncId}
Get the specified Windmill Sync by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/windmill/get-by-name

GET /api/v1/secret-syncs/windmill/sync-name/{syncName}
Get the specified Windmill Sync by name and project ID.



# Import Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/windmill/import-secrets

POST /api/v1/secret-syncs/windmill/{syncId}/import-secrets
Import secrets from the specified Windmill Sync destination.



# List
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/windmill/list

GET /api/v1/secret-syncs/windmill
List the Windmill Syncs for the specified project.



# Remove Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/windmill/remove-secrets

POST /api/v1/secret-syncs/windmill/{syncId}/remove-secrets
Remove previously synced secrets from the specified Windmill Sync destination.



# Sync Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/windmill/sync-secrets

POST /api/v1/secret-syncs/windmill/{syncId}/sync-secrets
Trigger a sync for the specified Windmill Sync.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/windmill/update

PATCH /api/v1/secret-syncs/windmill/{syncId}
Update the specified Windmill Sync.



# Create
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/zabbix/create

POST /api/v1/secret-syncs/zabbix
Create a Zabbix Sync for the specified project environment.



# Delete
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/zabbix/delete

DELETE /api/v1/secret-syncs/zabbix/{syncId}
Delete the specified Zabbix Sync.



# Get by ID
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/zabbix/get-by-id

GET /api/v1/secret-syncs/zabbix/{syncId}
Get the specified Zabbix Sync by ID.



# Get by Name
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/zabbix/get-by-name

GET /api/v1/secret-syncs/zabbix/sync-name/{syncName}
Get the specified Zabbix Sync by name and project ID.



# Import Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/zabbix/import-secrets

POST /api/v1/secret-syncs/zabbix/{syncId}/import-secrets
Import secrets from the specified Zabbix Sync destination.



# List
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/zabbix/list

GET /api/v1/secret-syncs/zabbix
List the Zabbix Syncs for the specified project.



# Remove Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/zabbix/remove-secrets

POST /api/v1/secret-syncs/zabbix/{syncId}/remove-secrets
Remove previously synced secrets from the specified Zabbix Sync destination.



# Sync Secrets
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/zabbix/sync-secrets

POST /api/v1/secret-syncs/zabbix/{syncId}/sync-secrets
Trigger a sync for the specified Zabbix Sync.



# Update
Source: https://infisical.com/docs/api-reference/endpoints/secret-syncs/zabbix/update

PATCH /api/v1/secret-syncs/zabbix/{syncId}
Update the specified Zabbix Sync.



# Create
Source: https://infisical.com/docs/api-reference/endpoints/secret-tags/create

POST /api/v1/projects/{projectId}/tags



# Delete
Source: https://infisical.com/docs/api-reference/endpoints/secret-tags/delete

DELETE /api/v1/projects/{projectId}/tags/{tagId}



# Get By ID
Source: https://infisical.com/docs/api-reference/endpoints/secret-tags/get-by-id

GET /api/v1/projects/{projectId}/tags/{tagId}



# Get By Slug
Source: https://infisical.com/docs/api-reference/endpoints/secret-tags/get-by-slug

GET /api/v1/projects/{projectId}/tags/slug/{tagSlug}



# List
Source: https://infisical.com/docs/api-reference/endpoints/secret-tags/list

GET /api/v1/projects/{projectId}/tags



# Update
Source: https://infisical.com/docs/api-reference/endpoints/secret-tags/update

PATCH /api/v1/projects/{projectId}/tags/{tagId}



# Create
Source: https://infisical.com/docs/api-reference/endpoints/secrets/create

POST /api/v4/secrets/{secretName}
Create secret



# Bulk Create
Source: https://infisical.com/docs/api-reference/endpoints/secrets/create-many

POST /api/v4/secrets/batch
Create many secrets



# Delete
Source: https://infisical.com/docs/api-reference/endpoints/secrets/delete

DELETE /api/v4/secrets/{secretName}
Delete secret



# Bulk Delete
Source: https://infisical.com/docs/api-reference/endpoints/secrets/delete-many

DELETE /api/v4/secrets/batch
Delete many secrets



# List
Source: https://infisical.com/docs/api-reference/endpoints/secrets/list

GET /api/v4/secrets
List secrets



# Retrieve
Source: https://infisical.com/docs/api-reference/endpoints/secrets/read

GET /api/v4/secrets/{secretName}
Get a secret by name



# Update
Source: https://infisical.com/docs/api-reference/endpoints/secrets/update

PATCH /api/v4/secrets/{secretName}
Update secret



# Bulk Update
Source: https://infisical.com/docs/api-reference/endpoints/secrets/update-many

PATCH /api/v4/secrets/batch
Update many secrets



# Get
Source: https://infisical.com/docs/api-reference/endpoints/service-tokens/get

GET /api/v2/service-token
Return Infisical Token data

<Warning>
  This endpoint is deprecated and will be removed in the future.

  We recommend switching to using [Machine Identities](/documentation/platform/identities/machine-identities).
</Warning>


# Create
Source: https://infisical.com/docs/api-reference/endpoints/ssh/ca/create

POST /api/v1/ssh/ca
Create SSH CA



# Delete
Source: https://infisical.com/docs/api-reference/endpoints/ssh/ca/delete

DELETE /api/v1/ssh/ca/{sshCaId}
Delete SSH CA



# List
Source: https://infisical.com/docs/api-reference/endpoints/ssh/ca/list

GET /api/v2/workspace/{projectId}/ssh-cas



# List templates
Source: https://infisical.com/docs/api-reference/endpoints/ssh/ca/list-certificate-templates

GET /api/v1/ssh/ca/{sshCaId}/certificate-templates
Get list of certificate templates for the SSH CA



# Retrieve public key
Source: https://infisical.com/docs/api-reference/endpoints/ssh/ca/public-key

GET /api/v1/ssh/ca/{sshCaId}/public-key
Get public key of SSH CA



# Retrieve
Source: https://infisical.com/docs/api-reference/endpoints/ssh/ca/read

GET /api/v1/ssh/ca/{sshCaId}
Get SSH CA



# Update
Source: https://infisical.com/docs/api-reference/endpoints/ssh/ca/update

PATCH /api/v1/ssh/ca/{sshCaId}
Update SSH CA



# Create
Source: https://infisical.com/docs/api-reference/endpoints/ssh/certificate-templates/create

POST /api/v1/ssh/certificate-templates



# Delete
Source: https://infisical.com/docs/api-reference/endpoints/ssh/certificate-templates/delete

DELETE /api/v1/ssh/certificate-templates/{certificateTemplateId}



# List
Source: https://infisical.com/docs/api-reference/endpoints/ssh/certificate-templates/list

GET /api/v2/workspace/{projectId}/ssh-certificate-templates



# Retrieve
Source: https://infisical.com/docs/api-reference/endpoints/ssh/certificate-templates/read

GET /api/v1/ssh/certificate-templates/{certificateTemplateId}



# Update
Source: https://infisical.com/docs/api-reference/endpoints/ssh/certificate-templates/update

PATCH /api/v1/ssh/certificate-templates/{certificateTemplateId}



# Issue SSH Credentials
Source: https://infisical.com/docs/api-reference/endpoints/ssh/certificates/issue-credentials

POST /api/v1/ssh/certificates/issue
Issue SSH credentials (certificate + key)



# Sign SSH Public Key
Source: https://infisical.com/docs/api-reference/endpoints/ssh/certificates/sign-key

POST /api/v1/ssh/certificates/sign
Sign SSH public key



# Add Host
Source: https://infisical.com/docs/api-reference/endpoints/ssh/groups/add-host

POST /api/v1/ssh/host-groups/{sshHostGroupId}/hosts/{hostId}
Add an SSH Host to a Host Group



# Create
Source: https://infisical.com/docs/api-reference/endpoints/ssh/groups/create

POST /api/v1/ssh/host-groups
Create SSH Host Group



# Delete
Source: https://infisical.com/docs/api-reference/endpoints/ssh/groups/delete

DELETE /api/v1/ssh/host-groups/{sshHostGroupId}
Delete SSH Host Group



# List
Source: https://infisical.com/docs/api-reference/endpoints/ssh/groups/list

GET /api/v2/workspace/{projectId}/ssh-host-groups



# List Hosts
Source: https://infisical.com/docs/api-reference/endpoints/ssh/groups/list-hosts

GET /api/v1/ssh/host-groups/{sshHostGroupId}/hosts
Get SSH Hosts in a Host Group



# Retrieve
Source: https://infisical.com/docs/api-reference/endpoints/ssh/groups/read

GET /api/v1/ssh/host-groups/{sshHostGroupId}
Get SSH Host Group



# Remove Host
Source: https://infisical.com/docs/api-reference/endpoints/ssh/groups/remove-host

DELETE /api/v1/ssh/host-groups/{sshHostGroupId}/hosts/{hostId}
Remove an SSH Host from a Host Group



# Update
Source: https://infisical.com/docs/api-reference/endpoints/ssh/groups/update

PATCH /api/v1/ssh/host-groups/{sshHostGroupId}
Update SSH Host Group



# Create
Source: https://infisical.com/docs/api-reference/endpoints/ssh/hosts/create

POST /api/v1/ssh/hosts
Register SSH Host



# Delete
Source: https://infisical.com/docs/api-reference/endpoints/ssh/hosts/delete

DELETE /api/v1/ssh/hosts/{sshHostId}
Delete SSH Host



# Issue Host Certificate
Source: https://infisical.com/docs/api-reference/endpoints/ssh/hosts/issue-host-cert

POST /api/v1/ssh/hosts/{sshHostId}/issue-host-cert
Issue SSH certificate for host



# Issue User Certificate
Source: https://infisical.com/docs/api-reference/endpoints/ssh/hosts/issue-user-cert

POST /api/v1/ssh/hosts/{sshHostId}/issue-user-cert
Issue SSH certificate for user



# List
Source: https://infisical.com/docs/api-reference/endpoints/ssh/hosts/list

GET /api/v2/workspace/{projectId}/ssh-hosts



# List My Hosts
Source: https://infisical.com/docs/api-reference/endpoints/ssh/hosts/list-my

GET /api/v1/ssh/hosts



# Retrieve
Source: https://infisical.com/docs/api-reference/endpoints/ssh/hosts/read

GET /api/v1/ssh/hosts/{sshHostId}



# Read Host CA Public Key
Source: https://infisical.com/docs/api-reference/endpoints/ssh/hosts/read-host-ca-pk

GET /api/v1/ssh/hosts/{sshHostId}/host-ca-public-key
Get public key of the host SSH CA linked to the host



# Read User CA Public Key
Source: https://infisical.com/docs/api-reference/endpoints/ssh/hosts/read-user-ca-pk

GET /api/v1/ssh/hosts/{sshHostId}/user-ca-public-key
Get public key of the user SSH CA linked to the host



# Update
Source: https://infisical.com/docs/api-reference/endpoints/ssh/hosts/update

PATCH /api/v1/ssh/hosts/{sshHostId}
Update SSH Host



# Attach
Source: https://infisical.com/docs/api-reference/endpoints/tls-cert-auth/attach

POST /api/v1/auth/tls-cert-auth/identities/{identityId}
Attach TLS Certificate Auth configuration onto machine identity



# Login
Source: https://infisical.com/docs/api-reference/endpoints/tls-cert-auth/login

POST /api/v1/auth/tls-cert-auth/login
Login with TLS Certificate Auth for machine identity

<Warning>
  Infisical US/EU and dedicated instances are deployed with AWS ALB. TLS Certificate Auth must flow through our ALB mTLS pass-through in order to authenticate.
  When you are authenticating with TLS Certificate Auth, you must use the port `8443` instead of the default `443`. Example: `https://app.infisical.com:8443/api/v1/auth/tls-cert-auth/login`
</Warning>


# Retrieve
Source: https://infisical.com/docs/api-reference/endpoints/tls-cert-auth/retrieve

GET /api/v1/auth/tls-cert-auth/identities/{identityId}
Retrieve TLS Certificate Auth configuration on machine identity



# Revoke
Source: https://infisical.com/docs/api-reference/endpoints/tls-cert-auth/revoke

DELETE /api/v1/auth/tls-cert-auth/identities/{identityId}
Delete TLS Certificate Auth configuration on machine identity



# Update
Source: https://infisical.com/docs/api-reference/endpoints/tls-cert-auth/update

PATCH /api/v1/auth/tls-cert-auth/identities/{identityId}
Update TLS Certificate Auth configuration on machine identity



# Attach
Source: https://infisical.com/docs/api-reference/endpoints/token-auth/attach

POST /api/v1/auth/token-auth/identities/{identityId}
Attach Token Auth configuration onto machine identity



# Create Token
Source: https://infisical.com/docs/api-reference/endpoints/token-auth/create-token

POST /api/v1/auth/token-auth/identities/{identityId}/tokens
Create token for machine identity with Token Auth



# Get Tokens
Source: https://infisical.com/docs/api-reference/endpoints/token-auth/get-tokens

GET /api/v1/auth/token-auth/identities/{identityId}/tokens
Get tokens for machine identity with Token Auth



# Retrieve
Source: https://infisical.com/docs/api-reference/endpoints/token-auth/retrieve

GET /api/v1/auth/token-auth/identities/{identityId}
Retrieve Token Auth configuration on machine identity



# Revoke
Source: https://infisical.com/docs/api-reference/endpoints/token-auth/revoke

DELETE /api/v1/auth/token-auth/identities/{identityId}
Delete Token Auth configuration on machine identity



# Revoke Token
Source: https://infisical.com/docs/api-reference/endpoints/token-auth/revoke-token

POST /api/v1/auth/token-auth/tokens/{tokenId}/revoke
Revoke token for machine identity with Token Auth



# Update
Source: https://infisical.com/docs/api-reference/endpoints/token-auth/update

PATCH /api/v1/auth/token-auth/identities/{identityId}
Update Token Auth configuration on machine identity



# Update Token
Source: https://infisical.com/docs/api-reference/endpoints/token-auth/update-token

PATCH /api/v1/auth/token-auth/tokens/{tokenId}
Update token for machine identity with Token Auth



# Attach
Source: https://infisical.com/docs/api-reference/endpoints/universal-auth/attach

POST /api/v1/auth/universal-auth/identities/{identityId}
Attach Universal Auth configuration onto machine identity



# Create Client Secret
Source: https://infisical.com/docs/api-reference/endpoints/universal-auth/create-client-secret

POST /api/v1/auth/universal-auth/identities/{identityId}/client-secrets
Create Universal Auth Client Secret for machine identity



# Get Client Secret By ID
Source: https://infisical.com/docs/api-reference/endpoints/universal-auth/get-client-secret-by-id

GET /api/v1/auth/universal-auth/identities/{identityId}/client-secrets/{clientSecretId}
Get Universal Auth Client Secret for machine identity



# List Client Secrets
Source: https://infisical.com/docs/api-reference/endpoints/universal-auth/list-client-secrets

GET /api/v1/auth/universal-auth/identities/{identityId}/client-secrets
List Universal Auth Client Secrets for machine identity



# Login
Source: https://infisical.com/docs/api-reference/endpoints/universal-auth/login

POST /api/v1/auth/universal-auth/login
Login with Universal Auth for machine identity



# Renew Access Token
Source: https://infisical.com/docs/api-reference/endpoints/universal-auth/renew-access-token

POST /api/v1/auth/token/renew
Renew machine identity access token



# Retrieve
Source: https://infisical.com/docs/api-reference/endpoints/universal-auth/retrieve

GET /api/v1/auth/universal-auth/identities/{identityId}
Retrieve Universal Auth configuration on machine identity



# Revoke
Source: https://infisical.com/docs/api-reference/endpoints/universal-auth/revoke

DELETE /api/v1/auth/universal-auth/identities/{identityId}
Delete Universal Auth configuration on machine identity



# Revoke Access Token
Source: https://infisical.com/docs/api-reference/endpoints/universal-auth/revoke-access-token

POST /api/v1/auth/token/revoke
Revoke machine identity access token



# Revoke Client Secret
Source: https://infisical.com/docs/api-reference/endpoints/universal-auth/revoke-client-secret

POST /api/v1/auth/universal-auth/identities/{identityId}/client-secrets/{clientSecretId}/revoke
Revoke Universal Auth Client Secrets for machine identity



# Update
Source: https://infisical.com/docs/api-reference/endpoints/universal-auth/update

PATCH /api/v1/auth/universal-auth/identities/{identityId}
Update Universal Auth configuration on machine identity



# Authentication
Source: https://infisical.com/docs/api-reference/overview/authentication

Learn how to authenticate with the Infisical Public API.

You can authenticate with the Infisical API using [Identities](/documentation/platform/identities/machine-identities) paired with authentication modes such as [Universal Auth](/documentation/platform/identities/universal-auth).

To interact with the Infisical API, you will need to obtain an access token. Follow the step by [step guide](/documentation/platform/identities/universal-auth) to get an access token via Universal Auth.

**FAQ**

<AccordionGroup>
  <Accordion title="Why can I not create, read, update, or delete an identity?">
    There are a few reasons for why this might happen:

    * You have insufficient organization permissions to create, read, update, delete identities.
    * The identity you are trying to read, update, or delete is more privileged than yourself.
    * The role you are trying to create an identity for or update an identity to is more privileged than yours.
  </Accordion>

  <Accordion title="Why is the Infisical API rejecting my identity credentials?">
    There are a few reasons for why this might happen:

    * The client secret or access token has expired.
    * The identity is insufficiently permissioned to interact with the resources you wish to access.
    * You are attempting to access a `/raw` secrets endpoint that requires your project to disable E2EE.
    * The client secret/access token is being used from an untrusted IP.
  </Accordion>
</AccordionGroup>


# Configure native integrations via API
Source: https://infisical.com/docs/api-reference/overview/examples/integration

How to use Infisical API to sync secrets to external secret managers

The Infisical API allows you to create programmatic integrations that connect with third-party secret managers to synchronize secrets from Infisical.

This guide will primarily demonstrate the process using AWS Secret Store Manager (AWS SSM), but the steps are generally applicable to other secret management integrations.

<Info>
  For details on setting up AWS SSM synchronization and understanding its prerequisites, refer to the [AWS SSM integration setup documentation](../../../integrations/cloud/aws-secret-manager).
</Info>

<Steps>
  <Step title="Authenticate with AWS SSM">
    Authentication is required for all integrations. Use the [Integration Auth API](../../endpoints/integrations/create-auth) with the following parameters to authenticate.

    <ParamField body="integration" type="string" initialValue="aws-secret-manager" required>
      Set this parameter to **aws-secret-manager**.
    </ParamField>

    <ParamField body="workspaceId" type="string" required>
      The Infisical project ID for the integration.
    </ParamField>

    <ParamField body="accessId" type="string" required>
      The AWS IAM User Access ID.
    </ParamField>

    <ParamField body="accessToken" type="string" required>
      The AWS IAM User Access Secret Key.
    </ParamField>

    ```bash Request theme={"dark"}
    curl --request POST \
        --url https://app.infisical.com/api/v1/integration-auth/access-token \
        --header 'Authorization: <authorization>' \
        --header 'Content-Type: application/json' \
        --data '{
        "workspaceId": "<workspaceid>",
        "integration": "aws-secret-manager",
        "accessId": "<aws iam user access id>",
        "accessToken": "<aws iam user access secret key>"
    }'
    ```
  </Step>

  <Step title="Configure the Synchronization Setup">
    Once authentication between AWS SSM and Infisical is established, you can configure the synchronization behavior.
    This involves specifying the source (environment and secret path in Infisical) and the destination in SSM to which the secrets will be synchronized.

    Use the [integration API](../../endpoints/integrations/create) with the following parameters to configure the sync source and destination.

    <ParamField body="integrationAuthId" type="string" required>
      The ID of the integration authentication object used with AWS, obtained from the previous API response.
    </ParamField>

    <ParamField body="isActive" type="boolean">
      Indicates whether the integration should be active or inactive.
    </ParamField>

    <ParamField body="app" type="string" required>
      The secret name for saving in AWS SSM, which can be arbitrarily chosen.
    </ParamField>

    <ParamField body="region" type="string" required>
      The AWS region where the SSM is located, e.g., `us-east-1`.
    </ParamField>

    <ParamField body="sourceEnvironment" type="string" required>
      The Infisical environment slug from which secrets will be synchronized, e.g., `dev`.
    </ParamField>

    <ParamField body="secretPath" type="string" required>
      The Infisical folder path from which secrets will be synchronized, e.g., `/some/path`. The root path is `/`.
    </ParamField>

    ```bash Request theme={"dark"}
    curl --request POST \
        --url https://app.infisical.com/api/v1/integration \
        --header 'Authorization: <authorization>' \
        --header 'Content-Type: application/json' \
        --data '{
        "integrationAuthId": "<integrationauthid>",
        "sourceEnvironment": "<sourceenvironment>",
        "secretPath": "<secret-path, default is '/' >",
        "app": "<app>",
        "region": "<aws-ssm-region>"
    }'
    ```
  </Step>
</Steps>

<Check>
  Congratulations! You have successfully set up an integration to synchronize secrets from Infisical with AWS SSM.
  For more information, [view the integration API reference](../../endpoints/integrations).
</Check>


# API Reference
Source: https://infisical.com/docs/api-reference/overview/introduction



Infisical's Public (REST) API provides users an alternative way to programmatically access and manage
secrets via HTTPS requests. This can be useful for automating tasks, such as
rotating credentials, or for integrating secret management into a larger system.

With the Public API, you can create, read, update, and delete secrets, as well as manage access control, query audit logs, and more.

## API Versioning

The API is versioned on a per-resource basis. A resource's version is only incremented for breaking changes, so different endpoints may have different version numbers (e.g., `/api/v4/secrets` vs. `/api/v1/secret-syncs`).

As a best practice, always use the latest available version for each endpoint to ensure access to the most recent features and improvements.


# Changelog
Source: https://infisical.com/docs/changelog/overview



The changelog below reflects new product developments and updates on a monthly basis.

## July 2025

* Improved speed performance of audit log filtering.
* Revamped password reset flow pages.
* Added support for [Bitbucket for Secret Scanning](https://infisical.com/docs/documentation/platform/secret-scanning/bitbucket).
* Released Secret Sync for [Zabbix](https://infisical.com/docs/integrations/secret-syncs/zabbix).

## June 2025

* Released Secret Sync for [1Password](https://infisical.com/docs/integrations/secret-syncs/1password), [Heroku](https://infisical.com/docs/integrations/secret-syncs/heroku), [Fly.io](https://infisical.com/docs/integrations/secret-syncs/flyio), and [Render](https://infisical.com/docs/integrations/secret-syncs/render).
* Added support for [Kubernetes dynamic secrets](https://infisical.com/docs/documentation/platform/dynamic-secrets/kubernetes) to generate service account tokens
* Released Secret Rotation for [MySQL](https://infisical.com/docs/documentation/platform/secret-rotation/mysql-credentials) and [OracleDB](https://infisical.com/docs/documentation/platform/secret-rotation/oracledb-credentials) as well as Dynamic Secrets for [Vertica](https://infisical.com/docs/documentation/platform/dynamic-secrets/vertica) and [GitHub App Tokens](https://infisical.com/docs/documentation/platform/dynamic-secrets/github).
* Added support for Azure Auth in ESO.
* [Kubernetes auth](https://infisical.com/docs/documentation/platform/identities/kubernetes-auth) now supports gateway as a token reviewer.
* Revamped [Infisical CLI](https://infisical.com/docs/cli/commands/login) to auto-open login link.
* Rolled out [Infisical Packer integration](https://infisical.com/docs/integrations/frameworks/packer).
* Released [AliCloud Authentication method](https://infisical.com/docs/documentation/platform/identities/alicloud-auth).
* Added support for [multi-step approval workflows](https://infisical.com/docs/documentation/platform/pr-workflows).
* Revamped UI for Access Controls, Access Tree, Policies, and Approval Workflows.
* Released [TLS Certificate Authentication method](https://infisical.com/docs/documentation/platform/identities/tls-cert-auth).
* Added ability to copy session tokens in the Infisical Dashboard.
* Expanded resource support for [Infisical Terraform Provider](https://registry.terraform.io/providers/Infisical/infisical/latest/docs).

## May 2025

* Added support for [Microsoft Teams integration](https://infisical.com/docs/documentation/platform/workflow-integrations/microsoft-teams-integration).
* Released [Infisical Gateway](https://infisical.com/docs/documentation/platform/gateways/overview) for accessing private network resources from Infisical.
* Added support for [Host Groups](https://infisical.com/docs/documentation/platform/ssh/host-groups) in Infisical SSH.
* Updated the designs of all emails send by Infisical.
* Added secret rotation support for [Azure Client](https://infisical.com/docs/documentation/platform/secret-rotation/azure-client-secret).
* Released secret sync for [HashiCorp Vault](https://infisical.com/docs/integrations/secret-syncs/hashicorp-vault).
* Made significant improvements to [Infisical Secret Scanning](https://infisical.com/docs/documentation/platform/secret-scanning/overview).
* Released [Infisical ACME Client](https://infisical.com/docs/documentation/platform/pki/acme-ca#certificates-with-acme-ca).
* [Access requests](https://infisical.com/docs/documentation/platform/access-controls/access-requests) now support "break-glass" policies.
* Updated [Point-in-time Recovery](https://infisical.com/docs/documentation/platform/pit-recovery) UI/UX.
* Redesigned [Approval Workflows and Change Requests](https://infisical.com/docs/documentation/platform/pr-workflows) user interface.

## April 2025

* Released ability to [request access to projects](https://infisical.com/docs/documentation/platform/access-controls/project-access-requests#project-access-requests).
* Updated UI for Audit Logs and Log Filtering.
* Launched [Infisical SSH V2](https://infisical.com/docs/documentation/platform/ssh/overview).
* Developer [Infisical MCP](https://github.com/Infisical/infisical-mcp-server).
* Added support for [Spotify Backstage Infisical plugin](https://infisical.com/docs/integrations/external/backstage).
* Added secret syncs for Terraform Cloud, Vercel, Windmill, TeamCity, and Camunda.
* Released [Auth0 Client Secret Rotation](https://infisical.com/docs/documentation/platform/secret-rotation/auth0-client-secret).
* Launched [Infisical C++ SDK](https://github.com/Infisical/infisical-cpp-sdk).
* Service tokens will now get expiry notifications.
* Added Infisical [Linux binary](https://infisical.com/docs/self-hosting/reference-architectures/linux-deployment-ha#linux-ha).
* Released ability to perform user impersonation.
* Added support for [LDAP password rotation](https://infisical.com/docs/documentation/platform/secret-rotation/ldap-password).

## March 2025

* Released [Infisical Gateway](https://infisical.com/docs/documentation/platform/gateways/overview) for secure access to private resources without needing direct inbound connections to private networks.
* Enhanced [Terraform](https://registry.terraform.io/providers/Infisical/infisical/latest/docs) capabilities with token authentication, ability to import existing Infisical secrets as resources, and support for project templates.
* Self-hosted improvements: Usage and billing visibility for enabled features, ability to delete users, and support for multiple super admins.
* UI and UX updates: Improved secret import interface on the overview page, password reset without backup PDF.
* CLI enhancements: Various improvements including multiline secret support and ability to pass headers.
* Kubernetes operator updates: Auto-reloading for DaemonSets and StatefulSets (previously only Deployments), added support for ConfigMaps.
* Implemented powerful [Access Control](https://infisical.com/docs/documentation/platform/access-controls/overview#access-controls) updates including "**Grant Privileges**" feature for designating specific users for policy management, **Access Tree** visualization for simulating permissions, and ability to restrict scope of secret sharing within organizations.
* Released new **Secret Requests** feature under Secret Share, added support for reminders with webhook triggers and implementing password policies for dynamic secrets.
* Enhanced secret version history to show who made changes.
* New integrations and syncs: **Crossplane** provider, **Humanitec** secret sync, **Airflow** system integration
* Performed significant performance optimizations including a 50% reduction in database usage and optimized client secret handling for universal auth.
* Enhanced security features with ability to add custom instance banners (useful for regulated industries), short-lived tokens for Kubernetes auth, and OIDC claim passing from machine identity login to permissions.
* [Golang SDK](https://infisical.com/docs/sdks/languages/go#infisical-go-sdk): New API added for enhanced functionality
* Added capability to programmatically configure an Infisical instance from start to finish without UI interaction.

## February 2025

* Released [KMIP integration](https://infisical.com/docs/documentation/platform/kms/kmip) with PKI structure, auth model integration with machine identities, complete set of client operations, and client certificate authentication flow.
* Added new [AWS App Connection](https://infisical.com/docs/integrations/app-connections/aws) and [Secret Sync](https://infisical.com/docs/integrations/secret-syncs/aws-secrets-manager) functionality for enhanced AWS integration.
* Released new [Azure Key Vault App Connection](https://infisical.com/docs/integrations/app-connections/azure-key-vault) and [Secret Sync](https://infisical.com/docs/integrations/secret-syncs/azure-key-vault), plus Terraform provider support.
* Introduced more comprehensive logging with detailed records for secret sharing and metadata in audit logs.
* Introduced new [permission types](https://infisical.com/docs/internals/permissions/project-permissions#subject-secrets): "View Value" vs "Describe Value" for more granular access control over secrets.
* Updated encryption logic with unified approach for all platform data, ensuring consistency across the system.
* Added support for [OIDC group mapping](https://infisical.com/docs/documentation/platform/sso/general-oidc) to automatically map groups to Infisical for role-based access control.
* Added [Terraform Cloud support for OIDC](https://infisical.com/docs/documentation/platform/identities/oidc-auth/terraform-cloud#terraform-cloud).

## January 2025

* Released new integration architecture with decoupled authentication, replacing native integrations with [App Connections](https://infisical.com/docs/integrations/app-connections/overview) and [Secret Syncs](https://infisical.com/docs/integrations/secret-syncs/overview). Initial support for AWS Parameter Store, GitHub, and GCP Secret Manager with improved API and Terraform integration capabilities.
* Added support for OIDC group mapping in [Keycloak](https://infisical.com/docs/documentation/platform/sso/keycloak-oidc/overview), enabling automatic mapping of Keycloak groups to Infisical for role-based access control.
* Enhanced [Kubernetes operator](https://infisical.com/docs/integrations/platforms/kubernetes/overview#kubernetes-operator) with namespaced group support, bi-directional secret sync (push to Infisical), [dynamic secrets](https://infisical.com/docs/documentation/platform/dynamic-secrets/overview#dynamic-secrets) capabilities, and support for multiple operator instances.
* Restructured navigation with dedicated sections for Secrets Management, [Certificate Management (PKI)](https://infisical.com/docs/documentation/platform/pki/overview), [Key Management (KMS)](https://infisical.com/docs/documentation/platform/kms/overview#key-management-service-kms), and [SSH Key Management](https://infisical.com/docs/documentation/platform/ssh).
* Added [ephemeral Terraform resource](https://registry.terraform.io/providers/Infisical/infisical/latest/docs) support and improved secret sync architecture.
* Released [.NET provider](https://github.com/Infisical/infisical-dotnet-configuration) with first-party Azure authentication support and Azure CLI integration.
* Implemented secret Access Visibility allowing users to view all entities with access to specific secrets in the secret side panel.
* Added secret filtering by metadata and SSH assigned certificates (Version 1).

## December 2024

* Added [GCP KMS](https://infisical.com/docs/documentation/platform/kms/overview) integration support.
* Added support for [K8s CSI integration](https://infisical.com/docs/integrations/platforms/kubernetes-csi) and ability to point K8s operator to specific secret versions.
* Fixed [Java SDK](https://github.com/Infisical/java-sdk) compatibility issues with Alpine Linux.
* Fixed SCIM group role assignment issues.
* Added Group View Page for improved team management.
* Added instance URL to email verification for Infisical accounts.
* Added ability to copy full path of nested folders.
* Added custom templating support for K8s operator, allowing flexible secret key mapping and additional fields.
* Optimized secrets versions table performance.

## November 2024

* Improved EnvKey migration functionality with support for Blocks, Inheritance, and Branches.
* Added [Hardware Security Module (HSM) Encryption](https://infisical.com/docs/documentation/platform/kms/hsm-integration) support.
* Updated permissions handling in [Infisical Terraform Provider](https://registry.terraform.io/providers/Infisical/infisical/latest/docs) to use lists instead of sets.
* Enhanced [SCIM](https://infisical.com/docs/documentation/platform/scim/overview) implementation to remove SAML dependency.
* Enhanced [OIDC Authentication](https://infisical.com/docs/documentation/platform/identities/oidc-auth/general) implementation and added Default Org Slug support.
* Added support for multiple authentication methods per identity.
* Added AWS Parameter Store integration sync improvements.
* Added new screen and API for managing additional privileges.
* Added Dynamic Secrets support for SQL Server.

## October 2024

* Significantly improved performance of audit log operations in UI.
* Released [Databricks integration](https://infisical.com/docs/integrations/cloud/databricks).
* Added ability to enforce 2FA organization-wide.
* Added multiple resource to the [Infisical Terraform Provider](https://registry.terraform.io/providers/Infisical/infisical/latest/docs), including AWS and GCP integrations.
* Released [Infisical KMS](https://infisical.com/docs/documentation/platform/kms/overview).
* Added support for [LDAP dynamic secrets](https://infisical.com/docs/documentation/platform/ldap/overview).
* Enabled changing auth methods for machine identities in the UI.
* Launched [Infisical EU Cloud](https://eu.infisical.com).

## September 2024

* Improved paginations for identities and secrets.
* Significant improvements to the [Infisical Terraform Provider](https://registry.terraform.io/providers/Infisical/infisical/latest/docs).
* Created [Slack Integration](https://infisical.com/docs/documentation/platform/workflow-integrations/slack-integration#slack-integration) for Access Requests and Approval Workflows.
* Added Dynamic Secrets for [Elaticsearch](https://infisical.com/docs/documentation/platform/dynamic-secrets/elastic-search) and [MongoDB](https://infisical.com/docs/documentation/platform/dynamic-secrets/mongo-db).
* More authentication methods are now supported by Infisical SDKs and Agent.
* Integrations now have dedicated audit logs and an overview screen.
* Added support for secret referencing in the Terraform Provider.
* Released support for [older versions of .NET](https://www.nuget.org/packages/Infisical.Sdk#supportedframeworks-body-tab) via SDK.
* Released Infisical PKI Issuer which works alongside `cert-manager` to manage certificates in Kubernetes.

## August 2024

* Added [Azure DevOps integration](https://infisical.com/docs/integrations/cloud/azure-devops).
* Released ability to hot-reload variables in CLI ([--watch flag](https://infisical.com/docs/cli/commands/run#infisical-run:watch)).
* Added Dynamic Secrets for [Redis](https://infisical.com/docs/documentation/platform/dynamic-secrets/redis).
* Added [Alerting](https://infisical.com/docs/documentation/platform/pki/alerting) for Certificate Management.
* You can now specify roles and project memberships when adding new users.
* Approval workflows now have email notifications.
* Access requests are now integrated with User Groups.
* Released ability to use IAM Roles for AWS Integrations.

## July 2024

* Released the official [Ruby SDK](https://infisical.com/docs/sdks/languages/ruby).
* Increased the speed and efficiency of secret operations.
* Released AWS KMS wrapping (bring your own key).
* Users can now log in to CLI via SSO in non-browser environments.
* Released [Slack Webhooks](https://infisical.com/docs/documentation/platform/webhooks).
* Added [Dynamic Secrets with MS SQL](https://infisical.com/docs/documentation/platform/dynamic-secrets/mssql).
* Redesigned and simplified the Machine Identities page.
* Added the ability to move secrets/folders to another location.
* Added [OIDC](https://infisical.com/docs/documentation/platform/identities/oidc-auth/general) support to CLI, Go SDK, and more.
* Released [Linux installer for Infisical](https://infisical.com/docs/self-hosting/deployment-options/native/standalone-binary).

## June 2024

* Released [Infisical PKI](https://infisical.com/docs/documentation/platform/pki/overview).
* Released the official [Go SDK](https://infisical.com/docs/sdks/languages/go).
* Released [OIDC Authentication method](https://infisical.com/docs/documentation/platform/identities/oidc-auth/general).
* Allowed users to configure log retention periods on self-hosted instances.
* Added [tags](https://registry.terraform.io/providers/Infisical/infisical/latest/docs/resources/secret_tag) to terraform provider.
* Released [public secret sharing](https://share.infisical.com).
* Built a [native integration with Rundeck](https://infisical.com/docs/integrations/cicd/rundeck).
* Added list view for projects in the dashboard.
* Fixed offline coding mode in CLI.
* Users are now able to leave a particular project themselves.

## May 2024

* Released [AWS](https://infisical.com/docs/documentation/platform/identities/aws-auth), [GCP](https://infisical.com/docs/documentation/platform/identities/gcp-auth), [Azure](https://infisical.com/docs/documentation/platform/identities/azure-auth), and [Kubernetes](https://infisical.com/docs/documentation/platform/identities/kubernetes-auth) Native Auth Methods.
* Added [Secret Sharing](https://infisical.com/docs/documentation/platform/secret-sharing) functionality for sharing sensitive data through encrypted links  within and outside of an organization.
* Updated [Secret Referencing](https://infisical.com/docs/documentation/platform/secret-reference) to be supported in all Infisical clients. Infisical UI is now able to provide automatic reference suggestions when typing.
* Released new [Infisical Jenkins Plugin](https://infisical.com/docs/integrations/cicd/jenkins).
* Added statuses and manual sync option to integrations in the Dashboard UI.
* Released universal [Audit Log Streaming](https://infisical.com/docs/documentation/platform/audit-log-streams).
* Added [Dynamic Secret template for AWS IAM](https://infisical.com/docs/documentation/platform/dynamic-secrets/aws-iam).
* Added support for syncing tags and custom KMS keys to [AWS Secrets Manager](https://infisical.com/docs/integrations/cloud/aws-secret-manager) and [Parameter Store](https://infisical.com/docs/integrations/cloud/aws-parameter-store) Integrations.
* Officially released Infisical on [AWS Marketplace](https://infisical.com/blog/infisical-launches-on-aws-marketplace).

## April 2024

* Added [Access Requests](https://infisical.com/docs/documentation/platform/access-controls/access-requests) as part of self-serve secrets management workflows.
* Added [Temporary Access Provisioning](https://infisical.com/docs/documentation/platform/access-controls/temporary-access) for roles and additional privileges.

## March 2024

* Released support for [Dynamic Secrets](https://infisical.com/docs/documentation/platform/dynamic-secrets/overview).
* Released the concept of [Additional Privileges](https://infisical.com/docs/documentation/platform/access-controls/additional-privileges) on top of user/machine roles.

## Feb 2024

* Added org-scoped authentication enforcement for SAML
* Added support for [SCIM](https://infisical.com/docs/documentation/platform/scim/overview) along with instructions for setting it up with [Okta](https://infisical.com/docs/documentation/platform/scim/okta), [Azure](https://infisical.com/docs/documentation/platform/scim/azure), and [JumpCloud](https://infisical.com/docs/documentation/platform/scim/jumpcloud).
* Pushed out project update for non-E2EE w/ new endpoints like for project creation and member invitation.
* Added API Integration testing for new backend.
* Added capability to create projects in Terraform.
* Added slug-based capabilities to both organizations and projects to gradually make the API more developer-friendly moving forward.
* Fixed + improved various analytics/telemetry-related items.
* Fixed various issues associated with the Python SDK: build during installation on Mac OS, Rust dependency.
* Updated self-hosting documentation to reflect [new backend](https://infisical.com/docs/self-hosting/overview).
* Released [Postgres-based Infisical helm chart](https://cloudsmith.io/~infisical/repos/helm-charts/packages/detail/helm/infisical-standalone/).
* Added checks to ensure that breaking API changes don't get released.
* Automated API reference documentation to be inline with latest releases of Infisical.

## Jan 2024

* Completed Postgres migration initiative with restructed Fastify-based backend.
* Reduced size of Infisical Node.js SDK by 90%.
* Added secret fallback support to all SDK's.
* Added Machine Identity support to [Terraform Provider](https://registry.terraform.io/providers/Infisical/infisical/latest/docs).
* Released [.NET SDK](https://infisical.com/docs/sdks/languages/csharp).
* Added symmetric encryption support to all SDK's.
* Fixed secret reminders bug, where reminders were not being updated correctly.

## Dec 2023

* Released [(machine) identities](https://infisical.com/docs/documentation/platform/identities/overview) and [universal auth](https://infisical.com/docs/documentation/platform/identities/universal-auth) features.
* Created new cross-language SDKs for [Python](https://infisical.com/docs/sdks/languages/python), [Node](https://infisical.com/docs/sdks/languages/node), and [Java](https://infisical.com/docs/sdks/languages/java).
* Released first version of the [Infisical Agent](https://infisical.com/docs/infisical-agent/overview)
* Added ability to [manage folders via CLI](https://infisical.com/docs/cli/commands/secrets).

## Nov 2023

* Replaced internal [Winston](https://github.com/winstonjs/winston) with [Pino](https://github.com/pinojs/pino) logging library with external logging to AWS CloudWatch
* Added admin panel to self-hosting experience.
* Released [secret rotation](https://infisical.com/docs/documentation/platform/secret-rotation/overview) feature with preliminary support for rotating [SendGrid](https://infisical.com/docs/documentation/platform/secret-rotation/sendgrid), [PostgreSQL/CockroachDB](https://infisical.com/docs/documentation/platform/secret-rotation/postgres-credentials), and [MySQL/MariaDB](https://infisical.com/docs/documentation/platform/secret-rotation/mysql) credentials.
* Released secret reminders feature.

## Oct 2023

* Added support for [GitLab SSO](https://infisical.com/docs/documentation/platform/sso/gitlab).
* Became SOC 2 (Type II) certified.
* Reduced required JWT configuration from 5-6 secrets to 1 secret for self-hosting Infisical.
* Compacted Infisical into 1 Docker image.
* Added native [Hasura Cloud integration](https://infisical.com/docs/integrations/cloud/hasura-cloud).
* Updated resource deletion logic for user, organization, and project deletion.

## Sep 2023

* Released [secret approvals](https://infisical.com/docs/documentation/platform/pr-workflows) feature.
* Released an update to access controls; every user role now clearly defines and enforces a certain set of conditions across Infisical.
* Updated UI/UX for integrations.
* Added a native integration with [Qovery](https://infisical.com/docs/integrations/cloud/qovery).
* Added service token generation capability for the CLI.

## Aug 2023

* Release Audit Logs V2.
* Add support for [GitHub SSO](https://infisical.com/docs/documentation/platform/sso/github).
* Enable users to opt in for multiple authentication methods.
* Improved password requirements including check against [Have I Been Pwnd Password API](https://haveibeenpwned.com/Passwords).
* Added native [GCP Secret Manager integration](https://infisical.com/docs/integrations/cloud/gcp-secret-manager)

## July 2023

* Released [secret referencing and importing](https://infisical.com/docs/documentation/platform/secret-reference) across folders and environments.
* Redesigned the project/organization experience.
* Updated the secrets overview page; users are now able to edit secrets directly from it.
* Added native [Laravel Forge integration](https://infisical.com/docs/integrations/cloud/laravel-forge).
* Added native [Codefresh integration](https://infisical.com/docs/integrations/cicd/codefresh).
* Added native [Bitbucket integration](https://infisical.com/docs/integrations/cicd/bitbucket).
* Added native [DigitalOcean App Platform integration](https://infisical.com/docs/integrations/cloud/digital-ocean-app-platform).
* Added native [Cloud66 integration](https://infisical.com/docs/integrations/cloud/cloud-66).
* Added native [Terraform Cloud integration](https://infisical.com/docs/integrations/cloud/terraform-cloud).
* Added native [Northflank integration](https://infisical.com/docs/integrations/cloud/northflank).
* Added native [Windmill integration](https://infisical.com/docs/integrations/cloud/windmill).
* Added support for [Google SSO](https://infisical.com/docs/documentation/platform/sso/google)
* Added support for [Okta](https://infisical.com/docs/documentation/platform/sso/okta), [Azure AD](https://infisical.com/docs/documentation/platform/sso/azure), and [JumpCloud](https://infisical.com/docs/documentation/platform/sso/jumpcloud) [SAML](https://infisical.com/docs/documentation/platform/saml) authentication.
* Released [folders / path-based secret storage](https://infisical.com/docs/documentation/platform/folder).
* Released [webhooks](https://infisical.com/docs/documentation/platform/webhooks).

## June 2023

* Released the [Terraform Provider](https://registry.terraform.io/providers/Infisical/infisical/latest/docs).
* Updated the usage and billing page. Added the free trial for the professional tier.
* Added native integrations with [Checkly](https://infisical.com/docs/integrations/cloud/checkly), [Hashicorp Vault](https://infisical.com/docs/integrations/cloud/hashicorp-vault), and [Cloudflare Pages](https://infisical.com/docs/integrations/cloud/cloudflare-pages).
* Completed a penetration test with a `very good` result.
* Added support for multi-line secrets.

## May 2023

* Released secret scanning capability for the CLI.
* Released customer / license service to manage customer billing information, cloud plans, and self-hosted enterprise licenses; all instances of Infisicals now fetch/relay information from this service.
* Completed penetration test.
* Released new landing page.
* Started SOC 2 (Type II) compliance certification preparation.
* Released new deployment options for Fly.io, Digital Ocean and Render.

## April 2023

* Upgraded secret-handling to include blind-indexing (can be thought of as a fingerprint).
* Added Node SDK support for working with individual secrets.
* Released preliminary Python SDK.
* Released service accounts, a client type capable of accessing multiple projects.
* Added native Supabase integration.
* Added native Railway integration.
* Improved dashboard speed / performance.
* Released the Secrets Overview page for users to view and identify missing environment secrets within one dashboard.
* Updated documentation to include quickstarts and guides; also updated `README.md`.

## March 2023

* Added support for global configs to the Kubernetes operator.
* Added support for self-hosted deployments to operate without any attached email service / SMTP configuration.
* Added native Azure Key Vault integration.
* Released one-click AWS EC2 deployment method.
* Released preliminary Node SDK.

## Feb 2023

* Upgraded private key encryption/decryption mechanism to use Argon2id and 256-bit protected keys.
* Added preliminary email-based 2FA capability.
* Added suspicious login alerting if user logs in via new device or IP address.
* Added documentation for PM2 integration.
* Added secret backups support for the CLI; it now fetches and caches secrets locally to be used in the event of future failed fetch.
* Added support for comparing secret values across environments on each secret.
* Added native AWS Parameter Store integration.
* Added native AWS Secrets Manager integration.
* Added native GitLab integration.
* Added native CircleCI integration.
* Added native Travis CI integration.
* Added secret tagging capability for enhanced organizational structure/grouping.
* Released new dashboard design allowing more actions to be performed within the dashboard itself.
* Added capability to generate `.env.example` file.

## Jan 2023

* Added preliminary audit logging capability covering CRUD secret operations.
* Added secret overriding capability for team members to have their own branch of a secret.
* Added secret versioning capability.
* Added secret snapshot and point-in-time recovery capabilities to track and roll back the full state of a project.
* Added native Vercel integration.
* Added native Netlify integration.
* Added native GitHub Actions integration.
* Added custom environment names.
* Added auto-redeployment capability to the Kubernetes operator.
* (Service Token 2.0) Shortened the length of service tokens.
* Added a public-facing API.
* Added preliminary access control capability for users to be provisioned read/write access to environments.
* Performed various web UI optimizations.

## Nov 2022

* Infisical is open sourced.
* Added Infisical CLI support for Docker and Docker Compose.
* Rewrote the Infisical CLI in Golang to be platform-agnostic.
* Rewrote the documentation.

## Oct 2022

* Added support for organizations; projects now belong to organizations.
* Improved speed / performance of dashboard by 25x.
* Added capability to change account password in settings.
* Added persistence for logging into the organization and project that users left from in their previous session.
* Added password recovery emergency kit with automatic download enforcement upon account creation.
* Added capability to copy-to-clipboard capabilities.
* Released first native integration between Infisical and Heroku; environment variables can now be sent and kept in sync with Heroku.

## Sep 2022

* Added capability to change user roles in projects.
* Added capability to delete projects.
* Added Stripe.
* Added default environments (development, staging, production) for new users with example key-pairs.
* Added loading indicators.
* Moved from push/pull mode of secret operation to automatically pulling and injecting secrets into processes upon startup.
* Added drag-and-drop capability for adding new .env files.
* Improved security measures against common attacks (e.g. XSS, clickjacking, etc.).
* Added support for personal secrets (later modified to be secret overrides in Jan 2023).
* Improved account password validation and enforce minimum requirements.
* Added sorting capability to sort keys by name alphabetically in dashboard.
* Added downloading secrets back as `.env` file capability.

## Aug 2022

* Released first version of the Infisical platform with push/pull capability and end-to-end encryption.
* Improved security handling of authentication tokens by storing refresh tokens in HttpOnly cookies.
* Added hiding key values on client-side.
* Added search bar to dashboard to query for keys on client-side.
* Added capability to rename a project.
* Added user roles for projects.
* Added incident contacts.


# infisical bootstrap
Source: https://infisical.com/docs/cli/commands/bootstrap

Automate the initial setup of a new Infisical instance for headless deployment and infrastructure-as-code workflows

```bash  theme={"dark"}
infisical bootstrap --domain=<domain> --email=<email> --password=<password> --organization=<organization>
```

## Description

The `infisical bootstrap` command is used when deploying Infisical in automated environments where manual UI setup is not feasible. It's ideal for:

* Containerized deployments in Kubernetes or Docker environments
* Infrastructure-as-code pipelines with Terraform or similar tools
* Continuous deployment workflows
* DevOps automation scenarios

The command initializes a fresh Infisical instance by creating an admin user, organization, and instance admin machine identity, enabling subsequent programmatic configuration without human intervention.

<Warning>
  This command creates an instance admin machine identity with the highest level
  of privileges. The returned token should be treated with the utmost security,
  similar to a root credential. Unauthorized access to this token could
  compromise your entire Infisical instance.
</Warning>

## Flags

<Accordion title="--domain" defaultOpen="true">
  The URL of your Infisical instance. This can be set using the `INFISICAL_API_URL` environment variable.

  ```bash  theme={"dark"}
  # Example
  infisical bootstrap --domain=https://your-infisical-instance.com
  ```

  This flag is required.
</Accordion>

<Accordion title="--email">
  Email address for the admin user account that will be created. This can be set using the `INFISICAL_ADMIN_EMAIL` environment variable.

  ```bash  theme={"dark"}
  # Example
  infisical bootstrap --email=admin@example.com
  ```

  This flag is required.
</Accordion>

<Accordion title="--password">
  Password for the admin user account. This can be set using the `INFISICAL_ADMIN_PASSWORD` environment variable.

  ```bash  theme={"dark"}
  # Example
  infisical bootstrap --password=your-secure-password
  ```

  This flag is required.
</Accordion>

<Accordion title="--organization">
  Name of the organization that will be created within the instance. This can be set using the `INFISICAL_ADMIN_ORGANIZATION` environment variable.

  ```bash  theme={"dark"}
  # Example
  infisical bootstrap --organization=your-org-name
  ```

  This flag is required.
</Accordion>

<Accordion title="--ignore-if-bootstrapped">
  Whether to continue without error if the instance has already been bootstrapped. Useful for idempotent automation scripts.

  ```bash  theme={"dark"}
  # Example
  infisical bootstrap --ignore-if-bootstrapped
  ```

  This flag is optional and defaults to `false`.
</Accordion>

<Accordion title="--output">
  The type of output format for the bootstrap command. Supports `k8-secret` for Kubernetes secret integration. This flag is optional and defaults to "".

  ```bash  theme={"dark"}
  # Kubernetes secret output
  infisical bootstrap --output=k8-secret --k8-secret-template='{"data":{"token":"{{.Identity.Credentials.Token}}"}}' --k8-secret-name=infisical-bootstrap --k8-secret-namespace=default
  ```

  When using `k8-secret`, the command will create or update a Kubernetes secret directly in your cluster. Note that this option requires the command to be executed from within a Kubernetes pod with appropriate service account permissions.
</Accordion>

<Accordion title="--k8-secret-template">
  The template to use for rendering the Kubernetes secret data/stringData section. Required when using `--output=k8-secret`. The template uses Go template syntax and has access to the bootstrap response data.

  ```bash  theme={"dark"}
  # Example template that stores the token
  infisical bootstrap --k8-secret-template='{"data":{"token":"{{.Identity.Credentials.Token}}"}}'

  # Example template with multiple fields
  infisical bootstrap --k8-secret-template='{"stringData":{"token":"{{.Identity.Credentials.Token}}","org-id":"{{.Organization.ID}}","user-email":"{{.User.Email}}"}}'
  ```

  Available template functions:

  * `encodeBase64`: Base64 encode a string

  Available data fields:

  * `.Identity.Credentials.Token`: The machine identity token
  * `.Identity.ID`: The identity ID
  * `.Identity.Name`: The identity name
  * `.Organization.ID`: The organization ID
  * `.Organization.Name`: The organization name
  * `.Organization.Slug`: The organization slug
  * `.User.Email`: The admin user email
  * `.User.ID`: The admin user ID
  * `.User.FirstName`: The admin user first name
  * `.User.LastName`: The admin user last name

  This flag is required when using `k8-secret` output.
</Accordion>

<Accordion title="--k8-secret-name">
  The name of the Kubernetes secret to create or update. Required when using `--output=k8-secret`.

  ```bash  theme={"dark"}
  # Example
  infisical bootstrap --k8-secret-name=infisical-bootstrap-credentials
  ```

  This flag is required when using `k8-secret` output.
</Accordion>

<Accordion title="--k8-secret-namespace">
  The namespace where the Kubernetes secret should be created or updated. Required when using `--output=k8-secret`.

  ```bash  theme={"dark"}
  # Example
  infisical bootstrap --k8-secret-namespace=infisical-system
  ```

  This flag is required when using `k8-secret` output.
</Accordion>

## Response

### JSON Output (Default)

The command returns a JSON response with details about the created user, organization, and machine identity:

```json  theme={"dark"}
{
  "identity": {
    "credentials": {
      "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZGVudGl0eUlkIjoiZGIyMjQ3OTItZWQxOC00Mjc3LTlkYWUtNTdlNzUyMzE1ODU0IiwiaWRlbnRpdHlBY2Nlc3NUb2tlbklkIjoiZmVkZmZmMGEtYmU3Yy00NjViLWEwZWEtZjM5OTNjMTg4OGRlIiwiYXV0aFRva2VuVHlwZSI6ImlkZW50aXR5QWNjZXNzVG9rZW4iLCJpYXQiOjE3NDIzMjI0ODl9.mqcZZqIFqER1e9ubrQXp8FbzGYi8nqqZwfMvz09g-8Y"
    },
    "id": "db224792-ed18-4277-9dae-57e752315854",
    "name": "Instance Admin Identity"
  },
  "message": "Successfully bootstrapped instance",
  "organization": {
    "id": "b56bece0-42f5-4262-b25e-be7bf5f84957",
    "name": "dog",
    "slug": "dog-v-e5l"
  },
  "user": {
    "email": "admin@example.com",
    "firstName": "Admin",
    "id": "a418f355-c8da-453c-bbc8-6c07208eeb3c",
    "lastName": "User",
    "superAdmin": true,
    "username": "admin@example.com"
  }
}
```

### Kubernetes Secret Output

When using `--output=k8-secret`, the command creates or updates a Kubernetes secret in your cluster and logs the operation result. This is particularly useful for automated bootstrapping scenarios such as Kubernetes Jobs, GitOps workflows, or when you need to immediately store the admin credentials for use by other applications in your cluster.

## Kubernetes Integration

### Prerequisites for k8-secret Output

When running with `--output=k8-secret`, the command must be executed from within a Kubernetes pod with proper service account permissions. The command automatically:

1. Reads the service account token from `/var/run/secrets/kubernetes.io/serviceaccount/token`
2. Reads the CA certificate from `/var/run/secrets/kubernetes.io/serviceaccount/ca.crt`
3. Gets the Kubernetes API server URL from environment variables (`KUBERNETES_SERVICE_HOST` and `KUBERNETES_SERVICE_PORT_HTTPS`)

### Required RBAC Permissions

Your service account needs the following permissions:

```yaml  theme={"dark"}
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: infisical-bootstrap
rules:
  - apiGroups: [""]
    resources: ["secrets"]
    verbs: ["get", "create", "update"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: infisical-bootstrap
subjects:
  - kind: ServiceAccount
    name: your-service-account
roleRef:
  kind: Role
  name: infisical-bootstrap
  apiGroup: rbac.authorization.k8s.io
```

## Usage with Automation

For automation purposes, you can extract just the machine identity token from the response:

```bash  theme={"dark"}
infisical bootstrap --domain=https://your-infisical-instance.com --email=admin@example.com --password=your-secure-password --organization=your-org-name | jq ".identity.credentials.token"
```

This extracts only the token, which can be captured in a variable or piped to other commands.

## Example: Capture Token in a Variable

```bash  theme={"dark"}
TOKEN=$(infisical bootstrap --domain=https://your-infisical-instance.com --email=admin@example.com --password=your-secure-password --organization=your-org-name | jq -r ".identity.credentials.token")

# Now use the token for further automation
echo "Token has been captured and can be used for authentication"
```

## Notes

* The bootstrap process can only be performed once on a fresh Infisical instance
* All core flags (domain, email, password, organization) are required for the bootstrap process to complete successfully
* Security controls prevent privilege escalation: instance admin identities cannot be managed by non-instance admin users and identities
* The generated admin user account can be used to log in via the UI if needed
* When using `k8-secret` output, the command must run within a Kubernetes pod with proper service account permissions
* The `--ignore-if-bootstrapped` flag is useful for making bootstrap scripts idempotent


# infisical dynamic-secrets
Source: https://infisical.com/docs/cli/commands/dynamic-secrets

Perform dynamic secret operations directly with the CLI

```
infisical dynamic-secrets
```

## Description

Dynamic secrets are unique secrets generated on demand based on the provided configuration settings. For more details, refer to [dynamics secrets section](/documentation/platform/dynamic-secrets/overview).

This command enables you to perform list, lease, renew lease, and revoke lease operations on dynamic secrets within your Infisical project.

### Sub-commands

<Accordion title="infisical dynamic-secrets">
  Use this command to print out all of the dynamic secrets in your project.

  ```bash  theme={"dark"}
  $ infisical dynamic-secrets
  ```

  ### Environment variables

  <Accordion title="INFISICAL_TOKEN">
    Used to fetch dynamic secrets via a [machine identity](/documentation/platform/identities/machine-identities) instead of logged-in credentials. Simply, export this variable in the terminal before running this command.

    ```bash  theme={"dark"}
    # Example
    export INFISICAL_TOKEN=$(infisical login --method=universal-auth --client-id=<identity-client-id> --client-secret=<identity-client-secret> --silent --plain) # --plain flag will output only the token, so it can be fed to an environment variable. --silent will disable any update messages.
    ```
  </Accordion>

  <Accordion title="INFISICAL_DISABLE_UPDATE_CHECK">
    Used to disable the check for new CLI versions. This can improve the time it takes to run this command. Recommended for production environments.

    To use, simply export this variable in the terminal before running this command.

    ```bash  theme={"dark"}
    # Example
    export INFISICAL_DISABLE_UPDATE_CHECK=true
    ```
  </Accordion>

  ### Flags

  <Accordion title="--projectId">
    The project ID to fetch dynamic secrets from.

    ```bash  theme={"dark"}
    # Example
    infisical dynamic-secrets --projectId=<project-id>
    ```
  </Accordion>

  <Accordion title="--project-slug">
    The project slug to fetch dynamic secrets from.

    ```bash  theme={"dark"}
    # Example
    infisical dynamic-secrets --project-slug=<project-slug>
    ```
  </Accordion>

  <Accordion title="--token">
    The authenticated token to fetch dynamic secrets from. This is required when using a machine identity to authenticate.

    ```bash  theme={"dark"}
    # Example
    infisical dynamic-secrets --token=<token>
    ```
  </Accordion>

  <Accordion title="--env">
    Used to select the environment name on which actions should be taken. Default
    value: `dev`
  </Accordion>

  <Accordion title="--path">
    Use to select the project folder on which dynamic secrets will be accessed.

    ```bash  theme={"dark"}
    # Example
    infisical dynamic-secrets --path="/" --env=dev
    ```
  </Accordion>
</Accordion>

<Accordion title="infisical dynamic-secrets lease create">
  This command is used to create a new lease for a dynamic secret.

  ```bash  theme={"dark"}
  $ infisical dynamic-secrets lease create <dynamic-secret-name>
  ```

  ### Flags

  <Accordion title="--env">
    Used to select the environment name on which actions should be taken. Default
    value: `dev`
  </Accordion>

  <Accordion title="--plain">
    The `--plain` flag will output dynamic secret lease credentials values without formatting, one per line.
    Default value: `false`

    ```bash  theme={"dark"}
    # Example
    infisical dynamic-secrets lease create dynamic-secret-postgres --plain
    ```
  </Accordion>

  <Accordion title="--path">
    The `--path` flag indicates which project folder dynamic secrets will be injected from.

    ```bash  theme={"dark"}
    # Example
    infisical dynamic-secrets lease create <dynamic-secret-name> --path="/" --env=dev
    ```
  </Accordion>

  <Accordion title="--projectId">
    The project ID of the dynamic secrets to lease from.

    ```bash  theme={"dark"}
    # Example
    infisical dynamic-secrets lease create <dynamic-secret-name> --projectId=<project-id>
    ```
  </Accordion>

  <Accordion title="--project-slug">
    The project slug of the dynamic secrets to lease from.

    ```bash  theme={"dark"}
    # Example
    infisical dynamic-secrets lease create <dynamic-secret-name> --project-slug=<project-slug>
    ```
  </Accordion>

  <Accordion title="--token">
    The authenticated token to create dynamic secret leases. This is required when using a machine identity to authenticate.

    ```bash  theme={"dark"}
    # Example
    infisical dynamic-secrets lease create <dynamic-secret-name> --token=<token>
    ```
  </Accordion>

  <Accordion title="--ttl">
    The lease lifetime. If not provided, the default TTL of the dynamic secret root credential will be used.

    ```bash  theme={"dark"}
    # Example
    infisical dynamic-secrets lease create <dynamic-secret-name> --ttl=<ttl>
    ```
  </Accordion>

  ### Provider-specific flags

  The following flags are specific to certain providers or integrations:

  <Accordion title="Kubernetes">
    <Accordion title="--kubernetes-namespace">
      The namespace to create the lease in. Only used for Kubernetes dynamic secrets.

      ```bash  theme={"dark"}
      # Example
      infisical dynamic-secrets lease create <dynamic-secret-name> --kubernetes-namespace=<namespace>
      ```
    </Accordion>
  </Accordion>
</Accordion>

<Accordion title="infisical dynamic-secrets lease list">
  This command is used to list leases for a dynamic secret.

  ```bash  theme={"dark"}
  $ infisical dynamic-secrets lease list <dynamic-secret-name>
  ```

  ### Flags

  <Accordion title="--env">
    Used to select the environment name on which actions should be taken. Default
    value: `dev`
  </Accordion>

  <Accordion title="--path">
    The `--path` flag indicates which project folder dynamic secrets will be injected from.

    ```bash  theme={"dark"}
    # Example
    infisical dynamic-secrets lease list <dynamic-secret-name> --path="/" --env=dev
    ```
  </Accordion>

  <Accordion title="--projectId">
    The project ID of the dynamic secrets to list leases from.

    ```bash  theme={"dark"}
    # Example
    infisical dynamic-secrets lease list <dynamic-secret-name> --projectId=<project-id>
    ```
  </Accordion>

  <Accordion title="--project-slug">
    The project slug of the dynamic secrets to list leases from.

    ```bash  theme={"dark"}
    # Example
    infisical dynamic-secrets lease list <dynamic-secret-name> --project-slug=<project-slug>
    ```
  </Accordion>

  <Accordion title="--token">
    The authenticated token to list dynamic secret leases. This is required when using a machine identity to authenticate.

    ```bash  theme={"dark"}
    # Example
    infisical dynamic-secrets lease list <dynamic-secret-name> --token=<token>
    ```
  </Accordion>
</Accordion>

<Accordion title="infisical dynamic-secrets lease renew">
  This command is used to renew a lease before it expires.

  ```bash  theme={"dark"}
  $ infisical dynamic-secrets lease renew <lease-id>
  ```

  ### Flags

  <Accordion title="--env">
    Used to select the environment name on which actions should be taken. Default
    value: `dev`
  </Accordion>

  <Accordion title="--path">
    The `--path` flag indicates which project folder dynamic secrets will be renewed from.

    ```bash  theme={"dark"}
    # Example
    infisical dynamic-secrets lease renew <lease-id> --path="/" --env=dev
    ```
  </Accordion>

  <Accordion title="--projectId">
    The project ID of the dynamic secret to lease from.

    ```bash  theme={"dark"}
    # Example
    infisical dynamic-secrets lease renew <lease-id> --projectId=<project-id>
    ```
  </Accordion>

  <Accordion title="--project-slug">
    The project slug of the dynamic secret to lease from.

    ```bash  theme={"dark"}
    # Example
    infisical dynamic-secrets lease renew <lease-id> --project-slug=<project-slug>
    ```
  </Accordion>

  <Accordion title="--token">
    The authenticated token to create dynamic secret leases. This is required when using a machine identity to authenticate.

    ```bash  theme={"dark"}
    # Example
    infisical dynamic-secrets lease renew <lease-id> --token=<token>
    ```
  </Accordion>

  <Accordion title="--ttl">
    The lease lifetime. If not provided, the default TTL of the dynamic secret root credential will be used.

    ```bash  theme={"dark"}
    # Example
    infisical dynamic-secrets lease renew <lease-id> --ttl=<ttl>
    ```
  </Accordion>
</Accordion>

<Accordion title="infisical dynamic-secrets lease delete">
  This command is used to delete a lease.

  ```bash  theme={"dark"}
  $ infisical dynamic-secrets lease delete <lease-id>
  ```

  ### Flags

  <Accordion title="--env">
    Used to select the environment name on which actions should be taken. Default
    value: `dev`
  </Accordion>

  <Accordion title="--path">
    The `--path` flag indicates which project folder dynamic secrets will be deleted from.

    ```bash  theme={"dark"}
    # Example
    infisical dynamic-secrets lease delete <lease-id> --path="/" --env=dev
    ```
  </Accordion>

  <Accordion title="--projectId">
    The project ID of the dynamic secret to delete lease from.

    ```bash  theme={"dark"}
    # Example
    infisical dynamic-secrets lease delete <lease-id> --projectId=<project-id>
    ```
  </Accordion>

  <Accordion title="--project-slug">
    The project slug of the dynamic secret to delete lease from.

    ```bash  theme={"dark"}
    # Example
    infisical dynamic-secrets lease delete <lease-id> --project-slug=<project-slug>
    ```
  </Accordion>

  <Accordion title="--token">
    The authenticated token to delete dynamic secret leases. This is required when using a machine identity to authenticate.

    ```bash  theme={"dark"}
    # Example
    infisical dynamic-secrets lease delete <lease-id> --token=<token>
    ```
  </Accordion>
</Accordion>


# infisical export
Source: https://infisical.com/docs/cli/commands/export

Export Infisical secrets from CLI into different file formats

```bash  theme={"dark"}
infisical export [options]
```

## Description

Export environment variables from the platform into a file format. By default, output is sent to stdout (standard output), but you can use the `--output-file` flag to save directly to a file.

## Subcommands & flags

<Accordion title="infisical export" defaultOpen="true">
  Use this command to export environment variables from the platform into a raw file formats

  ```bash  theme={"dark"}
  $ infisical export

  # Export variables to a .env file
  infisical export > .env
  infisical export --output-file=./.env

  # Export variables to a .env file (with export keyword)
  infisical export --format=dotenv-export > .env
  infisical export --format=dotenv-export --output-file=./.env

  # Export variables to a JSON file
  infisical export --format=json > secrets.json
  infisical export --format=json --output-file=./secrets.json

  # Export variables to a YAML file
  infisical export --format=yaml > secrets.yaml
  infisical export --format=yaml --output-file=./secrets.yaml

  # Render secrets using a custom template file
  infisical export --template=<path to template>
  ```

  ### Environment variables

  <Accordion title="INFISICAL_TOKEN">
    Used to fetch secrets via a [machine identities](/documentation/platform/identities/machine-identities) apposed to logged in credentials. Simply, export this variable in the terminal before running this command.

    ```bash  theme={"dark"}
    # Example
    export INFISICAL_TOKEN=$(infisical login --method=universal-auth --client-id=<identity-client-id> --client-secret=<identity-client-secret> --silent --plain) # --plain flag will output only the token, so it can be fed to an environment variable. --silent will disable any update messages.
    ```

    <Info>
      Alternatively, you may use service tokens.

      ```bash  theme={"dark"}
      # Example
      export INFISICAL_TOKEN=<service-token>
      ```
    </Info>
  </Accordion>

  <Accordion title="INFISICAL_DISABLE_UPDATE_CHECK">
    Used to disable the check for new CLI versions. This can improve the time it takes to run this command. Recommended for production environments.

    To use, simply export this variable in the terminal before running this command.

    ```bash  theme={"dark"}
    # Example
    export INFISICAL_DISABLE_UPDATE_CHECK=true
    ```
  </Accordion>

  ### flags

  <Accordion title="--output-file">
    The path to write the output file to. Can be a full file path, directory, or filename.

    ```bash  theme={"dark"}
    # Export to specific file
    infisical export --format=json --output-file=./secrets.json

    # Export to directory (uses default filename based on format)
    infisical export --format=yaml --output-file=./
    ```

    **When `--output-file` is specified:**

    * Secrets are saved directly to the specified file
    * A success message is displayed showing the file path
    * For directories: adds default filename `secrets.{format}` (e.g., `secrets.json`, `secrets.yaml`)
    * For dotenv formats in directories: uses `.env` as the filename

    **When `--output-file` is NOT specified (default behavior):**

    * Output is sent to stdout (standard output)
    * You can use shell redirection like `infisical export > secrets.json`
    * Maintains backwards compatibility with existing scripts

    <Warning>
      If you're using shell redirection and your token expires, re-authentication will fail because the prompt can't display properly due to the redirection.
    </Warning>
  </Accordion>

  <Accordion title="--template">
    The `--template` flag specifies the path to the template file used for rendering secrets. When using templates, you can omit the other format flags.

    ```text my-template-file theme={"dark"}
    {{$secrets := secret "<infisical-project-id>" "<environment-slug>" "<folder-path>"}}
    {{$length := len $secrets}}
    {{- "{"}}
    {{- with $secrets }}
    {{- range $index, $secret := . }}
    "{{ $secret.Key }}": "{{ $secret.Value }}"{{if lt $index (minus $length 1)}},{{end}}
    {{- end }}
    {{- end }}
    {{ "}" -}}
    ```

    ```bash  theme={"dark"}
    # Example
    infisical export --template="/path/to/template/file"
    ```
  </Accordion>

  <Accordion title="--env">
    Used to set the environment that secrets are pulled from.

    ```bash  theme={"dark"}
    # Example
    infisical export --env=prod
    ```

    Note: this flag only accepts environment slug names not the fully qualified name. To view the slug name of an environment, visit the project settings page.

    default value: `dev`
  </Accordion>

  <Accordion title="--projectId">
    By default the project id is retrieved from the `.infisical.json` located at the root of your local project.
    This flag allows you to override this behavior by explicitly defining the project to fetch your secrets from.

    ```bash  theme={"dark"}
    # Example

    infisical export --projectId=XXXXXXXXXXXXXX
    ```
  </Accordion>

  <Accordion title="--expand">
    Parse shell parameter expansions in your secrets (e.g., `${DOMAIN}`)

    Default value: `true`
  </Accordion>

  <Accordion title="--include-imports">
    By default imported secrets are available, you can disable it by setting this option to false.

    Default value: `true`
  </Accordion>

  <Accordion title="--format">
    Format of the output file. Accepted values: `dotenv`, `dotenv-export`, `csv`, `json` and `yaml`

    Default value: `dotenv`
  </Accordion>

  <Accordion title="--secret-overriding">
    Prioritizes personal secrets with the same name over shared secrets

    Default value: `true`
  </Accordion>

  <Accordion title="--path">
    The `--path` flag indicates which project folder secrets will be injected from.

    ```bash  theme={"dark"}
    # Example
    infisical export --path="/path/to/folder" --env=dev
    ```
  </Accordion>

  <Accordion title="--tags">
    When working with tags, you can use this flag to filter and retrieve only secrets that are associated with a specific tag(s).

    ```bash  theme={"dark"}
    # Example
    infisical export --tags=tag1,tag2,tag3 --env=dev
    ```

    Note: you must reference the tag by its slug name not its fully qualified name. Go to project settings to view all tag slugs.

    By default, all secrets are fetched
  </Accordion>
</Accordion>


# infisical gateway
Source: https://infisical.com/docs/cli/commands/gateway

Run the Infisical gateway or manage its systemd service

<Tabs>
  <Tab title="Start gateway">
    ```bash  theme={"dark"}
    sudo infisical gateway start --name=<name> --auth-method=<auth-method>
    ```
  </Tab>

  <Tab title="Start gateway as background daemon (Linux only)">
    ```bash  theme={"dark"}
    sudo infisical gateway systemd install --token=<token> --domain=<domain> --name=<name>
    ```
  </Tab>
</Tabs>

## Description

The Infisical gateway provides secure access to private resources using modern TCP-based SSH tunnel architecture with enhanced security and flexible deployment options.

The gateway system uses SSH reverse tunnels over TCP, eliminating firewall complexity and providing excellent performance for enterprise environments.

<Warning>
  **Deprecation and Migration Notice:** The legacy `infisical gateway` command (v1) will be removed in a future release. Please migrate to `infisical gateway start` (Gateway v2).

  If you are moving from Gateway v1 to Gateway v2, this is NOT a drop-in switch. Gateway v2 creates new gateway instances with new gateway IDs. You must update any existing resources that reference gateway IDs (for example: dynamic secret configs, app connections, or other gateway-bound resources) to point to the new Gateway v2 gateway resource. Until you update those references, traffic will continue to target the old v1 gateway.
</Warning>

## Subcommands & flags

<AccordionGroup>
  <Accordion title="infisical gateway start" defaultOpen="true">
    Run the Infisical gateway component within your the network where your target resources are located. The gateway establishes an SSH reverse tunnel to a relay server and provides secure access to private resources within your network.

    ```bash  theme={"dark"}
    sudo infisical gateway start --name=<name> --auth-method=<auth-method>
    ```

    <Info>
      By default, the gateway automatically connects to the relay with the lowest latency. To target a specific relay, use the `--relay=<relay-name>` flag.
    </Info>

    Once started, the gateway component will:

    * Automatically connect to a healthy relay with the lowest latency (unless the `--relay` flag is specified)
    * Establish outbound SSH reverse tunnel to relay server (no inbound firewall rules needed)
    * Authenticate using SSH certificates issued by Infisical
    * Automatically reconnect if the connection is lost
    * Provide access to private resources within your network

    ### Authentication

    The Gateway supports multiple authentication methods. Below are the available authentication methods, with their respective flags.

    <AccordionGroup>
      <Accordion title="Universal Auth">
        The Universal Auth method is a simple and secure way to authenticate with Infisical. It requires a client ID and a client secret to authenticate with Infisical.

        <ParamField query="Flags">
          <Expandable title="properties">
            <ParamField query="client-id" type="string" required>
              Your machine identity client ID.
            </ParamField>

            <ParamField query="client-secret" type="string" required>
              Your machine identity client secret.
            </ParamField>

            <ParamField query="auth-method" type="string" required>
              The authentication method to use. Must be `universal-auth` when using Universal Auth.
            </ParamField>
          </Expandable>
        </ParamField>

        ```bash  theme={"dark"}
          sudo infisical gateway start --auth-method=universal-auth --client-id=<client-id> --client-secret=<client-secret> --name=<name>
        ```
      </Accordion>

      <Accordion title="Native Kubernetes">
        The Native Kubernetes method is used to authenticate with Infisical when running in a Kubernetes environment. It requires a service account token to authenticate with Infisical.

        <ParamField query="Flags">
          <Expandable title="properties">
            <ParamField query="machine-identity-id" type="string" required>
              Your machine identity ID.
            </ParamField>

            <ParamField query="service-account-token-path" type="string" optional>
              Path to the Kubernetes service account token to use. Default: `/var/run/secrets/kubernetes.io/serviceaccount/token`.
            </ParamField>

            <ParamField query="auth-method" type="string" required>
              The authentication method to use. Must be `kubernetes` when using Native Kubernetes.
            </ParamField>
          </Expandable>
        </ParamField>

        ```bash  theme={"dark"}
          sudo infisical gateway start --auth-method=kubernetes --machine-identity-id=<machine-identity-id> --name=<name>
        ```
      </Accordion>

      <Accordion title="Native Azure">
        The Native Azure method is used to authenticate with Infisical when running in an Azure environment.

        <ParamField query="Flags">
          <Expandable title="properties">
            <ParamField query="machine-identity-id" type="string" required>
              Your machine identity ID.
            </ParamField>

            <ParamField query="auth-method" type="string" required>
              The authentication method to use. Must be `azure` when using Native Azure.
            </ParamField>
          </Expandable>
        </ParamField>

        ```bash  theme={"dark"}
          sudo infisical gateway start --auth-method=azure --machine-identity-id=<machine-identity-id> --name=<name>
        ```
      </Accordion>

      <Accordion title="Native GCP ID Token">
        The Native GCP ID Token method is used to authenticate with Infisical when running in a GCP environment.

        <ParamField query="Flags">
          <Expandable title="properties">
            <ParamField query="machine-identity-id" type="string" required>
              Your machine identity ID.
            </ParamField>

            <ParamField query="auth-method" type="string" required>
              The authentication method to use. Must be `gcp-id-token` when using Native GCP ID Token.
            </ParamField>
          </Expandable>
        </ParamField>

        ```bash  theme={"dark"}
          sudo infisical gateway start --auth-method=gcp-id-token --machine-identity-id=<machine-identity-id> --name=<name>
        ```
      </Accordion>

      <Accordion title="GCP IAM">
        The GCP IAM method is used to authenticate with Infisical with a GCP service account key.

        <ParamField query="Flags">
          <Expandable title="properties">
            <ParamField query="machine-identity-id" type="string" required>
              Your machine identity ID.
            </ParamField>

            <ParamField query="service-account-key-file-path" type="string" required>
              Path to your GCP service account key file *(Must be in JSON format!)*
            </ParamField>

            <ParamField query="auth-method" type="string" required>
              The authentication method to use. Must be `gcp-iam` when using GCP IAM.
            </ParamField>
          </Expandable>
        </ParamField>

        ```bash  theme={"dark"}
          sudo infisical gateway start --auth-method=gcp-iam --machine-identity-id=<machine-identity-id> --service-account-key-file-path=<service-account-key-file-path> --name=<name>
        ```
      </Accordion>

      <Accordion title="Native AWS IAM">
        The AWS IAM method is used to authenticate with Infisical with an AWS IAM role while running in an AWS environment like EC2, Lambda, etc.

        <ParamField query="Flags">
          <Expandable title="properties">
            <ParamField query="machine-identity-id" type="string" required>
              Your machine identity ID.
            </ParamField>

            <ParamField query="auth-method" type="string" required>
              The authentication method to use. Must be `aws-iam` when using Native AWS IAM.
            </ParamField>
          </Expandable>
        </ParamField>

        ```bash  theme={"dark"}
          sudo infisical gateway start --auth-method=aws-iam --machine-identity-id=<machine-identity-id> --name=<name>
        ```
      </Accordion>

      <Accordion title="OIDC Auth">
        The OIDC Auth method is used to authenticate with Infisical via identity tokens with OIDC.

        <ParamField query="Flags">
          <Expandable title="properties">
            <ParamField query="machine-identity-id" type="string" required>
              Your machine identity ID.
            </ParamField>

            <ParamField query="jwt" type="string" required>
              The OIDC JWT from the identity provider.
            </ParamField>

            <ParamField query="auth-method" type="string" required>
              The authentication method to use. Must be `oidc-auth` when using OIDC Auth.
            </ParamField>
          </Expandable>
        </ParamField>

        ```bash  theme={"dark"}
          sudo infisical gateway start --auth-method=oidc-auth --machine-identity-id=<machine-identity-id> --jwt=<oidc-jwt> --name=<name>
        ```
      </Accordion>

      <Accordion title="JWT Auth">
        The JWT Auth method is used to authenticate with Infisical via a JWT token.

        <ParamField query="Flags">
          <Expandable title="properties">
            <ParamField query="jwt" type="string" required>
              The JWT token to use for authentication.
            </ParamField>

            <ParamField query="machine-identity-id" type="string" required>
              Your machine identity ID.
            </ParamField>

            <ParamField query="auth-method" type="string" required>
              The authentication method to use. Must be `jwt-auth` when using JWT Auth.
            </ParamField>
          </Expandable>
        </ParamField>

        ```bash  theme={"dark"}
          sudo infisical gateway start --auth-method=jwt-auth --jwt=<jwt> --machine-identity-id=<machine-identity-id> --name=<name>
        ```
      </Accordion>

      <Accordion title="Token Auth">
        You can use the `INFISICAL_TOKEN` environment variable to authenticate with Infisical with a raw machine identity access token.

        <ParamField query="Flags">
          <Expandable title="properties">
            <ParamField query="token" type="string" required>
              The machine identity access token to use for authentication.
            </ParamField>
          </Expandable>
        </ParamField>

        ```bash  theme={"dark"}
          sudo infisical gateway start --token=<token> --name=<name>
        ```
      </Accordion>
    </AccordionGroup>

    ### Other Flags

    <AccordionGroup>
      <Accordion title="--relay">
        The name of the relay that this gateway should connect to. The relay must be running and registered before starting the gateway.

        If this flag is omitted, the gateway will automatically connect to a healthy relay with the lowest latency.

        ```bash  theme={"dark"}
        # Example
        sudo infisical gateway start --relay=my-relay --name=my-gateway --token=<token>
        ```

        **Note:** For Infisical Cloud users using instance relays, the relay infrastructure is already running and managed by Infisical. If using organization relays or self-hosted instance relays, you must first start a relay server. For more information on deploying relays, refer to the [Relay Deployment Guide](/documentation/platform/gateways/relay-deployment).
      </Accordion>

      <Accordion title="--name">
        The name of the gateway instance.

        ```bash  theme={"dark"}
        # Example
        sudo infisical gateway start --name=my-gateway --token=<token>
        ```
      </Accordion>

      <Accordion title="--domain">
        Domain of your self-hosted Infisical instance.

        ```bash  theme={"dark"}
        # Example
        sudo infisical gateway start --domain=https://app.your-domain.com --name=<name>
        ```
      </Accordion>
    </AccordionGroup>
  </Accordion>

  <Accordion title="infisical gateway systemd install">
    Install and enable the gateway as a systemd service. This command must be run with sudo on Linux.

    ```bash  theme={"dark"}
    sudo infisical gateway systemd install --token=<token> --domain=<domain> --name=<name>
    ```

    ### Requirements

    * Must be run on Linux
    * Must be run with root/sudo privileges
    * Requires systemd

    ### Flags

    <AccordionGroup>
      <Accordion title="--token">
        The machine identity access token to authenticate with Infisical.

        ```bash  theme={"dark"}
        # Example
        sudo infisical gateway systemd install --token=<token> --name=<name>
        ```

        You may also expose the token to the CLI by setting the environment variable `INFISICAL_TOKEN` before executing the install command.
      </Accordion>

      <Accordion title="--domain">
        Domain of your self-hosted Infisical instance.

        ```bash  theme={"dark"}
        # Example
        sudo infisical gateway systemd install --domain=https://app.your-domain.com --name=<name>
        ```
      </Accordion>

      <Accordion title="--name">
        The name of the gateway instance.

        ```bash  theme={"dark"}
        # Example
        sudo infisical gateway systemd install --name=my-gateway --token=<token>
        ```
      </Accordion>

      <Accordion title="--relay">
        The name of the relay that this gateway should connect to. The relay must be running and registered before starting the gateway.

        If this flag is omitted, the gateway will automatically connect to a healthy relay with the lowest latency.

        ```bash  theme={"dark"}
        # Example
        sudo infisical gateway systemd install --relay=my-relay --token=<token> --name=<name>
        ```

        **Note:** For Infisical Cloud users using instance relays, the relay infrastructure is already running and managed by Infisical. If using organization relays or self-hosted instance relays, you must first start a relay server. For more information on deploying relays, refer to the [Relay Deployment Guide](/documentation/platform/gateways/relay-deployment).
      </Accordion>
    </AccordionGroup>

    ### Service Details

    The systemd service is installed with secure defaults:

    * Service file: `/etc/systemd/system/infisical-gateway.service`
    * Config file: `/etc/infisical/gateway.conf`
    * Runs with restricted privileges:
      * InaccessibleDirectories=/home
      * PrivateTmp=yes
      * Resource limits configured for stability
    * Automatically restarts on failure
    * Enabled to start on boot
    * Maintains persistent SSH reverse tunnel connections to the specified relay
    * Handles certificate rotation and connection recovery automatically

    After installation, manage the service with standard systemd commands:

    ```bash  theme={"dark"}
    sudo systemctl start infisical-gateway    # Start the service
    sudo systemctl stop infisical-gateway     # Stop the service
    sudo systemctl status infisical-gateway   # Check service status
    sudo systemctl disable infisical-gateway  # Disable auto-start on boot
    ```
  </Accordion>
</AccordionGroup>

## Legacy Gateway Commands

<AccordionGroup>
  <Accordion title="infisical gateway (deprecated)">
    <Warning>
      **This command is deprecated and will be removed in a future release.**

      Please migrate to `infisical gateway start` for the new TCP-based SSH tunnel architecture.

      **Migration required:** If you are currently using Gateway v1 (via `infisical gateway`), moving to Gateway v2 is not in-place. Gateway v2 provisions new gateway instances with new gateway IDs. Update any resources that reference a gateway ID (for example: dynamic secret configs, app connections, or other gateway-bound resources) to use the new Gateway v2 gateway ID. Until you update those references, traffic will continue to target the old v1 gateway.
    </Warning>

    Run the legacy Infisical gateway in the foreground. The gateway will connect to the relay service and maintain a persistent connection.

    ```bash  theme={"dark"}
    infisical gateway --domain=<domain> --auth-method=<auth-method>
    ```

    ### Authentication

    The Infisical CLI supports multiple authentication methods. Below are the available authentication methods, with their respective flags.

    <AccordionGroup>
      <Accordion title="Universal Auth">
        The Universal Auth method is a simple and secure way to authenticate with Infisical. It requires a client ID and a client secret to authenticate with Infisical.

        <ParamField query="Flags">
          <Expandable title="properties">
            <ParamField query="client-id" type="string" required>
              Your machine identity client ID.
            </ParamField>

            <ParamField query="client-secret" type="string" required>
              Your machine identity client secret.
            </ParamField>

            <ParamField query="auth-method" type="string" required>
              The authentication method to use. Must be `universal-auth` when using Universal Auth.
            </ParamField>
          </Expandable>
        </ParamField>

        ```bash  theme={"dark"}
          infisical gateway --auth-method=universal-auth --client-id=<client-id> --client-secret=<client-secret>
        ```
      </Accordion>

      <Accordion title="Native Kubernetes">
        The Native Kubernetes method is used to authenticate with Infisical when running in a Kubernetes environment. It requires a service account token to authenticate with Infisical.

        <ParamField query="Flags">
          <Expandable title="properties">
            <ParamField query="machine-identity-id" type="string" required>
              Your machine identity ID.
            </ParamField>

            <ParamField query="service-account-token-path" type="string" optional>
              Path to the Kubernetes service account token to use. Default: `/var/run/secrets/kubernetes.io/serviceaccount/token`.
            </ParamField>

            <ParamField query="auth-method" type="string" required>
              The authentication method to use. Must be `kubernetes` when using Native Kubernetes.
            </ParamField>
          </Expandable>
        </ParamField>

        ```bash  theme={"dark"}
          infisical gateway --auth-method=kubernetes --machine-identity-id=<machine-identity-id>
        ```
      </Accordion>

      <Accordion title="Native Azure">
        The Native Azure method is used to authenticate with Infisical when running in an Azure environment.

        <ParamField query="Flags">
          <Expandable title="properties">
            <ParamField query="machine-identity-id" type="string" required>
              Your machine identity ID.
            </ParamField>

            <ParamField query="auth-method" type="string" required>
              The authentication method to use. Must be `azure` when using Native Azure.
            </ParamField>
          </Expandable>
        </ParamField>

        ```bash  theme={"dark"}
          infisical gateway --auth-method=azure --machine-identity-id=<machine-identity-id>
        ```
      </Accordion>

      <Accordion title="Native GCP ID Token">
        The Native GCP ID Token method is used to authenticate with Infisical when running in a GCP environment.

        <ParamField query="Flags">
          <Expandable title="properties">
            <ParamField query="machine-identity-id" type="string" required>
              Your machine identity ID.
            </ParamField>

            <ParamField query="auth-method" type="string" required>
              The authentication method to use. Must be `gcp-id-token` when using Native GCP ID Token.
            </ParamField>
          </Expandable>
        </ParamField>

        ```bash  theme={"dark"}
          infisical gateway --auth-method=gcp-id-token --machine-identity-id=<machine-identity-id>
        ```
      </Accordion>

      <Accordion title="GCP IAM">
        The GCP IAM method is used to authenticate with Infisical with a GCP service account key.

        <ParamField query="Flags">
          <Expandable title="properties">
            <ParamField query="machine-identity-id" type="string" required>
              Your machine identity ID.
            </ParamField>

            <ParamField query="service-account-key-file-path" type="string" required>
              Path to your GCP service account key file *(Must be in JSON format!)*
            </ParamField>

            <ParamField query="auth-method" type="string" required>
              The authentication method to use. Must be `gcp-iam` when using GCP IAM.
            </ParamField>
          </Expandable>
        </ParamField>

        ```bash  theme={"dark"}
          infisical gateway --auth-method=gcp-iam --machine-identity-id=<machine-identity-id> --service-account-key-file-path=<service-account-key-file-path>
        ```
      </Accordion>

      <Accordion title="Native AWS IAM">
        The AWS IAM method is used to authenticate with Infisical with an AWS IAM role while running in an AWS environment like EC2, Lambda, etc.

        <ParamField query="Flags">
          <Expandable title="properties">
            <ParamField query="machine-identity-id" type="string" required>
              Your machine identity ID.
            </ParamField>

            <ParamField query="auth-method" type="string" required>
              The authentication method to use. Must be `aws-iam` when using Native AWS IAM.
            </ParamField>
          </Expandable>
        </ParamField>

        ```bash  theme={"dark"}
          infisical gateway --auth-method=aws-iam --machine-identity-id=<machine-identity-id>
        ```
      </Accordion>

      <Accordion title="OIDC Auth">
        The OIDC Auth method is used to authenticate with Infisical via identity tokens with OIDC.

        <ParamField query="Flags">
          <Expandable title="properties">
            <ParamField query="machine-identity-id" type="string" required>
              Your machine identity ID.
            </ParamField>

            <ParamField query="jwt" type="string" required>
              The OIDC JWT from the identity provider.
            </ParamField>

            <ParamField query="auth-method" type="string" required>
              The authentication method to use. Must be `oidc-auth` when using OIDC Auth.
            </ParamField>
          </Expandable>
        </ParamField>

        ```bash  theme={"dark"}
          infisical gateway --auth-method=oidc-auth --machine-identity-id=<machine-identity-id> --jwt=<oidc-jwt>
        ```
      </Accordion>

      <Accordion title="JWT Auth">
        The JWT Auth method is used to authenticate with Infisical via a JWT token.

        <ParamField query="Flags">
          <Expandable title="properties">
            <ParamField query="jwt" type="string" required>
              The JWT token to use for authentication.
            </ParamField>

            <ParamField query="machine-identity-id" type="string" required>
              Your machine identity ID.
            </ParamField>

            <ParamField query="auth-method" type="string" required>
              The authentication method to use. Must be `jwt-auth` when using JWT Auth.
            </ParamField>
          </Expandable>
        </ParamField>

        ```bash  theme={"dark"}
          infisical gateway --auth-method=jwt-auth --jwt=<jwt> --machine-identity-id=<machine-identity-id>
        ```
      </Accordion>

      <Accordion title="Token Auth">
        You can use the `INFISICAL_TOKEN` environment variable to authenticate with Infisical with a raw machine identity access token.

        <ParamField query="Flags">
          <Expandable title="properties">
            <ParamField query="token" type="string" required>
              The machine identity access token to use for authentication.
            </ParamField>
          </Expandable>
        </ParamField>

        ```bash  theme={"dark"}
          infisical gateway --token=<token>
        ```
      </Accordion>
    </AccordionGroup>

    ### Other Flags

    <AccordionGroup>
      <Accordion title="--domain">
        Domain of your self-hosted Infisical instance.

        ```bash  theme={"dark"}
        # Example
        infisical gateway --domain=https://app.your-domain.com
        ```
      </Accordion>
    </AccordionGroup>
  </Accordion>

  <Accordion title="infisical gateway install (deprecated)">
    <Warning>
      **This command is deprecated and will be removed in a future release.**

      Please migrate to `infisical gateway systemd install` for the new TCP-based SSH tunnel architecture with enhanced security and better performance.

      **Migration required:** If you previously installed Gateway v1 via `infisical gateway install`, moving to Gateway v2 is not in-place. Gateway v2 provisions new gateway instances with new gateway IDs. Update any resources that reference a gateway ID (for example: dynamic secret configs, app connections, or other gateway-bound resources) to use the new Gateway v2 gateway ID. Until you update those references, traffic will continue to target the old v1 gateway.
    </Warning>

    Install and enable the legacy gateway as a systemd service. This command must be run with sudo on Linux.

    ```bash  theme={"dark"}
    sudo infisical gateway install --token=<token> --domain=<domain>
    ```

    ### Requirements

    * Must be run on Linux
    * Must be run with root/sudo privileges
    * Requires systemd

    ### Flags

    <AccordionGroup>
      <Accordion title="--token">
        The machine identity access token to authenticate with Infisical.

        ```bash  theme={"dark"}
        # Example
        sudo infisical gateway install --token=<token>
        ```

        You may also expose the token to the CLI by setting the environment variable `INFISICAL_TOKEN` before executing the install command.
      </Accordion>

      <Accordion title="--domain">
        Domain of your self-hosted Infisical instance.

        ```bash  theme={"dark"}
        # Example
        sudo infisical gateway install --domain=https://app.your-domain.com
        ```
      </Accordion>
    </AccordionGroup>

    ### Service Details

    The systemd service is installed with secure defaults:

    * Service file: `/etc/systemd/system/infisical-gateway.service`
    * Config file: `/etc/infisical/gateway.conf`
    * Runs with restricted privileges:
      * InaccessibleDirectories=/home
      * PrivateTmp=yes
      * Resource limits configured for stability
    * Automatically restarts on failure
    * Enabled to start on boot

    After installation, manage the service with standard systemd commands:

    ```bash  theme={"dark"}
    sudo systemctl start infisical-gateway    # Start the service
    sudo systemctl stop infisical-gateway     # Stop the service
    sudo systemctl status infisical-gateway   # Check service status
    sudo systemctl disable infisical-gateway  # Disable auto-start on boot
    ```
  </Accordion>
</AccordionGroup>

## Frequently Asked Questions

<AccordionGroup>
  <Accordion title="How are relays auto-selected?">
    If the `--relay` flag is omitted, the gateway automatically selects the optimal relay. It first checks for healthy organization relays and connects to the one with the lowest latency. If no organization relays are available, it then performs the same latency-based selection among the available managed relays.
  </Accordion>

  <Accordion title="When restarting the gateway without a relay flag, does it select a new relay every time?">
    No. The first time the gateway starts, it selects the optimal relay (based on latency) and caches that selection. On subsequent restarts, it will prioritize connecting to the cached relay. If it's unable to connect, it will then re-evaluate and connect to the next most optimal relay available.
  </Accordion>
</AccordionGroup>


# infisical init
Source: https://infisical.com/docs/cli/commands/init

Switch between Infisical projects within CLI

```bash  theme={"dark"}
infisical init
```

## Description

Link a local project to your Infisical project. Once connected, you can then access the secrets locally from the connected Infisical project.

<Info>
  This command creates a `infisical.json` file containing your Project ID.
</Info>


# infisical login
Source: https://infisical.com/docs/cli/commands/login

Login into Infisical from the CLI

```bash  theme={"dark"}
infisical login
```

### Description

The CLI uses authentication to verify your identity. You can authenticate using:

* **Browser Login** (default): Opens a browser for authentication
* **Direct Login**: Provide email and password via flags or environment variables for non-interactive workflows
* **Interactive CLI Login**: Use the `--interactive` flag to enter credentials via CLI prompts

When authenticated, a token is generated and saved in your system Keyring to allow you to make future interactions with the CLI.

To change where the login credentials are stored, visit the [vaults command](./vault).

If you have added multiple users, you can switch between the users by using the [user command](./user).

<Info>
  **JWT Token Output:**

  * For **user authentication** with the `--plain --silent` flags: outputs only the JWT access token (useful for scripting)
  * For **machine identity authentication**: an access token is always printed to the console

  Use the `--plain` flag to print only the token in plain text and the `--silent` flag to disable update alerts.

  Both flags are ideal for capturing the token in environment variables or CI/CD pipelines.
</Info>

### Authentication Methods

The Infisical CLI supports two main categories of authentication: User Authentication and Machine Identity Authentication.

#### User Authentication

User authentication is designed for individual developers and supports multiple login flows.

<AccordionGroup>
  <Accordion title="User">
    The User authentication method allows you to log in with your email and password. This method supports three different login flows:

    * **Browser Login** (default): Opens a browser for authentication
    * **Direct Login**: Provide credentials via flags or environment variables for CI/CD
    * **Interactive CLI Login**: Enter credentials via CLI prompts using `--interactive`

    <ParamField query="Flags">
      <Expandable title="properties">
        <ParamField query="email" type="string" optional>
          Your email address. Required for direct login along with `--password` and `--organization-id`.
        </ParamField>

        <ParamField query="password" type="string" optional>
          Your password. Required for direct login along with `--email` and `--organization-id`.
        </ParamField>

        <ParamField query="organization-id" type="string" optional>
          Your organization id. Required for direct login along with `--password` and `--email`.
        </ParamField>

        <ParamField query="interactive" type="boolean" optional>
          Force interactive CLI login instead of browser-based authentication.
        </ParamField>

        <ParamField query="plain" type="boolean" optional>
          Output only the JWT token (useful for scripting and CI/CD).
        </ParamField>
      </Expandable>
    </ParamField>

    <AccordionGroup>
      <Accordion title="Browser Login (Default)">
        ```bash  theme={"dark"}
        infisical login
        ```
      </Accordion>

      <Accordion title="Direct Login (CI/CD)">
        ```bash  theme={"dark"}
        infisical login --email=user@example.com --password=your-password --organization-id=your-organization-id

        # Or using environment variables
        export INFISICAL_EMAIL="user@example.com"
        export INFISICAL_PASSWORD="your-password"
        export INFISICAL_ORGANIZATION_ID="your-organization-id"
        infisical login
        ```
      </Accordion>

      <Accordion title="Interactive CLI Login">
        ```bash  theme={"dark"}
        infisical login --interactive
        ```
      </Accordion>

      <Accordion title="Plain Token Output (Useful for scripting and CI/CD)">
        ```bash  theme={"dark"}
        export INFISICAL_TOKEN=$(infisical login --email=user@example.com --password=your-password --organization-id=your-organization-id --plain --silent)
        ```
      </Accordion>
    </AccordionGroup>
  </Accordion>
</AccordionGroup>

#### Machine Identity Authentication

Machine identity authentication methods are designed for automated systems, services, and CI/CD pipelines.

<AccordionGroup>
  <Accordion title="Universal Auth">
    The Universal Auth method is a simple and secure way to authenticate with Infisical. It requires a client ID and a client secret to authenticate with Infisical.

    <ParamField query="Flags">
      <Expandable title="properties">
        <ParamField query="client-id" type="string" required>
          Your machine identity client ID.
        </ParamField>

        <ParamField query="client-secret" type="string" required>
          Your machine identity client secret.
        </ParamField>
      </Expandable>
    </ParamField>

    <Steps>
      <Step title="Create a universal auth machine identity">
        To create a universal auth machine identity, follow the step by step guide outlined [here](/documentation/platform/identities/universal-auth).
      </Step>

      <Step title="Obtain an access token">
        Run the `login` command with the following flags to obtain an access token:

        ```bash  theme={"dark"}
          infisical login --method=universal-auth --client-id=<client-id> --client-secret=<client-secret>
        ```
      </Step>
    </Steps>
  </Accordion>

  <Accordion title="Native Kubernetes">
    The Native Kubernetes method is used to authenticate with Infisical when running in a Kubernetes environment. It requires a service account token to authenticate with Infisical.

    <ParamField query="Flags">
      <Expandable title="properties">
        <ParamField query="machine-identity-id" type="string" required>
          Your machine identity ID.
        </ParamField>

        <ParamField query="service-account-token-path" type="string" optional>
          Path to the Kubernetes service account token to use. Default: `/var/run/secrets/kubernetes.io/serviceaccount/token`.
        </ParamField>
      </Expandable>
    </ParamField>

    <Steps>
      <Step title="Create a Kubernetes machine identity">
        To create a Kubernetes machine identity, follow the step by step guide outlined [here](/documentation/platform/identities/kubernetes-auth).
      </Step>

      <Step title="Obtain access an token">
        Run the `login` command with the following flags to obtain an access token:

        ```bash  theme={"dark"}
          # --service-account-token-path is optional, and will default to '/var/run/secrets/kubernetes.io/serviceaccount/token' if not provided.
          infisical login --method=kubernetes --machine-identity-id=<machine-identity-id> --service-account-token-path=<service-account-token-path>
        ```
      </Step>
    </Steps>
  </Accordion>

  <Accordion title="Native Azure">
    The Native Azure method is used to authenticate with Infisical when running in an Azure environment.

    <ParamField query="Flags">
      <Expandable title="properties">
        <ParamField query="machine-identity-id" type="string" required>
          Your machine identity ID.
        </ParamField>
      </Expandable>
    </ParamField>

    <Steps>
      <Step title="Create an Azure machine identity">
        To create an Azure machine identity, follow the step by step guide outlined [here](/documentation/platform/identities/azure-auth).
      </Step>

      <Step title="Obtain an access token">
        Run the `login` command with the following flags to obtain an access token:

        ```bash  theme={"dark"}
          infisical login --method=azure --machine-identity-id=<machine-identity-id>
        ```
      </Step>
    </Steps>
  </Accordion>

  <Accordion title="Native GCP ID Token">
    The Native GCP ID Token method is used to authenticate with Infisical when running in a GCP environment.

    <ParamField query="Flags">
      <Expandable title="properties">
        <ParamField query="machine-identity-id" type="string" required>
          Your machine identity ID.
        </ParamField>
      </Expandable>
    </ParamField>

    <Steps>
      <Step title="Create a GCP machine identity">
        To create a GCP machine identity, follow the step by step guide outlined [here](/documentation/platform/identities/gcp-auth).
      </Step>

      <Step title="Obtain an access token">
        Run the `login` command with the following flags to obtain an access token:

        ```bash  theme={"dark"}
          infisical login --method=gcp-id-token --machine-identity-id=<machine-identity-id>
        ```
      </Step>
    </Steps>
  </Accordion>

  <Accordion title="GCP IAM">
    The GCP IAM method is used to authenticate with Infisical with a GCP service account key.

    <ParamField query="Flags">
      <Expandable title="properties">
        <ParamField query="machine-identity-id" type="string" required>
          Your machine identity ID.
        </ParamField>

        <ParamField query="service-account-key-file-path" type="string" required>
          Path to your GCP service account key file *(Must be in JSON format!)*
        </ParamField>
      </Expandable>
    </ParamField>

    <Steps>
      <Step title="Create a GCP machine identity">
        To create a GCP machine identity, follow the step by step guide outlined [here](/documentation/platform/identities/gcp-auth).
      </Step>

      <Step title="Obtain an access token">
        Run the `login` command with the following flags to obtain an access token:

        ```bash  theme={"dark"}
          infisical login --method=gcp-iam --machine-identity-id=<machine-identity-id> --service-account-key-file-path=<service-account-key-file-path>
        ```
      </Step>
    </Steps>
  </Accordion>

  <Accordion title="Native AWS IAM">
    The AWS IAM method is used to authenticate with Infisical with an AWS IAM role while running in an AWS environment like EC2, Lambda, etc.

    <ParamField query="Flags">
      <Expandable title="properties">
        <ParamField query="machine-identity-id" type="string" required>
          Your machine identity ID.
        </ParamField>
      </Expandable>
    </ParamField>

    <Steps>
      <Step title="Create an AWS machine identity">
        To create an AWS machine identity, follow the step by step guide outlined [here](/documentation/platform/identities/aws-auth).
      </Step>

      <Step title="Obtain an access token">
        Run the `login` command with the following flags to obtain an access token:

        ```bash  theme={"dark"}
          infisical login --method=aws-iam --machine-identity-id=<machine-identity-id>
        ```
      </Step>
    </Steps>
  </Accordion>

  <Accordion title="OIDC Auth">
    The OIDC Auth method is used to authenticate with Infisical via identity tokens with OIDC.

    <ParamField query="Flags">
      <Expandable title="properties">
        <ParamField query="machine-identity-id" type="string" required>
          Your machine identity ID.
        </ParamField>

        <ParamField query="jwt" type="string" required>
          The OIDC JWT from the identity provider.
        </ParamField>
      </Expandable>
    </ParamField>

    <Steps>
      <Step title="Create an OIDC machine identity">
        To create an OIDC machine identity, follow the step by step guide outlined [here](/documentation/platform/identities/oidc-auth/general).
      </Step>

      <Step title="Obtain an access token">
        Run the `login` command with the following flags to obtain an access token:

        ```bash  theme={"dark"}
          infisical login --method=oidc-auth --machine-identity-id=<machine-identity-id> --jwt=<oidc-jwt>
        ```
      </Step>
    </Steps>
  </Accordion>

  <Accordion title="JWT Auth">
    The JWT Auth method is used to authenticate with Infisical via a JWT token.

    <ParamField query="Flags">
      <Expandable title="properties">
        <ParamField query="jwt" type="string" required>
          The JWT token to use for authentication.
        </ParamField>

        <ParamField query="machine-identity-id" type="string" required>
          Your machine identity ID.
        </ParamField>
      </Expandable>
    </ParamField>

    <Steps>
      <Step title="Obtain an access token">
        Run the `login` command with the following flags to obtain an access token:

        ```bash  theme={"dark"}
          infisical login --method=jwt-auth --jwt=<jwt-token> --machine-identity-id=<machine-identity-id>
        ```
      </Step>
    </Steps>
  </Accordion>
</AccordionGroup>

### Flags

The login command supports a number of flags that you can use for different authentication methods. Below is a list of all the flags that can be used with the login command.

<AccordionGroup>
  <Accordion title="--method">
    ```bash  theme={"dark"}
    infisical login --method=<auth-method> # Optional, will default to 'user'.
    ```

    #### Valid values for the `method` flag are:

    * `user`: Login using email and password. (default)
    * `universal-auth`: Login using a universal auth client ID and client secret.
    * `kubernetes`: Login using a Kubernetes native auth.
    * `azure`: Login using an Azure native auth.
    * `gcp-id-token`: Login using a GCP ID token native auth.
    * `gcp-iam`: Login using a GCP IAM.
    * `aws-iam`: Login using an AWS IAM native auth.
    * `oidc-auth`: Login using OIDC auth.
    * `jwt-auth`: Login using a plain JWT token.
  </Accordion>

  <Accordion title="--client-id">
    ```bash  theme={"dark"}
    infisical login --client-id=<client-id> # Optional, required if --method=universal-auth.
    ```

    #### Description

    The client ID of the universal auth machine identity. This is required if the `--method` flag is set to `universal-auth`.

    <Tip>
      The `client-id` flag can be substituted with the `INFISICAL_UNIVERSAL_AUTH_CLIENT_ID` environment variable.
    </Tip>
  </Accordion>

  <Accordion title="--client-secret">
    ```bash  theme={"dark"}
    infisical login --client-secret=<client-secret> # Optional, required if --method=universal-auth.
    ```

    #### Description

    The client secret of the universal auth machine identity. This is required if the `--method` flag is set to `universal-auth`.

    <Tip>
      The `client-secret` flag can be substituted with the `INFISICAL_UNIVERSAL_AUTH_CLIENT_SECRET` environment variable.
    </Tip>
  </Accordion>

  <Accordion title="--machine-identity-id">
    ```bash  theme={"dark"}
    infisical login --machine-identity-id=<your-machine-identity-id> # Optional, required if --method=kubernetes, azure, gcp-id-token, gcp-iam, or aws-iam.
    ```

    #### Description

    The ID of the machine identity. This is required if the `--method` flag is set to `kubernetes`, `azure`, `gcp-id-token`, `gcp-iam`, or `aws-iam`.

    <Tip>
      The `machine-identity-id` flag can be substituted with the `INFISICAL_MACHINE_IDENTITY_ID` environment variable.
    </Tip>
  </Accordion>

  <Accordion title="--service-account-token-path">
    ```bash  theme={"dark"}
    infisical login --service-account-token-path=<service-account-token-path> # Optional Will default to '/var/run/secrets/kubernetes.io/serviceaccount/token'.
    ```

    #### Description

    The path to the Kubernetes service account token to use for authentication.
    This is optional and will default to `/var/run/secrets/kubernetes.io/serviceaccount/token`.

    <Tip>
      The `service-account-token-path` flag can be substituted with the `INFISICAL_KUBERNETES_SERVICE_ACCOUNT_TOKEN_PATH` environment variable.
    </Tip>
  </Accordion>

  <Accordion title="--service-account-key-file-path">
    ```bash  theme={"dark"}
    infisical login --service-account-key-file-path=<gcp-service-account-key-file-path> # Optional, but required if --method=gcp-iam.
    ```

    #### Description

    The path to your GCP service account key file. This is required if the `--method` flag is set to `gcp-iam`.

    <Tip>
      The `service-account-key-path` flag can be substituted with the `INFISICAL_GCP_IAM_SERVICE_ACCOUNT_KEY_FILE_PATH` environment variable.
    </Tip>
  </Accordion>

  <Accordion title="--email">
    ```bash  theme={"dark"}
    infisical login --email=<email> --password=<password> --organization-id=<organization-id>
    ```

    #### Description

    User email address. Required if you want to do a non-interactive login when the **--method** flag is set to **user**. Must be used together with the `--password` and `--organization-id` flag.

    <Tip>
      You can omit the **--method=user** if you want as it's the default method.
    </Tip>

    <Tip>
      The `email` flag can be substituted with the `INFISICAL_EMAIL` environment variable.
    </Tip>
  </Accordion>

  <Accordion title="--password">
    ```bash  theme={"dark"}
    infisical login --email=<email> --password=<password> --organization-id=<organization-id>
    ```

    #### Description

    User password. Required if you want to do a non-interactive login when the **--method** flag is set to **user**. Must be used together with the `--email` and `--organization-id` flag.

    <Warning>
      For security in CI/CD environments, prefer using the `INFISICAL_PASSWORD` environment variable instead of passing the password as a command-line flag.
    </Warning>

    <Tip>
      You can omit the **--method=user** if you want as it's the default method.
    </Tip>

    <Tip>
      The `password` flag can be substituted with the `INFISICAL_PASSWORD` environment variable.
    </Tip>
  </Accordion>

  <Accordion title="--organization-id">
    ```bash  theme={"dark"}
    infisical login --email=<email> --password=<password> --organization-id=<organization-id>
    ```

    #### Description

    User organization id. Required if you want to do a non-interactive login when the **--method** flag is set to **user**. Must be used together with the `--email` and `--password` flag.

    <Tip>
      You can omit the **--method=user** if you want as it's the default method.
    </Tip>

    <Tip>
      The `organization-id` flag can be substituted with the `INFISICAL_ORGANIZATION_ID` environment variable.
    </Tip>
  </Accordion>

  <Accordion title="--interactive">
    ```bash  theme={"dark"}
    infisical login --interactive
    ```

    #### Description

    Forces interactive CLI login where you'll be prompted to enter your email, password, and select your organization in the terminal, instead of opening a browser.
  </Accordion>

  <Accordion title="--plain">
    ```bash  theme={"dark"}
    infisical login --email=<email> --password=<password> --organization-id=<organization-id> --plain
    ```

    #### Description

    When used with direct user login or machine identity authentication, outputs only the JWT access token without any additional formatting. This is useful for scripting and CI/CD pipelines where you need to capture the token.

    ```bash  theme={"dark"}
    # Example: Capture token in a variable
    export INFISICAL_TOKEN=$(infisical login --email=<email> --password=<password> --organization-id=<organization-id> --plain --silent)
    ```

    <Tip>
      Use it alongside the `silent` flag to disable all messages in the console except from the access token.
    </Tip>
  </Accordion>

  <Accordion title="--jwt">
    ```bash  theme={"dark"}
    infisical login --jwt=<jwt-token> --machine-identity-id=<machine-identity-id>
    ```

    #### Description

    The JWT provided by an identity provider for OIDC or plain JWT authentication. This is required if the `--method` flag is set to `oidc-auth` or `jwt-auth`.

    <Tip>
      The `jwt` flag can be substituted with the `INFISICAL_JWT` environment variable.
    </Tip>
  </Accordion>
</AccordionGroup>

### User Authentication Examples

The following examples demonstrate different ways to authenticate as a user with the Infisical CLI.

<AccordionGroup>
  <Accordion title="Browser Login (Default)">
    By default, running `infisical login` without any flags opens your browser for authentication.

    ```bash  theme={"dark"}
    # Opens browser for authentication
    infisical login
    ```

    The browser will open to the Infisical login page, and upon successful authentication, the CLI will be automatically authenticated.
  </Accordion>

  <Accordion title="Direct Login (Non-Interactive)">
    Direct login is ideal for CI/CD pipelines and automation scripts where browser-based authentication is not possible.

    #### Using Command-Line Flags

    ```bash  theme={"dark"}
    # Basic direct login (defaults to US Cloud)
    infisical login --email user@example.com --password "your-password" --organization-id "your-organization-id"

    # EU Cloud (Custom domain)
    infisical login --email user@example.com --password "your-password" --organization-id "your-organization-id" --domain https://eu.infisical.com

    # Output only JWT token for scripting
    export INFISICAL_TOKEN=$(infisical login --email user@example.com --password "your-password" --organization-id "your-organization-id" --plain --silent)
    ```

    #### Using Environment Variables (Recommended for CI/CD)

    ```bash  theme={"dark"}
    # Set credentials as environment variables
    export INFISICAL_EMAIL="user@example.com"
    export INFISICAL_PASSWORD="your-password"
    export INFISICAL_ORGANIZATION_ID="your-organization-id"

    # Login without additional flags
    infisical login

    # Or with plain output for token capture
    export INFISICAL_TOKEN=$(infisical login --plain --silent)
    ```
  </Accordion>

  <Accordion title="Interactive CLI Login">
    Interactive login prompts you to enter credentials in the terminal instead of opening a browser.

    ```bash  theme={"dark"}
    # Force interactive CLI login
    infisical login --interactive
    ```

    You'll be prompted to enter:

    * Email address
    * Password

    After the prompt, you will be shown a list of organizations to choose from.
  </Accordion>
</AccordionGroup>

<Tip>
  If you have SSO enabled, we recommend using the default browser login.
</Tip>

### Machine Identity Authentication Quick Start

In this example we'll be using the `universal-auth` method to login to obtain an Infisical access token, which we will then use to fetch secrets with.

<Steps>
  <Step title="Obtain an access token">
    ```bash  theme={"dark"}
      export INFISICAL_TOKEN=$(infisical login --method=universal-auth --client-id=<client-id> --client-secret=<client-secret> --silent --plain) # silent and plain is important to ensure only the token itself is printed, so we can easily set it as an environment variable.
    ```

    Now that we've set the `INFISICAL_TOKEN` environment variable, we can use the CLI to interact with Infisical. The CLI will automatically check for the presence of the `INFISICAL_TOKEN` environment variable and use it for authentication.

    Alternatively, if you would rather use the `--token` flag to pass the token directly, you can do so by running the following command:

    ```bash  theme={"dark"}
      infisical [command] --token=<your-access-token> # The token output from the login command.
    ```
  </Step>

  <Step title="Fetch all secrets from an environment">
    ```bash  theme={"dark"}
      infisical secrets --projectId=<your-project-id> --env=dev --recursive
    ```

    This command will fetch all secrets from the `dev` environment in your project, including all secrets in subfolders.

    <Info>
      The `--recursive`, and `--env` flag is optional and will fetch all secrets in subfolders. The default environment is `dev` if no `--env` flag is provided.
    </Info>
  </Step>
</Steps>


# infisical relay
Source: https://infisical.com/docs/cli/commands/relay

Relay-related commands for Infisical

<Tabs>
  <Tab title="Start relay">
    ```bash  theme={"dark"}
    infisical relay start --host=<host> --name=<name> --auth-method=<auth-method>
    ```
  </Tab>

  <Tab title="Start relay as background daemon (Linux only)">
    ```bash  theme={"dark"}
    # Install systemd service
    sudo infisical relay systemd install --host=<host> --name=<name> --token=<token>

    # Uninstall systemd service
    sudo infisical relay systemd uninstall
    ```
  </Tab>
</Tabs>

## Description

Relay-related commands for Infisical that provide identity-aware relay infrastructure for routing encrypted traffic. Relays are organization-deployed servers that route encrypted traffic between Infisical and your gateways.

## Subcommands & flags

<AccordionGroup>
  <Accordion title="infisical relay start" defaultOpen="true">
    Run the Infisical relay component. The relay handles network traffic routing between Infisical and your gateways.

    ```bash  theme={"dark"}
    infisical relay start --host=<host> --name=<name> --auth-method=<auth-method>
    ```

    ### Flags

    <AccordionGroup>
      <Accordion title="--host">
        The host (IP address or hostname) of the instance where the relay is deployed. This must be a static public IP or resolvable hostname that gateways can reach.

        ```bash  theme={"dark"}
        # Example with IP address
        infisical relay start --host=203.0.113.100 --name=my-relay

        # Example with hostname
        infisical relay start --host=relay.example.com --name=my-relay
        ```
      </Accordion>

      <Accordion title="--name">
        The name of the relay. This is an arbitrary identifier for your relay instance.

        ```bash  theme={"dark"}
        # Example
        infisical relay start --name=my-relay --host=192.168.1.100
        ```
      </Accordion>
    </AccordionGroup>

    ### Authentication

    Relays support all standard Infisical authentication methods. Choose the authentication method that best fits your environment and set the corresponding flags when starting the relay.

    ```bash  theme={"dark"}
    # Example with Universal Auth
    infisical relay start --host=192.168.1.100 --name=my-relay --auth-method=universal-auth --client-id=<client-id> --client-secret=<client-secret>
    ```

    ### Available Authentication Methods

    The Infisical CLI supports multiple authentication methods for relays. Below are the available authentication methods, with their respective flags.

    <AccordionGroup>
      <Accordion title="Universal Auth">
        The Universal Auth method is a simple and secure way to authenticate with Infisical. It requires a client ID and a client secret to authenticate with Infisical.

        <ParamField query="Flags">
          <Expandable title="properties">
            <ParamField query="client-id" type="string" required>
              Your machine identity client ID.
            </ParamField>

            <ParamField query="client-secret" type="string" required>
              Your machine identity client secret.
            </ParamField>

            <ParamField query="auth-method" type="string" required>
              The authentication method to use. Must be `universal-auth` when using Universal Auth.
            </ParamField>
          </Expandable>
        </ParamField>

        ```bash  theme={"dark"}
          infisical relay start --auth-method=universal-auth --client-id=<client-id> --client-secret=<client-secret> --host=<host> --name=<name>
        ```
      </Accordion>

      <Accordion title="Native Kubernetes">
        The Native Kubernetes method is used to authenticate with Infisical when running in a Kubernetes environment. It requires a service account token to authenticate with Infisical.

        <ParamField query="Flags">
          <Expandable title="properties">
            <ParamField query="machine-identity-id" type="string" required>
              Your machine identity ID.
            </ParamField>

            <ParamField query="service-account-token-path" type="string" optional>
              Path to the Kubernetes service account token to use. Default: `/var/run/secrets/kubernetes.io/serviceaccount/token`.
            </ParamField>

            <ParamField query="auth-method" type="string" required>
              The authentication method to use. Must be `kubernetes` when using Native Kubernetes.
            </ParamField>
          </Expandable>
        </ParamField>

        ```bash  theme={"dark"}
          infisical relay start --auth-method=kubernetes --machine-identity-id=<machine-identity-id> --host=<host> --name=<name>
        ```
      </Accordion>

      <Accordion title="Native Azure">
        The Native Azure method is used to authenticate with Infisical when running in an Azure environment.

        <ParamField query="Flags">
          <Expandable title="properties">
            <ParamField query="machine-identity-id" type="string" required>
              Your machine identity ID.
            </ParamField>

            <ParamField query="auth-method" type="string" required>
              The authentication method to use. Must be `azure` when using Native Azure.
            </ParamField>
          </Expandable>
        </ParamField>

        ```bash  theme={"dark"}
          infisical relay start --auth-method=azure --machine-identity-id=<machine-identity-id> --host=<host> --name=<name>
        ```
      </Accordion>

      <Accordion title="Native GCP ID Token">
        The Native GCP ID Token method is used to authenticate with Infisical when running in a GCP environment.

        <ParamField query="Flags">
          <Expandable title="properties">
            <ParamField query="machine-identity-id" type="string" required>
              Your machine identity ID.
            </ParamField>

            <ParamField query="auth-method" type="string" required>
              The authentication method to use. Must be `gcp-id-token` when using Native GCP ID Token.
            </ParamField>
          </Expandable>
        </ParamField>

        ```bash  theme={"dark"}
          infisical relay start --auth-method=gcp-id-token --machine-identity-id=<machine-identity-id> --host=<host> --name=<name>
        ```
      </Accordion>

      <Accordion title="GCP IAM">
        The GCP IAM method is used to authenticate with Infisical with a GCP service account key.

        <ParamField query="Flags">
          <Expandable title="properties">
            <ParamField query="machine-identity-id" type="string" required>
              Your machine identity ID.
            </ParamField>

            <ParamField query="service-account-key-file-path" type="string" required>
              Path to your GCP service account key file *(Must be in JSON format!)*
            </ParamField>

            <ParamField query="auth-method" type="string" required>
              The authentication method to use. Must be `gcp-iam` when using GCP IAM.
            </ParamField>
          </Expandable>
        </ParamField>

        ```bash  theme={"dark"}
          infisical relay start --auth-method=gcp-iam --machine-identity-id=<machine-identity-id> --service-account-key-file-path=<service-account-key-file-path> --host=<host> --name=<name>
        ```
      </Accordion>

      <Accordion title="Native AWS IAM">
        The AWS IAM method is used to authenticate with Infisical with an AWS IAM role while running in an AWS environment like EC2, Lambda, etc.

        <ParamField query="Flags">
          <Expandable title="properties">
            <ParamField query="machine-identity-id" type="string" required>
              Your machine identity ID.
            </ParamField>

            <ParamField query="auth-method" type="string" required>
              The authentication method to use. Must be `aws-iam` when using Native AWS IAM.
            </ParamField>
          </Expandable>
        </ParamField>

        ```bash  theme={"dark"}
          infisical relay start --auth-method=aws-iam --machine-identity-id=<machine-identity-id> --host=<host> --name=<name>
        ```
      </Accordion>

      <Accordion title="OIDC Auth">
        The OIDC Auth method is used to authenticate with Infisical via identity tokens with OIDC.

        <ParamField query="Flags">
          <Expandable title="properties">
            <ParamField query="machine-identity-id" type="string" required>
              Your machine identity ID.
            </ParamField>

            <ParamField query="jwt" type="string" required>
              The OIDC JWT from the identity provider.
            </ParamField>

            <ParamField query="auth-method" type="string" required>
              The authentication method to use. Must be `oidc-auth` when using OIDC Auth.
            </ParamField>
          </Expandable>
        </ParamField>

        ```bash  theme={"dark"}
          infisical relay start --auth-method=oidc-auth --machine-identity-id=<machine-identity-id> --jwt=<oidc-jwt> --host=<host> --name=<name>
        ```
      </Accordion>

      <Accordion title="JWT Auth">
        The JWT Auth method is used to authenticate with Infisical via a JWT token.

        <ParamField query="Flags">
          <Expandable title="properties">
            <ParamField query="jwt" type="string" required>
              The JWT token to use for authentication.
            </ParamField>

            <ParamField query="machine-identity-id" type="string" required>
              Your machine identity ID.
            </ParamField>

            <ParamField query="auth-method" type="string" required>
              The authentication method to use. Must be `jwt-auth` when using JWT Auth.
            </ParamField>
          </Expandable>
        </ParamField>

        ```bash  theme={"dark"}
          infisical relay start --auth-method=jwt-auth --jwt=<jwt> --machine-identity-id=<machine-identity-id> --host=<host> --name=<name>
        ```
      </Accordion>

      <Accordion title="Token Auth">
        You can use the `INFISICAL_TOKEN` environment variable to authenticate with Infisical with a raw machine identity access token.

        <ParamField query="Flags">
          <Expandable title="properties">
            <ParamField query="token" type="string" required>
              The machine identity access token to use for authentication.
            </ParamField>
          </Expandable>
        </ParamField>

        ```bash  theme={"dark"}
          infisical relay start --token=<token> --host=<host> --name=<name>
        ```
      </Accordion>
    </AccordionGroup>
  </Accordion>

  <Accordion title="infisical relay systemd" defaultOpen="false">
    Manage systemd service for Infisical relay. This allows you to install and run the relay as a systemd service on Linux systems.

    ### Requirements

    * **Operating System**: Linux only (systemd is not supported on other operating systems)
    * **Privileges**: Root/sudo privileges required for both install and uninstall operations
    * **Systemd**: The system must be running systemd as the init system

    ```bash  theme={"dark"}
    infisical relay systemd <subcommand>
    ```

    ### Subcommands

    <AccordionGroup>
      <Accordion title="install">
        Install and enable systemd service for the relay. Must be run with sudo on Linux systems.

        ```bash  theme={"dark"}
        sudo infisical relay systemd install --host=<host> --name=<name> --token=<token> [flags]
        ```

        #### Flags

        <AccordionGroup>
          <Accordion title="--host">
            The host (IP address or hostname) of the instance where the relay is deployed. This must be a static public IP or resolvable hostname that gateways can reach.

            ```bash  theme={"dark"}
            # Example with IP address
            sudo infisical relay systemd install --host=203.0.113.100 --name=my-relay --token=<token>

            # Example with hostname
            sudo infisical relay systemd install --host=relay.example.com --name=my-relay --token=<token>
            ```
          </Accordion>

          <Accordion title="--name">
            The name of the relay.

            ```bash  theme={"dark"}
            # Example
            sudo infisical relay systemd install --name=my-relay --host=192.168.1.100 --token=<token>
            ```
          </Accordion>

          <Accordion title="--token">
            Connect with Infisical using machine identity access token.

            ```bash  theme={"dark"}
            # Example
            sudo infisical relay systemd install --token=<machine-identity-token> --host=<host> --name=<name>
            ```
          </Accordion>

          <Accordion title="--domain">
            Domain of your self-hosted Infisical instance. Optional flag for specifying a custom domain.

            ```bash  theme={"dark"}
            # Example
            sudo infisical relay systemd install --domain=http://localhost:8080 --token=<token> --host=<host> --name=<name>
            ```
          </Accordion>
        </AccordionGroup>

        #### Examples

        ```bash  theme={"dark"}
        # Install relay with token authentication
        sudo infisical relay systemd install --host=192.168.1.100 --name=my-relay --token=<machine-identity-token>

        # Install with custom domain
        sudo infisical relay systemd install --domain=http://localhost:8080 --token=<token> --host=<host> --name=<name>
        ```

        #### Post-installation

        After successful installation, the service will be enabled but not started. To start the service:

        ```bash  theme={"dark"}
        sudo systemctl start infisical-relay
        ```

        To check the service status:

        ```bash  theme={"dark"}
        sudo systemctl status infisical-relay
        ```

        To view service logs:

        ```bash  theme={"dark"}
        sudo journalctl -u infisical-relay -f
        ```
      </Accordion>

      <Accordion title="uninstall">
        Uninstall and remove systemd service for the relay. Must be run with sudo on Linux systems.

        ```bash  theme={"dark"}
        sudo infisical relay systemd uninstall
        ```

        #### Examples

        ```bash  theme={"dark"}
        # Uninstall the relay systemd service
        sudo infisical relay systemd uninstall
        ```

        #### What it does

        * Stops the `infisical-relay` systemd service if it's running
        * Disables the service from starting on boot
        * Removes the systemd service file
        * Cleans up the service configuration
      </Accordion>
    </AccordionGroup>
  </Accordion>
</AccordionGroup>


# infisical reset
Source: https://infisical.com/docs/cli/commands/reset

Reset Infisical

```bash  theme={"dark"}
infisical reset
```

## Description

This command provides a way to clear all Infisical-generated configuration data, effectively resetting the software to its default settings. This can be an effective way to address any persistent issues that arise while using the CLI.


# infisical run
Source: https://infisical.com/docs/cli/commands/run

The command that injects your secrets into local environment

<Tabs>
  <Tab title="Single command">
    ```bash  theme={"dark"}
    infisical run [options] -- [your application start command]

    # Example
    infisical run [options] -- npm run dev
    ```
  </Tab>

  <Tab title="Chained commands">
    ```bash  theme={"dark"}
    infisical run [options] --command [string command]

    # Example
    infisical run [options] --command "npm run bootstrap && npm run dev start; other-bash-command"
    ```
  </Tab>
</Tabs>

## Description

Inject secrets from Infisical into your application process.

## Subcommands & flags

<Accordion title="infisical run" defaultOpen="true">
  Use this command to inject secrets into your applications process

  ```bash  theme={"dark"}
  $ infisical run -- <your application command>

  # Example
  $ infisical run -- npm run dev
  ```

  ### Environment variables

  <Accordion title="INFISICAL_TOKEN">
    Used to fetch secrets via a [machine identity](/documentation/platform/identities/machine-identities) apposed to logged in credentials. Simply, export this variable in the terminal before running this command.

    ```bash  theme={"dark"}
      # Example
      export INFISICAL_TOKEN=$(infisical login --method=universal-auth --client-id=<identity-client-id> --client-secret=<identity-client-secret> --silent --plain) # --plain flag will output only the token, so it can be fed to an environment variable. --silent will disable any update messages.
    ```

    <Info>
      Alternatively, you may use service tokens.

      ```bash  theme={"dark"}
        # Example
        export INFISICAL_TOKEN=<service-token>
      ```
    </Info>
  </Accordion>

  <Accordion title="INFISICAL_DISABLE_UPDATE_CHECK">
    Used to disable the check for new CLI versions. This can improve the time it takes to run this command. Recommended for production environments.

    To use, simply export this variable in the terminal before running this command.

    ```bash  theme={"dark"}
      # Example
      export INFISICAL_DISABLE_UPDATE_CHECK=true
    ```
  </Accordion>

  ### Flags

  <Accordion title="--watch">
    By passing the `watch` flag, you are telling the CLI to watch for changes that happen in your Infisical project.
    If secret changes happen, the command you provided will automatically be restarted with the new environment variables attached.

    ```bash  theme={"dark"}
      # Example
      infisical run --watch -- printenv
    ```
  </Accordion>

  <Accordion title="--project-config-dir">
    Explicitly set the directory where the .infisical.json resides. This is useful for some monorepo setups.

    ```bash  theme={"dark"}
      # Example
      infisical run --project-config-dir=/some-dir -- printenv
    ```
  </Accordion>

  <Accordion title="--command">
    Pass secrets into multiple commands at once

    ```bash  theme={"dark"}
    # Example
    infisical run --command="npm run build && npm run dev; more-commands..."
    ```
  </Accordion>

  <Accordion title="--projectId">
    The project ID to fetch secrets from. This is required when using a machine identity to authenticate.

    ```bash  theme={"dark"}
    # Example
    infisical run --projectId=<project-id> -- npm run dev
    ```
  </Accordion>

  <Accordion title="--token">
    If you are using a [machine identity](/documentation/platform/identities/machine-identities) to authenticate, you can pass the token as a flag

    ```bash  theme={"dark"}
    # Example
    infisical run --token="<universal-auth-access-token>" --projectId=<project-id> -- npm run start
    ```

    You may also expose the token to the CLI by setting the environment variable `INFISICAL_TOKEN` before executing the run command. This will have the same effect as setting the token with `--token` flag
  </Accordion>

  <Accordion title="--expand">
    Turn on or off the shell parameter expansion in your secrets. If you have used shell parameters in your secret(s), activating this feature will populate them before injecting them into your application process.

    Default value: `true`
  </Accordion>

  <Accordion title="--include-imports">
    By default imported secrets are available, you can disable it by setting this option to false.

    Default value: `true`
  </Accordion>

  {" "}

  <Accordion title="--env">
    This is used to specify the environment from which secrets should be
    retrieved. The accepted values are the environment slugs defined for your
    project, such as `dev`, `staging`, `test`, and `prod`. Default value: `dev`
  </Accordion>

  <Accordion title="--secret-overriding">
    Prioritizes personal secrets with the same name over shared secrets

    Default value: `true`
  </Accordion>

  <Accordion title="--tags">
    When working with tags, you can use this flag to filter and retrieve only secrets that are associated with a specific tag(s).

    ```bash  theme={"dark"}
    # Example
    infisical run --tags=tag1,tag2,tag3 -- npm run dev
    ```

    Note: you must reference the tag by its slug name not its fully qualified name. Go to project settings to view all tag slugs.

    By default, all secrets are fetched
  </Accordion>

  <Accordion title="--path">
    The `--path` flag indicates which project folder secrets will be injected from.

    ```bash  theme={"dark"}
    # Example
    infisical run --path="/nextjs" -- npm run dev
    ```
  </Accordion>
</Accordion>

## Automatically reload command when secrets change

To automatically reload your command when secrets change, use the `--watch` flag.

```bash  theme={"dark"}
infisical run --watch -- npm run dev
```

This will watch for changes in your secrets and automatically restart your command with the new secrets.
When your command restarts, it will have the new environment variables injeceted into it.

<Note>
  Please note that this feature is intended for development purposes. It is not recommended to use this in production environments. Generally it's not recommended to automatically reload your application in production when remote changes are made.
</Note>


# scan
Source: https://infisical.com/docs/cli/commands/scan

Scan git history, directories, and files for secrets

```bash  theme={"dark"}
infisical scan

# Display the full secret findings
infisical scan --verbose
```

## Description

The `infisical scan` command serves to scan repositories, directories, and files. It's compatible with both individual developer machines and Continuous Integration (CI) environments.

When you run `infisical scan` on a Git repository, Infisical will parses the output of a `git log -p` command. This command generates [patches](https://stackoverflow.com/questions/8279602/what-is-a-patch-in-git-version-control) that Infisical uses to identify secrets in your code.
You can configure the range of commits that `git log` will cover using the `--log-opts` flag.
Any options you can use with `git log -p` are valid for `--log-opts`.

For instance, to instruct Infisical to scan a specific range of commits, use the following command: `infisical scan --log-opts="--all commitA..commitB"`. For more details, refer to the [Git log documentation](https://git-scm.com/docs/git-log).

To scan individual files and directories, use the `--no-git` flag.

### Flags

<Accordion title="--log-opts">
  **Description**

  git log options
</Accordion>

<Accordion title="--no-git">
  **Description**

  treat git repo as a regular directory and scan those files, --log-opts has no effect on the scan when --no-git is set

  Default value: `false`
</Accordion>

<Accordion title="--pipe">
  Short hand: `-b`

  **Description**

  scan input from stdin, ex: `cat some_file | infisical scan --pipe`

  Default value: `false`
</Accordion>

<Accordion title="--follow-symlinks">
  Short hand: `-b`

  **Description**
  scan files that are symlinks to other files

  Default value: `false`
</Accordion>

<Accordion title="--baseline-path">
  Short hand: `-b`

  **Description**

  path to baseline with issues that can be ignored
</Accordion>

<Accordion title="--config">
  Short hand: `-c`

  **Description**

  config file path

  order of precedence:

  1. \--config flag
  2. env var INFISICAL\_SCAN\_CONFIG
  3. (--source/-s)/.infisical-scan.toml
     If none of the three options are used, then Infisical will use the default config
</Accordion>

<Accordion title="--exit-code">
  **Description**

  exit code when leaks have been encountered (default 1)
</Accordion>

<Accordion title="--max-target-megabytes">
  **Description**

  files larger than this will be skipped
</Accordion>

<Accordion title="--no-color">
  **Description**

  turn off color for verbose output
</Accordion>

<Accordion title="--redact">
  **Description**

  redact secrets from logs and stdout
</Accordion>

<Accordion title="--report-format">
  **Description**

  output format (json, csv, sarif) (default "json")
</Accordion>

<Accordion title="--report-path">
  **Description**

  report file
</Accordion>

<Accordion title="--source">
  **Description**

  path to source (default ".")
</Accordion>

<Accordion title="--verbose">
  **Description**

  show verbose output from scan
</Accordion>


# scan git-changes
Source: https://infisical.com/docs/cli/commands/scan-git-changes

Scan for secrets in your uncommitted code

```bash  theme={"dark"}
infisical scan git-changes

# Display the full secret findings
infisical scan git-changes --verbose
```

## Description

Scanning for secrets before you commit your changes is great way to prevent leaks. Infisical makes this easy with the sub command `git-changes`.

The `git-changes` scans for uncommitted changes in a Git repository, and is especially designed for use on developer machines, aligning with the ['shift left'](https://cloud.google.com/architecture/devops/devops-tech-shifting-left-on-security) security approach.
When `git-changes` is run on a Git repository, Infisical parses the output from a `git diff` command.

To scan changes in commits that have been staged via `git add`, you can add the `--staged` flag to the sub command. This flag is particularly useful when using Infisical CLI as a pre-commit tool.

### Flags

<Accordion title="--staged">
  **Description**

  detect secrets in a --staged state

  Default value: `false`
</Accordion>

<Accordion title="--log-opts">
  **Description**

  git log options
</Accordion>

<Accordion title="--baseline-path">
  Short hand: `-b`

  **Description**

  path to baseline with issues that can be ignored
</Accordion>

<Accordion title="--config">
  Short hand: `-c`

  **Description**

  config file path

  order of precedence:

  1. \--config flag
  2. env var INFISICAL\_SCAN\_CONFIG
  3. (--source/-s)/.infisical-scan.toml
     If none of the three options are used, then Infisical will use the default config
</Accordion>

<Accordion title="--exit-code">
  **Description**

  exit code when leaks have been encountered (default 1)
</Accordion>

<Accordion title="--max-target-megabytes">
  **Description**

  files larger than this will be skipped
</Accordion>

<Accordion title="--no-color">
  **Description**

  turn off color for verbose output
</Accordion>

<Accordion title="--redact">
  **Description**

  redact secrets from logs and stdout
</Accordion>

<Accordion title="--report-format">
  **Description**

  output format (json, csv, sarif) (default "json")
</Accordion>

<Accordion title="--report-path">
  **Description**

  report file
</Accordion>

<Accordion title="--source">
  **Description**

  path to source (default ".")
</Accordion>

<Accordion title="--verbose">
  **Description**

  show verbose output from scan
</Accordion>


# scan install
Source: https://infisical.com/docs/cli/commands/scan-install

Add various scanning tools seamlessly into your development lifecycle

```bash  theme={"dark"}
infisical scan install --pre-commit-hook
```

## Description

The command `infisical scan install` is designed to incorporate various scanning tools seamlessly into your development lifecycle.
Initially, we are offering users the ability to install a pre-commit hook. This hook conducts an automatic scan for any exposed secrets in your commits before they are pushed.

### Flags

<Accordion title="--pre-commit-hook">
  ```bash  theme={"dark"}
  infisical scan install --pre-commit-hook
  ```

  **Description**
  Installs a git pre-commit hook that triggers Infisical to scan your staged changes for any exposed secrets prior to pushing.
</Accordion>


# infisical secrets
Source: https://infisical.com/docs/cli/commands/secrets

Perform CRUD operations with Infisical secrets

```
infisical secrets
```

## Description

This command enables you to perform CRUD (create, read, update, delete) operations on secrets within your Infisical project. With it, you can view, create, update, and delete secrets in your environment.

### Sub-commands

<Accordion title="infisical secrets" defaultOpen="true">
  Use this command to print out all of the secrets in your project

  ```bash  theme={"dark"}
  $ infisical secrets
  ```

  ### Environment variables

  <Accordion title="INFISICAL_TOKEN">
    Used to fetch secrets via a [machine identity](/documentation/platform/identities/machine-identities) apposed to logged in credentials. Simply, export this variable in the terminal before running this command.

    ```bash  theme={"dark"}
    # Example
    export INFISICAL_TOKEN=$(infisical login --method=universal-auth --client-id=<identity-client-id> --client-secret=<identity-client-secret> --silent --plain) # --plain flag will output only the token, so it can be fed to an environment variable. --silent will disable any update messages.
    ```

    <Info>
      Alternatively, you may use service tokens.

      ```bash  theme={"dark"}
      # Example
      export INFISICAL_TOKEN=<service-token>
      ```
    </Info>
  </Accordion>

  <Accordion title="INFISICAL_DISABLE_UPDATE_CHECK">
    Used to disable the check for new CLI versions. This can improve the time it takes to run this command. Recommended for production environments.

    To use, simply export this variable in the terminal before running this command.

    ```bash  theme={"dark"}
    # Example
    export INFISICAL_DISABLE_UPDATE_CHECK=true
    ```
  </Accordion>

  ### Flags

  <Accordion title="--expand">
    Parse shell parameter expansions in your secrets

    Default value: `true`
  </Accordion>

  <Accordion title="--projectId">
    The project ID to fetch secrets from. This is required when using a machine identity to authenticate.

    ```bash  theme={"dark"}
    # Example
    infisical secrets --projectId=<project-id>
    ```
  </Accordion>

  <Accordion title="--env">
    Used to select the environment name on which actions should be taken on

    Default value: `dev`
  </Accordion>

  <Accordion title="--path">
    The `--path` flag indicates which project folder secrets will be injected from.

    ```bash  theme={"dark"}
    # Example
    infisical secrets --path="/" --env=dev
    ```
  </Accordion>

  <Accordion title="--plain">
    The `--plain` flag will output all your secret values without formatting, one per line.

    ```bash  theme={"dark"}
    # Example
    infisical secrets --plain --silent
    ```
  </Accordion>

  <Accordion title="--silent">
    The `--silent` flag disables output of tip/info messages. Useful when running in scripts or CI/CD pipelines.

    ```bash  theme={"dark"}
    # Example
    infisical secrets --silent
    ```

    Can be used inline to replace `INFISICAL_DISABLE_UPDATE_CHECK`
  </Accordion>
</Accordion>

<Accordion title="infisical secrets get">
  This command allows you selectively print the requested secrets by name

  ```bash  theme={"dark"}
  $ infisical secrets get <secret-name-a> <secret-name-b> ...

  # Example
  $ infisical secrets get DOMAIN
  $ infisical secrets get DOMAIN PORT

  ```

  ### Flags

  <Accordion title="--env">
    Used to select the environment name on which actions should be taken on

    Default value: `dev`
  </Accordion>

  <Accordion title="--plain">
    The `--plain` flag will output all your requested secret values without formatting, one per line.

    Default value: `false`

    ```bash  theme={"dark"}
    # Example
    infisical secrets get FOO --plain
    infisical secrets get FOO BAR --plain

    # Fetch a single value and assign it to a variable
    API_KEY=$(infisical secrets get FOO --plain --silent)
    ```

    <Tip>
      When running in CI/CD environments or in a script, set `INFISICAL_DISABLE_UPDATE_CHECK=true` or add the `--silent` flag. This will help hide any CLI info/debug output and only show the secret value.
    </Tip>
  </Accordion>

  <Accordion title="--silent">
    The `--silent` flag disables output of tip/info messages. Useful when running in scripts or CI/CD pipelines.

    ```bash  theme={"dark"}
    # Example
    infisical secrets get FOO --plain --silent
    ```

    Can be used inline to replace `INFISICAL_DISABLE_UPDATE_CHECK`
  </Accordion>

  <Accordion title="--raw-value (deprecated)">
    Use `--plain` instead, as it supports single and multiple secrets.

    Used to print the plain value of a single requested secret without any table style.

    Default value: `false`

    Example: `infisical secrets get DOMAIN --raw-value`

    <Tip>
      When running in CI/CD environments or in a script, set `INFISICAL_DISABLE_UPDATE_CHECK=true` or add the `--silent` flag. This will help hide any CLI info/debug output and only show the secret value.
    </Tip>
  </Accordion>
</Accordion>

<Accordion title="infisical secrets set">
  This command allows you to set or update secrets in your environment. If the secret key provided already exists, its value will be updated with the new value.
  If the secret key does not exist, a new secret will be created using both the key and value provided.

  ```bash  theme={"dark"}
  $ infisical secrets set <key1=value1> <key2=value2> <key3=@/path/to/file>...

  ## Example
  $ infisical secrets set STRIPE_API_KEY=sjdgwkeudyjwe DOMAIN=example.com HASH=jebhfbwe SECRET_PEM_KEY=@secret.pem
  ```

  <Tip>
    When setting secret values:

    * Use `secretName=@path/to/file` to load the secret value from a file
    * Use `secretName=\@value` if you need the literal '@' character at the beginning of your value

    Example:

    ```bash  theme={"dark"}
    # Set a secret with the value loaded from a certificate file
    $ secrets set CERTIFICATE=@/path/to/certificate.pem

    # Set a secret with the literal value "@example.com"
    $ secrets set email="\@example.com"
    ```
  </Tip>

  ### Flags

  <Accordion title="--env">
    Used to select the environment name on which actions should be taken on

    Default value: `dev`
  </Accordion>

  <Accordion title="--path">
    Used to select the project folder in which the secrets will be set. This is useful when creating new secrets under a particular path.

    ```bash  theme={"dark"}
    # Example
    infisical secrets set DOMAIN=example.com --path="common/backend"
    ```
  </Accordion>

  <Accordion title="--type">
    Used to select the type of secret to create. This could be either personal or shared (defaults to shared)

    ```bash  theme={"dark"}
    # Example
    infisical secrets set DOMAIN=example.com --type=personal
    ```
  </Accordion>

  <Accordion title="--file">
    Used to set secrets from a file, supporting both `.env` and `YAML` formats. The file path can be either absolute or relative to the current working directory.

    The file should contain secrets in the following formats:

    * `key=value` for `.env` files
    * `key: value` for YAML files

    Comments can be written using `# comment` or `// comment`. Empty lines will be ignored during processing.

    ```bash  theme={"dark"}
    # Example
    infisical secrets set --file="./.env"
    ```
  </Accordion>
</Accordion>

<Accordion title="infisical secrets delete">
  This command allows you to delete secrets by their name(s).

  ```bash  theme={"dark"}
  $ infisical secrets delete <keyName1> <keyName2>...

  ## Example
  $ infisical secrets delete STRIPE_API_KEY DOMAIN HASH
  ```

  ### Flags

  <Accordion title="--env">
    Used to select the environment name on which actions should be taken on

    Default value: `dev`
  </Accordion>

  <Accordion title="--path">
    The `--path` flag indicates which project folder secrets will be injected from.

    ```bash  theme={"dark"}
    # Example
    infisical secrets delete <keyName1> <keyName2>... --path="/"
    ```
  </Accordion>
</Accordion>

<Accordion title="infisical secrets folders">
  This command allows you to fetch, create and delete folders from within a path from a given project.

  ```bash  theme={"dark"}
  $ infisical secrets folders
  ```

  ### sub commands

  <Accordion title="get">
    Used to fetch all folders within a path in a given project

    ```
    infisical secrets folders get --path=/some/path/to/folder 
    ```

    #### Flags

    <Accordion title="--path">
      The path from where folders should be fetched from

      Default value: `/`
    </Accordion>

    <Accordion title="--token">
      Fetch folders using a [machine identity](/documentation/platform/identities/machine-identities) access token.

      Default value: \`\`
    </Accordion>
  </Accordion>

  <Accordion title="create">
    Used to create a folder by name within a path.

    ```
    infisical secrets folders create --path=/some/path/to/folder --name=folder-name
    ```

    ### Flags

    <Accordion title="--path">
      Path to where the folder should be created

      Default value: `/`
    </Accordion>

    <Accordion title="--name">
      Name of the folder to be created in selected `--path`

      Default value: \`\`
    </Accordion>
  </Accordion>

  <Accordion title="delete">
    Used to delete a folder by name within a path.

    ```
    infisical secrets folders delete --path=/some/path/to/folder --name=folder-name
    ```

    ### Flags

    <Accordion title="--path">
      Path to where the folder should be created

      Default value: `/`
    </Accordion>

    <Accordion title="--name">
      Name of the folder to be deleted within selected `--path`

      Default value: \`\`
    </Accordion>
  </Accordion>
</Accordion>

<Accordion title="infisical secrets generate-example-env">
  This command allows you to generate an example .env file from your secrets and with their associated comments and tags. This is useful when you would like to let
  others who work on the project but do not use Infisical become aware of the required environment variables and their intended values.

  To place default values in your example .env file, you can simply include the syntax `DEFAULT:<value>` within your secret's comment in Infisical. This will result in the specified value being extracted and utilized as the default.

  ```bash  theme={"dark"}
  $ infisical secrets generate-example-env

  ## Example
  $ infisical secrets generate-example-env > .example-env
  ```

  ### Flags

  <Accordion title="--env">
    Used to select the environment name on which actions should be taken on

    Default value: `dev`
  </Accordion>
</Accordion>


# infisical service-token
Source: https://infisical.com/docs/cli/commands/service-token

Manage Infisical service tokens

<Warning>
  This command is deprecated and will be removed in the near future. Please
  switch to using [Machine
  Identities](/documentation/platform/identities/machine-identities) for
  authenticating with Infisical.
</Warning>

```bash  theme={"dark"}
infisical service-token create --scope=dev:/global --scope=dev:/backend --access-level=read --access-level=write
```

## Description

The Infisical `service-token` command allows you to manage service tokens for a given Infisical project.
With this command, you can create, view, and delete service tokens.

<Accordion title="service-token create" defaultOpen="true">
  Use this command to create a service token

  ```bash  theme={"dark"}
  $ infisical service-token create --scope=dev:/backend/** --access-level=read --access-level=write
  ```

  ### Flags

  <Accordion title="--scope">
    ```bash  theme={"dark"}
    infisical service-token create --scope=dev:/global --scope=dev:/backend/** --access-level=read
    ```

    Use the scope flag to define which environments and paths your service token should be authorized to access.

    The value of your scope flag should be in the following `<environment slug>:<path>`.
    Here, `environment slug` refers to the slug name of the environment, and `path` indicates the folder path where your secrets are stored.

    For specifying multiple scopes, you can use multiple --scope flags.

    <Info>
      The `path` can be a Glob pattern
    </Info>
  </Accordion>

  <Accordion title="--projectId">
    ```bash  theme={"dark"}
    infisical service-token create --scope=dev:/global --access-level=read --projectId=63cefb15c8d3175601cfa989
    ```

    The project ID you'd like to create the service token for.
    By default, the CLI will attempt to use the linked Infisical project in `.infisical.json` generated by `infisical init` command.
  </Accordion>

  <Accordion title="--name">
    ```bash  theme={"dark"}
    infisical service-token create --scope=dev:/global --access-level=read --name service-token-name
    ```

    Service token name

    Default: `Service token generated via CLI`
  </Accordion>

  <Accordion title="--expiry-seconds">
    ```bash  theme={"dark"}
    infisical service-token create --scope=dev:/global --access-level=read --expiry-seconds 120
    ```

    Set the service token's expiration time in seconds from now. To never expire set to zero.

    Default: `1 day`
  </Accordion>

  <Accordion title="--access-level">
    ```bash  theme={"dark"}
    infisical service-token create --scope=dev:/global --access-level=read --access-level=write
    ```

    The type of access the service token should have. Can be `read` and or `write`
  </Accordion>

  <Accordion title="--token-only">
    ```bash  theme={"dark"}
    infisical service-token create --scope=dev:/global --access-level=read --access-level=write --token-only
    ```

    When true, only the service token will be printed

    Default: `false`
  </Accordion>
</Accordion>


# infisical ssh
Source: https://infisical.com/docs/cli/commands/ssh

Generate SSH credentials with the CLI

## Description

[Infisical SSH](/documentation/platform/ssh) lets you issue SSH credentials to clients to provide short-lived, secure SSH access to infrastructure.

This command enables you to obtain SSH credentials used to access a remote host. We recommend using the `connect` sub-command which handles the full workflow of issuing credentials and establishing an SSH connection in one step.

### Sub-commands

<Accordion title="infisical ssh connect">
  This command is used to connect to an SSH host using issued credentials. It will automatically issue credentials and either add them to your SSH agent or write them to disk before establishing an SSH connection.

  ```bash  theme={"dark"}
  $ infisical ssh connect
  ```

  ### Flags

  <Accordion title="--hostname">
    The hostname of the SSH host to connect to. If not provided, you will be prompted to select from available hosts.
  </Accordion>

  <Accordion title="--login-user">
    The login user for the SSH connection. If not provided, you will be prompted to select from available login users.
  </Accordion>

  <Accordion title="--write-host-ca-to-file">
    Whether to write the Host CA public key to `~/.ssh/known_hosts` if it doesn't already exist.

    Default value: `true`
  </Accordion>

  <Accordion title="--out-file-path">
    The path to write the SSH credentials to such as `~/.ssh`, `./some_folder`, `./some_folder/id_rsa-cert.pub`. If not provided, the credentials will be added to the SSH agent and used to establish an interactive SSH connection.
  </Accordion>

  <Accordion title="--token">
    Use a machine identity access token
  </Accordion>
</Accordion>

<Accordion title="infisical ssh add-host">
  This command is used to register a new SSH host with Infisical.

  This command can be used with the `--write-user-ca-to-file`, `--write-host-cert-to-file`, and `--configure-sshd` flags
  to also configure the host's SSH daemon with the necessary certificate authority and host certificate settings.

  ```bash  theme={"dark"}
  $ infisical ssh add-host --projectId=<project-id> --hostname=<hostname>
  ```

  ### Flags

  <Accordion title="--projectId">
    Project ID the host belongs to (required)
  </Accordion>

  <Accordion title="--hostname">
    Hostname of the SSH host (required)
  </Accordion>

  <Accordion title="--alias">
    Alias for the SSH host (optional)
  </Accordion>

  <Accordion title="--write-user-ca-to-file">
    Write User CA public key to `/etc/ssh/infisical_user_ca.pub`

    Default value: `false`
  </Accordion>

  <Accordion title="--user-ca-out-file-path">
    Custom file path to write the User CA public key

    Default value: `/etc/ssh/infisical_user_ca.pub`
  </Accordion>

  <Accordion title="--write-host-cert-to-file">
    Write SSH host certificate to `/etc/ssh/ssh_host_<type>_key-cert.pub`

    Default value: `false`
  </Accordion>

  <Accordion title="--configure-sshd">
    Update `TrustedUserCAKeys`, `HostKey`, and `HostCertificate` in the `/etc/ssh/sshd_config` file

    Default value: `false`

    Note: This flag requires both --write-user-ca-to-file and --write-host-cert-to-file to be set
  </Accordion>

  <Accordion title="--force">
    Force overwrite of existing certificate files as part of `--write-user-ca-to-file` and `--write-host-cert-to-file`

    Default value: `false`
  </Accordion>

  <Accordion title="--token">
    Use a machine identity access token
  </Accordion>
</Accordion>


# infisical token
Source: https://infisical.com/docs/cli/commands/token

Manage your Infisical identity access tokens

```bash  theme={"dark"}
infisical token renew <ua-access-token>
```

## Description

The Infisical `token` command allows you to manage your universal auth access tokens.
With this command, you can renew your access tokens. In the future more subcommands will be added to better help you manage your tokens through the CLI.

<Accordion title="token renew <access-token>" defaultOpen="true">
  Use this command to renew your access token. This command will renew your access token and output a renewed access token to the console.

  ```bash  theme={"dark"}
  $ infisical token renew <ua-access-token>
  ```
</Accordion>


# infisical user
Source: https://infisical.com/docs/cli/commands/user

Manage logged in users

```bash  theme={"dark"}
infisical user
```

## Description

This command allows you to manage the current logged in users on the CLI

### Sub-commands

<Accordion title="infisical user switch" defaultOpen="true">
  Use this command to switch between profiles that are currently logged into the CLI

  ```bash  theme={"dark"}
  infisical user switch
  ```
</Accordion>

<Accordion title="infisical user update domain">
  With this command, you can modify the backend API that is utilized for all requests associated with a specific profile.
  For instance, you have the option to point the profile to use either the Infisical Cloud or your own self-hosted Infisical instance.

  ```bash  theme={"dark"}
  infisical user update domain
  ```
</Accordion>

<Accordion title="infisical user get token">
  Use this command to get your current Infisical access token and session information. This command requires you to be logged in.

  The command will display:

  * Your session ID
  * Your full JWT access token

  ```bash  theme={"dark"}
  infisical user get token
  ```

  Example output:

  ```bash  theme={"dark"}
  Session ID: abc123-xyz-456
  Token: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
  ```

  ### Flags

  <Accordion title="--plain">
    Output only the JWT token without formatting (no session ID)

    Default value: `false`

    ```bash  theme={"dark"}
    # Example
    infisical user get token --plain
    ```

    Example output:

    ```bash  theme={"dark"}
    eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
    ```
  </Accordion>
</Accordion>


# infisical vault
Source: https://infisical.com/docs/cli/commands/vault

Change the vault type in Infisical

<Tabs>
  <Tab title="View current Vault">
    ```bash  theme={"dark"}
    infisical vault 

    # Example output
    Vaults are used to securely store your login details locally. Available vaults:
    - auto (automatically select native vault on system)
    - file (encrypted file vault)

    You are currently using [file] vault to store your login credentials
    ```
  </Tab>

  <Tab title="Switch vault">
    ```bash  theme={"dark"}
    infisical vault set <name-of-vault>

    # Example 
    infisical vault set keychain
    ```
  </Tab>
</Tabs>

## Description

To safeguard your login details when using the CLI, Infisical attempts to store them in a system keyring. If a system keyring cannot be found on your machine, the data is stored in a config file.


# FAQ
Source: https://infisical.com/docs/cli/faq

Frequently Asked Questions about Infisical CLI

Frequently asked questions about the CLI can be found on this page.
If you can't find the answer you are looking for, please create an issue on our GitHub repository or join our Slack channel for additional support.

<Accordion title="I'm getting a Keyring related error message when trying to login" defaultOpen="true">
  By default, the CLI will choose the most suitable store available on your system.
  If you experience issues with the default store, you can switch to a different one.
  If none of the available stores work for you, you can try using the `file` store type by running `infisical vault set file`, which should work in most cases.
  If you are still experiencing trouble, please seek support.

  [Learn more about vault command](./commands/vault)
</Accordion>

<Accordion title="Can I fetch secrets with Infisical if I am offline?">
  Yes. If you have previously retrieved secrets for a specific project and environment (such as dev, staging, or prod), the  `run`/`secret` command will utilize the saved secrets, even when offline, on subsequent fetch attempts.
</Accordion>

<Accordion title="Can I upload the .infisical.json file that was generated?">
  Yes. This is simply a configuration file and contains no sensitive data.
</Accordion>

<Accordion title="Where can I find my Project ID?">
  Visit the Infisical website and navigate to a project of your choice. Once on the project page, access the **Project Settings** from the sidebar. Within the Project name section, click the "Copy Project ID" button for copying the current Project ID to clipboard, or simply obtain it from the URL of the current page.

  ```
    https://app.infisical.com/project/<your_project_id>/settings
  ```
</Accordion>

<Accordion title="How do I use custom headers with the Infisical CLI?">
  The Infisical CLI supports custom HTTP headers for requests to servers that require additional authentication. Set these headers using the `INFISICAL_CUSTOM_HEADERS` environment variable:

  ```bash  theme={"dark"}
  export INFISICAL_CUSTOM_HEADERS="Access-Client-Id=your-client-id Access-Client-Secret=your-client-secret"
  ```

  After setting this environment variable, run your Infisical commands as usual.
</Accordion>

<Accordion title="Why would I need to use custom headers?">
  Custom headers are necessary when your Infisical server is protected by services like Cloudflare Access or other reverse proxies that require specific authentication headers. Without this feature, you would need to implement security workarounds that might compromise your security posture.
</Accordion>

<Accordion title="What format should I use for the custom headers?">
  Custom headers should be specified in the format `headername1=headervalue1 headername2=headervalue2`, with spaces separating each header-value pair. For example:

  ```bash  theme={"dark"}
  export INFISICAL_CUSTOM_HEADERS="Header1=value1 Header2=value2 Header3=value3"
  ```
</Accordion>


# Install
Source: https://infisical.com/docs/cli/overview

Infisical's CLI is one of the best ways to manage environments and secrets. Install it here

The Infisical CLI is a powerful command line tool that can be used to retrieve, modify, export and inject secrets into any process or application as environment variables.
You can use it across various environments, whether it's local development, CI/CD, staging, or production.

## Installation

<Warning>
  As of 04/08/25, all future releases for Debian/Ubuntu will be distributed via the official Infisical repository at [https://artifacts-cli.infisical.com](https://artifacts-cli.infisical.com).
  No new releases will be published for Debian/Ubuntu on Cloudsmith going forward.
</Warning>

<Tabs>
  <Tab title="MacOS">
    Use [brew](https://brew.sh/) package manager

    ```bash  theme={"dark"}
    brew install infisical/get-cli/infisical
    ```

    ### Updates

    ```bash  theme={"dark"}
    brew update && brew upgrade infisical
    ```
  </Tab>

  <Tab title="Windows">
    <Accordion title="Scoop package manager">
      Use [Scoop](https://scoop.sh/) package manager

      ```bash  theme={"dark"}
      scoop bucket add org https://github.com/Infisical/scoop-infisical.git
      ```

      ```bash  theme={"dark"}
      scoop install infisical
      ```

      ### Updates

      ```bash  theme={"dark"}
      scoop update infisical
      ```
    </Accordion>

    <Accordion title="Winget package manager">
      Use [Winget](https://learn.microsoft.com/en-us/windows/package-manager/winget/) package manager

      ```bash  theme={"dark"}
      winget install infisical
      ```
    </Accordion>
  </Tab>

  <Tab title="NPM">
    Use [NPM](https://www.npmjs.com/) package manager

    ```bash  theme={"dark"}
    npm install -g @infisical/cli
    ```

    ### Updates

    ```bash  theme={"dark"}
    npm update -g @infisical/cli
    ```
  </Tab>

  <Tab title="Alpine">
    Install prerequisite

    ```bash  theme={"dark"}
    apk add --no-cache bash sudo
    ```

    Add Infisical repository

    ```bash  theme={"dark"}
    curl -1sLf \
    	'https://dl.cloudsmith.io/public/infisical/infisical-cli/setup.alpine.sh' \
    	| bash
    ```

    Then install CLI

    ```bash  theme={"dark"}
    apk update && sudo apk add infisical
    ```

    ###

    <Tip>
      If you are installing the CLI in production environments, we highly recommend to set the version of the CLI to a specific version. This will help keep your CLI version consistent across reinstalls. [View versions](https://cloudsmith.io/~infisical/repos/infisical-cli/packages/)
    </Tip>
  </Tab>

  <Tab title="RedHat/CentOs/Amazon">
    Add Infisical repository

    ```bash  theme={"dark"}
    curl -1sLf \
    'https://dl.cloudsmith.io/public/infisical/infisical-cli/setup.rpm.sh' \
    | sudo -E bash
    ```

    Then install CLI

    ```bash  theme={"dark"}
    sudo yum install infisical
    ```

    ###

    <Tip>
      If you are installing the CLI in production environments, we highly recommend to set the version of the CLI to a specific version. This will help keep your CLI version consistent across reinstalls. [View versions](https://cloudsmith.io/~infisical/repos/infisical-cli/packages/)
    </Tip>
  </Tab>

  <Tab title="Debian/Ubuntu">
    Add Infisical repository

    ```bash  theme={"dark"}
    curl -1sLf \
    'https://artifacts-cli.infisical.com/setup.deb.sh' \
    | sudo -E bash
    ```

    Then install CLI

    ```bash  theme={"dark"}
    sudo apt-get update && sudo apt-get install -y infisical
    ```

    ###

    <Tip>
      If you are installing the CLI in production environments, we highly recommend to set the version of the CLI to a specific version. This will help keep your CLI version consistent across reinstalls. [View versions](https://cloudsmith.io/~infisical/repos/infisical-cli/packages/)
    </Tip>
  </Tab>

  <Tab title="Arch Linux">
    Use the `yay` package manager to install from the [Arch User Repository](https://aur.archlinux.org/packages/infisical-bin)

    ```bash  theme={"dark"}
    yay -S infisical-bin
    ```

    ###

    <Tip>
      If you are installing the CLI in production environments, we highly recommend to set the version of the CLI to a specific version. This will help keep your CLI version consistent across reinstalls. [View versions](https://cloudsmith.io/~infisical/repos/infisical-cli/packages/)
    </Tip>
  </Tab>
</Tabs>

## Quick Usage Guide

<Card color="#00A300" href="./usage">
  Now that you have the CLI installed on your system, follow this guide to make the best use of it
</Card>


# Project config file
Source: https://infisical.com/docs/cli/project-config

Project config file & customization options

To link your local project on your machine with an Infisical project, we suggest using the infisical init CLI command. This will generate a `.infisical.json` file in the root directory of your project.

The `.infisical.json` file specifies various parameters, such as the Infisical project to retrieve secrets from, along with other configuration options. Furthermore, you can define additional properties in the file to further tailor your local development experience.

## Set default environment

If you need to change environments while using the CLI, you can do so by including the `--env` flag in your command.
However, this can be inconvenient if you typically work in just one environment.
To simplify the process, you can establish a default environment, which will be used for every command unless you specify otherwise.

```json .infisical.json theme={"dark"}
{
  "workspaceId": "63ee5410a45f7a1ed39ba118",
  "defaultEnvironment": "test",
  "gitBranchToEnvironmentMapping": null
}
```

### How it works

If both `defaultEnvironment` and `gitBranchToEnvironmentMapping` are configured, `gitBranchToEnvironmentMapping` will take precedence over `defaultEnvironment`.
However, if `gitBranchToEnvironmentMapping` is not set and `defaultEnvironment` is, then the `defaultEnvironment` will be used to execute your Infisical CLI commands.
If you wish to override the `defaultEnvironment`, you can do so by using the `--env` flag explicitly.

## Set Infisical environment based on GitHub branch

When fetching your secrets from Infisical, you can switch between environments by using the `--env` flag. However, in certain cases, you may prefer the environment to be automatically mapped based on the current GitHub branch you are working on.
To achieve this, simply add the `gitBranchToEnvironmentMapping` property to your configuration file, as shown below.

```json .infisical.json theme={"dark"}
{
  "workspaceId": "63ee5410a45f7a1ed39ba118",
  "gitBranchToEnvironmentMapping": {
    "branchName": "dev",
    "anotherBranchName": "staging"
  }
}
```

### How it works

After configuring this property, every time you use the CLI with the specified configuration file, it will automatically verify if there is a corresponding environment mapping for the current Github branch you are on.
If it exists, the CLI will use that environment to retrieve secrets. You can override this behavior by explicitly using the `--env` flag while interacting with the CLI.


# Secret scanning
Source: https://infisical.com/docs/cli/scanning-overview

Scan and prevent secret leaks in your code base

Building upon its core functionality of fetching and injecting secrets into your applications, Infisical now takes a significant step forward in bolstering your code security.
We've enhanced our CLI tool to include a powerful scanning feature, capable of identifying more than 140 different types of secret leaks in your codebase.
In addition to scanning for past leaks, this new addition also actively aids in preventing future leaks.

# Scanning

<Tabs>
  <Tab title="Scanning files, directories and or git history">
    ```bash  theme={"dark"}
    infisical scan

    # Display the full secret findings
    infisical scan --verbose
    ```

    The `infisical scan` command serves to scan repositories, directories, and files. It's compatible with both individual developer machines and Continuous Integration (CI) environments.

    When you run `infisical scan` on a Git repository, Infisical will parses the output of a `git log -p` command. This command generates [patches](https://stackoverflow.com/questions/8279602/what-is-a-patch-in-git-version-control) that Infisical uses to identify secrets in your code.
    You can configure the range of commits that `git log` will cover using the `--log-opts` flag.
    Any options you can use with `git log -p` are valid for `--log-opts`.

    For instance, to instruct Infisical to scan a specific range of commits, use the following command: `infisical scan --log-opts="--all commitA..commitB"`. For more details, refer to the [Git log documentation](https://git-scm.com/docs/git-log).

    To scan individual files and directories, use the `--no-git` flag.

    **View [full details for this command](./commands/scan)**
  </Tab>

  <Tab title="Scanning uncommitted files ">
    ```bash  theme={"dark"}
    infisical scan git-changes

    # Display the full secret findings
    infisical scan git-changes --verbose
    ```

    Scanning for secrets before you commit your changes is great way to prevent leaks. Infisical makes this easy with the sub command `git-changes`.

    The `git-changes` scans for uncommitted changes in a Git repository, and is especially designed for use on developer machines, aligning with the ['shift left'](https://cloud.google.com/architecture/devops/devops-tech-shifting-left-on-security) security approach.
    When `git-changes` is run on a Git repository, Infisical parses the output from a `git diff` command.

    To scan changes in commits that have been staged via `git add`, you can add the `--staged` flag to the sub command. This flag is particularly useful when using Infisical CLI as a pre-commit tool.

    **View [full details for this command](./commands/scan-git-changes)**
    

    <Info>
      `git-changes` command is only for Git repositories; using it on files or directories will result in an error.
    </Info>
  </Tab>
</Tabs>

#

#

# Automatically scan changes before you commit

To lower the risk of committing hardcoded secrets to your code repository, we have designed a custom git pre-commit hook.
This hook scans the changes you're about to commit for any exposed secrets. If any hardcoded secrets are detected, it will block your commit.

### Install pre-commit hook

To install this git hook, go into your local git repository and run the following command.

```bash  theme={"dark"}
infisical scan install --pre-commit-hook
```

To disable this hook after installing it, run the command `git config --bool hooks.infisical-scan false`

### Third party hooks management

If you would rather handle your pre-commit hook outside of the standard `.git/hooks` directory, you can quickly achieve this by adding the following command into your pre-commit script.
For instance, if you utilize [Husky](https://typicode.github.io/husky/) for managing your Git hooks, you can insert the command provided below into your `.husky/pre-commit` file.

```bash  theme={"dark"}
infisical scan git-changes --staged --verbose
```

#

#

# Creating a baseline

When scanning large repositories or repositories with a long history, it can be helpful to use a baseline.

A baseline allows Infisical to ignore any old findings that are already present in the baseline findings. You can create a infisical scan report by running `infisical scan` with the `--report-path` flag.

To create a Infisical scan report and save it in a file called leaks-report.json, use the following command:

```
infisical scan --report-path leaks-report.json
```

Once a baseline is created, you can apply it when running the `infisical scan` command again. Use the following command:

```
infisical scan --baseline-path leaks-report.json --report-path findings.json
```

After running the `scan` command with the `--baseline-path` flag, the report output in findings.json will only contain new issues.

#

#

# Configuration file

To customize the scan, such as specifying your own rules or establishing exceptions for certain files or paths that should not be flagged as risks, you can define these specifications in the configuration file.

<Accordion title="Example custom configuration file">
  ```toml infisical-scan.toml theme={"dark"}
  # Title for the configuration file
  title = "Some title"


  # This configuration is the foundation that can be expanded. If there are any overlapping rules
  # between this base and the expanded configuration, the rules in this base will take priority.
  # Another aspect of extending configurations is the ability to link multiple files, up to a depth of 2.
  # "Allowlist" arrays get appended and may have repeated elements.
  # "useDefault" and "path" cannot be used simultaneously. Please choose one.
  [extend]
  # useDefault will extend the base configuration with the default config:
  # https://raw.githubusercontent.com/Infisical/infisical/main/cli/config/infisical-scan.toml
  useDefault = true
  # or you can supply a path to a configuration. Path is relative to where infisical cli
  # was invoked, not the location of the base config.
  path = "common_config.toml"

  # An array of tables that contain information that define instructions
  # on how to detect secrets
  [[rules]]

  # Unique identifier for this rule
  id = "some-identifier-for-rule"

  # Short human readable description of the rule.
  description = "awesome rule 1"

  # Golang regular expression used to detect secrets. Note Golang's regex engine
  # does not support lookaheads.
  regex = '''one-go-style-regex-for-this-rule'''

  # Golang regular expression used to match paths. This can be used as a standalone rule or it can be used
  # in conjunction with a valid `regex` entry.
  path = '''a-file-path-regex'''

  # Array of strings used for metadata and reporting purposes.
  tags = ["tag","another tag"]

  # A regex match may have many groups, this allows you to specify the group that should be used as (which group the secret is contained in)
  # its entropy checked if `entropy` is set.
  secretGroup = 3

  # Float representing the minimum shannon entropy a regex group must have to be considered a secret.
  # Shannon entropy measures how random a data is. Since secrets are usually composed of many random characters, they typically have high entropy
  entropy = 3.5

  # Keywords are used for pre-regex check filtering.
  # If rule has keywords but the text fragment being scanned doesn't have at least one of it's keywords, it will be skipped for processing further.
  # Ideally these values should either be part of the identifier or unique strings specific to the rule's regex
  # (introduced in v8.6.0)
  keywords = [
  	"auth",
  	"password",
  	"token",
  ]

  # You can include an allowlist table for a single rule to reduce false positives or ignore commits
  # with known/rotated secrets
  [rules.allowlist]
  description = "ignore commit A"
  commits = [ "commit-A", "commit-B"]
  paths = [
  	'''go\.mod''',
  	'''go\.sum'''
  ]
  # note: (rule) regexTarget defaults to check the _Secret_ in the finding.
  # if regexTarget is not specified then _Secret_ will be used.
  # Acceptable values for regexTarget are "match" and "line"
  regexTarget = "match"
  regexes = [
  	'''process''',
  	'''getenv''',
  ]
  # note: stopwords targets the extracted secret, not the entire regex match
  # if the extracted secret is found in the stopwords list, the finding will be skipped (i.e not included in report)
  stopwords = [
  	'''client''',
  	'''endpoint''',
  ]


  # This is a global allowlist which has a higher order of precedence than rule-specific allowlists.
  # If a commit listed in the `commits` field below is encountered then that commit will be skipped and no
  # secrets will be detected for said commit. The same logic applies for regexes and paths.
  [allowlist]
  description = "global allow list"
  commits = [ "commit-A", "commit-B", "commit-C"]
  paths = [
  	'''gitleaks\.toml''',
  	'''(.*?)(jpg|gif|doc)'''
  ]

  # note: (global) regexTarget defaults to check the _Secret_ in the finding.
  # if regexTarget is not specified then _Secret_ will be used.
  # Acceptable values for regexTarget are "match" and "line"
  regexTarget = "match"

  regexes = [
  	'''219-09-9999''',
  	'''078-05-1120''',
  	'''(9[0-9]{2}|666)-\d{2}-\d{4}''',
  ]
  # note: stopwords targets the extracted secret, not the entire regex match
  # if the extracted secret is found in the stopwords list, the finding will be skipped (i.e not included in report)
  stopwords = [
  	'''client''',
  	'''endpoint''',
  ]
  ```
</Accordion>

#

#

# Ignoring Known Secrets

If you're intentionally committing a test secret that `infisical scan` might flag, you can instruct Infisical to overlook that secret with the methods listed below.

### infisical-scan:ignore

To ignore a secret contained in line of code, simply add `infisical-scan:ignore ` at the end of the line as comment in the given programming.

```js example.js theme={"dark"}
function helloWorld() {
    console.log("8dyfuiRyq=vVc3RRr_edRk-fK__JItpZ"); // infisical-scan:ignore
}
```

### .infisicalignore

An alternative method to exclude specific findings involves creating a .infisicalignore file at your repository's root.
You can then add the fingerprints of the findings you wish to exclude. The Infisical scan report provides a unique Fingerprint for each secret found.
By incorporating these Fingerprints into the .infisicalignore file, Infisical will skip the corresponding secret findings in subsequent scans.

```.ignore .infisicalignore theme={"dark"}
bea0ff6e05a4de73a5db625d4ae181a015b50855:frontend/components/utilities/attemptLogin.js:stripe-access-token:147
bea0ff6e05a4de73a5db625d4ae181a015b50855:backend/src/json/integrations.json:generic-api-key:5
1961b92340e5d2613acae528b886c842427ce5d0:frontend/components/utilities/attemptLogin.js:stripe-access-token:148
```


# Quickstart
Source: https://infisical.com/docs/cli/usage

Manage secrets with Infisical CLI

The CLI is designed for a variety of secret management applications ranging from local development to CI/CD and production scenarios.

<Tabs>
  <Tab title="Local development">
    In the following steps, we explore how to use the Infisical CLI to fetch back environment variables from Infisical
    and inject them into your local development process.

    <Note>
      If you prefer learning by watching, you can follow along our step-by-step video tutorial [here](https://www.youtube.com/watch?v=EzDQC7nY3YY).
    </Note>

    <Steps>
      <Step title="Log in with the CLI">
        Start by running the `infisical login` command to authenticate with Infisical.

        ```bash  theme={"dark"}
        infisical login
        ```

        <Note>
          If you are in a containerized environment such as WSL 2 or Codespaces, run `infisical login -i` to avoid browser based login
        </Note>
      </Step>

      <Step title="Initialize Infisical for your project">
        Next, navigate to your project and initialize Infisical.

        ```bash  theme={"dark"}
        # navigate to your project
        cd /path/to/project

        # initialize infisical
        infisical init
        ```

        The `infisical init` command creates a `.infisical.json` file, containing [local project settings](./project-config), at the location where the command is executed.

        <Note>
          The `.infisical.json` file does not contain any sensitive data, so you may commit it to your git repository.
        </Note>
      </Step>

      <Step title="Inject environment variables">
        Finally, pass environment variables from Infisical into your application.

        <Tabs>
          <Tab title="Feed secrets to your application">
            ```bash  theme={"dark"}
            infisical run --env=dev --path=/apps/firefly -- [your application start command] # e.g. npm run dev

            # example with node (nodemon)
            infisical run --env=staging --path=/apps/spotify -- nodemon index.js

            # example with flask
            infisical run --env=prod --path=/apps/backend -- flask run

            # example with spring boot - maven
            infisical run --env=dev --path=/apps/ -- ./mvnw spring-boot:run --quiet
            ```
          </Tab>

          <Tab title="Feed secrets via custom aliases (advanced)">
            Custom aliases can utilize secrets from Infisical. Suppose there is a custom alias `yd` in `custom.sh` that runs `yarn dev` and needs the secrets provided by Infisical.

            ```bash  theme={"dark"}
            #!/bin/sh

            yd() {
              yarn dev
            }
            ```

            To make the secrets available from Infisical to `yd`, you can run the following command:

            ```bash  theme={"dark"}
            infisical run --env=prod --path=/apps/reddit --command="source custom.sh && yd"
            ```
          </Tab>
        </Tabs>

        View all available options for `run` command [here](./commands/run)
      </Step>
    </Steps>
  </Tab>

  <Tab title="Staging, production & all other use cases">
    In the following steps, we explore how to use the Infisical CLI in a non-local development scenario
    to fetch back environment variables and export them to a file.

    <Steps>
      <Step title="Create a machine identity and obtain credentials for it">
        Follow the steps listed [here](/documentation/platform/identities/universal-auth) to create a machine identity and obtain a **client ID** and **client secret** for it.
      </Step>

      <Step title="Obtain a machine identity access token">
        Run the following command to authenticate with Infisical using the **client ID** and **client secret** credentials from step 1 and set the `INFISICAL_TOKEN` environment variable to the retrieved access token.

        ```bash  theme={"dark"}
        export INFISICAL_TOKEN=$(infisical login --method=universal-auth --client-id=<identity-client-id> --client-secret=<identity-client-secret> --silent --plain) # --plain flag will output only the token, so it can be fed to an environment variable. --silent will disable any update messages.
        ```

        The CLI is configured to look out for the `INFISICAL_TOKEN` environment variable, so going forward any command used will be authenticated.

        Alternatively, assuming you have an access token on hand, you can also pass it directly to the CLI using the `--token` flag in conjunction with other CLI commands.

        <Info>
          Keep in mind that the machine identity access token has a limited lifetime. It is recommended to use it only for the duration of the task at hand.
          You can [refresh the token](./commands/token) if needed.
        </Info>
      </Step>

      <Step title="Export environment variables back into a file">
        Finally, export the environment variables from Infisical to a file of choice.

        ```bash  theme={"dark"}
        # export variables to a .env file (with export keyword)
        infisical export --format=dotenv-export > .env

        # export variables to a YAML file
        infisical export --format=yaml > secrets.yaml
        ```
      </Step>
    </Steps>
  </Tab>
</Tabs>

<Note>
  Starting with CLI version v0.4.0, you can now choose to log in via Infisical Cloud (US/EU) or your own self-hosted instance by simply running `infisical login` and following the on-screen instructions  no need to manually set the `INFISICAL_API_URL` environment variable.

  For versions prior to v0.4.0, the CLI defaults to the US Cloud. To connect to the EU Cloud or a self-hosted instance, set the `INFISICAL_API_URL` environment variable to `https://eu.infisical.com` or your custom URL.
</Note>

<Tip>
  ## Custom Request Headers

  The Infisical CLI supports custom HTTP headers for requests to servers protected by authentication services such as Cloudflare Access. Configure these headers using the `INFISICAL_CUSTOM_HEADERS` environment variable:

  ```bash  theme={"dark"}
  # Syntax: headername1=headervalue1 headername2=headervalue2
  export INFISICAL_CUSTOM_HEADERS="Access-Client-Id=your-client-id Access-Client-Secret=your-client-secret"

  # Execute Infisical commands after setting the environment variable
  infisical secrets
  ```

  This functionality enables secure interaction with Infisical instances that require specific authentication headers.
</Tip>

## History

Your terminal keeps a history with the commands you run. When you create Infisical secrets directly from your terminal, they'll stay there for a while.

For security and privacy concerns, we recommend you to configure your terminal to ignore those specific Infisical commands.

<Accordion title="Ignore commands">
  <Tabs>
    <Tab title="Unix/Linux">
      <Tip>
        `$HOME/.profile` is pretty common but, you could place it under `$HOME/.profile.d/infisical.sh` or any profile file run at login
      </Tip>

      ```bash  theme={"dark"}
      cat <<EOF >> $HOME/.profile && source $HOME/.profile

      # Ignoring specific Infisical CLI commands
      DEFAULT_HISTIGNORE=$HISTIGNORE
      export HISTIGNORE="*infisical secrets set*:$DEFAULT_HISTIGNORE"
      EOF
      ```
    </Tab>

    <Tab title="Windows">
      If you're on WSL, then you can use the Unix/Linux method.

      <Tip>
        Here's some [documentation](https://superuser.com/a/1658331) about how to clear the terminal history, in PowerShell and CMD
      </Tip>
    </Tab>
  </Tabs>
</Accordion>

## FAQ

<AccordionGroup>
  <Accordion title="Can I connect the CLI to my self-hosted Infisical instance?">
    Yes. The CLI is set to connect to Infisical Cloud by default, but if you're running your own instance of Infisical, you can direct the CLI to it using one of the methods provided below.

    #### Method 1: Use the updated CLI

    Beginning with CLI version V0.4.0, it is now possible to choose between logging in through the Infisical cloud or your own self-hosted instance. Simply execute the `infisical login` command and follow the on-screen instructions.

    #### Method 2: Export environment variable

    You can point the CLI to the self-hosted Infisical instance by exporting the environment variable `INFISICAL_API_URL` in your terminal.

    <Tabs>
      <Tab title="Linux/MacOs">
        ```bash  theme={"dark"}
        # set backend host
        export INFISICAL_API_URL="https://your-self-hosted-infisical.com/api"

        # remove backend host
        unset INFISICAL_API_URL
        ```
      </Tab>

      <Tab title="Windows Powershell">
        ```bash  theme={"dark"}
        # set backend host
        setx INFISICAL_API_URL "https://your-self-hosted-infisical.com/api"

        # remove backend host
        setx INFISICAL_API_URL ""

        # NOTE: Once set or removed, please restart powershell for the change to take effect
        ```
      </Tab>
    </Tabs>

    #### Method 3: Set manually on every command

    Another option to point the CLI to your self-hosted Infisical instance is to set it via a flag on every command you run.

    ```bash  theme={"dark"}
    # Example
    infisical <any-command> --domain="https://your-self-hosted-infisical.com/api"
    ```
  </Accordion>

  <Accordion title="Can I use the CLI with service tokens?">
    To use Infisical for non local development scenarios, please create a service token. The service token will allow you to authenticate and interact with Infisical. Once you have created a service token with the required permissions, youll need to feed the token to the CLI.

    ```bash  theme={"dark"}
      infisical export --token=<service-token>
      infisical secrets --token=<service-token>
      infisical run --token=<service-token> -- npm run dev
    ```

    #### Pass via shell environment variable

    The CLI is configured to look for an environment variable named `INFISICAL_TOKEN`. If set, itll attempt to use it for authentication.

    ```bash  theme={"dark"}
      export INFISICAL_TOKEN=<service-token>
    ```
  </Accordion>
</AccordionGroup>


# Code of Conduct
Source: https://infisical.com/docs/contributing/getting-started/code-of-conduct

What you should know before contributing to Infisical?

## Our Pledge

We as members, contributors, and leaders pledge to make participation in our
community a harassment-free experience for everyone, regardless of age, body
size, visible or invisible disability, ethnicity, sex characteristics, gender
identity and expression, level of experience, education, socio-economic status,
nationality, personal appearance, race, caste, color, religion, or sexual
identity and orientation.

We pledge to act and interact in ways that contribute to an open, welcoming,
diverse, inclusive, and healthy community.

## Our Standards

Examples of behavior that contributes to a positive environment for our
community include:

* Demonstrating empathy and kindness toward other people
* Being respectful of differing opinions, viewpoints, and experiences
* Giving and gracefully accepting constructive feedback
* Accepting responsibility and apologizing to those affected by our mistakes,
  and learning from the experience
* Focusing on what is best not just for us as individuals, but for the overall
  community

Examples of unacceptable behavior include:

* The use of sexualized language or imagery, and sexual attention or advances of
  any kind
* Trolling, insulting or derogatory comments, and personal or political attacks
* Public or private harassment
* Publishing others' private information, such as a physical or email address,
  without their explicit permission
* Other conduct which could reasonably be considered inappropriate in a
  professional setting

## Enforcement Responsibilities

Community leaders are responsible for clarifying and enforcing our standards of
acceptable behavior and will take appropriate and fair corrective action in
response to any behavior that they deem inappropriate, threatening, offensive,
or harmful.

Community leaders have the right and responsibility to remove, edit, or reject
comments, commits, code, wiki edits, issues, and other contributions that are
not aligned to this Code of Conduct, and will communicate reasons for moderation
decisions when appropriate.

## Scope

This Code of Conduct applies within all community spaces, and also applies when
an individual is officially representing the community in public spaces.
Examples of representing our community include using an official e-mail address,
posting via an official social media account, or acting as an appointed
representative at an online or offline event.

## Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be
reported to the community leaders responsible for enforcement at
[team@infisical.com](mailto:team@infisical.com).
All complaints will be reviewed and investigated promptly and fairly.

All community leaders are obligated to respect the privacy and security of the
reporter of any incident.

## Enforcement Guidelines

Community leaders will follow these Community Impact Guidelines in determining
the consequences for any action they deem in violation of this Code of Conduct:

### 1. Correction

**Community Impact**: Use of inappropriate language or other behavior deemed
unprofessional or unwelcome in the community.

**Consequence**: A private, written warning from community leaders, providing
clarity around the nature of the violation and an explanation of why the
behavior was inappropriate. A public apology may be requested.

### 2. Warning

**Community Impact**: A violation through a single incident or series of
actions.

**Consequence**: A warning with consequences for continued behavior. No
interaction with the people involved, including unsolicited interaction with
those enforcing the Code of Conduct, for a specified period of time. This
includes avoiding interactions in community spaces as well as external channels
like social media. Violating these terms may lead to a temporary or permanent
ban.

### 3. Temporary Ban

**Community Impact**: A serious violation of community standards, including
sustained inappropriate behavior.

**Consequence**: A temporary ban from any sort of interaction or public
communication with the community for a specified period of time. No public or
private interaction with the people involved, including unsolicited interaction
with those enforcing the Code of Conduct, is allowed during this period.
Violating these terms may lead to a permanent ban.

### 4. Permanent Ban

**Community Impact**: Demonstrating a pattern of violation of community
standards, including sustained inappropriate behavior, harassment of an
individual, or aggression toward or disparagement of classes of individuals.

**Consequence**: A permanent ban from any sort of public interaction within the
community.

## Attribution

This Code of Conduct is adapted from the [Contributor Covenant][homepage],
version 2.1, available at
[https://www.contributor-covenant.org/version/2/1/code\_of\_conduct.html][v2.1].

Community Impact Guidelines were inspired by
[Mozilla's code of conduct enforcement ladder][mozilla coc].

For answers to common questions about this code of conduct, see the FAQ at
[https://www.contributor-covenant.org/faq][faq]. Translations are available at
[https://www.contributor-covenant.org/translations][translations].

[homepage]: https://www.contributor-covenant.org

[v2.1]: https://www.contributor-covenant.org/version/2/1/code_of_conduct.html

[mozilla coc]: https://github.com/mozilla/diversity

[faq]: https://www.contributor-covenant.org/faq

[translations]: https://www.contributor-covenant.org/translations


# Overview
Source: https://infisical.com/docs/contributing/getting-started/overview

Contributing to the Infisical ecosystem.

To set a strong foundation, this section outlines how we, the community and members of Infisical,
should approach the development and contribution process.

## Code-bases

Infisical has two major code-bases. One for the platform code, and one for SDKs. The contribution process has some key differences between the two, so we've split the documentation into two sections:

* The [Infisical Platform](https://github.com/Infisical/infisical), the Infisical platform itself.
* The <b>Infisical SDKs</b>, please refer to each individual SDK repositories for more information.
  * [Node.js SDK](https://github.com/Infisical/node-sdk-v2)
  * [Python SDK](https://github.com/Infisical/python-sdk-official)
  * [Java SDK](https://github.com/Infisical/java-sdk)
  * [.NET SDK](https://github.com/Infisical/infisical-dotnet-sdk)
  * [Go SDK](https://github.com/Infisical/go-sdk)
  * [C++ SDK](https://github.com/Infisical/infisical-cpp-sdk)
  * [PHP SDK](https://github.com/Infisical/php-sdk)
  * [Rust SDK](https://github.com/Infisical/rust-sdk)

## Community

We are building an inclusive community, and this means adhering to the [Code of Conduct](/contributing/getting-started/code-of-conduct).

## Bugs and issues

Bug reports help make Infisical a better experience for everyone. When you report a bug, a template will be created automatically containing information we'd like to know.

Before raising a new issue, please search existing ones to make sure you're not creating a duplicate.

<Info>
  If the issue is related to security, please email us directly at
  [team@infisical.com](mailto:team@infisical.com).
</Info>

## Deciding what to work on

You can start by browsing through our list of issues or adding your own that improves on the platform experience. Once you've decided on an issue, leave a comment and wait to get approved; this helps avoid multiple people working on the same issue.

If you're ever in doubt about whether or not a proposed feature aligns with Infisical as a whole, feel free to raise an issue about it and we'll get back to you promptly.

## Writing and submitting code

Anyone can contribute code to Infisical. To get started, check out the local development guide for the platform:

* Local development guide for Platform is [here](/contributing/platform/developing).

## Licensing

Most of Infisical's code is under the MIT license, though some paid feature restrictions are covered by a proprietary license.

Any third party components incorporated into our code are licensed under the original license provided by the applicable component owner.


# Pull requests
Source: https://infisical.com/docs/contributing/getting-started/pull-requests

This guide walks through the code submission process for Infisical.

## Making a pull request

Once you are done making changes in local development, you can submit a pull request (PR) to the main repository branch.

We require a few considerations on your part to ensure that PRs are easy to review and up to standard with the code.

### Title and content

Start by providing a concise title addressing what your PR achieves such as "add pagination to retrieve environment variables for GitLab integration."

You should follow the automatically-generated PR template to fill in the PR description. This includes a more detailed description of the changes in the PR, the type of PR, and an acknowledgement that you've read and agreed to the contributing guidelines.

### Feature PRs

Give a functional overview of how your feature works, including how the user can use the feature. Then share any technical details in an overview of how the PR works.

As of `06-01-2023`, all PRs created after this date are required to attach a video of you performing the described functionality.

### Bug Fix PRs

Give an overview of the bug at hand and how your PR fixes the it at both a high and low level.

Feel free to add a short video or screenshots of what your PR achieves.

## Getting your PR reviewed

One or two relevant members of the Infisical team should review and approve the PR before it is merged. You can ping someone from the team in our [Slack](https://infisical.com/slack) to review your PR.

The team member(s) will start by enabling baseline checks to ensure that there are no leaked secrets, new dependencies are clear, and the frontend/backend services start up. Afterward, they will review your PR thoroughly by testing the code and leave any feedback or work in with you to revise the PR up to standard.

Once everything is good, the team member(s) will approve the PR to be merged into the `main` branch; all changes will be tested in CI/CD and our staging environment first before being deployed to production.

<Note>
  Due to the high volume of issues, PRs, etc. from the community, and limited bandwidth on our end to address everything instantly, we prefer
  reviewing PRs once they are fully complete and well-tested.

  In the past, we've often had to review low-quality PRs up to 10 times which severely restricts our capacity to address other issues, PRs, and initiatives in the pipeline. As such, we ask of the community to submit higher-quality PRs that, for example, don't break existing code; in return we'll prioritize the first 3 reviews for PRs.
</Note>


# Backend folder structure
Source: https://infisical.com/docs/contributing/platform/backend/folder-structure



```
 scripts
 e2e-test
 bdd
 src/
     @types/
        knex.d.ts
        fastify.d.ts
        ...
     db/
        migrations
        schemas
        seeds
     keystore/
     lib/
        api-docs
        aws
        axios
        base64
        casl
        certificates
        config
        crypto
        dates
        delay
        error-codes
        errors
        files
        fn
        ...
     queue
     server/
        routes/
           v1
           v2
           v3
           v4
        plugins
        config
        lib
     services/
        auth
        org
        ...
        project/
            project-service.ts
            project-types.ts
            project-dal.ts
     ee/
         routes
         services
```

### `backend/scripts`

Contains reusable scripts for backend automation, like running migrations and generating SQL schemas.

### `backend/e2e-test`

Integration tests for the APIs.

### `backend/bdd`

Behavior-Driven Development (BDD) tests using Python and Gherkin feature files.

### `backend/src`

The source code of the backend.

* `@types`: Type definitions for libraries like Fastify, Knex, and other third-party dependencies.
* `db`: Knex.js configuration for the database, including migrations, seed files, and SQL type schemas.
* `keystore`: Key-value store abstraction layer supporting Redis and PostgreSQL for application caching, distributed locking, and coordination.
* `lib`: Stateless, reusable functions used across the codebase, organized by functionality (crypto, config, dates, etc.).
* `queue`: Infisical's queue system based on BullMQ.

### `src/server`

* Scope anything related to Fastify/service here.
* Includes routes, Fastify plugins, server configurations, and server-specific utilities.
* The routes folder contains various versions of routes separated into v1, v2, v3, v4, etc.

### `src/services`

* Handles the core business logic for all operations.
* Follows the co-location principle: related components should be kept together.
* Each service component typically contains:

  1. **dal**: Database Access Layer functions for database operations
  2. **service**: The service layer containing business logic.
  3. **type**: Type definitions used within the service component.
  4. **fns**: An optional component for sharing reusable functions related to the service.
  5. **queue**: An optional component for queue-specific logic, like `secret-queue.ts`.

### `src/ee`

Follows the same pattern as above, with the exception of a license change from MIT to Infisical Proprietary License.

### Guidelines and Best Practices

* All services are interconnected at `/src/server/routes/index.ts`, following the principle of simple dependency injection.
* Files should be named in dash-case.
* Avoid using classes in the codebase; opt for simple functions instead.
* All committed code must be properly linted using `npm run lint:fix` and type-checked with `npm run type:check`.
* Minimize shared logic between services as much as possible.
* Controllers within a router component should ideally call only one service layer, with exceptions for services like `audit-log` that require access to request object data.


# Backend development guide
Source: https://infisical.com/docs/contributing/platform/backend/how-to-create-a-feature



Suppose you're interested in implementing a new feature in Infisical's backend, let's call it "feature-x." Here are the general steps you should follow.

## Creating new database model

If your feature involves a change in the database, you need to first address this by generating the necessary database schemas.

1. If you're adding a new table, update the `TableName` enum in `/src/db/schemas/models.ts` to include the new table name.
2. Create a new migration file by going to the `/backend` folder and running `npm run migration:new` and give it a relevant name, such as `feature-x`.
3. Navigate to `/src/db/migrations/<timestamp>_<feature-x>.ts`.
4. Modify both the `up` and `down` functions to create or alter Postgres fields on migration up and to revert these changes on migration down, ensuring idempotency as outlined [here](https://github.com/graphile/migrate/blob/main/docs/idempotent-examples.md).

### Generating TS Schemas

While typically you would need to manually write TS types for Knex type-sense, we have automated this process:

1. If you haven't done it yet, create a new `.env.migration` file at the root of the Infisical directory then copy the contents of the file linked [here](https://github.com/Infisical/infisical/blob/main/.env.migration.example)
2. Start the server.
3. Go to the `/backend` folder and run `npm run migration:latest-dev` to apply all database changes.
4. Execute `npm run generate:schema` to automatically generate types and schemas using [zod](https://github.com/colinhacks/zod) in the `/src/db/schemas` folder.
5. Update the barrel export in `schema/index` and include the new tables in `/src/@types/knex.d.ts` to enable type-sensing in Knex.js.

## Business Logic

Once the database changes are in place, it's time to create the APIs for `feature-x`:

1. Execute `npm run generate:component`.
2. Choose option 1 for the service component.
3. Name the service in dash-case, like `feature-x`. This will create a `feature-x` folder in `/src/services` containing three files.
   1. `feature-x-dal`: The Database Access Layer functions.
   2. `feature-x-service`: The service layer where all the business logic is handled.
   3. `feature-x-type`: The types used by `feature-x`.

For reusable shared functions, set up a file named `feature-x-fns`.

Use the custom Infisical function `ormify` in `src/lib/knex` for simple database operations within the DAL.

## Connecting the Service Layer to the Server Layer

Server-related logic is handled in `/src/server`. To connect the service layer to the server layer, we use Fastify's dependency injection pattern:

1. Add the service type in `/src/@types/fastify.d.ts` under the `services` namespace of the `FastifyInstance` interface.
2. In `/src/server/routes/index.ts`, instantiate the required dependencies for `feature-x` (such as the DAL and service layers), and then add the service instance to the `server.decorate()` call, where all services are registered for dependency injection.
3. This makes the service layer accessible within all routes under the Fastify service instance, accessed via `server.services.<registered service name>.<function>`.

## Writing API Routes

1. To create a route component, run `npm run generate:component`.
2. Select option 3, type the router name in dash-case, and provide the version number. This will generate a router file in `src/server/routes/v<version-number>/<router component name>`
   1. Implement your logic to connect with the service layer as needed.
   2. Import the router component in the version folder's index.ts. For instance, if it's in v1, import it in `v1/index.ts`.
   3. Finally, register it under the appropriate prefix for access.


# Local development
Source: https://infisical.com/docs/contributing/platform/developing

This guide will help you set up and run the Infisical platform in local development.

## Fork and clone the repo

[Fork](https://docs.github.com/en/get-started/quickstart/fork-a-repo) the [repository](https://github.com/Infisical/infisical) to your own GitHub account and then [clone](https://docs.github.com/en/repositories/creating-and-managing-repositories/cloning-a-repository) it to your local device.

Once, you've done that, create a new branch:

```console  theme={"dark"}
git checkout -b MY_BRANCH_NAME
```

## Set up environment variables

Start by creating a `.env` file at the root of the Infisical directory then copy the contents of the file linked [here](https://github.com/Infisical/infisical/blob/main/.env.example). View all available [environment variables](https://infisical.com/docs/self-hosting/configuration/envars) and guidance for each.

## Starting Infisical for development

We use Docker to spin up all required services for Infisical in local development. If you are unfamiliar with Docker, dont worry, all you have to do is install Docker for your
machine and run the command below to start up the development server.

#### Start local server

```bash  theme={"dark"}
docker compose -f docker-compose.dev.yml up --build --force-recreate
```

#### Access local server

Once all the services have spun up, browse to [http://localhost:8080](http://localhost:8080).

#### Shutdown local server

```bash  theme={"dark"}
# To stop environment use Control+C (on Mac) CTRL+C (on Win) or
docker compose -f docker-compose.dev.yml down
```

## Starting Infisical docs locally

We use [Mintlify](https://mintlify.com/) for our docs.

#### Install Mint CLI.

```bash  theme={"dark"}
npm i -g mint
```

or

```bash  theme={"dark"}
yarn global add mint
```

#### Running the docs

Go to `docs` directory and run `mint dev`. This will start up the docs on `localhost:3000`

```bash  theme={"dark"}
# From the root directory
cd docs; mint dev;
```


# Audit Logs
Source: https://infisical.com/docs/documentation/getting-started/concepts/audit-logs

Understand how Infisical logs activity and supports external audit streaming.

Infisical records a detailed audit trail of actions across the platform  providing deep visibility into access, changes, and usage for security and compliance purposes.

Every interaction with Infisical resources generates an audit event. These events are immutable and include metadata such as the actor, event type, affected resources, timestamp, IP address, and client source.

Audit logs enable teams to:

* Monitor access and changes to secrets, certificates, and infrastructure.
* Investigate incidents with full context around who did what, when, and how.
* Meet compliance and governance requirements with structured activity records.

To learn more, refer to the [audit logs documentation](/documentation/platform/audit-logs).

## Log Coverage

Infisical tracks dozens of event types across the platform  including secret access, permission changes, certificate issuance, SSH session activity, and identity management.

Each audit entry includes structured fields that make it easy to search, filter, and correlate across systems. For example:

* Event Type: Action that occurred (e.g., `create-secret`, `issue-ssh-cert`).
* Actor: Who performed the action (user or machine identity).
* Resource: What was affected (e.g., project, secret, certificate).
* Context: IP address, user agent, permissions, and more.

## External Log Streaming

For centralized monitoring and long-term retention, Infisical supports [audit log streaming](/documentation/platform/audit-log-streams/audit-log-streams) to external systems.

You can forward logs to SIEM platforms, storage buckets, or observability stacks using JSON-based collectors. Infisical integrates well with tools like [Fluent Bit](/documentation/platform/audit-log-streams/audit-log-streams-with-fluentbit#deploy-fluent-bit), enabling teams to route logs to destinations such as:

* AWS S3
* Elasticsearch
* Splunk
* Datadog
* Cloud-native log pipelines


# Client Ecosystem
Source: https://infisical.com/docs/documentation/getting-started/concepts/client-integrations

Get an overview of the CLI, SDKs, agents, APIs, and integrations that interact with Infisical.

Infisical provides a flexible interface for integrating into development workflows and infrastructure. Around it is a rich ecosystem of clients and integrations that allow users and systems to interact with Infisical across any environment.

These clients enable access to secrets, certificates, and other resources from wherever theyre neededwhether thats a developers terminal, a CI/CD pipeline, or a running Kubernetes workload.

## Available Clients and Interfaces

Infisical offers a non-exhaustive set of clients and interfaces to support a wide range of use cases:

* [CLI](/cli/overview): A powerful command-line interface for developers and operators to interact with Infisical from local or automated environments. Commonly used for secret access, SSH credential issuance, and more.

* [SDKs](/sdks/overview): Official client libraries for languages like Go, Node.js, and Python make it easy to integrate Infisical directly into applications and internal tooling.

* [HTTP API](/api-reference/overview/introduction): A fully documented RESTful API powers all core functionality and enables advanced or custom integrations.

* [Agents](/integrations/platforms/infisical-agent): Lightweight background processes that can fetch and sync secrets or credentials into local environments, containers, or file systems.

* [Kubernetes Operator](/integrations/platforms/kubernetes/overview): A native controller that syncs Infisical secrets into Kubernetes as native Secrets, and supports secure workload integration.

* [External Secrets Operator (ESO)](https://external-secrets.io/latest/provider/infisical): Allows Infisical to act as a backend provider for syncing secrets into Kubernetes `Secret` objects using the widely adopted External Secrets Operator.

* [Kubernetes PKI Issuer](/documentation/platform/pki/pki-issuer): A controller that issues X.509 certificates from Infisical PKI using the cert-manager Issuer and Certificate CRDs.

* [Secret Syncs](/integrations/secret-syncs/overview): Native integrations to forward secrets to services like GitHub, GitLab, AWS Secrets Manager, Vercel, and more.

This modular ecosystem lets teams use Infisical alongside their existing stackwithout requiring opinionated workflows or lock-in.


# Using Infisical: Cloud or Self-Hosted
Source: https://infisical.com/docs/documentation/getting-started/concepts/deployment-models

Choose between Infisical Cloud or a self-managed deployment

Infisical can be used in two ways: via [Infisical Cloud](https://app.infisical.com), a managed offering, or through a self-hosted deployment within your own infrastructure.

Both options provide the same core platform capabilities. The decision depends on your operational model, trust boundaries, and compliance requirements. While Infisical Cloud comes with built-in security and operational guarantees, a self-hosted deployment gives you full controlbut also full responsibility for securing and maintaining the system.

## Infisical Cloud

Infisical Cloud is our managed service found at [app.infisical.com](https://app.infisical.com). It includes automated updates, availability guarantees, and secure infrastructure operations.

For most teams, Infisical Cloud is the recommended way to get started. It simplifies adoption by removing the need to manage deployment, scaling, or maintenance internally.

Use this if:

* You prefer not to operate infrastructure or handle upgrades
* You require a secure, production-grade hosted service
* You want to adopt Infisical with minimal operational overhead

<Info>
  <p>
    By default, Infisical Cloud is a secure, multi-tenant service. For
    enterprises with stricter isolation or regulatory needs, dedicated cloud
    instances are available.
  </p>

  <p>Contact [sales@infisical.com](mailto:sales@infisical.com) to learn more.</p>
</Info>

## Self-Hosted Infisical

Infisical can also be deployed and managed within your own infrastructure. This approach provides full control over platform configuration, data storage, and operational security. In this model, your team is responsible for maintaining uptime, monitoring, patching, and integrations.

Use this if:

* You require complete control over data, deployment, and security posture
* Your compliance model mandates self-managed or on-premise systems
* You need to tightly integrate with internal tooling and infrastructure

Infisical supports multiple deployment methods, including [Docker](/self-hosting/deployment-options/standalone-infisical), [Docker Compose](/self-hosting/deployment-options/docker-compose), [Kubernetes](/self-hosting/deployment-options/kubernetes-helm), and [Linux package](/self-hosting/deployment-options/native/linux-package/installation).

To learn more, refer to the [self-hosting documentation](/self-hosting/overview).

<Info>
  <p>
    The open-source core is available under the MIT license. Additional
    enterprise features and support are available with a commercial license.
  </p>

  <p>Contact [sales@infisical.com](mailto:sales@infisical.com) to learn more.</p>
</Info>


# Platform Hierarchy
Source: https://infisical.com/docs/documentation/getting-started/concepts/platform-hierarchy

Understand how organizations and projects are structured in Infisical.

Infisical is structured around organizations and projects, allowing teams to manage multiple products, access scopes, and use cases within a single account while keeping boundaries and responsibilities clearly defined.

## Organizations

An [organization](/documentation/platform/organization) typically represents a company or high-level entity (e.g. Acme Corp). It acts as the umbrella for all projects, members, and billing settings.

[Users](/documentation/platform/identities/user-identities) are invited to an organization and assigned [organization-level roles](/documentation/platform/access-controls/role-based-access-controls#organization-level-access-controls) that determine what they can managesuch as members, machine identities, and billing details.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/organization/organization.png" alt="organization" />

## Projects

A [project](/documentation/platform/project) belongs to an organization and defines a specific scope of work. Each project has a product type such as Secrets Management, SSH, or PKI that determines what features are available in that project.

For example:

* A Secrets Management project manages application secrets across environments.

* An SSH project enables certificate-based access to infrastructure.

* A PKI project manages certificate authorities and X.509 certificate workflows.

Users are added to a project and assigned [project-level roles](/documentation/platform/access-controls/role-based-access-controls#project-level-access-controls) that determine what they can managesuch as secrets, access policies, or certificate authorities. A user can have different roles across projects, allowing for flexible and fine-grained access control that reflects how teams operate in practice.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/organization/organization-projects.png" alt="organization projects" />

## Key Characteristics

* Projects are isolated in terms of configuration, permissions, and product workflows.

* Access is managed independently at both the organization and project level.

* All projects within an organization share the same billing and user directory.

Teams can adopt Infisical incrementallystarting with one product and expanding as needed.


# Platform Identity and Access Management
Source: https://infisical.com/docs/documentation/getting-started/concepts/platform-iam

Understand how users, machine identities, roles, and permissions are managed.

Infisical uses identity-based access control to govern how users and systems interact with secrets, certificates, infrastructure, and other resources on the platform.

There are two types of identities:

* [User identities](/documentation/platform/identities/user-identities): Represent individuals such as developers or administrators that typically access the platform via browser.

* [Machine identities](/documentation/platform/identities/machine-identities): Represent systems such as CI pipelines or applications that programmatically interact with the platform.

Each identity is granted access based on its assigned roles and permissions and must authenticate with the platform in order to access any resources.

To learn more, refer to the [identities documentation](/documentation/platform/identities/overview).

## Roles and Access

Infisical provides a robust and flexible access control system. The primary authorization mechanism is [role-based access control (RBAC)](/documentation/platform/access-controls/role-based-access-controls), where identities are assigned roles at two access control levels:

* [Organization-level access control](/documentation/platform/access-controls/role-based-access-controls#organization-level-access-controls): Control billing, member management, and platform-wide settings

* [Project-level access control](/documentation/platform/access-controls/role-based-access-controls#project-level-access-controls): Control access to specific product resources like secrets, SSH hosts, or certificates

Beyond RBAC, Infisical also supports additional project-level permissioning features, [including attribute-based access control (ABAC)](/documentation/platform/access-controls/abac/overview), [temporary access grants](/documentation/platform/access-controls/temporary-access), and [additional privileges](/documentation/platform/access-controls/additional-privileges) for select project types.

To learn more, refer to the [access control documentation](/documentation/platform/access-controls/overview).


# What is Infisical?
Source: https://infisical.com/docs/documentation/getting-started/introduction

The open source platform for managing secrets, certificates, and secure infrastructure access.

## What is Infisical?

[Infisical](https://infisical.com) is the [open source](https://github.com/Infisical/infisical), all-in-one platform for secrets, certificates, and privileged access management.

It provides modern security workflows  including secrets rotation, dynamic credentials, access approvals, and SSH certificate-based access  all within one platform designed for developers, infrastructure, and security teams.

Start managing secrets securely with [Infisical Cloud](https://app.infisical.com) or learn how to [host Infisical](/self-hosting/overview) yourself.

## Why use Infisical?

Managing secrets, credentials, and infrastructure access is a critical concern for engineering teams. As infrastructure scales and environments become more complex, [secrets start to sprawl](https://infisical.com/blog/what-is-secret-sprawl)  across codebases, CI/CD pipelines, configuration files, and cloud services. This makes them difficult to track, rotate, and secure.

Without proper management, secret sprawl turns into risk: hardcoded credentials, unrotated keys, fragmented access controls that attackers can exploit amongst other things.

Infisical addresses this challenge by providing an all-in-one platform and workflows to:

* Securely store and manage application secrets from development to production.
* Scan code and pipelines for exposed credentials.
* Automate X.509 certificate issuance and renewal.
* Manage SSH access using short-lived, policy-driven certificates.
* Encrypt and decrypt sensitive data with centralized key control.
* Audit every access, credential use, and change.

Infisical is designed to integrate cleanly into your stackimproving security without adding complexity.

## What does Infisical include?

Infisical consists of several tightly integrated products, each designed to solve a specific part of the infrastructure security surface:

* [Secrets Management](/documentation/platform/secrets-mgmt/overview): Securely store, access, and distribute secrets across environments with fine-grained controls, automatic rotation, and audit logging.
* [Secrets Scanning](/documentation/platform/secret-scanning/overview): Detect hardcoded secrets in code, CI pipelines, and infrastructureintegrated with GitHub, GitLab, Bitbucket, and more.
* [Certificate Management](/documentation/platform/pki/overview): Issue and manage X.509 certificates using protocols like EST, with support for internal and external CAs.
* [Infisical SSH](/documentation/platform/ssh/overview): Provide short-lived SSH access to servers using certificate-based authentication, replacing static keys with policy-driven, time-bound control.
* [Infisical KMS](/documentation/platform/kms/overview): Encrypt and decrypt data using centrally managed keys with enforced access policies and full audit visibility.
* [Infisical PAM](/documentation/platform/pam/overview): Manage access to resources like databases, servers, and accounts with policy-based controls and approvals.


# Overview
Source: https://infisical.com/docs/documentation/getting-started/overview

The open source platform for managing secrets, certificates, and secure infrastructure access.

<Card title="What is Infisical?" href="/documentation/getting-started/introduction">
  Learn what Infisical is and how it can help you manage secrets, certificates,
  and secure access across your infrastructure.
</Card>

## Products

<Columns cols="2">
  <Card title="Secrets Management" href="/documentation/platform/secrets-mgmt/overview">
    Securely store, manage, and control access to sensitive application secrets across your environments.
  </Card>

  <Card title="Secrets Scanning" href="/documentation/platform/secret-scanning/overview">
    Automatically detect and alert on hardcoded secrets in source code, CI pipelines, and infrastructure.
  </Card>

  <Card title="Certificate Management" href="/documentation/platform/pki/overview">
    Automate CA and X.509 certificate lifecycle management across your infrastructure.
  </Card>

  <Card title="Infisical SSH" href="/documentation/platform/ssh/overview">
    Replace static SSH keys with short-lived SSH certificates to simplify access and improve security.
  </Card>

  <Card title="Infisical PAM" href="/documentation/platform/pam/overview">
    Manage access to resources like databases, servers, and accounts with policy-based controls and approvals.
  </Card>

  <Card title="Infisical KMS" href="/documentation/platform/kms/overview">
    Encrypt and decrypt sensitive data using a centralized key management system.
  </Card>
</Columns>

## Resources

<Columns cols="2">
  <Card title="CLI Reference" href="/cli/overview">
    Explore Infisicals command-line interface for managing secrets,
    certificates, and system operations via terminal.
  </Card>

  <Card title="API Reference" href="/api-reference/overview/introduction">
    Browse Infisicals API documentation to programmatically interact with
    secrets, access controls, and certificate workflows.
  </Card>
</Columns>

<Columns cols="1">
  <Card title="Self-Hosting" href="/self-hosting/overview">
    Learn how to deploy and operate Infisical on your own infrastructure with
    full control and data ownership.
  </Card>
</Columns>


# Introduction
Source: https://infisical.com/docs/documentation/guides/introduction



Whether you're running a Node application on Heroku, Next.js application with Vercel, or Kubernetes on AWS, Infisical has a secret management strategy from local development to production ready for you.

## Guides by Language

<CardGroup cols={2}>
  <Card title="Node" href="/documentation/guides/node" icon="node" color="#3c8639">
    Manage secrets across your Node stack
  </Card>

  <Card href="/documentation/guides/python" title="Python" icon="python" color="#3775a9">
    Manage secrets across your Python stack
  </Card>
</CardGroup>

## Guides by Stack

<CardGroup cols={2}>
  <Card title="Next.js + Vercel" href="/documentation/guides/nextjs-vercel" icon="cloud" color="#3c8639">
    Manage secrets for your Next.js + Vercel stack
  </Card>
</CardGroup>

Want a guide? [Throw in a request](https://github.com/Infisical/infisical/issues).


# Managing Secrets With Kubernetes Operator
Source: https://infisical.com/docs/documentation/guides/kubernetes-operator

How to use the Infisical Kubernetes Operator to Push Secrets, Pull Secrets, and Generate Dynamic Secrets within your clusters.

Infisical's Kubernetes Operator provides a seamless, secure, and automated way to synchronize secrets between your Infisical instance and your Kubernetes clusters. The Operator's three Custom Resource Definitions (CRDs) make this possible. In this guide, we provide the necessary CRDs and configurations for your kubernetes cluster, but you can customize them to fit your use-case.

In this guide, we'll walk through how to:

1. **Install the Infisical Operator on your Kubernetes cluster**.
2. **Configure Authentication using Kubernetes Service Accounts**.
3. **Use Each of the three CRDs**.
   * **InfisicalSecret** \[Sync secrets from Infisical to Kubernetes]
   * **InfisicalPushSecret** \[Sync secrets from Kubernetes to Infisical]
   * **InfisicalDynamicSecret** \[Manage Dynamic Secrets and automatically create time-bound leases]

## Prerequisites

Before we begin, make sure your environment is ready

1. Installed tools
   * [helm](https://helm.sh/docs/intro/install/), [git](https://git-scm.com/downloads), [kubectl](https://kubernetes.io/docs/tasks/tools/)
2. Kubernetes Cluster
   * Ensure you have access to a running cluster and connect with kubectl
3. PostgreSQL Cluster (for InfisicalDynamicSecret)
   * Ensure you have a running database that you have access to
4. Clone [infisical-guides-source-code](https://github.com/Infisical/infisical-guides-source-code) repository
5. Access to an Infisical instance (cloud or self-hosted)

## Step-By-Step Guide

<Steps titleSize="h2">
  <Step title="Install the Infisical Operator">
    The [Infisical Operator](https://infisical.com/docs/integrations/platforms/kubernetes/overview) runs inside your cluster and is responsible for handling secret synchronization events.

    ```console  theme={"dark"}
    helm repo add infisical-helm-charts 'https://dl.cloudsmith.io/public/infisical/helm-charts/helm/charts/'
    helm repo update
    helm install infisical-operator infisical-helm-charts/secrets-operator
    ```

    Verify the operator pod is running:

    ```console  theme={"dark"}
    kubectl get pods -n default
    ```
  </Step>

  <Step title="Create a Machine Identity and Set Up a Project">
    The operator uses a [Machine Identity](https://infisical.com/docs/documentation/platform/identities/machine-identities) to authenticate with Infisical through the Kubernetes Auth Method

    1. Login to [Infisical](https://app.infisical.com/)
    2. Select **Organization Access** from the left navigational pane
    3. Create an Identity and give it a name and a role
    4. Once the Machine Identity is created, copy the **Identity ID** (will be used later)
    5. Select the created Machine Identity, and add a [Kubernetes Authentication Method](https://infisical.com/docs/documentation/platform/identities/kubernetes-auth). Use these configurations:
       * **Allowed Service Account Names**: infisical-service-account, default
       * **Allowed Namespaces**: default
       * **Kubernetes Host URL** can be found by running `kubectl cluster-info`
       * **Token Reviewer JWT / CA Certificate**: We will be generating these two later and adding them in later, leave it blank for now
    6. Once the Machine Identity has been created, navigate back to **Overview**
    7. Now select **Add New Project**
       * Add a **Project Name**, and select **Secrets Management** as the product type
       * Add a description (Optional).
    8. Once the Project is created, navigate into the Project to **Add Secrets**. You can add any key-value pair for this example, however if you want to use the InfisicalSecret CRD example provided in this demo, use the following configurations:
       * **Key**: SMTP\_HOST
       * **Value**: [smtp@gmail.com](mailto:smtp@gmail.com)
       * **Tags**: N/A (Not needed for this demonstration)
       * **Environments**: Production
    9. Now lets navigate to the **Project Access** tab on the left hand navigation pane.
       * Add the machine identity we created, and give it Admin permissions (just for demonstration purposes)
  </Step>

  <Step title="Set Up RBAC, Service Accounts, and Create Tokens">
    Now we will be interacting with the local repository you cloned earlier. Make sure you are in the directory that contains the yaml configurations. Assuming you are in your root user directory:

    ```console  theme={"dark"}
    cd infisical-guides-source-code/kubernetes-operator-demo
    ```

    1. Create the `infisical-token-reviewer` service account. This Manifest creates a **service account** that the Infisical Operator uses to authenticate with Kubernetes for token reviews. It allows Infisical to validate Kubernetes tokens securely during the Machine Identity authentication process.

    ```console  theme={"dark"}
    kubectl apply -f infisical-reviewer-service-account.yaml
    ```

    2. Create the token for the reviewer service account. This Yaml defines a **service account token secret** linked to the reviewer account created above. It generates a JWT token that Infisical uses for the Kubernetes Auth Method in your Machine Identity configuration.

    ```console  theme={"dark"}
    kubectl apply -f service-account-reviewer-token.yaml
    ```

    3. This file binds the `infisical-token-reviewer` service account to the built-in `system:auth-delegator` ClusterRole. That role allows the service account to perform **token review** and **authentication delegation** requests on behalf of other service accounts - a key part of Kubernetes-based identity verification. Without this binding, the Infisical Operator wouldn't have permission to validate tokens.

    ```console  theme={"dark"}
    kubectl apply -f cluster-role-binding.yaml
    ```

    4. Create the service account that will be used by the InfisicalSecret. This file creates a **dedicated service account** `infisical-service-account` that the Infisical Operator uses to access and sync secrets within your cluster. It operates as the Operator's working identity in your cluster, separate from the token reviewer.

    ```console  theme={"dark"}
    kubectl apply -f infisical-service-account.yaml
    ```

    5. Create the token for the Infisical service account. This manifest defines a **token secret** for the `infisical-service-account`. It allows the Infisical operator to authenticate against Infisical's API when syncing secrets. The token will then be manually patched and associated with the service account to make sure Kubernetes mains it persistently.

    ```console  theme={"dark"}
    kubectl apply -f infisical-service-account-token.yaml
    ```

    6. Apply the patch to manually associate the token secret

    ```console  theme={"dark"}
    kubectl patch serviceaccount infisical-service-account -p '{"secrets": [{"name": "infisical-service-account-token"}]}' -n default
    ```

    7. Create the **JWT Token** and **Certificate** and add it to the **Machine Identity** we created under **Kubernetes Auth**. For the generated CA, navigate to the **Advanced** tab to paste the certificate:

    * JWT Command

    ```console  theme={"dark"}
    kubectl get secret infisical-token-reviewer-token -n default -o jsonpath='{.data.token}' | base64 -d
    ```

    * CA Command

    ```console  theme={"dark"}
    kubectl get secret infisical-token-reviewer-token -n default -o jsonpath='{.data.ca\.crt}' | base64 -d
    ```
  </Step>

  <Step title="Verify Service Accounts and Tokens">
    1. Check to see if the service accounts were created

    ```console  theme={"dark"}
    kubectl get serviceaccount -n default | grep infisical
    ```

    2. Verify the tokens were created and linked

    ```console  theme={"dark"}
    kubectl get secrets -n default | grep infisical
    ```
  </Step>

  <Step title="Create the InfisicalSecret CRD">
    The [InfisicalSecret](https://infisical.com/docs/integrations/platforms/kubernetes/infisical-secret-crd) CRD tells the operator to sync secrets from Infisical to Kubernetes. By referencing your `identityID`, `projectSlug`, and `envSlug`, this CRD tells the Infisical Operator which Infisical secrets to fetch and how to format them into a Kubernetes Secret. Make sure to edit the provided CRD to match your specific Machine Identity ID, Project ID, and which environment your secrets are being pulled from (default is prod).

    * **Project Slug**: Can be found when you select your project and navigate to settings
    * **Identity ID**: Can be found when you select your machine identity from your organization's access control

    1. After editing the `example-infisical-secret-crd.yaml` to contain your demo-specific values, apply the yaml in your cluster

    ```console  theme={"dark"}
    kubectl apply -f example-infisical-secret-crd.yaml
    ```
  </Step>

  <Step title="Verify the InfisicalSecret Status">
    1. Check that the `InfisicalSecret` was created successfully

    ```console  theme={"dark"}
    kubectl get infisicalsecret -n default
    ```

    2. Check that the operator created the `managed-secret`

    ```console  theme={"dark"}
    kubectl get secret managed-secret -n default
    ```

    3. View the secret contents (base64 encoded)

    ```console  theme={"dark"}
    kubectl get secret managed-secret -n default -o jsonpath='{.data}' | jq
    ```
  </Step>

  <Step title="Deploy the Demo Application">
    1. Deploy the nginx demo deployment that will use the managed secret.

    ```console  theme={"dark"}
    kubectl apply -f demo-deployment.yaml
    ```

    2. Wait 15-20 seconds and then verify the deployments

    ```console  theme={"dark"}
    kubectl get deployments
    kubectl get pods -l app=nginx
    ```
  </Step>

  <Step title="Verify the Secret is Injected Into the Pod">
    1. Check that the environment variable is in the running pod. If everything was successful, at this point you should be able to see the secret populate in the kubernetes pod and have a successful **sync** from Infisical to Kubernetes.

    ```console  theme={"dark"}
    kubectl exec -it $(kubectl get pod -l app=nginx -o jsonpath='{.items[0].metadata.name}') -- env | grep SMTP
    ```
  </Step>

  <Step title="Create a Kubernetes Secret to Push Up to Infisical">
    Now that we have successfully synced secrets from Infisical to Kubernetes, lets explore how we can push **Kubernetes Secrets** to Infisical.

    1. Either create a **Kubernetes Secret** via yaml, or use the one in the repository.

    ```console  theme={"dark"}
    kubectl apply -f source-secret.yaml
    ```

    2. Verify creation of the secret

    ```console  theme={"dark"}
    kubectl get secret push-secret-demo -n default -o yaml
    ```
  </Step>

  <Step title="Create the InfisicalPushSecret CRD">
    The [InfisicalPushSecret](https://infisical.com/docs/integrations/platforms/kubernetes/infisical-push-secret-crd) CRD tells the operator to sync secrets from Kubernetes to Infisical. Make sure you edit the CRD to include the specific **Project Slug**, and **Identity ID**. The other values present in `example-push-secret.yaml` should be configured based on the previously committed yaml configurations.

    1. Apply the InfisicalPushSecret CRD provided after making the necessary changes

    ```console  theme={"dark"}
    kubectl apply -f example-push-secret-crd.yaml
    ```

    2. Once your CRD has been configured, go back to your project within Infisical and check to see if your secrets have populated there.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/push-secret.png" alt="secrets dashboard" />
  </Step>

  <Step title="Create the InfisicalDynamicSecret CRD">
    The [InfisicalDynamicSecret](https://infisical.com/docs/integrations/platforms/kubernetes/infisical-dynamic-secret-crd) CRD allows you to sync dynamic secrets and create leases automatically in Kubernetes as native **Kubernetes Secret** resources Any Pod, Deployment, or other Kubernetes resource can make use of dynamic secrets from Infisical just like any other Kubernetes secret.

    1. Navigate to your Infisical **Project** and click on the dropdown next to **Add Secret**. From here you will select **Add Dynamic Secret**
       * Select **SQL Database** as the service you would like to connect to.
       * Select **PostegreSQL** as the database service. Enter in the connection details for your database, specifically the **Host**, **Port**, **User**, **Password**, and **Database Name**.
       * For the **Secret Name**, if you want to use the same name as the one in the cloned **InfisicalDynamicSecret** CRD, use the name **dynamic-secret-lease**. Otherwise you will need to change the **dynamicSecret.secretName** config in the InfisicalDynamicSecret CRD to whatever you name the secret here.
       * In the CA (SSL) section, make sure to upload the **CA Certificate** for your database.
       * Finally, select **Prod** as the environment (we are keeping this configuration as part of the demonstration).

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/dynamic-secret.png" alt="secrets dashboard dynamic" />

    2. Edit the `dynamic-secret-crd` with the proper machine **Identity ID**, **Project Slug**, **dynamicSecret.secretName** (same as the **Secret Name** you gave to the dynamic secret in Infisical), and managedSecretReference.secretName (name of the kubernetes secret that Infisical Operator will create/populate in the cluster).
       * If you want to keep the **managedSecretReference.secretName** then you can leave it as **dynamic-secret-test**

    3. Once the changes have been saved, apply the yaml:

    ```console  theme={"dark"}
    kubectl apply -f dynamic-secret-crd.yaml
    ```

    4. After applying the CRD, you should notice that the dynamic secret lease has been created and synced with your cluster. Verify by running:

    ```console  theme={"dark"}
    kubectl get secret dynamic-secret-test -n default -o yaml
    ```

    5. Once the dynamic secret lease has been created, you should see that the secret has data that contains the lease credentials.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/dynamic-secret-crd.png" alt="dynamic secrets output" />
  </Step>
</Steps>

**Congratulations! You successfully managed secrets with Kubernetes.**


# Secret Management in Development Environments
Source: https://infisical.com/docs/documentation/guides/local-development

Learn how to manage secrets in local development environments.

## Problem at hand

There are a number of issues that arise with secret management in local development environment:

1. **Getting secrets onto local machines**. When new developers join or a new project is created, the process of getting the development set of secrets onto local machines is often unclear. As a result, developers end up spending a lot of time onboarding and risk potentially following insecure practices when sharing secrets from one developer to another.
2. **Syncing secrets with teammates**. One of the problems with .env files is that they become unsynced when one of the developers updates a secret or configuration. Even if the rest of the team is notified, developers don't make all the right changes immediately, and later on end up spending a lot of time debugging an issue due to missing environment variables. This leads to a lot of inefficiencies and lost time.
3. **Accidentally leaking secrets**. When developing locally, it's common for developers to accidentally leak a hardcoded secret as part of a commit. As soon as the secret is part of the git history, it becomes hard to get it removed and create a security vulnerability.

## Solution

One of the main benefits of Infisical is the facilitation of secret management workflows in local development use cases. In particular, Infisical heavily follows the "Security Shift Left" principle to enable developers to effortlessly follow secure practices when coding.

### CLI

[Infisical CLI](/cli/overview) is the most frequently used Infisical tool for secret management in local development environments. It makes it easy to inject secrets right into the local application environments based on the permissions given to corresponding developers.

### Dashboard

On top of that, Infisical provides a great [Web Dashboard](https://app.infisical.com/signup) that can be used to making quick secret updates.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/dashboard.png" alt="project dashboard" />

### Personal Overrides

By default, all the secrets in the Infisical environments are shared among project members who have the permission to access those environment. At the same time, when doing local development, it is often desirable to change the value of a certain secret only for a particular self. For such use cases, Infisical supports the functionality of **Personal Overrides**  which allow developers to override values of any secrets without affecting the workflows of the rest of the team. Personal Overrides can be created both in the dashboard or via [Infisical CLI](/cli/overview).

### Secret Scanning

In addition, Infisical also provides a set of tools to automatically prevent secret leaks to git history. This functionality can be set up on the level of [Infisical CLI using pre-commit hooks](/cli/scanning-overview#automatically-scan-changes-before-you-commit) or through a direct integration with platforms like GitHub.


# Microsoft Power Apps
Source: https://infisical.com/docs/documentation/guides/microsoft-power-apps

Learn how to manage secrets in Microsoft Power Apps with Infisical.

In recent years, there has been a shift towards so-called low-code and no-code platforms. These platforms are particularly appealing to businesses without internal development capabilities, yet teams often discover that some coding is necessary to fully satisfy their business needs.

Low-code platforms have become increasingly sophisticated and useful, leading to a rise in their adoption by businesses. A prime example is Microsoft Power Apps, which offers a range of data sources and service integrations right out of the box. However, even with advanced tools, you might not always find a ready-made solution for every challenge. This means that low-code doesn't equate to no-code, as some coding and customization are still required to cater to specific needs.

Consider the need for data integrations where an HTTP-based call to a web service might be necessary, typically requiring authentication through an API key or another type of secret.

Importantly, it's crucial to avoid hardcoding these secrets, as they would then be accessible to anyone with collaboration rights to the code. This underscores the importance of using a secret management solution like Infisical.

In this article, we'll demonstrate how to retrieve app secrets from Infisical for use in a Power Apps application. We'll create a simple application with a dedicated data connector to illustrate the ease of integrating Infisical with Power Apps. This tutorial assumes some prior programming experience in C#.

Prerequisites:

* Created Microsoft Power App.

<Steps>
  <Step title="Integrate an Azure Function Call">
    First, lets create a new Azure Function using the Azure Management Portal. Get the [Function App](https://azuremarketplace.microsoft.com/en-us/marketplace/apps/Microsoft.FunctionApp?tab=Overview) from the [Azure Marketplace](https://azuremarketplace.microsoft.com/en-us/).
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/guides/microsoft-power-apps/function-app.png" alt="function app" />

    Place it in a subscription using any resource group. The name of the function is arbitrary. We'll use .NET as a runtime stack, but you can use whatever you're most comfortable with. The OS choice is also up to you. While Linux may look like a lightweight solution, Windows actually has more Azure Functions support. For instance, you cannot edit a Linux-based Azure Function within the Azure management portal.

    By using a consumption plan, we'll only pay for the resources we use when they are requested. This is the classic serverless approach, where you do not pay for running servers, only for interactivity.

    Once the new Azure Functions instance is ready, we add a function. In this case, we can do that already from the Azure Management Portal. Use the HTTP trigger template and choose the function authorization level.

    The code for the first function can be as simple as:

    ```
    using System.Net;

    public static async Task<HttpResponseMessage> Run(HttpRequestMessage req, TraceWriter log)
    {
        log.Info("C# HTTP trigger function processed a request.");
        return req.CreateResponse(HttpStatusCode.OK, "Hello World");
    }
    ```

    <Note>
      The code above is written for the older runtime. As a result, you may need to change the runtime version to 1 for the Azure Power Apps integration to work. If we start at a newer version (for example, 3) this triggers a warning before the migration.
    </Note>

    Finally, we also need to publish the Swagger (or API) definitions and enable cross-origin resource sharing (CORS). While the API definitions are rather easy to set up, the correct CORS value may be tricky. For now, we can use the wildcard option to allow all hosts.
  </Step>

  <Step title="Create Custom Connector">
    Once we set all this up, its time to create the custom connector.

    You can create the custom connector via the data pane. When we use Create from Azure Service (Preview), this yields a dialog similar to the following:

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/guides/microsoft-power-apps/custom-connector.png" alt="custom-connector" />

    We can now fill out the fields using the information for our created function. The combination boxes are automatically filled in order. Once we select one of the reachable subscriptions (tied to the same account weve used to log in to create a Power App), the available services are displayed. Once we select our Azure Functions service, we select the function for retrieving the secret.
  </Step>

  <Step title="Set Up Infisical in an Azure Function">
    You can add Infisical in an Azure Function quite easily using the [Infisical SDK for .NET](https://infisical.com/docs/sdks/languages/csharp) (or other languages). This enables the function to communicate with Infisical to obtain secrets, among other things.

    In short, we can simply bring all the necessary classes over and start using the Client class. Essentially, this enables us to write code like this:

    ```
    var settings = new ClientSettings
    {
        ClientId = "CLIENT_ID",
        ClientSecret = "CLIENT_SECRET",
        // SiteUrl = "http://localhost:8080", <-- This line can be omitted if you're using Infisical Cloud.
    };
    var infisical = new InfisicalClient(settings);

    var options = new GetSecretOptions
    {
        SecretName = "TEST",
        ProjectId = "PROJECT_ID",
        Environment = "dev",
    };
    var secret = infisical.GetSecret(options);
    ```

    Knowing the URL of Infisical as well as the Client Id and Client Secret, we can now access the desired values.

    Now its time to actually use the secret within a Power App. There are two ways to request a desired target service with a secret retrieved from the function:

    1. Call the function first, retrieve the secret, then call the target service, for example, via another custom connector with the secret as input.

    2. Perform the final API request within the function call  not returning a secret at all, just the response from invoking the target service.

    While the first option is more flexible (and presumably cheaper!), the second option is definitely easier. In the end, you should mostly decide based on whether the function should be reused for other purposes. If the single Power App is the only consumer of the function, it may make more sense to go with the second option. Otherwise, you should use the first option.

    For our simple example, we dont need to reuse the function. We also dont want the additional complexity of maintaining two different custom connectors, where we only use one to pass data to the other one.

    Based on the previous snippet, we create the following code (for proxying a GET request from an API accessible via the URL specified in the apiEndpoint variable).

    ```
    using (var client = new HttpClient())
    {
        client.DefaultRequestHeaders
            .Accept
            .Add(new MediaTypeWithQualityHeaderValue("application/json"));

        client.DefaultRequestHeaders.Add("X-API-KEY", secret);

        var result = await client.GetAsync(apiEndpoint);
        var resultContent = await result.Content.ReadAsStringAsync();
        req.CreateResponse(HttpStatusCode.OK, resultContent);
    }
    ```

    This creates a request to the resource protected by an API key that is retrieved from Infisical.
  </Step>
</Steps>


# Next.js + Vercel
Source: https://infisical.com/docs/documentation/guides/nextjs-vercel



This guide demonstrates how to use Infisical to manage secrets for your Next.js + Vercel stack from local development to production. It uses:

* Infisical (you can use [Infisical Cloud](https://app.infisical.com) or a [self-hosted instance of Infisical](https://infisical.com/docs/self-hosting/overview)) to store your secrets.

## Project Setup

To begin, we need to set up a project in Infisical and add secrets to an environment in it.

### Create a project

1. Create a new project in [Infisical](https://app.infisical.com/).

2. Add a secret to the development environment of this project so we can pull it back for local development. In the **Secrets Overview** page, press **Explore Development** and add a secret with the key `NEXT_PUBLIC_NAME` and value `YOUR_NAME`.

3. Add a secret to the production environment of this project so we can sync it to Vercel. Switch to the **Production** environment and add a secret with the key `NEXT_PUBLIC_NAME` and value `ANOTHER_NAME`.

## Create a Next.js app

Initialize a new Node.js app.

We can use `create-next-app` to initialize an app called `infisical-nextjs`.

<Tabs>
  <Tab title="JavaScript">
    ```console  theme={"dark"}
    npx create-next-app@latest --use-npm infisical-nextjs
    cd infisical-nextjs
    ```
  </Tab>

  <Tab title="TypeScript">
    ```console  theme={"dark"}
    npx create-next-app@latest --ts --use-npm infisical-nextjs
    cd infisical-nextjs
    ```
  </Tab>
</Tabs>

Next, inside `pages/_app.js`, lets add a `console.log()` to print out the environment variable in the browser console.

<Tabs>
  <Tab title="JavaScript">
    ```js  theme={"dark"}
    import '@/styles/globals.css'

    export default function App({ Component, pageProps }) {
        console.log('Hello, ', process.env.NEXT_PUBLIC_NAME);
        return <Component {...pageProps} />
    }
    ```
  </Tab>

  <Tab title="TypeScript">
    ```tsx  theme={"dark"}
    import '@/styles/globals.css'
    import type { AppProps } from 'next/app'

    export default function App({ Component, pageProps }: AppProps) {
        console.log('Hello, ', process.env.NEXT_PUBLIC_NAME);
        return <Component {...pageProps} />
    }
    ```
  </Tab>
</Tabs>

## Infisical CLI for local development environment variables

We'll now use the Infisical CLI to fetch secrets from Infisical into your Next.js app for local development.

### CLI Installation

Follow the instructions for your operating system to install the Infisical CLI.

<Tabs>
  <Tab title="MacOS">
    Use [brew](https://brew.sh/) package manager

    ```console  theme={"dark"}
    $ brew install infisical/get-cli/infisical
    ```
  </Tab>

  <Tab title="Windows">
    Use [Scoop](https://scoop.sh/) package manager

    ```console  theme={"dark"}
    $ scoop bucket add org https://github.com/Infisical/scoop-infisical.git
    ```

    ```console  theme={"dark"}
    $ scoop install infisical
    ```
  </Tab>

  <Tab title="Alpine">
    Install prerequisite

    ```console  theme={"dark"}
    $ apk add --no-cache bash sudo
    ```

    Add Infisical repository

    ```console  theme={"dark"}
    $ curl -1sLf \
    	'https://dl.cloudsmith.io/public/infisical/infisical-cli/setup.alpine.sh' \
    	| bash
    ```

    Then install CLI

    ```console  theme={"dark"}
    $ apk update && sudo apk add infisical
    ```
  </Tab>

  <Tab title="RedHat/CentOs/Amazon">
    Add Infisical repository

    ```console  theme={"dark"}
    $ curl -1sLf \
    'https://dl.cloudsmith.io/public/infisical/infisical-cli/setup.rpm.sh' \
    | sudo -E bash
    ```

    Then install CLI

    ```console  theme={"dark"}
    $ sudo yum install infisical
    ```
  </Tab>

  <Tab title="Debian/Ubuntu">
    Add Infisical repository

    ```console  theme={"dark"}
    $ curl -1sLf \
    'https://dl.cloudsmith.io/public/infisical/infisical-cli/setup.deb.sh' \
    | sudo -E bash
    ```

    Then install CLI

    ```console  theme={"dark"}
    $ sudo apt-get update && sudo apt-get install -y infisical
    ```
  </Tab>

  <Tab title="Arch Linux">
    Use the `yay` package manager to install from the [Arch User Repository](https://aur.archlinux.org/packages/infisical-bin)

    ```console  theme={"dark"}
    $ yay -S infisical-bin
    ```
  </Tab>
</Tabs>

### Login

Authenticate the CLI with the Infisical platform using your email and password.

```console  theme={"dark"}
$ infisical login
```

### Initialization

Run the `init` command at the root of the Next.js app. This step connects your local project to the project on the Infisical platform and creates a `infisical.json` file containing a reference to that latter project.

```console  theme={"dark"}
$ infisical init
```

### Start the Next.js app with secrets injected as environment variables

```console  theme={"dark"}
$ infisical run -- npm run dev
```

If you open your browser console, **Hello, YOUR\_NAME** should be printed out.

Here, the CLI fetched the secret from Infisical and injected it into the Next.js app upon starting up. By default,
the CLI fetches secrets from the development environment which has the slug `dev`; you can inject secrets from different
environments by modifying the `env` flag as per the [CLI documentation](/cli/usage).

At this stage, you know how to use the Infisical CLI to inject secrets into your Next.js app for local development.

## Infisical-Vercel integration for production environment variables

We'll now use the Infisical-Vercel integration send secrets from Infisical to Vercel as production environment variables.

### Infisical-Vercel integration

To begin we have to import the Next.js app into Vercel as a project. [Follow these instructions](https://vercel.com/docs/frameworks/nextjs) to deploy the Next.js app to Vercel.

Next, navigate to your project's integrations tab in Infisical and press on the Vercel tile to grant Infisical access to your Vercel account.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations.png" alt="integrations" />

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/vercel/integrations-vercel-auth.png" alt="integrations vercel authorization" />

<Note>
  Opting in for the Infisical-Vercel integration will break end-to-end encryption since Infisical will be able to read
  your secrets. This is, however, necessary for Infisical to sync the secrets to Vercel.

  Your secrets remain encrypted at rest following our [security guide mechanics](/internals/security).
</Note>

Now select **Production** for (the source) **Environment** and sync it to the **Production Environment** of the (target) application in Vercel.
Lastly, press create integration to start syncing secrets to Vercel.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/vercel/integrations-vercel-create.png" alt="integrations vercel" />
<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/vercel/integrations-vercel.png" alt="integrations vercel" />

You should now see your secret from Infisical appear as production environment variables in your Vercel project.

At this stage, you know how to use the Infisical-Vercel integration to sync production secrets from Infisical to Vercel.

<Warning>
  The following environment variable names are reserved by Vercel and cannot be
  synced: `AWS_SECRET_KEY`, `AWS_EXECUTION_ENV`, `AWS_LAMBDA_LOG_GROUP_NAME`,
  `AWS_LAMBDA_LOG_STREAM_NAME`, `AWS_LAMBDA_FUNCTION_NAME`,
  `AWS_LAMBDA_FUNCTION_MEMORY_SIZE`, `AWS_LAMBDA_FUNCTION_VERSION`,
  `NOW_REGION`, `TZ`, `LAMBDA_TASK_ROOT`, `LAMBDA_RUNTIME_DIR`,
  `AWS_ACCESS_KEY_ID`, `AWS_SECRET_ACCESS_KEY`, `AWS_SESSION_TOKEN`,
  `AWS_REGION`, and `AWS_DEFAULT_REGION`.
</Warning>

## FAQ

<AccordionGroup>
  <Accordion title="Why should I use Infisical if I can centralize all my Next.js + Vercel environment variables across all environments directly in Vercel?">
    Vercel does not specialize in secret management which means it lacks many useful features for effectively managing environment variables.
    Here are some features that teams benefit from by using Infisical together with Vercel:

    * Audit logs: See which team members are creating, reading, updating, and deleting environment variables across all environments.
    * Versioning and point in time recovery: Rolling back secrets and an entire project state.
    * Overriding secrets that should be unique amongst team members.

    And much more.
  </Accordion>

  <Accordion title="Is opting out of end-to-end encryption for the Infisical-Vercel integration safe?">
    Yes. Your secrets are still encrypted at rest. To note, most secret managers actually don't support end-to-end encryption.

    Check out the [security guide](/internals/security).
  </Accordion>
</AccordionGroup>

See also:

* [Documentation for the Infisical CLI](/cli/overview)
* [Documentation for the Vercel integration](/integrations/cloud/vercel)


# Node
Source: https://infisical.com/docs/documentation/guides/node



This guide demonstrates how to use Infisical to manage secrets for your Node stack from local development to production. It uses:

* Infisical (you can use [Infisical Cloud](https://app.infisical.com) or a [self-hosted instance of Infisical](https://infisical.com/docs/self-hosting/overview)) to store your secrets.
* The [@infisical/sdk](https://github.com/Infisical/node-sdk-v2) Node.js client SDK to fetch secrets back to your Node application on demand.

## Project Setup

To begin, we need to set up a project in Infisical and add secrets to an environment in it.

### Create a project

1. Create a new project in [Infisical](https://app.infisical.com/).

2. Add a secret to the development environment of this project so we can pull it back for local development. In the **Secrets Overview** page, press **Explore Development** and add a secret with the key `NAME` and value `YOUR_NAME`.

### Create a Machine Identity

Now that we've created a project and added a secret to its development environment, we need to configure an Infisical Machine Identity that our Node application can use to access the secret.

* [How to setup machine identities](/documentation/platform/identities/overview)

## Create a Node app

For this demonstration, we use a minimal Express application. However, the same principles will apply to any Node application such as those built on Koa or Fastify.

### Create an Express app

Initialize a new Node.js project with a default `package.json` file.

```console  theme={"dark"}
npm init -y
```

Install `express` and [@infisical/sdk](https://www.npmjs.com/package/@infisical/sdk), the client Node SDK for Infisical.

```console  theme={"dark"}
npm install express @infisical/sdk
```

Finally, create an index.js file containing the application code.

```js  theme={"dark"}
const express = require('express');
const { InfisicalSDK } = require("@infisical/sdk");


const app = express();

const PORT = 3000;

let client;

const setupClient = () => {  

  if (client) {
    return;
  }

  const infisicalSdk = new InfisicalSDK({
      siteUrl: "your-infisical-instance.com" // Optional, defaults to https://app.infisical.com
  });

  await infisicalSdk.auth().universalAuth.login({
    clientId: "<machine-identity-client-id>",
    clientSecret: "<machine-identity-client-secret>"
  });

  // If authentication was successful, assign the client
  client = infisicalSdk;
}



app.get("/", async (req, res) => {
    

    const name = await client.secrets().getSecret({
      environment: "dev", // dev, staging, prod, etc.
      projectId: "<project-id>",
      secretPath: "/",
      secretName: "NAME"
    });
    
    res.send(`Hello! My name is: ${name.secretValue}`);
});

app.listen(PORT, async () => {
  // initialize http server and Infisical
    await setupClient();
    console.log(`Server listening on port ${PORT}`);
});
```

Here, we initialized a `client` instance of the Infisical Node SDK with the [Machine Identity](/documentation/platform/identities/overview)
that we created earlier, giving access to the secrets in the development environment of the
project in Infisical that we created earlier.

Finally, start the app and head to `http://localhost:3000` to see the message **Hello, Your Name**.

```console  theme={"dark"}
node index.js
```

The client fetched the secret with the key `NAME` from Infisical that we returned in the response of the endpoint.

At this stage, you know how to fetch secrets from Infisical back to your Node application.
By using Machine Identities scoped to different projects and environments, you can easily manage secrets across various stages of your project in Infisical, from local development to production.

## FAQ

<AccordionGroup>
  <Accordion title="What if a request for a secret fails?">
    The SDK caches every secret and falls back to the cached value if a request fails. If no cached
    value ever-existed, the SDK falls back to whatever value is on `process.env`.
  </Accordion>

  <Accordion title="What's the point if I still have to manage a token for the SDK?">
    The token enables the SDK to authenticate with Infisical to fetch back your secrets.
    Although the SDK requires you to pass in a token, it enables greater efficiency and security
    than if you managed dozens of secrets yourself without it. Here're some benefits:

    * You always pull in the right secrets because they're fetched on demand from a centralized source that is Infisical.
    * You can use the Infisical which comes with tons of benefits like secret versioning, access controls, audit logs, etc.
    * You now risk leaking one token that can be revoked instead of dozens of raw secrets.

    And much more.
  </Accordion>
</AccordionGroup>

See also:

* Explore the [Node SDK](https://github.com/Infisical/node-sdk-v2)


# Infisical Organizational Structure Blueprint
Source: https://infisical.com/docs/documentation/guides/organization-structure

Learn how to structure your projects, secrets, and other resources within Infisical.

Infisical is designed to provide comprehensive, centralized, and efficient management of secrets, certificates, and encryption keys within organizations. Below is an overview of Infisical's structured components, which developers and administrators can leverage for optimal project management and security posture.

### 0. Cluster/Instance

* **Best Practice**: In most cases, a single Infisical instance or cluster is sufficient. Multiple clusters are typically only necessary for large, globally distributed organizations.
* **Use Cases**:
  * **Cloud-hosted** deployments typically use a single cluster. While technically possible, using multiple clusters is not a common practice and is generally unnecessary.
  * **Self-hosted** deployments can be configured with multiple clusters if needed.

### 1. Organization

* **Definition**: An Infisical [organization](/documentation/platform/organization) is a set of projects that use the same billing.
* **Use Cases**:
  * In **self-hosted** setups, you can create multiple organizations (e.g., one for each department or business unit).
  * In **cloud-hosted deployments**, it's standard to use a single organization.

### 2. Projects

* **Definition and Role**: [Projects](/documentation/platform/project) are the highest-level construct within an [organization](/documentation/platform/organization) in Infisical. They serve as the primary container for all functionalities.
* **Common Project Mappings**: Projects typically align with applications, services, or code repositories  each being a valid and common approach depending on your organizational structure.
* **Functional Capabilities**: Each project encompasses features for managing secrets, certificates, and encryption keys, serving as the central hub for these resources.

<Note>Projects are isolated from one another. Secrets, certificates, and other resources cannot be shared or referenced across different projects. Each project maintains its own separate set of resources.</Note>

### 3. Environments

* **Purpose**: Environments are designed for organizing and compartmentalizing secrets within projects.
* **Customization Options**: Environments can be tailored to align with existing infrastructure setups of any project. Default options include **Development**, **Staging**, and **Production**.
* **Structure**: Each environment inherently has a root level for storing secrets, but additional sub-organizations can be created through [folders](/documentation/platform/folder) for better secret management.

### 4. Folders

* **Use Case**: Folders are available for more advanced organizational needs, allowing logical separation of secrets.
* **Typical Structure**: Folders can correspond to specific logical units, such as microservices or different layers of an application, providing refined control over secrets.

### 5. Imports

* **Purpose and Benefits**: To promote reusability and avoid redundancy within a project, Infisical supports the use of imports and references. This allows secrets, folders, or entire environments to be referenced within the same project as needed.
* **Project Isolation**: Imports and references only work within a single project. Secrets cannot be imported or referenced across different projects, as projects are isolated from one another.
* **Best Practice**: Utilizing [secret imports](/documentation/platform/secret-reference#secret-imports) or [references](/documentation/platform/secret-reference#secret-referencing) ensures consistency and minimizes manual overhead when managing secrets within a project.

### 6. Approval Workflows

* **Importance**: Implementing approval workflows is recommended for organizations aiming to enhance efficiency and strengthen their security posture.
* **Types of Workflows**:
  * **[Access Requests](/documentation/platform/pr-workflows)**: This workflow allows developers to request access to sensitive resources. Such access can be configured for temporary use, a practice known as "just-in-time" access.
  * **[Change Requests](/documentation/platform/access-controls/access-requests)**: Facilitates reviews and approvals when changes are proposed for sensitive environments or specific folders, ensuring proper oversight.

### 7. Access Controls

Infisicals access control framework is unified for both human users and machine identities, ensuring consistent management across the board.

### 7.1 Roles

* **2 Role Types**:
  * **Organization-Level Roles**: Provide broad access across the organization (e.g., ability to manage billing, configure settings, etc.).
  * **Project-Level Roles**: Essential for configuring access to specific secrets and other sensitive assets within a project.
* **Granular Permissions**: While default roles are available, [custom roles](/documentation/platform/access-controls/role-based-access-controls#creating-custom-roles) can be created for more tailored access controls.
* **Admin Considerations**: Note that admin users are able to access all projects. This role should be assigned judiciously to prevent unintended overreach.

<Note>Project access is defined not via an organization-level role, but rather through specific project memberships of both human and machine identities. Admin roles bypass this by default. </Note>

### 7.2 Additional Privileges

[Additional privileges](/documentation/platform/access-controls/additional-privileges) can be assigned to users and machines on an ad-hoc basis for specific scenarios where roles alone are insufficient. If you find yourself using additional privileges too much, it is recommended to create custom roles. Additional privileges can be temporary or permanent.

### 7.3 Attribute-Based Access Control (ABAC)

[Attribute-based Access Controls](/documentation/platform/access-controls/abac/overview) allow restrictions based on tags or attributes linked to secrets. These can be integrated with SAML assertions and other security frameworks for dynamic access management.

### 7.4 User Groups

* **Application**: Organizations should use users groups in situations when they have a lot of developers with the same level of access (e.g., separated by team, department, seniority, etc.).
* **Synchronization**: [User groups](/documentation/platform/groups) can be synced with an identity provider to maintain consistency and reduce manual management.

### **Implementation Note**

For larger-scale organizations, automating configurations through **Terraform** or other infrastructure-as-code (IaC) tools is advisable. Manual configurations may lead to errors, so leveraging IaC enhances reliability and consistency in managing Infisical's robust capabilities.

This structured approach ensures that Infisical's functionalities are fully leveraged, providing both flexibility and rigorous control over an organization's sensitive information and access needs.


# Python
Source: https://infisical.com/docs/documentation/guides/python



This guide demonstrates how to use Infisical to manage secrets for your Python stack from local development to production. It uses:

* Infisical (you can use [Infisical Cloud](https://app.infisical.com) or a [self-hosted instance of Infisical](https://infisical.com/docs/self-hosting/overview)) to store your secrets.
* The [infisicalsdk](https://pypi.org/project/infisicalsdk/) Python client SDK to fetch secrets back to your Python application on demand.

## Project Setup

To begin, we need to set up a project in Infisical and add secrets to an environment in it.

### Create a project

1. Create a new project in [Infisical](https://app.infisical.com/).

2. Add a secret to the development environment of this project so we can pull it back for local development. In the **Secrets Overview** page, press **Explore Development** and add a secret with the key `NAME` and value `YOUR_NAME`.

### Create a Machine Identity

Now that we've created a project and added a secret to its development environment, we need to configure an Infisical Machine Identity that our Python application can use to access the secret.

* [How to setup machine identities](/documentation/platform/identities/overview)

## Create a Python app

For this demonstration, we use a minimal Flask application. However, the same principles will apply to any Python application such as those built with Django.

### Create a Flask app

First, create a virtual environment and activate it.

```console  theme={"dark"}
python3 -m venv env
source env/bin/activate
```

Install Flask and [infisicalsdk](https://pypi.org/project/infisicalsdk/), the client Python SDK for Infisical.

```console  theme={"dark"}
pip install flask infisicalsdk
```

Finally, create an `app.py` file containing the application code.

```py  theme={"dark"}
from flask import Flask
from infisical_sdk import InfisicalSDKClient

app = Flask(__name__)

client = InfisicalSDKClient(host="https://app.infisical.com") # host is optional, defaults to https://app.infisical.com

client.auth.universal_auth.login(
  "<machine-identity-client-id>",
  "<machine-identity-client-secret>"
)

@app.route("/")
def hello_world():
    # access value
     name = client.secrets.get_secret_by_name(
      secret_name="NAME",
      project_id="<project-id>",
      environment_slug="dev",
      secret_path="/"
     )

    return f"Hello! My name is: {name.secretValue}"
```

Here, we initialized a `client` instance of the Infisical Python SDK with the Infisical Token
that we created earlier, giving access to the secrets in the development environment of the
project in Infisical that we created earlier.

Finally, start the app and head to `http://localhost:5000` to see the message **Hello, Your Name**.

```console  theme={"dark"}
flask run
```

The client fetched the secret with the key `NAME` from Infisical that we returned in the response of the endpoint.

At this stage, you know how to fetch secrets from Infisical back to your Python application. By using Infisical Tokens scoped to different environments, you can easily manage secrets across various stages of your project in Infisical, from local development to production.

## FAQ

<AccordionGroup>
  <Accordion title="What's the point if I still have to manage a token for the SDK?">
    The token enables the SDK to authenticate with Infisical to fetch back your secrets.
    Although the SDK requires you to pass in a token, it enables greater efficiency and security
    than if you managed dozens of secrets yourself without it. Here're some benefits:

    * You always pull in the right secrets because they're fetched on demand from a centralized source that is Infisical.
    * You can use the Infisical which comes with tons of benefits like secret versioning, access controls, audit logs, etc.
    * You now risk leaking one token that can be revoked instead of dozens of raw secrets.

    And much more.
  </Accordion>
</AccordionGroup>

See also:

* Explore the [Python SDK](https://github.com/Infisical/python-sdk-official)


# Machine identities
Source: https://infisical.com/docs/documentation/platform/access-controls/abac/managing-machine-identity-attributes

Learn how to set metadata and leverage authentication attributes for machine identities.

Machine identities can have metadata set manually, just like users. In addition, during the machine authentication process (e.g., via OIDC), extra attributes called claimsare provided, which can be used in your ABAC policies.

#### Setting Metadata on Machine Identities

<Tabs>
  <Tab title="Manually Configure Metadata">
    <Steps>
      <Step title="Navigate to the Access Control page on the organization sidebar and select a machine identity.">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/documentation/platform/access-controls/abac/images/add-metadata-on-machine-identity-1.png" />
      </Step>

      <Step title="On the machine identity page, click the pencil icon to edit the selected identity.">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/documentation/platform/access-controls/abac/images/add-metadata-on-machine-identity-2.png" />
      </Step>

      <Step title="Add metadata via key-value pairs and update the machine identity.">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/documentation/platform/access-controls/abac/images/add-metadata-on-machine-identity-3.png" />
      </Step>
    </Steps>
  </Tab>
</Tabs>

#### Accessing Attributes From Machine Identity Login

When machine identities authenticate, they may receive additional payloads/attributes from the service provider.
For methods like OIDC, these come as claims in the token and can be made available in your policies.

<Tabs>
  <Tab title="OIDC Login Attributes">
    1. Navigate to the Identity Authentication settings and select the OIDC Auth Method.
    2. In the **Advanced section**, locate the Claim Mapping configuration.
    3. Map the OIDC claims to permission attributes by specifying:
       * **Attribute Name:** The identifier to be used in your policies (e.g., department).
       * **Claim Path:** The dot notation path to the claim in the OIDC token (e.g., user.department).

    For example, if your OIDC provider returns:

    ```json  theme={"dark"}
    {
      "sub": "machine456",
      "name": "Service A",
      "user": {
        "department": "engineering",
        "role": "service"
      }
    }
    ```

    You might map:

    * **department:** to `user.department`
    * **role:** to `user.role`

    Once configured, these attributes become available in your policies using the following format:

    ```
    {{ identity.auth.oidc.claims.<permission claim name> }}
    ```

    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/access-controls/abac-policy-oidc-format.png" />
  </Tab>

  <Tab title="Kubernetes Login Attributes">
    For identities authenticated using Kubernetes, the service account's namespace and name are available in their policy and can be accessed as follows:

    ```
    {{ identity.auth.kubernetes.namespace }}
    {{ identity.auth.kubernetes.name }}
    ```

    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/access-controls/abac-policy-k8s-format.png" />
  </Tab>

  <Tab title="AWS Attributes">
    For identities authenticated using AWS Auth, several attributes can be accessed. On top of the 3 base attributes, there's 4 derived from the ARN. The example below includes comments showing how each derived attribute looks like based on this ARN: `arn:aws:iam::123456789012:user/example-user`

    ```
    {{ identity.auth.aws.accountId }}
    {{ identity.auth.aws.arn }}
    {{ identity.auth.aws.userId }}

    // Derived from ARN
    {{ identity.auth.aws.partition }} // aws
    {{ identity.auth.aws.service }} // iam
    {{ identity.auth.aws.resourceType }} // user
    {{ identity.auth.aws.resourceName }} // example-user
    ```

    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/access-controls/abac-policy-aws-format.png" />
  </Tab>

  <Tab title="Other Authentication Method Attributes">
    At the moment we only support OIDC claims, Kubernetes attributes, and AWS attributes. Payloads on other authentication methods are not yet accessible.
  </Tab>
</Tabs>


# Users identities
Source: https://infisical.com/docs/documentation/platform/access-controls/abac/managing-user-metadata

How to set and use metadata attributes on user identities for ABAC.

User identities can have metadata attributes assigned directly. These attributes (such as location or department) are used to define dynamic access policies.

#### Setting Metadata on Users

<Tabs>
  <Tab title="Manually Configure Metadata">
    <Steps>
      <Step title="Navigate to the Access Control page on the organization sidebar and select a user.">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/access-controls/add-metadata-step1.png" />
      </Step>

      <Step title="On the User Page, click the pencil icon to edit the selected user.">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/access-controls/add-metadata-step2.png" />
      </Step>

      <Step title="Add metadata via key-value pairs and update the user identity.">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/access-controls/add-metadata-step3.png" />
      </Step>
    </Steps>
  </Tab>

  <Tab title="Automatically Populate Metadata">
    For organizations using SAML for **user logins**, Infisical automatically maps metadata attributes from SAML assertions to user identities on every login. This enables dynamic policies based on the user's SAML attributes.
  </Tab>
</Tabs>

#### Applying ABAC Policies with User Metadata

Attribute-based access controls are currently only available for policies defined on Secrets Manager projects.
You can set ABAC permissions to dynamically set access to environments, folders, secrets, and secret tags.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/access-controls/example-abac-1.png" />

In your policies, metadata values are accessed as follows:

* **User ID:** `{{ identity.id }}` (always available)
* **Username:** `{{ identity.username }}` (always available)
* **Metadata Attributes:** `{{ identity.metadata.<metadata-key-name> }}` (available if set)


# Overview
Source: https://infisical.com/docs/documentation/platform/access-controls/abac/overview

Learn the basics of ABAC for both users and machine identities.

Infisical's Attribute-based Access Controls (ABAC) enable dynamic, attribute-driven permissions for both users and machine identities. ABAC enforces fine-grained, context-aware access controls using metadata attributesstored as key-value pairseither attached to identities or provided during authentication.

<CardGroup cols={2}>
  <Card title="Users" icon="square-1" href="./managing-user-metadata">
    Manage user metadata manually or automatically via SAML logins.
  </Card>

  <Card title="Machine Identities" icon="square-2" href="./managing-machine-identity-attributes">
    Set metadata manually like users and access additional attributes provided during machine authentication (for example, OIDC claims).
  </Card>
</CardGroup>


# Access Requests
Source: https://infisical.com/docs/documentation/platform/access-controls/access-requests

Learn how to request access to sensitive resources in Infisical.

In certain situations, developers need to expand their access to a certain new project or a sensitive environment. For those use cases, it is helpful to utilize Infisical's **Access Requests** functionality.

This functionality works in the following way:

1. A project administrator sets up an access policy that assigns access managers (also known as eligible approvers) to a certain sensitive folder or environment.
   <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/access-controls/create-access-request-policy.png" alt="Create Access Request Policy Modal" />

   <Note>
     A step policy enables a sequential approval workflow in which approvals
     must follow the designated chain.
   </Note>

   <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/access-controls/access-request-policies.png" alt="Access Request Policies" />

2. When a developer requests access to one of such sensitive resources, the request is visible in the dashboard, and the corresponding eligible approvers get an email notification about it.
   <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/access-controls/request-access.png" alt="Access Request Create" />
   <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/access-controls/access-requests-pending.png" alt="Access Request Dashboard" />

3. An eligible approver can approve or reject the access request.

   <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/access-controls/access-request-bypass.png" alt="Access Request Bypass" />

   <Note>
     Optionally, approvers can edit the duration of an access request to reduce how long access will be granted by clicking the **Edit** icon next to the duration.
     <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/access-controls/edit-access-request.png" alt="Edit Access Request" />
   </Note>

<Info>
  If the access request matches with a policy that allows break-glass approval
  bypasses, the requester may bypass the policy and get access to the resource
  without full approval.
</Info>

5. As soon as the request is approved, developer is able to access the sought resources.


# Additional Privileges
Source: https://infisical.com/docs/documentation/platform/access-controls/additional-privileges

Learn how to add specific privileges on top of predefined roles.

Even though Infisical supports full-fledged [role-base access controls](./role-based-access-controls) with ability to set predefined permissions for user and machine identities, it is sometimes desired to set additional privileges for specific user or machine identities on top of their roles.

Infisical **Additional Privileges** functionality enables specific permissions with access to sensitive secrets/folders by identities within certain projects. It is possible to set up additional privileges through Web UI or API.

To provision specific privileges through Web UI:

1. Click on the `Edit` button next to the set of roles for user or identities.
   <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/access-controls/edit-role.png" alt="Edit User Role" />

2. Click `Add Additional Privileges` in the corresponding section of the permission management modal.
   <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/access-controls/add-additional-privileges.png" alt="Add Specific Privilege" />

3. Fill out the necessary parameters in the privilege entry that appears. It is possible to specify the `Environment` and `Secret Path` to which you want to enable access.
   It is also possible to define the range of permissions (`View`, `Create`, `Modify`, `Delete`) as well as how long the access should last (e.g., permanent or timed).
   <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/access-controls/additional-privileges.png" alt="Additional privileges" />

4. Click the `Save` button to enable the additional privilege.
   <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/access-controls/confirm-additional-privileges.png" alt="Confirm Specific Privilege" />


# Assume Privileges
Source: https://infisical.com/docs/documentation/platform/access-controls/assume-privilege

Learn how to temporarily assume the privileges of a user or machine identity within a project.

This feature allows authorized users to temporarily take on the permissions of another user or identity. It helps administrators and access managers test and verify permissions before granting access, ensuring everything is set up correctly.
It also reduces back-and-forth with end users when troubleshooting permission-related issues.

## How It Works

When an authorized user activates assume privileges mode, they temporarily inherit the target user or identitys permissions for up to one hour.\
During this time, they can perform actions within the system with the same level of access as the target user.

* **Permission-based**: Only permissions are inherited, not the full identity
* **Time-limited**: Access automatically expires after one hour
* **Audited**: All actions are logged under the original user's account. This means any action taken during the session will be recorded under the entity assuming the privileges, not the target entity.
* **Authorization required**: Only users with the specific **assume privilege** permission can use this feature
* **Scoped to a single project**: You can only assume privileges for one project at a time

## How to Assume Privileges

<Steps>
  <Step title="Go to Project Access">
    Click on the user or identity you want to assume.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/access-controls/assume-privileges/access-control.png" alt="Access control page" />
  </Step>

  <Step title="Click Assume Privilege">
    Click **Assume Privilege**, then type `assume` to confirm and start your session.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/access-controls/assume-privileges/access-control-detail.png" alt="Access control detail page" />
  </Step>

  <Step title="Session is Active">
    You will see a yellow banner indicating that your assume privilege session is active. You can exit at any time by clicking **Exit**.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/access-controls/assume-privileges/session-start.png" alt="session start" />
  </Step>
</Steps>


# Access Controls
Source: https://infisical.com/docs/documentation/platform/access-controls/overview

Learn about Infisical's access control toolset.

To make sure that users and machine identities are only accessing the resources and performing actions they are authorized to, Infisical supports a wide range of access control tools.

<CardGroup cols={2}>
  <Card title="Role-based Access Controls" href="./role-based-access-controls" icon="address-book" color="#000000">
    Manage user and machine identitity permissions through predefined roles.
  </Card>

  <Card title="Attribute-based Access Control" href="/documentation/platform/access-controls/abac" icon="address-book" color="#000000">
    Manage user and machine identitity permissions based on their attributes.
  </Card>

  <Card title="Additional Privileges" href="./additional-privileges" icon="ballot-check" color="#000000">
    Add specific privileges to users and machines on top of their roles.
  </Card>

  <Card title="Temporary Access" href="./temporary-access" icon="clock" color="#000000">
    Grant timed access to roles and specific privileges.
  </Card>

  <Card title="Access Requests" href="./access-requests" icon="check" color="#000000">
    Enable users to request (temporary) access to sensitive resources.
  </Card>

  <Card title="Approval Workflows" href="/documentation/platform/pr-workflows" icon="thumbs-up" color="#000000">
    Set up review policies for secret changes in sensitive environments.
  </Card>

  <Card title="Audit Logs" href="/documentation/platform/audit-logs" icon="list" color="#000000">
    Track every action performed by user and machine identities in Infisical.
  </Card>
</CardGroup>


# Project Access Requests
Source: https://infisical.com/docs/documentation/platform/access-controls/project-access-requests

Learn how to request access to projects in Infisical.

The Project Access Request feature allows users to view all projects within organization, including those they don't currently have access to.
Users can request access to these projects by submitting a request that automatically notifies project administrators via email, along with any comments provided by the user.

# Viewing Available Projects

From the Infisical dashboard, users can view all projects within the organization:

1. Navigate to the main dashboard after logging in
2. The overview page for each product displays two tabs:

   * **My Projects**: Projects you currently have access to
   * **All Projects**: Complete list of projects in the organization

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/project-access-requests/all-project-view.png" alt="all-project-view" />

# Requesting Access to a Project

To request access to a project you don't currently have access for:

1. Click the **Request Access** button next to the project name
   <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/project-access-requests/request-access.png" alt="all-project-view" />

2. Add a comment explaining why you need access
   <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/project-access-requests/access-comment.png" alt="all-project-view" />

3. Click **Submit Request**

<Info>
  Project administrators will receive email notification with details regarding
  the access request.
</Info>


# Role-based Access Controls
Source: https://infisical.com/docs/documentation/platform/access-controls/role-based-access-controls

Learn how to use RBAC to manage user permissions.

Infisical's Role-based Access Controls (RBAC) enable the usage of predefined and custom roles that imply a set of permissions for user and machine identities. Such roles make it possible to restrict access to resources and the range of actions that can be performed.

In general, access controls can be split up across [projects](/documentation/platform/project) and [organizations](/documentation/platform/organization).

## Organization-level access controls

By default, every user and machine identity in a organization is either an **admin** or a **member**.

**Admins** are able to perform every action with the organization, including adding and removing organization members, managing access controls, setting up security settings, and creating new projects.

**Members**, on the other hand, are restricted from removing organization members, modifying billing information, updating access controls, and performing a number of other actions.

Overall, organization-level access controls are significantly of administrative nature. Access to projects, secrets and other sensitive data is specified on the project level.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/rbac/org-member-role.png" alt="Org member role" />

## Project-level access controls

By default, every user in a project is either a **viewer**, **developer**, or an **admin**. Each of these roles comes with a varying access to different features and resources inside projects.

As such:

* **Admin**: This role enables identities to have access to all environments, folders, secrets, and actions within the project.
* **Developers**: This role restricts identities from performing project control actions, updating Approval Workflow policies, managing roles, editing and removing project members, and more.
* **Viewer**: The most limiting bulit-in role on the project level it forbids user and machine identities to perform any action and rather shows them in the read-only mode.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/access-controls/rbac.png" alt="Project member role" />

## Creating custom roles

By creating custom roles, you are able to adjust permissions to the needs of your organization. This can be useful for:

* Creating superadmin roles, roles specific to SRE engineers, etc.
* Restricting access of users to specific secrets, folders, and environments.
* Embedding these specific roles into [Approval Workflow policies](/documentation/platform/pr-workflows).

<Note>
  It is worth noting that users are able to assume multiple built-in and custom roles. A user will gain access to all actions within the roles assigned to them, not just the actions those roles share in common.
</Note>

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/rbac/project-member-custom-role.png" alt="project member custom role" />


# Temporary Access
Source: https://infisical.com/docs/documentation/platform/access-controls/temporary-access

Learn how to set up timed access to sensitive resources for user and machine identities.

Certain environments and secrets are so sensitive that it is recommended to not give any user permanent access to those. For such use cases, Infisical supports the functionality of **Temporary Access** provisioning.

To provision temporary access through Web UI:

1. Click on the `Edit` button next to the set of roles for user or identities.
   <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/access-controls/edit-role.png" alt="Edit User Role" />

2. Click `Permanent` next to the role or specific privilege that you want to make temporary.

3. Specify the duration of remporary access (e.g., `1m`, `2h`, `3d`).
   <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/access-controls/configure-temporary-access.png" alt="Configure temp access" />

4. Click `Grant`.

5. Click the corresponding `Save` button to enable remporary access.
   <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/access-controls/temporary-access.png" alt="Temporary Access" />

<Note>
  Every user and machine identity should always have at least one permanent role attached to it.
</Note>


# Server Admin Console
Source: https://infisical.com/docs/documentation/platform/admin-panel/server-admin

Configure and manage server related features

The Server Admin Console provides **server administrators** with the ability to
customize settings and manage users for their entire Infisical instance.

<Note>
  The first user to setup an account on your Infisical instance is designated as
  the server administrator by default.
</Note>

## Accessing the Server Admin Console

On the sidebar, hover over **Admin** to access the settings dropdown and press the **Server Admin Console** option.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/admin-panels/access-server-admin-panel.png" alt="Access Server Admin Console" />

## General Tab

Configure general settings for your instance.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/admin-panels/admin-panel-general.png" alt="General Settings" />
<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/admin-panels/admin-panel-general-1.png" alt="General Settings 1" />

### Allow User Signups

User signups are enabled by default, allowing **Anyone** with access to your instance to sign up. This can alternatively be **Disabled** to prevent any users from signing up.

### Restrict Signup Domain

Signup can be restricted to users matching one or more email domains, such as your organization's domain, to control who has access to your instance.

### Default Organization

If you're using SAML/LDAP/OIDC for only one organization on your instance, you can specify a default organization to use at login to skip requiring users to manually enter the organization slug.

### Trust Emails

By default, users signing up through SAML/LDAP/OIDC will still need to verify their email address to prevent email spoofing. This requirement can be skipped by enabling the switch to trust logins through the respective method.

### Broadcast Messages

Auth consent content is displayed to users on the login page. They can be used to display important information to users, such as a maintenance message or a new feature announcement. Both HTML and Markdown formatting are supported, allowing for customized styling like below:

```
**You are entering a confidential website**
```

```html  theme={"dark"}
<div style="font-weight: bold;">You are entering a confidential website</div>
```

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/admin-panels/auth-consent-usage.png" alt="Auth Consent Usage" />

Page frame content is displayed as a header and footer in ALL protected pages. Like the auth consent content, both HTML and Markdown formatting are supported here as well.
<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/admin-panels/page-frame-usage.png" alt="Page Frame Usage" />

## Authentication Tab

From this tab, you can configure which login methods are enabled for your instance.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/admin-panels/admin-panel-auths.png" alt="Authentication Settings" />

## Rate Limit Tab

This tab allows you to set various rate limits for your Infisical instance. You do not need to redeploy when making changes to rate limits as these will be propagated automatically.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/admin-panels/admin-panel-rate-limits.png" alt="Rate Limit Settings" />

<Note>
  Note that rate limit configuration is a paid feature. Please contact
  [sales@infisical.com](mailto:sales@infisical.com) to purchase a license for its use.
</Note>

## User Management Tab

From this tab, you can view all the users who have signed up for your instance. You can search for users using the search bar and remove them from your instance by clicking on the three dots icon on the right. Additionally, the Server Admin can grant server administrator access to other users through this menu.
<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/admin-panels/admin-panel-users.png" alt="User Management" />

<Note>
  Note that rate limit configuration is a paid feature. Please contact
  [sales@infisical.com](mailto:sales@infisical.com) to purchase a license for its use.
</Note>


# Audit Log Streams
Source: https://infisical.com/docs/documentation/platform/audit-log-streams/audit-log-streams

Learn how to stream Infisical Audit Logs to external logging providers.

<Info>
  Audit log streams is a paid feature.

  If you're using Infisical Cloud, then it is available under the **Enterprise Tier**. If you're self-hosting Infisical, then you should contact [team@infisical.com](mailto:team@infisical.com) to purchase an enterprise license to use it.
</Info>

Infisical Audit Log Streaming enables you to transmit your organization's audit logs to external logging providers for monitoring and analysis.

## Overview

<Steps>
  <Step title="Create Stream">
    1. Navigate to **Organization Settings**
    2. Select the **Audit Log Streams** tab
    3. Click **Add Log Stream**

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/audit-log-streams/stream-create.png" alt="stream create" />
  </Step>

  <Step title="Select Provider">
    If your log provider is included in this list, select it. Otherwise click on **Custom** to input your own Endpoint URL and headers.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/audit-log-streams/select-provider.png" alt="select provider" />
  </Step>

  <Step title="Input Credentials">
    Depending on your chosen provider, you'll be asked to input different credentials.

    For **Custom**, you need to input an endpoint URL and headers.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/audit-log-streams/custom-provider.png" alt="custom provider" />

    Once you're finished, click **Create Log Stream**.
  </Step>

  <Step title="Log Stream Created">
    Your audit logs are now ready to be streamed.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/audit-log-streams/stream-list.png" alt="stream list" />
  </Step>
</Steps>

## Example Providers

<AccordionGroup>
  <Accordion title="Azure">
    Infisical offers a dedicated **Azure** provider to stream your audit logs, enabling seamless integration with services like Microsoft Sentinel.

    <Warning>
      After setting up all Azure resources, it may take 10-20 minutes for logs to begin streaming.
    </Warning>

    <Steps>
      <Step title="Create a Data Collection Endpoint">
        Navigate to [Data Collection Endpoints](https://portal.azure.com/#view/HubsExtension/BrowseResource.ReactView/resourceType/microsoft.insights%2Fdatacollectionendpoints) and click **Create**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/audit-log-streams/azure-create-dce.png" alt="azure create dce" />

        Configure your Data Collection Endpoint by providing an **Endpoint Name**, **Subscription**, and a **Resource group**. Then click **Review + Create**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/audit-log-streams/azure-configure-dce.png" alt="azure configure dce" />

        After creation, it may take a few minutes for the Data Collection Endpoint to appear. Once visible, click on it and copy the **Logs Ingestion** URL. You will need this URL in later steps.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/audit-log-streams/azure-dce-url.png" alt="azure dce url" />
      </Step>

      <Step title="Create a Log Analytics Workspace">
        <Info>
          If you already have a Log Analytics Workspace, you may skip this step.
        </Info>

        Navigate to [Log Analytics Workspaces](https://portal.azure.com/#browse/Microsoft.OperationalInsights%2Fworkspaces) and click **Create**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/audit-log-streams/azure-create-law.png" alt="azure create law" />

        Configure your Log Analytics Workspace by providing a **Subscription**, **Resource group**, and a **Name**. Then click **Review + Create**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/audit-log-streams/azure-configure-law.png" alt="azure configure law" />

        Once the workspace is deployed, click **Go to resource** to access it.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/audit-log-streams/azure-go-to-resource.png" alt="azure go to resource" />
      </Step>

      <Step title="Create a Custom Log Table">
        Within your Log Analytics Workspace, navigate to **Tables** and click **Create**. Select **New custom log (DCR-based)** from the dropdown.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/audit-log-streams/azure-new-table.png" alt="azure new table" />

        Configure the Custom Log Table: Provide a **Table name** (e.g., `InfisicalLogs`), select the **Data collection endpoint** created in Step 1, and create a new **Data collection rule** as illustrated in the image below. Then, click **Next**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/audit-log-streams/azure-configure-table.png" alt="azure configure table" />

        On the **Schema and transformation** page, you'll be prompted to upload a **Log Sample**. Create a `.json` file with the following content and upload it:

        ```json  theme={"dark"}
        {
        "id": "00000000-0000-0000-0000-000000000000",
        "actor": "user",
        "actorMetadata": {
            "email": "user@example.com",
            "userId": "00000000-0000-0000-0000-000000000000",
            "username": "user@example.com"
        },
        "ipAddress": "0.0.0.0",
        "userAgent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/139.0.0.0 Safari/537.36",
        "userAgentType": "web",
        "eventType": "get-secrets",
        "eventMetadata": {},
        "projectName": "MyProject",
        "orgId": "00000000-0000-0000-0000-000000000000",
        "projectId": "00000000-0000-0000-0000-000000000000",
        "TimeGenerated": "2025-01-01T00:00:00.000Z"
        }
        ```

        Optionally, you can add **Transformations** to further destructure the data. For example, to extract actor email and userId:

        ```
        source
        | extend
            ActorEmail = tostring(actorMetadata.email),
            ActorUserId = tostring(actorMetadata.userId)
        ```

        On the final step, click **Create**.

        <Warning>
          It may take a few minutes for your Custom Log Table to be created and appear under Tables.
        </Warning>
      </Step>

      <Step title="Obtain Data Collection Rule Immutable ID">
        After creating your Data Collection Rule, you'll need its **Immutable ID**.

        Navigate to [Data collection rules](https://portal.azure.com/#view/HubsExtension/BrowseResource.ReactView/resourceType/microsoft.insights%2Fdatacollectionrules). Click on your newly created DCR and copy its **Immutable ID** for the next step.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/audit-log-streams/azure-dcr.png" alt="azure dcr" />
      </Step>

      <Step title="Create Audit Log Stream on Infisical">
        In Infisical, create a new audit log stream and select the **Azure** provider. Input the following details:

        * **Tenant ID**: Your Tenant ID
        * **Client ID**: The Client ID of an App Registration
        * **Client Secret**: The Client Secret of an App Registration
        * **Data Collection Endpoint URL**: Obtained from Step 1
        * **Data Collection Rule Immutable ID**: Obtained from Step 4
        * **Custom Log Table Name**: Defined in Step 3

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/audit-log-streams/azure-create-als.png" alt="azure create als" />

        <Warning>
          The App Registration used for authentication must have the **Monitoring Metrics Publisher** role assigned on the **Data Collection Rule** created in Step 3. [See Microsoft Guide](https://learn.microsoft.com/en-us/azure/azure-monitor/logs/tutorial-logs-ingestion-portal#assign-permissions-to-the-dcr).
        </Warning>
      </Step>
    </Steps>
  </Accordion>

  <Accordion title="Better Stack">
    You can stream to Better Stack using a **Custom** log stream.

    <Steps>
      <Step title="Connect Source">
        On Better Stack, select **Connect Source** and click **Create source** after providing a name.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/audit-log-streams/betterstack-create-source.png" alt="better stack connect source" />

        Once your source is created, take note of the **endpoint** and **Source token** for the next step.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/audit-log-streams/betterstack-source-details.png" alt="better stack connect" />
      </Step>

      <Step title="Create Audit Log Stream on Infisical">
        On Infisical, create a new audit log stream and select the **Custom** option.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/audit-log-streams/select-custom.png" alt="select custom" />

        1. Fill in the endpoint URL with your Better Stack source endpoint
        2. Create a new header with key `Authorization` and set the value as `Bearer <betterstack-src-token>`

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/audit-log-streams/custom-provider.png" alt="custom provider" />

        Once you're finished, click **Create Log Stream**.
      </Step>
    </Steps>
  </Accordion>

  <Accordion title="Cribl">
    Stream Infisical audit logs to Cribl Stream for centralized processing and routing. Infisical supports Cribl as a provider for seamless integration.

    <Steps>
      <Step title="Create Infisical Data Source">
        In Cribl Stream, navigate to **Worker Groups** and select your Worker Group. Take note of the **Ingress Address** for later steps.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/audit-log-streams/cribl-ingress-address.png" alt="cribl ingress address" />

        Within your Worker Group, navigate to **Data > Sources > HTTP** and click **Add Source**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/audit-log-streams/cribl-add-source.png" alt="cribl add source" />

        Configure the **Input ID**, **Port**, and **Cribl HTTP event API** path (e.g., `/infisical`). Then, generate an **Auth Token**.

        You can optionally configure TLS in the **TLS Settings** tab and add a pipeline in the **Pre-Processing** tab.

        <Warning>
          Ensure that you're using a port that's open on your instance.
        </Warning>

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/audit-log-streams/cribl-general-settings.png" alt="cribl general settings" />

        Once you've configured the Data Source, click **Save** and deploy your changes.
      </Step>

      <Step title="Create Audit Log Stream on Infisical">
        On Infisical, create a new audit log stream and select the **Cribl** provider option.

        Input the following credentials:

        * **Cribl Stream URL**: Your HTTP source endpoint composed of `http://<ingress-address>:<port>/<http-event-api-path>/_bulk`
        * **Cribl Stream Token**: The authentication token from Step 1

        <Info>
          If you configured TLS for your Data Source, use the `https://` protocol.
        </Info>

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/audit-log-streams/cribl-details.png" alt="cribl details" />

        Once you're finished, click **Create Log Stream**.
      </Step>
    </Steps>
  </Accordion>

  <Accordion title="Datadog">
    You can stream to Datadog using the **Datadog** provider log stream.

    <Steps>
      <Step title="Navigate to API Keys section">
                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/audit-log-streams/datadog-api-sidebar.png" alt="api key create" />
      </Step>

      <Step title="Select New Key and provide a key name">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/audit-log-streams/data-create-api-key.png" alt="api key form" />
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/audit-log-streams/data-dog-api-key.png" alt="api key form" />
      </Step>

      <Step title="Create Audit Log Stream on Infisical">
        On Infisical, create a new audit log stream and select the **Datadog** provider option.

        Input your **Datadog Region** and the **Token** obtained from step 2.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/audit-log-streams/datadog-details.png" alt="datadog details" />

        Once you're finished, click **Create Log Stream**.
      </Step>
    </Steps>
  </Accordion>

  <Accordion title="Splunk">
    You can stream to Splunk using the **Splunk** provider log stream.

    <Steps>
      <Step title="Obtain Splunk Token">
        Navigate to **Settings** > **Data Inputs**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/audit-log-streams/splunk-data-inputs.png" alt="splunk data inputs" />

        Click on **HTTP Event Collector**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/audit-log-streams/splunk-http-collector.png" alt="splunk http collector" />

        Click on **New Token** in the top left.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/audit-log-streams/splunk-new-token.png" alt="splunk new token" />

        Provide a name and click **Next**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/audit-log-streams/splunk-name.png" alt="splunk name" />

        On the next page, click **Review** and then **Submit** at the top. On the final page you'll see your token.

        Copy the **Token Value** and your Splunk hostname from the URL to be used for later.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/audit-log-streams/splunk-credentials.png" alt="splunk credentials" />
      </Step>

      <Step title="Create Audit Log Stream on Infisical">
        On Infisical, create a new audit log stream and select the **Splunk** provider option.

        Input your **Splunk Hostname** and the **Token** obtained from step 1.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/audit-log-streams/splunk-details.png" alt="splunk details" />

        Once you're finished, click **Create Log Stream**.
      </Step>
    </Steps>
  </Accordion>
</AccordionGroup>

### Example Log Entry

```created-secret.json  theme={"dark"}
{
  "id": "7dc1713b-d787-4147-9e21-770be01cc992",
  "actor": "user",
  "actorMetadata": {
    "email": "example@infisical.com",
    "userId": "7383b701-d83f-45c0-acb4-04e138b987ab",
    "username": "example@infisical.com"
  },
  "ipAddress": "127.0.0.1",
  "eventType": "create-secret",
  "eventMetadata": {
    "secretId": "3e5c796e-6599-4181-8dca-51133bb3acd0",
    "secretKey": "TEST-SECRET",
    "secretPath": "/",
    "environment": "dev",
    "secretVersion": 1
  },
  "userAgent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36",
  "userAgentType": "web",
  "expiresAt": "2025-01-18T01:11:25.552Z",
  "createdAt": "2025-01-15T01:11:25.552Z",
  "updatedAt": "2025-01-15T01:11:25.552Z",
  "orgId": "785649f1-ff4b-4ef9-a40a-9b9878e46e57",
  "projectId": "09bfcc01-0917-4bea-9c7a-2d320584d5b1",
  "projectName": "example-project"
}
```

### Audit Logs Structure

<Warning>
  Streamed audit log structure **varies based on provider**, but they all share the audit log fields shown below.
</Warning>

<ParamField path="id" type="string" required>
  The unique identifier for the log entry.
</ParamField>

<ParamField path="actor" type="platform | user | service | identity | scimClient | unknownUser" required>
  The entity responsible for performing or causing the event; this can be a user or service.
</ParamField>

<ParamField path="actorMetadata" type="object" required>
  The metadata associated with the actor. This varies based on the actor type.

  <AccordionGroup>
    <Accordion title="User Metadata">
      This metadata is present when the `actor` field is set to `user`.

      <ParamField path="userId" type="string" required>
        The unique identifier for the actor.
      </ParamField>

      <ParamField path="email" type="string" required>
        The email address of the actor.
      </ParamField>

      <ParamField path="username" type="string" required>
        The username of the actor.
      </ParamField>
    </Accordion>

    <Accordion title="Identity Metadata">
      This metadata is present when the `actor` field is set to `identity`.

      <ParamField path="identityId" type="string" required>
        The unique identifier for the identity.
      </ParamField>

      <ParamField path="name" type="string" required>
        The name of the identity.
      </ParamField>
    </Accordion>

    <Accordion title="Service Token Metadata">
      This metadata is present when the `actor` field is set to `service`.

      <ParamField path="serviceId" type="string" required>
        The unique identifier for the service.
      </ParamField>

      <ParamField path="name" type="string" required>
        The name of the service.
      </ParamField>
    </Accordion>
  </AccordionGroup>

  <Note>
    If the `actor` field is set to `platform`, `scimClient`, or `unknownUser`, the `actorMetadata` field will be an empty object.
  </Note>
</ParamField>

<ParamField path="ipAddress" type="string" required>
  The IP address of the actor.
</ParamField>

<ParamField path="eventType" type="string" required>
  The type of event that occurred. Below you can see a list of possible event types. More event types will be added in the future as we expand our audit logs further.

  `get-secrets`, `delete-secrets`, `get-secret`, `create-secret`, `update-secret`, `delete-secret`, `get-workspace-key`, `authorize-integration`, `update-integration-auth`, `unauthorize-integration`, `create-integration`, `delete-integration`, `add-trusted-ip`, `update-trusted-ip`, `delete-trusted-ip`, `create-service-token`, `delete-service-token`, `create-identity`, `update-identity`, `delete-identity`, `login-identity-universal-auth`, `add-identity-universal-auth`, `update-identity-universal-auth`, `get-identity-universal-auth`, `create-identity-universal-auth-client-secret`, `revoke-identity-universal-auth-client-secret`, `get-identity-universal-auth-client-secret`, `create-environment`, `update-environment`, `delete-environment`, `add-workspace-member`, `remove-workspace-member`, `create-folder`, `update-folder`, `delete-folder`, `create-webhook`, `update-webhook-status`, `delete-webhook`, `webhook-triggered`, `get-secret-imports`, `create-secret-import`, `update-secret-import`, `delete-secret-import`, `update-user-workspace-role`, `update-user-workspace-denied-permissions`, `create-certificate-authority`, `get-certificate-authority`, `update-certificate-authority`, `delete-certificate-authority`, `get-certificate-authority-csr`, `get-certificate-authority-cert`, `sign-intermediate`, `import-certificate-authority-cert`, `get-certificate-authority-crl`, `issue-cert`, `get-cert`, `delete-cert`, `revoke-cert`, `get-cert-body`, `create-pki-alert`, `get-pki-alert`, `update-pki-alert`, `delete-pki-alert`, `create-pki-collection`, `get-pki-collection`, `update-pki-collection`, `delete-pki-collection`, `get-pki-collection-items`, `add-pki-collection-item`, `delete-pki-collection-item`, `org-admin-accessed-project`, `create-certificate-template`, `update-certificate-template`, `delete-certificate-template`, `get-certificate-template`, `create-certificate-template-est-config`, `update-certificate-template-est-config`, `get-certificate-template-est-config`, `update-project-slack-config`, `get-project-slack-config`, `integration-synced`, `create-shared-secret`, `delete-shared-secret`, `read-shared-secret`.
</ParamField>

<ParamField path="eventMetadata" type="object" required>
  The metadata associated with the event. This varies based on the event type.
</ParamField>

<ParamField path="userAgent" type="string">
  The user agent of the actor, if applicable.
</ParamField>

<ParamField path="userAgentType" type="web | cli | k8-operator | terraform | other | InfisicalPythonSDK | InfisicalNodeSDK">
  The type of user agent.
</ParamField>

<ParamField path="expiresAt" type="string" required>
  The expiration date of the log entry. When this date is reached, the log entry will be deleted from Infisical.
</ParamField>

<ParamField path="createdAt" type="string" required>
  The creation date of the log entry.
</ParamField>

<ParamField path="updatedAt" type="string" required>
  The last update date of the log entry. This is unlikely to be out of sync with the `createdAt` field, as we do not update log entries after they've been created.
</ParamField>

<ParamField path="orgId" type="string" required>
  The unique identifier for the organization where the event occurred.
</ParamField>

<ParamField path="projectId" type="string">
  The unique identifier for the project where the event occurred.

  The `projectId` field will only be present if the event occurred at the project level, not the organization level.
</ParamField>

<ParamField path="projectName" type="string">
  The name of the project where the event occurred.

  The `projectName` field will only be present if the event occurred at the project level, not the organization level.
</ParamField>


# Stream to Non-HTTP providers
Source: https://infisical.com/docs/documentation/platform/audit-log-streams/audit-log-streams-with-fluentbit

How to stream Infisical Audit Logs to Non-HTTP log providers

<Info>
  Audit log streams is a paid feature.

  If you're using Infisical Cloud, then it is available under the **Enterprise Tier**. If you're self-hosting Infisical,
  then you should contact [team@infisical.com](mailto:team@infisical.com) to purchase an enterprise license to use it.
</Info>

This guide will demonstrate how you can send Infisical Audit log streams to storage solutions that do not support direct HTTP-based ingestion, such as AWS S3.
To achieve this, you will learn how you can use a log collector like Fluent Bit to capture and forward logs from Infisical to non-HTTP storage options.
In this pattern, Fluent Bit acts as an intermediary, accepting HTTP log streams from Infisical and transforming them into a format that can be sent to your desired storage provider.

## Overview

Log collectors are tools used to collect, analyze, transform, and send logs to storage.
For the purposes of this guide, we will use [Fluent Bit](https://fluentbit.io) as our log collector and send logs from Infisical to AWS S3.
However, this is just a example and you can use any log collector of your choice.

## Deploy Fluent Bit

You can deploy Fluent Bit in one of two ways:

1. As a sidecar to your self-hosted Infisical instance
2. As a standalone service in any deployment/compute service (e.g., AWS EC2, ECS, or GCP Compute Engine)

To view all deployment methods, visit the [Fluent Bit Getting Started guide](https://docs.fluentbit.io/manual/installation/getting-started-with-fluent-bit).

## Configure Fluent Bit

To set up Fluent Bit, you'll need to provide a configuration file that establishes an HTTP listener and configures an output to send JSON data to your chosen storage solution.

The following Fluent Bit configuration sets up an HTTP listener on port `8888` and sends logs to AWS S3:

```ini  theme={"dark"}
[SERVICE]
    Flush        1
    Log_Level    info
    Daemon       off

[INPUT]
    Name   http
    Listen 0.0.0.0
    Port   8888

[OUTPUT]
    Name                         s3
    Match                        *
    bucket                       my-bucket
    region                       us-west-2
    total_file_size              50M
    use_put_object               Off
    compression                  gzip
    s3_key_format                /$TAG/%Y/%m/%d/%H_%M_%S.gz
```

### Connecting Infisical Audit Log Stream

Once Fluent Bit is set up and configured, you can point the Infisical [audit log stream](/documentation/platform/audit-log-streams/audit-log-streams) to Fluent Bit's HTTP listener, which will then forward the logs to your chosen provider.
Using this pattern, you are able to send Infisical Audit logs to various providers that do not support HTTP based log ingestion by default.


# Overview
Source: https://infisical.com/docs/documentation/platform/audit-logs

Track all actions performed within Infisical

<Info>
  Note that Audit Logs is a paid feature.

  If you're using Infisical Cloud, then it is available under the **Pro**,
  and **Enterprise Tier** with varying retention periods. If you're self-hosting Infisical,
  then you should contact [sales@infisical.com](mailto:sales@infisical.com) to purchase an enterprise license to use it.
</Info>

Infisical provides audit logs for security and compliance teams to monitor information access.
With the Audit Log functionality, teams can:

* **Track** 40+ different events;
* **Filter** audit logs by event, actor, source, date or any combination of these filters;
* **Inspect** extensive metadata in the event of any suspicious activity or incident review.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/audit-logs/audit-logs-table.png" alt="Audit logs" />

## Audit Log Structure

Each log contains the following data:

| Field                     | Type     | Description                                               | Purpose                                                       |
| ------------------------- | -------- | --------------------------------------------------------- | ------------------------------------------------------------- |
| **event**                 | Object   | Contains details about the action performed               | Captures what happened                                        |
| event.type                | String   | The specific action that occurred (e.g., "create-secret") | Identifies the exact operation                                |
| event.metadata            | Object   | Context-specific details about the event                  | Provides detailed information relevant to the specific action |
| **actor**                 | Object   | Information about who performed the action                | Identifies the responsible entity                             |
| actor.type                | String   | Category of actor (user, service, identity, etc.)         | Distinguishes between human and non-human actors              |
| actor.metadata            | Object   | Details about the specific actor                          | Provides identity information                                 |
| actor.metadata.userId     | String   | Unique identifier for user actors                         | Links to specific user account                                |
| actor.metadata.email      | String   | Email address for user actors                             | Email of the executing user                                   |
| actor.metadata.username   | String   | Username for user actors                                  | Username of the executing user                                |
| actor.metadata.serviceId  | String   | Identifier for service actors                             | ID of specific service token                                  |
| actor.metadata.identityId | String   | Identifier for identity actors                            | ID to specific identity                                       |
| actor.metadata.permission | Object   | Permission context for the action                         | Shows permission template data when action was performed      |
| **orgId**                 | String   | Organization identifier                                   | Indicates which organization the action occurred in           |
| **projectId**             | String   | Project identifier                                        | Indicates which project the action affected                   |
| **ipAddress**             | String   | Source IP address                                         | Shows where the request originated from                       |
| **userAgent**             | String   | Client application information                            | Identifies browser or application used                        |
| **userAgentType**         | String   | Category of client (web, CLI, SDK, etc.)                  | Classifies the access method                                  |
| **timestamp**             | DateTime | When the action occurred                                  | Records the exact time of the event                           |

<Accordion title="Example Payload">
  ```json  theme={"dark"}
  {
     "id": "[UUID]",
     "ipAddress": "[IP_ADDRESS]",
     "userAgent": "[USER_AGENT_STRING]",
     "userAgentType": "web",
     "expiresAt": "[TIMESTAMP]",
     "createdAt": "[TIMESTAMP]",
     "updatedAt": "[TIMESTAMP]",
     "orgId": "[ORGANIZATION_UUID]",
     "projectId": "[PROJECT_UUID]",
     "projectName": "[PROJECT_NAME]",
     "event": {
         "type": "get-secrets",
         "metadata": {
             "secretPath": "[PATH]",
             "environment": "[ENVIRONMENT_NAME]",
             "numberOfSecrets": [NUMBER]
         }
     },
     "actor": {
         "type": "user",
         "metadata": {
             "email": "[EMAIL]",
             "userId": "[USER_UUID]",
             "username": "[USERNAME]",
             "permission": {
                 "metadata": {},
                 "auth": {}
             }
         }
     }
  }
  ```
</Accordion>


# Email and Password
Source: https://infisical.com/docs/documentation/platform/auth-methods/email-password

Learn how to authenticate into Infisical with email and password.

**Email and Password** is the most common authentication method that can be used by user identities for authentication into Web Dashboard and Infisical CLI. It is recommended to utilize [Multi-factor Authentication](/documentation/platform/mfa) in addition to it.

It is currently possible to use the **Email and Password** auth method to authenticate into the Web Dashboard and Infisical CLI.

### Emergency Kit

Every **Email and Password** is accompanied by an emergency kit given to users during signup. If the password is lost or forgotten, emergency kit is only way to retrieve the access to your account. It is possible to generate a new emergency kit with the following steps:

1. Open the `Personal Settings` menu.
   <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/auth-methods/access-personal-settings.png" alt="open personal settings" />
2. Scroll down to the `Emergency Kit` section.
3. Enter your current password and click `Save`.

### Change Password

You can update your account password at any time:

1. Open the `Personal Settings` menu.
   <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/auth-methods/access-personal-settings.png" alt="open personal settings" />
2. Navigate to the `Authentication` tab.
   <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/auth-methods/personal-settings-authentication-tab.png" alt="open authentication tab" />
3. In the `Change Password` section, enter your current password and new password.
   <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/auth-methods/personal-settings-authentication-change-email-password.png" alt="change password section" />
4. Click `Save` to save your new password.

### Change Email

You can update your account email address:

1. Open the `Personal Settings` menu.
2. Navigate to the `Authentication` tab.
3. In the `Change Email` section, enter your new email address.

<Info>
  If you don't currently have Email authentication enabled, it will be automatically activated when you change your email. You may disable it in the authentication settings after logging in with your new email if needed.
</Info>

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/auth-methods/personal-settings-authentication-change-email-password.png" alt="change email section" />
4\. Click `Send Verification Code` to receive an 6-digit verification code at your new email address.
5\. Check your new email inbox and enter the verification code.
<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/auth-methods/personal-settings-authentication-change-email-confirmation.png" alt="change email section" />
6\. Click `Confirm Email Change` to complete the process.
7\. You will be logged out and need to sign in again with your new email address.

<Tip>
  Changing your email will remove all connected external authentication methods and terminate all active sessions for security.
</Tip>

<Warning>
  Email changes are disabled if SCIM is enabled for any of your organizations. Contact your organization administrator if you need to change your email address in a SCIM-enabled environment.
</Warning>


# AWS ElastiCache
Source: https://infisical.com/docs/documentation/platform/dynamic-secrets/aws-elasticache

Learn how to dynamically generate AWS ElastiCache user credentials.

The Infisical AWS ElastiCache dynamic secret allows you to generate AWS ElastiCache credentials on demand based on configured role.

## Prerequisites

2. Create an AWS IAM user with the following permissions:

```json  theme={"dark"}
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "",
      "Effect": "Allow",
      "Action": [
        "elasticache:DescribeUsers",
        "elasticache:ModifyUser",
        "elasticache:CreateUser",
        "elasticache:CreateUserGroup",
        "elasticache:DeleteUser",
        "elasticache:DescribeReplicationGroups",
        "elasticache:DescribeUserGroups",
        "elasticache:ModifyReplicationGroup",
        "elasticache:ModifyUserGroup"
      ],
      "Resource": "arn:aws:elasticache:<region>:<account-id>:user:*"
    }
  ]
}
```

3. Create an access key ID and secret access key for the user you created in the previous step. You will need these to configure the Infisical dynamic secret.

<Note>
  New leases may take up-to a couple of minutes before ElastiCache has the chance to complete their configuration.
  It is recommended to use a retry strategy when establishing new ElastiCache connections.
  This may prevent errors when trying to use a password that isn't yet live on the targeted ElastiCache cluster.

  While a leasing is being created, you will be unable to create new leases for the same dynamic secret.
</Note>

<Note>
  Please ensure that your ElastiCache cluster has transit encryption enabled and set to required. This is required for the dynamic secret to work.
</Note>

## Set up Dynamic Secrets with AWS ElastiCache

<Steps>
  <Step title="Open Secret Overview Dashboard">
    Open the Secret Overview dashboard and select the environment in which you would like to add a dynamic secret.
  </Step>

  <Step title="Click on the 'Add Dynamic Secret' button">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/add-dynamic-secret-button.png" alt="Add Dynamic Secret Button" />
  </Step>

  <Step title="Select AWS ElastiCache">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-modal-aws-elasti-cache.png" alt="Dynamic Secret Modal" />
  </Step>

  <Step title="Provide the inputs for dynamic secret parameters">
    <ParamField path="Secret Name" type="string" required>
      Name by which you want the secret to be referenced
    </ParamField>

    <ParamField path="Default TTL" type="string" required>
      Default time-to-live for a generated secret (it is possible to modify this value after a secret is generated)
    </ParamField>

    <ParamField path="Max TTL" type="string" required>
      Maximum time-to-live for a generated secret.
    </ParamField>

    <ParamField path="Region" type="string" required>
      The region that the ElastiCache cluster is located in. *(e.g. us-east-1)*
    </ParamField>

    <ParamField path="Access Key ID" type="string" required>
      This is the access key ID of the AWS IAM user you created in the prerequisites. This will be used to provision and manage the dynamic secret leases.
    </ParamField>

    <ParamField path="Secret Access Key" type="string" required>
      This is the secret access key of the AWS IAM user you created in the prerequisites. This will be used to provision and manage the dynamic secret leases.
    </ParamField>

    <ParamField path="CA(SSL)" type="string">
      A CA may be required if your DB requires it for incoming connections. This is often the case when connecting to a managed service.
    </ParamField>
  </Step>

  <Step title="(Optional) Modify ElastiCache Statements">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/modify-elasticache-statement.png" alt="Modify ElastiCache Statements Modal" />

    <ParamField path="Username Template" type="string" default="{{randomUsername}}">
      Specifies a template for generating usernames. This field allows customization of how usernames are automatically created.

      Allowed template variables are

      * `{{randomUsername}}`: Random username string
      * `{{unixTimestamp}}`: Current Unix timestamp
      * `{{identity.name}}`: Name of the identity that is generating the secret
      * `{{random N}}`: Random string of N characters

      Allowed template functions are

      * `truncate`: Truncates a string to a specified length
      * `replace`: Replaces a substring with another value

      Examples:

      ```
      {{randomUsername}}                              // 3POnzeFyK9gW2nioK0q2gMjr6CZqsRiX
      {{unixTimestamp}}                               // 17490641580
      {{identity.name}}                               // testuser
      {{random-5}}                                    // x9k2m
      {{truncate identity.name 4}}                    // test
      {{replace identity.name 'user' 'replace'}}      // testreplace
      ```
    </ParamField>

    <ParamField path="Customize ElastiCache Statement" type="string">
      If you want to provide specific privileges for the generated dynamic credentials, you can modify the ElastiCache statement to your needs. This is useful if you want to only give access to a specific resource.
    </ParamField>
  </Step>

  <Step title="Click `Submit`">
    After submitting the form, you will see a dynamic secret created in the dashboard.

    <Note>
      If this step fails, you may have to add the CA certificate.
    </Note>
  </Step>

  <Step title="Generate dynamic secrets">
    Once you've successfully configured the dynamic secret, you're ready to generate on-demand credentials.
    To do this, simply click on the 'Generate' button which appears when hovering over the dynamic secret item.
    Alternatively, you can initiate the creation of a new lease by selecting 'New Lease' from the dynamic secret lease list section.

    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-generate.png" alt="Dynamic Secret" />
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-lease-empty.png" alt="Dynamic Secret" />

    When generating these secrets, it's important to specify a Time-to-Live (TTL) duration. This will dictate how long the credentials are valid for.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/provision-lease.png" alt="Provision Lease" />

    <Tip>
      Ensure that the TTL for the lease falls within the maximum TTL defined when configuring the dynamic secret.
    </Tip>

    Once you click the `Submit` button, a new secret lease will be generated and the credentials from it will be shown to you.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/lease-values.png" alt="Provision Lease" />
  </Step>
</Steps>

## Audit or Revoke Leases

Once you have created one or more leases, you will be able to access them by clicking on the respective dynamic secret item on the dashboard.
This will allow you to see the expiration time of the lease or delete a lease before it's set time to live.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/lease-data.png" alt="Provision Lease" />

## Renew Leases

To extend the life of the generated dynamic secret leases past its initial time to live, simply click on the **Renew** button as illustrated below.
<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-lease-renew.png" alt="Provision Lease" />

<Warning>
  Lease renewals cannot exceed the maximum TTL set when configuring the dynamic secret
</Warning>


# AWS IAM
Source: https://infisical.com/docs/documentation/platform/dynamic-secrets/aws-iam

Learn how to dynamically generate AWS IAM Users.

The Infisical AWS IAM dynamic secret allows you to generate AWS IAM Users and temporary credentials on demand based on a configured AWS policy. Infisical supports several authentication methods to connect to your AWS account, including assuming an IAM Role, using IAM Roles for Service Accounts (IRSA) on EKS, or static Access Keys.

## AWS STS Duration Limits

When using **Temporary Credentials**, AWS STS has specific maximum duration limits:

* **AssumeRole operations**: Maximum 1 hour (3600 seconds) when using temporary credentials
* **GetSessionToken operations** (Access Key & IRSA): Maximum 12 hours (43200 seconds)

<Info>
  **Automatic Duration Adjustment**: If you specify a TTL that exceeds these AWS limits, Infisical will automatically use the maximum allowed duration instead of failing the operation. This ensures your dynamic secrets work reliably within AWS constraints.
</Info>

## Prerequisite

Infisical needs an AWS IAM principal (a user or a role) with the required permissions to create and manage other IAM users and temporary credentials. This principal will be responsible for the lifecycle of the dynamically generated users and temporary credentials.

<Accordion title="Required IAM Permissions">
  <Tabs>
    <Tab title="IAM User">
      Required permissions for creating temporary IAM users:

      ```json  theme={"dark"}
      {
        "Version": "2012-10-17",
        "Statement": [
          {
            "Effect": "Allow",
            "Action": [
              "iam:AttachUserPolicy",
              "iam:CreateAccessKey",
              "iam:CreateUser",
              "iam:DeleteAccessKey",
              "iam:DeleteUser",
              "iam:DeleteUserPolicy",
              "iam:DetachUserPolicy",
              "iam:GetUser",
              "iam:ListAccessKeys",
              "iam:ListAttachedUserPolicies",
              "iam:ListGroupsForUser",
              "iam:ListUserPolicies",
              "iam:PutUserPolicy",
              "iam:AddUserToGroup",
              "iam:RemoveUserFromGroup",
              "iam:TagUser"
            ],
            "Resource": ["*"]
          }
        ]
      }
      ```

      To minimize managing user access you can attach a resource in format

      > arn:aws:iam::\<account-id>:user/\<aws-scope-path>

      Replace **\<account id>** with your AWS account id and **\<aws-scope-path>** with a path to minimize managing user access.
    </Tab>

    <Tab title="Temporary Credentials">
      Required permissions for Access Key and Assume Role methods:

      ```json  theme={"dark"}
      {
        "Version": "2012-10-17",
        "Statement": [
          {
            "Effect": "Allow",
            "Action": [
              "sts:GetSessionToken",
              "sts:AssumeRole"
            ],
            "Resource": ["*"]
          }
        ]
      }
      ```

      To minimize managing user access you can attach a resource in format

      > arn:aws:iam::\<account-id>:user/\<aws-scope-path>

      Replace **\<account id>** with your AWS account id and **\<aws-scope-path>** with a path to minimize managing user access.
    </Tab>
  </Tabs>
</Accordion>

## Set up Dynamic Secrets with AWS IAM

<Tabs>
  <Tab title="Assume Role (Recommended)">
    Infisical will assume the provided role in your AWS account securely, without the need to share any credentials.

    <Accordion title="Self-Hosted Instance">
      To connect your self-hosted Infisical instance with AWS, you need to set up an AWS IAM User account that can assume the configured AWS IAM Role.

      If your instance is deployed on AWS, the aws-sdk will automatically retrieve the credentials. Ensure that you assign the provided permission policy to your deployed instance, such as ECS or EC2.

      The following steps are for instances not deployed on AWS:

      <Steps>
        <Step title="Create an IAM User">
          Navigate to [Create IAM User](https://console.aws.amazon.com/iamv2/home#/users/create) in your AWS Console.
        </Step>

        <Step title="Create an Inline Policy">
          Attach the following inline permission policy to the IAM User to allow it to assume any IAM Roles:

          ```json  theme={"dark"}
          {
              "Version": "2012-10-17",
              "Statement": [
          {
              "Sid": "AllowAssumeAnyRole",
              "Effect": "Allow",
              "Action": "sts:AssumeRole",
              "Resource": "arn:aws:iam::*:role/*"
          }
              ]
          }
          ```
        </Step>

        <Step title="Obtain the IAM User Credentials">
          Obtain the AWS access key ID and secret access key for your IAM User by navigating to **IAM > Users > \[Your User] > Security credentials > Access keys**.

          <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/aws/integrations-aws-access-key-1.png" alt="Access Key Step 1" />
          <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/aws/integrations-aws-access-key-2.png" alt="Access Key Step 2" />
          <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/aws/integrations-aws-access-key-3.png" alt="Access Key Step 3" />
        </Step>

        <Step title="Set Up Connection Keys">
          1. Set the access key as **DYNAMIC\_SECRET\_AWS\_ACCESS\_KEY\_ID**.
          2. Set the secret key as **DYNAMIC\_SECRET\_AWS\_SECRET\_ACCESS\_KEY**.
        </Step>
      </Steps>
    </Accordion>

    <Steps>
      <Step title="Create the Managing User IAM Role for Infisical">
        1. Navigate to the [Create IAM Role](https://console.aws.amazon.com/iamv2/home#/roles/create?step=selectEntities) page in your AWS Console.
           <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/aws/integration-aws-iam-assume-role.png" alt="IAM Role Creation" />

        2. Select **AWS Account** as the **Trusted Entity Type**.

        3. Select **Another AWS Account** and provide the appropriate Infisical AWS Account ID: use **381492033652** for the **US region**, and **345594589636** for the **EU region**. This restricts the role to be assumed only by Infisical. If self-hosting, provide your AWS account number instead.

        <Note>
          **For Dedicated Instances**: Your AWS account ID differs from the one provided above. Please reach out to Infisical support to obtain your AWS account ID.
        </Note>

        4. (Recommended) <strong>Enable "Require external ID"</strong> and input your **Project ID** to strengthen security and mitigate the [confused deputy problem](https://docs.aws.amazon.com/IAM/latest/UserGuide/confused-deputy.html).
        5. Assign permission as shared in prerequisite.

        <Warning type="warning" title="Security Best Practice: Use External ID to Prevent Confused Deputy Attacks">
          When configuring an IAM Role that Infisical will assume, its highly recommended to enable the **"Require external ID"** option and specify your **Project ID**.

          This precaution helps protect your AWS account against the [confused deputy problem](https://docs.aws.amazon.com/IAM/latest/UserGuide/confused-deputy.html), a potential security vulnerability where Infisical could be tricked into performing actions on your behalf by an unauthorized actor.

          <strong>Always enable "Require external ID" and use your Project ID when setting up the IAM Role.</strong>
        </Warning>
      </Step>

      <Step title="Copy the AWS IAM Role ARN">
                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/aws/integration-aws-iam-assume-arn.png" alt="Copy IAM Role ARN" />
      </Step>

      <Step title="Secret Overview Dashboard">
        Navigate to the Secret Overview dashboard and select the environment in which you would like to add a dynamic secret to.
      </Step>

      <Step title="Click on the 'Add Dynamic Secret' button">
                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/add-dynamic-secret-button.png" alt="Add Dynamic Secret Button" />
      </Step>

      <Step title="Select AWS IAM">
                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-modal-aws-iam.png" alt="Dynamic Secret Modal" />
      </Step>

      <Step title="Provide the inputs for dynamic secret parameters">
                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-setup-modal-aws-iam-assume-role.png" alt="Dynamic Secret Setup Modal" />

        <ParamField path="Secret Name" type="string" required>
          Name by which you want the secret to be referenced
        </ParamField>

        <ParamField path="Default TTL" type="string" required>
          Default time-to-live for a generated secret (it is possible to modify this value after a secret is generated)
        </ParamField>

        <ParamField path="Max TTL" type="string" required>
          Maximum time-to-live for a generated secret
        </ParamField>

        <ParamField path="Username Template" type="string" default="{{randomUsername}}">
          Specifies a template for generating usernames. This field allows customization of how usernames are automatically created.

          Allowed template variables are

          * `{{randomUsername}}`: Random username string
          * `{{unixTimestamp}}`: Current Unix timestamp
          * `{{identity.name}}`: Name of the identity that is generating the secret
          * `{{random N}}`: Random string of N characters

          Allowed template functions are

          * `truncate`: Truncates a string to a specified length
          * `replace`: Replaces a substring with another value

          Examples:

          ```
          {{randomUsername}}                              // 3POnzeFyK9gW2nioK0q2gMjr6CZqsRiX
          {{unixTimestamp}}                               // 17490641580
          {{identity.name}}                               // testuser
          {{random-5}}                                    // x9k2m
          {{truncate identity.name 4}}                    // test
          {{replace identity.name 'user' 'replace'}}      // testreplace
          ```
        </ParamField>

        <ParamField path="Tags" type="map<string, string>[]">
          Tags to be added to the created IAM User resource.
        </ParamField>

        <ParamField path="Method" type="string" required>
          Select *Assume Role* method.
        </ParamField>

        <ParamField path="Credential Type" type="string" required>
          Choose the credential generation approach:

          * **IAM User (Default)**: Creates new temporary IAM users in your AWS account
          * **Temporary Credentials**: Generates temporary credentials from your role connection
        </ParamField>

        <ParamField path="Aws Role ARN" type="string" required>
          The ARN of the AWS Role to assume.
        </ParamField>

        <ParamField path="AWS Region" type="string" required>
          The AWS data center region.
        </ParamField>

        <Tabs>
          <Tab title="IAM User">
            <ParamField path="AWS IAM Path" type="string">
              [IAM AWS Path](https://aws.amazon.com/blogs/security/optimize-aws-administration-with-iam-paths/) to scope created IAM User resource access.
            </ParamField>

            <ParamField path="IAM User Permission Boundary" type="string">
              The IAM Policy ARN of the [AWS Permissions Boundary](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html) to attach to IAM users created in the role.
            </ParamField>

            <ParamField path="AWS IAM Groups" type="string">
              The AWS IAM groups that should be assigned to the created users. Multiple values can be provided by separating them with commas.
            </ParamField>

            <ParamField path="AWS Policy ARNs" type="string">
              The AWS IAM managed policies that should be attached to the created users. Multiple values can be provided by separating them with commas.
            </ParamField>

            <ParamField path="AWS IAM Policy Document" type="string">
              The AWS IAM inline policy that should be attached to the created users. Multiple values can be provided by separating them with commas.
            </ParamField>

            <ParamField path="Username Template" type="string" default="{{randomUsername}}">
              Specifies a template for generating usernames. This field allows customization of how usernames are automatically created.

              Allowed template variables are:

              * `{{randomUsername}}`: Random username string
              * `{{unixTimestamp}}`: Current Unix timestamp
              * `{{identity.name}}`: Name of the identity that is generating the secret
              * `{{random N}}`: Random string of N characters

              Allowed template functions are:

              * `truncate`: Truncates a string to a specified length
              * `replace`: Replaces a substring with another value
            </ParamField>

            <ParamField path="Tags" type="map<string, string>[]">
              Tags to be added to the created IAM User resource.
            </ParamField>
          </Tab>

          <Tab title="Temporary Credentials">
            When **Credential Type** is set to **Temporary Credentials**:

            <Info>
              No additional configuration parameters are required. The generated credentials will:

              * Inherit the permissions of the assumed role
              * Include an AWS Session Token
              * Be valid for the duration specified in Default TTL
            </Info>

            <Warning>
              **Duration Limit**: AssumeRole temporary credentials are limited to 1 hour maximum by AWS. TTL values exceeding this limit will be automatically adjusted to 1 hour.
            </Warning>
          </Tab>
        </Tabs>
      </Step>

      <Step title="Click 'Submit'">
        After submitting the form, you will see a dynamic secret created in the dashboard.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret.png" alt="Dynamic Secret" />
      </Step>

      <Step title="Generate dynamic secrets">
        Once you've successfully configured the dynamic secret, you're ready to generate on-demand credentials.
        To do this, simply click on the 'Generate' button which appears when hovering over the dynamic secret item.
        Alternatively, you can initiate the creation of a new lease by selecting 'New Lease' from the dynamic secret lease list section.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-generate.png" alt="Dynamic Secret" />
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-lease-empty.png" alt="Dynamic Secret" />

        When generating these secrets, it's important to specify a Time-to-Live (TTL) duration. This will dictate how long the credentials are valid for.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/provision-lease.png" alt="Provision Lease" />

        <Tip>
          Ensure that the TTL for the lease falls within the maximum TTL defined when configuring the dynamic secret in step 4.
        </Tip>

        Once you click the `Submit` button, a new secret lease will be generated and the credentials for it will be shown to you.

        **Credentials format depends on your chosen credential type:**

        **IAM User credential type:**

        * AWS Username
        * AWS Access Key ID
        * AWS Secret Access Key

        **Temporary Credentials credential type:**

        * AWS Access Key ID
        * AWS Secret Access Key
        * AWS Session Token

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/lease-values-aws-iam.png" alt="Provision Lease" />
      </Step>
    </Steps>
  </Tab>

  <Tab title="IRSA (EKS)">
    This method is recommended for self-hosted Infisical instances running on AWS EKS. It uses [IAM Roles for Service Accounts (IRSA)](https://docs.aws.amazon.com/eks/latest/userguide/iam-roles-for-service-accounts.html) to securely grant permissions to the Infisical pods without managing static credentials.

    <Warning type="warning" title="IRSA Configuration Prerequisite">
      In order to use IRSA, the `KUBERNETES_AUTO_FETCH_SERVICE_ACCOUNT_TOKEN` environment variable must be set to `true` for your self-hosted Infisical instance.
    </Warning>

    <Steps>
      <Step title="Create an IAM OIDC provider for your cluster">
        If you don't already have one, you need to create an IAM OIDC provider for your EKS cluster. This allows IAM to trust authentication tokens from your Kubernetes cluster.

        1. Find your cluster's OIDC provider URL from the EKS console or by using the AWS CLI:
           `aws eks describe-cluster --name <your-cluster-name> --query "cluster.identity.oidc.issuer" --output text`
        2. Navigate to the [IAM Identity Providers](https://console.aws.amazon.com/iam/home#/providers) page in your AWS Console and create a new OpenID Connect provider with the URL and `sts.amazonaws.com` as the audience.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/aws/irsa-create-oidc-provider.png" alt="Create OIDC Provider Placeholder" />
      </Step>

      <Step title="Create the Managing User IAM Role for Infisical">
        1. Navigate to the [Create IAM Role](https://console.aws.amazon.com/iamv2/home#/roles/create?step=selectEntities) page in your AWS Console.
        2. Select **Web identity** as the **Trusted Entity Type**.
        3. Choose the OIDC provider you created in the previous step.
        4. For the **Audience**, select `sts.amazonaws.com`.
           <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/aws/irsa-iam-role-creation.png" alt="IAM Role Creation for IRSA" />
        5. Attach the permission policy detailed in the **Prerequisite** section at the top of this page.
        6. After creating the role, edit its **Trust relationship** to specify the service account Infisical is using in your cluster. This ensures only the Infisical pod can assume this role.

        ```json  theme={"dark"}
        {
            "Version": "2012-10-17",
            "Statement": [
                {
                    "Effect": "Allow",
                    "Principal": {
                        "Federated": "arn:aws:iam::<ACCOUNT_ID>:oidc-provider/oidc.eks.<REGION>.amazonaws.com/id/<OIDC_ID>"
                    },
                    "Action": "sts:AssumeRoleWithWebIdentity",
                    "Condition": {
                        "StringEquals": {
                            "oidc.eks.<REGION>.amazonaws.com/id/<OIDC_ID>:sub": "system:serviceaccount:<K8S_NAMESPACE>:<INFISICAL_SERVICE_ACCOUNT_NAME>",
                            "oidc.eks.<REGION>.amazonaws.com/id/<OIDC_ID>:aud": "sts.amazonaws.com"
                        }
                    }
                }
            ]
        }
        ```

        Replace `<ACCOUNT_ID>`, `<REGION>`, `<OIDC_ID>`, `<K8S_NAMESPACE>`, and `<INFISICAL_SERVICE_ACCOUNT_NAME>` with your specific values.
      </Step>

      <Step title="Annotate the Infisical Kubernetes Service Account">
        For the IRSA mechanism to work, the Infisical service account in your Kubernetes cluster must be annotated with the ARN of the IAM role you just created.

        Run the following command, replacing the placeholders with your values:

        ```bash  theme={"dark"}
        kubectl annotate serviceaccount -n <infisical-namespace> <infisical-service-account> \
        eks.amazonaws.com/role-arn=arn:aws:iam::<account-id>:role/<iam-role-name>
        ```

        This annotation tells the EKS Pod Identity Webhook to inject the necessary environment variables and tokens into the Infisical pod, allowing it to assume the specified IAM role.
      </Step>

      <Step title="Secret Overview Dashboard">
        Navigate to the Secret Overview dashboard and select the environment in which you would like to add a dynamic secret to.
      </Step>

      <Step title="Click on the 'Add Dynamic Secret' button">
                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/add-dynamic-secret-button.png" alt="Add Dynamic Secret Button" />
      </Step>

      <Step title="Select AWS IAM">
                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-modal-aws-iam.png" alt="Dynamic Secret Modal" />
      </Step>

      <Step title="Provide the inputs for dynamic secret parameters">
                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-setup-modal-aws-iam-irsa.png" alt="Dynamic Secret Setup Modal for IRSA" />

        <ParamField path="Secret Name" type="string" required>
          Name by which you want the secret to be referenced
        </ParamField>

        <ParamField path="Default TTL" type="string" required>
          Default time-to-live for a generated secret (it is possible to modify this value after a secret is generated)
        </ParamField>

        <ParamField path="Max TTL" type="string" required>
          Maximum time-to-live for a generated secret
        </ParamField>

        <ParamField path="Username Template" type="string" default="{{randomUsername}}">
          Specifies a template for generating usernames. This field allows customization of how usernames are automatically created.

          Allowed template variables are

          * `{{randomUsername}}`: Random username string
          * `{{unixTimestamp}}`: Current Unix timestamp
          * `{{identity.name}}`: Name of the identity that is generating the secret
          * `{{random N}}`: Random string of N characters

          Allowed template functions are

          * `truncate`: Truncates a string to a specified length
          * `replace`: Replaces a substring with another value

          Examples:

          ```
          {{randomUsername}}                              // 3POnzeFyK9gW2nioK0q2gMjr6CZqsRiX
          {{unixTimestamp}}                               // 17490641580
          {{identity.name}}                               // testuser
          {{random-5}}                                    // x9k2m
          {{truncate identity.name 4}}                    // test
          {{replace identity.name 'user' 'replace'}}      // testreplace
          ```
        </ParamField>

        <ParamField path="Tags" type="map<string, string>[]">
          Tags to be added to the created IAM User resource.
        </ParamField>

        <ParamField path="Method" type="string" required>
          Select *IRSA* method.
        </ParamField>

        <ParamField path="Credential Type" type="string" required>
          Choose the credential generation approach:

          * **IAM User**: Creates new temporary IAM users in your AWS account
          * **Temporary Credentials**: Generates temporary credentials from your IRSA role connection
        </ParamField>

        <ParamField path="Aws Role ARN" type="string" required>
          The ARN of the AWS IAM Role for the service account to assume.
        </ParamField>

        <ParamField path="AWS Region" type="string" required>
          The AWS data center region.
        </ParamField>

        <Tabs>
          <Tab title="IAM User">
            <ParamField path="AWS IAM Path" type="string">
              [IAM AWS Path](https://aws.amazon.com/blogs/security/optimize-aws-administration-with-iam-paths/) to scope created IAM User resource access.
            </ParamField>

            <ParamField path="IAM User Permission Boundary" type="string">
              The IAM Policy ARN of the [AWS Permissions Boundary](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html) to attach to IAM users created in the role.
            </ParamField>

            <ParamField path="AWS IAM Groups" type="string">
              The AWS IAM groups that should be assigned to the created users. Multiple values can be provided by separating them with commas.
            </ParamField>

            <ParamField path="AWS Policy ARNs" type="string">
              The AWS IAM managed policies that should be attached to the created users. Multiple values can be provided by separating them with commas.
            </ParamField>

            <ParamField path="AWS IAM Policy Document" type="string">
              The AWS IAM inline policy that should be attached to the created users. Multiple values can be provided by separating them with commas.
            </ParamField>

            <ParamField path="Username Template" type="string" default="{{randomUsername}}">
              Specifies a template for generating usernames. This field allows customization of how usernames are automatically created.

              Allowed template variables are:

              * `{{randomUsername}}`: Random username string
              * `{{unixTimestamp}}`: Current Unix timestamp
              * `{{identity.name}}`: Name of the identity that is generating the secret
              * `{{random N}}`: Random string of N characters

              Allowed template functions are:

              * `truncate`: Truncates a string to a specified length
              * `replace`: Replaces a substring with another value
            </ParamField>

            <ParamField path="Tags" type="map<string, string>[]">
              Tags to be added to the created IAM User resource.
            </ParamField>
          </Tab>

          <Tab title="Temporary Credentials">
            When **Credential Type** is set to **Temporary Credentials**:

            <Info>
              No additional configuration parameters are required. The generated credentials will:

              * Inherit the permissions of the assumed IRSA role
              * Include an AWS Session Token
              * Be valid for the duration specified in Default TTL
            </Info>

            <Note>
              **Duration Limit**: IRSA temporary credentials support up to 12 hours maximum via GetSessionToken. TTL values exceeding this limit will be automatically adjusted.
            </Note>
          </Tab>
        </Tabs>
      </Step>

      <Step title="Click 'Submit'">
        After submitting the form, you will see a dynamic secret created in the dashboard.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret.png" alt="Dynamic Secret" />
      </Step>

      <Step title="Generate dynamic secrets">
        Once you've successfully configured the dynamic secret, you're ready to generate on-demand credentials.
        To do this, simply click on the 'Generate' button which appears when hovering over the dynamic secret item.
        Alternatively, you can initiate the creation of a new lease by selecting 'New Lease' from the dynamic secret lease list section.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-generate.png" alt="Dynamic Secret" />
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-lease-empty.png" alt="Dynamic Secret" />

        When generating these secrets, it's important to specify a Time-to-Live (TTL) duration. This will dictate how long the credentials are valid for.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/provision-lease.png" alt="Provision Lease" />

        <Tip>
          Ensure that the TTL for the lease falls within the maximum TTL defined when configuring the dynamic secret in step 4.
        </Tip>

        Once you click the `Submit` button, a new secret lease will be generated and the credentials for it will be shown to you.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/lease-values-aws-iam.png" alt="Provision Lease" />
      </Step>
    </Steps>
  </Tab>

  <Tab title="Access Key">
    Infisical will use the provided **Access Key ID** and **Secret Key** to connect to your AWS instance.

    <Steps>
      <Step title="Secret Overview Dashboard">
        Navigate to the Secret Overview dashboard and select the environment in which you would like to add a dynamic secret to.
      </Step>

      <Step title="Click on the 'Add Dynamic Secret' button">
                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/add-dynamic-secret-button.png" alt="Add Dynamic Secret Button" />
      </Step>

      <Step title="Select AWS IAM">
                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-modal-aws-iam.png" alt="Dynamic Secret Modal" />
      </Step>

      <Step title="Provide the inputs for dynamic secret parameters">
                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-setup-modal-aws-iam-access-key.png" alt="Dynamic Secret Setup Modal" />

        <ParamField path="Secret Name" type="string" required>
          Name by which you want the secret to be referenced
        </ParamField>

        <ParamField path="Default TTL" type="string" required>
          Default time-to-live for a generated secret (it is possible to modify this value after a secret is generated)
        </ParamField>

        <ParamField path="Max TTL" type="string" required>
          Maximum time-to-live for a generated secret
        </ParamField>

        <ParamField path="Method" type="string" required>
          Select *Access Key* method.
        </ParamField>

        <ParamField path="Credential Type" type="string" required>
          Choose the credential generation approach:

          * **IAM User**: Creates new temporary IAM users in your AWS account
          * **Temporary Credentials**: Generates temporary credentials from your access key connection
        </ParamField>

        <ParamField path="AWS Access Key" type="string" required>
          The managing AWS IAM User Access Key
        </ParamField>

        <ParamField path="AWS Secret Key" type="string" required>
          The managing AWS IAM User Secret Key
        </ParamField>

        <ParamField path="AWS Region" type="string" required>
          The AWS data center region.
        </ParamField>

        <Tabs>
          <Tab title="IAM User">
            <ParamField path="AWS IAM Path" type="string">
              [IAM AWS Path](https://aws.amazon.com/blogs/security/optimize-aws-administration-with-iam-paths/) to scope created IAM User resource access.
            </ParamField>

            <ParamField path="IAM User Permission Boundary" type="string">
              The IAM Policy ARN of the [AWS Permissions Boundary](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html) to attach to IAM users created in the role.
            </ParamField>

            <ParamField path="AWS IAM Groups" type="string">
              The AWS IAM groups that should be assigned to the created users. Multiple values can be provided by separating them with commas.
            </ParamField>

            <ParamField path="AWS Policy ARNs" type="string">
              The AWS IAM managed policies that should be attached to the created users. Multiple values can be provided by separating them with commas.
            </ParamField>

            <ParamField path="AWS IAM Policy Document" type="string">
              The AWS IAM inline policy that should be attached to the created users. Multiple values can be provided by separating them with commas.
            </ParamField>

            <ParamField path="Username Template" type="string" default="{{randomUsername}}">
              Specifies a template for generating usernames. This field allows customization of how usernames are automatically created.

              Allowed template variables are:

              * `{{randomUsername}}`: Random username string
              * `{{unixTimestamp}}`: Current Unix timestamp
              * `{{identity.name}}`: Name of the identity that is generating the secret
              * `{{random N}}`: Random string of N characters

              Allowed template functions are:

              * `truncate`: Truncates a string to a specified length
              * `replace`: Replaces a substring with another value
            </ParamField>

            <ParamField path="Tags" type="map[string]string">
              Tags to be added to the created IAM User resource.
            </ParamField>
          </Tab>

          <Tab title="Temporary Credentials">
            When **Credential Type** is set to **Temporary Credentials**:

            <Info>
              No additional configuration parameters are required. The generated credentials will:

              * Inherit the permissions of your access key connection
              * Include an AWS Session Token
              * Be valid for the duration specified in Default TTL
            </Info>

            <Note>
              **Duration Limit**: Access Key temporary credentials support up to 12 hours maximum via GetSessionToken. TTL values exceeding this limit will be automatically adjusted.
            </Note>
          </Tab>
        </Tabs>
      </Step>

      <Step title="Click 'Submit'">
        After submitting the form, you will see a dynamic secret created in the dashboard.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret.png" alt="Dynamic Secret" />
      </Step>

      <Step title="Generate dynamic secrets">
        Once you've successfully configured the dynamic secret, you're ready to generate on-demand credentials.
        To do this, simply click on the 'Generate' button which appears when hovering over the dynamic secret item.
        Alternatively, you can initiate the creation of a new lease by selecting 'New Lease' from the dynamic secret lease list section.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-generate.png" alt="Dynamic Secret" />
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-lease-empty.png" alt="Dynamic Secret" />

        When generating these secrets, it's important to specify a Time-to-Live (TTL) duration. This will dictate how long the credentials are valid for.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/provision-lease.png" alt="Provision Lease" />

        <Tip>
          Ensure that the TTL for the lease falls within the maximum TTL defined when configuring the dynamic secret in step 4.
        </Tip>

        Once you click the `Submit` button, a new secret lease will be generated and the credentials for it will be shown to you.

        **Credentials format depends on your chosen credential type:**

        **IAM User credential type:**

        * AWS Username
        * AWS Access Key ID
        * AWS Secret Access Key

        **Temporary Credentials credential type:**

        * AWS Access Key ID
        * AWS Secret Access Key
        * AWS Session Token

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/lease-values-aws-iam.png" alt="Provision Lease" />
      </Step>
    </Steps>
  </Tab>
</Tabs>

## Audit or Revoke Leases

Once you have created one or more leases, you will be able to access them by clicking on the respective dynamic secret item on the dashboard.
This will allow you to see the lease details and delete the lease ahead of its expiration time.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/lease-data.png" alt="Provision Lease" />

## Renew Leases

To extend the life of the generated dynamic secret lease past its initial time to live, simply click on the **Renew** button as illustrated below.
<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-lease-renew.png" alt="Provision Lease" />

<Warning>
  Lease renewals cannot exceed the maximum TTL set when configuring the dynamic
  secret
</Warning>


# Azure Entra Id
Source: https://infisical.com/docs/documentation/platform/dynamic-secrets/azure-entra-id

Learn how to dynamically generate Azure Entra Id user credentials.

The Infisical Azure Entra Id dynamic secret allows you to generate Azure Entra Id credentials on demand based on configured role.

## Prerequisites

<Steps>
  <Step>
    Login to [Microsoft Entra ID](https://entra.microsoft.com/)
  </Step>

  <Step>
    Go to Overview, Copy and store `Tenant Id`
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-ad-tenant-id.png" alt="Copy Tenant Id" />
  </Step>

  <Step>
    Go to Applications > App registrations. Click on New Registration.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-ad-new-registration.png" alt="Copy Tenant Id" />
  </Step>

  <Step>
    Enter an application name. Click Register.
  </Step>

  <Step>
    Copy and store `Application Id`.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-ad-copy-app-id.png" alt="Copy Application Id" />
  </Step>

  <Step>
    Go to Clients and Secrets. Click on New Client Secret.
  </Step>

  <Step>
    Enter a description, select expiry and click Add.
  </Step>

  <Step>
    Copy and store `Client Secret` value.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-ad-add-client-secret.png" alt="Copy client Secret" />
  </Step>

  <Step>
    Go to API Permissions. Click on Add a permission.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-ad-add-permission.png" alt="Click add a permission" />
  </Step>

  <Step>
    Click on Microsoft Graph.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-ad-select-graph.png" alt="Click Microsoft Graph" />
  </Step>

  <Step>
    Click on Application Permissions. Search and select `User.ReadWrite.All` and click Add permissions.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-ad-select-perms.png" alt="Add User.Read.All" />
  </Step>

  <Step>
    Click on Grant admin consent for app. Click yes to confirm.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-ad-admin-consent.png" alt="Grant admin consent" />
  </Step>

  <Step>
    Go to Dashboard. Click on show more.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-ad-show-more.png" alt="Show more" />
  </Step>

  <Step>
    Click on Roles & admins. Search for User Administrator and click on it.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-ad-user-admin.png" alt="User Administrator" />
  </Step>

  <Step>
    Click on Add assignments. Search for the application name you created and select it. Click on Add.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-ad-add-assignments.png" alt="Add assignments" />
  </Step>
</Steps>

## Set up Dynamic Secrets with Azure Entra ID

<Steps>
  <Step title="Open Secret Overview Dashboard">
    Open the Secret Overview dashboard and select the environment in which you would like to add a dynamic secret.
  </Step>

  <Step title="Click on the 'Add Dynamic Secret' button">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/add-dynamic-secret-button.png" alt="Add Dynamic Secret Button" />
  </Step>

  <Step title="Select 'Azure Entra ID'">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-ad-modal.png" alt="Dynamic Secret Modal" />
  </Step>

  <Step title="Provide the inputs for dynamic secret parameters">
    <ParamField path="Secret Prefix" type="string" required>
      Prefix for the secrets to be created
    </ParamField>

    <ParamField path="Default TTL" type="string" required>
      Default time-to-live for a generated secret (it is possible to modify this value after a secret is generated)
    </ParamField>

    <ParamField path="Max TTL" type="string" required>
      Maximum time-to-live for a generated secret.
    </ParamField>

    <ParamField path="Tenant ID" type="string" required>
      The Tenant ID of your Azure Entra ID account.
    </ParamField>

    <ParamField path="Application ID" type="string" required>
      The Application ID of the application you created in Azure Entra ID.
    </ParamField>

    <ParamField path="Client Secret" type="string" required>
      The Client Secret of the application you created in Azure Entra ID.
    </ParamField>

    <ParamField path="Users" type="selection" required>
      Multi select list of users to generate secrets for.
    </ParamField>
  </Step>

  <Step title="Click `Submit`">
    After submitting the form, you will see a dynamic secret for each user created in the dashboard.
  </Step>

  <Step title="Generate dynamic secrets">
    Once you've successfully configured the dynamic secret, you're ready to generate on-demand credentials.
    To do this, simply click on the 'Generate' button which appears when hovering over the dynamic secret item.
    Alternatively, you can initiate the creation of a new lease by selecting 'New Lease' from the dynamic secret lease list section.

    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-generate.png" alt="Dynamic Secret" />
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-lease-empty.png" alt="Dynamic Secret" />

    When generating these secrets, it's important to specify a Time-to-Live (TTL) duration. This will dictate how long the credentials are valid for.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/provision-lease.png" alt="Provision Lease" />

    <Tip>
      Ensure that the TTL for the lease falls within the maximum TTL defined when configuring the dynamic secret.
    </Tip>

    Once you click the `Submit` button, a new secret lease will be generated and the credentials from it will be shown to you.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-ad-lease.png" alt="Provision Lease" />
  </Step>
</Steps>

## Audit or Revoke Leases

Once you have created one or more leases, you will be able to access them by clicking on the respective dynamic secret item on the dashboard.
This will allow you to see the expiration time of the lease or delete a lease before its set time to live.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/lease-data.png" alt="Provision Lease" />

## Renew Leases

To extend the life of the generated dynamic secret leases past its initial time to live, simply click on the **Renew** button as illustrated below.
<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-lease-renew.png" alt="Provision Lease" />

<Warning>
  Lease renewals cannot exceed the maximum TTL set when configuring the dynamic secret
</Warning>


# Azure SQL Database
Source: https://infisical.com/docs/documentation/platform/dynamic-secrets/azure-sql-database

Learn how to dynamically generate Azure SQL Database user credentials.

The Infisical Azure SQL Database dynamic secret allows you to generate Azure SQL Database user credentials on demand based on configured roles.

## How Azure SQL Database Authentication Works

Azure SQL Database uses a two-tier authentication system that differs from traditional SQL Server:

1. **Master Database**: Contains server-level logins that can authenticate to the Azure SQL Database server
2. **User Databases**: Individual databases that contain database users mapped to server logins

When creating dynamic credentials for Azure SQL Database, Infisical performs a two-step process:

1. **Create Login in Master Database**: Creates a server-level login with the specified password
2. **Create User in Target Database**: Creates a database user mapped to the login and grants the necessary permissions

This architecture ensures proper security isolation and follows Azure SQL Database best practices.

## Prerequisite

Create a user with the required permissions in your Azure SQL Database instance. This user will be used to create new accounts on-demand.

The user needs:

* `loginmanager` role in the master database (to create logins)
* `db_owner` role in the target database (to create users and grant permissions)

## Set up Dynamic Secrets with Azure SQL Database

<Steps>
  <Step title="Open Secret Overview Dashboard">
    Open the Secret Overview dashboard and select the environment in which you would like to add a dynamic secret.
  </Step>

  <Step title="Click on the 'Add Dynamic Secret' button">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/add-dynamic-secret-button.png" alt="Add Dynamic Secret Button" />
  </Step>

  <Step title="Select `Azure SQL Database`">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/azure-sql-database/add-dynamic-secret-button.png" alt="Dynamic Secret Modal" />
  </Step>

  <Step title="Provide the inputs for dynamic secret parameters">
    <ParamField path="Secret Name" type="string" required>
      Name by which you want the secret to be referenced
    </ParamField>

    <ParamField path="Default TTL" type="string" required>
      Default time-to-live for a generated secret (it is possible to modify this value after a secret is generated)
    </ParamField>

    <ParamField path="Max TTL" type="string" required>
      Maximum time-to-live for a generated secret
    </ParamField>

    <ParamField path="Metadata" type="list" required>
      List of key/value metadata pairs
    </ParamField>

    <ParamField path="Host" type="string" required>
      Azure SQL Database server hostname (e.g., myserver.database.windows.net)
    </ParamField>

    <ParamField path="Port" type="number" required>
      Database port (typically 1433 for Azure SQL Database)
    </ParamField>

    <ParamField path="User" type="string" required>
      Username that will be used to create dynamic secrets (must have loginmanager role in master and db\_owner in target database)
    </ParamField>

    <ParamField path="Password" type="string" required>
      Password that will be used to create dynamic secrets
    </ParamField>

    <ParamField path="Database" type="string" required>
      Name of the target database where users will be created and granted permissions
    </ParamField>

    <ParamField path="Encrypt Connection (SSL)" type="boolean">
      Enable SSL encryption for the database connection (recommended for Azure SQL Database)
    </ParamField>

    <ParamField path="CA(SSL)" type="string">
      SSL certificate authority certificate. For Azure SQL Database, this is typically not required as Azure manages the certificates.
    </ParamField>

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/azure-sql-database/create-dynamic-secret-form.png" alt="Dynamic Secret Setup Modal" />
  </Step>

  <Step title="Configure SQL Statements">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/azure-sql-database/modify-sql-statements-azure-sql.png" alt="Modify SQL Statements Modal" />

    Azure SQL Database dynamic secrets use predefined SQL statements that follow Azure's security best practices:

    <ParamField path="Master Creation Statement" type="string" default="CREATE LOGIN [{{username}}] WITH PASSWORD = '{{password}}';'">
      SQL statement executed in the master database to create a server-level login. This login allows authentication to the Azure SQL Database server.
    </ParamField>

    <ParamField path="Creation Statement" type="string" default="CREATE USER [{{username}}] FOR LOGIN [{{username}}];\nGRANT SELECT, INSERT, UPDATE, DELETE ON SCHEMA::dbo TO [{{username}}];">
      SQL statement executed in the target database to create a database user and grant permissions. The user is mapped to the login created in the master database.
    </ParamField>

    <ParamField path="Revocation Statement" type="string">
      SQL statements executed when a lease expires or is manually revoked. The system intelligently routes DROP USER commands to the target database and DROP LOGIN commands to the master database for proper cleanup.
    </ParamField>

    <ParamField path="Username Template" type="string" default="{{randomUsername}}">
      Specifies a template for generating usernames. This field allows customization of how usernames are automatically created.

      Allowed template variables are:

      * `{{randomUsername}}`: Random username string
      * `{{unixTimestamp}}`: Current Unix timestamp
      * `{{identity.name}}`: Name of the identity that is generating the secret
      * `{{random N}}`: Random string of N characters

      Allowed template functions are:

      * `truncate`: Truncates a string to a specified length
      * `replace`: Replaces a substring with another value

      Examples:

      ```
      {{randomUsername}}                              // 3POnzeFyK9gW2nioK0q2gMjr6CZqsRiX
      {{unixTimestamp}}                               // 17490641580
      {{identity.name}}                               // testuser
      {{random-5}}                                    // x9k2m
      {{truncate identity.name 4}}                    // test
      {{replace identity.name 'user' 'replace'}}      // testreplace
      ```
    </ParamField>
  </Step>

  <Step title="Click 'Submit'">
    After submitting the form, you will see a dynamic secret created in the dashboard.

    <Note>
      If this step fails, ensure your user has the proper permissions in both the master database (`loginmanager` role) and target database (`db_owner` role).
    </Note>

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret.png" alt="Dynamic Secret" />
  </Step>

  <Step title="Generate dynamic secrets">
    Once you've successfully configured the dynamic secret, you're ready to generate on-demand credentials.
    To do this, simply click on the 'Generate' button which appears when hovering over the dynamic secret item.
    Alternatively, you can initiate the creation of a new lease by selecting 'New Lease' from the dynamic secret lease list section.

    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-generate.png" alt="Dynamic Secret" />
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-lease-empty.png" alt="Dynamic Secret" />

    When generating these secrets, it's important to specify a Time-to-Live (TTL) duration. This will dictate how long the credentials are valid for.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/provision-lease.png" alt="Provision Lease" />

    <Tip>
      Ensure that the TTL for the lease falls within the maximum TTL defined when configuring the dynamic secret.
    </Tip>

    Once you click the `Submit` button, a new secret lease will be generated and the credentials for it will be shown to you.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/lease-values.png" alt="Provision Lease" />
  </Step>
</Steps>

## Audit or Revoke Leases

Once you have created one or more leases, you will be able to access them by clicking on the respective dynamic secret item on the dashboard.
This will allow you to see the expiration time of the lease or delete the lease before its set time to live.

When a lease is revoked or expires, Infisical automatically:

1. **Drops the user** from the target database
2. **Drops the login** from the master database

This ensures complete cleanup and prevents orphaned credentials.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/lease-data.png" alt="Provision Lease" />

## Renew Leases

To extend the life of the generated dynamic secret leases past its initial time to live, simply click on the **Renew** button as illustrated below.
<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-lease-renew.png" alt="Provision Lease" />

<Warning>
  Lease renewals cannot exceed the maximum TTL set when configuring the dynamic secret
</Warning>


# Cassandra
Source: https://infisical.com/docs/documentation/platform/dynamic-secrets/cassandra

Learn how to dynamically generate Cassandra database user credentials

The Infisical Cassandra dynamic secret allows you to generate Cassandra database credentials on demand based on configured role.

## Prerequisite

Infisical requires a Cassandra user in your instance with the necessary permissions. This user will facilitate the creation of new accounts as needed.
Ensure the user possesses privileges for creating, dropping, and granting permissions to roles for it to be able to create dynamic secrets.

<Tip>
  In your Cassandra configuration file `cassandra.yaml`, make sure you have the following settings:

  ```yaml  theme={"dark"}
  authenticator: PasswordAuthenticator
  authorizer: CassandraAuthorizer
  ```
</Tip>

The above configuration allows user creation and granting permissions.

## Set up Dynamic Secrets with Cassandra

<Steps>
  <Step title="Open Secret Overview Dashboard">
    Open the Secret Overview dashboard and select the environment in which you would like to add a dynamic secret.
  </Step>

  <Step title="Click on the 'Add Dynamic Secret' button">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/add-dynamic-secret-button.png" alt="Add Dynamic Secret Button" />
  </Step>

  <Step title="Select Cassandra">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-modal-cassandra.png" alt="Dynamic Secret Modal" />
  </Step>

  <Step title="Provide the inputs for dynamic secret parameters">
    <ParamField path="Secret Name" type="string" required>
      Name by which you want the secret to be referenced
    </ParamField>

    <ParamField path="Default TTL" type="string" required>
      Default time-to-live for a generated secret (it is possible to modify this value after a secret is generated)
    </ParamField>

    <ParamField path="Max TTL" type="string" required>
      Maximum time-to-live for a generated secret
    </ParamField>

    <ParamField path="Host" type="string" required>
      Cassandra Host. You can specify multiple Cassandra hosts by separating them with commas.
    </ParamField>

    <ParamField path="Port" type="number" required>
      Cassandra port
    </ParamField>

    <ParamField path="User" type="string" required>
      Username that will be used to create dynamic secrets
    </ParamField>

    <ParamField path="Password" type="string" required>
      Password that will be used to create dynamic secrets
    </ParamField>

    <ParamField path="Local Data Center" type="string" required>
      Specify the local data center in Cassandra that you want to use. This choice should align with your Cassandra cluster setup.
    </ParamField>

    <ParamField path="Keyspace" type="string">
      Keyspace name where you want to create dynamic secrets. This ensures that the user is limited to that keyspace.
    </ParamField>

    <ParamField path="CA(SSL)" type="string">
      A CA may be required if your cassandra requires it for incoming connections.
    </ParamField>

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-setup-modal-cassandra.png" alt="Dynamic Secret Setup Modal" />
  </Step>

  <Step title="(Optional) Modify CQL Statements">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/modify-cql-statements.png" alt="Modify CQL Statements Modal" />

    <ParamField path="Username Template" type="string" default="{{randomUsername}}">
      Specifies a template for generating usernames. This field allows customization of how usernames are automatically created.

      Allowed template variables are

      * `{{randomUsername}}`: Random username string
      * `{{unixTimestamp}}`: Current Unix timestamp
      * `{{identity.name}}`: Name of the identity that is generating the secret
      * `{{random N}}`: Random string of N characters

      Allowed template functions are

      * `truncate`: Truncates a string to a specified length
      * `replace`: Replaces a substring with another value

      Examples:

      ```
      {{randomUsername}}                              // 3POnzeFyK9gW2nioK0q2gMjr6CZqsRiX
      {{unixTimestamp}}                               // 17490641580
      {{identity.name}}                               // testuser
      {{random-5}}                                    // x9k2m
      {{truncate identity.name 4}}                    // test
      {{replace identity.name 'user' 'replace'}}      // testreplace
      ```
    </ParamField>

    <ParamField path="Customize CQL Statement" type="string">
      If you want to provide specific privileges for the generated dynamic credentials, you can modify the CQL statement to your needs. This is useful if you want to only give access to a specific key-space(s).
    </ParamField>
  </Step>

  <Step title="Click 'Submit'">
    After submitting the form, you will see a dynamic secret created in the dashboard.

    <Note>
      If this step fails, you may have to add the CA certificate.
    </Note>

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret.png" alt="Dynamic Secret" />
  </Step>

  <Step title="Generate dynamic secrets">
    Once you've successfully configured the dynamic secret, you're ready to generate on-demand credentials.
    To do this, simply click on the 'Generate' button which appears when hovering over the dynamic secret item.
    Alternatively, you can initiate the creation of a new lease by selecting 'New Lease' from the dynamic secret lease list section.

    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-generate.png" alt="Dynamic Secret" />
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-lease-empty.png" alt="Dynamic Secret" />

    When generating these secrets, it's important to specify a Time-to-Live (TTL) duration. This will dictate how long the credentials are valid for.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/provision-lease.png" alt="Provision Lease" />

    <Tip>
      Ensure that the TTL for the lease falls within the maximum TTL defined when configuring the dynamic secret in step 4.
    </Tip>

    Once you click the `Submit` button, a new secret lease will be generated and the credentials for it will be shown to you.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/lease-values.png" alt="Provision Lease" />
  </Step>
</Steps>

## Audit or Revoke Leases

Once you have created one or more leases, you will be able to access them by clicking on the respective dynamic secret item on the dashboard.
This will allow you to see the lease details and delete the lease ahead of its expiration time.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/lease-data.png" alt="Provision Lease" />

## Renew Leases

To extend the life of the generated dynamic secret lease past its initial time to live, simply click on the **Renew** button as illustrated below.
<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-lease-renew.png" alt="Provision Lease" />

<Warning>
  Lease renewals cannot exceed the maximum TTL set when configuring the dynamic secret
</Warning>


# Couchbase
Source: https://infisical.com/docs/documentation/platform/dynamic-secrets/couchbase

Learn how to dynamically generate Couchbase Database user credentials.

The Infisical Couchbase dynamic secret allows you to generate Couchbase Cloud Database user credentials on demand based on configured roles and bucket access permissions.

## Prerequisite

Create an API Key in your Couchbase Cloud following the [official documentation](https://docs.couchbase.com/cloud/get-started/create-account.html#create-api-key).

<Info>The API Key must have permission to manage database users in your Couchbase Cloud organization and project.</Info>

## Set up Dynamic Secrets with Couchbase

<Steps>
  <Step title="Open Secret Overview Dashboard">
    Open the Secret Overview dashboard and select the environment in which you would like to add a dynamic secret.
  </Step>

  <Step title="Click on the 'Add Dynamic Secret' button">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/add-dynamic-secret-button.png" alt="Add Dynamic Secret Button" />
  </Step>

  <Step title="Select Couchbase">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/couchbase/dynamic-secret-couchbase-modal.png" alt="Dynamic Secret Modal" />
  </Step>

  <Step title="Provide the inputs for dynamic secret parameters">
    <ParamField path="Secret Name" type="string" required>
      Name by which you want the secret to be referenced
    </ParamField>

    <ParamField path="Default TTL" type="string" required>
      Default time-to-live for a generated secret (it is possible to modify this value after a secret is generated)
    </ParamField>

    <ParamField path="Max TTL" type="string" required>
      Maximum time-to-live for a generated secret
    </ParamField>

    <ParamField path="URL" type="string" required default="https://cloudapi.cloud.couchbase.com">
      The Couchbase Cloud API URL
    </ParamField>

    <ParamField path="Organization ID" type="string" required>
      Your Couchbase Cloud organization ID
    </ParamField>

    <ParamField path="Project ID" type="string" required>
      Your Couchbase Cloud project ID
    </ParamField>

    <ParamField path="Cluster ID" type="string" required>
      Your Couchbase Cloud cluster ID where users will be created
    </ParamField>

    <ParamField path="Roles" type="array" required>
      Database credential roles to assign to the generated user. Available options:

      * **read**: Read access to bucket data (alias for data\_reader)
      * **write**: Read and write access to bucket data (alias for data\_writer)
    </ParamField>

    <ParamField path="Bucket Access" type="string" required default="*">
      Specify bucket access configuration:

      * Use `*` for access to all buckets
      * Use comma-separated bucket names (e.g., `bucket1,bucket2,bucket3`) for specific buckets
      * Use Advanced Bucket Configuration for granular scope and collection access
    </ParamField>

    <ParamField path="API Key" type="string" required>
      Your Couchbase Cloud API Key for authentication
    </ParamField>

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/couchbase/dynamic-secret-modal-couchbase.png" alt="Dynamic Secret Setup Modal" />
  </Step>

  <Step title="(Optional) Advanced Configuration">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/couchbase/advanced-option-couchbase.png" alt="Advanced Configuration Modal" />

    <ParamField path="Advanced Bucket Configuration" type="boolean" default="false">
      Enable advanced bucket configuration to specify granular access to buckets, scopes, and collections
    </ParamField>

    When Advanced Bucket Configuration is enabled, you can configure:

    <ParamField path="Buckets" type="array">
      List of buckets with optional scope and collection specifications:

      * **Bucket Name**: Name of the bucket (e.g., travel-sample)
      * **Scopes**: Optional array of scopes within the bucket
        * **Scope Name**: Name of the scope (e.g., inventory, \_default)
        * **Collections**: Optional array of collection names within the scope
    </ParamField>

    <ParamField path="Username Template" type="string" default="{{randomUsername}}">
      Specifies a template for generating usernames. This field allows customization of how usernames are automatically created.

      Allowed template variables are:

      * `{{randomUsername}}`: Random username string
      * `{{unixTimestamp}}`: Current Unix timestamp
      * `{{identity.name}}`: Name of the identity that is generating the secret
      * `{{random N}}`: Random string of N characters

      Allowed template functions are:

      * `truncate`: Truncates a string to a specified length
      * `replace`: Replaces a substring with another value

      Examples:

      ```
      {{randomUsername}}                              // infisical-3POnzeFyK9gW2nioK0q2gMjr6CZqsRiX
      {{unixTimestamp}}                               // 17490641580
      {{identity.name}}                               // testuser
      {{random 5}}                                    // x9k2m
      {{truncate identity.name 4}}                    // test
      {{replace identity.name 'user' 'replace'}}      // testreplace
      ```
    </ParamField>

    <ParamField path="Password Configuration" type="object">
      Optional password generation requirements for Couchbase users:

      <ParamField path="Password Length" type="number" default="12" min="8" max="128">
        Length of the generated password
      </ParamField>

      <ParamField path="Character Requirements" type="object">
        Minimum required character counts:

        * **Lowercase Count**: Minimum lowercase letters (default: 1)
        * **Uppercase Count**: Minimum uppercase letters (default: 1)
        * **Digit Count**: Minimum digits (default: 1)
        * **Symbol Count**: Minimum special characters (default: 1)
      </ParamField>

      <ParamField path="Allowed Symbols" type="string" default="!@#$%^()_+-=[]{}:,?/~`">
        Special characters allowed in passwords. Cannot contain: `< > ; . * & | `
      </ParamField>

      <Info>
        Couchbase password requirements: minimum 8 characters, maximum 128 characters, at least 1 uppercase, 1 lowercase, 1 digit, and 1 special character. Cannot contain: `< > ; . * & | `
      </Info>
    </ParamField>
  </Step>

  <Step title="Click 'Submit'">
    After submitting the form, you will see a dynamic secret created in the dashboard.

    <Note>
      If this step fails, you may need to verify your Couchbase Cloud API key permissions and organization/project/cluster IDs.
    </Note>

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/couchbase/dynamic-secret-couchbase.png" alt="Dynamic Secret" />
  </Step>

  <Step title="Generate dynamic secrets">
    Once you've successfully configured the dynamic secret, you're ready to generate on-demand credentials.
    To do this, simply click on the 'Generate' button which appears when hovering over the dynamic secret item.
    Alternatively, you can initiate the creation of a new lease by selecting 'New Lease' from the dynamic secret lease list section.

    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-generate.png" alt="Dynamic Secret" />
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-lease-empty.png" alt="Dynamic Secret" />

    When generating these secrets, it's important to specify a Time-to-Live (TTL) duration. This will dictate how long the credentials are valid for.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/provision-lease.png" alt="Provision Lease" />

    <Tip>
      Ensure that the TTL for the lease falls within the maximum TTL defined when configuring the dynamic secret.
    </Tip>

    Once you click the `Submit` button, a new secret lease will be generated and the credentials for it will be shown to you.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/lease-values.png" alt="Provision Lease" />
  </Step>
</Steps>

## Advanced Bucket Configuration Examples

The advanced bucket configuration allows you to specify granular access control:

### Example 1: Specific Bucket Access

```json  theme={"dark"}
[
  {
    "name": "travel-sample"
  }
]
```

### Example 2: Bucket with Specific Scopes

```json  theme={"dark"}
[
  {
    "name": "travel-sample",
    "scopes": [
      {
        "name": "inventory"
      },
      {
        "name": "_default"
      }
    ]
  }
]
```

### Example 3: Bucket with Scopes and Collections

```json  theme={"dark"}
[
  {
    "name": "travel-sample",
    "scopes": [
      {
        "name": "inventory",
        "collections": ["airport", "airline"]
      },
      {
        "name": "_default",
        "collections": ["users"]
      }
    ]
  }
]
```

## Audit or Revoke Leases

Once you have created one or more leases, you will be able to access them by clicking on the respective dynamic secret item on the dashboard.
This will allow you to see the expiration time of the lease or delete a lease before its set time to live.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/lease-data.png" alt="Provision Lease" />

## Renew Leases

To extend the life of the generated dynamic secret leases past its initial time to live, simply click on the **Renew** button as illustrated below.
<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-lease-renew.png" alt="Provision Lease" />

<Warning>
  Lease renewals cannot exceed the maximum TTL set when configuring the dynamic secret
</Warning>

## Couchbase Roles and Permissions

The Couchbase dynamic secret integration supports the following database credential roles:

* **read**: Provides read-only access to bucket data
* **write**: Provides read and write access to bucket data

<Note>
  These roles are specifically for database credentials and are different from Couchbase's administrative roles. They provide data-level access to buckets, scopes, and collections based on your configuration.
</Note>

## Troubleshooting

### Common Issues

1. **Invalid API Key**: Ensure your Couchbase Cloud API key has the necessary permissions to manage database users
2. **Invalid Organization/Project/Cluster IDs**: Verify that the provided IDs exist and are accessible with your API key
3. **Role Permission Errors**: Make sure you're using only the supported database credential roles (read, write)
4. **Bucket Access Issues**: Ensure the specified buckets exist in your cluster and are accessible


# Elasticsearch
Source: https://infisical.com/docs/documentation/platform/dynamic-secrets/elastic-search

Learn how to dynamically generate Elasticsearch user credentials.

The Infisical Elasticsearch dynamic secret allows you to generate Elasticsearch credentials on demand based on configured role.

## Prerequisites

1. Create a role with at least `manage_security` and `monitor` permissions.
2. Assign the newly created role to your API key or user that you'll use later in the dynamic secret configuration.

<Note>
  For testing purposes, you can also use a highly privileged role like
  `superuser`, that will have full control over the cluster. This is not
  recommended in production environments following the principle of least
  privilege.
</Note>

## Set up Dynamic Secrets with Elasticsearch

<Steps>
  <Step title="Open Secret Overview Dashboard">
    Open the Secret Overview dashboard and select the environment in which you would like to add a dynamic secret.
  </Step>

  <Step title="Click on the 'Add Dynamic Secret' button">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/add-dynamic-secret-button.png" alt="Add Dynamic Secret Button" />
  </Step>

  <Step title="Select 'Elasticsearch'">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-modal-elastic-search.png" alt="Dynamic Secret Modal" />
  </Step>

  <Step title="Provide the inputs for dynamic secret parameters">
    <ParamField path="Secret Name" type="string" required>
      Name by which you want the secret to be referenced
    </ParamField>

    <ParamField path="Default TTL" type="string" required>
      Default time-to-live for a generated secret (it is possible to modify this value after a secret is generated)
    </ParamField>

    <ParamField path="Max TTL" type="string" required>
      Maximum time-to-live for a generated secret.
    </ParamField>

    <ParamField path="Host" type="string" required>
      Your Elasticsearch host. This is the endpoint that your instance runs on. *(Example: [https://your-cluster-ip](https://your-cluster-ip))*
    </ParamField>

    <ParamField path="Port" type="string" required>
      The port that your Elasticsearch instance is running on. *(Example: 9200)*
    </ParamField>

    <ParamField path="Roles" type="string[]" required>
      The roles that the new user that is created when a lease is provisioned will
      be assigned to. This is a required field. This defaults to `superuser`, which
      is highly privileged. It is recommended to create a new role with the least
      privileges required for the lease.
    </ParamField>

    <ParamField path="Authentication Method" type="API Key | Username/Password" required>
      Select the authentication method you want to use to connect to your Elasticsearch instance.
    </ParamField>

    <ParamField path="Username" type="string" required>
      The username of the user that will be used to provision new dynamic secret
      leases. Only required if you selected the `Username/Password` authentication
      method.
    </ParamField>

    <ParamField path="Password" type="string" required>
      The password of the user that will be used to provision new dynamic secret
      leases. Only required if you selected the `Username/Password` authentication
      method.
    </ParamField>

    <ParamField path="API Key ID" required>
      The ID of the API key that will be used to provision new dynamic secret
      leases. Only required if you selected the `API Key` authentication method.
    </ParamField>

    <ParamField path="API Key" required>
      The API key that will be used to provision new dynamic secret leases. Only
      required if you selected the `API Key` authentication method.
    </ParamField>

    <ParamField path="CA(SSL)" type="string">
      A CA may be required if your DB requires it for incoming connections. This is often the case when connecting to a managed service.
    </ParamField>

    <ParamField path="Username Template" type="string" default="{{randomUsername}}">
      Specifies a template for generating usernames. This field allows customization of how usernames are automatically created.

      Allowed template variables are

      * `{{randomUsername}}`: Random username string
      * `{{unixTimestamp}}`: Current Unix timestamp
      * `{{identity.name}}`: Name of the identity that is generating the secret
      * `{{random N}}`: Random string of N characters

      Allowed template functions are

      * `truncate`: Truncates a string to a specified length
      * `replace`: Replaces a substring with another value

      Examples:

      ```
      {{randomUsername}}                              // 3POnzeFyK9gW2nioK0q2gMjr6CZqsRiX
      {{unixTimestamp}}                               // 17490641580
      {{identity.name}}                               // testuser
      {{random-5}}                                    // x9k2m
      {{truncate identity.name 4}}                    // test
      {{replace identity.name 'user' 'replace'}}      // testreplace
      ```
    </ParamField>

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-input-modal-elastic-search.png" alt="Dynamic Secret Setup Modal" />
  </Step>

  <Step title="Click `Submit`">
    After submitting the form, you will see a dynamic secret created in the dashboard.

    <Note>
      If this step fails, you may have to add the CA certificate.
    </Note>
  </Step>

  <Step title="Generate dynamic secrets">
    Once you've successfully configured the dynamic secret, you're ready to generate on-demand credentials.
    To do this, simply click on the 'Generate' button which appears when hovering over the dynamic secret item.
    Alternatively, you can initiate the creation of a new lease by selecting 'New Lease' from the dynamic secret lease list section.

    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-generate.png" alt="Dynamic Secret" />
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-lease-empty.png" alt="Dynamic Secret" />

    When generating these secrets, it's important to specify a Time-to-Live (TTL) duration. This will dictate  how long the credentials are valid for.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/provision-lease.png" alt="Provision Lease" />

    <Tip>
      Ensure that the TTL for the lease falls within the maximum TTL defined when configuring the dynamic secret.
    </Tip>

    Once you click the `Submit` button, a new secret lease will be generated and the credentials from it will be shown to you.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/lease-values.png" alt="Provision Lease" />
  </Step>
</Steps>

## Audit or Revoke Leases

Once you have created one or more leases, you will be able to access them by clicking on the respective dynamic secret item on the dashboard.
This will allow you to see the expiration time of the lease or delete a lease before it's set time to live.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/lease-data.png" alt="Provision Lease" />

## Renew Leases

To extend the life of the generated dynamic secret leases past its initial time to live, simply click on the **Renew** button as illustrated below.
<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-lease-renew.png" alt="Provision Lease" />

<Warning>
  Lease renewals cannot exceed the maximum TTL set when configuring the dynamic
  secret
</Warning>


# GCP IAM
Source: https://infisical.com/docs/documentation/platform/dynamic-secrets/gcp-iam

Learn how to dynamically generate GCP service account tokens.

The Infisical GCP IAM dynamic secret allows you to generate GCP service account tokens on demand based on service account permissions.

<Warning>
  GCP service account access tokens cannot be revoked. As such, revoking or regenerating a token does not invalidate the old one; it remains active until it expires.
</Warning>

<Note>
  You must enable the [IAM API](https://console.cloud.google.com/apis/library/iam.googleapis.com) and [IAM Credentials API](https://console.cloud.google.com/apis/library/iamcredentials.googleapis.com) in your GCP console as a prerequisite
</Note>

<Accordion title="Self-Hosted Instance">
  Using the GCP integration on a self-hosted instance of Infisical requires configuring a service account on GCP and
  configuring your instance to use it.

  <Steps>
    <Step title="Enable the IAM Service Account Credentials API">
            <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/gcp/service-account-credentials-api.png" alt="Service Account API" />
    </Step>

    <Step title="Navigate to IAM & Admin > Service Accounts in Google Cloud Console">
            <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/gcp/service-account-overview.png" alt="Service Account IAM Page" />
    </Step>

    <Step title="Create a Service Account">
      Create a new service account that will be used to impersonate other GCP service accounts for your app connections.
      <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/gcp/create-instance-service-account.png" alt="Create Service Account Page" />

      Press "DONE" after creating the service account.
    </Step>

    <Step title="Generate Service Account Key">
      Download the JSON key file for your service account. This will be used to authenticate your instance with GCP.
      <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/gcp/create-service-account-credential.png" alt="Service Account Credential Page" />
    </Step>

    <Step title="Configure Your Instance">
      1. Copy the entire contents of the downloaded JSON key file.
      2. Set it as a string value for the `INF_APP_CONNECTION_GCP_SERVICE_ACCOUNT_CREDENTIAL` environment variable.
      3. Restart your Infisical instance to apply the changes.
      4. You can now use GCP integration with service account impersonation.
    </Step>
  </Steps>
</Accordion>

## Create GCP Service Account

<Steps>
  <Step title="Navigate to IAM & Admin > Service Accounts">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/gcp/service-account-overview.png" alt="Service Account Page" />
  </Step>

  <Step title="Create Service Account">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/gcp/create-service-account.png" alt="Create Service Account" />
  </Step>

  <Step title="Configure Service Account Permissions">
    When you assign specific roles and permissions to this service account, any tokens generated through Infisical's dynamic secrets functionality will inherit these exact permissions. This means that applications using these dynamically generated tokens will have the same access capabilities as defined by the service account's role assignments, ensuring proper access control while maintaining the principle of least privilege.

    After configuring the appropriate roles, press "DONE".
  </Step>

  <Step title="Enable Service Account Impersonation">
    To enable service account impersonation, you'll need to grant the **Service Account Token Creator** role to the Infisical instance's service account. This configuration allows Infisical to securely impersonate the new service account.

    * Navigate to the IAM & Admin > Service Accounts section in your Google Cloud Console
    * Select the newly created service account
    * Click on the "PERMISSIONS" tab
    * Click "Grant Access" to add a new principal

    If you're using Infisical Cloud US, use the following service account: `infisical-us@infisical-us.iam.gserviceaccount.com`

    If you're using Infisical Cloud EU, use the following service account: `infisical-eu@infisical-eu.iam.gserviceaccount.com`

    If you're self-hosting, follow the "Self-Hosted Instance" guide at the top of the page and then use service account you created

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/gcp/service-account-grant-access.png" alt="Service Account Page" />
  </Step>
</Steps>

## Set up Dynamic Secrets with GCP IAM

<Steps>
  <Step title="Open Secret Overview Dashboard">
    Open the Secret Overview dashboard and select the environment in which you would like to add a dynamic secret.
  </Step>

  <Step title="Click on the 'Add Dynamic Secret' button">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/add-dynamic-secret-button.png" alt="Add Dynamic Secret Button" />
  </Step>

  <Step title="Select 'GCP IAM'">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-gcp-iam-modal.png" alt="Dynamic Secret Modal" />
  </Step>

  <Step title="Provide the inputs for dynamic secret parameters">
    <ParamField path="Secret Name" type="string" required>
      Name by which you want the secret to be referenced
    </ParamField>

    <ParamField path="Default TTL" type="string" required>
      Default time-to-live for a generated secret (it is possible to modify this value after a secret is generated)
    </ParamField>

    <ParamField path="Max TTL" type="string" required>
      Maximum time-to-live for a generated secret
    </ParamField>

    <ParamField path="Service Account Email" type="string" required>
      The email tied to the service account created in earlier steps.
    </ParamField>
  </Step>

  <Step title="Click `Submit`">
    After submitting the form, you will see a dynamic secret created in the dashboard.
  </Step>

  <Step title="Generate dynamic secrets">
    Once you've successfully configured the dynamic secret, you're ready to generate on-demand credentials.
    To do this, simply click on the 'Generate' button which appears when hovering over the dynamic secret item.
    Alternatively, you can initiate the creation of a new lease by selecting 'New Lease' from the dynamic secret lease list section.

    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-generate.png" alt="Dynamic Secret" />
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-lease-empty.png" alt="Dynamic Secret" />

    When generating these secrets, it's important to specify a Time-to-Live (TTL) duration. This will dictate how long the credentials are valid for.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/provision-lease.png" alt="Provision Lease" />

    <Tip>
      Ensure that the TTL for the lease falls within the maximum TTL defined when configuring the dynamic secret.
    </Tip>

    Once you click the `Submit` button, a new secret lease will be generated and the credentials from it will be shown to you.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-gcp-iam-lease.png" alt="Dynamic Secret Lease" />
  </Step>
</Steps>

## Audit or Revoke Leases

Once you have created one or more leases, you will be able to access them by clicking on the respective dynamic secret item on the dashboard.

This will allow you to see the expiration time of the lease or delete a lease before its set time to live.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/lease-data.png" alt="Lease Data" />

## Renew Leases

To extend the life of the generated dynamic secret leases past its initial time to live, simply click on the **Renew** button as illustrated below.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-lease-renew.png" alt="Lease Renew" />

<Warning>
  Lease renewals cannot exceed the maximum TTL set when configuring the dynamic secret
</Warning>


# GitHub
Source: https://infisical.com/docs/documentation/platform/dynamic-secrets/github

Learn how to dynamically generate GitHub App tokens.

The Infisical GitHub dynamic secret allows you to generate short-lived tokens for a GitHub App on demand based on service account permissions.

## Setup GitHub App

<Steps>
  <Step title="Create an application on GitHub">
    Navigate to [GitHub App settings](https://github.com/settings/apps) and click **New GitHub App**.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/github/app/self-hosted-github-app-create.png" alt="integrations github app create" />

    Give the application a name and a homepage URL. These values do not need to be anything specific.

    Disable webhook by unchecking the Active checkbox.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/github/app/self-hosted-github-app-webhook.png" alt="integrations github app webhook" />

    Configure the app's permissions to grant the necessary access for the dynamic secret's short-lived tokens based on your use case.

    Create the GitHub Application.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/github/app/self-hosted-github-app-create-confirm.png" alt="integrations github app create confirm" />

    <Note>
      If you have a GitHub organization, you can create an application under it
      in your organization Settings > Developer settings > GitHub Apps > New GitHub App.
    </Note>
  </Step>

  <Step title="Save app credentials">
    Copy the **App ID** and generate a new **Private Key** for your GitHub Application.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/github/app/self-hosted-github-app-private-key.png" alt="integrations github app create private key" />

    Save these for later steps.
  </Step>

  <Step title="Install app">
    Install your application to whichever repositories and organizations that you want the dynamic secret to access.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/github/install-app.png" alt="Install App" />

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/github/install-app-modal.png" alt="Install App" />

    Once you've installed the app, **copy the installation ID** from the URL and save it for later steps.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/github/installation.png" alt="Install App" />
  </Step>
</Steps>

## Set up Dynamic Secrets with GitHub

<Steps>
  <Step title="Open Secret Overview Dashboard">
    Open the Secret Overview dashboard and select the environment in which you would like to add a dynamic secret.
  </Step>

  <Step title="Click on the 'Add Dynamic Secret' button">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/add-dynamic-secret-button.png" alt="Add Dynamic Secret Button" />
  </Step>

  <Step title="Select 'GitHub'">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/github/modal.png" alt="Dynamic Secret Modal" />
  </Step>

  <Step title="Provide the inputs for dynamic secret parameters">
    <ParamField path="Secret Name" type="string" required>
      Name by which you want the secret to be referenced
    </ParamField>

    <ParamField path="App ID" type="string" required>
      The ID of the app created in earlier steps.
    </ParamField>

    <ParamField path="App Private Key PEM" type="string" required>
      The Private Key of the app created in earlier steps.
    </ParamField>

    <ParamField path="Installation ID" type="string" required>
      The ID of the installation from earlier steps.
    </ParamField>
  </Step>

  <Step title="Click `Submit`">
    After submitting the form, you will see a dynamic secret created in the dashboard.
  </Step>

  <Step title="Generate dynamic secrets">
    Once you've successfully configured the dynamic secret, you're ready to generate on-demand credentials.
    To do this, simply click on the 'Generate' button which appears when hovering over the dynamic secret item.
    Alternatively, you can initiate the creation of a new lease by selecting 'New Lease' from the dynamic secret lease list section.

    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-generate.png" alt="Dynamic Secret" />
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-lease-empty.png" alt="Dynamic Secret" />

    When generating these secrets, the TTL will be fixed to 1 hour.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/provision-lease.png" alt="Provision Lease" />

    Once you click the `Submit` button, a new secret lease will be generated and the credentials from it will be shown to you.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/github/lease.png" alt="Dynamic Secret Lease" />
  </Step>
</Steps>

## Audit or Revoke Leases

Once you have created one or more leases, you will be able to access them by clicking on the respective dynamic secret item on the dashboard.

This will allow you to see the expiration time of the lease or delete a lease before its set time to live.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/lease-data.png" alt="Lease Data" />

<Warning>
  GitHub App tokens cannot be revoked. As such, revoking a token on Infisical does not invalidate the GitHub token; it remains active until it expires.
</Warning>

## Renew Leases

<Note>
  GitHub App tokens cannot be renewed because they are fixed to a lifetime of 1 hour.
</Note>


# Kubernetes
Source: https://infisical.com/docs/documentation/platform/dynamic-secrets/kubernetes

Learn how to dynamically generate Kubernetes service account tokens.

The Infisical Kubernetes dynamic secret allows you to generate short-lived service account tokens on demand.

## Overview

The Kubernetes dynamic secret feature enables you to generate short-lived service account tokens for your Kubernetes clusters. This is particularly useful for:

* **Secure Access Management**: Instead of using long-lived service account tokens, you can generate short-lived tokens that automatically expire, reducing the risk of token exposure.
* **Temporary Access**: Generate tokens with specific TTLs (Time To Live) for temporary access to your Kubernetes clusters.
* **Audit Trail**: Each token generation is tracked, providing better visibility into who accessed your cluster and when.
* **Integration with Private Clusters**: Seamlessly work with private Kubernetes clusters using Infisical's Gateway feature.

<Note>
  Kubernetes service account tokens cannot be revoked once issued. This is why
  it's important to use short TTLs and carefully manage token generation. The
  tokens will automatically expire after their TTL period.
</Note>

<Note>
  Kubernetes service account tokens are JWTs (JSON Web Tokens) with a fixed
  expiration time. Once a token is generated, its lifetime cannot be extended.
  If you need longer access, you'll need to generate a new token.
</Note>

This feature is ideal for scenarios where you need to:

* Provide temporary access to developers or CI/CD pipelines
* Rotate service account tokens frequently
* Maintain a secure audit trail of cluster access
* Manage access to multiple Kubernetes clusters

## Set up Dynamic Secrets with Kubernetes

<Steps>
  <Step title="Open Secret Overview Dashboard">
    Open the Secret Overview dashboard and select the environment in which you would like to add a dynamic secret.
  </Step>

  <Step title="Click on the 'Add Dynamic Secret' button">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/add-dynamic-secret-button.png" alt="Add Dynamic Secret Button" />
  </Step>

  <Step title="Select Kubernetes">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-modal-kubernetes.png" alt="Dynamic Secret Modal" />
  </Step>

  <Step title="Choose your configuration options">
    Before proceeding with the setup, you'll need to make two key decisions:

    1. **Credential Type**: How you want to manage service accounts
       * **Static**: Use an existing service account with predefined permissions
       * **Dynamic**: Create temporary service accounts with specific role assignments

    2. **Authentication Method**: How you want to authenticate with the cluster
       * **Token (API)**: Use a service account token for direct API access
       * **Gateway**: Use an Infisical Gateway deployed in your cluster

    <Tabs>
      <Tab title="Static Credentials">
        Static credentials generate service account tokens for a predefined service account. This is useful when you want to:

        * Generate tokens for an existing service account
        * Maintain consistent permissions across token generations
        * Use a service account that already has the necessary RBAC permissions

        ### Prerequisites

        * A Kubernetes cluster with a service account
        * Cluster access token with permissions to create service account tokens
        * (Optional) [Gateway](/documentation/platform/gateways/overview) for private cluster access

        ### Authentication Setup

        Choose your authentication method:

        <AccordionGroup>
          <Accordion title="Token (API) Authentication">
            This method uses a service account token to authenticate with the Kubernetes cluster. It's suitable when:

            * You want to use a specific service account token that you've created
            * You're working with a public cluster or have network access to the cluster's API server
            * You want to explicitly control which service account is used for operations

            <Note>
              With Token (API) authentication, Infisical uses the provided service account token
              to make API calls to your Kubernetes cluster. This token must have the necessary
              permissions to generate tokens for the target service account.
            </Note>

            1. Create a service account:

            ```yaml infisical-service-account.yaml theme={"dark"}
            apiVersion: v1
            kind: ServiceAccount
            metadata:
              name: infisical-token-requester
              namespace: default
            ```

            ```bash  theme={"dark"}
            kubectl apply -f infisical-service-account.yaml
            ```

            2. Set up RBAC permissions:

            ```yaml rbac.yaml theme={"dark"}
            apiVersion: rbac.authorization.k8s.io/v1
            kind: ClusterRole
            metadata:
              name: tokenrequest
            rules:
              - apiGroups: [""]
                resources:
                  - "serviceaccounts/token"
                  - "serviceaccounts"
                verbs:
                  - "create"
                  - "get"
            ---
            apiVersion: rbac.authorization.k8s.io/v1
            kind: ClusterRoleBinding
            metadata:
              name: tokenrequest
            roleRef:
              apiGroup: rbac.authorization.k8s.io
              kind: ClusterRole
              name: tokenrequest
            subjects:
              - kind: ServiceAccount
                name: infisical-token-requester
                namespace: default
            ```

            ```bash  theme={"dark"}
            kubectl apply -f rbac.yaml
            ```

            3. Create and obtain the token:

            ```yaml service-account-token.yaml theme={"dark"}
            apiVersion: v1
            kind: Secret
            type: kubernetes.io/service-account-token
            metadata:
              name: infisical-token-requester-token
              annotations:
                kubernetes.io/service-account.name: "infisical-token-requester"
            ```

            ```bash  theme={"dark"}
            kubectl apply -f service-account-token.yaml
            kubectl patch serviceaccount infisical-token-requester -p '{"secrets": [{"name": "infisical-token-requester-token"}]}' -n default
            kubectl get secret infisical-token-requester-token -n default -o=jsonpath='{.data.token}' | base64 --decode
            ```
          </Accordion>

          <Accordion title="Gateway Authentication">
            This method uses an Infisical Gateway deployed in your Kubernetes cluster. It's ideal when:

            * You want to avoid storing static service account tokens
            * You prefer to use the Gateway's pre-configured service account
            * You want centralized management of cluster operations

            <Note>
              With Gateway authentication, Infisical communicates with the Gateway, which then
              uses its own service account to make API calls to the Kubernetes API server.
              The Gateway's service account must have the necessary permissions to generate
              tokens for the target service account.
            </Note>

            <Note>
              When using Gateway authentication, the Gateway will access the Kubernetes API server
              using its internal cluster URL (typically [https://kubernetes.default.svc](https://kubernetes.default.svc)) and TLS configuration.
              You don't need to specify these values separately in the dynamic secret configuration.
            </Note>

            1. Deploy the Infisical Gateway in your cluster
            2. Set up RBAC permissions for the Gateway's service account:

            ```yaml rbac.yaml theme={"dark"}
            apiVersion: rbac.authorization.k8s.io/v1
            kind: ClusterRole
            metadata:
              name: tokenrequest
            rules:
              - apiGroups: [""]
                resources:
                  - "serviceaccounts/token"
                  - "serviceaccounts"
                verbs:
                  - "create"
                  - "get"
            ---
            apiVersion: rbac.authorization.k8s.io/v1
            kind: ClusterRoleBinding
            metadata:
              name: tokenrequest
            roleRef:
              apiGroup: rbac.authorization.k8s.io
              kind: ClusterRole
              name: tokenrequest
            subjects:
              - kind: ServiceAccount
                name: infisical-gateway
                namespace: infisical
            ```

            ```bash  theme={"dark"}
            kubectl apply -f rbac.yaml
            ```
          </Accordion>
        </AccordionGroup>
      </Tab>

      <Tab title="Dynamic Credentials">
        Dynamic credentials create a temporary service account, assign it to a defined role/cluster-role, and generate a service account token. This is useful when you want to:

        * Create temporary service accounts with specific permissions
        * Automatically clean up service accounts after token expiration
        * Assign different roles to different users or applications
        * Maintain strict control over service account permissions
        * Support multiple namespaces with a single dynamic secret configuration

        ### Prerequisites

        * A Kubernetes cluster with a service account
        * Cluster access token with permissions to create service accounts and manage RBAC
        * (Optional) [Gateway](/documentation/platform/gateways/overview) for private cluster access

        ### Namespace Support

        When configuring a dynamic secret, you can specify multiple allowed namespaces as a comma-separated list. During lease creation, you can then specify which namespace to use from this allowed list. This provides flexibility while maintaining security by:

        * Allowing a single dynamic secret configuration to support multiple namespaces
        * Restricting service account creation to only the specified allowed namespaces
        * Enabling fine-grained control over which namespaces can be used for each lease

        For example, if you configure a dynamic secret with allowed namespaces "default,kube-system,monitoring", you can create leases that use any of these namespaces while preventing access to other namespaces in your cluster.

        ### Authentication Setup

        Choose your authentication method:

        <AccordionGroup>
          <Accordion title="Token (API) Authentication">
            This method uses a service account token to authenticate with the Kubernetes cluster. It's suitable when:

            * You want to use a specific service account token that you've created
            * You're working with a public cluster or have network access to the cluster's API server
            * You want to explicitly control which service account is used for operations

            <Note>
              With Token (API) authentication, Infisical uses the provided service account token
              to make API calls to your Kubernetes cluster. This token must have the necessary
              permissions to create and manage service accounts, their tokens, and RBAC resources.
            </Note>

            1. Create a service account:

            ```yaml service-account.yaml theme={"dark"}
            apiVersion: v1
            kind: ServiceAccount
            metadata:
              name: infisical-token-requester
              namespace: default
            ---
            apiVersion: v1
            kind: Secret
            type: kubernetes.io/service-account-token
            metadata:
              name: infisical-token-requester-token
              annotations:
                kubernetes.io/service-account.name: "infisical-token-requester"
            ```

            ```bash  theme={"dark"}
            kubectl apply -f service-account.yaml
            ```

            2. Set up RBAC permissions:

            ```yaml rbac.yaml theme={"dark"}
            apiVersion: rbac.authorization.k8s.io/v1
            kind: ClusterRole
            metadata:
              name: tokenrequest
            rules:
              - apiGroups: [""]
                resources:
                  - "serviceaccounts/token"
                  - "serviceaccounts"
                verbs:
                  - "create"
                  - "get"
                  - "delete"
              - apiGroups: ["rbac.authorization.k8s.io"]
                resources:
                  - "rolebindings"
                  - "clusterrolebindings"
                verbs:
                  - "create"
                  - "delete"
            ---
            apiVersion: rbac.authorization.k8s.io/v1
            kind: ClusterRoleBinding
            metadata:
              name: tokenrequest
            roleRef:
              apiGroup: rbac.authorization.k8s.io
              kind: ClusterRole
              name: tokenrequest
            subjects:
              - kind: ServiceAccount
                name: infisical-token-requester
                namespace: default
            ---
            apiVersion: rbac.authorization.k8s.io/v1
            kind: ClusterRoleBinding
            metadata:
              name: infisical-dynamic-role-binding-sa
            roleRef:
              apiGroup: rbac.authorization.k8s.io
              kind: ClusterRole
              name: infisical-dynamic-role
            subjects:
              - kind: ServiceAccount
                name: infisical-token-requester
                namespace: default
            ```

            ```bash  theme={"dark"}
            kubectl apply -f rbac.yaml
            ```
          </Accordion>

          <Accordion title="Gateway Authentication">
            This method uses an Infisical Gateway deployed in your Kubernetes cluster. It's ideal when:

            * You want to avoid storing static service account tokens
            * You prefer to use the Gateway's pre-configured service account
            * You want centralized management of cluster operations

            <Note>
              With Gateway authentication, Infisical communicates with the Gateway, which then
              uses its own service account to make API calls to the Kubernetes API server.
              The Gateway's service account must have the necessary permissions to create and
              manage service accounts, their tokens, and RBAC resources.
            </Note>

            <Note>
              When using Gateway authentication, the Gateway will access the Kubernetes API server
              using its internal cluster URL (typically [https://kubernetes.default.svc](https://kubernetes.default.svc)) and TLS configuration.
              You don't need to specify these values separately in the dynamic secret configuration.
            </Note>

            1. Deploy the Infisical Gateway in your cluster
            2. Set up RBAC permissions for the Gateway's service account:

            ```yaml rbac.yaml theme={"dark"}
            apiVersion: rbac.authorization.k8s.io/v1
            kind: ClusterRole
            metadata:
              name: tokenrequest
            rules:
              - apiGroups: [""]
                resources:
                  - "serviceaccounts/token"
                  - "serviceaccounts"
                verbs:
                  - "create"
                  - "get"
                  - "delete"
              - apiGroups: ["rbac.authorization.k8s.io"]
                resources:
                  - "rolebindings"
                  - "clusterrolebindings"
                verbs:
                  - "create"
                  - "delete"
            ---
            apiVersion: rbac.authorization.k8s.io/v1
            kind: ClusterRoleBinding
            metadata:
              name: tokenrequest
            roleRef:
              apiGroup: rbac.authorization.k8s.io
              kind: ClusterRole
              name: tokenrequest
            subjects:
              - kind: ServiceAccount
                name: infisical-gateway
                namespace: infisical
            ---
            apiVersion: rbac.authorization.k8s.io/v1
            kind: ClusterRoleBinding
            metadata:
              name: infisical-dynamic-role-binding-sa
            roleRef:
              apiGroup: rbac.authorization.k8s.io
              kind: ClusterRole
              name: infisical-dynamic-role
            subjects:
              - kind: ServiceAccount
                name: infisical-gateway
                namespace: infisical
            ```

            ```bash  theme={"dark"}
            kubectl apply -f rbac.yaml
            ```
          </Accordion>
        </AccordionGroup>

        <Note>
          In Kubernetes RBAC, a service account can only create role bindings for resources that it has access to.
          This means that if you want to create dynamic service accounts with access to certain resources,
          the service account creating these bindings (either the token requester or Gateway service account)
          must also have access to those same resources. For example, if you want to create dynamic service
          accounts that can access secrets, the token requester service account must also have access to secrets.
        </Note>
      </Tab>
    </Tabs>
  </Step>

  <Step title="Provide the inputs for dynamic secret parameters">
    <ParamField path="Secret Name" type="string" required>
      Name by which you want the secret to be referenced
    </ParamField>

    <ParamField path="Default TTL" type="string" required>
      Default time-to-live for a generated secret (it is possible to modify this value after a secret is generated)
    </ParamField>

    <ParamField path="Max TTL" type="string" required>
      Maximum time-to-live for a generated secret
    </ParamField>

    <ParamField path="Gateway" type="string">
      Select a gateway for private cluster access. If not specified, the Internet Gateway will be used.
    </ParamField>

    <ParamField path="Cluster URL" type="string" required>
      Kubernetes API server URL (e.g., [https://kubernetes.default.svc](https://kubernetes.default.svc)). Not required when using Gateway authentication as the Gateway will use its internal cluster URL.
    </ParamField>

    <ParamField path="Enable SSL" type="boolean">
      Whether to enable SSL verification for the Kubernetes API server connection. Not required when using Gateway authentication as the Gateway will use its internal TLS configuration.
    </ParamField>

    <ParamField path="CA" type="string">
      Custom CA certificate for the Kubernetes API server. Leave blank to use the system/public CA. Not required when using Gateway authentication as the Gateway will use its internal TLS configuration.
    </ParamField>

    <ParamField path="Auth Method" type="string" required>
      Choose between Token (API) or Gateway authentication. If using Gateway, the Gateway must be deployed in your Kubernetes cluster.
    </ParamField>

    <ParamField path="Cluster Token" type="string" required>
      Token with permissions to create service accounts and manage RBAC (required when using Token authentication)
    </ParamField>

    <ParamField path="Credential Type" type="string" required>
      Choose between Static (predefined service account) or Dynamic (temporary service accounts with role assignments)
    </ParamField>

    <Tabs>
      <Tab title="Static Credentials Parameters">
        <ParamField path="Service Account Name" type="string" required>
          Name of the service account to generate tokens for
        </ParamField>

        <ParamField path="Namespace" type="string" required>
          Kubernetes namespace where the service account exists
        </ParamField>
      </Tab>

      <Tab title="Dynamic Credentials Parameters">
        <ParamField path="Allowed Namespaces" type="string" required>
          Kubernetes namespace(s) where the service accounts will be created. You can specify multiple namespaces as a comma-separated list (e.g., "default,kube-system"). During lease creation, you can specify which namespace to use from this allowed list.
        </ParamField>

        <ParamField path="Role Type" type="string" required>
          Type of role to assign (ClusterRole or Role)
        </ParamField>

        <ParamField path="Role" type="string" required>
          Name of the role to assign to the temporary service account
        </ParamField>
      </Tab>
    </Tabs>

    <ParamField path="Audiences" type="array">
      Optional list of audiences to include in the generated token
    </ParamField>

    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-setup-modal-kubernetes-1.png" alt="Dynamic Secret Setup Modal" />
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-setup-modal-kubernetes-2.png" alt="Dynamic Secret Setup Modal" />
  </Step>

  <Step title="Click 'Submit'">
    After submitting the form, you will see a dynamic secret created in the dashboard.
  </Step>
</Steps>

## Generate and Manage Tokens

Once you've successfully configured the dynamic secret, you're ready to generate on-demand service account tokens.
To do this, simply click on the 'Generate' button which appears when hovering over the dynamic secret item.
Alternatively, you can initiate the creation of a new lease by selecting 'New Lease' from the dynamic secret lease list section.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-generate.png" alt="Dynamic Secret" />
<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-lease-empty.png" alt="Dynamic Secret" />

When generating these secrets, it's important to specify a Time-to-Live (TTL) duration. This will dictate how long the credentials are valid for.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/provision-lease.png" alt="Provision Lease" />

<Tip>
  Ensure that the TTL for the lease falls within the maximum TTL defined when
  configuring the dynamic secret.
</Tip>

Once you click the `Submit` button, a new secret lease will be generated and the service account token will be shown to you.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/kubernetes-lease-value.png" alt="Provision Lease" />

## Audit or Revoke Leases

Once you have created one or more leases, you will be able to access them by clicking on the respective dynamic secret item on the dashboard.
This will allow you to see the lease details and delete the lease ahead of its expiration time.

<Note>
  While you can delete the lease from Infisical, the actual Kubernetes service
  account token cannot be revoked. The token will remain valid until its TTL
  expires. This is why it's crucial to use appropriate TTL values when
  generating tokens.
</Note>

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/lease-data.png" alt="Provision Lease" />


# LDAP
Source: https://infisical.com/docs/documentation/platform/dynamic-secrets/ldap

Learn how to dynamically generate user credentials via LDAP.

The Infisical LDAP dynamic secret allows you to generate user credentials on demand via LDAP. The integration is general to any LDAP implementation but has been tested with OpenLDAP and Active directory as of now.

## Prerequisites

1. Create a user with the necessary permissions to create users in your LDAP server.
2. Ensure your LDAP server is reachable via Infisical instance.

## Create LDAP Credentials

<Tabs>
  <Tab title="Dynamic">
    <Steps>
      <Step title="Open Secret Overview Dashboard">
        Open the Secret Overview dashboard and select the environment in which you would like to add a dynamic secret.
      </Step>

      <Step title="Click on the 'Add Dynamic Secret' button">
                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/add-dynamic-secret-button.png" alt="Add Dynamic Secret Button" />
      </Step>

      <Step title="Select 'LDAP'">
                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-ldap-select.png" alt="Dynamic Secret Modal" />
      </Step>

      <Step title="Provide the inputs for dynamic secret parameters">
        <ParamField path="Secret Name" type="string" required>
          Name by which you want the secret to be referenced
        </ParamField>

        <ParamField path="Default TTL" type="string" required>
          Default time-to-live for a generated secret (it is possible to modify this value after a secret is generated)
        </ParamField>

        <ParamField path="Max TTL" type="string" required>
          Maximum time-to-live for a generated secret.
        </ParamField>

        <ParamField path="URL" type="string" required>
          LDAP url to connect to. *(Example: ldap\://your-ldap-ip:389 or ldaps\://domain:636)*
        </ParamField>

        <ParamField path="BIND DN" type="string" required>
          DN to bind to. This should have permissions to create a new users.
        </ParamField>

        <ParamField path="BIND Password" type="string" required>
          Password for the given DN.
        </ParamField>

        <ParamField path="CA" type="text">
          CA certificate to use for TLS in case of a secure connection.
        </ParamField>

        <ParamField path="Credential Type" type="enum">
          The type of LDAP credential - select Dynamic.
        </ParamField>

        <ParamField path="Creation LDIF" type="text" required>
          LDIF to run while creating a user in LDAP. This can include extra steps to assign the user to groups or set permissions.
          Here `{{Username}}`, `{{Password}}` and `{{EncodedPassword}}` are templatized variables for the username and password generated by the dynamic secret.

          `{{EncodedPassword}}` is the encoded password required for the `unicodePwd` field in Active Directory as described [here](https://learn.microsoft.com/en-us/troubleshoot/windows-server/active-directory/change-windows-active-directory-user-password).

          **OpenLDAP** Example:

          ```
          dn: uid={{Username}},dc=infisical,dc=com
          changetype: add
          objectClass: top
          objectClass: person
          objectClass: organizationalPerson
          objectClass: inetOrgPerson
          cn: John Doe
          sn: Doe
          uid: jdoe
          mail: jdoe@infisical.com
          userPassword: {{Password}}
          ```

          **Active Directory** Example:

          ```
          dn: CN={{Username}},OU=Test Create,DC=infisical,DC=com
          changetype: add
          objectClass: top
          objectClass: person
          objectClass: organizationalPerson
          objectClass: user
          userPrincipalName: {{Username}}@infisical.com
          sAMAccountName: {{Username}}
          unicodePwd::{{EncodedPassword}}
          userAccountControl: 66048

          dn: CN=test-group,OU=Test Create,DC=infisical,DC=com
          changetype: modify
          add: member
          member:  CN={{Username}},OU=Test Create,DC=infisical,DC=com
          -
          ```
        </ParamField>

        <ParamField path="Revocation LDIF" type="text" required>
          LDIF to run while revoking a user in LDAP. This can include extra steps to remove the user from groups or set permissions.
          Here `{{Username}}` is a templatized variable for the username generated by the dynamic secret.

          **OpenLDAP / Active Directory** Example:

          ```
          dn: CN={{Username}},OU=Test Create,DC=infisical,DC=com
          changetype: delete
          ```
        </ParamField>

        <ParamField path="Rollback LDIF" type="text">
          LDIF to run incase Creation LDIF fails midway.

          For the creation example shown above, if the user is created successfully but not added to a group, this LDIF can be used to remove the user.
          Here `{{Username}}`, `{{Password}}` and `{{EncodedPassword}}` are templatized variables for the username generated by the dynamic secret.

          **OpenLDAP / Active Directory** Example:

          ```
          dn: CN={{Username}},OU=Test Create,DC=infisical,DC=com
          changetype: delete
          ```
        </ParamField>

        <ParamField path="Username Template" type="string" default="{{randomUsername}}">
          Specifies a template for generating usernames. This field allows customization of how usernames are automatically created.

          Allowed template variables are

          * `{{randomUsername}}`: Random username string
          * `{{unixTimestamp}}`: Current Unix timestamp
          * `{{identity.name}}`: Name of the identity that is generating the secret
          * `{{random N}}`: Random string of N characters

          Allowed template functions are

          * `truncate`: Truncates a string to a specified length
          * `replace`: Replaces a substring with another value

          Examples:

          ```
          {{randomUsername}}                              // 3POnzeFyK9gW2nioK0q2gMjr6CZqsRiX
          {{unixTimestamp}}                               // 17490641580
          {{identity.name}}                               // testuser
          {{random-5}}                                    // x9k2m
          {{truncate identity.name 4}}                    // test
          {{replace identity.name 'user' 'replace'}}      // testreplace
          ```
        </ParamField>
      </Step>

      <Step title="Click `Submit`">
        After submitting the form, you will see a dynamic secret created in the dashboard.
      </Step>

      <Step title="Generate dynamic secrets">
        Once you've successfully configured the dynamic secret, you're ready to generate on-demand credentials.
        To do this, simply click on the 'Generate' button which appears when hovering over the dynamic secret item.
        Alternatively, you can initiate the creation of a new lease by selecting 'New Lease' from the dynamic secret lease list section.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-generate.png" alt="Dynamic Secret" />
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-lease-empty.png" alt="Dynamic Secret" />

        When generating these secrets, it's important to specify a Time-to-Live (TTL) duration. This will dictate how long the credentials are valid for.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/provision-lease.png" alt="Provision Lease" />

        <Tip>
          Ensure that the TTL for the lease falls within the maximum TTL defined when configuring the dynamic secret.
        </Tip>

        Once you click the `Submit` button, a new secret lease will be generated and the credentials from it will be shown to you with an array of DN's altered depending on the Creation LDIF.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-ldap-lease.png" alt="Provision Lease" />
      </Step>
    </Steps>
  </Tab>

  <Tab title="Static">
    <Steps>
      <Step title="Open Secret Overview Dashboard">
        Open the Secret Overview dashboard and select the environment in which you would like to add a dynamic secret.
      </Step>

      <Step title="Click on the 'Add Dynamic Secret' button">
                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/add-dynamic-secret-button.png" alt="Add Dynamic Secret Button" />
      </Step>

      <Step title="Select 'LDAP'">
                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-ldap-select.png" alt="Dynamic Secret Modal" />
      </Step>

      <Step title="Provide the inputs for dynamic secret parameters">
        <ParamField path="Secret Name" type="string" required>
          Name by which you want the secret to be referenced
        </ParamField>

        <ParamField path="Default TTL" type="string" required>
          Default time-to-live for a generated secret (it is possible to modify this value after a secret is generated)
        </ParamField>

        <ParamField path="Max TTL" type="string" required>
          Maximum time-to-live for a generated secret.
        </ParamField>

        <ParamField path="URL" type="string" required>
          LDAP url to connect to. *(Example: ldap\://your-ldap-ip:389 or ldaps\://domain:636)*
        </ParamField>

        <ParamField path="BIND DN" type="string" required>
          DN to bind to. This should have permissions to create a new users.
        </ParamField>

        <ParamField path="BIND Password" type="string" required>
          Password for the given DN.
        </ParamField>

        <ParamField path="CA" type="text">
          CA certificate to use for TLS in case of a secure connection.
        </ParamField>

        <ParamField path="Credential Type" type="enum">
          The type of LDAP credential - select Static.
        </ParamField>

        <ParamField path="Rotation LDIF" type="text" required>
          LDIF to run for rotating the credentals of an LDAP user. This can include extra LDAP steps based on your needs.
          Here `{{Password}}` and `{{EncodedPassword}}` are templatized variables for the password generated by the dynamic secret.

          Note that the `-` characters and the empty lines found at the end of the examples are necessary based on the LDIF format.

          **OpenLDAP** Example:

          ```
          dn: cn=sheencaps capadngan,ou=people,dc=acme,dc=com
          changetype: modify
          replace: userPassword
          password: {{Password}}
          -

          ```

          **Active Directory** Example:

          ```
          dn: cn=sheencaps capadngan,ou=people,dc=acme,dc=com
          changetype: modify
          replace: unicodePwd
          unicodePwd::{{EncodedPassword}}
          -

          ```

          `{{EncodedPassword}}` is the encoded password required for the `unicodePwd` field in Active Directory as described [here](https://learn.microsoft.com/en-us/troubleshoot/windows-server/active-directory/change-windows-active-directory-user-password).
        </ParamField>
      </Step>

      <Step title="Click `Submit`">
        After submitting the form, you will see a dynamic secret created in the dashboard.
      </Step>

      <Step title="Generate dynamic secrets">
        Once you've successfully configured the dynamic secret, you're ready to generate on-demand credentials.
        To do this, simply click on the 'Generate' button which appears when hovering over the dynamic secret item.
        Alternatively, you can initiate the creation of a new lease by selecting 'New Lease' from the dynamic secret lease list section.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-generate.png" alt="Dynamic Secret" />
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-lease-empty.png" alt="Dynamic Secret" />

        When generating these secrets, it's important to specify a Time-to-Live (TTL) duration. This will dictate how long the credentials are valid for.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/provision-lease.png" alt="Provision Lease" />

        <Tip>
          Ensure that the TTL for the lease falls within the maximum TTL defined when configuring the dynamic secret.
        </Tip>

        Once you click the `Submit` button, a new secret lease will be generated and the credentials from it will be shown to you with an array of DN's altered depending on the Creation LDIF.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-ldap-lease.png" alt="Provision Lease" />
      </Step>
    </Steps>
  </Tab>
</Tabs>

## Active Directory Integration

* Passwords in Active Directory are set using the `unicodePwd` field. This must be proceeded by two colons `::` as shown in the example. [Source](https://learn.microsoft.com/en-us/troubleshoot/windows-server/active-directory/change-windows-active-directory-user-password)
* Active directory uses the `userAccountControl` field to enable account. [Read More](https://learn.microsoft.com/en-us/troubleshoot/windows-server/active-directory/useraccountcontrol-manipulate-account-properties)
  * `userAccountControl` set to `512` enables a user.
  * To disable AD's password expiration for this dynamic user account. The `userAccountControl` value for this is: `65536`.
  * Since `userAccountControl` flag is cumulative set it to `512 + 65536` = `66048` to do both.
* Active Directory does not permit direct modification of a user's `memberOf` attribute. The member attribute of a group and the `memberOf` attribute of a user are [linked attributes](https://learn.microsoft.com/en-us/windows/win32/ad/linked-attributes), where the member attribute represents the forward link, which can be modified. In the context of AD group membership, the group's `member` attribute serves as the forward link. Therefore, to add a newly created dynamic user to a group, a modification request must be issued to the desired group, updating its membership to include the new user.

## LDIF Entries

User account management is handled through **LDIF entries**.

#### Things to Remember

* **No trailing spaces:** Ensure there are no trailing spaces on any line, including blank lines.
* **Empty lines before modify blocks:** Every modify block must be preceded by an empty line.
* **Multiple modifications:** You can define multiple modifications for a DN within a single modify block. Each modification should end with a single dash (`-`).


# Mongo Atlas
Source: https://infisical.com/docs/documentation/platform/dynamic-secrets/mongo-atlas

Learn how to dynamically generate Mongo Atlas Database user credentials.

The Infisical Mongo Atlas dynamic secret allows you to generate Mongo Atlas Database credentials on demand based on configured role.

## Prerequisite

Create a project scoped API Key with the required permission in your Mongo Atlas following the [official doc](https://www.mongodb.com/docs/atlas/configure-api-access/#grant-programmatic-access-to-a-project).

<Info>The API Key must have permission to manage users in the project.</Info>

## Set up Dynamic Secrets with Mongo Atlas

<Steps>
  <Step title="Open Secret Overview Dashboard">
    Open the Secret Overview dashboard and select the environment in which you would like to add a dynamic secret.
  </Step>

  <Step title="Click on the 'Add Dynamic Secret' button">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/add-dynamic-secret-button.png" alt="Add Dynamic Secret Button" />
  </Step>

  <Step title="Select Mongo Atlas">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-atlas-modal.png" alt="Dynamic Secret Modal" />
  </Step>

  <Step title="Provide the inputs for dynamic secret parameters">
    <ParamField path="Secret Name" type="string" required>
      Name by which you want the secret to be referenced
    </ParamField>

    <ParamField path="Default TTL" type="string" required>
      Default time-to-live for a generated secret (it is possible to modify this value after a secret is generated)
    </ParamField>

    <ParamField path="Max TTL" type="string" required>
      Maximum time-to-live for a generated secret
    </ParamField>

    <ParamField path="Admin public key" type="string" required>
      The public key of your generated Atlas API Key. This acts as a username.
    </ParamField>

    <ParamField path="Admin private key" type="string" required>
      The private key of your generated Atlas API Key. This acts as a password.
    </ParamField>

    <ParamField path="Group ID" type="number" required>
      Unique 24-hexadecimal digit string that identifies your project. This is same as project id
    </ParamField>

    <ParamField path="Roles" type="string" required>
      List that provides the pairings of one role with one applicable database.

      * **Database Name**: Database to which the user is granted access privileges.
      * **Collection**: Collection on which this role applies.
      * **Role Name**: Human-readable label that identifies a group of privileges assigned to a database user. This value can either be a built-in role or a custom role.
        * Enum: `atlasAdmin` `backup` `clusterMonitor` `dbAdmin` `dbAdminAnyDatabase` `enableSharding` `read` `readAnyDatabase` `readWrite` `readWriteAnyDatabase` `<a custom role name>`.
    </ParamField>

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-modal-atlas.png" alt="Dynamic Secret Setup Modal" />
  </Step>

  <Step title="(Optional) Modify Access Scope">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/advanced-option-atlas.png" alt="Modify Scope Modal" />

    <ParamField path="Username Template" type="string" default="{{randomUsername}}">
      Specifies a template for generating usernames. This field allows customization of how usernames are automatically created.

      Allowed template variables are

      * `{{randomUsername}}`: Random username string
      * `{{unixTimestamp}}`: Current Unix timestamp
      * `{{identity.name}}`: Name of the identity that is generating the secret
      * `{{random N}}`: Random string of N characters

      Allowed template functions are

      * `truncate`: Truncates a string to a specified length
      * `replace`: Replaces a substring with another value

      Examples:

      ```
      {{randomUsername}}                              // 3POnzeFyK9gW2nioK0q2gMjr6CZqsRiX
      {{unixTimestamp}}                               // 17490641580
      {{identity.name}}                               // testuser
      {{random-5}}                                    // x9k2m
      {{truncate identity.name 4}}                    // test
      {{replace identity.name 'user' 'replace'}}      // testreplace
      ```
    </ParamField>

    <ParamField path="Customize Scope" type="string">
      List that contains clusters, MongoDB Atlas Data Lakes, and MongoDB Atlas Streams Instances that this database user can access. If omitted, MongoDB Cloud grants the database user access to all the clusters, MongoDB Atlas Data Lakes, and MongoDB Atlas Streams Instances in the project.

      * **Label**: Human-readable label that identifies the cluster or MongoDB Atlas Data Lake that this database user can access.
      * **Type**: Category of resource that this database user can access.
    </ParamField>
  </Step>

  <Step title="Click 'Submit'">
    After submitting the form, you will see a dynamic secret created in the dashboard.

    <Note>
      If this step fails, you may have to add the CA certificate.
    </Note>

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret.png" alt="Dynamic Secret" />
  </Step>

  <Step title="Generate dynamic secrets">
    Once you've successfully configured the dynamic secret, you're ready to generate on-demand credentials.
    To do this, simply click on the 'Generate' button which appears when hovering over the dynamic secret item.
    Alternatively, you can initiate the creation of a new lease by selecting 'New Lease' from the dynamic secret lease list section.

    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-generate.png" alt="Dynamic Secret" />
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-lease-empty.png" alt="Dynamic Secret" />

    When generating these secrets, it's important to specify a Time-to-Live (TTL) duration. This will dictate how long the credentials are valid for.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/provision-lease.png" alt="Provision Lease" />

    <Tip>
      Ensure that the TTL for the lease falls within the maximum TTL defined when configuring the dynamic secret.
    </Tip>

    Once you click the `Submit` button, a new secret lease will be generated and the credentials for it will be shown to you.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/lease-values.png" alt="Provision Lease" />
  </Step>
</Steps>

## Audit or Revoke Leases

Once you have created one or more leases, you will be able to access them by clicking on the respective dynamic secret item on the dashboard.
This will allow you to see the expiration time of the lease or delete a lease before it's set time to live.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/lease-data.png" alt="Provision Lease" />

## Renew Leases

To extend the life of the generated dynamic secret leases past its initial time to live, simply click on the **Renew** button as illustrated below.
<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-lease-renew.png" alt="Provision Lease" />

<Warning>
  Lease renewals cannot exceed the maximum TTL set when configuring the dynamic
  secret
</Warning>


# Mongo DB
Source: https://infisical.com/docs/documentation/platform/dynamic-secrets/mongo-db

Learn how to dynamically generate Mongo DB Database user credentials.

The Infisical Mongo DB dynamic secret allows you to generate Mongo DB Database credentials on demand based on configured role.

<Info>
  If your using Mongo Atlas, please use [Atlas Dynamic Secret](./mongo-atlas) as MongoDB commands are not supported by atlas.
</Info>

## Prerequisite

Create a user with the required permission in your MongoDB instance. This user will be used to create new accounts on-demand.

## Set up Dynamic Secrets with Mongo DB

<Steps>
  <Step title="Open Secret Overview Dashboard">
    Open the Secret Overview dashboard and select the environment in which you would like to add a dynamic secret.
  </Step>

  <Step title="Click on the 'Add Dynamic Secret' button">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/add-dynamic-secret-button.png" alt="Add Dynamic Secret Button" />
  </Step>

  <Step title="Select Mongo DB">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-modal-mongodb.png" alt="Dynamic Secret Modal" />
  </Step>

  <Step title="Provide the inputs for dynamic secret parameters">
    <ParamField path="Secret Name" type="string" required>
      Name by which you want the secret to be referenced
    </ParamField>

    <ParamField path="Default TTL" type="string" required>
      Default time-to-live for a generated secret (it is possible to modify this value after a secret is generated)
    </ParamField>

    <ParamField path="Max TTL" type="string" required>
      Maximum time-to-live for a generated secret
    </ParamField>

    <ParamField path="Host" type="string" required>
      Database host URL.
    </ParamField>

    <ParamField path="Port" type="number">
      Database port number. If your Mongo DB is cluster you can omit this.
    </ParamField>

    <ParamField path="User" type="string" required>
      Username of the admin user that will be used to create dynamic secrets
    </ParamField>

    <ParamField path="Password" type="string" required>
      Password of the admin user that will be used to create dynamic secrets
    </ParamField>

    <ParamField path="Database Name" type="string" required>
      Name of the database for which you want to create dynamic secrets
    </ParamField>

    <ParamField path="Roles" type="list" required>
      Human-readable label that identifies a group of privileges assigned to a database user. This value can either be a built-in role or a custom role.

      * Enum: `atlasAdmin` `backup` `clusterMonitor` `dbAdmin` `dbAdminAnyDatabase` `enableSharding` `read` `readAnyDatabase` `readWrite` `readWriteAnyDatabase` `<a custom role name>`.
    </ParamField>

    <ParamField path="CA(SSL)" type="string">
      A CA may be required if your DB requires it for incoming connections.
    </ParamField>

    <ParamField path="Username Template" type="string" default="{{randomUsername}}">
      Specifies a template for generating usernames. This field allows customization of how usernames are automatically created.

      Allowed template variables are

      * `{{randomUsername}}`: Random username string
      * `{{unixTimestamp}}`: Current Unix timestamp
      * `{{identity.name}}`: Name of the identity that is generating the secret
      * `{{random N}}`: Random string of N characters

      Allowed template functions are

      * `truncate`: Truncates a string to a specified length
      * `replace`: Replaces a substring with another value

      Examples:

      ```
      {{randomUsername}}                              // 3POnzeFyK9gW2nioK0q2gMjr6CZqsRiX
      {{unixTimestamp}}                               // 17490641580
      {{identity.name}}                               // testuser
      {{random-5}}                                    // x9k2m
      {{truncate identity.name 4}}                    // test
      {{replace identity.name 'user' 'replace'}}      // testreplace
      ```
    </ParamField>

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-mongodb.png" alt="Dynamic Secret Setup Modal" />
  </Step>

  <Step title="Click `Submit`">
    After submitting the form, you will see a dynamic secret created in the dashboard.

    <Note>
      If this step fails, you may have to add the CA certificate.
    </Note>
  </Step>

  <Step title="Generate dynamic secrets">
    Once you've successfully configured the dynamic secret, you're ready to generate on-demand credentials.
    To do this, simply click on the 'Generate' button which appears when hovering over the dynamic secret item.
    Alternatively, you can initiate the creation of a new lease by selecting 'New Lease' from the dynamic secret lease list section.

    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-generate.png" alt="Dynamic Secret" />
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-lease-empty.png" alt="Dynamic Secret" />

    When generating these secrets, it's important to specify a Time-to-Live (TTL) duration. This will dictate how long the credentials are valid for.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/provision-lease.png" alt="Provision Lease" />

    <Tip>
      Ensure that the TTL for the lease falls within the maximum TTL defined when configuring the dynamic secret.
    </Tip>

    Once you click the `Submit` button, a new secret lease will be generated and the credentials from it will be shown to you.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/lease-values.png" alt="Provision Lease" />
  </Step>
</Steps>

## Audit or Revoke Leases

Once you have created one or more leases, you will be able to access them by clicking on the respective dynamic secret item on the dashboard.
This will allow you to see the expiration time of the lease or delete a lease before it's set time to live.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/lease-data.png" alt="Provision Lease" />

## Renew Leases

To extend the life of the generated dynamic secret leases past its initial time to live, simply click on the **Renew** button as illustrated below.
<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-lease-renew.png" alt="Provision Lease" />

<Warning>
  Lease renewals cannot exceed the maximum TTL set when configuring the dynamic secret
</Warning>


# MS SQL
Source: https://infisical.com/docs/documentation/platform/dynamic-secrets/mssql

Learn how to dynamically generate MS SQL database user credentials.

The Infisical MS SQL dynamic secret allows you to generate Microsoft SQL server database credentials on demand based on configured role.

## Prerequisite

Create a user with the required permission in your SQL instance. This user will be used to create new accounts on-demand.

## Set up Dynamic Secrets with MS SQL

<Steps>
  <Step title="Open Secret Overview Dashboard">
    Open the Secret Overview dashboard and select the environment in which you would like to add a dynamic secret.
  </Step>

  <Step title="Click on the 'Add Dynamic Secret' button">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/add-dynamic-secret-button.png" alt="Add Dynamic Secret Button" />
  </Step>

  <Step title="Select `SQL Database`">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-modal.png" alt="Dynamic Secret Modal" />
  </Step>

  <Step title="Provide the inputs for dynamic secret parameters">
    <ParamField path="Secret Name" type="string" required>
      Name by which you want the secret to be referenced
    </ParamField>

    <ParamField path="Default TTL" type="string" required>
      Default time-to-live for a generated secret (it is possible to modify this value after a secret is generated)
    </ParamField>

    <ParamField path="Max TTL" type="string" required>
      Maximum time-to-live for a generated secret
    </ParamField>

    <ParamField path="Metadata" type="list" required>
      List of key/value metadata pairs
    </ParamField>

    <ParamField path="Service" type="string" required>
      Choose the service you want to generate dynamic secrets for. This must be selected as **MS SQL**.
    </ParamField>

    <ParamField path="Host" type="string" required>
      Database host
    </ParamField>

    <ParamField path="Port" type="number" required>
      Database port
    </ParamField>

    <ParamField path="User" type="string" required>
      Username that will be used to create dynamic secrets
    </ParamField>

    <ParamField path="Password" type="string" required>
      Password that will be used to create dynamic secrets
    </ParamField>

    <ParamField path="Database Name" type="string" required>
      Name of the database for which you want to create dynamic secrets
    </ParamField>

    <ParamField path="CA(SSL)" type="string">
      A CA may be required if your DB requires it for incoming connections. AWS RDS instances with default settings will requires a CA which can be downloaded [here](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/UsingWithRDS.SSL.html#UsingWithRDS.SSL.CertificatesAllRegions).
    </ParamField>

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-setup-modal-mssql.png" alt="Dynamic Secret Setup Modal" />
  </Step>

  <Step title="(Optional) Modify SQL Statements">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/modify-sql-statements-mssql.png" alt="Modify SQL Statements Modal" />

    <ParamField path="Username Template" type="string" default="{{randomUsername}}">
      Specifies a template for generating usernames. This field allows customization of how usernames are automatically created.

      Allowed template variables are

      * `{{randomUsername}}`: Random username string
      * `{{unixTimestamp}}`: Current Unix timestamp
      * `{{identity.name}}`: Name of the identity that is generating the secret
      * `{{random N}}`: Random string of N characters

      Allowed template functions are

      * `truncate`: Truncates a string to a specified length
      * `replace`: Replaces a substring with another value

      Examples:

      ```
      {{randomUsername}}                              // 3POnzeFyK9gW2nioK0q2gMjr6CZqsRiX
      {{unixTimestamp}}                               // 17490641580
      {{identity.name}}                               // testuser
      {{random-5}}                                    // x9k2m
      {{truncate identity.name 4}}                    // test
      {{replace identity.name 'user' 'replace'}}      // testreplace
      ```
    </ParamField>
  </Step>

  <Step title="Click 'Submit'">
    After submitting the form, you will see a dynamic secret created in the dashboard.

    <Note>
      If this step fails, you may have to add the CA certificate.
    </Note>

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret.png" alt="Dynamic Secret" />
  </Step>

  <Step title="Generate dynamic secrets">
    Once you've successfully configured the dynamic secret, you're ready to generate on-demand credentials.
    To do this, simply click on the 'Generate' button which appears when hovering over the dynamic secret item.
    Alternatively, you can initiate the creation of a new lease by selecting 'New Lease' from the dynamic secret lease list section.

    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-generate.png" alt="Dynamic Secret" />
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-lease-empty.png" alt="Dynamic Secret" />

    When generating these secrets, it's important to specify a Time-to-Live (TTL) duration. This will dictate how long the credentials are valid for.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/provision-lease.png" alt="Provision Lease" />

    <Tip>
      Ensure that the TTL for the lease falls within the maximum TTL defined when configuring the dynamic secret.
    </Tip>

    Once you click the `Submit` button, a new secret lease will be generated and the credentials for it will be shown to you.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/lease-values.png" alt="Provision Lease" />
  </Step>
</Steps>

## Audit or Revoke Leases

Once you have created one or more leases, you will be able to access them by clicking on the respective dynamic secret item on the dashboard.
This will allow you to see the expiration time of the lease or delete the lease before it's set time to live.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/lease-data.png" alt="Provision Lease" />

## Renew Leases

To extend the life of the generated dynamic secret leases past its initial time to live, simply click on the **Renew** button as illustrated below.
<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-lease-renew.png" alt="Provision Lease" />

<Warning>
  Lease renewals cannot exceed the maximum TTL set when configuring the dynamic
  secret
</Warning>


# MySQL
Source: https://infisical.com/docs/documentation/platform/dynamic-secrets/mysql

Learn how to dynamically generate MySQL Database user credentials.

The Infisical MySQL dynamic secret allows you to generate MySQL Database credentials on demand based on configured role.

## Prerequisite

Create a user with the required permission in your SQL instance. This user will be used to create new accounts on-demand.

## Set up Dynamic Secrets with MySQL

<Steps>
  <Step title="Open Secret Overview Dashboard">
    Open the Secret Overview dashboard and select the environment in which you would like to add a dynamic secret.
  </Step>

  <Step title="Click on the 'Add Dynamic Secret' button">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/add-dynamic-secret-button.png" alt="Add Dynamic Secret Button" />
  </Step>

  <Step title="Select 'SQL Database'">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-modal.png" alt="Dynamic Secret Modal" />
  </Step>

  <Step title="Provide the inputs for dynamic secret parameters">
    <ParamField path="Secret Name" type="string" required>
      Name by which you want the secret to be referenced
    </ParamField>

    <ParamField path="Default TTL" type="string" required>
      Default time-to-live for a generated secret (it is possible to modify this value after a secret is generated)
    </ParamField>

    <ParamField path="Max TTL" type="string" required>
      Maximum time-to-live for a generated secret
    </ParamField>

    <ParamField path="Metadata" type="list" required>
      List of key/value metadata pairs
    </ParamField>

    <ParamField path="Service" type="string" required>
      Choose the service you want to generate dynamic secrets for. This must be selected as **MySQL**.
    </ParamField>

    <ParamField path="Host" type="string" required>
      Database host
    </ParamField>

    <ParamField path="Port" type="number" required>
      Database port
    </ParamField>

    <ParamField path="User" type="string" required>
      Username that will be used to create dynamic secrets
    </ParamField>

    <ParamField path="Password" type="string" required>
      Password that will be used to create dynamic secrets
    </ParamField>

    <ParamField path="Database Name" type="string" required>
      Name of the database for which you want to create dynamic secrets
    </ParamField>

    <ParamField path="CA(SSL)" type="string">
      A CA may be required if your DB requires it for incoming connections. AWS RDS instances with default settings will requires a CA which can be downloaded [here](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/UsingWithRDS.SSL.html#UsingWithRDS.SSL.CertificatesAllRegions).
    </ParamField>
  </Step>

  <Step title="(Optional) Modify SQL Statements">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/modify-sql-statement-mysql.png" alt="Modify SQL Statements Modal" />

    <ParamField path="Username Template" type="string" default="{{randomUsername}}">
      Specifies a template for generating usernames. This field allows customization of how usernames are automatically created.

      Allowed template variables are

      * `{{randomUsername}}`: Random username string
      * `{{unixTimestamp}}`: Current Unix timestamp
      * `{{identity.name}}`: Name of the identity that is generating the secret
      * `{{random N}}`: Random string of N characters

      Allowed template functions are

      * `truncate`: Truncates a string to a specified length
      * `replace`: Replaces a substring with another value

      Examples:

      ```
      {{randomUsername}}                              // 3POnzeFyK9gW2nioK0q2gMjr6CZqsRiX
      {{unixTimestamp}}                               // 17490641580
      {{identity.name}}                               // testuser
      {{random-5}}                                    // x9k2m
      {{truncate identity.name 4}}                    // test
      {{replace identity.name 'user' 'replace'}}      // testreplace
      ```
    </ParamField>
  </Step>

  <Step title="Click `Submit`">
    After submitting the form, you will see a dynamic secret created in the dashboard.

    <Note>
      If this step fails, you may have to add the CA certificate.
    </Note>

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret.png" alt="Dynamic Secret" />
  </Step>

  <Step title="Generate dynamic secrets">
    Once you've successfully configured the dynamic secret, you're ready to generate on-demand credentials.
    To do this, simply click on the 'Generate' button which appears when hovering over the dynamic secret item.
    Alternatively, you can initiate the creation of a new lease by selecting 'New Lease' from the dynamic secret lease list section.

    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-generate.png" alt="Dynamic Secret" />
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-lease-empty.png" alt="Dynamic Secret" />

    When generating these secrets, it's important to specify a Time-to-Live (TTL) duration. This will dictate how long the credentials are valid for.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/provision-lease.png" alt="Provision Lease" />

    <Tip>
      Ensure that the TTL for the lease falls within the maximum TTL defined when configuring the dynamic secret.
    </Tip>

    Once you click the `Submit` button, a new secret lease will be generated and the credentials from it will be shown to you.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/lease-values.png" alt="Provision Lease" />
  </Step>
</Steps>

## Audit or Revoke Leases

Once you have created one or more leases, you will be able to access them by clicking on the respective dynamic secret item on the dashboard.
This will allow you to see the expiration time of the lease or delete a lease before it's set time to live.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/lease-data.png" alt="Provision Lease" />

## Renew Leases

To extend the life of the generated dynamic secret leases past its initial time to live, simply click on the **Renew** button as illustrated below.
<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-lease-renew.png" alt="Provision Lease" />

<Warning>
  Lease renewals cannot exceed the maximum TTL set when configuring the dynamic secret
</Warning>


# Oracle
Source: https://infisical.com/docs/documentation/platform/dynamic-secrets/oracle

Learn how to dynamically generate Oracle Database user credentials.

The Infisical Oracle dynamic secret allows you to generate Oracle Database credentials on demand based on configured role.

## Prerequisite

Create a user with the required permission in your SQL instance. This user will be used to create new accounts on-demand.

## Set up Dynamic Secrets with Oracle

<Steps>
  <Step title="Open Secret Overview Dashboard">
    Open the Secret Overview dashboard and select the environment in which you would like to add a dynamic secret.
  </Step>

  <Step title="Click on the 'Add Dynamic Secret' button">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/add-dynamic-secret-button.png" alt="Add Dynamic Secret Button" />
  </Step>

  <Step title="Select `SQL Database`">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-modal.png" alt="Dynamic Secret Modal" />
  </Step>

  <Step title="Provide the inputs for dynamic secret parameters">
    <ParamField path="Secret Name" type="string" required>
      Name by which you want the secret to be referenced
    </ParamField>

    <ParamField path="Default TTL" type="string" required>
      Default time-to-live for a generated secret (it is possible to modify this value after a secret is generated)
    </ParamField>

    <ParamField path="Max TTL" type="string" required>
      Maximum time-to-live for a generated secret
    </ParamField>

    <ParamField path="Metadata" type="list" required>
      List of key/value metadata pairs
    </ParamField>

    <ParamField path="Service" type="string" required>
      Choose the service you want to generate dynamic secrets for. This must be selected as **Oracle**.
    </ParamField>

    <ParamField path="Host" type="string" required>
      Database host
    </ParamField>

    <ParamField path="Port" type="number" required>
      Database port
    </ParamField>

    <ParamField path="User" type="string" required>
      Username that will be used to create dynamic secrets
    </ParamField>

    <ParamField path="Password" type="string" required>
      Password that will be used to create dynamic secrets
    </ParamField>

    <ParamField path="Database Name" type="string" required>
      Name of the database for which you want to create dynamic secrets
    </ParamField>

    <ParamField path="CA(SSL)" type="string">
      A CA may be required if your DB requires it for incoming connections. AWS RDS instances with default settings will requires a CA which can be downloaded [here](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/UsingWithRDS.SSL.html#UsingWithRDS.SSL.CertificatesAllRegions).
    </ParamField>

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-setup-modal-oracle.png" alt="Dynamic Secret Setup Modal" />
  </Step>

  <Step title="(Optional) Modify SQL Statements">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/modify-sql-statement-oracle.png" alt="Modify SQL Statements Modal" />

    <ParamField path="Username Template" type="string" default="{{randomUsername}}">
      Specifies a template for generating usernames. This field allows customization of how usernames are automatically created.

      Allowed template variables are

      * `{{randomUsername}}`: Random username string
      * `{{unixTimestamp}}`: Current Unix timestamp
      * `{{identity.name}}`: Name of the identity that is generating the secret
      * `{{random N}}`: Random string of N characters

      Allowed template functions are

      * `truncate`: Truncates a string to a specified length
      * `replace`: Replaces a substring with another value

      Examples:

      ```
      {{randomUsername}}                              // 3POnzeFyK9gW2nioK0q2gMjr6CZqsRiX
      {{unixTimestamp}}                               // 17490641580
      {{identity.name}}                               // testuser
      {{random-5}}                                    // x9k2m
      {{truncate identity.name 4}}                    // test
      {{replace identity.name 'user' 'replace'}}      // testreplace
      ```
    </ParamField>
  </Step>

  <Step title="Click 'Submit'">
    After submitting the form, you will see a dynamic secret created in the dashboard.

    <Note>
      If this step fails, you may have to add the CA certificate.
    </Note>

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret.png" alt="Dynamic Secret" />
  </Step>

  <Step title="Generate dynamic secrets">
    Once you've successfully configured the dynamic secret, you're ready to generate on-demand credentials.
    To do this, simply click on the 'Generate' button which appears when hovering over the dynamic secret item.
    Alternatively, you can initiate the creation of a new lease by selecting 'New Lease' from the dynamic secret lease list section.

    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-generate.png" alt="Dynamic Secret" />
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-lease-empty.png" alt="Dynamic Secret" />

    When generating these secrets, it's important to specify a Time-to-Live (TTL) duration. This will dictate how long the credentials are valid for.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/provision-lease.png" alt="Provision Lease" />

    <Tip>
      Ensure that the TTL for the lease falls within the maximum TTL defined when configuring the dynamic secret.
    </Tip>

    Once you click the `Submit` button, a new secret lease will be generated and the credentials for it will be shown to you.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/lease-values.png" alt="Provision Lease" />
  </Step>
</Steps>

## Audit or Revoke Leases

Once you have created one or more leases, you will be able to access them by clicking on the respective dynamic secret item on the dashboard.
This will allow you to see the expiration time of the lease or delete a lease before it's set time to live.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/lease-data.png" alt="Provision Lease" />

## Renew Leases

To extend the life of the generated dynamic secret leases past its initial time to live, simply click on the **Renew** button as illustrated below.
<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-lease-renew.png" alt="Provision Lease" />

<Warning>
  Lease renewals cannot exceed the maximum TTL set when configuring the dynamic secret
</Warning>


# Dynamic Secrets
Source: https://infisical.com/docs/documentation/platform/dynamic-secrets/overview

Learn how to generate secrets dynamically on-demand.

<Info>
  Note that Dynamic Secrets is a paid feature.

  If you're using Infisical Cloud, then it is available under the **Enterprise Tier**
  If you're self-hosting Infisical, then you should contact [sales@infisical.com](mailto:sales@infisical.com) to purchase an enterprise license to use it.
</Info>

## Introduction

Contrary to static key-value secrets, which require manual input of data into the secure Infisical storage, **dynamic secrets are generated on-demand upon access**.

**Dynamic secrets are unique to every identity using them**. Such secrets come are generated only at the moment they are retrieved, eliminating the possibility of theft or reuse by another identity. Thanks to Infisical's integrated revocation capabilities, dynamic secrets can be promptly invalidated post-use, significantly reducing their lifespan.

## Benefits of Dynamic Secrets

This approach offers several advantages in terms of security and management:

* **Enhanced Security**: By frequently changing secrets, dynamic secrets minimize the risk associated with secret compromise. Even if an attacker manages to obtain a secret, it would likely be invalid by the time they attempt to use it.

* **Reduced Secret Lifetime**: The limited validity period of dynamic secrets means that they are less valuable targets for attackers. This inherently reduces the time window during which a secret can be exploited.

* **Automated Management**: Dynamic secrets enable automated systems to handle the generation, distribution, revocation, and rotation of secrets without human intervention, thus reducing the risk of human error.

* **Auditing and Traceability**: The generation of dynamic secrets can be tightly controlled and monitored. This allows for detailed auditing of who accessed what secret and when, improving overall security posture and compliance with regulatory standards.

* **Scalability**: Dynamic secret management systems can scale more effectively to handle a large number of services and applications, as they automate much of the overhead associated with manual secret management.

Dynamic secrets are particularly useful in environments with stringent security requirements, such as cloud environments, distributed systems, and microservices architectures, where they help to manage database credentials, API keys, tokens, and other types of secrets.

## Infisical Dynamic Secret Templates

1. [PostgreSQL](./postgresql)
2. [MySQL](./mysql)
3. [Cassandra](./cassandra)
4. [Oracle](./oracle)
5. [Redis](./redis)
6. [AWS IAM](./aws-iam)

**FAQ**

<AccordionGroup>
  <Accordion title="Why is my SQL dynamic secret failing when I generate a lease?">
    This usually happens when the SQL statements defined for creating or revoking the secret are not compatible with your database provider.

    Different SQL engines have different expectations for quoting identifiers and values. For example, some use backticks (`` `username` ``), others use single quotes (`'username'`), and some expect double quotes (`"username"`). A statement that works on one provider might fail on another.

    **Recommendation:**\
    Make sure to adjust your SQL statements to follow the syntax required by your specific database provider. Always test them directly on your target database to ensure they execute without errors.
  </Accordion>
</AccordionGroup>


# PostgreSQL
Source: https://infisical.com/docs/documentation/platform/dynamic-secrets/postgresql

Learn how to dynamically generate PostgreSQL database users.

The Infisical PostgreSQL dynamic secret allows you to generate PostgreSQL database credentials on demand based on configured role.

## Prerequisite

Create a user with the required permission in your SQL instance. This user will be used to create new accounts on-demand.

## Set up Dynamic Secrets with PostgreSQL

<Steps>
  <Step title="Open Secret Overview Dashboard">
    Open the Secret Overview dashboard and select the environment in which you would like to add a dynamic secret.
  </Step>

  <Step title="Click on the 'Add Dynamic Secret' button">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/add-dynamic-secret-button.png" alt="Add Dynamic Secret Button" />
  </Step>

  <Step title="Select `SQL Database`">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-modal.png" alt="Dynamic Secret Modal" />
  </Step>

  <Step title="Provide the inputs for dynamic secret parameters">
    <ParamField path="Secret Name" type="string" required>
      Name by which you want the secret to be referenced
    </ParamField>

    <ParamField path="Default TTL" type="string" required>
      Default time-to-live for a generated secret (it is possible to modify this value after a secret is generated)
    </ParamField>

    <ParamField path="Max TTL" type="string" required>
      Maximum time-to-live for a generated secret
    </ParamField>

    <ParamField path="Metadata" type="list" required>
      List of key/value metadata pairs
    </ParamField>

    <ParamField path="Service" type="string" required>
      Choose the service you want to generate dynamic secrets for. This must be selected as **PostgreSQL**.
    </ParamField>

    <ParamField path="Host" type="string" required>
      Database host
    </ParamField>

    <ParamField path="Port" type="number" required>
      Database port
    </ParamField>

    <ParamField path="User" type="string" required>
      Username that will be used to create dynamic secrets
    </ParamField>

    <ParamField path="Password" type="string" required>
      Password that will be used to create dynamic secrets
    </ParamField>

    <ParamField path="Database Name" type="string" required>
      Name of the database for which you want to create dynamic secrets
    </ParamField>

    <ParamField path="CA(SSL)" type="string">
      A CA may be required if your DB requires it for incoming connections. AWS RDS instances with default settings will requires a CA which can be downloaded [here](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/UsingWithRDS.SSL.html#UsingWithRDS.SSL.CertificatesAllRegions).
    </ParamField>

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-setup-modal-postgresql.png" alt="Dynamic Secret Setup Modal" />
  </Step>

  <Step title="(Optional) Modify SQL Statements">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/modify-sql-statements.png" alt="Modify SQL Statements Modal" />

    <ParamField path="Username Template" type="string" default="{{randomUsername}}">
      Specifies a template for generating usernames. This field allows customization of how usernames are automatically created.

      Allowed template variables are

      * `{{randomUsername}}`: Random username string
      * `{{unixTimestamp}}`: Current Unix timestamp
      * `{{identity.name}}`: Name of the identity that is generating the secret
      * `{{random N}}`: Random string of N characters

      Allowed template functions are

      * `truncate`: Truncates a string to a specified length
      * `replace`: Replaces a substring with another value

      Examples:

      ```
      {{randomUsername}}                              // 3POnzeFyK9gW2nioK0q2gMjr6CZqsRiX
      {{unixTimestamp}}                               // 17490641580
      {{identity.name}}                               // testuser
      {{random-5}}                                    // x9k2m
      {{truncate identity.name 4}}                    // test
      {{replace identity.name 'user' 'replace'}}      // testreplace
      ```
    </ParamField>

    <ParamField path="Customize SQL Statement" type="string">
      If you want to provide specific privileges for the generated dynamic credentials, you can modify the SQL statement to your needs. This is useful if you want to only give access to a specific table(s).
    </ParamField>
  </Step>

  <Step title="Click 'Submit'">
    After submitting the form, you will see a dynamic secret created in the dashboard.

    <Note>
      If this step fails, you may have to add the CA certificate.
    </Note>

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret.png" alt="Dynamic Secret" />
  </Step>

  <Step title="Generate dynamic secrets">
    Once you've successfully configured the dynamic secret, you're ready to generate on-demand credentials.
    To do this, simply click on the 'Generate' button which appears when hovering over the dynamic secret item.
    Alternatively, you can initiate the creation of a new lease by selecting 'New Lease' from the dynamic secret lease list section.

    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-generate.png" alt="Dynamic Secret" />
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-lease-empty.png" alt="Dynamic Secret" />

    When generating these secrets, it's important to specify a Time-to-Live (TTL) duration. This will dictate how long the credentials are valid for.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/provision-lease.png" alt="Provision Lease" />

    <Tip>
      Ensure that the TTL for the lease falls within the maximum TTL defined when configuring the dynamic secret.
    </Tip>

    Once you click the `Submit` button, a new secret lease will be generated and the credentials for it will be shown to you.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/lease-values.png" alt="Provision Lease" />
  </Step>
</Steps>

## Audit or Revoke Leases

Once you have created one or more leases, you will be able to access them by clicking on the respective dynamic secret item on the dashboard.
This will allow you to see the expiration time of the lease or delete the lease before it's set time to live.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/lease-data.png" alt="Provision Lease" />

## Renew Leases

To extend the life of the generated dynamic secret leases past its initial time to live, simply click on the **Renew** button as illustrated below.
<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-lease-renew.png" alt="Provision Lease" />

<Warning>
  Lease renewals cannot exceed the maximum TTL set when configuring the dynamic secret
</Warning>


# RabbitMQ
Source: https://infisical.com/docs/documentation/platform/dynamic-secrets/rabbit-mq

Learn how to dynamically generate RabbitMQ user credentials.

The Infisical RabbitMQ dynamic secret allows you to generate RabbitMQ credentials on demand based on configured role.

## Prerequisites

1. Ensure that the `management` plugin is enabled on your RabbitMQ instance. This is required for the dynamic secret to work.

## Set up Dynamic Secrets with RabbitMQ

<Steps>
  <Step title="Open Secret Overview Dashboard">
    Open the Secret Overview dashboard and select the environment in which you would like to add a dynamic secret.
  </Step>

  <Step title="Click on the 'Add Dynamic Secret' button">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/add-dynamic-secret-button.png" alt="Add Dynamic Secret Button" />
  </Step>

  <Step title="Select RabbitMQ">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-rabbit-mq-modal.png" alt="Dynamic Secret Modal" />
  </Step>

  <Step title="Provide the inputs for dynamic secret parameters">
    <ParamField path="Secret Name" type="string" required>
      Name by which you want the secret to be referenced
    </ParamField>

    <ParamField path="Default TTL" type="string" required>
      Default time-to-live for a generated secret (it is possible to modify this value after a secret is generated)
    </ParamField>

    <ParamField path="Max TTL" type="string" required>
      Maximum time-to-live for a generated secret.
    </ParamField>

    <ParamField path="Host" type="string" required>
      Your RabbitMQ host. This must be in HTTP format. *(Example: [http://your-cluster-ip](http://your-cluster-ip))*
    </ParamField>

    <ParamField path="Port" type="string" required>
      The port that the RabbitMQ management plugin is listening on. This is `15672` by default.
    </ParamField>

    <ParamField path="Virtual host name" type="string" required>
      The name of the virtual host that the user will be assigned to. This defaults
      to `/`.
    </ParamField>

    <ParamField path="Virtual host permissions (Read/Write/Configure)" type="string" required>
      The permissions that the user will have on the virtual host. This defaults to `.*`.

      The three permission fields all take a regular expression *(regex)*, that should match resource names for which the user is granted read / write / configuration permissions
    </ParamField>

    <ParamField path="Username" type="string" required>
      The username of the user that will be used to provision new dynamic secret
      leases.
    </ParamField>

    <ParamField path="Password" type="string" required>
      The password of the user that will be used to provision new dynamic secret
      leases.
    </ParamField>

    <ParamField path="Username Template" type="string" default="{{randomUsername}}">
      Specifies a template for generating usernames. This field allows customization of how usernames are automatically created.

      Allowed template variables are

      * `{{randomUsername}}`: Random username string
      * `{{unixTimestamp}}`: Current Unix timestamp
      * `{{identity.name}}`: Name of the identity that is generating the secret
      * `{{random N}}`: Random string of N characters

      Allowed template functions are

      * `truncate`: Truncates a string to a specified length
      * `replace`: Replaces a substring with another value

      Examples:

      ```
      {{randomUsername}}                              // 3POnzeFyK9gW2nioK0q2gMjr6CZqsRiX
      {{unixTimestamp}}                               // 17490641580
      {{identity.name}}                               // testuser
      {{random-5}}                                    // x9k2m
      {{truncate identity.name 4}}                    // test
      {{replace identity.name 'user' 'replace'}}      // testreplace
      ```
    </ParamField>

    <ParamField path="CA(SSL)" type="string">
      A CA may be required if your DB requires it for incoming connections. This is often the case when connecting to a managed service.
    </ParamField>

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-input-modal-rabbit-mq.png" alt="Dynamic Secret Setup Modal" />
  </Step>

  <Step title="Click `Submit`">
    After submitting the form, you will see a dynamic secret created in the dashboard.

    <Note>
      If this step fails, you may have to add the CA certificate.
    </Note>
  </Step>

  <Step title="Generate dynamic secrets">
    Once you've successfully configured the dynamic secret, you're ready to generate on-demand credentials.
    To do this, simply click on the 'Generate' button which appears when hovering over the dynamic secret item.
    Alternatively, you can initiate the creation of a new lease by selecting 'New Lease' from the dynamic secret lease list section.

    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-generate.png" alt="Dynamic Secret" />
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-lease-empty.png" alt="Dynamic Secret" />

    When generating these secrets, it's important to specify a Time-to-Live (TTL) duration. This will dictate  how long the credentials are valid for.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/provision-lease.png" alt="Provision Lease" />

    <Tip>
      Ensure that the TTL for the lease falls within the maximum TTL defined when configuring the dynamic secret.
    </Tip>

    Once you click the `Submit` button, a new secret lease will be generated and the credentials from it will be shown to you.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/lease-values.png" alt="Provision Lease" />
  </Step>
</Steps>

## Audit or Revoke Leases

Once you have created one or more leases, you will be able to access them by clicking on the respective dynamic secret item on the dashboard.
This will allow you to see the expiration time of the lease or delete a lease before it's set time to live.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/lease-data.png" alt="Provision Lease" />

## Renew Leases

To extend the life of the generated dynamic secret leases past its initial time to live, simply click on the **Renew** button as illustrated below.
<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-lease-renew.png" alt="Provision Lease" />

<Warning>
  Lease renewals cannot exceed the maximum TTL set when configuring the dynamic
  secret
</Warning>


# Redis
Source: https://infisical.com/docs/documentation/platform/dynamic-secrets/redis

Learn how to dynamically generate Redis Database user credentials.

The Infisical Redis dynamic secret allows you to generate Redis Database credentials on demand based on configured role.

## Prerequisite

Create a user with the required permission in your Redis instance. This user will be used to create new accounts on-demand.

## Set up Dynamic Secrets with Redis

<Steps>
  <Step title="Open Secret Overview Dashboard">
    Open the Secret Overview dashboard and select the environment in which you would like to add a dynamic secret.
  </Step>

  <Step title="Click on the 'Add Dynamic Secret' button">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/add-dynamic-secret-button.png" alt="Add Dynamic Secret Button" />
  </Step>

  <Step title="Select 'Redis'">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-modal-redis.png" alt="Dynamic Secret Modal" />
  </Step>

  <Step title="Provide the inputs for dynamic secret parameters">
    <ParamField path="Secret Name" type="string" required>
      Name by which you want the secret to be referenced
    </ParamField>

    <ParamField path="Default TTL" type="string" required>
      Default time-to-live for a generated secret (it is possible to modify this value after a secret is generated)
    </ParamField>

    <ParamField path="Max TTL" type="string" required>
      Maximum time-to-live for a generated secret.
    </ParamField>

    <ParamField path="Host" type="string" required>
      The database host, this can be an IP address or a domain name as long as Infisical can reach it.
    </ParamField>

    <ParamField path="Port" type="number" required>
      The database port, this is the port that the Redis instance is listening on.
    </ParamField>

    <ParamField path="User" type="string" required>
      Redis username that will be used to create new users on-demand. This is often 'default' or 'admin'.
    </ParamField>

    <ParamField path="Password" type="string" optional>
      Password that will be used to create dynamic secrets. This is required if your Redis instance is password protected.
    </ParamField>

    <ParamField path="CA(SSL)" type="string">
      A CA may be required if your DB requires it for incoming connections. This is often the case when connecting to a managed service.
    </ParamField>
  </Step>

  <Step title="(Optional) Modify Redis Statements">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/modify-redis-statement.png" alt="Modify Redis Statements Modal" />

    <ParamField path="Username Template" type="string" default="{{randomUsername}}">
      Specifies a template for generating usernames. This field allows customization of how usernames are automatically created.

      Allowed template variables are

      * `{{randomUsername}}`: Random username string
      * `{{unixTimestamp}}`: Current Unix timestamp
      * `{{identity.name}}`: Name of the identity that is generating the secret
      * `{{random N}}`: Random string of N characters

      Allowed template functions are

      * `truncate`: Truncates a string to a specified length
      * `replace`: Replaces a substring with another value

      Examples:

      ```
      {{randomUsername}}                              // 3POnzeFyK9gW2nioK0q2gMjr6CZqsRiX
      {{unixTimestamp}}                               // 17490641580
      {{identity.name}}                               // testuser
      {{random-5}}                                    // x9k2m
      {{truncate identity.name 4}}                    // test
      {{replace identity.name 'user' 'replace'}}      // testreplace
      ```
    </ParamField>

    <ParamField path="Customize Redis Statement" type="string">
      If you want to provide specific privileges for the generated dynamic credentials, you can modify the Redis statement to your needs. This is useful if you want to only give access to a specific table(s).
    </ParamField>
  </Step>

  <Step title="Click `Submit`">
    After submitting the form, you will see a dynamic secret created in the dashboard.

    <Note>
      If this step fails, you may have to add the CA certificate.
    </Note>
  </Step>

  <Step title="Generate dynamic secrets">
    Once you've successfully configured the dynamic secret, you're ready to generate on-demand credentials.
    To do this, simply click on the 'Generate' button which appears when hovering over the dynamic secret item.
    Alternatively, you can initiate the creation of a new lease by selecting 'New Lease' from the dynamic secret lease list section.

    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-generate.png" alt="Dynamic Secret" />
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-lease-empty.png" alt="Dynamic Secret" />

    When generating these secrets, it's important to specify a Time-to-Live (TTL) duration. This will dictate how long the credentials are valid for.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/provision-lease.png" alt="Provision Lease" />

    <Tip>
      Ensure that the TTL for the lease falls within the maximum TTL defined when configuring the dynamic secret.
    </Tip>

    Once you click the `Submit` button, a new secret lease will be generated and the credentials from it will be shown to you.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/lease-values.png" alt="Provision Lease" />
  </Step>
</Steps>

## Audit or Revoke Leases

Once you have created one or more leases, you will be able to access them by clicking on the respective dynamic secret item on the dashboard.
This will allow you to see the expiration time of the lease or delete a lease before it's set time to live.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/lease-data.png" alt="Provision Lease" />

## Renew Leases

To extend the life of the generated dynamic secret leases past its initial time to live, simply click on the **Renew** button as illustrated below.
<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-lease-renew.png" alt="Provision Lease" />

<Warning>
  Lease renewals cannot exceed the maximum TTL set when configuring the dynamic secret
</Warning>


# SAP ASE
Source: https://infisical.com/docs/documentation/platform/dynamic-secrets/sap-ase

Learn how to dynamically generate SAP ASE database account credentials.

The Infisical SAP ASE dynamic secret allows you to generate SAP ASE database credentials on demand.

## Prerequisite

* Infisical requires that you have a user in your SAP ASE instance, configured with the appropriate permissions. This user will facilitate the creation of new accounts as needed.
  Ensure the user possesses privileges for creating, dropping, and granting permissions to roles for it to be able to create dynamic secrets.
  The user used for authentication must have access to the `master` database. You can use the `sa` user for this purpose or create a new user with the necessary permissions.

* The SAP ASE instance should be reachable by Infisical.

## Set up Dynamic Secrets with SAP ASE

<Steps>
  <Step title="Open Secret Overview Dashboard">
    Open the Secret Overview dashboard and select the environment in which you would like to add a dynamic secret.
  </Step>

  <Step title="Click on the 'Add Dynamic Secret' button">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/add-dynamic-secret-button.png" alt="Add Dynamic Secret Button" />
  </Step>

  <Step title="Select SAP ASE">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/sap-ase/dynamic-secret-sap-ase-modal.png" alt="Dynamic Secret Modal" />
  </Step>

  <Step title="Provide the inputs for dynamic secret parameters">
    <ParamField path="Secret Name" type="string" required>
      Name by which you want the secret to be referenced
    </ParamField>

    <ParamField path="Default TTL" type="string" required>
      Default time-to-live for a generated secret (it is possible to modify this value when a secret is generate)
    </ParamField>

    <ParamField path="Max TTL" type="string" required>
      The maximum time-to-live for a generated secret
    </ParamField>

    <ParamField path="Host" type="string" required>
      Your SAP ASE instance host (IP or domain)
    </ParamField>

    <ParamField path="Port" type="number" required>
      Your SAP ASE instance port. On default SAP ASE instances this is usually `5000`.
    </ParamField>

    <ParamField path="Database" type="number" required>
      The database name that you want to generate credentials for. This database must exist on the SAP ASE instance.
      Please note that the user/password used for authentication must have access to this database, **and** the `master` database.
    </ParamField>

    <ParamField path="User" type="string" required>
      Username that will be used to create dynamic secrets
    </ParamField>

    <ParamField path="Password" type="string" required>
      Password that will be used to create dynamic secrets
    </ParamField>

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/sap-ase/dynamic-secret-sap-ase-setup-modal.png" alt="Dynamic Secret Setup Modal" />
  </Step>

  <Step title="(Optional) Modify SAP SQL Statements">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/sap-ase/dynamic-secret-sap-ase-statements.png" alt="Modify SQL Statements Modal" />

    <ParamField path="Username Template" type="string" default="{{randomUsername}}">
      Specifies a template for generating usernames. This field allows customization of how usernames are automatically created.

      Allowed template variables are

      * `{{randomUsername}}`: Random username string
      * `{{unixTimestamp}}`: Current Unix timestamp
      * `{{identity.name}}`: Name of the identity that is generating the secret
      * `{{random N}}`: Random string of N characters

      Allowed template functions are

      * `truncate`: Truncates a string to a specified length
      * `replace`: Replaces a substring with another value

      Examples:

      ```
      {{randomUsername}}                              // 3POnzeFyK9gW2nioK0q2gMjr6CZqsRiX
      {{unixTimestamp}}                               // 17490641580
      {{identity.name}}                               // testuser
      {{random-5}}                                    // x9k2m
      {{truncate identity.name 4}}                    // test
      {{replace identity.name 'user' 'replace'}}      // testreplace
      ```
    </ParamField>

    <ParamField path="Customize Statement" type="string">
      If you want to provide specific privileges for the generated dynamic credentials, you can modify the SQL statement to your needs.

      <Warning>
        Due to SAP ASE limitations, the attached SQL statements are not executed as a transaction.
      </Warning>
    </ParamField>
  </Step>

  <Step title="Click 'Submit'">
    After submitting the form, you will see a dynamic secret created in the dashboard.
  </Step>

  <Step title="Generate dynamic secrets">
    Once you've successfully configured the dynamic secret, you're ready to generate on-demand credentials.
    To do this, simply click on the 'Generate' button which appears when hovering over the dynamic secret item.
    Alternatively, you can initiate the creation of a new lease by selecting 'New Lease' from the dynamic secret lease list section.

    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-generate.png" alt="Dynamic Secret" />
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-lease-empty.png" alt="Dynamic Secret" />

    When generating these secrets, it's important to specify a Time-to-Live (TTL) duration. This will dictate how long the credentials are valid for.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/provision-lease.png" alt="Provision Lease" />

    <Tip>
      Ensure that the TTL for the lease falls within the maximum TTL defined when configuring the dynamic secret in step 4.
    </Tip>

    Once you click the `Submit` button, a new secret lease will be generated and the credentials for it will be shown to you.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/lease-values.png" alt="Provision Lease" />
  </Step>
</Steps>

## Audit or Revoke Leases

Once you have created one or more leases, you will be able to access them by clicking on the respective dynamic secret item on the dashboard.
This will allow you see the lease details and delete the lease ahead of its expiration time.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/lease-data.png" alt="Provision Lease" />

## Renew Leases

To extend the life of the generated dynamic secret lease past its initial time to live, simply click on the **Renew** as illustrated below.
<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-lease-renew.png" alt="Provision Lease" />

<Warning>
  Lease renewals cannot exceed the maximum TTL set when configuring the dynamic
  secret.
</Warning>


# SAP HANA
Source: https://infisical.com/docs/documentation/platform/dynamic-secrets/sap-hana

Learn how to dynamically generate SAP HANA database account credentials.

The Infisical SAP HANA dynamic secret allows you to generate SAP HANA database credentials on demand.

## Prerequisite

* Infisical requires a SAP HANA database user in your instance with the necessary permissions. This user will facilitate the creation of new accounts as needed.
  Ensure the user possesses privileges for creating, dropping, and granting permissions to roles for it to be able to create dynamic secrets.

* The SAP HANA instance should be reachable by Infisical.

## Set up Dynamic Secrets with SAP HANA

<Steps>
  <Step title="Open Secret Overview Dashboard">
    Open the Secret Overview dashboard and select the environment in which you would like to add a dynamic secret.
  </Step>

  <Step title="Click on the 'Add Dynamic Secret' button">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/add-dynamic-secret-button.png" alt="Add Dynamic Secret Button" />
  </Step>

  <Step title="Select SAP HANA">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-modal-sap-hana.png" alt="Dynamic Secret Modal" />
  </Step>

  <Step title="Provide the inputs for dynamic secret parameters">
    <ParamField path="Secret Name" type="string" required>
      Name by which you want the secret to be referenced
    </ParamField>

    <ParamField path="Default TTL" type="string" required>
      Default time-to-live for a generated secret (it is possible to modify this value after a secret is generated)
    </ParamField>

    <ParamField path="Max TTL" type="string" required>
      Maximum time-to-live for a generated secret
    </ParamField>

    <ParamField path="Host" type="string" required>
      SAP HANA Host
    </ParamField>

    <ParamField path="Port" type="number" required>
      SAP HANA Port
    </ParamField>

    <ParamField path="User" type="string" required>
      Username that will be used to create dynamic secrets
    </ParamField>

    <ParamField path="Password" type="string" required>
      Password that will be used to create dynamic secrets
    </ParamField>

    <ParamField path="CA(SSL)" type="string">
      A CA may be required for SSL if you are self-hosting SAP HANA
    </ParamField>

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-setup-modal-sap-hana.png" alt="Dynamic Secret Setup Modal" />
  </Step>

  <Step title="(Optional) Modify SAP SQL Statements">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/modify-sap-hana-sql-statements.png" alt="Modify SQL Statements Modal" />

    <ParamField path="Username Template" type="string" default="{{randomUsername}}">
      Specifies a template for generating usernames. This field allows customization of how usernames are automatically created.

      Allowed template variables are

      * `{{randomUsername}}`: Random username string
      * `{{unixTimestamp}}`: Current Unix timestamp
      * `{{identity.name}}`: Name of the identity that is generating the secret
      * `{{random N}}`: Random string of N characters

      Allowed template functions are

      * `truncate`: Truncates a string to a specified length
      * `replace`: Replaces a substring with another value

      Examples:

      ```
      {{randomUsername}}                              // 3POnzeFyK9gW2nioK0q2gMjr6CZqsRiX
      {{unixTimestamp}}                               // 17490641580
      {{identity.name}}                               // testuser
      {{random-5}}                                    // x9k2m
      {{truncate identity.name 4}}                    // test
      {{replace identity.name 'user' 'replace'}}      // testreplace
      ```
    </ParamField>

    <ParamField path="Customize Statement" type="string">
      If you want to provide specific privileges for the generated dynamic credentials, you can modify the SQL statement to your needs.

      <Warning>
        Due to SAP HANA limitations, the attached SQL statements are not executed as a transaction.
      </Warning>
    </ParamField>
  </Step>

  <Step title="Click 'Submit'">
    After submitting the form, you will see a dynamic secret created in the dashboard.

    <Note>
      If this step fails, you may have to add the CA certficate.
    </Note>
  </Step>

  <Step title="Generate dynamic secrets">
    Once you've successfully configured the dynamic secret, you're ready to generate on-demand credentials.
    To do this, simply click on the 'Generate' button which appears when hovering over the dynamic secret item.
    Alternatively, you can initiate the creation of a new lease by selecting 'New Lease' from the dynamic secret lease list section.

    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-generate.png" alt="Dynamic Secret" />
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-lease-empty.png" alt="Dynamic Secret" />

    When generating these secrets, it's important to specify a Time-to-Live (TTL) duration. This will dictate how long the credentials are valid for.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/provision-lease.png" alt="Provision Lease" />

    <Tip>
      Ensure that the TTL for the lease falls within the maximum TTL defined when configuring the dynamic secret in step 4.
    </Tip>

    Once you click the `Submit` button, a new secret lease will be generated and the credentials for it will be shown to you.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/lease-values.png" alt="Provision Lease" />
  </Step>
</Steps>

## Audit or Revoke Leases

Once you have created one or more leases, you will be able to access them by clicking on the respective dynamic secret item on the dashboard.
This will allow you to see the lease details and delete the lease ahead of its expiration time.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/lease-data.png" alt="Provision Lease" />

## Renew Leases

To extend the life of the generated dynamic secret lease past its initial time to live, simply click on the **Renew** button as illustrated below.
<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-lease-renew.png" alt="Provision Lease" />

<Warning>
  Lease renewals cannot exceed the maximum TTL set when configuring the dynamic
  secret.
</Warning>


# Snowflake
Source: https://infisical.com/docs/documentation/platform/dynamic-secrets/snowflake

Learn how to dynamically generate Snowflake user credentials.

Infisical's Snowflake dynamic secrets allow you to generate Snowflake user credentials on demand.

## Snowflake Prerequisites

<Note>
  Infisical requires a Snowflake user in your account with the USERADMIN role.
  This user will act as a service account for Infisical and facilitate the
  creation of new users as needed.
</Note>

<Steps>
  <Step title="Navigate to Snowflake's User Dashboard and press the '+ User' button">
        <img
          src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/snowflake/dynamic-secret-snowflake-users-page.png"
          alt="Snowflake User
    Dashboard"
        />
  </Step>

  <Step title="Create a Snowflake user with the USERADMIN role for Infisical">
    <Warning>
      Be sure to uncheck "Force user to change password on first time login"
    </Warning>

        <img
          src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/snowflake/dynamic-secret-snowflake-create-service-user.png"
          alt="Snowflake Create Service
    User"
        />
  </Step>

  <Step title="Click on the Account Menu in the bottom left and take note of your Account and Organization identifiers">
        <img
          src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/snowflake/dynamic-secret-snowflake-identifiers.png"
          alt="Snowflake Account And Organization
    Identifiers"
        />
  </Step>
</Steps>

## Set up Dynamic Secrets with Snowflake

<Steps>
  <Step title="Open the Secret Overview Dashboard">
    Open the Secret Overview dashboard and select the environment in which you would like to add a dynamic secret.
  </Step>

  <Step title="Click on the 'Add Dynamic Secret' button">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/add-dynamic-secret-button.png" alt="Add Dynamic Secret Button" />
  </Step>

  <Step title="Select the Snowflake option in the grid list">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/snowflake/dynamic-secret-snowflake-modal.png" alt="Dynamic Secret Modal" />
  </Step>

  <Step title="Provide the required parameters for the Snowflake dynamic secret">
    <ParamField path="Secret Name" type="string" required>
      The name you want to reference this secret by
    </ParamField>

    <ParamField path="Default TTL" type="string" required>
      Default time-to-live for a generated secret (it is possible to modify this value when generating a secret)
    </ParamField>

    <ParamField path="Max TTL" type="string" required>
      Maximum time-to-live for a generated secret
    </ParamField>

    <ParamField path="Account Identifier" type="string" required>
      Snowflake account identifier
    </ParamField>

    <ParamField path="Organization Identifier" type="string" required>
      Snowflake organization identifier
    </ParamField>

    <ParamField path="User" type="string" required>
      Username of the Infisical Service User
    </ParamField>

    <ParamField path="Password" type="string" required>
      Password of the Infisical Service User
    </ParamField>

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/snowflake/dynamic-secret-snowflake-setup-modal.png" alt="Dynamic Secret Setup Modal" />
  </Step>

  <Step title="(Optional) Modify SQL Statements">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/snowflake/dynamic-secret-snowflake-sql-statements.png" alt="Modify SQL Statements Modal" />

    <ParamField path="Username Template" type="string" default="{{randomUsername}}">
      Specifies a template for generating usernames. This field allows customization of how usernames are automatically created.

      Allowed template variables are

      * `{{randomUsername}}`: Random username string
      * `{{unixTimestamp}}`: Current Unix timestamp
      * `{{identity.name}}`: Name of the identity that is generating the secret
      * `{{random N}}`: Random string of N characters

      Allowed template functions are

      * `truncate`: Truncates a string to a specified length
      * `replace`: Replaces a substring with another value

      Examples:

      ```
      {{randomUsername}}                              // 3POnzeFyK9gW2nioK0q2gMjr6CZqsRiX
      {{unixTimestamp}}                               // 17490641580
      {{identity.name}}                               // testuser
      {{random-5}}                                    // x9k2m
      {{truncate identity.name 4}}                    // test
      {{replace identity.name 'user' 'replace'}}      // testreplace
      ```
    </ParamField>

    <ParamField path="Customize Statement" type="string">
      If you want to provide specific privileges for the generated dynamic credentials, you can modify the SQL
      statement to your needs.
    </ParamField>
  </Step>

  <Step title="Click 'Submit'">
    After submitting the form, you will see a dynamic secret created in the dashboard.
  </Step>

  <Step title="Generate dynamic secrets">
    Once you've successfully configured the dynamic secret, you're ready to generate on-demand credentials.
    To do this, simply click on the 'Generate' button which appears when hovering over the dynamic secret item.
    Alternatively, you can initiate the creation of a new lease by selecting 'New Lease' from the dynamic secret
    lease list section.

    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-generate.png" alt="Dynamic Secret" />
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-lease-empty.png" alt="Dynamic Secret" />

    When generating these secrets, it's important to specify a Time-to-Live (TTL) duration. This will dictate how
    long the credentials are valid for.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/provision-lease.png" alt="Provision Lease" />

    <Tip>
      Ensure that the TTL for the lease falls within the maximum TTL defined when configuring the dynamic secret in
      step 4.
    </Tip>

    Once you click the `Submit` button, a new secret lease will be generated and the credentials for it will be
    shown to you.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/lease-values.png" alt="Provision Lease" />
  </Step>
</Steps>

## Audit or Revoke Leases

Once you have created one or more leases, you will be able to access them by clicking on the respective dynamic secret item on the dashboard.
This will allow you to see the lease details and delete the lease ahead of its expiration time.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/lease-data.png" alt="Provision Lease" />

## Renew Leases

To extend the life of the generated dynamic secret lease past its initial time to live, simply click on the **Renew** button as illustrated below.
<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-lease-renew.png" alt="Provision Lease" />

<Warning>
  Lease renewals cannot exceed the maximum TTL set when configuring the dynamic
  secret.
</Warning>


# TOTP
Source: https://infisical.com/docs/documentation/platform/dynamic-secrets/totp

Learn how to dynamically generate time-based one-time passwords.

The Infisical TOTP dynamic secret allows you to generate time-based one-time passwords on demand.

## Prerequisite

* Infisical requires either an OTP url or a secret key from a TOTP provider.

## Set up Dynamic Secrets with TOTP

<Steps>
  <Step title="Open Secret Overview Dashboard">
    Open the Secret Overview dashboard and select the environment in which you would like to add a dynamic secret.
  </Step>

  <Step title="Click on the 'Add Dynamic Secret' button">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/add-dynamic-secret-button.png" alt="Add Dynamic Secret Button" />
  </Step>

  <Step title="Select TOTP">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-modal-totp.png" alt="Dynamic Secret Modal" />
  </Step>

  <Step title="Provide the inputs for dynamic secret parameters">
    <ParamField path="Secret Name" type="string" required>
      Name by which you want the secret to be referenced
    </ParamField>

    <ParamField path="Configuration Type" type="string" required>
      There are two supported configuration types - `url` and `manual`.

      When `url` is selected, you can configure the TOTP generator using the OTP URL.

      When `manual` is selected, you can configure the TOTP generator using the secret key along with other configurations like period, number of digits, and algorithm.
    </ParamField>

    <ParamField path="URL" type="string">
      OTP URL in `otpauth://` format used to generate TOTP codes.
    </ParamField>

    <ParamField path="Secret Key" type="string">
      Base32 encoded secret used to generate TOTP codes.
    </ParamField>

    <ParamField path="Period" type="number">
      Time interval in seconds between generating new TOTP codes.
    </ParamField>

    <ParamField path="Digits" type="number">
      Number of digits to generate in each TOTP code.
    </ParamField>

    <ParamField path="Algorithm" type="string">
      Hash algorithm to use when generating TOTP codes. The supported algorithms are sha1, sha256, and sha512.
    </ParamField>

    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-setup-modal-totp-url.png" alt="Dynamic Secret Setup Modal" />
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-setup-modal-totp-manual.png" alt="Dynamic Secret Setup Modal" />
  </Step>

  <Step title="Click 'Submit'">
    After submitting the form, you will see a dynamic secret created in the dashboard.
  </Step>

  <Step title="Generate dynamic secrets">
    Once you've successfully configured the dynamic secret, you're ready to generate on-demand TOTPs.
    To do this, simply click on the 'Generate' button which appears when hovering over the dynamic secret item.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-generate.png" alt="Dynamic Secret" />

    Once you click the `Generate` button, a new secret lease will be generated and the TOTP will be shown to you.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/totp-lease-value.png" alt="Provision Lease" />
  </Step>
</Steps>


# Vertica
Source: https://infisical.com/docs/documentation/platform/dynamic-secrets/vertica

Learn how to dynamically generate Vertica database users.

The Infisical Vertica dynamic secret allows you to generate Vertica database credentials on demand based on configured role.

## Prerequisite

Create a user with the required permission in your Vertica instance. This user will be used to create new accounts on-demand.

## Set up Dynamic Secrets with Vertica

<Steps>
  <Step title="Open Secret Overview Dashboard">
    Open the Secret Overview dashboard and select the environment in which you would like to add a dynamic secret.
  </Step>

  <Step title="Click on the 'Add Dynamic Secret' button">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/add-dynamic-secret-button.png" alt="Add Dynamic Secret Button" />
  </Step>

  <Step title="Select `Vertica`">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/vertica/dynamic-secret-modal-vertica.png" alt="Dynamic Secret Modal" />
  </Step>

  <Step title="Provide the inputs for dynamic secret parameters">
    <ParamField path="Secret Name" type="string" required>
      Name by which you want the secret to be referenced
    </ParamField>

    <ParamField path="Default TTL" type="string" required>
      Default time-to-live for a generated secret (it is possible to modify this value after a secret is generated)
    </ParamField>

    <ParamField path="Max TTL" type="string" required>
      Maximum time-to-live for a generated secret
    </ParamField>

    <ParamField path="Gateway" type="string">
      Select a gateway for private cluster access. If not specified, the Internet Gateway will be used.
    </ParamField>

    <ParamField path="Host" type="string" required>
      Vertica database host
    </ParamField>

    <ParamField path="Port" type="number" required>
      Vertica database port (default: 5433)
    </ParamField>

    <ParamField path="Database" type="string" required>
      Name of the Vertica database for which you want to create dynamic secrets
    </ParamField>

    <ParamField path="User" type="string" required>
      Username that will be used to create dynamic secrets
    </ParamField>

    <ParamField path="Password" type="string" required>
      Password that will be used to create dynamic secrets
    </ParamField>

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/vertica/dynamic-secret-setup-modal-vertica.png" alt="Dynamic Secret Setup Modal" />
  </Step>

  <Step title="(Optional) Modify SQL Statements">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/vertica/modify-sql-statements-vertica.png" alt="Modify SQL Statements Modal" />

    <ParamField path="Username Template" type="string" default="{{randomUsername}}">
      Specifies a template for generating usernames. This field allows customization of how usernames are automatically created.

      Allowed template variables are

      * `{{randomUsername}}`: Random username string
      * `{{unixTimestamp}}`: Current Unix timestamp
    </ParamField>

    <ParamField path="Creation Statement" type="string">
      Customize the SQL statement used to create new users. Default creates a user with basic schema permissions.
    </ParamField>

    <ParamField path="Revocation Statement" type="string">
      Customize the SQL statement used to revoke users. Default revokes a user.
    </ParamField>
  </Step>

  <Step title="(Optional) Configure Password Requirements">
    <ParamField path="Password Length" type="number" default="48">
      Length of generated passwords (1-250 characters)
    </ParamField>

    <ParamField path="Character Requirements" type="object">
      Minimum required character counts:

      * **Lowercase Count**: Minimum lowercase letters (default: 1)
      * **Uppercase Count**: Minimum uppercase letters (default: 1)
      * **Digit Count**: Minimum digits (default: 1)
      * **Symbol Count**: Minimum symbols (default: 0)
    </ParamField>

    <ParamField path="Allowed Symbols" type="string" default="-_.~!*">
      Symbols allowed in generated passwords
    </ParamField>
  </Step>

  <Step title="Click 'Submit'">
    After submitting the form, you will see a dynamic secret created in the dashboard.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/vertica/dynamic-secret-vertica.png" alt="Dynamic Secret" />
  </Step>

  <Step title="Generate dynamic secrets">
    Once you've successfully configured the dynamic secret, you're ready to generate on-demand credentials.
    To do this, simply click on the 'Generate' button which appears when hovering over the dynamic secret item.
    Alternatively, you can initiate the creation of a new lease by selecting 'New Lease' from the dynamic secret lease list section.

    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-generate.png" alt="Dynamic Secret" />
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-lease-empty.png" alt="Dynamic Secret" />

    When generating these secrets, it's important to specify a Time-to-Live (TTL) duration. This will dictate how long the credentials are valid for.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/provision-lease.png" alt="Provision Lease" />

    <Tip>
      Ensure that the TTL for the lease falls within the maximum TTL defined when configuring the dynamic secret.
    </Tip>

    Once you click the `Submit` button, a new secret lease will be generated and the credentials for it will be shown to you.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/lease-values.png" alt="Provision Lease" />
  </Step>
</Steps>

## Audit or Revoke Leases

Once you have created one or more leases, you will be able to access them by clicking on the respective dynamic secret item on the dashboard.
This will allow you to see the expiration time of the lease or delete the lease before its set time to live.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/lease-data.png" alt="Provision Lease" />

## Renew Leases

To extend the life of the generated dynamic secret leases past its initial time to live, simply click on the **Renew** button as illustrated below.
<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/dynamic-secrets/dynamic-secret-lease-renew.png" alt="Provision Lease" />

<Warning>
  Lease renewals cannot exceed the maximum TTL set when configuring the dynamic secret
</Warning>


# Event Subscriptions
Source: https://infisical.com/docs/documentation/platform/event-subscriptions

Subscribe to events in Infisical for real-time updates

<Info>
  **Note:** Event Subscriptions is a paid feature. - **Infisical Cloud users:** Event Subscriptions is available under
  the **Enterprise Tier**. - **Self-Hosted Infisical:** Please contact [sales@infisical.com](mailto:sales@infisical.com)
  to purchase an enterprise license.
</Info>

Event Subscriptions in Infisical allow you to receive real-time notifications when specific actions occur within your account or organization. These notifications include changes to secrets, users, teams, and many more **coming soon**.

## How It Works

* Server receives message over pubsub connection indicating changes have occurred
* Server processes the change notification
* Updated data is synchronized across all connected Infisical instances
* Client applications receive real-time updates through [Server-Sent Events (SSE)](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events)
* All servers maintain consistent state without manual intervention

This ensures your infrastructure stays up-to-date automatically, without requiring restarts or manual synchronization.

<Note>
  Event Subscriptions are designed for real-time communication and do not include persistence or replay
  capabilitiesevents are delivered once and are not stored for future retrieval.
</Note>

## Supported Resources

You can currently subscribe to notifications for the following resources and event types:

* **Secrets**
  * `secret:created`: Triggered when a secret is created
  * `secret:updated`: Triggered when a secret is updated
  * `secret:deleted`: Triggered when a secret is deleted

## Permissions Setup

To receive events on a supported resource, the identity must have `Subscribe` action permission on that resource.

Follow these steps to set up the necessary permissions:

<Steps>
  <Step title="Select a project and copy the Project ID">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/events/select-project.png" alt="Select Project" />

    On your project page, open **Project Settings** from the sidebar.

    In the Project name section, click **Copy Project ID** to copy your Project ID, or extract it from the URL:
    `https://app.infisical.com/project/<your_project_id>/settings`
  </Step>

  <Step title="Navigate to Access Management and open Project Roles">
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/events/project-detail.png" alt="Project Detail" /> <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/events/project-access.png" alt="Project
    Access" /> Navigate to **Access Management**, then select **Project Roles**.
  </Step>

  <Step title="Select an existing role or create a new one">
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/events/project-role.png" alt="Project Role" /> You can either edit an existing role or create a new role
    for event subscriptions.
  </Step>

  <Step title="Assign policies to the role">
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/events/role-detail.png" alt="Role Detail" /> Select the specific resources that the role should have access
    to. <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/events/add-policy.png" alt="Add policy" />
  </Step>

  <Step title="Enable the Subscribe action in permissions">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/events/policy-setting.png" alt="Policy setting" />

    Ensure the **Subscribe** action is selected for the relevant resources and events.

    ## Conditions

    By default, the role will have access to all events for the selected resources in this project.

    <AccordionGroup>
      <Accordion title="Full Access">
                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/events/access-full.png" alt="Policy setting" />
      </Accordion>

      <Accordion title="Path Prefix">
                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/events/access-path.png" alt="Policy setting" />
      </Accordion>

      <Accordion title="Environment">
                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/events/access-dev.png" alt="Policy setting" />
      </Accordion>
    </AccordionGroup>
  </Step>
</Steps>

## Getting Started

Currently, events are only available via [API](/api-reference/endpoints/events) but will soon be available in our SDKs, Kubernetes Operator, and more.

### API Usage

You need an auth token to use this API. To get an authentication token, follow the authentication guide for one of our supported auth methods from the [machine identities documentation](/documentation/platform/identities/machine-identities#authentication-methods).

#### Creating a Subscription

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/events/postman-subscribe.png" alt="Postman Subscription" />

**Request Parameters:**

* `projectId`: Project whose events you want to subscribe to
* `register`: List of event filters
  * `conditions`: Conditions to filter events on
    * `environmentSlug`: Project environment
    * `secretPath`: Path of the secrets

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/events/postman-sse-response.png" alt="Postman Subscription Response" />

The subscribe endpoint responds with a `text/event-stream` content type to initiate SSE streaming.

For more specific details, please refer to our [API Reference](/api-reference/endpoints/events).


# Migrating from EnvKey to Infisical
Source: https://infisical.com/docs/documentation/platform/external-migrations/envkey

Learn how to migrate secrets from EnvKey to Infisical.

## Migrating from EnvKey

<Steps>
  <Step title="Open the EnvKey dashboard and go to My Org">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/external-migrations/envkey-dashboard.png" alt="EnvKey Dashboard" />
  </Step>

  <Step title="Export your EnvKey organization">
    Go to Import/Export on the top right corner, Click on Export Org and save the exported file.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/external-migrations/envkey-export.png" alt="Export organization" />
  </Step>

  <Step title="Obtain EnvKey encryption key">
    Click on copy to copy the encryption key and save it.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/external-migrations/envkey-copy-encryption-key.png" alt="Copy encryption key" />
  </Step>

  <Step title="Navigate to Infisical external migrations">
    Open the Infisical dashboard and go to Organization Settings > External Migrations.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/external-migrations/infisical-external-migration-dashboard.png" alt="Infisical Organization settings" />
  </Step>

  <Step title="Select the EnvKey platform">
    Select the EnvKey platform and click on Next.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/external-migrations/infisical-import-envkey-modal.png" alt="Select EnvKey platform" />
  </Step>

  <Step title="Upload the exported file from EnvKey">
    Upload the exported file from EnvKey, paste the encryption key and click Import data.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/external-migrations/infisical-import-envkey.png" alt="Infisical Import EnvKey" />
  </Step>
</Steps>

<Note>
  It may take several minutes to complete the migration. You will receive an email when the migration is complete, or if there were any errors during the migration process.
</Note>

## Talk to our team

To make the migration process even more seamless, you can [schedule a meeting with our team](https://infisical.cal.com/vlad/migration-from-envkey-to-infisical) to learn more about how Infisical compares to EnvKey and discuss unique needs of your organization. You are also welcome to email us at [support@infisical.com](mailto:support@infisical.com) to ask any questions or get any technical help.


# External Migrations
Source: https://infisical.com/docs/documentation/platform/external-migrations/overview

Learn how to migrate resources from third-party secrets management platforms to Infisical.

## Overview

Infisical supports migrating resources from third-party secrets management platforms to Infisical. This is useful if you're looking to easily switch to Infisical and wish to move over your existing resources from a different platform.

Infisical offers two types of migration approaches:

* **In-Platform Migration Tooling**: Configure platform connections to enable granular, on-demand imports of secrets, policies, and configurations directly within the Infisical UI. This allows you to migrate resources incrementally as needed.

* **Bulk Data Import**: Perform one-time organization-level migrations to import all resources from external platforms at once. This is ideal for initial migrations when moving entirely to Infisical.

## Supported Platforms

* [EnvKey](./envkey)
* [Vault](./vault)

We're always looking to add more migration paths for other providers. If we're missing a platform, please open an issue on our [GitHub repository](https://github.com/infisical/infisical/issues).


# Migrating from Vault to Infisical
Source: https://infisical.com/docs/documentation/platform/external-migrations/vault

Learn how to migrate resources from Vault to Infisical.

Infisical provides two approaches for migrating from HashiCorp Vault.

### Which approach should I use?

**Choose In-Platform Migration Tooling if you want to:**

* Migrate specific secrets, not everything at once
* Import secrets into existing Infisical projects
* Translate Vault policies to Infisical access controls
* Import Kubernetes authentication configurations
* Have more control over the migration process

**Choose Bulk Data Import if you want to:**

* Migrate all secrets from Vault in one go
* Automatically create new Infisical projects from your Vault structure
* Perform a one-time migration when moving entirely from Vault to Infisical

## In-Platform Migration Tooling

This migration approach lets you set up a connection to your Vault instance once, then import specific resources as needed throughout Infisical.

<Warning>
  **Organization Admin Access Required:** All in-platform migration features
  (importing secrets, Kubernetes configurations, and policies from Vault) are
  only accessible to organization admins.
</Warning>

### Step 1: Set Up Your Vault Connection

<Steps>
  <Step title="Create a Vault policy">
    In your Vault instance, create a policy that allows Infisical to read your secrets, policies, and authentication configurations. This policy grants read-only access and doesn't allow Infisical to modify anything in Vault.

    <Accordion title="View the complete policy">
      ```hcl  theme={"dark"}
      # System endpoints - for listing namespaces, policies, mounts, and auth methods
      path "sys/namespaces" {
        capabilities = ["list"]
      }

      path "sys/policy" {
        capabilities = ["read", "list"]
      }

      path "sys/policy/*" {
        capabilities = ["read"]
      }

      path "sys/mounts" {
        capabilities = ["read"]
      }

      path "sys/auth" {
        capabilities = ["read"]
      }

      # KV v2 secrets - for listing and reading secrets
      # Replace '+' with your actual KV v2 mount paths (e.g., "secret", "kv")
      path "+/metadata/*" {
        capabilities = ["list", "read"]
      }

      path "+/data/*" {
        capabilities = ["read"]
      }

      # KV v1 secrets - for listing and reading secrets
      # Replace '+' with your actual KV v1 mount paths (e.g., "secret", "kv-v1")
      # WARNING: This is broad - ideally specify exact mount names
      path "+/*" {
        capabilities = ["list", "read"]
      }

      # Kubernetes auth - for reading auth configuration and roles
      path "auth/+/config" {
        capabilities = ["read"]
      }

      path "auth/+/role" {
        capabilities = ["list"]
      }

      path "auth/+/role/*" {
        capabilities = ["read"]
      }

      # Kubernetes secrets engine - for reading secrets engine configuration and roles
      path "+/config" {
        capabilities = ["read"]
      }

      path "+/roles" {
        capabilities = ["list"]
      }

      path "+/roles/*" {
        capabilities = ["read"]
      }
      ```
    </Accordion>

    Save this policy in Vault with the name `infisical-in-platform-migration`.
  </Step>

  <Step title="Create an App Connection in Infisical">
    In Infisical, navigate to **Organization Settings > App Connections** and create a new HashiCorp Vault connection.

    Follow the [HashiCorp Vault App Connection documentation](/integrations/app-connections/hashicorp-vault) for detailed setup instructions. When configuring authentication (Token or AppRole), make sure it uses the `infisical-in-platform-migration` policy you created.
  </Step>

  <Step title="Add Vault Namespaces for Migration">
    Navigate to **Organization Settings > External Migrations** in Infisical.

    Under the "In-Platform Migration Tooling" section for HashiCorp Vault, click **"+ Add Namespace"**.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/external-migrations/vault-in-platform/external-migration-overview.png" alt="In-Platform Migration Tooling" />

    Configure your namespace:

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/external-migrations/vault-in-platform/namespace-configuration-modal.png" alt="Namespace Configuration" />

    * **Namespace**: Enter your Vault namespace path (e.g., `admin/namespace1`). If you intend to use the root namespace, set the namespace value to "root".
    * **Connection**: Select the App Connection you created in the previous step.

    <Note>
      You can add multiple namespaces with different connections if you have multiple Vault instances or namespaces to migrate from.
    </Note>
  </Step>
</Steps>

### Step 2: Import Your Resources

Once your Vault connection is configured, you'll see import options throughout Infisical wherever relevant. Here's what you can import:

#### Import Secrets into a Project

You can import secrets from Vault directly into a specific environment and secret path:

1. Navigate to your project and select a specific environment (e.g., Development, Production)

2. In the secrets view, click the dropdown icon (caret) next to the **"+ Add Secret"** button

3. Select **"Add from HashiCorp Vault"**

   <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/external-migrations/vault-in-platform/import-vault-secrets-modal.png" alt="Import Vault Secrets" />

4. Choose your Vault namespace and the secret path you want to import

5. Click **"Import Secrets"**

The secrets will be imported into your current environment and folder path.

#### Import Kubernetes Authentication Configurations

When setting up Kubernetes authentication for a machine identity, you can import the configuration from Vault:

1. Navigate to **Access Control > Machine Identities** and select an identity

2. Click **"Add Authentication Method"** and choose **Kubernetes Auth**

3. In the configuration modal, click **"Load from Vault"**

   <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/external-migrations/vault-in-platform/import-vault-kubernetes-auth-modal.png" alt="Load Kubernetes Auth from Vault" />

4. Select your Vault namespace and the Kubernetes role

5. Click **"Load"**

   <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/external-migrations/vault-in-platform/import-vault-kubernetes-auth-modal-form.png" alt="Kubernetes Auth Form Populated" />

The authentication settings (service accounts, TTL, policies, etc.) will be automatically populated from your Vault configuration.

<Note>
  Sensitive values like service account JWTs cannot be retrieved from Vault and
  must be manually provided in the form after importing the configuration.
</Note>

#### Import Kubernetes Dynamic Secret Configurations

When creating a Kubernetes dynamic secret, you can import the configuration from a Vault Kubernetes secrets engine role:

1. Navigate to your project and select an environment

2. Click **"+ Add Secret"** dropdown and choose **"Dynamic Secret"**

3. Select **Kubernetes** as the provider

4. Click **"Load from Vault"** at the top of the form

   <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/external-migrations/vault-in-platform/import-vault-kubernetes-role-modal.png" alt="Load Kubernetes Dynamic Secret from Vault" />

5. Select your Vault namespace, Kubernetes secrets engine mount, and role

6. Click **"Load Configuration"**

The form will be automatically populated with the role's configuration including:

* Cluster URL and CA certificate
* Credential type (Static or Dynamic)
* Service account name or Kubernetes role settings
* Allowed namespaces
* Token TTL values
* Token audiences

<Note>
  Sensitive values like cluster tokens cannot be retrieved from Vault and must
  be manually provided in the form after loading the configuration.
</Note>

#### Import and Translate Access Control Policies

When configuring project role-based access control, you can import Vault HCL policies and automatically translate them to Infisical permissions.

<Note>
  Policy translation is best-effort and provides a starting point based on your
  Vault configuration. The translated permissions should be reviewed and
  adjusted as needed since Vault and Infisical have different access control
  models. Infisical will analyze path patterns and capabilities to suggest
  equivalent permissions.
</Note>

**To import and translate a policy:**

1. Navigate to your project, then go to **Access Control > Roles** and create or edit a role

2. In the policy configuration, click **"Add from HashiCorp Vault"**

   <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/external-migrations/vault-in-platform/translate-vault-policy-toggle.png" alt="Import Vault Policy Button" />

3. Select your Vault namespace

4. Either choose an existing policy from the dropdown or paste your own HCL policy

   <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/external-migrations/vault-in-platform/translate-vault-policy-modal.png" alt="Translate Vault Policy Modal" />

5. Review the automatically translated Infisical permissions

6. Make any adjustments and save

<Tip>
  **How policy translation works:**

  * Vault path patterns are analyzed to identify KV secret engines and environments
  * Vault capabilities (`read`,`list`, `create`, etc.) are mapped to Infisical permissions
  * Wildcards in paths are converted to glob patterns
  * Secret paths are preserved for granular access control

  Always review the translated permissions carefully, as Vault's capability-based model may not map 1:1 with Infisical's permission structure.
</Tip>

***

## Bulk Data Import

This migration approach imports all secrets from your Vault instance in one operation and automatically creates new Infisical projects based on your Vault structure.

### Understanding Project Mapping

Before starting the bulk import, you need to decide how your Vault structure will map to Infisical projects:

<Accordion title="Namespace Mapping (One Project Per Namespace)">
  Each Vault namespace becomes a single Infisical project, with each KV secret engine becoming an environment within that project.

  **Example:** If you have a namespace with 3 KV secret engines (`dev-secrets`, `staging-secrets`, `prod-secrets`):

  * Creates: 1 Infisical project
  * Environments: 3 (`dev-secrets`, `staging-secrets`, `prod-secrets`)
</Accordion>

<Accordion title="Key Vault Mapping (One Project Per KV Engine)">
  Each KV secret engine becomes its own Infisical project with a single `Production` environment.

  **Example:** If you have 3 KV secret engines (`dev-secrets`, `staging-secrets`, `prod-secrets`):

  * Creates: 3 Infisical projects (`dev-secrets`, `staging-secrets`, `prod-secrets`)
  * Each project has: 1 environment (`Production`)
</Accordion>

### How to Perform a Bulk Import

<Steps>
  <Step title="Create a Vault policy for bulk import">
    In your Vault instance, create a policy that allows Infisical to read all secrets and metadata. This policy grants read-only access.

    <Accordion title="View the bulk import policy">
      ```hcl  theme={"dark"}
      # Allow listing secret engines/mounts
      path "sys/mounts" {
        capabilities = ["read", "list"]
      }

      # For KV v2 engines - access to both data and metadata
      path "*/data/*" {
        capabilities = ["read", "list"]
      }

      path "*/metadata/*" {
        capabilities = ["read", "list"]
      }

      # If using Vault Enterprise - allow listing namespaces
      path "sys/namespaces" {
        capabilities = ["list", "read"]
      }

      # Cross-namespace access (Enterprise only)
      path "+/*" {
        capabilities = ["read", "list"]
      }

      path "+/sys/mounts" {
        capabilities = ["read", "list"]
      }
      ```
    </Accordion>

    Save this policy in Vault with the name `infisical-bulk-migration`.
  </Step>

  <Step title="Generate an access token">
    Use the Vault CLI to generate an access token:

    ```bash  theme={"dark"}
    vault token create --policy="infisical-bulk-migration"
    ```

    Copy the `token` value from the output - you'll need it in the next step.
  </Step>

  <Step title="Start the import in Infisical">
    In Infisical, navigate to **Organization Settings > External Migrations**.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/external-migrations/infisical-external-migration-dashboard.png" alt="Infisical Organization settings" />

    Under the "Bulk Data Import" section, click **"+ Import"**.
  </Step>

  <Step title="Select Vault as the source">
    Select **HashiCorp Vault** as the migration source and click **Next**.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/external-migrations/infisical-import-vault-modal.png" alt="Select Vault platform" />
  </Step>

  <Step title="Configure and start the migration">
    Fill in your Vault connection details:

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/external-migrations/infisical-import-vault.png" alt="Configure Vault migration" />

    * **Vault URL**: Your Vault instance URL (e.g., `https://vault.example.com`)
    * **Vault Namespace**: Optional - only needed if using Vault Enterprise namespaces
    * **Vault Access Token**: The token you generated in step 2
    * **Project Mapping**: Choose how to structure your Infisical projects (see [Understanding Project Mapping](#understanding-project-mapping))

    Click **"Import Data"** to start the migration.

    <Note>
      The import runs in the background and may take several minutes. You'll receive an email when it completes.
    </Note>
  </Step>
</Steps>


# Folders
Source: https://infisical.com/docs/documentation/platform/folder

Learn how to organize secrets with folders.

Infisical Folders enable users to organize secrets using custom structures dependent on the intended use case (also known as **path-based secret storage**).

It is great for organizing secrets around hierarchies with multiple services or types of secrets involved at large quantities.
Infisical Folders can be infinitely nested to mirror your application architecture whether it's microservices, monorepos,
or any logical grouping that best suits your needs.

Consider the following structure for a microservice architecture:

```
| service1
|---- envars
|---- users
|-------- tokens1
|-------- tokens2
| service2
|---- envars
...
```

In this example, we store environment variables for each microservice under each respective `/envars` folder.
We also store user-specific secrets for micro-service 1 under `/service1/users`. With this folder structure in place, your applications only need to specify a path like `/microservice1/envars` to fetch secrets from there.
By extending this example, you can see how path-based secret storage provides a versatile approach to manage secrets for any architecture.

## Managing folders

To add a folder, press the downward chevron to the right of the **Add Secret** button; then press on the **Add Folder** button.

<Info>
  Folder names can only contain alphabets, numbers, and dashes
</Info>

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/folder/folders-add.png" alt="add folder" />

To delete a folder, hover over it and press the **X** button that appears on the right side.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/folder/folders-delete.png" alt="delete folder" />

### Comparing folders

It's possible to compare the contents of folders across environments in the **Secrets Overview** page.
When you click on a folder, the table will display the items within it across environments.

In the image below, you can see that the **Development** environment is the only one that contains items
in the `/users` folder, being other folders `/user-a`, `/user-b`, ... `/user-f`.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/folder/folders-secrets-overview.png" alt="comparing folders" />

### Replicating Folder Contents

If you want to copy secrets or folders from one path to another, you can utilize the **Replicate Secrets** functionality located in the **Add Secret** dropdown.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/folder/replicate-secrets.png" alt="replicate secrets" />

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/folder/replicate-secrets-modal.png" alt="replicate secrets modal" />

First, select the **Source Environment** and the **Source Root Path** you want to copy secrets *from*. In the example provided, we select `/dev-folder` as the source root path from the Development environment. This means any secrets within `/dev-folder` from Development will be replicated. By default, these secrets are copied into the *currently active* folder/path in your target environment (e.g., the root folder of your Staging environment in this scenario).

As a final step, you can select the specific secrets you wish to copy and then click **Replicate Secrets**.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/folder/replicate-secrets-result.png" alt="replicate secrets modal" />

The result shows two secrets successfully copied from the `/dev-folder` in the Development environment into the root folder of the Staging environment.

<Info>
  If you do not select a **Source Root Path**, the replication will consider the contents of the *entire root* of the **Source Environment** (e.g., the Development environment). In this example that would mean copying the `/dev-folder` itself rather than just its contents.
</Info>


# Gateway Deployment
Source: https://infisical.com/docs/documentation/platform/gateways/gateway-deployment

Complete guide to deploying Infisical Gateways including network configuration and firewall requirements

Infisical Gateways enables secure communication between your private resources and the Infisical platform without exposing inbound ports in your network.
This guide covers everything you need to deploy and configure Infisical Gateways.

## Deployment Steps

To successfully deploy an Infisical Gateway for use, follow these steps in order.

<Steps>
  <Step title="Provision a Machine Identity">
    Create a machine identity with the correct permissions to create and manage gateways. This identity is used by the gateway to authenticate with Infisical and should be provisioned in advance.
    The gateway supports several [machine identity auth methods](/documentation/platform/identities/machine-identities), as listed below. Choose the one that best fits your environment and set the corresponding environment variables when deploying the gateway.

    <AccordionGroup>
      <Accordion title="Universal Auth">
        Simple and secure authentication using client ID and client secret.

        **Environment Variables:**

        * `INFISICAL_AUTH_METHOD=universal-auth`
        * `INFISICAL_UNIVERSAL_AUTH_CLIENT_ID=<client-id>`
        * `INFISICAL_UNIVERSAL_AUTH_CLIENT_SECRET=<client-secret>`
      </Accordion>

      <Accordion title="Token Auth">
        Direct authentication using a machine identity access token.

        **Environment Variables:**

        * `INFISICAL_TOKEN=<token>`
      </Accordion>

      <Accordion title="Native Kubernetes">
        Authentication using Kubernetes service account tokens.

        **Environment Variables:**

        * `INFISICAL_AUTH_METHOD=kubernetes`
        * `INFISICAL_MACHINE_IDENTITY_ID=<machine-identity-id>`
      </Accordion>

      <Accordion title="Native AWS IAM">
        Authentication using AWS IAM roles.

        **Environment Variables:**

        * `INFISICAL_AUTH_METHOD=aws-iam`
        * `INFISICAL_MACHINE_IDENTITY_ID=<machine-identity-id>`
      </Accordion>

      <Accordion title="Native GCP ID Token">
        Authentication using GCP identity tokens.

        **Environment Variables:**

        * `INFISICAL_AUTH_METHOD=gcp-id-token`
        * `INFISICAL_MACHINE_IDENTITY_ID=<machine-identity-id>`
      </Accordion>

      <Accordion title="GCP IAM">
        Authentication using GCP service account keys.

        **Environment Variables:**

        * `INFISICAL_AUTH_METHOD=gcp-iam`
        * `INFISICAL_MACHINE_IDENTITY_ID=<machine-identity-id>`
        * `INFISICAL_GCP_SERVICE_ACCOUNT_KEY_FILE_PATH=<path-to-key-file>`
      </Accordion>

      <Accordion title="Native Azure">
        Authentication using Azure managed identity.

        **Environment Variables:**

        * `INFISICAL_AUTH_METHOD=azure`
        * `INFISICAL_MACHINE_IDENTITY_ID=<machine-identity-id>`
      </Accordion>

      <Accordion title="OIDC Auth">
        Authentication using OIDC identity tokens.

        **Environment Variables:**

        * `INFISICAL_AUTH_METHOD=oidc-auth`
        * `INFISICAL_MACHINE_IDENTITY_ID=<machine-identity-id>`
        * `INFISICAL_JWT=<oidc-jwt>`
      </Accordion>

      <Accordion title="JWT Auth">
        Authentication using JWT tokens.

        **Environment Variables:**

        * `INFISICAL_AUTH_METHOD=jwt-auth`
        * `INFISICAL_MACHINE_IDENTITY_ID=<machine-identity-id>`
        * `INFISICAL_JWT=<jwt>`
      </Accordion>
    </AccordionGroup>
  </Step>

  <Step title="Set Up a Relay Server">
    Ensure a relay server is running and accessible before you deploy any gateways. You have two options:

    * **Managed relay (Infisical Cloud, US/EU only):** Managed relays are only available for Infisical Cloud instances in the US and EU regions. If you are using Infisical Cloud in these regions, you can use the provided managed relay.
    * **Self-hosted relay:** For all other cases, including all self-hosted and dedicated enterprise instances of Infisical, you must deploy your own relay server. You can also choose to deploy your own relay server when using Infisical Cloud if you require reduced geographic proximity to your target resources for lower latency or to reduce network congestion. For setup instructions, see the [Relay Deployment Guide](/documentation/platform/gateways/relay-deployment).
  </Step>

  <Step title="Install the Infisical CLI">
    Make sure the Infisical CLI is installed on the machine or environment where you plan to deploy the gateway. The CLI is required for gateway installation and management.

    See the [CLI Installation Guide](/cli/overview) for instructions.
  </Step>

  <Step title="Configure Network & Firewall">
    Ensure your network and firewall settings allow the gateway to connect to all required services. All connections are outbound only; no inbound ports need to be opened.

    | Protocol | Destination                            | Port | Purpose                                    |
    | -------- | -------------------------------------- | ---- | ------------------------------------------ |
    | TCP      | Relay Server IP/Hostname               | 2222 | SSH reverse tunnel establishment           |
    | TCP      | Infisical instance host (US/EU, other) | 443  | API communication and certificate requests |

    For managed relays, allow outbound traffic to the provided relay server IP/hostname. For self-hosted relays, allow outbound traffic to your own relay server address.

    If you are in a corporate environment with strict egress filtering, ensure outbound TCP 2222 to relay servers and outbound HTTPS 443 to Infisical API endpoints are allowed.
  </Step>

  <Step title="Select a Deployment Method">
    The Infisical CLI is used to install and start the gateway in your chosen environment. The CLI provides commands for both production and development scenarios, and supports a variety of options/flags to configure your deployment.

    To view all available flags and equivalent environment variables for gateway deployment, see the [Gateway CLI Command Reference](/cli/commands/gateway).

    <Tabs>
      <Tab title="Linux Server (Production)">
        For production deployments on Linux servers, install the Gateway as a systemd service so that it runs securely in the background and automatically restarts on failure or system reboot:

        ```bash  theme={"dark"}
        sudo infisical gateway systemd install --token <your-machine-identity-token> --domain <your-infisical-domain> --name <gateway-name>
        sudo systemctl start infisical-gateway
        ```

        <Info>
          By default, the gateway connects to the most optimal relay. Use the `--relay` flag to manually specify a different relay server.
        </Info>

        <Warning>
          The systemd install command requires a Linux operating system with root/sudo
          privileges.
        </Warning>
      </Tab>

      <Tab title="Kubernetes (Production)">
        For production deployments on Kubernetes clusters, install the Gateway using the Infisical Helm chart:

        #### Install the latest Helm Chart repository

        ```bash  theme={"dark"}
        helm repo add infisical-helm-charts 'https://dl.cloudsmith.io/public/infisical/helm-charts/helm/charts/'
        helm repo update
        ```

        #### Create a Kubernetes Secret

        The gateway supports all identity authentication methods through environment variables:

        ```bash  theme={"dark"}
        kubectl create secret generic infisical-gateway-environment \
          --from-literal=INFISICAL_AUTH_METHOD=universal-auth \
          --from-literal=INFISICAL_UNIVERSAL_AUTH_CLIENT_ID=<client-id> \
          --from-literal=INFISICAL_UNIVERSAL_AUTH_CLIENT_SECRET=<client-secret> \
          --from-literal=INFISICAL_GATEWAY_NAME=<gateway-name>
        ```

        <Info>
          By default, the gateway connects to the most optimal relay. Use the `--from-literal=INFISICAL_RELAY_NAME=<relay-name>` flag to manually specify a different relay server.
        </Info>

        #### Install the Gateway

        ```bash  theme={"dark"}
        helm install infisical-gateway infisical-helm-charts/infisical-gateway
        ```
      </Tab>

      <Tab title="Development & Testing">
        For development or testing environments:

        ```bash  theme={"dark"}
        sudo infisical gateway start --token <token> --name=<gateway-name>
        ```

        <Info>
          By default, the gateway connects to the most optimal relay. Use the `--relay` flag to manually specify a different relay server.
        </Info>
      </Tab>
    </Tabs>
  </Step>

  <Step title="Verify Your Gateway Deployment">
    After deployment, verify your gateway is working:

    1. **Check logs** for "Gateway started successfully" message indicating the gateway is running and connected to the relay

    2. **Verify registration** in the Infisical by visiting the Gateways section of your organization. The new gateway should appear with a recent heartbeat timestamp.

    3. **Test connectivity** by creating a resource in Infisical that uses the gateway to access a private service. Verify the resource can successfully connect through the gateway.
  </Step>
</Steps>

## Frequently Asked Questions

<AccordionGroup>
  <Accordion title="Do I need to open any inbound ports on my firewall?">
    No inbound ports need to be opened for gateways. The gateway only makes outbound connections:

    * **Outbound SSH** to relay servers on port 2222
    * **Outbound HTTPS** to Infisical API endpoints on port 443
    * **SSH reverse tunnels** handle all communication - no return traffic configuration needed

    This design maintains security by avoiding the need for inbound firewall rules that could expose your network to external threats.
  </Accordion>

  <Accordion title="How do I test network connectivity from the gateway?">
    Test relay connectivity and outbound API access from the gateway:

    1. Test SSH port to relay:

    ```bash  theme={"dark"}
    nc -zv <relay-ip> 2222
    ```

    2. Test outbound API access (replace with your Infisical domain if different):

    ```bash  theme={"dark"}
    curl -I https://app.infisical.com
    ```
  </Accordion>

  <Accordion title="How do I troubleshoot relay connectivity issues?">
    If the gateway cannot connect to the relay:

    1. Verify the relay server is running and accessible
    2. Check firewall rules allow outbound connections on port 2222
    3. Confirm the relay name matches exactly
    4. Test SSH port to relay:

    ```bash  theme={"dark"}
    nc -zv <relay-ip> 2222
    ```
  </Accordion>

  <Accordion title="How do I troubleshoot authentication failures?">
    If you encounter authentication failures:

    1. Verify machine identity credentials are correct
    2. Check token expiration and renewal
    3. Ensure authentication method is properly configured
  </Accordion>

  <Accordion title="Where can I find gateway logs?">
    Check gateway logs for detailed error information:

    * **systemd service:**
      ```bash  theme={"dark"}
      sudo journalctl -u infisical-gateway -f
      ```
    * **Kubernetes:**
      ```bash  theme={"dark"}
      kubectl logs deployment/infisical-gateway
      ```
    * **Local installation:** Logs appear in the terminal where you started the gateway
  </Accordion>

  <Accordion title="Where is the gateway configuration file stored?">
    For systemd-based installations, the gateway's configuration file is stored at `/etc/infisical/gateway.conf`. You may reference or inspect this file for troubleshooting advanced configuration issues.
  </Accordion>

  <Accordion title="What happens if there is a network interruption?">
    The gateway is designed to handle network interruptions gracefully:

    * **Automatic reconnection**: The gateway will automatically attempt to reconnect to relay servers if the SSH connection is lost
    * **Connection retry logic**: Built-in retry mechanisms handle temporary network outages without manual intervention
    * **Persistent SSH tunnels**: SSH connections are automatically re-established when connectivity is restored
    * **Certificate rotation**: The gateway handles certificate renewal automatically during reconnection
    * **Graceful degradation**: The gateway logs connection issues and continues attempting to restore connectivity

    No manual intervention is typically required during network interruptions.
  </Accordion>
</AccordionGroup>


# Gateway Overview
Source: https://infisical.com/docs/documentation/platform/gateways/overview

How to access private network resources from Infisical

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/gateways/gateway-highlevel-diagram.png" alt="Architecture Overview" />

The Infisical Gateway provides secure access to private resources within your network without needing direct inbound connections to your environment.
This is particularly useful when Infisical isn't hosted within the same network as the resources it needs to reach.
This method keeps your resources fully protected from external access while enabling Infisical to securely interact with resources like databases.

<Info>
  Gateway is a paid feature available under the Enterprise Tier for Infisical
  Cloud users. Self-hosted Infisical users can contact
  [sales@infisical.com](mailto:sales@infisical.com) to purchase an enterprise
  license.
</Info>

## Core Components

The Gateway system consists of two primary components working together to enable secure network access:

<Tabs>
  <Tab title="Gateway" icon="server">
    A Gateway is a lightweight service that you deploy within your own network infrastructure to provide secure access to your private resources. Think of it as a secure bridge between Infisical and your internal systems.

    Gateways must be deployed within the same network where your target resources are located, with direct network connectivity to the private resources you want Infisical to access.
    For different networks, regions, or isolated environments, you'll need to deploy separate gateways.

    **Core Functions:**

    * **Network Placement**: Deployed within your VPCs, data centers, or on-premises infrastructure where your private resources live
    * **Connection Model**: Only makes outbound connections to Infisical's relay servers, so no inbound firewall rules are needed
    * **Security Method**: Uses SSH reverse tunnels with certificate-based authentication for maximum security
    * **Resource Access**: Acts as a proxy to connect Infisical to your private databases, APIs, and other services
  </Tab>

  <Tab title="Relay Server" icon="route">
    A Relay Server is the routing infrastructure that enables secure communication between the Infisical platform and your deployed gateways. It acts as an intermediary that never sees your actual data.

    **Core Functions:**

    * **Traffic Routing**: Routes encrypted traffic between the Infisical platform and your gateways without storing or inspecting the data
    * **Network Isolation**: Enables secure communication without requiring direct network connections between Infisical and your private infrastructure
    * **Authentication Management**: Validates SSH certificates and manages secure routing between authenticated gateways

    **Deployment Options:**
    To reduce operational overhead, Infisical Cloud (US/EU) provides managed relay infrastructure, though organizations can also deploy their own relays for reduced latency.

    * **Infisical Managed**: Use pre-deployed relays in select regions, shared across all Infisical Cloud organizations. Each organization traffic is isolated and encrypted.
    * **Self-Deployed**: Deploy your own dedicated relay servers geographically close to your infrastructure for reduced latency.
  </Tab>
</Tabs>

## How It Works

The Gateway system uses SSH reverse tunnels for secure, firewall-friendly connectivity:

1. **Gateway Registration**: The gateway establishes an outbound SSH reverse tunnel to a relay server using SSH certificates issued by Infisical
2. **Persistent Connection**: The gateway maintains an open TCP connection with the relay server, creating a secure channel for incoming requests
3. **Request Routing**: When Infisical needs to access your resources, requests are routed through the relay server to the already-established gateway connection
4. **Resource Access**: The gateway receives the routed requests and connects to your private resources on behalf of Infisical

## Health Check

To monitor their operational status, both gateways and relays transmit hourly heartbeats. A component is considered unhealthy if a heartbeat is not received for over an hour.

Infisical automatically notifies all organization admins of unhealthy gateway or relay statuses through email and in-app notifications.

## Getting Started

Ready to set up your gateway? Follow the guides below.

<Columns cols={2}>
  <Card title="Gateway Deployment" href="/documentation/platform/gateways/gateway-deployment">
    Deploy and configure your gateway within your network infrastructure.
  </Card>

  <Card title="Relay Deployment" href="/documentation/platform/gateways/relay-deployment">
    Set up relay servers if using self-deployed infrastructure.
  </Card>
</Columns>

<Columns cols={1}>
  <Card title="Security Architecture" href="/documentation/platform/gateways/security">
    Learn about the security model and implementation best practices.
  </Card>
</Columns>


# Overview
Source: https://infisical.com/docs/documentation/platform/gateways/relay-deployment/overview

How to deploy Infisical Relay Servers

Infisical Relay is a secure routing layer that allows Infisical to connect to your private network resources, such as databases or internal APIs, without exposing them to the public internet.
The relay acts as an intermediary, forwarding encrypted traffic between Infisical and your deployed gateways. This ensures that your sensitive data remains protected and never leaves your network unencrypted.
With this architecture, you can achieve secure, firewall-friendly access across network boundaries, making it possible for Infisical to interact with resources even in highly restricted environments.

Before diving in, it's important to determine whether you actually need to deploy your own relay server or if you can use Infisical's managed infrastructure.

## Do You Need to Deploy a Relay?

Not all users need to deploy their own relay servers. Infisical provides managed relay infrastructure in US/EU regions for Infisical Cloud users, which requires no setup or maintenance. You only need to deploy a relay if you:

* Are self-hosting Infisical
* Have a dedicated enterprise instance of Infisical (managed by Infisical)
* Require closer geographic proximity to target resources than managed relays provide for lower latency and reduced network congestion when accessing resources through the relay
* Need full control over relay infrastructure and traffic routing

If you are using Infisical Cloud and do not have specific requirements, you can use the managed relays provided by Infisical and skip the rest of this guide.

## Deployment Steps

To successfully deploy an Infisical Relay for use, follow these steps in order.

<Steps>
  <Step title="Provision a Machine Identity">
    Create a machine identity with the correct permissions to create and manage relays. This identity is used by the relay to authenticate with Infisical and should be provisioned in advance.
    The relay supports several [machine identity auth methods](/documentation/platform/identities/machine-identities) for authentication, as listed below. Choose the one that best fits your environment and set the corresponding environment variables when deploying the relay.

    <AccordionGroup>
      <Accordion title="Universal Auth">
        Simple and secure authentication using client ID and client secret.

        **Environment Variables:**

        * `INFISICAL_AUTH_METHOD=universal-auth`
        * `INFISICAL_UNIVERSAL_AUTH_CLIENT_ID=<client-id>`
        * `INFISICAL_UNIVERSAL_AUTH_CLIENT_SECRET=<client-secret>`
      </Accordion>

      <Accordion title="Token Auth">
        Direct authentication using a machine identity access token.

        **Environment Variables:**

        * `INFISICAL_TOKEN=<token>`
      </Accordion>

      <Accordion title="Native Kubernetes">
        Authentication using Kubernetes service account tokens.

        **Environment Variables:**

        * `INFISICAL_AUTH_METHOD=kubernetes`
        * `INFISICAL_MACHINE_IDENTITY_ID=<machine-identity-id>`
      </Accordion>

      <Accordion title="Native AWS IAM">
        Authentication using AWS IAM roles.

        **Environment Variables:**

        * `INFISICAL_AUTH_METHOD=aws-iam`
        * `INFISICAL_MACHINE_IDENTITY_ID=<machine-identity-id>`
      </Accordion>

      <Accordion title="Native GCP ID Token">
        Authentication using GCP identity tokens.

        **Environment Variables:**

        * `INFISICAL_AUTH_METHOD=gcp-id-token`
        * `INFISICAL_MACHINE_IDENTITY_ID=<machine-identity-id>`
      </Accordion>

      <Accordion title="GCP IAM">
        Authentication using GCP service account keys.

        **Environment Variables:**

        * `INFISICAL_AUTH_METHOD=gcp-iam`
        * `INFISICAL_MACHINE_IDENTITY_ID=<machine-identity-id>`
        * `INFISICAL_GCP_SERVICE_ACCOUNT_KEY_FILE_PATH=<path-to-key-file>`
      </Accordion>

      <Accordion title="Native Azure">
        Authentication using Azure managed identity.

        **Environment Variables:**

        * `INFISICAL_AUTH_METHOD=azure`
        * `INFISICAL_MACHINE_IDENTITY_ID=<machine-identity-id>`
      </Accordion>

      <Accordion title="OIDC Auth">
        Authentication using OIDC identity tokens.

        **Environment Variables:**

        * `INFISICAL_AUTH_METHOD=oidc-auth`
        * `INFISICAL_MACHINE_IDENTITY_ID=<machine-identity-id>`
        * `INFISICAL_JWT=<oidc-jwt>`
      </Accordion>

      <Accordion title="JWT Auth">
        Authentication using JWT tokens.

        **Environment Variables:**

        * `INFISICAL_AUTH_METHOD=jwt-auth`
        * `INFISICAL_MACHINE_IDENTITY_ID=<machine-identity-id>`
        * `INFISICAL_JWT=<jwt>`
      </Accordion>
    </AccordionGroup>
  </Step>

  <Step title="Provision a Server">
    Provision a server or virtual machine where you plan to deploy the relay. This server must have a static IP address or DNS name to be identifiable by the Infisical platform.
  </Step>

  <Step title="Configure Network & Firewall">
    Ensure your network and firewall settings allow the server to accept inbound connections and make outbound connections:

    **Inbound Connections Rules:**

    | Protocol | Source                                 | Port | Purpose                          |
    | -------- | -------------------------------------- | ---- | -------------------------------- |
    | TCP      | Gateways                               | 2222 | SSH reverse tunnel establishment |
    | TCP      | Infisical instance host (US/EU, other) | 8443 | Platform-to-relay communication  |

    **Outbound Connections Rules:**

    | Protocol | Destination                            | Port | Purpose                                    |
    | -------- | -------------------------------------- | ---- | ------------------------------------------ |
    | TCP      | Infisical instance host (US/EU, other) | 443  | API communication and certificate requests |
  </Step>

  <Step title="Select a Deployment Method">
    You can deploy the Infisical Relay in various ways. This guide provides a manual setup example using the Infisical CLI. For an infrastructure-as-code approach, see our [Terraform guide](/documentation/platform/gateways/relay-deployment/terraform).

    The Infisical CLI is used to install and start the relay in your chosen environment. The CLI provides commands for both production and development scenarios, and supports a variety of options/flags to configure your deployment.

    To view all available flags and equivalent environment variables for relay deployment, see the [Relay CLI Command Reference](/cli/commands/relay).

    <Tabs>
      <Tab title="Linux Server">
        For production deployments on Linux servers, install the Relay as a systemd service. This installation method only supports [Token Auth](/documentation/platform/identities/token-auth) at the moment.

        Once you have a [Token Auth](/documentation/platform/identities/token-auth) token, set the following environment variables for relay authentication:

        ```bash  theme={"dark"}
        export INFISICAL_TOKEN=<your-machine-identity-token>
        ```

        <Warning>
          The systemd install command requires a Linux operating system with root/sudo privileges.
        </Warning>

        ```bash  theme={"dark"}
        sudo infisical relay systemd install \
           --token <your-machine-identity-token> \
           --name <relay-name> \
           --domain <your-infisical-domain> \
           --host <static-ip-or-dns-of-the-server>

        # Start the relay service
        sudo systemctl start infisical-relay
        sudo systemctl enable infisical-relay
        ```
      </Tab>

      <Tab title="Other Environments">
        For non-Linux systems or when you need more control over the relay process:

        ```bash  theme={"dark"}
        infisical relay start \
           --host=<host> \
           --name=<name> \
           --auth-method=<auth-method>
        ```

        This method supports all [machine identity auth methods](/documentation/platform/identities/machine-identities) and runs in the foreground. Suitable for production use on non-Linux systems or development environments.
        Set the appropriate environment variables for your chosen auth method as described in Step 1 before running the relay start command.
      </Tab>
    </Tabs>
  </Step>
</Steps>

## Frequently Asked Questions

<AccordionGroup>
  <Accordion title="Can the relay servers decrypt traffic going through them?">
    No, relay servers cannot decrypt any traffic passing through them due to end-to-end encryption:

    * **Client-to-Gateway mTLS (via TLS-pinned tunnel)**: Clients connect via a proxy that establishes a TLS-pinned tunnel to the gateway; mTLS between the client and gateway is negotiated inside this tunnel, encrypting all application traffic
    * **SSH tunnel encryption**: The mTLS-encrypted traffic is then transmitted through SSH reverse tunnels to relay servers
    * **Double encryption**: Traffic is encrypted twice - once by client mTLS and again by SSH tunnels
    * **Relay only routes traffic**: The relay server only routes the doubly-encrypted traffic without access to either encryption layer

    The relay infrastructure is designed as a secure routing mechanism where only the client and gateway can decrypt the actual application traffic.
  </Accordion>

  <Accordion title="What are the benefits of deploying my own relay?">
    Deploying your own relay provides several advantages:

    * **Dedicated resources**: Full control over relay infrastructure and performance
    * **Lower latency**: Deploy closer to your gateways for optimal performance
    * **Compliance**: Meet specific data routing and compliance requirements
    * **Custom network policies**: Implement organization-specific network configurations
    * **Geographic proximity**: Reduce network congestion and improve response times to access resources
    * **High availability**: Deploy multiple relays for redundancy and load distribution

    Organization-deployed relays give you complete control over your secure communication infrastructure.
  </Accordion>

  <Accordion title="How do I troubleshoot connectivity issues?">
    For detailed troubleshooting:

    **Platform cannot connect to relay:**

    * Check firewall rules allow inbound TCP with TLS on port 8443
    * Test connectivity: `openssl s_client -connect <relay-ip>:8443`

    **Test network connectivity:**

    ```bash  theme={"dark"}
    # Test outbound API access from relay. Replace URL with your Infisical instance if self-hosted
    curl -I https://app.infisical.com

    # Test TCP with TLS port from platform
    openssl s_client -connect <relay-ip>:8443
    ```
  </Accordion>

  <Accordion title="What happens if my relay server goes down?">
    Relay server outages affect gateway connectivity:

    * **Gateway reconnection**: Gateways will automatically attempt to reconnect when the relay comes back online
    * **Service interruption**: While the relay is down, the Infisical platform cannot reach gateways through that relay. As a result, any secrets or resources accessed via those gateways will be temporarily unavailable until connectivity is restored.
    * **Multiple relays**: Deploy multiple relay servers for redundancy and high availability
    * **Automatic restart**: Use systemd or container orchestration to automatically restart failed relay services

    For production environments, consider deploying multiple relay servers to avoid single points of failure.
  </Accordion>
</AccordionGroup>


# Terraform
Source: https://infisical.com/docs/documentation/platform/gateways/relay-deployment/terraform

How to deploy Infisical Relay Servers using Terraform

This guide walks you through deploying an Infisical Relay server using Terraform. Select a provider below for specific instructions.

<Tabs>
  <Tab title="AWS EC2">
    The provided configuration automates the creation of the EC2 instance, sets up the necessary security group rules, and uses a startup script to install and configure the Infisical Relay service.

    ### Prerequisites

    Before you start, make sure you have the following:

    * An AWS account with permissions to create EC2 instances, Security Groups, and Elastic IPs.
    * An existing VPC and Subnet ID in your desired AWS region.
    * The AMI ID for your chosen OS (this guide uses an Ubuntu 22.04 LTS AMI).
    * Credentials for the Infisical Relay to authenticate with your Infisical instance. This guide uses a Machine Identity token, but other methods are available. You can find a full list of authentication options [here](/cli/commands/relay#available-authentication-methods).

    ### Terraform Configuration

    Here is the complete Terraform configuration to deploy the Infisical Relay.

    ```terraform  theme={"dark"}
    terraform {
      required_providers {
        aws = {
          source  = "hashicorp/aws"
          version = "~> 5.0"
        }
      }
    }

    provider "aws" {
      region = "us-west-2" # Change to your desired AWS region
    }

    # Security Group for the Infisical Relay instance
    resource "aws_security_group" "infisical_relay_sg" {
      name        = "infisical-relay-sg"
      description = "Allows inbound traffic for Infisical Relay and SSH"
      vpc_id      = "vpc-0c71f9c5709d88d18" # Change to your VPC ID

      # Inbound: Allows the Infisical platform to securely communicate with the Relay server.
      ingress {
        from_port   = 8443
        to_port     = 8443
        protocol    = "tcp"
        cidr_blocks = ["0.0.0.0/0"]
      }

      # Inbound: Allows Infisical Gateway to securely communicate via the Relay.
      ingress {
        from_port   = 2222
        to_port     = 2222
        protocol    = "tcp"
        cidr_blocks = ["0.0.0.0/0"]
      }

      # Inbound: Allows secure shell (SSH) access for administration.
      ingress {
        from_port   = 22
        to_port     = 22
        protocol    = "tcp"
        cidr_blocks = ["0.0.0.0/0"] # Restrict this to your IP in production
      }

      # Outbound: Allows the Relay server to make necessary outbound connections to the Infisical platform.
      egress {
        from_port   = 0
        to_port     = 0
        protocol    = "-1"
        cidr_blocks = ["0.0.0.0/0"]
      }

      tags = {
        Name = "infisical-relay-sg"
      }
    }

    # Elastic IP for a static public IP address
    resource "aws_eip" "infisical_relay_eip" {
      tags = {
        Name = "infisical-relay-eip"
      }
    }

    # EC2 instance to run Infisical Relay
    module "infisical_relay_instance" {
      source  = "terraform-aws-modules/ec2-instance/aws"
      version = "~> 5.6"

      name          = "infisical-relay-example"
      ami           = "ami-065778886ef8ec7c8" # Change to your desired AMI ID
      instance_type = "t3.micro"
      subnet_id     = "subnet-0fd2337a1c604a494" # Change to your Subnet ID

      vpc_security_group_ids      = [aws_security_group.infisical_relay_sg.id]
      associate_public_ip_address = false # We are using an Elastic IP instead

      user_data = <<-EOT
        #!/bin/bash
        set -e
        # Install Infisical CLI
        curl -1sLf 'https://artifacts-cli.infisical.com/setup.deb.sh' | bash
        apt-get update && apt-get install -y infisical

        # Install the relay as a systemd service.
        # This example uses a Machine Identity token for authentication via the INFISICAL_TOKEN environment variable.
        #
        # Note: For production environments, you might consider fetching the token from AWS Parameter Store or AWS Secrets Manager.
        export INFISICAL_TOKEN="your-machine-identity-token"
        sudo -E infisical relay systemd install \
          --name "my-relay-example" \
          --domain "https://app.infisical.com" \
          --host "${aws_eip.infisical_relay_eip.public_ip}"

        # Start and enable the service to run on boot
        sudo systemctl start infisical-relay
        sudo systemctl enable infisical-relay
      EOT
    }

    # Associate the Elastic IP with the EC2 instance
    resource "aws_eip_association" "eip_assoc" {
      instance_id   = module.infisical_relay_instance.id
      allocation_id = aws_eip.infisical_relay_eip.id
    }
    ```

    <Warning>
      The provided security group rules are open to the internet (`0.0.0.0/0`) for simplicity. In a production environment, you should restrict the `cidr_blocks` to known IP addresses for enhanced security, especially for the SSH port (22).
    </Warning>

    ### How to Deploy

    1. **Save the configuration:** Save the code above to a file named `main.tf`.
    2. **Customize values:** Update the placeholder values in `main.tf` to match your AWS environment and Infisical credentials. You'll need to replace:
       * `region` in the `provider` block.
       * `vpc_id` in the `aws_security_group` resource.
       * `ami` and `subnet_id` in the `infisical_relay_instance` module.
       * The `INFISICAL_TOKEN` environment variable in the `user_data` script (e.g., `export INFISICAL_TOKEN="your-machine-identity-token"`).
       * The `--domain` in the `user_data` script if you are self-hosting Infisical.
    3. **Apply the configuration:** Run the following Terraform commands in your terminal:
       ```bash  theme={"dark"}
       terraform init
       terraform plan
       terraform apply
       ```
  </Tab>
</Tabs>


# Security Architecture
Source: https://infisical.com/docs/documentation/platform/gateways/security

Security model, tenant isolation, and best practices for Infisical Gateways and Relays

The Infisical Gateway enables secure access to private resources using SSH reverse tunnels, certificate-based authentication, and a comprehensive PKI (Public Key Infrastructure) system. The architecture provides end-to-end encryption and complete tenant isolation through multiple certificate authorities.

## Security Model Overview

### Certificate Architecture

The gateway system uses multiple certificate authorities depending on deployment configuration:

**For Organizations Using Infisical-Managed Relays:**

* **Instance relay SSH Client CA & Server CA** - Gateway  Infisical Relay Server authentication
* **Instance relay PKI Client CA & Server CA** - Platform  Infisical Relay Server authentication
* **Organization Gateway Client CA & Server CA** - Platform  Gateway authentication

**For Organizations Using Customer-Deployed Relays:**

* **Organization relay SSH Client CA & Server CA** - Gateway  Customer Relay Server authentication
* **Organization relay PKI Client CA & Server CA** - Platform  Customer Relay Server authentication
* **Organization Gateway Client CA & Server CA** - Platform  Gateway authentication

### Certificate Hierarchy

```
Instance Level (Shared Relays):
 Instance Relay SSH CA (Gateway  Relay)
 Instance Relay PKI CA (Platform  Relay)

Organization Level:
 Organization Relay SSH CA (Gateway  Org Relay)
 Organization Relay PKI CA (Platform  Org Relay)
 Organization Gateway CA (Platform  Gateway)
```

## Communication Security

### 1. Gateway Registration

When a gateway is first deployed:

1. Authenticates with Infisical using machine identity token
2. Receives SSH certificates for relay server authentication
3. Establishes SSH reverse tunnel to assigned relay server
4. Certificate issuance varies by relay configuration:
   * **Infisical-managed relay**: Receives Instance relay SSH client certificate + Instance relay SSH Server CA
   * **Customer-deployed relay**: Receives Organization relay SSH client certificate + Organization relay SSH Server CA

### 2. SSH Tunnel Authentication

Gateway  Relay Server communication uses SSH certificate authentication:

* **Gateway Authentication**:

  * Presents SSH client certificate (Instance or Organization relay SSH Client CA)
  * Certificate contains gateway identification and permissions
  * Relay server validates certificate against appropriate SSH Client CA

* **Relay Server Authentication**:
  * Presents SSH server certificate (Instance or Organization relay SSH Server CA)
  * Gateway validates certificate against appropriate SSH Server CA
  * Ensures gateway connects to legitimate relay infrastructure

### 3. Platform-to-Gateway Direct Connection

The platform establishes secure direct connections with gateways through a **TLS-pinned tunnel** mechanism:

1. **TLS-Pinned Tunnel Establishment**:

   * Gateway initiates outbound connection to platform through SSH reverse tunnel
   * Platform establishes direct mTLS connection with gateway using Organization Gateway certificates
   * TLS certificate pinning ensures the connection is bound to the specific gateway identity
   * No inbound connections required - all communication flows through the outbound tunnel

2. **Connection Flow**:

   ```
   Platform  [TCP with TLS]  Relay  [SSH Reverse Tunnel]  Gateway
   ```

   * Gateway maintains persistent outbound SSH tunnel to relay server
   * Platform connects to relay server using TCP with TLS
   * Relay routes encrypted traffic between platform and gateway
   * TLS handshake occurs between platform and gateway through the relay
   * Application traffic flows through the TLS-pinned tunnel via relay routing

3. **Security Benefits**:
   * **No inbound connections**: Gateway never needs to accept incoming connections
   * **Certificate-based authentication**: Uses Organization Gateway certificates for mutual TLS
   * **Double encryption**: TLS traffic within SSH tunnel provides layered security
   * **Relay server isolation**: Relay cannot decrypt either TLS or application data
   * **Tenant isolation**: Each organization's traffic flows through separate authenticated channels

## Tenant Isolation

### Multi-Layer Certificate Isolation

The architecture provides tenant isolation through multiple certificate authority layers:

* **Instance-level CAs**: Shared relay infrastructure uses instance-level certificates
* **Organization-level CAs**: Each organization has unique certificate authorities
* **Relay deployment flexibility**: Organizations can choose shared or dedicated relay infrastructure
* **Cryptographic separation**: Cross-tenant communication is cryptographically impossible

### Authentication Flows by Deployment Type

**Infisical-Managed Relay Deployments:**

* Gateway authenticates with relay using Instance relay SSH certificates
* Platform authenticates with relay using Instance relay PKI certificates
* Platform authenticates with gateway using Organization Gateway certificates

**Customer-Deployed Relay Deployments:**

* Gateway authenticates with relay using Organization relay SSH certificates
* Platform authenticates with relay using Organization relay PKI certificates
* Platform authenticates with gateway using Organization Gateway certificates

### Resource Access Control

1. **Certificate Validation**:

   * All connections require valid certificates from appropriate CAs
   * Embedded certificate details control access permissions
   * Ephemeral certificate validation ensures time-bound access

2. **Network Isolation**:
   * Each organization's traffic flows through isolated certificate-authenticated channels
   * Relay servers route traffic based on certificate validation without content access
   * Gateway validates all incoming connections against Organization Gateway Client CA


# GitHub Team Sync
Source: https://infisical.com/docs/documentation/platform/github-org-sync

Learn how to automatically synchronize your GitHub teams with Infisical Groups.

## Overview

The GitHub Organization Synchronization feature streamlines user and group management by automatically syncing users belonging to your specified GitHub organization with corresponding groups within Infisical. This integration ensures that users logging in via GitHub are automatically added to or removed from Infisical groups based on their team memberships within your GitHub organization.

## Configuration

To enable and configure GitHub Organization Synchronization, follow these steps:

<Steps>
  <Step title="Set up GitHub organization configuration">
    1. Navigate to the **Single Sign-On (SSO)** page and select the **Provisioning** tab.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/external-syncs/github-org-sync-section.png" alt="config" />
    2. Click the **Configure** button and provide the name of your GitHub Organization.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/external-syncs/github-org-sync-config-modal.png" alt="config-modal" />
  </Step>

  <Step title="Enable GitHub organization sync">
    Toggle ON GitHub Organization sync to activate sync.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/external-syncs/github-org-sync-active.png" alt="toggle-on" />
  </Step>

  <Step title="Approve the Infisical OAuth application on your organization">
    Connecting the Infisical OAuth application grants it permission to **read:org** details. This approval is done by selecting your organization during the GitHub OAuth login process.

    1. Initiate the login process via the GitHub OAuth flow.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/external-syncs/github-org-sync-oauth-flow-start.png" alt="oauth-flow-start" />
    2. Select the organization you have connected.
    3. Grant access to Infisical oauth application to your configured organization.  Infisical shown here is an organization, just for walkthrough.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/external-syncs/github-org-sync-oauth.png" alt="grant-access" />

    <Info>
      This action only needs to be done once and authorizes the Infisical OAuth app to read organization details, including team information.
      The following users don't need to select organization in GitHub on login anymore.
    </Info>
  </Step>
</Steps>

## Working

Once configured, the GitHub Organization Synchronization feature functions as follows:

When a user logs in via the GitHub OAuth flow and selects the configured organization, the system will then automatically synchronize the teams they are a part of in GitHub with corresponding groups in Infisical.

## Manual Team Sync

You can manually synchronize GitHub teams for all organization members who have previously logged in with GitHub. This bulk sync operation updates team memberships without requiring users to log in again.

<Steps>
  <Step title="Generate a GitHub Access Token">
    To perform manual syncs, you'll need to create a GitHub Personal Access Token with the appropriate permissions. GitHub offers two types of tokens:

    <Tabs>
      <Tab title="Classic Token">
        1. Go to [GitHub Settings  Personal Access Tokens  Tokens (classic)](https://github.com/settings/tokens)
        2. Click **Generate new token**  **Generate new token (classic)**
        3. Give your token a descriptive name (e.g., "Infisical GitHub Sync")
        4. Set an appropriate expiration date
        5. Select the **read:org** scope - Required to read organization team information
        6. Click **Generate token**
        7. Copy the token immediately (you won't be able to see it again)

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/external-syncs/github-classic-token.png" alt="Classic Token Creation" />
      </Tab>

      <Tab title="Fine-grained Token">
        1. Go to [GitHub Settings  Personal Access Tokens  Fine-grained tokens](https://github.com/settings/personal-access-tokens/new)
        2. Click **Generate new token**
        3. Give your token a descriptive name (e.g., "Infisical GitHub Sync")
        4. Set an appropriate expiration date
        5. Select your organization under **Resource owner**
        6. Under **Organization permissions**, set **Members** to **Read**
        7. Click **Generate token**
        8. Copy the token immediately (you won't be able to see it again)

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/external-syncs/github-fine-grained-token.png" alt="Fine-grained Token Creation" />
      </Tab>
    </Tabs>
  </Step>

  <Step title="Configure the Token in Infisical">
    1. Navigate to the **Single Sign-On (SSO)** page and select the **Provisioning** tab.
    2. Click the **Configure** button next to your GitHub Organization configuration.
    3. In the configuration modal, you'll find an optional **GitHub Access Token** field.
    4. Paste the token you generated in the previous step.
    5. Click **Update** to save the configuration.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/external-syncs/github-token-config-modal.png" alt="Token Configuration Modal" />
  </Step>

  <Step title="Perform Manual Sync">
    Once you have configured the GitHub access token:

    1. Navigate to the **Single Sign-On (SSO)** page and select the **Provisioning** tab.
    2. You'll see a **Sync Now** section with a button to trigger the manual sync.
    3. Click **Sync Now** to synchronize GitHub teams for all organization members.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/external-syncs/github-manual-sync-button.png" alt="Manual Sync Button" />

    The sync operation will process all organization members who have previously logged in with GitHub and update their team memberships accordingly.
  </Step>
</Steps>

## Troubleshooting

<Accordion title="Please check if your organization has approved the Infisical OAuth application.">
  If you encounter an error related to this, it indicates that you need to approve the Infisical OAuth application within your GitHub organization.

  You can verify the application's approval status by navigating to **[https://github.com/organizations/\_\_your-organization\_\_/settings/oauth\_application\_policy](https://github.com/organizations/__your-organization__/settings/oauth_application_policy)**. Replace `__your-organization__` with the actual name of your GitHub organization.

    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/external-syncs/github-org-sync-approved-oauth-apps.png" alt="check-approval" />
</Accordion>


# User Groups
Source: https://infisical.com/docs/documentation/platform/groups

Manage user groups in Infisical.

<Info>
  User Groups is a paid feature.

  If you're using Infisical Cloud, then it is available under the **Enterprise Tier**. If you're self-hosting Infisical,
  then you should contact [team@infisical.com](mailto:team@infisical.com) to purchase an enterprise license to use it.
</Info>

## Concept

A (user) group is a collection of users that you can create in an Infisical organization to more efficiently manage permissions and access control for multiple users together. For example, you can have a group called `Developers` with the `Developer` role containing all the developers in your organization.

User groups have the following properties:

* If a group is added to a project under specific role(s), all users in the group will be provisioned access to the project with the role(s). Conversely, if a group is removed from a project, all users in the group will lose access to the project.
* If a user is added to a group, they will inherit the access control properties of the group including access to project(s) under the role(s) assigned to the group. Conversely, if a user is removed from a group, they will lose access to project(s) that the group has access to.
* If a user was previously added to a project under a role and is later added to a group that has access to the same project under a different role, then the user will now have access to the project under the composite permissions of the two roles. If the group is subsequently removed from the project, the user will not lose access to the project as they were previously added to the project separately.
* A user can be part of multiple groups. If a user is part of multiple groups, they will inherit the composite permissions of all the groups that they are part of.

## Workflow

In the following steps, we explore how to create and use user groups to provision user access to projects in Infisical.

<Steps>
  <Step title="Creating a group">
    To create a group, head to your Organization Settings > Access Control > Groups and press **Create group**.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/groups/groups-org.png" alt="groups org" />

    When creating a group, you specify an organization level [role](/documentation/platform/access-controls/role-based-access-controls) for it to assume; you can configure roles in Organization Settings > Access Control > Organization Roles.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/groups/groups-org-create.png" alt="groups org create" />

    Now input a few details for your new group. Heres some guidance for each field:

    * Name (required): A friendly name for the group like `Engineering`.
    * Slug (required): A unique identifier for the group like `engineering`.
    * Role (required): A role from the Organization Roles tab for the group to assume. The organization role assigned will determine what organization level resources this group can have access to.
  </Step>

  <Step title="Adding users to the group">
    Next, you'll want to assign users to the group. To do this, press on the users icon on the group and start assigning users to the group.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/groups/groups-org-users.png" alt="groups org users" />

    In this example, we're assigning **Alan Turing** and **Ada Lovelace** to the group **Engineering**.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/groups/groups-org-users-assign.png" alt="groups org assign users" />
  </Step>

  <Step title="Adding the group to a project">
    To enable the group to access project-level resources such as secrets within a specific project, you should add it to that project.

    To do this, head over to the project you want to add the group to and go to Project Settings > Access Control > Groups and press **Add group**.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/groups/groups-project.png" alt="groups project" />

    Next, select the group you want to add to the project and the project level role you want to allow it to assume. The project role assigned will determine what project level resources this group can have access to.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/groups/groups-project-create.png" alt="groups project add" />

    That's it!

    The users of the group now have access to the project under the role you assigned to the group.
  </Step>
</Steps>


# Alibaba Cloud Auth
Source: https://infisical.com/docs/documentation/platform/identities/alicloud-auth

Learn how to authenticate with Infisical using Alibaba Cloud user accounts.

**Alibaba Cloud Auth** is an authentication method that verifies Alibaba Cloud users through signature validation, allowing secure access to Infisical resources.

## Diagram

The following sequence diagram illustrates the Alibaba Cloud Auth workflow for authenticating Alibaba Cloud users with Infisical.

```mermaid  theme={"dark"}
sequenceDiagram
  participant Client
  participant Infisical
  participant Alibaba Cloud

  Note over Client,Client: Step 1: Sign user identity request

  Note over Client,Infisical: Step 2: Login Operation
  Client->>Infisical: Send signed request details to /api/v1/auth/alicloud-auth/login

  Note over Infisical,Alibaba Cloud: Step 3: Request verification
  Infisical->>Alibaba Cloud: Forward signed request
  Alibaba Cloud-->>Infisical: Return user details

  Note over Infisical: Step 4: Identity property validation
  Infisical->>Client: Return short-lived access token

  Note over Client,Infisical: Step 5: Access Infisical API with token
  Client->>Infisical: Make authenticated requests using the short-lived access token
```

## Concept

At a high level, Infisical authenticates an Alibaba Cloud user by verifying its identity and checking that it meets specific requirements (e.g., its ARN is whitelisted) at the `/api/v1/auth/alicloud-auth/login` endpoint. If successful,
then Infisical returns a short-lived access token that can be used to make authenticated requests to the Infisical API.

To be more specific:

1. The client signs a `GetCallerIdentity` request using an Alibaba Cloud user's access key secret; this is done using an HMAC sha1 algorithm.
2. The client sends the signed request information alongside the signature to Infisical at the `/api/v1/auth/alicloud-auth/login` endpoint.
3. Infisical reconstructs the request and sends it to Alibaba Cloud for verification and obtains the identity associated with the Alibaba Cloud user.
4. Infisical checks the user's properties against set criteria such as **Allowed ARNs**.
5. If all checks pass, Infisical returns a short-lived access token that the client can use to make authenticated requests to the Infisical API.

## Prerequisite

In order to sign requests, you must have an Alibaba Cloud user with credentials such as access key ID and secret. If you're unaware of how to create a user and obtain the needed credentials, expand the menu below.

<Accordion title="Creating an Alibaba Cloud user">
  <Steps>
    <Step title="Click 'Create User'">
      Visit [https://ram.console.aliyun.com/users](https://ram.console.aliyun.com/users) to get to the Users page and click **Create User**.

            <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/alicloud/users-page.png" alt="Users Page" />
    </Step>

    <Step title="Provide User Info">
      Fill out the username and display name with values of your choice and click **OK**.

            <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/alicloud/user-info.png" alt="User Info" />
    </Step>

    <Step title="Click User Row">
      After a user has been created, click on its row to see user information.

            <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/alicloud/user-row.png" alt="User Info" />
    </Step>

    <Step title="Create Access Key">
      Click **Create AccessKey** and select the most relevant option for your use-case. Then click **Continue**.

            <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/alicloud/create-access-key.png" alt="User Info" />
    </Step>

    <Step title="Copy Credentials">
      Save the displayed credentials for later steps.

            <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/alicloud/credentials.png" alt="User Info" />
    </Step>
  </Steps>
</Accordion>

## Guide

In the following steps, we explore how to create and use identities for your workloads and applications on Alibaba Cloud to
access the Infisical API using request signing.

### Creating an identity

To create an identity, head to your Organization Settings > Access Control > [Identities](https://app.infisical.com/organization/access-management?selectedTab=identities) and press **Create identity**.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-org.png" alt="identities organization" />

When creating an identity, you specify an organization-level [role](/documentation/platform/access-controls/role-based-access-controls) for it to assume; you can configure roles in Organization Settings > Access Control > [Organization Roles](https://app.infisical.com/organization/access-management?selectedTab=roles).

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-org-create.png" alt="identities organization create" />

Input some details for your new identity:

* **Name (required):** A friendly name for the identity.
* **Role (required):** A role from the [**Organization Roles**](https://app.infisical.com/organization/access-management?selectedTab=roles) tab for the identity to assume. The organization role assigned will determine what organization-level resources this identity can have access to.

Once you've created an identity, you'll be redirected to a page where you can manage the identity.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-page.png" alt="identities page" />

Since the identity has been configured with [Universal Auth](https://infisical.com/docs/documentation/platform/identities/universal-auth) by default, you should reconfigure it to use Alibaba Cloud Auth instead. To do this, click the cog next to **Universal Auth** and then select **Delete** in the options dropdown.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-press-cog.png" alt="identities press cog" />

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-page-remove-default-auth.png" alt="identities page remove default auth" />

Now create a new Alibaba Cloud Auth Method.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/alicloud/create-auth-method.png" alt="identities create alicloud auth method" />

Here's some information about each field:

* **Allowed ARNs:** A comma-separated list of trusted Alibaba Cloud ARNs that are allowed to authenticate with Infisical.
* **Access Token TTL (default is `2592000` equivalent to 30 days):** The lifetime for an access token in seconds. This value will be referenced at renewal time.
* **Access Token Max TTL (default is `2592000` equivalent to 30 days):** The maximum lifetime for an access token in seconds. This value will be referenced at renewal time.
* **Access Token Max Number of Uses (default is `0`):** The maximum number of times that an access token can be used; a value of `0` implies an infinite number of uses.
* **Access Token Trusted IPs:** The IPs or CIDR ranges that access tokens can be used from. By default, each token is given the `0.0.0.0/0`, allowing usage from any network address.

### Adding an identity to a project

In order to allow an identity to access project-level resources such as secrets, you must add it to the relevant projects.

To do this, head over to the project you want to add the identity to and navigate to Project Settings > Access Control > Machine Identities and press **Add Identity**.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-project.png" alt="identities project" />

Select the identity you want to add to the project and the project-level role you want it to assume. The project role given to the identity will determine what project-level resources this identity can access.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-project-create.png" alt="identities project create" />

### Accessing the Infisical API with the identity

To access the Infisical API as the identity, you need to construct a signed `GetCallerIdentity` request and then make a request to the `/api/v1/auth/alicloud-auth/login` endpoint passing the signed data and signature.

Below is an example of how you can authenticate with Infisical using NodeJS.

```ts  theme={"dark"}
import crypto from "crypto";

// We highly recommend using environment variables instead of hardcoding these values
const ALICLOUD_ACCESS_KEY_ID = "...";
const ALICLOUD_ACCESS_KEY_SECRET = "...";

const params: { [key: string]: string } = {
  Action: "GetCallerIdentity",
  Format: "JSON",
  Version: "2015-04-01",
  AccessKeyId: ALICLOUD_ACCESS_KEY_ID,
  SignatureMethod: "HMAC-SHA1",
  Timestamp: new Date().toISOString(),
  SignatureVersion: "1.0",
  SignatureNonce: crypto.randomBytes(16).toString("hex"),
};

const canonicalizedQueryString = Object.keys(params)
  .sort()
  .map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(params[key])}`)
  .join("&");

const stringToSign = `GET&%2F&${encodeURIComponent(canonicalizedQueryString)}`;

const signature = crypto
  .createHmac("sha1", `${ALICLOUD_ACCESS_KEY_SECRET}&`)
  .update(stringToSign)
  .digest("base64");

const res = await fetch(
  "https://app.infisical.com/api/v1/auth/alicloud-auth/login",
  {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
    },
    body: JSON.stringify({
      identityId: "...", // Replace with your identity ID
      Signature: signature,
      ...params,
    }),
  },
);

const json = await res.json();

console.log("Infisical Response:", JSON.stringify(json));
```

<Note>
  Each identity access token has a time-to-live (TTL) which you can infer from the response of the login operation; the default TTL is `7200` seconds, which can be adjusted.

  If an identity access token expires, it can no longer access the Infisical API. A new access token should be obtained by performing another login operation.
</Note>


# Machine Identity Auth Templates
Source: https://infisical.com/docs/documentation/platform/identities/auth-templates

Learn how to use auth templates to standardize authentication configurations for machine identities.

## Concept

Machine Identity Auth Templates allow you to create reusable authentication configurations that can be applied across multiple machine identities. This feature helps standardize authentication setups, reduces configuration drift, and simplifies identity management at scale.

Instead of manually configuring authentication settings for each identity, you can create templates with predefined authentication parameters and apply them to multiple identities. This ensures consistency and reduces the likelihood of configuration errors.

Key Benefits:

* **Standardization**: Ensure consistent authentication configurations across identities
* **Efficiency**: Reduce time spent configuring individual identities
* **Governance**: Centrally manage and update authentication parameters
* **Scalability**: Easily apply proven configurations to new identities

## Managing Auth Templates

Auth templates are managed in **Organization Settings > Access Control > Identities** under the **Identity Auth Templates** section.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/auth-templates/templates-section.png" alt="Identity Auth Templates Section" />

### Creating a Template

<Steps>
  <Step title="Navigate to Auth Templates">
    In your organization settings, go to **Access Control > Identities** and scroll down to the **Identity Auth Templates** section.
  </Step>

  <Step title="Create a new template">
    Click **Create Template** to open the template creation modal.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/auth-templates/create-template-button.png" alt="Create Template Button" />

    Select the authentication method you want to create a template for (currently supports LDAP Auth).
  </Step>

  <Step title="Configure template settings">
    Fill in the template configuration based on your chosen authentication method.

    <Tabs>
      <Tab title="LDAP Auth Template">
        **For LDAP Auth templates**, configure the following fields:

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/auth-templates/ldap-template.png" alt="LDAP Auth Template" />

        * **Template Name**: A descriptive name for your template
        * **URL**: The LDAP server to connect to such as `ldap://ldap.your-org.com`, `ldaps://ldap.myorg.com:636` *(for connection over SSL/TLS)*, etc.
        * **Bind DN**: The DN to bind to the LDAP server with.
        * **Bind Pass**: The password to bind to the LDAP server with.
        * **Search Base / DN**: Base DN under which to perform user search such as `ou=Users,dc=acme,dc=com`.
        * **CA Certificate**: The CA certificate to use when verifying the LDAP server certificate. This field is optional but recommended.

        <Note>
          You can read more about LDAP Auth configuration in the [LDAP Auth documentation](/documentation/platform/identities/ldap-auth/general).
        </Note>
      </Tab>
    </Tabs>
  </Step>
</Steps>

### Using Templates

Once created, templates can be applied when configuring authentication methods for machine identities. When adding an auth method to an identity, you'll have the option to select from available templates or configure manually.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/auth-templates/machine-identity-page.png" alt="Attach Template" />
<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/auth-templates/attach-template-form.png" alt="Attach Template Form" />

### Managing Template Usage

You can view which identities are using a specific template by clicking **View Usages** in the template's dropdown menu.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/auth-templates/template-usages.png" alt="Template Usages" />
<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/auth-templates/template-usages-modal.png" alt="Template Usages Modal" />

## FAQ

<AccordionGroup>
  <Accordion title="Can I modify a template after it's been applied to identities?">
    Yes, you can edit existing templates. After editing a template, changes to templates will automatically update identities that are already using them.
  </Accordion>

  <Accordion title="What happens if I delete a template that's in use?">
    If you delete a template that's currently being used by identities, those identities will continue to function with their existing configuration. However, the link to the template will be broken, and you won't be able to use the template for new identities.
  </Accordion>

  <Accordion title="Can I see which identities are using a specific template?">
    Yes, click **View Usages** in the template's dropdown menu to see all identities currently using that template.
  </Accordion>

  <Accordion title="Do templates support all authentication methods?">
    Currently, auth templates support LDAP Auth. Support for additional authentication methods will be added in future releases.
  </Accordion>
</AccordionGroup>


# AWS Auth
Source: https://infisical.com/docs/documentation/platform/identities/aws-auth

Learn how to authenticate with Infisical for EC2 instances, Lambda functions, and other IAM principals.

**AWS Auth** is an AWS-native authentication method for IAM principals like EC2 instances or Lambda functions to access Infisical.

## Diagram

The following sequence diagram illustrates the AWS Auth workflow for authenticating AWS IAM principals with Infisical.

```mermaid  theme={"dark"}
sequenceDiagram
  participant Client as Client
  participant Infis as Infisical
  participant AWS as AWS STS

  Note over Client,Client: Step 1: Sign GetCallerIdentityQuery

  Note over Client,Infis: Step 2: Login Operation
  Client->>Infis: Send signed query details /api/v1/auth/aws-auth/login

  Note over Infis,AWS: Step 3: Query verification
  Infis->>AWS: Forward signed GetCallerIdentity query
  AWS-->>Infis: Return IAM user/role details

  Note over Infis: Step 4: Identity Property Validation
  Infis->>Client: Return short-lived access token

  Note over Client,Infis: Step 5: Access Infisical API with Token
  Client->>Infis: Make authenticated requests using the short-lived access token
```

## Concept

At a high-level, Infisical authenticates an IAM principal by verifying its identity and checking that it meets specific requirements (e.g. it is an allowed IAM principal ARN) at the `/api/v1/auth/aws-auth/login` endpoint. If successful,
then Infisical returns a short-lived access token that can be used to make authenticated requests to the Infisical API.

To be more specific:

1. The client IAM principal signs a `GetCallerIdentity` query using the [AWS Signature v4 algorithm](https://docs.aws.amazon.com/IAM/latest/UserGuide/create-signed-request.html); this is done using the credentials from the AWS environment where the IAM principal is running.
2. The client sends the signed query data to Infisical including the request method, request body, and request headers at the `/api/v1/auth/aws-auth/login` endpoint.
3. Infisical reconstructs the query and sends it to AWS STS API via the [sts:GetCallerIdentity](https://docs.aws.amazon.com/STS/latest/APIReference/API_GetCallerIdentity.html) method for verification and obtains the identity associated with the IAM principal.
4. Infisical checks the identity's properties against set criteria such **Allowed Principal ARNs**.
5. If all is well, Infisical returns a short-lived access token that the IAM principal can use to make authenticated requests to the Infisical API.

<Note>
  We recommend using one of Infisical's clients like SDKs or the Infisical Agent
  to authenticate with Infisical using AWS Auth as they handle the
  authentication process including the signed `GetCallerIdentity` query
  construction for you.

  Also, note that Infisical needs network-level access to send requests to the AWS STS API
  as part of the AWS Auth workflow.
</Note>

## Guide

In the following steps, we explore how to create and use identities for your workloads and applications on AWS to
access the Infisical API using the AWS Auth authentication method.

<Steps>
  <Step title="Creating an identity">
    To create an identity, head to your Organization Settings > Access Control > Identities and press **Create identity**.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-org.png" alt="identities organization" />

    When creating an identity, you specify an organization level [role](/documentation/platform/access-controls/role-based-access-controls) for it to assume; you can configure roles in Organization Settings > Access Control > Organization Roles.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-org-create.png" alt="identities organization create" />

    Now input a few details for your new identity. Here's some guidance for each field:

    * Name (required): A friendly name for the identity.
    * Role (required): A role from the **Organization Roles** tab for the identity to assume. The organization role assigned will determine what organization level resources this identity can have access to.

    Once you've created an identity, you'll be redirected to a page where you can manage the identity.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-page.png" alt="identities page" />

    Since the identity has been configured with Universal Auth by default, you should re-configure it to use AWS Auth instead. To do this, press to edit the **Authentication** section,
    remove the existing Universal Auth configuration, and add a new AWS Auth configuration onto the identity.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-page-remove-default-auth.png" alt="identities page remove default auth" />

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-org-create-aws-auth-method.png" alt="identities create aws auth method" />

    Here's some more guidance on each field:

    * Allowed Principal ARNs: A comma-separated list of trusted IAM principal ARNs that are allowed to authenticate with Infisical. The values should take one of three forms: `arn:aws:iam::123456789012:user/MyUserName`, `arn:aws:iam::123456789012:role/MyRoleName`, or `arn:aws:iam::123456789012:*`. Using a wildcard in this case allows any IAM principal in the account `123456789012` to authenticate with Infisical under the identity.
    * Allowed Account IDs: A comma-separated list of trusted AWS account IDs that are allowed to authenticate with Infisical.
    * STS Endpoint (default is `https://sts.amazonaws.com/`): The endpoint URL for the AWS STS API. This value should be adjusted based on the AWS region you are operating in (e.g. `https://sts.us-east-1.amazonaws.com/`); refer to the list of regional STS endpoints [here](https://docs.aws.amazon.com/general/latest/gr/sts.html).
    * Access Token TTL (default is `2592000` equivalent to 30 days): The lifetime for an acccess token in seconds. This value will be referenced at renewal time.
    * Access Token Max TTL (default is `2592000`  equivalent to 30 days): The maximum lifetime for an acccess token in seconds. This value will be referenced at renewal time.
    * Access Token Max Number of Uses (default is `0`): The maximum number of times that an access token can be used; a value of `0` implies infinite number of uses.
    * Access Token Trusted IPs: The IPs or CIDR ranges that access tokens can be used from. By default, each token is given the `0.0.0.0/0`, allowing usage from any network address.
  </Step>

  <Step title="Adding an identity to a project">
    To enable the identity to access project-level resources such as secrets within a specific project, you should add it to that project.

    To do this, head over to the project you want to add the identity to and go to Project Settings > Access Control > Machine Identities and press **Add identity**.

    Next, select the identity you want to add to the project and the project level role you want to allow it to assume. The project role assigned will determine what project level resources this identity can have access to.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-project.png" alt="identities project" />

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-project-create.png" alt="identities project create" />
  </Step>

  <Step title="Accessing the Infisical API with the identity">
    To access the Infisical API as the identity, you need to construct a signed `GetCallerIdentity` query using the [AWS Signature v4 algorithm](https://docs.aws.amazon.com/IAM/latest/UserGuide/create-signed-request.html) and make a request to the `/api/v1/auth/aws-auth/login` endpoint containing the query data
    in exchange for an access token.

    We provide a few code examples below of how you can authenticate with Infisical from inside a Lambda function, EC2 instance, etc. and obtain an access token to access the [Infisical API](/api-reference/overview/introduction).

    <AccordionGroup>
      <Accordion title="Sample code for inside a Lambda function">
        The following query construction is an example of how you can authenticate with Infisical from inside a Lambda function.

        The shown example uses Node.js but you can use other languages supported by AWS Lambda.

        ```javascript  theme={"dark"}
        import AWS from "aws-sdk";
        import axios from "axios";

        export const handler = async (event, context) => {
            try {
                const region = process.env.AWS_REGION;
                AWS.config.update({ region });

                const iamRequestURL = `https://sts.${region}.amazonaws.com/`;
                const iamRequestBody = "Action=GetCallerIdentity&Version=2011-06-15";
                const iamRequestHeaders = {
                    "Content-Type": "application/x-www-form-urlencoded; charset=utf-8",
                    Host: `sts.${region}.amazonaws.com`,
                };

                // Create the request
                const request = new AWS.HttpRequest(iamRequestURL, region);
                request.method = "POST";
                request.headers = iamRequestHeaders;
                request.headers["X-Amz-Date"] = AWS.util.date
                    .iso8601(new Date())
                    .replace(/[:-]|\.\d{3}/g, "");
                request.body = iamRequestBody;
                request.headers["Content-Length"] =
                Buffer.byteLength(iamRequestBody).toString();

                // Sign the request
                const signer = new AWS.Signers.V4(request, "sts");
                signer.addAuthorization(AWS.config.credentials, new Date());

                const infisicalUrl = "https://app.infisical.com"; // or your self-hosted Infisical URL
                const identityId = "<your-identity-id>";

                const { data } = await axios.post(
                    `${infisicalUrl}/api/v1/auth/aws-auth/login`,
                    {
                        identityId,
                        iamHttpRequestMethod: "POST",
                        iamRequestUrl: Buffer.from(iamRequestURL).toString("base64"),
                        iamRequestBody: Buffer.from(iamRequestBody).toString("base64"),
                        iamRequestHeaders: Buffer.from(
                        JSON.stringify(iamRequestHeaders)
                        ).toString("base64"),
                    }
                );

                console.log("result data: ", data); // access token here
            } catch (err) {
                console.error(err);
            }
        };
        ```
      </Accordion>

      <Accordion title="Sample code for inside an EC2 instance">
        The following query construction is an example of how you can authenticate with Infisical from inside a EC2 instance.

        The shown example uses Node.js but you can use other language you wish.

        ```javascript  theme={"dark"}
        import AWS from "aws-sdk";
        import axios from "axios";

        const main = async () => {
            try {
                // obtain region from EC2 instance metadata
                const tokenResponse = await axios.put("http://169.254.169.254/latest/api/token", null, {
                    headers: {
                    "X-aws-ec2-metadata-token-ttl-seconds": "21600"
                    }
                });

                const url = "http://169.254.169.254/latest/dynamic/instance-identity/document";
                const response = await axios.get(url, {
                    headers: {
                        "X-aws-ec2-metadata-token": tokenResponse.data
                    }
                });

                const region = response.data.region;

                AWS.config.update({
                    region
                });

                const iamRequestURL = `https://sts.${region}.amazonaws.com/`;
                const iamRequestBody = "Action=GetCallerIdentity&Version=2011-06-15";
                const iamRequestHeaders = {
                    "Content-Type": "application/x-www-form-urlencoded; charset=utf-8",
                    Host: `sts.${region}.amazonaws.com`
                };

                const request = new AWS.HttpRequest(new AWS.Endpoint(iamRequestURL), AWS.config.region);
                request.method = "POST";
                request.headers = iamRequestHeaders;
                request.headers["X-Amz-Date"] = AWS.util.date.iso8601(new Date()).replace(/[:-]|\.\d{3}/g, "");
                request.body = iamRequestBody;
                request.headers["Content-Length"] = Buffer.byteLength(iamRequestBody);

                const signer = new AWS.Signers.V4(request, "sts");
                signer.addAuthorization(AWS.config.credentials, new Date());

                const infisicalUrl = "https://app.infisical.com"; // or your self-hosted Infisical URL
                const identityId = "<your-identity-id>";

                const { data } = await axios.post(`${infisicalUrl}/api/v1/auth/aws-auth/login`, {
                    identityId,
                    iamHttpRequestMethod: "POST",
                    iamRequestUrl: Buffer.from(iamRequestURL).toString("base64"),
                    iamRequestBody: Buffer.from(iamRequestBody).toString("base64"),
                    iamRequestHeaders: Buffer.from(JSON.stringify(iamRequestHeaders)).toString("base64")
                });

                console.log("result data: ", data); // access token here
            } catch (err) {
                console.error(err);
            }
        }

        main();
        ```
      </Accordion>

      <Accordion title="Sample code for general query construction">
        The following query construction provides a generic example of how you can construct a signed `GetCallerIdentity` query and obtain the required payload components.

        The shown example uses Node.js but you can use any language you wish.

        ```javascript  theme={"dark"}
        const AWS = require("aws-sdk");

        const region = "<your-aws-region>";
        const infisicalUrl = "https://app.infisical.com"; // or your self-hosted Infisical URL

        const iamRequestURL = `https://sts.${region}.amazonaws.com/`;
        const iamRequestBody = "Action=GetCallerIdentity&Version=2011-06-15";
        const iamRequestHeaders = {
            "Content-Type": "application/x-www-form-urlencoded; charset=utf-8",
            Host: `sts.${region}.amazonaws.com`
        };

        const request = new AWS.HttpRequest(new AWS.Endpoint(iamRequestURL), region);
        request.method = "POST";
        request.headers = iamRequestHeaders;
        request.headers["X-Amz-Date"] = AWS.util.date.iso8601(new Date()).replace(/[:-]|\.\d{3}/g, "");
        request.body = iamRequestBody;
        request.headers["Content-Length"] = Buffer.byteLength(iamRequestBody);

        const signer = new AWS.Signers.V4(request, "sts");
        signer.addAuthorization(AWS.config.credentials, new Date());
        ```

        #### Sample request

        ```bash Request theme={"dark"}
        curl --location --request POST 'https://app.infisical.com/api/v1/auth/aws-auth/login' \
            --header 'Content-Type: application/x-www-form-urlencoded' \
            --data-urlencode 'identityId=...' \
            --data-urlencode 'iamHttpRequestMethod=...' \
            --data-urlencode 'iamRequestBody=...' \
            --data-urlencode 'iamRequestHeaders=...'
        ```

        <Note>
          Note that you should replace `<identityId>` with the ID of the identity you created in step 1.
        </Note>

        #### Sample response

        ```bash Response theme={"dark"}
        {
            "accessToken": "...",
            "expiresIn": 7200,
            "accessTokenMaxTTL": 43244
            "tokenType": "Bearer"
        }
        ```

        Next, you can use the access token to access the [Infisical API](/api-reference/overview/introduction)
      </Accordion>

      <Accordion title="Sample code for inside an EKS pod">
        The following query construction is an example of how you can authenticate with Infisical from inside an EKS pod.

        The shown example uses Node.js Typescript but you can use any language you wish.

        ```javascript  theme={"dark"}
        import axios from "axios";
        import { Sha256 } from "@aws-crypto/sha256-js";
        import { fromNodeProviderChain } from "@aws-sdk/credential-providers";
        import { HttpRequest } from "@aws-sdk/protocol-http";
        import { SignatureV4 } from "@aws-sdk/signature-v4";

        const main = async () => {
          try {
            const tokenRes = await axios.put<string>("http://169.254.169.254/latest/api/token", undefined, {
              headers: {
                "X-aws-ec2-metadata-token-ttl-seconds": "21600"
              }
            });

            const {
              data: { region }
            } = await axios.get<{ region: string }>("http://169.254.169.254/latest/dynamic/instance-identity/document", {
              headers: {
                "X-aws-ec2-metadata-token": tokenRes.data,
                Accept: "application/json"
              }
            });

            const credentials = await fromNodeProviderChain()();

            if (!credentials.accessKeyId || !credentials.secretAccessKey) {
              throw new Error("Credentials not found");
            }

            const iamRequestURL = `https://sts.${region}.amazonaws.com/`;
            const iamRequestBody = "Action=GetCallerIdentity&Version=2011-06-15";
            const iamRequestHeaders = {
              "Content-Type": "application/x-www-form-urlencoded; charset=utf-8",
              Host: `sts.${region}.amazonaws.com`
            };

            const request = new HttpRequest({
              protocol: "https:",
              hostname: `sts.${region}.amazonaws.com`,
              path: "/",
              method: "POST",
              headers: {
                ...iamRequestHeaders,
                "Content-Length": String(Buffer.byteLength(iamRequestBody))
              },
              body: iamRequestBody
            });

            const signer = new SignatureV4({
              credentials,
              region,
              service: "sts",
              sha256: Sha256
            });

            const signedRequest = await signer.sign(request);

            const headers: Record<string, string> = {};
            Object.entries(signedRequest.headers).forEach(([key, value]) => {
              if (typeof value === "string") headers[key] = value;
            });

            const iamRequest = {
              iamHttpRequestMethod: "POST",
              iamRequestUrl: iamRequestURL,
              iamRequestBody: iamRequestBody,
              iamRequestHeaders: headers
            };

            const {
              data: { accessToken }
            } = await axios.post<{ accessToken: string }>("https://app.infisical.com/api/v1/auth/aws-auth/login", {
              ...iamRequest,
              identityId: "<replace-with-your-identity-id>"
            });

            console.log(`Infisical Access Token: ${accessToken}`);
          } catch (e) {
            console.error("Failed to do AWS auth", e);
          }
        };
        ```
      </Accordion>
    </AccordionGroup>

    <Tip>
      We recommend using one of Infisical's clients like SDKs or the Infisical Agent to authenticate with Infisical using AWS Auth as they handle the authentication process including the signed `GetCallerIdentity` query construction for you.
    </Tip>

    <Note>
      Each identity access token has a time-to-live (TTL) which you can infer from the response of the login operation;
      the default TTL is `7200` seconds which can be adjusted.

      If an identity access token expires, it can no longer authenticate with the Infisical API. In this case,
      a new access token should be obtained by performing another login operation.
    </Note>
  </Step>
</Steps>


# Azure Auth
Source: https://infisical.com/docs/documentation/platform/identities/azure-auth

Learn how to authenticate with Infisical for services on Azure

**Azure Auth** is an Azure-native authentication method for Azure resources like Azure VMs, Azure App Services, Azure Functions, Azure Kubernetes Service, etc. to access Infisical.

## Diagram

The following sequence diagram illustrates the Azure Auth workflow for authenticating Azure [service principals](https://learn.microsoft.com/en-us/entra/identity-platform/app-objects-and-service-principals?tabs=browser) with Infisical.

```mermaid  theme={"dark"}
sequenceDiagram
  participant Client as Client
  participant Infis as Infisical
  participant Azure as Azure AD OpenID

  Note over Client,Azure: Step 1: Instance Identity Token Retrieval
  Client->>Azure: Request managed identity access token
  Azure-->>Client: Return managed identity access token

  Note over Client,Infis: Step 2: Identity Token Login Operation
  Client->>Infis: Send managed identity access token to /api/v1/auth/azure-auth/login
  Infis->>Azure: Request public key
  Azure-->>Infis: Return public key

  Note over Infis: Step 3: Identity Token Verification
  Note over Infis: Step 4: Identity Property Validation
  Infis->>Client: Return short-lived access token

  Note over Client,Infis: Step 4: Access Infisical API with Token
  Client->>Infis: Make authenticated requests using the short-lived access token
```

## Concept

At a high-level, Infisical authenticates an Azure service by verifying its identity and checking that it meets specific requirements (e.g. it is bound to an allowed service principal) at the `/api/v1/auth/azure-auth/login` endpoint. If successful,
then Infisical returns a short-lived access token that can be used to make authenticated requests to the Infisical API.

To be more specific:

1. The client running on an Azure service obtains an [access token](https://learn.microsoft.com/en-us/entra/identity/managed-identities-azure-resources/how-to-use-vm-token#get-a-token-using-http) that is a JWT token representing the managed identity for the Azure resource such as a Virtual Machine; the managed identity is associated with a service principal in Azure AD.
2. The client sends the access token to Infisical.
3. Infisical verifies the token against the corresponding public key at the [public Azure AD OpenID configuration endpoint](https://learn.microsoft.com/en-us/answers/questions/793793/azure-ad-validate-access-token).
4. Infisical checks if the entity behind the access token is allowed to authenticate with Infisical based on set criteria such as **Allowed Service Principal IDs**.
5. If all is well, Infisical returns a short-lived access token that the client can use to make authenticated requests to the Infisical API.

<Note>
  We recommend using one of Infisical's clients like SDKs or the Infisical Agent
  to authenticate with Infisical using Azure Auth as they handle the
  authentication process including generating the client access token for you.

  Also, note that Infisical needs network-level access to send requests to the Google Cloud API
  as part of the Azure Auth workflow.
</Note>

## Guide

In the following steps, we explore how to create and use identities for your applications in Azure to
access the Infisical API using the Azure Auth authentication method.

<Steps>
  <Step title="Creating an identity">
    To create an identity, head to your Organization Settings > Access Control > Identities and press **Create identity**.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-org.png" alt="identities organization" />

    When creating an identity, you specify an organization level [role](/documentation/platform/access-controls/role-based-access-controls) for it to assume; you can configure roles in Organization Settings > Access Control > Organization Roles.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-org-create.png" alt="identities organization create" />

    Now input a few details for your new identity. Here's some guidance for each field:

    * Name (required): A friendly name for the identity.
    * Role (required): A role from the **Organization Roles** tab for the identity to assume. The organization role assigned will determine what organization level resources this identity can have access to.

    Once you've created an identity, you'll be redirected to a page where you can manage the identity.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-page.png" alt="identities page" />

    Since the identity has been configured with Universal Auth by default, you should re-configure it to use Azure Auth instead. To do this, press to edit the **Authentication** section,
    remove the existing Universal Auth configuration, and add a new Azure Auth configuration onto the identity.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-page-remove-default-auth.png" alt="identities page remove default auth" />

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-org-create-azure-auth-method.png" alt="identities create azure auth method" />

    Here's some more guidance on each field:

    * Tenant ID: The [tenant ID](https://learn.microsoft.com/en-us/entra/fundamentals/how-to-find-tenant) for the Azure AD organization.
    * Resource / Audience: The resource URL for the application registered in Azure AD. The value is expected to match the `aud` claim of the access token JWT later used in the login operation against Infisical. See the [resource](https://learn.microsoft.com/en-us/entra/identity/managed-identities-azure-resources/how-to-use-vm-token#get-a-token-using-http) parameter for how the audience is set when requesting a JWT access token from the Azure Instance Metadata Service (IMDS) endpoint. In most cases, this value should be `https://management.azure.com/` which is the default.
    * Allowed Service Principal IDs: A comma-separated list of Azure AD service principal IDs that are allowed to authenticate with Infisical.
    * Access Token TTL (default is `2592000` equivalent to 30 days): The lifetime for an acccess token in seconds. This value will be referenced at renewal time.
    * Access Token Max TTL (default is `2592000`  equivalent to 30 days): The maximum lifetime for an acccess token in seconds. This value will be referenced at renewal time.
    * Access Token Max Number of Uses (default is `0`): The maximum number of times that an access token can be used; a value of `0` implies infinite number of uses.
    * Access Token Trusted IPs: The IPs or CIDR ranges that access tokens can be used from. By default, each token is given the `0.0.0.0/0`, allowing usage from any network address.
  </Step>

  <Step title="Adding an identity to a project">
    To enable the identity to access project-level resources such as secrets within a specific project, you should add it to that project.

    To do this, head over to the project you want to add the identity to and go to Project Settings > Access Control > Machine Identities and press **Add identity**.

    Next, select the identity you want to add to the project and the project level role you want to allow it to assume. The project role assigned will determine what project level resources this identity can have access to.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-project.png" alt="identities project" />

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-project-create.png" alt="identities project create" />
  </Step>

  <Step title="Accessing the Infisical API with the identity">
    To access the Infisical API as the identity, you need to generate a managed identity [access token](https://learn.microsoft.com/en-us/entra/identity/managed-identities-azure-resources/how-to-use-vm-token#get-a-token-using-http) that is a JWT token representing the managed identity for the Azure resource such as a Virtual Machine. The client token must be sent to the `/api/v1/auth/azure-auth/login` endpoint in exchange for a separate access token to access the Infisical API.

    We provide a few code examples below of how you can authenticate with Infisical to access the [Infisical API](/api-reference/overview/introduction).

    <AccordionGroup>
      <Accordion title="Sample code for generating the access token">
        Start by making a request from your Azure client such as Virtual Machine to obtain a managed identity access token.

        For more examples of how to obtain the managed identity access token, refer to the [official documentation](https://learn.microsoft.com/en-us/entra/identity/managed-identities-azure-resources/how-to-use-vm-token#get-a-token-using-http).

        #### Sample request

        ```bash curl theme={"dark"}
        curl 'http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https%3A%2F%2Fmanagement.azure.com%2F' -H Metadata:true -s
        ```

        #### Sample response

        ```bash  theme={"dark"}
        {
            "access_token": "eyJ0eXAi...",
            "refresh_token": "",
            "expires_in": "3599",
            "expires_on": "1506484173",
            "not_before": "1506480273",
            "resource": "https://management.azure.com/",
            "token_type": "Bearer"
        }
        ```

        Next use send the obtained managed identity access token (i.e. the token from the `access_token` field above) to authenticate with Infisical and obtain a separate access token.

        #### Sample request

        ```bash Request theme={"dark"}
        curl --location --request POST 'https://app.infisical.com/api/v1/auth/gcp-auth/login' \
            --header 'Content-Type: application/x-www-form-urlencoded' \
            --data-urlencode 'identityId=...' \
            --data-urlencode 'jwt=...'
        ```

        <Note>
          Note that you should replace `<identityId>` with the ID of the identity you created in step 1.
        </Note>

        #### Sample response

        ```bash Response theme={"dark"}
        {
            "accessToken": "...",
            "expiresIn": 7200,
            "accessTokenMaxTTL": 43244
            "tokenType": "Bearer"
        }
        ```

        Next, you can use this access token to access the [Infisical API](/api-reference/overview/introduction)
      </Accordion>
    </AccordionGroup>

    <Tip>
      We recommend using one of Infisical's clients like SDKs or the Infisical Agent to authenticate with Infisical using Azure Auth as they handle the authentication process including retrieving the client access token.
    </Tip>

    <Note>
      Each identity access token has a time-to-live (TTL) which you can infer from the response of the login operation;
      the default TTL is `7200` seconds which can be adjusted.
      If an identity access token expires, it can no longer authenticate with the Infisical API. In this case,
      a new access token should be obtained by performing another login operation.
    </Note>
  </Step>
</Steps>


# GCP Auth
Source: https://infisical.com/docs/documentation/platform/identities/gcp-auth

Learn how to authenticate with Infisical for services on Google Cloud Platform

**GCP Auth** is a GCP-native authentication method for GCP resources to access Infisical. It consists of two sub-methods/approaches:

* GCP ID Token Auth: For GCP services including [Compute Engine](https://cloud.google.com/compute/docs/instances/verifying-instance-identity#request_signature), [App Engine standard environment](https://cloud.google.com/appengine/docs/standard/python3/runtime#metadata_server), [App Engine flexible environment](https://cloud.google.com/appengine/docs/flexible/python/runtime#metadata_server), [Cloud Functions](https://cloud.google.com/functions/docs/securing/function-identity#using_the_metadata_server_to_acquire_tokens), [Cloud Run](https://cloud.google.com/run/docs/container-contract#metadata-server), [Google Kubernetes Engine](https://cloud.google.com/kubernetes-engine/docs/concepts/workload-identity#instance_metadata), and [Cloud Build](https://cloud.google.com/kubernetes-engine/docs/concepts/workload-identity#instance_metadata) to authenticate with Infisical.
* GCP IAM Auth: For Google Cloud Platform (GCP) service accounts to authenticate with Infisical.

<Tabs>
  <Tab title="Google ID Token Auth">
    ## Diagram

    The following sequence diagram illustrates the GCP ID Token Auth workflow for authenticating GCP resources with Infisical.

    ```mermaid  theme={"dark"}
    sequenceDiagram
      participant GCE as GCP Service
      participant Infis as Infisical
      participant Google as OAuth2 API

      Note over GCE,Google: Step 1: Instance Identity Token Retrieval
      GCE->>Google: Request instance identity metadata token
      Google-->>GCE: Return JWT token with RS256 signature

      Note over GCE,Infis: Step 2: Identity Token Login Operation
      GCE->>Infis: Send JWT token to /api/v1/auth/gcp-auth/login
      Infis->>Google: Request OAuth2 certificates
      Google-->>Infis: Return certificates

      Note over Infis: Step 3: Identity Token Verification
      Note over Infis: Step 4: Identity Property Validation
      Infis->>GCE: Return short-lived access token

      Note over GCE,Infis: Step 4: Access Infisical API with Token
      GCE->>Infis: Make authenticated requests using the short-lived access token
    ```

    ## Concept

    At a high-level, Infisical authenticates a GCP resource by verifying its identity and checking that it meets specific requirements (e.g. it is an allowed GCE instance) at the `/api/v1/auth/gcp-auth/login` endpoint. If successful,
    then Infisical returns a short-lived access token that can be used to make authenticated requests to the Infisical API.

    To be more specific:

    1. The client running on a GCP service obtains an [ID token](https://cloud.google.com/docs/authentication/get-id-token) constituting the identity for a GCP resource such as a GCE instance or Cloud Function; this is a unique JWT token that includes details about the instance as well as Google's [RS256 signature](https://datatracker.ietf.org/doc/html/rfc7518#section-3.3).
    2. The client sends the ID token to Infisical at the `/api/v1/auth/gcp-auth/login` endpoint.
    3. Infisical verifies the token against Google's [public OAuth2 certificates](https://www.googleapis.com/oauth2/v3/certs).
    4. Infisical checks if the entity behind the ID token is allowed to authenticate with Infisical based on set criteria such as **Allowed Service Account Emails**.
    5. If all is well, Infisical returns a short-lived access token that the client can use to make authenticated requests to the Infisical API.

    <Note>
      We recommend using one of Infisical's clients like SDKs or the Infisical Agent
      to authenticate with Infisical using GCP ID Token Auth as they handle the
      authentication process including generating the instance ID token for you.

      Also, note that Infisical needs network-level access to send requests to the Google Cloud API
      as part of the GCP Auth workflow.
    </Note>

    ## Guide

    In the following steps, we explore how to create and use identities for your workloads and applications on GCP to
    access the Infisical API using the GCP ID Token authentication method.

    <Steps>
      <Step title="Creating an identity">
        To create an identity, head to your Organization Settings > Access Control > Identities and press **Create identity**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-org.png" alt="identities organization" />

        When creating an identity, you specify an organization level [role](/documentation/platform/access-controls/role-based-access-controls) for it to assume; you can configure roles in Organization Settings > Access Control > Organization Roles.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-org-create.png" alt="identities organization create" />

        Now input a few details for your new identity. Here's some guidance for each field:

        * Name (required): A friendly name for the identity.
        * Role (required): A role from the **Organization Roles** tab for the identity to assume. The organization role assigned will determine what organization level resources this identity can have access to.

        Once you've created an identity, you'll be redirected to a page where you can manage the identity.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-page.png" alt="identities page" />

        Since the identity has been configured with Universal Auth by default, you should re-configure it to use GCP Auth instead. To do this, press to edit the **Authentication** section,
        remove the existing Universal Auth configuration, and add a new GCP Auth configuration onto the identity; set the **Type** field to **GCP ID Token Auth**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-page-remove-default-auth.png" alt="identities page remove default auth" />

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-org-create-gcp-gce-auth-method.png" alt="identities create gcp auth method" />

        Here's some more guidance on each field:

        * Allowed Service Account Emails: A comma-separated list of trusted service account emails corresponding to the GCE resource(s) allowed to authenticate with Infisical; this could be something like `test@project.iam.gserviceaccount.com`, `12345-compute@developer.gserviceaccount.com`, etc.
        * Allowed Projects: A comma-separated list of trusted GCP projects that the GCE instance must belong to authenticate with Infisical. Note that this validation property will only work for GCE instances.
        * Allowed Zones: A comma-separated list of trusted zones that the GCE instances must belong to authenticate with Infisical; this should be the fully-qualified zone name in the format `<region>-<zone>`like `us-central1-a`, `us-west1-b`, etc. Note that this validation property will only work for GCE instances.
        * Access Token TTL (default is `2592000` equivalent to 30 days): The lifetime for an acccess token in seconds. This value will be referenced at renewal time.
        * Access Token Max TTL (default is `2592000`  equivalent to 30 days): The maximum lifetime for an acccess token in seconds. This value will be referenced at renewal time.
        * Access Token Max Number of Uses (default is `0`): The maximum number of times that an access token can be used; a value of `0` implies infinite number of uses.
        * Access Token Trusted IPs: The IPs or CIDR ranges that access tokens can be used from. By default, each token is given the `0.0.0.0/0`, allowing usage from any network address.
      </Step>

      <Step title="Adding an identity to a project">
        To enable the identity to access project-level resources such as secrets within a specific project, you should add it to that project.

        To do this, head over to the project you want to add the identity to and go to Project Settings > Access Control > Machine Identities and press **Add identity**.

        Next, select the identity you want to add to the project and the project level role you want to allow it to assume. The project role assigned will determine what project level resources this identity can have access to.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-project.png" alt="identities project" />

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-project-create.png" alt="identities project create" />
      </Step>

      <Step title="Accessing the Infisical API with the identity">
        To access the Infisical API as the identity, you need to generate an [ID token](https://cloud.google.com/docs/authentication/get-id-token) constituting the identity of the present GCE instance and make a request to the `/api/v1/auth/gcp-auth/login` endpoint containing the token in exchange for an access token.

        We provide a few code examples below of how you can authenticate with Infisical to access the [Infisical API](/api-reference/overview/introduction).

        <AccordionGroup>
          <Accordion title="Sample code for generating the ID token">
            Start by making a request from the GCE instance to obtain the ID token.
            For more examples of how to obtain the token in Java, Go, Node.js, etc. refer to the [official documentation](https://cloud.google.com/docs/authentication/get-id-token#curl).

            #### Sample request

            <CodeGroup>
              ```bash curl theme={"dark"}
              curl -H "Metadata-Flavor: Google" \
              'http://metadata/computeMetadata/v1/instance/service-accounts/default/identity?audience=<identityId>&format=full'
              ```
            </CodeGroup>

            <Note>
              Note that you should replace `<identityId>` with the ID of the identity you created in step 1.
            </Note>

            Next use send the obtained JWT token along to authenticate with Infisical and obtain an access token.

            #### Sample request

            ```bash Request theme={"dark"}
            curl --location --request POST 'https://app.infisical.com/api/v1/auth/gcp-auth/login' \
                --header 'Content-Type: application/x-www-form-urlencoded' \
                --data-urlencode 'identityId=...' \
                --data-urlencode 'jwt=...'
            ```

            #### Sample response

            ```bash Response theme={"dark"}
            {
                "accessToken": "...",
                "expiresIn": 7200,
                "accessTokenMaxTTL": 43244
                "tokenType": "Bearer"
            }
            ```

            Next, you can use the access token to access the [Infisical API](/api-reference/overview/introduction)
          </Accordion>
        </AccordionGroup>

        <Tip>
          We recommend using one of Infisical's clients like SDKs or the Infisical Agent to authenticate with Infisical using GCP IAM Auth as they handle the authentication process including generating the signed JWT token.
        </Tip>

        <Note>
          Each identity access token has a time-to-live (TTL) which you can infer from the response of the login operation;
          the default TTL is `7200` seconds which can be adjusted.
          If an identity access token expires, it can no longer authenticate with the Infisical API. In this case,
          a new access token should be obtained by performing another login operation.
        </Note>
      </Step>
    </Steps>
  </Tab>

  <Tab title="GCP IAM Auth">
    ## Diagram

    The following sequence diagram illustrates the GCP IAM Auth workflow for authenticating GCP IAM service accounts with Infisical.

    ```mermaid  theme={"dark"}
    sequenceDiagram
      participant GCE as Client
      participant Infis as Infisical
      participant Google as Cloud IAM

      Note over GCE,Google: Step 1: Signed JWT Token Generation
      GCE->>Google: Request to generate signed JWT token
      Google-->>GCE: Return signed JWT token

      Note over GCE,Infis: Step 2: JWT Token Login Operation
      GCE->>Infis: Send signed JWT token to /api/v1/auth/gcp-auth/login
      Infis->>Google: Request public key
      Google-->>Infis: Return public key

      Note over Infis: Step 3: JWT Token Verification
      Note over Infis: Step 4: JWT Property Validation
      Infis->>GCE: Return short-lived access token

      Note over GCE,Infis: Step 5: Access Infisical API with Token
      GCE->>Infis: Make authenticated requests using the short-lived access token
    ```

    ## Concept

    At a high-level, Infisical authenticates an IAM service account by verifying its identity and checking that it meets specific requirements (e.g. it is an allowed service account) at the `/api/v1/auth/gcp-auth/login` endpoint. If successful,
    then Infisical returns a short-lived access token that can be used to make authenticated requests to the Infisical API.

    To be more specific:

    1. The client generates a signed JWT token using the `projects.serviceAccounts.signJwt` [API method](https://cloud.google.com/iam/docs/reference/credentials/rest/v1/projects.serviceAccounts/signJwt); this is done using the service account credentials associated with the client.
    2. The client sends the signed JWT token to Infisical at the `/api/v1/auth/gcp-auth/login` endpoint.
    3. Infisical verifies the signed JWT token.
    4. Infisical checks if the service account behind the JWT token is allowed to authenticate with Infisical based **Allowed Service Account Emails**.
    5. If all is well, Infisical returns a short-lived access token that the client can use to make authenticated requests to the Infisical API.

    <Note>
      We recommend using one of Infisical's clients like SDKs or the Infisical Agent
      to authenticate with Infisical using GCP IAM Auth as they handle the
      authentication process including generating the signed JWT token.

      Also, note that Infisical needs network-level access to send requests to the Google Cloud API
      as part of the GCP Auth workflow.
    </Note>

    ## Guide

    In the following steps, we explore how to create and use identities for your workloads and applications on GCP to
    access the Infisical API using the GCP IAM authentication method.

    <Steps>
      <Step title="Creating an identity">
        To create an identity, head to your Organization Settings > Access Control > Identities and press **Create identity**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-org.png" alt="identities organization" />

        When creating an identity, you specify an organization level [role](/documentation/platform/access-controls/role-based-access-controls) for it to assume; you can configure roles in Organization Settings > Access Control > Organization Roles.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-org-create.png" alt="identities organization create" />

        Now input a few details for your new identity. Here's some guidance for each field:

        * Name (required): A friendly name for the identity.
        * Role (required): A role from the **Organization Roles** tab for the identity to assume. The organization role assigned will determine what organization level resources this identity can have access to.

        Once you've created an identity, you'll be redirected to a page where you can manage the identity.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-page.png" alt="identities page" />

        Since the identity has been configured with Universal Auth by default, you should re-configure it to use GCP Auth instead. To do this, press to edit the **Authentication** section,
        remove the existing Universal Auth configuration, and add a new GCP Auth configuration onto the identity; set the **Type** field to **GCP IAM Auth**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-page-remove-default-auth.png" alt="identities page remove default auth" />

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-org-create-gcp-iam-auth-method.png" alt="identities organization create token auth method" />

        Here's some more guidance on each field:

        * Allowed Service Account Emails: A comma-separated list of trusted IAM service account emails that are allowed to authenticate with Infisical; this could be something like `test@project.iam.gserviceaccount.com`, `12345-compute@developer.gserviceaccount.com`, etc.
        * Access Token TTL (default is `2592000` equivalent to 30 days): The lifetime for an acccess token in seconds. This value will be referenced at renewal time.
        * Access Token Max TTL (default is `2592000`  equivalent to 30 days): The maximum lifetime for an acccess token in seconds. This value will be referenced at renewal time.
        * Access Token Max Number of Uses (default is `0`): The maximum number of times that an access token can be used; a value of `0` implies infinite number of uses.
        * Access Token Trusted IPs: The IPs or CIDR ranges that access tokens can be used from. By default, each token is given the `0.0.0.0/0`, allowing usage from any network address.
      </Step>

      <Step title="Adding an identity to a project">
        To enable the identity to access project-level resources such as secrets within a specific project, you should add it to that project.

        To do this, head over to the project you want to add the identity to and go to Project Settings > Access Control > Machine Identities and press **Add identity**.

        Next, select the identity you want to add to the project and the project level role you want to allow it to assume. The project role assigned will determine what project level resources this identity can have access to.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-project.png" alt="identities project" />

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-project-create.png" alt="identities project create" />
      </Step>

      <Step title="Accessing the Infisical API with the identity">
        To access the Infisical API as the identity, you need to generate a signed JWT token using the `projects.serviceAccounts.signJwt` [API method](https://cloud.google.com/iam/docs/reference/credentials/rest/v1/projects.serviceAccounts/signJwt) and make a request to the `/api/v1/auth/gcp-auth/login` endpoint containing the signed JWT token in exchange for an access token.

        <Info>
          Make sure that the service account has the `iam.serviceAccounts.signJwt` permission or the `roles/iam.serviceAccountTokenCreator` role.
        </Info>

        We provide a few code examples below of how you can authenticate with Infisical to access the [Infisical API](/api-reference/overview/introduction).

        <AccordionGroup>
          <Accordion title="Sample code for generating a signed JWT token">
            The following code provides a generic example of how you can generate a signed JWT token against the `projects.serviceAccounts.signJwt` API method.

            The shown example uses Node.js and the official [google-auth-library](https://github.com/googleapis/google-auth-library-nodejs#readme) package but you can use any language you wish.

            ```javascript  theme={"dark"}
            const { GoogleAuth } = require("google-auth-library");

            const auth = new GoogleAuth({
                scopes: "https://www.googleapis.com/auth/cloud-platform",
            });

            const credentials = await auth.getCredentials();

            const identityId = "<your-infisical-identity-id>";

            const jwtPayload = {
                sub: credentials.client_email,
                aud: identityId,
            };

            const { data } = await client.request({
                url: `https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/${credentials.client_email}:signJwt`,
                method: "POST",
                data: { payload: JSON.stringify(jwtPayload) },
            });

            const jwt = data.signedJwt // send this jwt to Infisical in the next step
            ```

            #### Sample request

            ```bash Request theme={"dark"}
            curl --location --request POST 'https://app.infisical.com/api/v1/auth/gcp-auth/login' \
                --header 'Content-Type: application/x-www-form-urlencoded' \
                --data-urlencode 'identityId=...' \
                --data-urlencode 'jwt=...'
            ```

            #### Sample response

            ```bash Response theme={"dark"}
            {
                "accessToken": "...",
                "expiresIn": 7200,
                "accessTokenMaxTTL": 43244
                "tokenType": "Bearer"
            }
            ```

            Next, you can use the access token to access the [Infisical API](/api-reference/overview/introduction)
          </Accordion>
        </AccordionGroup>

        <Tip>
          We recommend using one of Infisical's clients like SDKs or the Infisical Agent to authenticate with Infisical using GCP IAM Auth as they handle the authentication process including generating the signed JWT token.
        </Tip>

        <Note>
          Each identity access token has a time-to-live (TTL) which you can infer from the response of the login operation;
          the default TTL is `7200` seconds which can be adjusted.
          If an identity access token expires, it can no longer authenticate with the Infisical API. In this case,
          a new access token should be obtained by performing another login operation.
        </Note>
      </Step>
    </Steps>
  </Tab>
</Tabs>


# JWT Auth
Source: https://infisical.com/docs/documentation/platform/identities/jwt-auth

Learn how to authenticate with Infisical using JWT-based authentication.

**JWT Auth** is a platform-agnostic authentication method that validates JSON Web Tokens (JWTs) issued by your JWT issuer or authentication system, allowing secure authentication from any platform or environment that can obtain valid JWTs.

## Diagram

The following sequence diagram illustrates the JWT Auth workflow for authenticating with Infisical.

```mermaid  theme={"dark"}
sequenceDiagram
    participant Client as Client Application
    participant Issuer as JWT Issuer
    participant Infis as Infisical

    Client->>Issuer: Step 1: Request JWT token
    Issuer-->>Client: Return signed JWT with claims

    Note over Client,Infis: Step 2: Login Operation
    Client->>Infis: Send signed JWT to /api/v1/auth/jwt-auth/login

    Note over Infis: Step 3: JWT Validation
    Infis->>Infis: Validate JWT signature using configured public keys or JWKS
    Infis->>Infis: Verify required claims (aud, sub, iss)

    Note over Infis: Step 4: Token Generation
    Infis->>Client: Return short-lived access token

    Note over Client,Infis: Step 5: Access Infisical API with Token
    Client->>Infis: Make authenticated requests using the short-lived access token
```

## Concept

At a high-level, Infisical authenticates a client by verifying the JWT and checking that it meets specific requirements (e.g. it is signed by a trusted key) at the `/api/v1/auth/jwt-auth/login` endpoint. If successful, then Infisical returns a short-lived access token that can be used to make authenticated requests to the Infisical API.

To be more specific:

1. The client requests a JWT from their JWT issuer.
2. The fetched JWT is sent to Infisical at the `/api/v1/auth/jwt-auth/login` endpoint.
3. Infisical validates the JWT signature using either:
   * Pre-configured public keys (Static configuration)
   * Public keys fetched from a JWKS endpoint (JWKS configuration)
4. Infisical verifies that the configured claims match in the token. This includes standard claims like subject, audience, and issuer, as well as any additional custom claims specified in the configuration.
5. If all is well, Infisical returns a short-lived access token that the client can use to make authenticated requests to the Infisical API.

<Note>
  For JWKS configuration, Infisical needs network-level access to the configured
  JWKS endpoint.
</Note>

## Guide

In the following steps, we explore how to create and use identities to access the Infisical API using the JWT authentication method.

<Steps>
  <Step title="Creating an identity">
    To create an identity, head to your Organization Settings > Access Control > Identities and press **Create identity**.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-org.png" alt="identities organization" />

    When creating an identity, you specify an organization level [role](/documentation/platform/access-controls/role-based-access-controls) for it to assume; you can configure roles in Organization Settings > Access Control > Organization Roles.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-org-create.png" alt="identities organization create" />

    Now input a few details for your new identity. Here's some guidance for each field:

    * Name (required): A friendly name for the identity.
    * Role (required): A role from the **Organization Roles** tab for the identity to assume. The organization role assigned will determine what organization level resources this identity can have access to.

    Once you've created an identity, you'll be redirected to a page where you can manage the identity.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-page.png" alt="identities page" />

    Since the identity has been configured with Universal Auth by default, you should re-configure it to use JWT Auth instead. To do this, press to edit the **Authentication** section,
    remove the existing Universal Auth configuration, and add a new JWT Auth configuration onto the identity.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-page-remove-default-auth.png" alt="identities page remove default auth" />

    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-org-create-jwt-auth-method-jwks.png" alt="identities create jwt auth method" />
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-org-create-jwt-auth-method-static.png" alt="identities create jwt auth method" />

    <Warning>Restrict access by properly configuring the JWT validation settings.</Warning>

    Here's some more guidance for each field:

    **Static configuration**:

    * Public Keys: One or more PEM-encoded public keys (RSA or ECDSA) used to verify JWT signatures. Each key must include the proper BEGIN/END markers.

    **JWKS configuration**:

    * JWKS URL: The endpoint URL that serves your JSON Web Key Sets (JWKS). This endpoint must provide the public keys used for JWT signature verification.
    * JWKS CA Certificate: Optional PEM-encoded CA certificate used for validating the TLS connection to the JWKS endpoint.

    **Common fields for both configurations**:

    * Issuer: The unique identifier of the JWT provider. This value is used to verify the iss (issuer) claim in the JWT.
    * Audiences: A list of intended recipients. This value is checked against the aud (audience) claim in the token.
    * Subject: The expected principal that is the subject of the JWT. This value is checked against the sub (subject) claim in the token.
    * Claims: Additional claims that must be present in the JWT for it to be valid. You can specify required claim names and their expected values.
    * Access Token TTL (default is `2592000` equivalent to 30 days): The lifetime for an access token in seconds. This value will be referenced at renewal time.
    * Access Token Max TTL (default is `2592000` equivalent to 30 days): The maximum lifetime for an access token in seconds. This value will be referenced at renewal time.
    * Access Token Max Number of Uses (default is `0`): The maximum number of times that an access token can be used; a value of `0` implies infinite number of uses.
    * Access Token Trusted IPs: The IPs or CIDR ranges that access tokens can be used from. By default, each token is given the `0.0.0.0/0`, allowing usage from any network address.

    <Info>The `subject`, `audiences`, and `claims` fields support glob pattern matching; however, we highly recommend using hardcoded values whenever possible.</Info>
  </Step>

  <Step title="Adding an identity to a project">
    To enable the identity to access project-level resources such as secrets within a specific project, you should add it to that project.

    To do this, head over to the project you want to add the identity to and go to Project Settings > Access Control > Machine Identities and press **Add identity**.

    Next, select the identity you want to add to the project and the project level role you want to allow it to assume. The project role assigned will determine what project level resources this identity can have access to.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-project.png" alt="identities project" />

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-project-create.png" alt="identities project create" />
  </Step>

  <Step title="Accessing the Infisical API with the identity">
    To access the Infisical API as the identity, you will need to obtain a JWT from your JWT issuer that meets the validation requirements configured in step 2.

    Once you have obtained a valid JWT, you can use it to authenticate with Infisical at the `/api/v1/auth/jwt-auth/login` endpoint.

    We provide a code example below of how you might use the JWT to authenticate with Infisical to gain access to the [Infisical API](/api-reference/overview/introduction).

    <Accordion title="Sample code for inside an application">
      The shown example uses Node.js but you can use any other language to authenticate with Infisical using your JWT.

      ```javascript  theme={"dark"}
      try {
          // Obtain JWT from your issuer
          const jwt = "<your-jwt-token>";

          const infisicalUrl = "https://app.infisical.com"; // or your self-hosted Infisical URL
          const identityId = "<your-identity-id>";

          const { data } = await axios.post(
              `{infisicalUrl}/api/v1/auth/jwt-auth/login`,
              {
                  identityId,
                  jwt,
              }
          );

          console.log("result data: ", data); // access token here
      } catch(err) {
          console.error(err);
      }
      ```
    </Accordion>

    <Tip>
      We recommend using one of Infisical's clients like SDKs or the Infisical Agent to authenticate with Infisical using JWT Auth as they handle the authentication process for you.
    </Tip>

    <Note>
      Each identity access token has a time-to-live (TTL) which you can infer from the response of the login operation;
      the default TTL is `2592000` seconds (30 days) which can be adjusted in the configuration.

      If an identity access token exceeds its max TTL or maximum number of uses, it can no longer authenticate with the Infisical API. In this case,
      a new access token should be obtained by performing another login operation with a valid JWT.
    </Note>
  </Step>
</Steps>


# Kubernetes Auth
Source: https://infisical.com/docs/documentation/platform/identities/kubernetes-auth

Learn how to authenticate with Infisical in Kubernetes

**Kubernetes Auth** is a Kubernetes-native authentication method for applications (e.g. pods) to access Infisical.

## Diagram

The following sequence diagram illustrates the Kubernetes Auth workflow for authenticating applications running in pods with Infisical.

```mermaid  theme={"dark"}
sequenceDiagram
  participant Pod as Pod
  participant Infis as Infisical
  participant KubernetesServer as K8s API Server

  Note over Pod: Step 1: Service Account JWT Token Retrieval

  Note over Pod,Infis: Step 2: JWT Token Login Operation
  Pod->>Infis: Send JWT token to /api/v1/auth/kubernetes-auth/login
  Infis->>KubernetesServer: Forward JWT token for validation
    KubernetesServer-->>Infis: Return identity info for JWT

  Note over Infis: Step 3: Identity Property Verification
  Infis->>Pod: Return short-lived access token

  Note over Pod,Infis: Step 4: Access Infisical API with Token
  Pod->>Infis: Make authenticated requests using the short-lived access token
```

## Concept

At a high-level, Infisical authenticates an application in Kubernetes by verifying its identity and checking that it meets specific requirements (e.g. it is bound to an allowed service account) at the `/api/v1/auth/kubernetes-auth/login` endpoint. If successful,
then Infisical returns a short-lived access token that can be used to make authenticated requests to the Infisical API.

To be more specific:

1. The application deployed on Kubernetes retrieves its [service account credential](https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#opt-out-of-api-credential-automounting) that is a JWT token at the `/var/run/secrets/kubernetes.io/serviceaccount/token` pod path.
2. The application sends the JWT token to Infisical at the `/api/v1/auth/kubernetes-auth/login` endpoint after which Infisical forwards the JWT token to the Kubernetes API Server at the TokenReview API for verification and to obtain the service account information associated with the JWT token.
   Infisical is able to authenticate and interact with the TokenReview API by using either the long lived JWT token set while configuring this authentication method or by using the incoming token itself. The JWT token mentioned in this context is referred as the token reviewer JWT token.
3. Infisical checks the service account properties against set criteria such **Allowed Service Account Names** and **Allowed Namespaces**.
4. If all is well, Infisical returns a short-lived access token that the application can use to make authenticated requests to the Infisical API.

<Note>
  We recommend using one of Infisical's clients like SDKs or the Infisical Agent
  to authenticate with Infisical using Kubernetes Auth as they handle the
  authentication process including service account credential retrieval for you.
</Note>

## Guide

In the following steps, we explore how to create and use identities for your applications in Kubernetes to access the Infisical API using the Kubernetes Auth authentication method.

<Steps>
  <Step title="Obtaining the token reviewer JWT for Infisical">
    <Accordion title="Option 1: Reviewer JWT Token">
      <Note>
        **When to use this option**: Choose this approach when you want centralized authentication management. Only one service account needs special permissions, and your application service accounts remain unchanged.
      </Note>

      1.1. Start by creating a service account in your Kubernetes cluster that will be used by Infisical to authenticate with the Kubernetes API Server.

      ```yaml infisical-service-account.yaml theme={"dark"}
      apiVersion: v1
      kind: ServiceAccount
      metadata:
        name: infisical-auth
        namespace: default
      ```

      ```
      kubectl apply -f infisical-service-account.yaml
      ```

      1.2. Bind the service account to the `system:auth-delegator` cluster role. As described [here](https://kubernetes.io/docs/reference/access-authn-authz/rbac/#other-component-roles), this role allows delegated authentication and authorization checks, specifically for Infisical to access the [TokenReview API](https://kubernetes.io/docs/reference/kubernetes-api/authentication-resources/token-review-v1/). You can apply the following configuration file:

      ```yaml cluster-role-binding.yaml theme={"dark"}
      apiVersion: rbac.authorization.k8s.io/v1
      kind: ClusterRoleBinding
      metadata:
        name: role-tokenreview-binding
        namespace: default
      roleRef:
        apiGroup: rbac.authorization.k8s.io
        kind: ClusterRole
        name: system:auth-delegator
      subjects:
        - kind: ServiceAccount
          name: infisical-auth
          namespace: default
      ```

      ```
      kubectl apply -f cluster-role-binding.yaml
      ```

      1.3. Next, create a long-lived service account JWT token (i.e. the token reviewer JWT token) for the service account using this configuration file for a new `Secret` resource:

      ```yaml service-account-token.yaml theme={"dark"}
      apiVersion: v1
      kind: Secret
      type: kubernetes.io/service-account-token
      metadata:
        name: infisical-auth-token
        annotations:
          kubernetes.io/service-account.name: "infisical-auth"
      ```

      ```
      kubectl apply -f service-account-token.yaml
      ```

      1.4. Link the secret in step 1.3 to the service account in step 1.1:

      ```bash  theme={"dark"}
      kubectl patch serviceaccount infisical-auth -p '{"secrets": [{"name": "infisical-auth-token"}]}' -n default
      ```

      1.5. Finally, retrieve the token reviewer JWT token from the secret.

      ```bash  theme={"dark"}
      kubectl get secret infisical-auth-token -n default -o=jsonpath='{.data.token}' | base64 --decode
      ```

      Keep this JWT token handy as you will need it for the **Token Reviewer JWT** field when configuring the Kubernetes Auth authentication method for the identity in step 2.
    </Accordion>

    <Accordion title="Option 2: Client JWT as Reviewer JWT Token">
      <Note>
        **When to use this option**: Choose this approach to eliminate long-lived tokens. This option simplifies Infisical configuration but requires each application service account to have elevated permissions.
      </Note>

      The self-validation method eliminates the need for a separate long-lived reviewer JWT by using the same token for both authentication and validation. Instead of creating a dedicated reviewer service account, you'll grant the necessary permissions to each application service account.

      For each service account that needs to authenticate with Infisical, add the `system:auth-delegator` role:

      ```yaml client-role-binding.yaml theme={"dark"}
      apiVersion: rbac.authorization.k8s.io/v1
      kind: ClusterRoleBinding
      metadata:
        name: infisical-client-binding-[your-app-name]
      roleRef:
        apiGroup: rbac.authorization.k8s.io
        kind: ClusterRole
        name: system:auth-delegator
      subjects:
        - kind: ServiceAccount
          name: [your-app-service-account]
          namespace: [your-app-namespace]
      ```

      ```
      kubectl apply -f client-role-binding.yaml
      ```

      When configuring Kubernetes Auth in Infisical, leave the **Token Reviewer JWT** field empty. Infisical will use the client's own token for validation.
    </Accordion>

    <Accordion title="Option 3: Use Gateway as Reviewer">
      <Note>
        **When to use this option**: Choose this approach when you have a gateway deployed in your Kubernetes Cluster and wish to eliminate long-lived tokens. This approach simplifies Infisical Kubernetes Auth configuration, and only one service account will need to have the elevated `system:auth-delegator` ClusterRole binding.
      </Note>

      <Info>
        **Note:** Gateway is a paid feature. - **Infisical Cloud users:** Gateway is
        available under the **Enterprise Tier**. - **Self-Hosted Infisical:** Please
        contact [sales@infisical.com](mailto:sales@infisical.com) to purchase an
        enterprise license.
      </Info>

      <Steps>
        <Step title="Deploying a gateway">
          To deploy a gateway in your Kubernetes cluster, follow our [Gateway deployment guide using helm](/documentation/platform/gateways/overview).
        </Step>

        <Step title="Grant the gateway the system:auth-delegator ClusterRole binding">
          To grant the gateway the `system:auth-delegator` ClusterRole binding, you can use the following command:

          ```yaml gateway-role-binding.yaml theme={"dark"}
          apiVersion: rbac.authorization.k8s.io/v1
          kind: ClusterRoleBinding
          metadata:
            name: infisical-token-reviewer-role-binding
            namespace: default # Replace with your namespace if not default
          roleRef:
            apiGroup: rbac.authorization.k8s.io
            kind: ClusterRole
            name: system:auth-delegator
          subjects:
            - kind: ServiceAccount
              name: infisical-gateway # The name of the gateway service account
              namespace: default # Replace with your namespace if not default
          ```

          ```bash  theme={"dark"}
          kubectl apply -f gateway-role-binding.yaml
          ```

          <Tip>
            The gateway service account name is `infisical-gateway` by default if deployed using Helm.
          </Tip>
        </Step>

        <Step title="Configure the Kubernetes Auth authentication method for the identity">
          To configure your Kubernetes Auth method to use the gateway as the token reviewer, set the `Review Method` to "Gateway as Reviewer", and select the gateway you want to use as the token reviewer.

                    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-kubernetes-auth-gateway-as-reviewer.png" alt="identities organization create kubernetes auth method" />
        </Step>
      </Steps>
    </Accordion>
  </Step>

  <Step title="Creating an identity">
    To create an identity, head to your Organization Settings > Access Control > Identities and press **Create identity**.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-org.png" alt="identities organization" />

    When creating an identity, you specify an organization level [role](/documentation/platform/access-controls/role-based-access-controls) for it to assume; you can configure roles in Organization Settings > Access Control > Organization Roles.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-org-create.png" alt="identities organization create" />

    Now input a few details for your new identity. Here's some guidance for each field:

    * Name (required): A friendly name for the identity.
    * Role (required): A role from the **Organization Roles** tab for the identity to assume. The organization role assigned will determine what organization level resources this identity can have access to.

    Once you've created an identity, you'll be redirected to a page where you can manage the identity.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-page.png" alt="identities page" />

    Since the identity has been configured with Universal Auth by default, you should re-configure it to use Kubernetes Auth instead. To do this, press to edit the **Authentication** section,
    remove the existing Universal Auth configuration, and add a new Kubernetes Auth configuration onto the identity.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-page-remove-default-auth.png" alt="identities page remove default auth" />

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-org-create-kubernetes-auth-method.png" alt="identities organization create kubernetes auth method" />

    Here's some more guidance on each field:

    * Kubernetes Host / Base Kubernetes API URL: The host string, host:port pair, or URL to the base of the Kubernetes API server. This can usually be obtained by running `kubectl cluster-info`.
    * Token Reviewer JWT: A long-lived service account JWT token for Infisical to access the [TokenReview API](https://kubernetes.io/docs/reference/kubernetes-api/authentication-resources/token-review-v1/) to validate other service account JWT tokens submitted by applications/pods. This is the JWT token obtained from step 1.5(Reviewer Tab). If omitted, the client's own JWT will be used instead, which requires the client to have the `system:auth-delegator` ClusterRole binding.
      This is shown in step 1, option 2.
    * Allowed Service Account Names: A comma-separated list of trusted service account names that are allowed to authenticate with Infisical.
    * Allowed Namespaces: A comma-separated list of trusted namespaces that service accounts must belong to authenticate with Infisical.
    * Allowed Audience: An optional audience claim that the service account JWT token must have to authenticate with Infisical.
    * CA Certificate: The PEM-encoded CA cert for the Kubernetes API server. This is used by the TLS client for secure communication with the Kubernetes API server.
    * Access Token TTL (default is `2592000` equivalent to 30 days): The lifetime for an acccess token in seconds. This value will be referenced at renewal time.
    * Access Token Max TTL (default is `2592000`  equivalent to 30 days): The maximum lifetime for an acccess token in seconds. This value will be referenced at renewal time.
    * Access Token Max Number of Uses (default is `0`): The maximum number of times that an access token can be used; a value of `0` implies infinite number of uses.
    * Access Token Trusted IPs: The IPs or CIDR ranges that access tokens can be used from. By default, each token is given the `0.0.0.0/0`, allowing usage from any network address.
  </Step>

  <Step title="Adding an identity to a project">
    To enable the identity to access project-level resources such as secrets within a specific project, you should add it to that project.

    To do this, head over to the project you want to add the identity to and go to Project Settings > Access Control > Machine Identities and press **Add identity**.

    Next, select the identity you want to add to the project and the project level role you want to allow it to assume. The project role assigned will determine what project level resources this identity can have access to.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-project.png" alt="identities project" />

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-project-create.png" alt="identities project create" />
  </Step>

  <Step title="Accessing the Infisical API with the identity">
    To access the Infisical API as the identity, you should first make sure that the pod running your application is bound to a service account specified in the **Allowed Service Account Names** field of the identity's Kubernetes Auth authentication method configuration in step 2.

    Once bound, the pod will receive automatically mounted service account credentials that is a JWT token at the `/var/run/secrets/kubernetes.io/serviceaccount/token` path. This token should be used to authenticate with Infisical at the `/api/v1/auth/kubernetes-auth/login` endpoint.

    For information on how to configure sevice accounts for pods, refer to the guide [here](https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/).

    We provide a code example below of how you might retrieve the JWT token and use it to authenticate with Infisical to gain access to the [Infisical API](/api-reference/overview/introduction).

    <Accordion title="Sample code for inside an application">
      The shown example uses Node.js but you can use any other language to retrieve the service account JWT token and use it to authenticate with Infisical.

      ```javascript  theme={"dark"}
      const fs = require("fs");
      try {
          const tokenPath = "/var/run/secrets/kubernetes.io/serviceaccount/token";
          const jwtToken = fs.readFileSync(tokenPath, "utf8");

          const infisicalUrl = "https://app.infisical.com"; // or your self-hosted Infisical URL
          const identityId = "<your-identity-id>";

          const { data } = await axios.post(
              `{infisicalUrl}/api/v1/auth/kubernetes-auth/login`,
              {
                  identityId,
                  jwt,
              }
          );

          console.log("result data: ", data); // access token here
      } catch(err) {
          console.error(err);
      }
      ```
    </Accordion>

    <Tip>
      We recommend using one of Infisical's clients like SDKs or the Infisical Agent to authenticate with Infisical using Kubernetes Auth as they handle the authentication process including service account credential retrieval for you.
    </Tip>

    <Note>
      Each identity access token has a time-to-live (TTL) which you can infer from the response of the login operation;
      the default TTL is `7200` seconds which can be adjusted.

      If an identity access token exceeds its max ttl, it can no longer authenticate with the Infisical API. In this case,
      a new access token should be obtained by performing another login operation.
    </Note>
  </Step>
</Steps>

**FAQ**

<AccordionGroup>
  <Accordion title="Why is the Infisical API rejecting my service account JWT token?">
    There are a few reasons for why this might happen:

    * The Kubernetes Auth authentication method configuration is invalid.
    * The service account JWT token has expired is malformed or invalid.
    * The service account associated with the JWT token does not meet the criteria set forth in the Kubernetes Auth authentication method configuration such as **Allowed Service Account Names** and **Allowed Namespaces**.
  </Accordion>

  <Accordion title="Why is the Infisical API rejecting my access token?">
    There are a few reasons for why this might happen:

    * The access token has expired.
    * The identity is insufficiently permissioned to interact with the resources you wish to access.
    * The client access token is being used from an untrusted IP.
  </Accordion>

  <Accordion title="What is access token renewal and TTL/Max TTL?">
    A identity access token can have a time-to-live (TTL) or incremental lifetime after which it expires.

    In certain cases, you may want to extend the lifespan of an access token; to do so, you must set a max TTL parameter.

    A token can be renewed any number of times where each call to renew it can extend the token's lifetime by increments of the access token's TTL.
    Regardless of how frequently an access token is renewed, its lifespan remains bound to the maximum TTL determined at its creation.
  </Accordion>
</AccordionGroup>


# General
Source: https://infisical.com/docs/documentation/platform/identities/ldap-auth/general

Learn how to authenticate with Infisical using LDAP.

**LDAP Auth** is an LDAP based authentication method that allows you to authenticate with Infisical using a machine identity configured with an [LDAP](https://en.wikipedia.org/wiki/Lightweight_Directory_Access_Protocol) directory.

## Templates

You can create reusable LDAP authentication templates to standardize configurations across multiple machine identities. Templates help ensure consistency, reduce configuration errors, and simplify identity management at scale.

To create and manage LDAP auth templates, see our [Machine Identity Auth Templates documentation](/documentation/platform/identities/auth-templates). Once you've created a template, you can apply it when configuring LDAP auth for your identities in the guide below.

## Guide

<Steps>
  <Step title="Creating an identity">
    To create an identity, head to your Organization Settings > Access Control > Identities and press **Create identity**.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/ldap/identities-org-create-identity.png" alt="Create identity" />

    When creating an identity, you specify an organization level role for it to assume; you can configure roles in Organization Settings > Access Control > Organization Roles.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/ldap/identities-org-create-identity-modal.png" alt="Create identity modal" />

    Now input a few details for your new identity. Here's some guidance for each field:

    * Name (required): A friendly name for the identity.
    * Role (required): A role from the Organization Roles tab for the identity to assume. The organization role assigned will determine what organization level resources this identity can have access to.

    Once you've created an identity, you'll be redirected to a page where you can manage the identity.
  </Step>

  <Step title="Configuring LDAP auth for your identity">
    To configure LDAP auth for your identity, press the **Add Auth Method** button on the identity's page.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/ldap/identities-org-add-auth-method.png" alt="Add auth method" />

    Now select **LDAP Auth** from the list of available auth methods for the identity.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/ldap/identities-org-add-auth-method-modal.png" alt="Select LDAP auth" />

    After selecting **LDAP Auth**, you'll see the form you need to fill out to configure LDAP auth for your identity. The following fields are available:

    **Configuration Tab**

    * `URL`: The LDAP server to connect to such as `ldap://ldap.your-org.com`, `ldaps://ldap.myorg.com:636` *(for connection over SSL/TLS)*, etc.
    * `Bind DN`: The DN to bind to the LDAP server with.
    * `Bind Pass`: The password to bind to the LDAP server with.
    * `Search Base / DN`: Base DN under which to perform user search such as `ou=Users,dc=acme,dc=com`.
    * `User Search Filter`: Template used to construct the LDAP user search filter such as `(uid={{username}})`; use literal `{{username}}` to have the given username used in the search. The default is `(uid={{username}})` which is compatible with several common directory schemas.
    * `Required Attributes`: A key/value pair of attributes that must be present in the LDAP user entry for them to be authenticated. As an example, if you set key `uid` to value `user1,user2,user3`, then only users with `uid` of `user1`, `user2`, or `user3` will be able to login with this identity. Each value is a comma separated list of attributes.
    * `Access Token TTL` *(default is 2592000 equivalent to 30 days)*: The lifetime for an access token in seconds. This value will be referenced at renewal time.
    * `Access Token Max TTL` *(default is 2592000 equivalent to 30 days)*: The maximum lifetime for an access token in seconds. This value will be referenced at renewal time.
    * `Access Token Max Number of Uses` *(default is 0)*: The maximum number of times that an access token can be used; a value of 0 implies infinite number of uses.

    **Lockout Tab**

    * `Lockout` *(enabled by default)*: The lockout feature will temporarily block login attempts after X consecutive login failures.
    * `Lockout Threshold` *(default is 3)*: The amount of times login must fail before locking the identity auth method.
    * `Lockout Duration` *(default is 5 minutes)*: How long an identity auth method lockout lasts.
    * `Lockout Counter Reset` *(default is 30 seconds)*: How long to wait from the most recent failed login until resetting the lockout counter.

    **Advanced Tab**

    * `CA Certificate`: The CA certificate to use when verifying the LDAP server certificate. This field is optional but recommended.
    * `Access Token Trusted IPs`: The IPs or CIDR ranges that access tokens can be used from. By default, each token is given the 0.0.0.0/0, allowing usage from any network address.

    Once you've filled out the form, press **Add** to save your changes.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/ldap/identities-org-configure-ldap.png" alt="Configure LDAP auth" />

    <Step title="Authenticating with the identity">
      After configuring LDAP auth for your identity, you can authenticate with the identity and obtain an access token using your LDAP credentials.

      ```bash  theme={"dark"}
        curl --request POST \
          --url https://app.infisical.com/api/v1/auth/ldap-auth/login \
          --header 'Content-Type: application/json' \
          --data '{
          "identityId": "<string>",
          "username": "<string>",
          "password": "<string>"
        }'
      ```

      <Note>
        For EU Cloud and Self-Hosted users, make sure to replace `https://app.infisical.com` with `https://eu.infisical.com` or your self-hosted instance's URL in the request URL.
      </Note>

      If successful, you'll receive an access token in the response body.

      ```json  theme={"dark"}
      {
        "accessToken": "your-access-token",
        "expiresIn": 2592000,
        "accessTokenMaxTTL": 2592000,
        "tokenType": "Bearer"
      }
      ```

      You can read more about the login API endpoint [here](/api-reference/endpoints/ldap-auth/login).
    </Step>
  </Step>
</Steps>

**FAQ**

<AccordionGroup>
  <Accordion title="How do I reset a lockout?">
    You can reset (remove) all lockouts for an identity auth method by clicking into the auth method and pressing **Reset All Lockouts**.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/ldap-reset-lockouts.png" alt="ldap reset lockouts" />
  </Accordion>
</AccordionGroup>


# JumpCloud
Source: https://infisical.com/docs/documentation/platform/identities/ldap-auth/jumpcloud

Learn how to authenticate with Infisical using LDAP with JumpCloud.

**LDAP Auth** is an LDAP based authentication method that allows you to authenticate with Infisical using a machine identity configured with an [LDAP](https://en.wikipedia.org/wiki/Lightweight_Directory_Access_Protocol) directory.

## Guide

<Steps>
  <Step title="Prepare LDAP in JumpCloud">
    In JumpCloud, head to USER MANAGEMENT > Users and create a new user via the Manual user entry option.
    This user will be used as a privileged service account to facilitate Infisical's ability to bind/search the LDAP directory.

    Next after creating the user, under User Security Settings and Permissions > Permission Settings, check the box next to Enable as LDAP Bind DN.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/ldap/jumpcloud-users-management.png" alt="User management" />
  </Step>

  <Step title="Creating an identity">
    To create an identity, head to your Organization Settings > Access Control > Identities and press **Create identity**.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/ldap/identities-org-create-identity.png" alt="Create identity" />

    When creating an identity, you specify an organization level role for it to assume; you can configure roles in Organization Settings > Access Control > Organization Roles.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/ldap/identities-org-create-identity-modal.png" alt="Create identity modal" />

    Now input a few details for your new identity. Here's some guidance for each field:

    * Name (required): A friendly name for the identity.
    * Role (required): A role from the Organization Roles tab for the identity to assume. The organization role assigned will determine what organization level resources this identity can have access to.

    Once you've created an identity, you'll be redirected to a page where you can manage the identity.
  </Step>

  <Step title="Configuring LDAP auth for your identity">
    To configure LDAP auth for your identity, press the **Add Auth Method** button on the identity's page.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/ldap/identities-org-add-auth-method.png" alt="Add auth method" />

    Now select **LDAP Auth** from the list of available auth methods for the identity.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/ldap/identities-org-add-auth-method-modal.png" alt="Select LDAP auth" />

    After selecting **LDAP Auth**, you'll see the form you need to fill out to configure LDAP auth for your identity. The following fields are available:

    * `URL`: The LDAP server to connect to (`ldaps://ldap.jumpcloud.com:636`).
    * `Bind DN`: The distinguished name of object to bind when performing the user search (`uid=<ldap-user-username>,ou=Users,o=<your-org-id>,dc=jumpcloud,dc=com`).
    * `Bind Pass`: The password to use along with Bind DN when performing the user search. This is the password for the user created in the previous step.
    * `Search Base / DN`: Base DN under which to perform user search (`ou=Users,o=<your-org-id>,dc=jumpcloud,dc=com`).
    * `User Search Filter`: Template used to construct the LDAP user search filter (`(uid={{username}})`).
    * `Required Attributes`: A key/value pair of attributes that must be present in the LDAP user entry for them to be authenticated. As an example, if you set key `uid` to value `user1,user2,user3`, then only users with `uid` of `user1`, `user2`, or `user3` will be able to login with this identity. Each value is a comma separated list of attributes.
    * `CA Certificate`: The CA certificate to use when verifying the LDAP server certificate (instructions to obtain the certificate for JumpCloud [here](https://jumpcloud.com/support/connect-to-ldap-with-tls-ssl)).
    * `Access Token TTL` *(default is 2592000 equivalent to 30 days)*: The lifetime for an access token in seconds. This value will be referenced at renewal time.
    * `Access Token Max TTL` *(default is 2592000 equivalent to 30 days)*: The maximum lifetime for an access token in seconds. This value will be referenced at renewal time.
    * `Access Token Max Number of Uses` *(default is 0)*: The maximum number of times that an access token can be used; a value of 0 implies infinite number of uses.
    * `Access Token Trusted IPs`: The IPs or CIDR ranges that access tokens can be used from. By default, each token is given the 0.0.0.0/0, allowing usage from any network address.

    Once you've filled out the form, press **Add** to save your changes.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/ldap/identities-org-configure-ldap.png" alt="Configure LDAP auth" />

    <Step title="Authenticating with the identity">
      After configuring LDAP auth for your identity, you can authenticate with the identity and obtain an access token using your LDAP credentials.

      ```bash  theme={"dark"}
        curl --request POST \
          --url https://app.infisical.com/api/v1/auth/ldap-auth/login \
          --header 'Content-Type: application/json' \
          --data '{
          "identityId": "<string>",
          "username": "<string>",
          "password": "<string>"
        }'
      ```

      <Note>
        For EU Cloud and Self-Hosted users, make sure to replace `https://app.infisical.com` with `https://eu.infisical.com` or your self-hosted instance's URL in the request URL.
      </Note>

      If successful, you'll receive an access token in the response body.

      ```json  theme={"dark"}
      {
        "accessToken": "your-access-token",
        "expiresIn": 2592000,
        "accessTokenMaxTTL": 2592000,
        "tokenType": "Bearer"
      }
      ```

      You can read more about the login API endpoint [here](/api-reference/endpoints/ldap-auth/login).
    </Step>
  </Step>
</Steps>


# Machine Identities
Source: https://infisical.com/docs/documentation/platform/identities/machine-identities

Learn how to use Machine Identities to programmatically interact with Infisical.

## Concept

An Infisical machine identity is an entity that represents a workload or application that require access to various resources in Infisical. This is conceptually similar to an IAM user in AWS or service account in Google Cloud Platform (GCP).

Each identity must authenticate with the Infisical API using a supported authentication method like [Token Auth](/documentation/platform/identities/token-auth), [Universal Auth](/documentation/platform/identities/universal-auth), [Kubernetes Auth](/documentation/platform/identities/kubernetes-auth), [AWS Auth](/documentation/platform/identities/aws-auth), [Azure Auth](/documentation/platform/identities/azure-auth), or [GCP Auth](/documentation/platform/identities/gcp-auth) to get back a short-lived access token to be used in subsequent requests.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/organization/organization-machine-identities.png" alt="Organization Identities" />

Key Features:

* Role Assignment: Identities must be assigned [roles](/documentation/platform/access-controls/role-based-access-controls). These roles determine the scope of access to resources, either at the organization level or project level.
* Auth/Token Configuration: Identities must be configured with corresponding authentication methods and access token properties to securely interact with the Infisical API.

## Scopes

Identities can be created either at the organization-level or the project-level. Outside of identity management and scope of operation, organization and project identities are functionally identical.

* Project identities are managed at the project-level and can only operate within their respective project.
  Project-level identities are useful for organizations that delegate responsibility to autonomous teams via projects.

* Organization identities are managed at the organization-level and can be assigned to one or more projects, as well as
  perform organization-level operations. Organization-level identities are useful for organizations that have cross-project operations.

## Workflow

<Tabs>
  <Tab title="Project Identities">
    A typical workflow for using project identities consists of three steps:

    1. Creating the identity with a name and [role](/documentation/platform/access-controls/role-based-access-controls) in Project > Access Control > Machine Identities.
       This step also involves configuring an authentication method for it.
    2. Authenticating the identity with the Infisical API based on the configured authentication method on it and receiving a short-lived access token back.
    3. Authenticating subsequent requests with the Infisical API using the short-lived access token.
  </Tab>

  <Tab title="Organization Identities">
    A typical workflow for using organization identities consists of four steps:

    1. Creating the identity with a name and [role](/documentation/platform/access-controls/role-based-access-controls) in Organization > Access Control > Machine Identities.
       This step also involves configuring an authentication method for it.
    2. Adding the identity to the project(s) you want it to have access to.
    3. Authenticating the identity with the Infisical API based on the configured authentication method on it and receiving a short-lived access token back.
    4. Authenticating subsequent requests with the Infisical API using the short-lived access token.
  </Tab>
</Tabs>

## Authentication Methods

To interact with various resources in Infisical, Machine Identities can authenticate with the Infisical API using:

* [Token Auth](/documentation/platform/identities/token-auth): A platform-agnostic, simple authentication method suitable to authenticate with Infisical using a token.
* [Universal Auth](/documentation/platform/identities/universal-auth): A platform-agnostic authentication method suitable to authenticate with Infisical using a Client ID and Client Secret.
* [Kubernetes Auth](/documentation/platform/identities/kubernetes-auth): A Kubernetes-native authentication method for applications (e.g. pods).
* [AWS Auth](/documentation/platform/identities/aws-auth): An AWS-native authentication method for AWS services (e.g. EC2, Lambda functions, etc.).
* [Azure Auth](/documentation/platform/identities/azure-auth): An Azure-native authentication method for Azure resources (e.g. Azure VMs, Azure App Services, Azure Functions, Azure Kubernetes Service, etc.).
* [GCP Auth](/documentation/platform/identities/gcp-auth): A GCP-native authentication method for GCP resources (e.g. Compute Engine, App Engine, Cloud Run, Google Kubernetes Engine, IAM service accounts, etc.).
* [OIDC Auth](/documentation/platform/identities/oidc-auth): A platform-agnostic, JWT-based authentication method for workloads using an OpenID Connect identity provider.

## Identity Lockout

Lockout is a feature that prevents brute-force attacks on identity login endpoints. Auth methods that support lockout include: [Universal Auth](/documentation/platform/identities/universal-auth), [LDAP Auth](/documentation/platform/identities/ldap-auth/general).

Supported auth methods have lockout enabled by default. If triggered, lockout temporarily disables the login endpoint for 5 minutes after 3 consecutive failed login attempts within a 30-second window. Lockout can be configured and disabled in the identity auth method settings.

## FAQ

<AccordionGroup>
  <Accordion title="Can I use machine identities with the CLI?">
    Yes - Identities can be used with the CLI.

    You can learn more about how to do this in the CLI quickstart [here](/cli/usage).
  </Accordion>

  <Accordion title="What is the difference between an identity and service token?">
    A service token is a project-level authentication method that is being deprecated in favor of identities. The service token method will be removed in the future in accordance with the deprecation notice and timeline stated [here](https://infisical.com/blog/deprecating-api-keys).

    Amongst many differences, identities provide broader access over the Infisical API, utilizes the same
    permission system as user identities, and come with a significantly larger number of configurable authentication and security features.

    If you're looking for a simple authentication method, similar to service tokens, that can be bound onto an identity, we recommend checking out [Token Auth](/documentation/platform/identities/token-auth).
  </Accordion>

  <Accordion title="Why can I not create, read, update, or delete an identity?">
    There are a few reasons for why this might happen:

    * You have insufficient organization permissions to create, read, update, delete identities.
    * The identity you are trying to read, update, or delete is more privileged than yourself.
    * The role you are trying to create an identity for or update an identity to is more privileged than yours.
  </Accordion>
</AccordionGroup>


# OCI Auth
Source: https://infisical.com/docs/documentation/platform/identities/oci-auth

Learn how to authenticate with Infisical using OCI user accounts.

**OCI Auth** is an OCI-native authentication method that verifies Oracle Cloud Infrastructure users through signature validation, allowing secure access to Infisical resources.

## Diagram

The following sequence diagram illustrates the OCI Auth workflow for authenticating OCI users with Infisical.

```mermaid  theme={"dark"}
sequenceDiagram
  participant Client
  participant Infisical
  participant OCI

  Note over Client,Client: Step 1: Sign user identity request

  Note over Client,Infisical: Step 2: Login Operation
  Client->>Infisical: Send signed request details to /api/v1/auth/oci-auth/login

  Note over Infisical,OCI: Step 3: Request verification
  Infisical->>OCI: Forward signed request
  OCI-->>Infisical: Return user details

  Note over Infisical: Step 4: Identity property validation
  Infisical->>Client: Return short-lived access token

  Note over Client,Infisical: Step 5: Access Infisical API with token
  Client->>Infisical: Make authenticated requests using the short-lived access token
```

## Concept

At a high level, Infisical authenticates an OCI user by verifying its identity and checking that it meets specific requirements (e.g., its username is authorized, its part of a tenancy) at the `/api/v1/auth/oci-auth/login` endpoint. If successful,
then Infisical returns a short-lived access token that can be used to make authenticated requests to the Infisical API.

To be more specific:

1. The client [signs](https://docs.oracle.com/en-us/iaas/Content/API/Concepts/signingrequests.htm) a `/20160918/users/{userId}` request using an OCI user's [private key](https://docs.oracle.com/en-us/iaas/Content/API/Concepts/apisigningkey.htm#Required_Keys_and_OCIDs); this is done using the [OCI SDK](https://infisical.com/docs/documentation/platform/identities/oci-auth#accessing-the-infisical-api-with-the-identity) or API.
2. The client sends the signed request's headers and their user OCID to Infisical at the `/api/v1/auth/oci-auth/login` endpoint.
3. Infisical reconstructs the request and sends it to OCI via the [Get User](https://docs.oracle.com/en/engineered-systems/private-cloud-appliance/3.0-latest/ceapi/op-20160918-users-user_id-get.html) endpoint for verification and obtains the identity associated with the OCI user.
4. Infisical checks the user's properties against set criteria such as **Allowed Usernames** and **Tenancy OCID**.
5. If all checks pass, Infisical returns a short-lived access token that the client can use to make authenticated requests to the Infisical API.

## Prerequisite

In order to sign requests, you must have an OCI user with credentials such as the private key. If you're unaware of how to create a user and obtain the needed credentials, expand the menu below.

<Accordion title="Creating an OCI user">
  <Steps>
    <Step title="Search for 'Domains' and click as shown">
            <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/oci/search-domains.png" alt="Search Domains" />
    </Step>

    <Step title="Select domain">
      Select the domain in which you want to create the Infisical user account.

            <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/oci/select-domain.png" alt="Select Domain" />
    </Step>

    <Step title="Navigate to 'Users'">
            <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/oci/select-users.png" alt="Select Users" />
    </Step>

    <Step title="Click 'Create user'">
            <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/oci/click-create-user.png" alt="Click Create User" />
    </Step>

    <Step title="Create user">
      The name, email, and username can be anything.

            <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/oci/create-user.png" alt="Create User" />
    </Step>

    <Step title="Navigate to 'API keys'">
      After you've created a user, you'll be redirected to the user's page. Navigate to 'API keys'.

            <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/oci/select-api-keys.png" alt="Select API Keys" />
    </Step>

    <Step title="Add API key">
      Click on 'Add API key' and then download or import the private key. After you've obtained the private key, click 'Add'.

            <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/oci/add-api-key.png" alt="Add API Key" />

      <Note>
        At the end of the downloaded private key file, you'll see `OCI_API_KEY`. This is not apart of the private key, and should not be included when you use the private key to sign requests.
      </Note>
    </Step>

    <Step title="Store configuration">
      After creating the API key, you'll be shown a modal with relevant information. Save the highlighted values (and the private key) for later steps.

            <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/oci/user-info.png" alt="User Info" />
    </Step>
  </Steps>
</Accordion>

## Guide

In the following steps, we explore how to create and use identities for your workloads and applications on OCI to
access the Infisical API using the OCI request signing authentication method.

### Creating an identity

To create an identity, head to your Organization Settings > Access Control > [Identities](https://app.infisical.com/organization/access-management?selectedTab=identities) and press **Create identity**.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-org.png" alt="identities organization" />

When creating an identity, you specify an organization-level [role](/documentation/platform/access-controls/role-based-access-controls) for it to assume; you can configure roles in Organization Settings > Access Control > [Organization Roles](https://app.infisical.com/organization/access-management?selectedTab=roles).

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-org-create.png" alt="identities organization create" />

Input some details for your new identity:

* **Name (required):** A friendly name for the identity.
* **Role (required):** A role from the [**Organization Roles**](https://app.infisical.com/organization/access-management?selectedTab=roles) tab for the identity to assume. The organization role assigned will determine what organization-level resources this identity can have access to.

Once you've created an identity, you'll be redirected to a page where you can manage the identity.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-page.png" alt="identities page" />

Since the identity has been configured with [Universal Auth](https://infisical.com/docs/documentation/platform/identities/universal-auth) by default, you should reconfigure it to use OCI Auth instead. To do this, click the cog next to **Universal Auth** and then select **Delete** in the options dropdown.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-press-cog.png" alt="identities press cog" />

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-page-remove-default-auth.png" alt="identities page remove default auth" />

Now create a new OCI Auth Method.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-org-create-oci-auth-method.png" alt="identities create oci auth method" />

Here's some information about each field:

* **Tenancy OCID:** The OCID of your tenancy. All users authenticating must be part of this Tenancy.
* **Allowed Usernames:** A comma-separated list of trusted OCI users that are allowed to authenticate with Infisical.
* **Access Token TTL (default is `2592000` equivalent to 30 days):** The lifetime for an access token in seconds. This value will be referenced at renewal time.
* **Access Token Max TTL (default is `2592000` equivalent to 30 days):** The maximum lifetime for an access token in seconds. This value will be referenced at renewal time.
* **Access Token Max Number of Uses (default is `0`):** The maximum number of times that an access token can be used; a value of `0` implies an infinite number of uses.
* **Access Token Trusted IPs:** The IPs or CIDR ranges that access tokens can be used from. By default, each token is given the `0.0.0.0/0`, allowing usage from any network address.

### Adding an identity to a project

In order to allow an identity to access project-level resources such as secrets, you must add it to the relevant projects.

To do this, head over to the project you want to add the identity to and navigate to Project Settings > Access Control > Machine Identities and press **Add Identity**.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-project.png" alt="identities project" />

Select the identity you want to add to the project and the project-level role you want it to assume. The project role given to the identity will determine what project-level resources this identity can access.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-project-create.png" alt="identities project create" />

### Accessing the Infisical API with the identity

To access the Infisical API as the identity, you need to construct a signed [Get User](https://docs.oracle.com/en/engineered-systems/private-cloud-appliance/3.0-latest/ceapi/op-20160918-users-user_id-get.html) request using [OCI Signature v1](https://docs.oracle.com/en-us/iaas/Content/API/Concepts/signingrequests.htm#Request_Signatures) and then make a request to the `/api/v1/auth/oci-auth/login` endpoint passing the signed header data and user OCID.

Below is an example of how you can authenticate with Infisical using the `oci-sdk` for NodeJS.

```typescript  theme={"dark"}
import { common } from "oci-sdk";

// Change these credentials to match your OCI user
const tenancyId = "ocid1.tenancy.oc1..example";
const userId = "ocid1.user.oc1..example";
const fingerprint = "00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00";
const region = "us-ashburn-1";
const privateKey = "..."; // Must be PEM format

const provider = new common.SimpleAuthenticationDetailsProvider(
  tenancyId,
  userId,
  fingerprint,
  privateKey,
  null,
  common.Region.fromRegionId(region),
);

// Build request
const headers = new Headers({
  host: `identity.${region}.oraclecloud.com`,
});

const request: common.HttpRequest = {
  method: "GET",
  uri: `/20160918/users/${userId}`,
  headers,
  body: null,
};

// Sign request
const signer = new common.DefaultRequestSigner(provider);
await signer.signHttpRequest(request);

// Forward signed request to Infisical
const requestAsJson = {
  identityId: "2dd11664-68e3-471d-b366-907206ab1bff",
  userOcid: userId,
  headers: Object.fromEntries(request.headers.entries()),
};

const res = await fetch("https://app.infisical.com/api/v1/auth/oci-auth/login", {
  method: "POST",
  headers: {
    "Content-Type": "application/json",
  },
  body: JSON.stringify(requestAsJson),
});

const json = await res.json();

console.log("Infisical Response:", json);
```

<Note>
  Each identity access token has a time-to-live (TTL) which you can infer from the response of the login operation; the default TTL is `7200` seconds, which can be adjusted.

  If an identity access token expires, it can no longer access the Infisical API. A new access token should be obtained by performing another login operation.
</Note>


# Azure
Source: https://infisical.com/docs/documentation/platform/identities/oidc-auth/azure

Learn how to authenticate Azure pipelines with Infisical using OpenID Connect (OIDC).

**OIDC Auth** is a platform-agnostic JWT-based authentication method that can be used to authenticate from any platform or environment using an identity provider with OpenID Connect.

## Diagram

The following sequence diagram illustrates the OIDC Auth workflow for authenticating Azure pipelines with Infisical.

```mermaid  theme={"dark"}
sequenceDiagram
  participant Client as Azure Pipeline
  participant Idp as Identity Provider
  participant Infis as Infisical

  Client->>Idp: Step 1: Request identity token
  Idp-->>Client: Return JWT with verifiable claims

  Note over Client,Infis: Step 2: Login Operation
  Client->>Infis: Send signed JWT to /api/v1/auth/oidc-auth/login

  Note over Infis,Idp: Step 3: Query verification
  Infis->>Idp: Request JWT public key using OIDC Discovery
  Idp-->>Infis: Return public key

  Note over Infis: Step 4: JWT validation
  Infis->>Client: Return short-lived access token

  Note over Client,Infis: Step 5: Access Infisical API with Token
  Client->>Infis: Make authenticated requests using the short-lived access token
```

## Concept

At a high-level, Infisical authenticates a client by verifying the JWT and checking that it meets specific requirements (e.g. it is issued by a trusted identity provider) at the `/api/v1/auth/oidc-auth/login` endpoint. If successful,
then Infisical returns a short-lived access token that can be used to make authenticated requests to the Infisical API.

To be more specific:

1. The Azure pipeline requests an identity token from Azure's identity provider.
2. The fetched identity token is sent to Infisical at the `/api/v1/auth/oidc-auth/login` endpoint.
3. Infisical fetches the public key that was used to sign the identity token from Azure's identity provider using OIDC Discovery.
4. Infisical validates the JWT using the public key provided by the identity provider and checks that the subject, audience, and claims of the token matches with the set criteria.
5. If all is well, Infisical returns a short-lived access token that the Azure pipeline can use to make authenticated requests to the Infisical API.

<Note>
  Infisical needs network-level access to Azure's identity provider endpoints.
</Note>

## Guide

In the following steps, we explore how to create and use identities to access the Infisical API using the OIDC Auth authentication method.

<Steps>
  <Step title="Creating an identity">
    To create an identity, head to your Organization Settings > Access Control > Identities and press **Create identity**.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-org.png" alt="identities organization" />

    When creating an identity, you specify an organization level [role](/documentation/platform/access-controls/role-based-access-controls) for it to assume; you can configure roles in Organization Settings > Access Control > Organization Roles.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-org-create.png" alt="identities organization create" />

    Now input a few details for your new identity. Here's some guidance for each field:

    * Name (required): A friendly name for the identity.
    * Role (required): A role from the **Organization Roles** tab for the identity to assume. The organization role assigned will determine what organization level resources this identity can have access to.

    Once you've created an identity, you'll be redirected to a page where you can manage the identity.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-page.png" alt="identities page" />

    Since the identity has been configured with Universal Auth by default, you should re-configure it to use OIDC Auth instead. To do this, press to edit the **Authentication** section,
    remove the existing Universal Auth configuration, and add a new OIDC Auth configuration onto the identity.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-page-remove-default-auth.png" alt="identities page remove default auth" />

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-org-create-oidc-auth-method.png" alt="identities create oidc auth method" />

    <Warning>Restrict access by configuring the Subject, Audiences, and Claims fields</Warning>

    Here's some more guidance on each field:

    * <div style={{ textAlign: 'justify' }}>**OIDC Discovery URL**: The URL used to retrieve the OpenID Connect configuration from the identity provider. This is used to fetch the public keys needed to verify the JWT. For Azure, set this to `https://login.microsoftonline.com/{tenant-id}/v2.0` (replace `{tenant-id}` with your Azure AD tenant ID).</div>
    * <div style={{ textAlign: 'justify' }}>**Issuer**: The value of the `iss` claim that the token must match. For Azure, this should be `https://login.microsoftonline.com/{tenant-id}/v2.0`.</div>
    * **Subject**: This must match the `sub` claim in the JWT.
    * **Audiences**: Values that must match the `aud` claim.
    * **Claims**: Additional claims that must be present. Refer to [Azure DevOps docs](https://learn.microsoft.com/en-us/azure/devops/pipelines/library/connect-to-azure?view=azure-devops#workload-identity-federation) for available claims.
    * **Access Token TTL**: Lifetime of the issued token (in seconds), e.g., `2592000` (30 days)
    * **Access Token Max TTL**: Maximum allowed lifetime of the token
    * **Access Token Max Number of Uses**: Max times the token can be used (`0` = unlimited)
    * **Access Token Trusted IPs**: List of allowed IP ranges (defaults to `0.0.0.0/0`)

    <Tip>If you are unsure about what to configure for the subject, audience, and claims fields, you can inspect the JWT token from your Azure DevOps pipeline by adding a debug step that outputs the token claims.</Tip>
    <Info>The `subject`, `audiences`, and `claims` fields support glob pattern matching; however, we highly recommend using hardcoded values whenever possible.</Info>
  </Step>

  <Step title="Adding an identity to a project">
    To enable the identity to access project-level resources such as secrets within a specific project, you should add it to that project.

    To do this, head over to the project you want to add the identity to and go to Project Settings > Access Control > Machine Identities and press **Add identity**.

    Next, select the identity you want to add to the project and the project level role you want to allow it to assume. The project role assigned will determine what project level resources this identity can have access to.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-project.png" alt="identities project" />

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-project-create.png" alt="identities project create" />
  </Step>

  <Step title="Accessing the Infisical API with the identity">
    In Azure DevOps, to authenticate with Infisical using OIDC, you must configure a service connection that enables workload identity federation.

    Once set up, the OIDC token can be fetched automatically within the pipeline job context. Here's an example:

    ```yaml  theme={"dark"}
    trigger:
    - main

    pool:
      vmImage: ubuntu-latest

    steps:
    - task: AzureCLI@2
      displayName: 'Retrieve secrets from Infisical using OIDC'
      inputs:
        azureSubscription: 'your-azure-service-connection-name'
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        addSpnToEnvironment: true
        inlineScript: |
          # Get OIDC access token
          OIDC_TOKEN=$(az account get-access-token --resource "api://AzureADTokenExchange" --query accessToken -o tsv)
          
          [ -z "$OIDC_TOKEN" ] && { echo "Failed to get access token"; exit 1; }
          
          # Exchange for Infisical access token
          ACCESS_TOKEN=$(curl -s -X POST "<YOUR-INFISICAL-INSTANCE-URL>/api/v1/auth/oidc-auth/login" \
            -H "Content-Type: application/json" \
            -d "{\"identityId\":\"{your-identity-id}\",\"jwt\":\"$OIDC_TOKEN\"}" \
            | jq -r '.accessToken')
          
          # Fetch secrets
          curl -s -H "Authorization: Bearer $ACCESS_TOKEN" \
            "<YOUR-INFISICAL-INSTANCE-URL>/api/v3/secrets/raw?environment={your-environment-slug}&workspaceSlug={your-workspace-slug}"
    ```

    Make sure the service connection is properly configured for workload identity federation and linked to your Azure AD app registration with appropriate claims.

    <Note>
      Each identity access token has a time-to-live (TTL) which you can infer from the response of the login operation;
      the default TTL is `7200` seconds which can be adjusted.

      If an identity access token expires, it can no longer authenticate with the Infisical API. In this case,
      a new access token should be obtained by performing another login operation.
    </Note>
  </Step>
</Steps>


# CircleCI
Source: https://infisical.com/docs/documentation/platform/identities/oidc-auth/circleci

Learn how to authenticate CircleCI jobs with Infisical using OpenID Connect (OIDC).

**OIDC Auth** is a platform-agnostic JWT-based authentication method that can be used to authenticate from any platform or environment using an identity provider with OpenID Connect.

## Diagram

The following sequence diagram illustrates the OIDC Auth workflow for authenticating CircleCI jobs with Infisical.

```mermaid  theme={"dark"}
sequenceDiagram
  participant Client as CircleCI Job
  participant Idp as CircleCI Identity Provider
  participant Infis as Infisical

  Idp->>Client: Step 1: Inject JWT with verifiable claims

  Note over Client,Infis: Step 2: Login Operation
  Client->>Infis: Send signed JWT to /api/v1/auth/oidc-auth/login

  Note over Infis,Idp: Step 3: Query verification
  Infis->>Idp: Request JWT public key using OIDC Discovery
  Idp-->>Infis: Return public key

  Note over Infis: Step 4: JWT validation
  Infis->>Client: Return short-lived access token

  Note over Client,Infis: Step 5: Access Infisical API with Token
  Client->>Infis: Make authenticated requests using the short-lived access token
```

## Concept

At a high-level, Infisical authenticates a client by verifying the JWT and checking that it meets specific requirements (e.g. it is issued by a trusted identity provider) at the `/api/v1/auth/oidc-auth/login` endpoint. If successful,
then Infisical returns a short-lived access token that can be used to make authenticated requests to the Infisical API.

To be more specific:

1. CircleCI provides the running job with a valid OIDC token specific to the execution.
2. The CircleCI OIDC token is sent to Infisical at the `/api/v1/auth/oidc-auth/login` endpoint.
3. Infisical fetches the public key that was used to sign the identity token provided by CircleCI.
4. Infisical validates the JWT using the public key provided by the identity provider and checks that the subject, audience, and claims of the token matches with the set criteria.
5. If all is well, Infisical returns a short-lived access token that CircleCI jobs can use to make authenticated requests to the Infisical API.

<Note>Infisical needs network-level access to the CircleCI servers.</Note>

## Guide

In the following steps, we explore how to create and use identities to access the Infisical API using the OIDC Auth authentication method.

<Steps>
  <Step title="Creating an identity">
    To create an identity, head to your Organization Settings > Access Control > Identities and press **Create identity**.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-org.png" alt="identities organization" />

    When creating an identity, you specify an organization level [role](/documentation/platform/access-controls/role-based-access-controls) for it to assume; you can configure roles in Organization Settings > Access Control > Organization Roles.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-org-create.png" alt="identities organization create" />

    Now input a few details for your new identity. Here's some guidance for each field:

    * Name (required): A friendly name for the identity.
    * Role (required): A role from the **Organization Roles** tab for the identity to assume. The organization role assigned will determine what organization level resources this identity can have access to.

    Once you've created an identity, you'll be redirected to a page where you can manage the identity.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-page.png" alt="identities page" />

    Since the identity has been configured with Universal Auth by default, you should re-configure it to use OIDC Auth instead. To do this, press to edit the **Authentication** section,
    remove the existing Universal Auth configuration, and add a new OIDC Auth configuration onto the identity.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-page-remove-default-auth.png" alt="identities page remove default auth" />

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-org-create-oidc-auth-method.png" alt="identities create oidc auth method" />

    <Warning>Restrict access by configuring the Subject, Audiences, and Claims fields</Warning>

    Here's some more guidance on each field:

    * OIDC Discovery URL:  The URL used to retrieve the OpenID Connect configuration from the identity provider. This will be used to fetch the public key needed for verifying the provided JWT. This should be set to `https://oidc.circleci.com/org/<organization_id>` where `organization_id` refers to the CircleCI organization where the job is being run.
    * Issuer: The unique identifier of the identity provider issuing the JWT. This value is used to verify the iss (issuer) claim in the JWT to ensure the token is issued by a trusted provider. This should be set to `https://oidc.circleci.com/org/<organization_id>` as well.
    * CA Certificate: The PEM-encoded CA cert for establishing secure communication with the Identity Provider endpoints. This can be left as blank.
    * Subject: The expected principal that is the subject of the JWT. The format of the sub field for CircleCI OIDC tokens is `org/<organization_id>/project/<project_id>/user/<user_id>` where organization\_id, project\_id, and user\_id are UUIDs that identify the CircleCI organization, project, and user, respectively. The user is the CircleCI user that caused this job to run.
    * Audiences: A list of intended recipients. This value is checked against the aud (audience) claim in the token. Set this to the CircleCI `organization_id` corresponding to where the job is running.
    * Claims: Additional information or attributes that should be present in the JWT for it to be valid. Refer to CircleCI's [documentation](https://circleci.com/docs/openid-connect-tokens) for the complete list of supported claims.
    * Access Token TTL (default is `2592000` equivalent to 30 days): The lifetime for an acccess token in seconds. This value will be referenced at renewal time.
    * Access Token Max TTL (default is `2592000`  equivalent to 30 days): The maximum lifetime for an acccess token in seconds. This value will be referenced at renewal time.
    * Access Token Max Number of Uses (default is `0`): The maximum number of times that an access token can be used; a value of `0` implies infinite number of uses.
    * Access Token Trusted IPs: The IPs or CIDR ranges that access tokens can be used from. By default, each token is given the `0.0.0.0/0`, allowing usage from any network address.
      <Tip>For more details on the appropriate values for the OIDC fields, refer to CircleCI's [documentation](https://circleci.com/docs/openid-connect-tokens). </Tip>
      <Info>The `subject`, `audiences`, and `claims` fields support glob pattern matching; however, we highly recommend using hardcoded values whenever possible.</Info>
  </Step>

  <Step title="Adding an identity to a project">
    To enable the identity to access project-level resources such as secrets within a specific project, you should add it to that project.

    To do this, head over to the project you want to add the identity to and go to Project Settings > Access Control > Machine Identities and press **Add identity**.

    Next, select the identity you want to add to the project and the project level role you want to allow it to assume. The project role assigned will determine what project level resources this identity can have access to.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-project.png" alt="identities project" />

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-project-create.png" alt="identities project create" />
  </Step>

  <Step title="Using CircleCI OIDC token to authenticate with Infisical">
    The following is an example of how to use the `$CIRCLE_OIDC_TOKEN` with the Infisical [terraform provider](https://registry.terraform.io/providers/Infisical/infisical/latest/docs) to manage resources in a CircleCI pipeline.

    ```yml config.yml theme={"dark"}
    version: 2.1

    jobs:
    terraform-apply:
        docker:
        - image: hashicorp/terraform:latest

        steps:
        - checkout
        - run:
            command: |
                export INFISICAL_AUTH_JWT="$CIRCLE_OIDC_TOKEN"
                terraform init
                terraform apply -auto-approve

    workflows:
    version: 2
    build-and-test:
        jobs:
        - terraform-apply
    ```

    The Infisical terraform provider expects the  `INFISICAL_AUTH_JWT` environment variable to be set to the CircleCI OIDC token.

    ```hcl main.tf theme={"dark"}
    terraform {
        required_providers {
            infisical = {
                source = "infisical/infisical"
            }
        }
    }

    provider "infisical" {
        host = "https://app.infisical.com"
        auth = {
            oidc = {
                identity_id = "f2f5ee4c-6223-461a-87c3-406a6b481462"
            }
        }
    }

    resource "infisical_access_approval_policy" "prod-access-approval" {
        project_id = "09eda1f8-85a3-47a9-8a6f-e27f133b2a36"
        name = "my-approval-policy"
        environment_slug = "prod"
        secret_path = "/"
        approvers = [
        {
            type = "user"
            username = "sheen+200@infisical.com"
        },
        ]
        required_approvals = 1
        enforcement_level =  "soft"
    }
    ```

    <Note>
      Each identity access token has a time-to-live (TTL) which you can infer from the response of the login operation;
      the default TTL is `7200` seconds which can be adjusted.

      If an identity access token expires, it can no longer authenticate with the Infisical API. In this case,
      a new access token should be obtained by performing another login operation.
    </Note>
  </Step>
</Steps>


# General
Source: https://infisical.com/docs/documentation/platform/identities/oidc-auth/general

Learn how to authenticate with Infisical from any platform or environment using OpenID Connect (OIDC).

**OIDC Auth** is a platform-agnostic JWT-based authentication method that can be used to authenticate from any platform or environment using an identity provider with OpenID Connect.

## Diagram

The following sequence diagram illustrates the OIDC Auth workflow for authenticating clients with Infisical.

```mermaid  theme={"dark"}
sequenceDiagram
  participant Client as Client
  participant Idp as Identity Provider
  participant Infis as Infisical

  Client->>Idp: Step 1: Request identity token
  Idp-->>Client: Return JWT with verifiable claims

  Note over Client,Infis: Step 2: Login Operation
  Client->>Infis: Send signed JWT to /api/v1/auth/oidc-auth/login

  Note over Infis,Idp: Step 3: Query verification
  Infis->>Idp: Request JWT public key using OIDC Discovery
  Idp-->>Infis: Return public key

  Note over Infis: Step 4: JWT validation
  Infis->>Client: Return short-lived access token

  Note over Client,Infis: Step 5: Access Infisical API with Token
  Client->>Infis: Make authenticated requests using the short-lived access token
```

## Concept

At a high-level, Infisical authenticates a client by verifying the JWT and checking that it meets specific requirements (e.g. it is issued by a trusted identity provider) at the `/api/v1/auth/oidc-auth/login` endpoint. If successful,
then Infisical returns a short-lived access token that can be used to make authenticated requests to the Infisical API.

To be more specific:

1. The client requests an identity token from its identity provider.
2. The client sends the identity token to Infisical at the `/api/v1/auth/oidc-auth/login` endpoint.
3. Infisical fetches the public key that was used to sign the identity token from the identity provider using OIDC Discovery.
4. Infisical validates the JWT using the public key provided by the identity provider and checks that the subject, audience, and claims of the token matches with the set criteria.
5. If all is well, Infisical returns a short-lived access token that the client can use to make authenticated requests to the Infisical API.

<Note>
  Infisical needs network-level access to the identity provider configuration
  endpoints.
</Note>

## Guide

In the following steps, we explore how to create and use identities to access the Infisical API using the OIDC Auth authentication method.

<Steps>
  <Step title="Creating an identity">
    To create an identity, head to your Organization Settings > Access Control > Identities and press **Create identity**.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-org.png" alt="identities organization" />

    When creating an identity, you specify an organization level [role](/documentation/platform/access-controls/role-based-access-controls) for it to assume; you can configure roles in Organization Settings > Access Control > Organization Roles.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-org-create.png" alt="identities organization create" />

    Now input a few details for your new identity. Here's some guidance for each field:

    * Name (required): A friendly name for the identity.
    * Role (required): A role from the **Organization Roles** tab for the identity to assume. The organization role assigned will determine what organization level resources this identity can have access to.

    Once you've created an identity, you'll be redirected to a page where you can manage the identity.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-page.png" alt="identities page" />

    Since the identity has been configured with Universal Auth by default, you should re-configure it to use OIDC Auth instead. To do this, press to edit the **Authentication** section,
    remove the existing Universal Auth configuration, and add a new OIDC Auth configuration onto the identity.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-page-remove-default-auth.png" alt="identities page remove default auth" />

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-org-create-oidc-auth-method.png" alt="identities create oidc auth method" />

    <Tip>Restrict access by configuring the Subject, Audiences, and Claims fields</Tip>

    Here's some more guidance on each field:

    * OIDC Discovery URL:  The URL used to retrieve the OpenID Connect configuration from the identity provider. This will be used to fetch the public key needed for verifying the provided JWT.
    * Issuer: The unique identifier of the identity provider issuing the JWT. This value is used to verify the iss (issuer) claim in the JWT to ensure the token is issued by a trusted provider.
    * CA Certificate: The PEM-encoded CA cert for establishing secure communication with the Identity Provider endpoints.
    * Subject: The expected principal that is the subject of the JWT. The `sub` (subject) claim in the JWT should match this value.
    * Audiences: A list of intended recipients. This value is checked against the aud (audience) claim in the token. The token's aud claim should match at least one of the audiences for it to be valid.
    * Claims: Additional information or attributes that should be present in the JWT for it to be valid.
    * Access Token TTL (default is `2592000` equivalent to 30 days): The lifetime for an acccess token in seconds. This value will be referenced at renewal time.
    * Access Token Max TTL (default is `2592000`  equivalent to 30 days): The maximum lifetime for an acccess token in seconds. This value will be referenced at renewal time.
    * Access Token Max Number of Uses (default is `0`): The maximum number of times that an access token can be used; a value of `0` implies infinite number of uses.
    * Access Token Trusted IPs: The IPs or CIDR ranges that access tokens can be used from. By default, each token is given the `0.0.0.0/0`, allowing usage from any network address.

    <Info>
      The `subject`, `audiences`, and `claims` fields support glob pattern matching; however, we highly recommend using hardcoded values whenever possible.
    </Info>
  </Step>

  <Step title="Adding an identity to a project">
    To enable the identity to access project-level resources such as secrets within a specific project, you should add it to that project.

    To do this, head over to the project you want to add the identity to and go to Project Settings > Access Control > Machine Identities and press **Add identity**.

    Next, select the identity you want to add to the project and the project level role you want to allow it to assume. The project role assigned will determine what project level resources this identity can have access to.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-project.png" alt="identities project" />

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-project-create.png" alt="identities project create" />
  </Step>

  <Step title="Accessing the Infisical API with the identity">
    To access the Infisical API as the identity, you need to fetch an identity token from an identity provider and make a request to the `/api/v1/auth/oidc-auth/login` endpoint in exchange for an access token.

    We provide an example below of how authentication is done with Infisical using OIDC. It is a snippet from the [official Github secrets action](https://github.com/Infisical/secrets-action).

    #### Sample usage

    ```javascript  theme={"dark"}
    export const oidcLogin = async ({ identityId, domain, oidcAudience }) => {
        const idToken = await core.getIDToken(oidcAudience);

        const loginData = querystring.stringify({
            identityId,
            jwt: idToken,
        });

        try {
            const response = await axios({
            method: "post",
            url: `${domain}/api/v1/auth/oidc-auth/login`,
            headers: {
                "Content-Type": "application/x-www-form-urlencoded",
            },
            data: loginData,
            });

            return response.data.accessToken;
        } catch (err) {
            core.error("Error:", err.message);
            throw err;
        }
    };
    ```

    #### Sample OIDC login response

    ```bash Response theme={"dark"}
    {
    "accessToken": "...",
    "expiresIn": 7200,
    "accessTokenMaxTTL": 43244
    "tokenType": "Bearer"
    }
    ```

    <Tip>
      We recommend using one of Infisical's clients like SDKs or the Infisical Agent to authenticate with Infisical using OIDC Auth as they handle the authentication process including the fetching of identity tokens for you.
    </Tip>

    <Note>
      Each identity access token has a time-to-live (TTL) which you can infer from the response of the login operation;
      the default TTL is `7200` seconds which can be adjusted.

      If an identity access token expires, it can no longer authenticate with the Infisical API. In this case,
      a new access token should be obtained by performing another login operation.
    </Note>
  </Step>
</Steps>


# Github
Source: https://infisical.com/docs/documentation/platform/identities/oidc-auth/github

Learn how to authenticate Github workflows with Infisical using OpenID Connect (OIDC).

**OIDC Auth** is a platform-agnostic JWT-based authentication method that can be used to authenticate from any platform or environment using an identity provider with OpenID Connect.

## Diagram

The following sequence diagram illustrates the OIDC Auth workflow for authenticating Github workflows with Infisical.

```mermaid  theme={"dark"}
sequenceDiagram
  participant Client as Github Workflow
  participant Idp as Identity Provider
  participant Infis as Infisical

  Client->>Idp: Step 1: Request identity token
  Idp-->>Client: Return JWT with verifiable claims

  Note over Client,Infis: Step 2: Login Operation
  Client->>Infis: Send signed JWT to /api/v1/auth/oidc-auth/login

  Note over Infis,Idp: Step 3: Query verification
  Infis->>Idp: Request JWT public key using OIDC Discovery
  Idp-->>Infis: Return public key

  Note over Infis: Step 4: JWT validation
  Infis->>Client: Return short-lived access token

  Note over Client,Infis: Step 5: Access Infisical API with Token
  Client->>Infis: Make authenticated requests using the short-lived access token
```

## Concept

At a high-level, Infisical authenticates a client by verifying the JWT and checking that it meets specific requirements (e.g. it is issued by a trusted identity provider) at the `/api/v1/auth/oidc-auth/login` endpoint. If successful,
then Infisical returns a short-lived access token that can be used to make authenticated requests to the Infisical API.

To be more specific:

1. The Github workflow requests an identity token from Github's identity provider.
2. The fetched identity token is sent to Infisical at the `/api/v1/auth/oidc-auth/login` endpoint.
3. Infisical fetches the public key that was used to sign the identity token from Github's identity provider using OIDC Discovery.
4. Infisical validates the JWT using the public key provided by the identity provider and checks that the subject, audience, and claims of the token matches with the set criteria.
5. If all is well, Infisical returns a short-lived access token that the Github workflow can use to make authenticated requests to the Infisical API.

<Note>
  Infisical needs network-level access to Github's identity provider endpoints.
</Note>

## Guide

In the following steps, we explore how to create and use identities to access the Infisical API using the OIDC Auth authentication method.

<Steps>
  <Step title="Creating an identity">
    To create an identity, head to your Organization Settings > Access Control > Identities and press **Create identity**.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-org.png" alt="identities organization" />

    When creating an identity, you specify an organization level [role](/documentation/platform/access-controls/role-based-access-controls) for it to assume; you can configure roles in Organization Settings > Access Control > Organization Roles.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-org-create.png" alt="identities organization create" />

    Now input a few details for your new identity. Here's some guidance for each field:

    * Name (required): A friendly name for the identity.
    * Role (required): A role from the **Organization Roles** tab for the identity to assume. The organization role assigned will determine what organization level resources this identity can have access to.

    Once you've created an identity, you'll be redirected to a page where you can manage the identity.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-page.png" alt="identities page" />

    Since the identity has been configured with Universal Auth by default, you should re-configure it to use OIDC Auth instead. To do this, press to edit the **Authentication** section,
    remove the existing Universal Auth configuration, and add a new OIDC Auth configuration onto the identity.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-page-remove-default-auth.png" alt="identities page remove default auth" />

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-org-create-oidc-auth-method.png" alt="identities create oidc auth method" />

    <Warning>Restrict access by configuring the Subject, Audiences, and Claims fields</Warning>

    Here's some more guidance on each field:

    * OIDC Discovery URL:  The URL used to retrieve the OpenID Connect configuration from the identity provider. This will be used to fetch the public key needed for verifying the provided JWT. This should be set to `https://token.actions.githubusercontent.com`
    * Issuer: The unique identifier of the identity provider issuing the JWT. This value is used to verify the iss (issuer) claim in the JWT to ensure the token is issued by a trusted provider. This should be set to `https://token.actions.githubusercontent.com`
    * CA Certificate: The PEM-encoded CA cert for establishing secure communication with the Identity Provider endpoints. For Github workflows, this can be left as blank.
    * Subject: The expected principal that is the subject of the JWT. The format of the sub field for GitHub workflow OIDC tokens is as follows: `"repo:<owner>/<repo>:<environment>"`. The environment can be where the GitHub workflow is running, such as `environment`, `ref`, or `job_workflow_ref`. For example, if you have a repository owned by octocat named example-repo, and the GitHub workflow is running on the main branch, the subject field might look like this: `repo:octocat/example-repo:ref:refs/heads/main`
    * Audiences: A list of intended recipients. This value is checked against the aud (audience) claim in the token. By default, set this to the URL of the repository owner, such as the organization that owns the repository (e.g. `https://github.com/octo-org`).
    * Claims: Additional information or attributes that should be present in the JWT for it to be valid. You can refer to Github's [documentation](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect#understanding-the-oidc-token) for the complete list of supported claims.
    * Access Token TTL (default is `2592000` equivalent to 30 days): The lifetime for an acccess token in seconds. This value will be referenced at renewal time.
    * Access Token Max TTL (default is `2592000`  equivalent to 30 days): The maximum lifetime for an acccess token in seconds. This value will be referenced at renewal time.
    * Access Token Max Number of Uses (default is `0`): The maximum number of times that an access token can be used; a value of `0` implies infinite number of uses.
    * Access Token Trusted IPs: The IPs or CIDR ranges that access tokens can be used from. By default, each token is given the `0.0.0.0/0`, allowing usage from any network address.
      <Tip>If you are unsure about what to configure for the subject, audience, and claims fields you can use [github/actions-oidc-debugger](https://github.com/github/actions-oidc-debugger) to get the appropriate values. Alternatively, you can fetch the JWT from the workflow and inspect the fields manually.</Tip>
      <Info>The `subject`, `audiences`, and `claims` fields support glob pattern matching; however, we highly recommend using hardcoded values whenever possible.</Info>
  </Step>

  <Step title="Adding an identity to a project">
    To enable the identity to access project-level resources such as secrets within a specific project, you should add it to that project.

    To do this, head over to the project you want to add the identity to and go to Project Settings > Access Control > Machine Identities and press **Add identity**.

    Next, select the identity you want to add to the project and the project level role you want to allow it to assume. The project role assigned will determine what project level resources this identity can have access to.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-project.png" alt="identities project" />

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-project-create.png" alt="identities project create" />
  </Step>

  <Step title="Accessing the Infisical API with the identity">
    As a prerequisite, you will need to set `id-token:write` permissions for the Github workflow. This setting allows the JWT to be requested from Github's OIDC provider.

    ```yaml  theme={"dark"}
    permissions:
        id-token: write # This is required for requesting the JWT
    ...
    ```

    To access the Infisical API as the identity, you need to fetch an identity token from Github's identity provider and make a request to the `/api/v1/auth/oidc-auth/login` endpoint in exchange for an access token.
    The identity token can be fetched using either of the following approaches:

    * Using environment variables on the runner (`ACTIONS_ID_TOKEN_REQUEST_URL` and `ACTIONS_ID_TOKEN_REQUEST_TOKEN`).

    ```yaml  theme={"dark"}
    steps:
        - name: Request OIDC Token
            run: |
            echo "Requesting OIDC token..."
            TOKEN=$(curl -s -H "Authorization: Bearer $ACTIONS_ID_TOKEN_REQUEST_TOKEN" "$ACTIONS_ID_TOKEN_REQUEST_URL" | jq -r '.value')
            echo "TOKEN=$TOKEN" >> $GITHUB_ENV
    ```

    * Using `getIDToken()` from the Github Actions toolkit.

    Below is an example of how a Github workflow can be configured to fetch secrets from Infisical using the [Infisical Secrets Action](https://github.com/Infisical/secrets-action) with OIDC Auth.

    ```yaml  theme={"dark"}
    name: Manual workflow

    on:
        workflow_dispatch:

    permissions:
        id-token: write # This is required for requesting the JWT

    jobs:
        build:
            runs-on: ubuntu-latest
            steps:
                - uses: Infisical/secrets-action@v1.0.7
                with:
                    method: "oidc"
                    env-slug: "dev"
                    project-slug: "ggggg-9-des"
                    identity-id: "6b579c00-5c85-4b44-aabe-f8a
    ...
    ```

    Preceding steps can then use the secret values injected onto the workflow's environment.

    <Tip>
      We recommend using [Infisical Secrets Action](https://github.com/Infisical/secrets-action) to authenticate with Infisical using OIDC Auth as it handles the authentication process including the fetching of identity tokens for you.
    </Tip>

    <Note>
      Each identity access token has a time-to-live (TTL) which you can infer from the response of the login operation;
      the default TTL is `7200` seconds which can be adjusted.

      If an identity access token expires, it can no longer authenticate with the Infisical API. In this case,
      a new access token should be obtained by performing another login operation.
    </Note>
  </Step>
</Steps>


# GitLab
Source: https://infisical.com/docs/documentation/platform/identities/oidc-auth/gitlab

Learn how to authenticate GitLab pipelines with Infisical using OpenID Connect (OIDC).

**OIDC Auth** is a platform-agnostic JWT-based authentication method that can be used to authenticate from any platform or environment using an identity provider with OpenID Connect.

## Diagram

The following sequence diagram illustrates the OIDC Auth workflow for authenticating GitLab pipelines with Infisical.

```mermaid  theme={"dark"}
sequenceDiagram
  participant Client as GitLab Pipeline
  participant Idp as GitLab Identity Provider
  participant Infis as Infisical

  Client->>Idp: Step 1: Request identity token
  Idp-->>Client: Return JWT with verifiable claims

  Note over Client,Infis: Step 2: Login Operation
  Client->>Infis: Send signed JWT to /api/v1/auth/oidc-auth/login

  Note over Infis,Idp: Step 3: Query verification
  Infis->>Idp: Request JWT public key using OIDC Discovery
  Idp-->>Infis: Return public key

  Note over Infis: Step 4: JWT validation
  Infis->>Client: Return short-lived access token

  Note over Client,Infis: Step 5: Access Infisical API with Token
  Client->>Infis: Make authenticated requests using the short-lived access token
```

## Concept

At a high-level, Infisical authenticates a client by verifying the JWT and checking that it meets specific requirements (e.g. it is issued by a trusted identity provider) at the `/api/v1/auth/oidc-auth/login` endpoint. If successful,
then Infisical returns a short-lived access token that can be used to make authenticated requests to the Infisical API.

To be more specific:

1. The GitLab pipeline requests an identity token from GitLab's identity provider.
2. The fetched identity token is sent to Infisical at the `/api/v1/auth/oidc-auth/login` endpoint.
3. Infisical fetches the public key that was used to sign the identity token from GitLab's identity provider using OIDC Discovery.
4. Infisical validates the JWT using the public key provided by the identity provider and checks that the subject, audience, and claims of the token matches with the set criteria.
5. If all is well, Infisical returns a short-lived access token that the GitLab pipeline can use to make authenticated requests to the Infisical API.

<Note>
  Infisical needs network-level access to GitLab's identity provider endpoints.
</Note>

## Guide

In the following steps, we explore how to create and use identities to access the Infisical API using the OIDC Auth authentication method.

<Steps>
  <Step title="Creating an identity">
    To create an identity, head to your Organization Settings > Access Control > Identities and press **Create identity**.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-org.png" alt="identities organization" />

    When creating an identity, you specify an organization level [role](/documentation/platform/access-controls/role-based-access-controls) for it to assume; you can configure roles in Organization Settings > Access Control > Organization Roles.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-org-create.png" alt="identities organization create" />

    Now input a few details for your new identity. Here's some guidance for each field:

    * Name (required): A friendly name for the identity.
    * Role (required): A role from the **Organization Roles** tab for the identity to assume. The organization role assigned will determine what organization level resources this identity can have access to.

    Once you've created an identity, you'll be redirected to a page where you can manage the identity.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-page.png" alt="identities page" />

    Since the identity has been configured with Universal Auth by default, you should re-configure it to use OIDC Auth instead. To do this, press to edit the **Authentication** section,
    remove the existing Universal Auth configuration, and add a new OIDC Auth configuration onto the identity.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-page-remove-default-auth.png" alt="identities page remove default auth" />

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-org-create-oidc-auth-method.png" alt="identities create oidc auth method" />

    <Warning>Restrict access by configuring the Subject, Audiences, and Claims fields</Warning>

    Here's some more guidance on each field:

    * OIDC Discovery URL: The URL used to retrieve the OpenID Connect configuration from the identity provider. This will be used to fetch the public key needed for verifying the provided JWT. For GitLab SaaS (GitLab.com), this should be set to `https://gitlab.com`. For self-hosted GitLab instances, use the domain of your GitLab instance.
    * Issuer: The unique identifier of the identity provider issuing the JWT. This value is used to verify the iss (issuer) claim in the JWT to ensure the token is issued by a trusted provider. This should also be set to the domain of the Gitlab instance.
    * CA Certificate: The PEM-encoded CA cert for establishing secure communication with the Identity Provider endpoints. For GitLab.com, this can be left blank.
    * Subject: The expected principal that is the subject of the JWT. For GitLab pipelines, this should be set to a string that uniquely identifies the pipeline and its context, in the format `project_path:{group}/{project}:ref_type:{type}:ref:{branch_name}` (e.g., `project_path:example-group/example-project:ref_type:branch:ref:main`).
    * Claims: Additional information or attributes that should be present in the JWT for it to be valid. You can refer to GitLab's [documentation](https://docs.gitlab.com/ee/ci/secrets/id_token_authentication.html#token-payload) for the list of supported claims.
    * Access Token TTL (default is `2592000` equivalent to 30 days): The lifetime for an acccess token in seconds. This value will be referenced at renewal time.
    * Access Token Max TTL (default is `2592000`  equivalent to 30 days): The maximum lifetime for an acccess token in seconds. This value will be referenced at renewal time.
    * Access Token Max Number of Uses (default is `0`): The maximum number of times that an access token can be used; a value of `0` implies infinite number of uses.
    * Access Token Trusted IPs: The IPs or CIDR ranges that access tokens can be used from. By default, each token is given the `0.0.0.0/0`, allowing usage from any network address.
      <Tip>For more details on the appropriate values for the OIDC fields, refer to GitLab's [documentation](https://docs.gitlab.com/ee/ci/secrets/id_token_authentication.html#token-payload). </Tip>
      <Info>The `subject`, `audiences`, and `claims` fields support glob pattern matching; however, we highly recommend using hardcoded values whenever possible.</Info>
  </Step>

  <Step title="Adding an identity to a project">
    To enable the identity to access project-level resources such as secrets within a specific project, you should add it to that project.

    To do this, head over to the project you want to add the identity to and go to Project Settings > Access Control > Machine Identities and press **Add identity**.

    Next, select the identity you want to add to the project and the project level role you want to allow it to assume. The project role assigned will determine what project level resources this identity can have access to.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-project.png" alt="identities project" />

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-project-create.png" alt="identities project create" />
  </Step>

  <Step title="Accessing the Infisical API with the identity">
    As demonstration, we will be using the Infisical CLI to fetch Infisical secrets and utilize them within a GitLab pipeline.

    To access Infisical secrets as the identity, you need to use an identity token from GitLab which matches the OIDC configuration defined for the machine identity.
    This can be done by defining the `id_tokens` property. The resulting token would then be used to login with OIDC like the following: `infisical login --method=oidc-auth --oidc-jwt=$GITLAB_TOKEN`

    Below is a complete example of how a GitLab pipeline can be configured to work with secrets from Infisical using the Infisical CLI with OIDC Auth:

    ```yaml  theme={"dark"}
    image: ubuntu

    stages:
    - build

    build-job:
    stage: build
    id_tokens:
        INFISICAL_ID_TOKEN:
            aud: infisical-aud-test
    script:
        - apt update && apt install -y curl
        - curl -1sLf 'https://dl.cloudsmith.io/public/infisical/infisical-cli/setup.deb.sh' | bash
        - apt-get update && apt-get install -y infisical
        - export INFISICAL_TOKEN=$(infisical login --method=oidc-auth --machine-identity-id=4e807a78-1b1c-4bd6-9609-ef2b0cf4fd54 --oidc-jwt=$INFISICAL_ID_TOKEN --silent --plain)
        - infisical run --projectId=1d0443c1-cd43-4b3a-91a3-9d5f81254a89 --env=dev -- npm run build
    ```

    The `id_tokens` keyword is used to request an ID token for the job. In this example, an ID token named `INFISICAL_ID_TOKEN` is requested with the audience (`aud`) claim set to "infisical-aud-test". This ID token will be used to authenticate with Infisical.

    <Note>
      Each identity access token has a time-to-live (TTL) which you can infer from the response of the login operation; the default TTL is `7200` seconds, which can be adjusted.

      If an identity access token expires, it can no longer authenticate with the Infisical API. In this case, a new access token should be obtained by performing another login operation.
    </Note>
  </Step>
</Steps>


# SPIFFE/SPIRE
Source: https://infisical.com/docs/documentation/platform/identities/oidc-auth/spire

Learn how to authenticate SPIRE workloads with Infisical using OpenID Connect (OIDC).

**OIDC Auth** is a platform-agnostic JWT-based authentication method that can be used to authenticate from any platform or environment using an identity provider with OpenID Connect.

## Diagram

The following sequence diagram illustrates the OIDC Auth workflow for authenticating SPIRE workloads with Infisical.

```mermaid  theme={"dark"}
sequenceDiagram
  participant Client as SPIRE Workload
  participant Agent as SPIRE Agent
  participant Server as SPIRE Server
  participant Infis as Infisical

  Client->>Agent: Step 1: Request JWT-SVID
  Agent->>Server: Validate workload and fetch signing key
  Server-->>Agent: Return signing material
  Agent-->>Client: Return JWT-SVID with verifiable claims

  Note over Client,Infis: Step 2: Login Operation
  Client->>Infis: Send JWT-SVID to /api/v1/auth/oidc-auth/login

  Note over Infis,Server: Step 3: Query verification
  Infis->>Server: Request JWT public key using OIDC Discovery
  Server-->>Infis: Return public key

  Note over Infis: Step 4: JWT validation
  Infis->>Client: Return short-lived access token

  Note over Client,Infis: Step 5: Access Infisical API with Token
  Client->>Infis: Make authenticated requests using the short-lived access token
```

## Concept

At a high-level, Infisical authenticates a SPIRE workload by verifying the JWT-SVID and checking that it meets specific requirements (e.g. it is issued by a trusted SPIRE server) at the `/api/v1/auth/oidc-auth/login` endpoint. If successful,
then Infisical returns a short-lived access token that can be used to make authenticated requests to the Infisical API.

To be more specific:

1. The SPIRE workload requests a JWT-SVID from the local SPIRE Agent.
2. The SPIRE Agent validates the workload's identity and requests signing material from the SPIRE Server.
3. The SPIRE Agent returns a JWT-SVID containing the workload's SPIFFE ID and other claims.
4. The JWT-SVID is sent to Infisical at the `/api/v1/auth/oidc-auth/login` endpoint.
5. Infisical fetches the public key that was used to sign the JWT-SVID from the SPIRE Server using OIDC Discovery.
6. Infisical validates the JWT-SVID using the public key provided by the SPIRE Server and checks that the subject, audience, and claims of the token matches with the set criteria.
7. If all is well, Infisical returns a short-lived access token that the workload can use to make authenticated requests to the Infisical API.

<Note>Infisical needs network-level access to the SPIRE Server's OIDC Discovery endpoint.</Note>

## Prerequisites

Before following this guide, ensure you have:

* A running SPIRE deployment with both SPIRE Server and SPIRE Agent configured
* OIDC Discovery Provider deployed alongside your SPIRE Server
* Workload registration entries created in SPIRE for the workloads that need to access Infisical
* Network connectivity between Infisical and your OIDC Discovery Provider endpoint

For detailed SPIRE setup instructions, refer to the [SPIRE documentation](https://spiffe.io/docs/latest/spire-about/).

## OIDC Discovery Provider Setup

To enable JWT-SVID verification with Infisical, you need to deploy the OIDC Discovery Provider alongside your SPIRE Server. The OIDC Discovery Provider runs as a separate service that exposes the necessary OIDC endpoints.

In Kubernetes deployments, this is typically done by adding an `oidc-discovery-provider` container to your SPIRE Server StatefulSet:

```yaml  theme={"dark"}
- name: spire-oidc
  image: ghcr.io/spiffe/oidc-discovery-provider:1.12.2
  args:
    - -config
    - /run/spire/oidc/config/oidc-discovery-provider.conf
  ports:
    - containerPort: 443
      name: spire-oidc-port
```

The OIDC Discovery Provider will expose the OIDC Discovery endpoint at `https://<spire-oidc-host>/.well-known/openid_configuration`, which Infisical will use to fetch the public keys for JWT-SVID verification.

<Note>For detailed setup instructions, refer to the [SPIRE OIDC Discovery Provider documentation](https://github.com/spiffe/spire/tree/main/support/oidc-discovery-provider).</Note>

## Guide

In the following steps, we explore how to create and use identities to access the Infisical API using the OIDC Auth authentication method with SPIFFE/SPIRE.

<Steps>
  <Step title="Creating an identity">
    To create an identity, head to your Organization Settings > Access Control > Identities and press **Create identity**.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-org.png" alt="identities organization" />

    When creating an identity, you specify an organization level [role](/documentation/platform/access-controls/role-based-access-controls) for it to assume; you can configure roles in Organization Settings > Access Control > Organization Roles.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-org-create.png" alt="identities organization create" />

    Now input a few details for your new identity. Here's some guidance for each field:

    * Name (required): A friendly name for the identity.
    * Role (required): A role from the **Organization Roles** tab for the identity to assume. The organization role assigned will determine what organization level resources this identity can have access to.

    Once you've created an identity, you'll be redirected to a page where you can manage the identity.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-page.png" alt="identities page" />

    Since the identity has been configured with Universal Auth by default, you should re-configure it to use OIDC Auth instead. To do this, press to edit the **Authentication** section,
    remove the existing Universal Auth configuration, and add a new OIDC Auth configuration onto the identity.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-page-remove-default-auth.png" alt="identities page remove default auth" />

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-org-create-oidc-auth-method.png" alt="identities create oidc auth method" />

    <Warning>Restrict access by configuring the Subject, Audiences, and Claims fields</Warning>

    Here's some more guidance on each field:

    * OIDC Discovery URL: The URL used to retrieve the OpenID Connect configuration from the SPIRE Server. This will be used to fetch the public key needed for verifying the provided JWT-SVID. This should be set to your SPIRE Server's OIDC Discovery endpoint, typically `https://<spire-server-host>:<port>/.well-known/openid_configuration`
    * Issuer: The unique identifier of the SPIRE Server issuing the JWT-SVID. This value is used to verify the iss (issuer) claim in the JWT-SVID to ensure the token is issued by a trusted SPIRE Server. This should match your SPIRE Server's configured issuer, typically `https://<spire-server-host>:<port>`
    * CA Certificate: The PEM-encoded CA certificate for establishing secure communication with the SPIRE Server endpoints. This should contain the CA certificate that signed your SPIRE Server's TLS certificate.
    * Subject: The expected SPIFFE ID that is the subject of the JWT-SVID. The format of the sub field for SPIRE JWT-SVIDs follows the SPIFFE ID format: `spiffe://<trust-domain>/<workload-path>`. For example: `spiffe://example.org/workload/api-server`
    * Audiences: A list of intended recipients for the JWT-SVID. This value is checked against the aud (audience) claim in the token. When workloads request JWT-SVIDs from SPIRE, they specify an audience (e.g., `infisical` or your service name). Configure this to match what your workloads use.
    * Claims: Additional information or attributes that should be present in the JWT-SVID for it to be valid. Standard SPIRE JWT-SVID claims include `sub` (SPIFFE ID), `aud` (audience), `exp` (expiration), and `iat` (issued at). You can also configure custom claims if your SPIRE Server includes additional metadata.
    * Access Token TTL (default is `2592000` equivalent to 30 days): The lifetime for an access token in seconds. This value will be referenced at renewal time.
    * Access Token Max TTL (default is `2592000` equivalent to 30 days): The maximum lifetime for an access token in seconds. This value will be referenced at renewal time.
    * Access Token Max Number of Uses (default is `0`): The maximum number of times that an access token can be used; a value of `0` implies infinite number of uses.
    * Access Token Trusted IPs: The IPs or CIDR ranges that access tokens can be used from. By default, each token is given the `0.0.0.0/0`, allowing usage from any network address.
      <Tip>SPIRE JWT-SVIDs contain standard claims like `sub` (SPIFFE ID), `aud` (audience), `exp`, and `iat`. The audience is typically specified when requesting the JWT-SVID (e.g., `spire-agent api fetch jwt -audience infisical`).</Tip>
      <Info>The `subject`, `audiences`, and `claims` fields support glob pattern matching; however, we highly recommend using hardcoded SPIFFE IDs whenever possible for better security.</Info>
  </Step>

  <Step title="Adding an identity to a project">
    To enable the identity to access project-level resources such as secrets within a specific project, you should add it to that project.

    To do this, head over to the project you want to add the identity to and go to Project Settings > Access Control > Machine Identities and press **Add identity**.

    Next, select the identity you want to add to the project and the project level role you want to allow it to assume. The project role assigned will determine what project level resources this identity can have access to.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-project.png" alt="identities project" />

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-project-create.png" alt="identities project create" />
  </Step>

  <Step title="Using JWT-SVID to authenticate with Infisical">
    Here's an example of how a workload can use its JWT-SVID to authenticate with Infisical and retrieve secrets:

    ```bash  theme={"dark"}
    #!/bin/bash

    # Obtain JWT-SVID from SPIRE Agent
    JWT_SVID=$(spire-agent api fetch jwt -audience infisical -socketPath /run/spire/sockets/agent.sock | grep -A1 "token(" | tail -1)

    # Authenticate with Infisical using the JWT-SVID
    ACCESS_TOKEN=$(curl -s -X POST \
        -H "Content-Type: application/json" \
        -d "{\"identityId\":\"<your-identity-id>\",\"jwt\":\"$JWT_SVID\"}" \
        https://app.infisical.com/api/v1/auth/oidc-auth/login | jq -r '.accessToken')

    # Use the access token to retrieve secrets
    curl -s -H "Authorization: Bearer $ACCESS_TOKEN" \
        "https://app.infisical.com/api/v3/secrets/raw?workspaceSlug=<project-slug>&environment=<env-slug>&secretPath=/"
    ```

    <Note>
      Each identity access token has a time-to-live (TTL) which you can infer from the response of the login operation;
      the default TTL is `7200` seconds which can be adjusted.

      If an identity access token expires, it can no longer authenticate with the Infisical API. In this case,
      a new access token should be obtained by performing another login operation.
    </Note>

    <Tip>
      JWT-SVIDs from SPIRE have their own expiration time (typically short-lived). Ensure your application handles both JWT-SVID renewal from SPIRE and access token renewal from Infisical appropriately.
    </Tip>
  </Step>
</Steps>


# Terraform Cloud
Source: https://infisical.com/docs/documentation/platform/identities/oidc-auth/terraform-cloud

How to authenticate with Infisical from Terraform Cloud using OIDC.

This guide will walk you through setting up Terraform Cloud to inject a [workload identity token](https://developer.hashicorp.com/terraform/cloud-docs/workspaces/dynamic-provider-credentials/workload-identity-tokens) and use it for OIDC-based authentication with the Infisical Terraform provider. You'll start by creating a machine identity in Infisical, then configure Terraform Cloud to pass the injected token into your Terraform runs.

<Steps>
  <Step title="Create a Machine Identity in Infisical">
    Follow the instructions [in this documentation](/documentation/platform/identities/oidc-auth/general) to create a machine identity with OIDC auth. Infisical OIDC configuration values for Terraform Cloud:

    1. Set the OIDC Discovery URL to [https://app.terraform.io](https://app.terraform.io).

    2. Set the Issuer to [https://app.terraform.io](https://app.terraform.io).

    3. Configure the Audience to match the value you will use for **TFC\_WORKLOAD\_IDENTITY\_AUDIENCE** in Terraform Cloud for the next step.

    To view all possible claims available from Terraform cloud, visit [HashiCorps documentation](https://developer.hashicorp.com/terraform/cloud-docs/workspaces/dynamic-provider-credentials/workload-identity-tokens#token-structure).
  </Step>

  <Step title="Enable Workload Identity Token Injection in Terraform Cloud">
    <Tabs>
      <Tab title="Generate single token">
        1. **Navigate to your workspace** in Terraform Cloud.
        2. **Add a workspace variable** named `TFC_WORKLOAD_IDENTITY_AUDIENCE`:

        * **Key**: `TFC_WORKLOAD_IDENTITY_AUDIENCE`
        * **Value**: For example, `my-infisical-audience`
        * **Category**: Environment

        > **Important**:
        >
        > * The presence of `TFC_WORKLOAD_IDENTITY_AUDIENCE` is required for Terraform Cloud to inject a token.
        > * If you are self-hosting HCP Terraform agents, ensure they are **v1.7.0 or above**.

        Once set, Terraform Cloud will inject a workload identity token into the run environment as `TFC_WORKLOAD_IDENTITY_TOKEN`.
      </Tab>

      <Tab title="(Optional) Generate Multiple Tokens">
        If you need multiple tokens (each with a different audience), create additional variables:

        ```
        TFC_WORKLOAD_IDENTITY_AUDIENCE_[YOUR_TAG_HERE]
        ```

        For example:

        * `TFC_WORKLOAD_IDENTITY_AUDIENCE_INFISICAL`
        * `TFC_WORKLOAD_IDENTITY_AUDIENCE_OTHER_SERVICE`

        Terraform Cloud will then inject:

        * `TFC_WORKLOAD_IDENTITY_TOKEN_INFISICAL`
        * `TFC_WORKLOAD_IDENTITY_TOKEN_OTHER_SERVICE`

        > **Note**:
        >
        > * The `[YOUR_TAG_HERE]` can only contain letters, numbers, and underscores.
        > * You **cannot** use the reserved keyword `TYPE`.
        > * Generating multiple tokens requires **v1.12.0 or later** if you are self-hosting agents.
      </Tab>
    </Tabs>

    <Warning>
      If you are running on self-hosted HCP Terraform agents, you must use v1.7.0 or later to enable token injection. If you need to generate multiple tokens, you must use v1.12.0 or later.
    </Warning>
  </Step>

  <Step title="Configure the Infisical Provider">
    In your Terraform configuration, reference the injected token by name. For example:

    ```hcl  theme={"dark"}
    provider "infisical" {
      host = "https://app.infisical.com"

      auth = {
        oidc = {
          identity_id = "<identity-id>"
          # This must match the environment variable Terraform injects:
          token_environment_variable_name = "TFC_WORKLOAD_IDENTITY_TOKEN"
        }
      }
    }
    ```

    * **`host`**: Defaults to `https://app.infisical.com`. Override if using a self-hosted Infisical instance.
    * **`identity_id`**: The OIDC identity ID from Infisical.
    * **`token_environment_variable_name`**: Must match the injected variable name from Terraform Cloud. If using single token, use `TFC_WORKLOAD_IDENTITY_TOKEN`. If using multiple tokens, choose the one you want to use (e.g., `TFC_WORKLOAD_IDENTITY_TOKEN_INFISICAL`).
  </Step>

  <Step title="Validate Your Setup">
    1. Run a plan and apply in Terraform Cloud.
    2. Verify the Infisical provider authenticates successfully without issues. If you run into authentication errors, double-check the Infisical identity has the correct roles/permissions in Infisical.
  </Step>
</Steps>


# User and Machine Identities
Source: https://infisical.com/docs/documentation/platform/identities/overview

Learn more about identities to interact with resources in Infisical.

To interact with secrets and resource with Infisical, it is important to understand the concept of identities.
Identities can be of two types:

* **People** (e.g., developers, platform engineers, administrators)
* **Machines** (e.g., machine entities for managing secrets in CI/CD pipelines, production applications, and more)

Both people and machines are able to utilize corresponding clients (e.g., Dashboard UI, CLI, SDKs, API, Kubernetes Operator) together with allowed authentication methods (e.g., email & password, SAML SSO, LDAP, OIDC, Universal Auth).

<CardGroup cols={2}>
  <Card href="./user-identities" title="People (User Identities)" icon="people" color="#000000">
    Learn more about the concept on user identities in Infisical.
  </Card>

  <Card title="Machine Identities" href="./machine-identities" icon="computer" color="#000000">
    Understand the concept of machine identities in Infisical.
  </Card>
</CardGroup>


# TLS Certificate Auth
Source: https://infisical.com/docs/documentation/platform/identities/tls-cert-auth

Learn how to authenticate with Infisical using TLS Certificate.

**TLS Certificate Auth** is an authentication method that verifies a user's TLS Client certificate using the provided CA Certificate, allowing secure access to Infisical resources.

## Diagram

The following sequence diagram illustrates the TLS Certificate Auth workflow for authenticating users with Infisical.

```mermaid  theme={"dark"}
sequenceDiagram
  participant Client
  participant Infisical

  Note over Client,Client: Step 1: Setup your TLS request with the client certificate

  Note over Client,Infisical: Step 2: Login Operation
  Client->>Infisical: Send request to /api/v1/auth/tls-cert-auth/login

  Note over Infisical: Step 3: Request verification using CA Certificate

  Infisical->>Client: Return short-lived access token

  Note over Client,Infisical: Step 5: Access Infisical API with token
  Client->>Infisical: Make authenticated requests using the short-lived access token
```

## Concept

At a high level, Infisical authenticates the client's TLS Certificate by verifying its identity and checking that it meets specific requirements (e.g., it is bound to the allowed common names) at the `/api/v1/auth/tls-cert-auth/login` endpoint. If successful, Infisical returns a short-lived access token that can be used to make authenticated requests to the Infisical API.

To be more specific:

1. The client sends a TLS request with the client certificate to Infisical at the `/api/v1/auth/tls-cert-auth/login` endpoint.
2. Infisical verifies the incoming request using the provided CA certificate.
3. Infisical checks the user's properties against set criteria such as Allowed Common Names.
4. If all checks pass, Infisical returns a short-lived access token that the client can use to make authenticated requests to the Infisical API.

<Accordion title="TLS with Load Balancer/Proxy">
  Most of the time, the Infisical server will be behind a load balancer or
  proxy. To propagate the TLS certificate from the load balancer to the
  instance, you can configure the TLS to send the client certificate as a header
  that is set as an [environment variable](/self-hosting/configuration/envars#param-identity-tls-cert-auth-client-certificate-header-key).
</Accordion>

<Note>
  Infisical US/EU and dedicated instances are deployed with AWS ALB. TLS Certificate Auth must flow through our ALB mTLS pass-through in order to authenticate.
  When you are authenticating with TLS Certificate Auth, you must use the port `8443` instead of the default `443`. Example: `https://app.infisical.com:8443/api/v1/auth/tls-cert-auth/login`
</Note>

## Guide

In the following steps, we explore how to create and use identities for your workloads and applications on TLS Certificate to
access the Infisical API using request signing.

<Warning>
  **Self-Hosted Users:** Before using TLS Certificate Auth, please review the
  [Security Requirements for Self-Hosted
  Deployments](#security-requirements-for-self-hosted-deployments) section below
  to ensure proper configuration and avoid security vulnerabilities.
</Warning>

### Creating an identity

To create an identity, head to your Organization Settings > Access Control > [Identities](https://app.infisical.com/organization/access-management?selectedTab=identities) and press **Create identity**.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-org.png" alt="identities organization" />

When creating an identity, you specify an organization-level [role](/documentation/platform/access-controls/role-based-access-controls) for it to assume; you can configure roles in Organization Settings > Access Control > [Organization Roles](https://app.infisical.com/organization/access-management?selectedTab=roles).

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-org-create.png" alt="identities organization create" />

Input some details for your new identity:

* **Name (required):** A friendly name for the identity.
* **Role (required):** A role from the [**Organization Roles**](https://app.infisical.com/organization/access-management?selectedTab=roles) tab for the identity to assume. The organization role assigned will determine what organization-level resources this identity can have access to.

Once you've created an identity, you'll be redirected to a page where you can manage the identity.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-page.png" alt="identities page" />

Since the identity has been configured with [Universal Auth](https://infisical.com/docs/documentation/platform/identities/universal-auth) by default, you should reconfigure it to use TLS Certificate Auth instead. To do this, click the cog next to **Universal Auth** and then select **Delete** in the options dropdown.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-press-cog.png" alt="identities press cog" />

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-page-remove-default-auth.png" alt="identities page remove default auth" />

Now create a new TLS Certificate Auth Method.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-tls-cert-auth-create-auth.png" alt="identities create tls cert auth method" />

Here's some information about each field:

* **CA Certificate:** A PEM encoded CA Certificate used to validate incoming TLS request client certificate.
* **Allowed Common Names:** A comma separated list of client certificate common names allowed.
* **Access Token TTL (default is `2592000` equivalent to 30 days):** The lifetime for an access token in seconds. This value will be referenced at renewal time.
* **Access Token Max TTL (default is `2592000` equivalent to 30 days):** The maximum lifetime for an access token in seconds. This value will be referenced at renewal time.
* **Access Token Max Number of Uses (default is `0`):** The maximum number of times that an access token can be used; a value of `0` implies an infinite number of uses.
* **Access Token Trusted IPs:** The IPs or CIDR ranges that access tokens can be used from. By default, each token is given the `0.0.0.0/0`, allowing usage from any network address.

### Adding an identity to a project

In order to allow an identity to access project-level resources such as secrets, you must add it to the relevant projects.

To do this, head over to the project you want to add the identity to and navigate to Project Settings > Access Control > Machine Identities and press **Add Identity**.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-project.png" alt="identities project" />

Select the identity you want to add to the project and the project-level role you want it to assume. The project role given to the identity will determine what project-level resources this identity can access.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-project-create.png" alt="identities project create" />

### Accessing the Infisical API with the identity

To access the Infisical API as the identity, you need to send a TLS request to `/api/v1/auth/tls-cert-auth/login` endpoint.

Below is an example of how you can authenticate with Infisical using NodeJS.

```javascript  theme={"dark"}
const fs = require("fs");
const https = require("https");
const axios = require("axios");

try {
  const clientCertificate = fs.readFileSync("client-cert.pem", "utf8");
  const clientKeyCertificate = fs.readFileSync("client-key.pem", "utf8");

  const infisicalUrl = "https://app.infisical.com:8443"; // or your self-hosted Infisical URL
  const identityId = "<your-identity-id>";

  // Create HTTPS agent with client certificate and key
  const httpsAgent = new https.Agent({
    cert: clientCertificate,
    key: clientKeyCertificate,
  });

  const { data } = await axios.post(
    `${infisicalUrl}/api/v1/auth/tls-cert-auth/login`,
    {
      identityId,
    },
    {
      httpsAgent: httpsAgent, // Pass the HTTPS agent with client cert
    }
  );

  console.log("result data: ", data); // access token here
} catch (err) {
  console.error(err);
}
```

<Note>
  Each identity access token has a time-to-live (TTL) which you can infer from the response of the login operation; the default TTL is `7200` seconds, which can be adjusted.

  If an identity access token expires, it can no longer access the Infisical API. A new access token should be obtained by performing another login operation.
</Note>

## Security Requirements for Self-Hosted Deployments

ALL TLS cert [login](/api-reference/endpoints/tls-cert-auth/login) requests **MUST** go through a load balancer/proxy that verifies certificate ownership:

* **REQUIRED:** Configure your load balancer/proxy to **require a proper TLS handshake with client certificate presentation**
* **REQUIRED:** Ensure the load balancer **verifies the client possesses the private key** corresponding to the certificate (standard TLS behavior)
* **NEVER** allow direct connections to Infisical for TLS cert auth - this enables header injection attacks
* **NEVER** forward certificate headers without requiring proper TLS certificate presentation

### Load Balancer Configuration Examples

* **AWS ALB:** Use mTLS listeners which require client certificate presentation during the TLS handshake
* **NGINX/HAProxy:** Configure SSL client certificate requirement with proper TLS handshake verification

<Note>
  Infisical will handle the actual certificate validation against the configured
  CA certificate and determine authentication permissions. The load balancer's
  role is to ensure certificate ownership, not certificate trust validation.
</Note>


# Token Auth
Source: https://infisical.com/docs/documentation/platform/identities/token-auth

Learn how to authenticate to Infisical from any platform or environment using an access token.

**Token Auth** is a platform-agnostic, simple authentication method that can be configured for a [machine identity](/documentation/platform/identities/machine-identities) to authenticate from any platform/environment using a token.

## Diagram

The following sequence diagram illustrates the Token Auth workflow for authenticating clients with Infisical.

```mermaid  theme={"dark"}
sequenceDiagram
  participant Client as Client
  participant Infis as Infisical

  Note over Client,Infis: Access Infisical API with Token
  Client->>Infis: Make authenticated requests using the token

```

## Concept

Token Auth is the simplest authentication method that a client can use to authenticate with Infisical.

Unlike other authentication methods where a client must exchange credential(s) for a short-lived access token to access the Infisical API,
Token Auth allows a client to make authenticated requests to the Infisical API directly using a token. Conceptually, this is similar to using an API Key.

To be more specific:

1. An operator creates an access token in the Infisical UI.
2. The operator shares the access token with the client which it can then use to make authenticated requests to the Infisical API.

## Guide

In the following steps, we explore how to create and use identities for your workloads and applications to access the Infisical API
using the Token Auth authentication method.

<Steps>
  <Step title="Creating an identity">
    To create an identity, head to your Organization Settings > Access Control > Identities and press **Create identity**.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-org.png" alt="identities organization" />

    When creating an identity, you specify an organization level [role](/documentation/platform/access-controls/role-based-access-controls) for it to assume; you can configure roles in Organization Settings > Access Control > Organization Roles.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-org-create.png" alt="identities organization create" />

    Now input a few details for your new identity. Here's some guidance for each field:

    * Name (required): A friendly name for the identity.
    * Role (required): A role from the **Organization Roles** tab for the identity to assume. The organization role assigned will determine what organization level resources this identity can have access to.

    Once you've created an identity, you'll be redirected to a page where you can manage the identity.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-page.png" alt="identities page" />

    Since the identity has been configured with Universal Auth by default, you should re-configure it to use Token Auth instead. To do this, press to edit the **Authentication** section,
    remove the existing Universal Auth configuration, and add a new Token Auth configuration onto the identity.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-page-remove-default-auth.png" alt="identities page remove default auth" />

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-org-create-token-auth-method.png" alt="identities organization create token auth method" />

    Here's some more guidance on each field:

    * Access Token TTL (default is `2592000` equivalent to 30 days): The lifetime for an acccess token in seconds. This value will be referenced at renewal time.
    * Access Token Max TTL (default is `2592000`  equivalent to 30 days): The maximum lifetime for an acccess token in seconds. This value will be referenced at renewal time.
    * Access Token Max Number of Uses (default is `0`): The maximum number of times that an access token can be used; a value of `0` implies infinite number of uses.
    * Access Token Trusted IPs: The IPs or CIDR ranges that access tokens can be used from. By default, each token is given the `0.0.0.0/0`, allowing usage from any network address.

    <Warning>
      Restricting access token usage to specific trusted IPs is a paid feature.

      If youre using Infisical Cloud, then it is available under the Pro Tier. If youre self-hosting Infisical, then you should contact [sales@infisical.com](mailto:sales@infisical.com) to purchase an enterprise license to use it.
    </Warning>
  </Step>

  <Step title="Creating a Token">
    In order to use the identity with Token Auth, you'll need to create an (access) token; you can think of this token akin
    to an API Key used to authenticate with the Infisical API. With that, press **Create Token**.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-token-auth-create-1.png" alt="identities client secret create" />

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-token-auth-create-2.png" alt="identities client secret create" />

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-token-auth-create-3.png" alt="identities client secret create" />

    Copy the token and keep it handy as you'll need it to authenticate with the Infisical API.
  </Step>

  <Step title="Adding an identity to a project">
    To enable the identity to access project-level resources such as secrets within a specific project, you should add it to that project.

    To do this, head over to the project you want to add the identity to and go to Project Settings > Access Control > Machine Identities and press **Add identity**.

    Next, select the identity you want to add to the project and the project level role you want to allow it to assume. The project role assigned will determine what project level resources this identity can have access to.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-project.png" alt="identities project" />

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-project-create.png" alt="identities project create" />
  </Step>

  <Step title="Accessing the Infisical API with the identity">
    To access the Infisical API as the identity, you can use the generated access token from step 2
    to authenticate with the [Infisical API](/api-reference/overview/introduction).

    <Note>
      Each identity access token has a time-to-live (TTL) which you can infer from the response of the login operation;
      the default TTL is `7200` seconds which can be adjusted in the Token Auth configuration.

      If an identity access token expires, it can no longer authenticate with the Infisical API. In this case,
      a new access token should be obtained.
    </Note>
  </Step>
</Steps>

**FAQ**

<AccordionGroup>
  <Accordion title="Why is the Infisical API rejecting my access token?">
    There are a few reasons for why this might happen:

    * The access token has expired. If this is the case, you should obtain a new access token or consider extending the token's TTL.
    * The identity is insufficiently permissioned to interact with the resources you wish to access.
    * The access token is being used from an untrusted IP.
  </Accordion>

  <Accordion title="What is access token renewal and TTL/Max TTL?">
    A identity access token can have a time-to-live (TTL) or incremental lifetime after which it expires.

    In certain cases, you may want to extend the lifespan of an access token; to do so, you must set a max TTL parameter.

    A token can be renewed any number of times where each call to renew it can extend the token's lifetime by increments of the access token's TTL.
    Regardless of how frequently an access token is renewed, its lifespan remains bound to the maximum TTL determined at its creation.
  </Accordion>
</AccordionGroup>


# Universal Auth
Source: https://infisical.com/docs/documentation/platform/identities/universal-auth

Learn how to authenticate to Infisical from any platform or environment.

**Universal Auth** is a platform-agnostic authentication method that can be configured for a [machine identity](/documentation/platform/identities/machine-identities) to authenticate from any platform/environment using a Client ID and Client Secret.
This authentication method supports setting token periods, which can help [overcome secret zero](#solving-secret-zero-with-periodic-tokens).

## Diagram

The following sequence diagram illustrates the Universal Auth workflow for authenticating clients with Infisical.

```mermaid  theme={"dark"}
sequenceDiagram
  participant Client as Client
  participant Infis as Infisical

  Note over Client,Infis: Step 1: Login Operation
  Client->>Infis: Send Client ID and Client Secret

  Note over Infis: Step 2: Client ID and Client Secret validation
  Infis->>Client: Return short-lived access token

  Note over Client,Infis: Step 3: Access Infisical API with Token
  Client->>Infis: Make authenticated requests using the short-lived access token
```

## Concept

In this method, Infisical authenticates a client by verifying the credentials issued for it at the `/api/v1/auth/universal-auth/login` endpoint. If successful,
then Infisical returns a short-lived access token that can be used to make authenticated requests to the Infisical API.

To be more specific:

1. The client submits a **Client ID** and **Client Secret** to Infisical at the `/api/v1/auth/universal-auth/login` endpoint.
2. Infisical verifies the credential pair.
3. If all is well, Infisical returns a short-lived access token that the client can use to make authenticated requests to the Infisical API.

## Guide

In the following steps, we explore how to create and use identities for your workloads and applications to access the Infisical API
using the Universal Auth authentication method.

<Steps>
  <Step title="Creating an identity">
    To create an identity, head to your Organization Settings > Access Control > Identities and press **Create identity**.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-org.png" alt="identities organization" />

    When creating an identity, you specify an organization level [role](/documentation/platform/access-controls/role-based-access-controls) for it to assume; you can configure roles in Organization Settings > Access Control > Organization Roles.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-org-create.png" alt="identities organization create" />

    Now input a few details for your new identity. Here's some guidance for each field:

    * Name (required): A friendly name for the identity.
    * Role (required): A role from the **Organization Roles** tab for the identity to assume. The organization role assigned will determine what organization level resources this identity can have access to.

    Once you've created an identity, you'll be redirected to a page where you can manage the identity.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-page.png" alt="identities page" />

    Once you've created an identity, you'll be prompted to configure the **Universal Auth** authentication method for it.

    By default, the identity has been configured with Universal Auth. If you wish, you can edit the Universal Auth configuration
    details by pressing to edit the **Authentication** section.

    Here's some guidance on each field:

    **Configuration Tab**

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-org-create-universal-auth-method-1.png" alt="identities organization create universal auth method 1" />

    * Access Token TTL (default is `2592000` equivalent to 30 days): The lifetime for an access token in seconds. This value will be referenced at renewal time.
    * Access Token Max TTL (default is `2592000`  equivalent to 30 days): The maximum lifetime for an access token in seconds. This value will be referenced at renewal time.
    * Access Token Max Number of Uses (default is `0`): The maximum number of times that an access token can be used; a value of `0` implies infinite number of uses.
    * Access Token Period (optional, default is `0`): If set, the access token becomes a renewable, non-expiring token for the specified period (in seconds). TTL and Max TTL are ignored when this is set. This is ideal for "secret zero" scenarios, where a workload needs to bootstrap itself securely without hard-coded static secrets.

    **Lockout Tab**

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-org-create-universal-auth-method-2.png" alt="identities organization create universal auth method 2" />

    * Lockout (enabled by default): The lockout feature will temporarily block login attempts after X consecutive login failures.
    * Lockout Threshold (default is `3`): The amount of times login must fail before locking the identity auth method.
    * Lockout Duration (default is `5 minutes`): How long an identity auth method lockout lasts.
    * Lockout Counter Reset (default is `30 seconds`): How long to wait from the most recent failed login until resetting the lockout counter.

    **Advanced Tab**

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-org-create-universal-auth-method-3.png" alt="identities organization create universal auth method 3" />

    * Client Secret Trusted IPs: The IPs or CIDR ranges that the **Client Secret** can be used from together with the **Client ID** to get back an access token. By default, **Client Secrets** are given the `0.0.0.0/0`, allowing usage from any network address.
    * Access Token Trusted IPs: The IPs or CIDR ranges that access tokens can be used from. By default, each token is given the `0.0.0.0/0`, allowing usage from any network address.

    <Warning>
      Restricting **Client Secret** and access token usage to specific trusted IPs is a paid feature.

      If you're using Infisical Cloud, then it is available under the Pro Tier. If you're self-hosting Infisical, then you should contact [sales@infisical.com](mailto:sales@infisical.com) to purchase an enterprise license to use it.
    </Warning>
  </Step>

  <Step title="Creating a Client Secret">
    In order to use the identity, you'll need the non-sensitive **Client ID**
    of the identity and a **Client Secret** for it; you can think of these credentials akin to a username
    and password used to authenticate with the Infisical API.
    With that, press **Create Client Secret**.

    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-universal-auth-create-1.png" alt="identities client secret create" />
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-universal-auth-create-2.png" alt="identities client secret create" />
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-universal-auth-create-3.png" alt="identities client secret create" />

    Feel free to input any (optional) details for the **Client Secret** configuration:

    * Description: A description for the **Client Secret**.
    * TTL (default is `0`): The time-to-live for the **Client Secret**. By default, the TTL will be set to 0 which implies that the **Client Secret** will never expire; a value of `0` implies an infinite lifetime.
    * Max Number of Uses (default is `0`): The maximum number of times that the **Client Secret** can be used together with the **Client ID** to get back an access token; a value of `0` implies infinite number of uses.
  </Step>

  <Step title="Adding an identity to a project">
    To enable the identity to access project-level resources such as secrets within a specific project, you should add it to that project.

    To do this, head over to the project you want to add the identity to and go to Project Settings > Access Control > Machine Identities and press **Add identity**.

    Next, select the identity you want to add to the project and the project level role you want to allow it to assume. The project role assigned will determine what project level resources this identity can have access to.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-project.png" alt="identities project" />

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-project-create.png" alt="identities project create" />
  </Step>

  <Step title="Accessing the Infisical API with the identity">
    To access the Infisical API as the identity, you should first perform a login operation
    that is to exchange the **Client ID** and **Client Secret** of the identity for an access token
    by making a request to the `/api/v1/auth/universal-auth/login` endpoint.

    <Tip>
      Choose the correct base URL based on your region:

      * For Infisical Cloud US users: `https://app.infisical.com`
      * For Infisical Cloud EU users: `https://eu.infisical.com`
    </Tip>

    #### Sample request

    ```bash Request theme={"dark"}
    curl --location --request POST 'https://app.infisical.com/api/v1/auth/universal-auth/login' \
      --header 'Content-Type: application/x-www-form-urlencoded' \
      --data-urlencode 'clientId=...' \
      --data-urlencode 'clientSecret=...'
    ```

    #### Sample response

    ```bash Response theme={"dark"}
    {
      "accessToken": "...",
      "expiresIn": 7200,
      "accessTokenMaxTTL": 43244
      "tokenType": "Bearer"
    }
    ```

    Next, you can use the access token to authenticate with the [Infisical API](/api-reference/overview/introduction)

    <Note>
      Each identity access token has a time-to-live (TTL) which you can infer from the response of the login operation;
      the default TTL is `7200` seconds which can be adjusted in the Universal Auth configuration.

      If an identity access token expires, it can no longer authenticate with the Infisical API. In this case,
      a new access token should be obtained by performing another login operation.
    </Note>
  </Step>
</Steps>

## Solving Secret Zero with Periodic Tokens

In many automated, cloud-native, or ephemeral environments (such as VMs, containers, or serverless functions), it is often unsafe or impractical to hard-code long-lived credentials for bootstrapping access to secrets management systems. The "secret zero" problem refers to the challenge of securely providing a workload with its initial credential, without manual intervention or static secrets that could be leaked or reused. Periodic tokens in Universal Auth are designed to solve this problem by enabling secure, automated bootstrapping and ongoing access renewal, even in dynamic or short-lived environments.

A common challenge in cloud-native and automated environments is the "secret zero" problem: how to securely bootstrap a workload (such as a VM, container, or serverless function) with its first credential, without hard-coding static secrets or requiring manual intervention.

**Periodic tokens** in Universal Auth solve this by allowing you to issue an access token that can be continuously renewed by your workload before it expires (i.e., a client-initiated rotation mechanism):

* When you set the **Access Token Period** in the Universal Auth configuration, the issued access token can be renewed by your workload for the specified period (in seconds).
* The token can be renewed any number of times, each time for the same period, with no maximum lifetime (unless you set a use limit).
* As long as the token is renewed before its period expires, it remains valid, so you do not need to re-issue static credentials.
* TTL and Max TTL are ignored when Access Token Period is set.

### Example: Bootstrapping with a Periodic Token

1. Configure Universal Auth for your identity and set **Access Token Period** (e.g., `3600` for 1 hour).
2. For improved security, configure the Client Secret with a low number of uses (e.g., `1`) or a short TTL. This ensures that after the initial login, the Client Secret cannot be reused, and any disruption in token renewal will require manual intervention.
3. Deploy your workload with the **Client Secret** and **Client ID**.
4. The workload authenticates with Infisical using the Client Secret and Client ID to obtain the initial access token (JWT).
5. The workload uses the access token to authenticate and continuously renews it before expiration:

```bash  theme={"dark"}
curl --location --request POST 'https://app.infisical.com/api/v1/auth/universal-auth/renew' \
  --header 'Authorization: Bearer <accessToken>'
```

This approach allows your workload to securely bootstrap and maintain access to Infisical without hard-coded secrets, solving the secret zero problem.

**FAQ**

<AccordionGroup>
  <Accordion title="Why is the Infisical API rejecting my identity credentials?">
    There are a few reasons for why this might happen:

    * The client secret or access token has expired.
    * The identity is insufficiently permissioned to interact with the resources you wish to access.
    * The client secret/access token is being used from an untrusted IP.
  </Accordion>

  <Accordion title="What is access token renewal and TTL/Max TTL?">
    A identity access token can have a time-to-live (TTL) or incremental lifetime after which it expires.

    In certain cases, you may want to extend the lifespan of an access token; to do so, you must set a max TTL parameter.

    A token can be renewed any number of times where each call to renew it can extend the token's lifetime by increments of the access token's TTL.
    Regardless of how frequently an access token is renewed, its lifespan remains bound to the maximum TTL determined at its creation.
  </Accordion>

  <Accordion title="How do I reset a lockout?">
    You can reset (remove) all lockouts for an identity auth method by clicking into the auth method and pressing **Reset All Lockouts**.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/ua-reset-lockouts.png" alt="ua reset lockouts" />
  </Accordion>
</AccordionGroup>


# User Identities
Source: https://infisical.com/docs/documentation/platform/identities/user-identities

Read more about the concept of user identities in Infisical.

## Concept

A **user identity** (also known as **user**) represents a developer, admin, or any other human entity interacting with resources in Infisical.

Users can be added manually (through Web UI) or programmatically (e.g., API) to [organizations](../organization) and [projects](../project).

Upon being added to an organization and projects, users assume a certain set of roles and permissions that represents their identity.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/organization/organization-users.png" alt="organization users" />

## Authentication methods

To interact with various resources in Infisical, users are able to utilize a number of authentication methods:

* **Email & Password**: the most common authentication method that is used for authentication into Web Dashboard and Infisical CLI. It is recommended to utilize [Multi-factor Authentication](/documentation/platform/mfa) in addition to it.
* **SSO**: Infisical natively integrates with a number of SSO identity providers like [Google](/documentation/platform/sso/google), [GitHub](/documentation/platform/sso/github), and [GitLab](/documentation/platform/sso/gitlab).
* **SAML SSO**: It is also possible to set up SAML SSO integration with identity providers like [Okta](/documentation/platform/sso/okta), [Microsoft Entra ID](/documentation/platform/sso/azure) (formerly known as Azure AD), [JumpCloud](/documentation/platform/sso/jumpcloud), [Google](/documentation/platform/sso/google-saml), and more.
* **LDAP**: For organizations with more advanced needs, Infisical also provides user authentication with [LDAP](/documentation/platform/ldap/overview) that includes a number of LDAP providers.


# AWS CloudHSM
Source: https://infisical.com/docs/documentation/platform/kms-configuration/aws-hsm

Learn how to manage encryption using AWS CloudHSM

This guide provides instructions on securing Infisical project secrets using AWS CloudHSM.
Integration with AWS CloudHSM is achieved by configuring it as a custom key store for AWS KMS.
Follow the steps below to set up AWS KMS with AWS CloudHSM as the custom key store.

## Prepare AWS CloudHSM Cluster

Before you get started, you'll need to configure a AWS CloudHSM cluster which meets the following criteria:

* The cluster must be active.
* The cluster must not be associated with any other AWS KMS custom key store.
* The cluster must be configured with private subnets in at least two Availability Zones in the Region.
* The security group for the cluster must include inbound and outbound rules that allow TCP traffic on ports 2223-2225.
* The cluster must contain at least two active HSMs in different Availability Zones.

For more details on setting up your cluster, refer to the following [AWS documentation](https://docs.aws.amazon.com/kms/latest/developerguide/create-keystore.html#before-keystore).

## Set Up AWS KMS Custom Key Store

To set up an AWS KMS custom key store with AWS CloudHSM, you will need the following:

* The trust anchor certificate of your AWS CloudHSM cluster.
* A `kmsuser` user in the AWS CloudHSM cluster with the crypto-user role.

<Steps>
  <Step title="Navigate to Key store creation page">
    In the AWS console, head over to `AWS KMS` > `AWS CloudHSM key stores` and click **Create key store**.
  </Step>

  <Step title="Add key store name">
    Input the custom key store name. <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/kms/aws-hsm/create-key-store-name.png" alt="Set key store name" />
  </Step>

  <Step title="Select HSM cluster">
    Select the AWS CloudHSM cluster. You should be able to select the cluster if it meets the required criteria mentioned above.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/kms/aws-hsm/create-key-store-cluster.png" alt="Set key store cluster" />
  </Step>

  <Step title="Upload trust anchor certificate">
    Upload your CloudHSM's cluster trust anchor certificate file.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/kms/aws-hsm/create-key-store-cert.png" alt="Set key store cert" />
  </Step>

  <Step title="Provide cluster user password">
    Input the password of the `kmsuser` crypto-user in your cluster.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/kms/aws-hsm/create-key-store-password.png" alt="Set key store password" />
  </Step>

  <Step title="Finish key store creation">
    Proceed with creating the AWS CloudHSM key store.
  </Step>
</Steps>

For more details, refer to the following [AWS documentation](https://docs.aws.amazon.com/kms/latest/developerguide/create-keystore.html#create-keystore-console).

## Create AWS KMS Key

Next, you'll need to create a AWS KMS key where you will set the key store you created previously.

<Steps>
  <Step title="Navigate to AWS KMS key creation page">
    In your AWS console, proceed to `AWS KMS` > `Customer managed keys` and click **Create**.
  </Step>

  <Step title="Set key options">
    Set Key type to `Symmetric` and Key usage to `Encrypt and decrypt`.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/kms/aws-hsm/create-kms-key-1.png" alt="Set key options 1" />
  </Step>

  <Step title="Select key material origin">
    In the advanced options, for the Key material origin field, select `AWS CloudHSM key store`. Then, click next.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/kms/aws-hsm/create-kms-key-2.png" alt="Set key options 2" />
  </Step>

  <Step title="Choose key store">
    Select the AWS CloudHSM key store you created earlier.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/kms/aws-hsm/create-kms-select-hsm.png" alt="Select HSM 1" />
  </Step>

  <Step title="Finish KMS key creation">
    Proceed with creating the AWS KMS Key.
  </Step>
</Steps>

## Connect Infisical to AWS KMS Key

You should now have an AWS KMS that has a custom key store set to AWS CloudHSM.
To secure project resources, you will need to add this AWS KMS to your Infisical organization. To learn how, refer to the documentation [here](./aws-kms).


# AWS Key Management Service
Source: https://infisical.com/docs/documentation/platform/kms-configuration/aws-kms

Learn how to manage encryption using AWS KMS

To enhance the security of your Infisical projects, you can now encrypt your secrets using an external Key Management Service (KMS).
When external KMS is configured for your project, all encryption and decryption operations will be handled by the chosen KMS.
This guide will walk you through the steps needed to configure external KMS support with AWS KMS.

## Prerequisites

* An AWS KMS Key configured as a `Symmetric` key and with `Encrypt and Decrypt` key usage.
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/kms/aws/aws-kms-key-create.png" alt="Create AWS KMS Key" />

Before you begin, you'll first need to choose a method of authentication with AWS from below.

<Tabs>
  <Tab title="Method 1: Assume Role (Recommended)">
    <Steps>
      <Step title="Create the Managing User IAM Role">
        1. Navigate to the [Create IAM Role](https://console.aws.amazon.com/iamv2/home#/roles/create?step=selectEntities) page in your AWS Console.
           <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/aws/integration-aws-iam-assume-role.png" alt="IAM Role Creation" />

        2. Select **AWS Account** as the **Trusted Entity Type**.

        3. Select **Another AWS Account** and provide the appropriate Infisical AWS Account ID: use **381492033652** for the **US region**, and **345594589636** for the **EU region**. This restricts the role to be assumed only by Infisical. If you are self-hosting, provide the AWS account number where Infisical is hosted.

        <Note>
          **For Dedicated Instances**: Your AWS account ID differs from the one provided above. Please reach out to Infisical support to obtain your AWS account ID.
        </Note>

        4. Optionally, enable **Require external ID** and enter your Infisical **project ID** to further enhance security.
      </Step>

      <Step title="Add Required Permissions for the IAM Role">
        Use the following custom policy to grant the minimum permissions required by Infisical to integrate with AWS KMS

        ```json  theme={"dark"}
        {
          "Version": "2012-10-17",
          "Statement": [
            {
              "Sid": "AllowKMSAccess",
              "Effect": "Allow",
                "Action": [
                  "kms:Decrypt",
                  "kms:Encrypt",
                  "kms:DescribeKey"
              ],
              "Resource": "*"
            }
          ]
        }
        ```
      </Step>
    </Steps>
  </Tab>

  <Tab title="Method 2: Access Key">
    Navigate to your IAM user and add a policy to grant the following permissions:

    ```json  theme={"dark"}
    {
      "Version": "2012-10-17",
      "Statement": [
        {
          "Sid": "AllowKMSAccess",
          "Effect": "Allow",
            "Action": [
              "kms:Decrypt",
              "kms:Encrypt",
              "kms:DescribeKey"
          ],
          "Resource": "*"
        }
      ]
    }
    ```
  </Tab>
</Tabs>

## Setup AWS KMS in the Organization Settings

Next, you will need to follow the steps listed below to add AWS KMS for your organization.

<Steps>
  <Step title="Navigate to the organization settings and select the 'Encryption' tab.">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/kms/encryption-org-settings.png" alt="Open encryption org settings" />
  </Step>

  <Step title="Click on the 'Add' button">
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/kms/encryption-org-settings-add.png" alt="Add encryption org settings" />
    Click the 'Add' button to begin adding a new external KMS.
  </Step>

  <Step title="Select 'AWS KMS'">
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/kms/encryption-modal-provider-select.png" alt="Select Encryption Provider" />
    Choose 'AWS KMS' from the list of encryption providers.
  </Step>

  <Step title="Provide the inputs for AWS KMS">
    Selecting AWS as the provider will require you input the following fields.

    <ParamField path="Alias" type="string" required>
      Name for referencing the AWS KMS key within the organization.
    </ParamField>

    <ParamField path="Description" type="string">
      Short description of the AWS KMS key.
    </ParamField>

    <ParamField path="Authentication Mode" type="string" required>
      Authentication mode for AWS, either "AWS Assume Role" or "Access Key".
    </ParamField>

    <ParamField path="IAM Role ARN For Role Assumption" type="string">
      ARN of the AWS role to assume for providing Infisical access to the AWS KMS Key (required if Authentication Mode is "AWS Assume Role")
    </ParamField>

    <ParamField path="Assume Role External ID" type="string">
      Custom identifier for additional validation during role assumption.
    </ParamField>

    <ParamField path="Access Key ID" type="string">
      AWS IAM Access Key ID for authentication (required if Authentication Mode is "Access Key").
    </ParamField>

    <ParamField path="Secret Access Key" type="string">
      AWS IAM Secret Access Key for authentication (required if Authentication Mode is "Access Key").
    </ParamField>

    <ParamField path="AWS Region" type="string" required>
      AWS region where the AWS KMS Key is located.
    </ParamField>

    <ParamField path="AWS KMS Key ID" type="string">
      Key ID of the AWS KMS Key. If left blank, Infisical will generate and use a new AWS KMS Key in the specified region.
      <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/kms/aws/aws-kms-key-id.png" alt="AWS KMS key ID" />
    </ParamField>
  </Step>

  <Step title="Click Save">
    Save your configuration to apply the settings.
  </Step>
</Steps>

You now have an AWS KMS Key configured at the organization level. You can assign these AWS KMS keys to existing Infisical projects by visiting the 'Project Settings' page.

## Assign AWS KMS Key to an Existing Project

To assign the AWS KMS key you added to your organization, follow the steps below.

<Steps>
  <Step title="Open Project Settings and select to the Encryption Tab">
        <img
          src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/kms/aws/encryption-project-settings.png"
          alt="Open encryption project
    settings"
        />
  </Step>

  <Step title="Under the Key Management section, select your newly added AWS KMS key from the dropdown">
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/kms/aws/encryption-project-settings-select.png" alt="Select encryption project
    settings" />
    Choose the AWS KMS key you configured earlier.
  </Step>

  <Step title="Click Save">
    Once you have selected the KMS of choice, click save.
  </Step>
</Steps>


# GCP Key Management Service
Source: https://infisical.com/docs/documentation/platform/kms-configuration/gcp-kms

Learn how to manage encryption using GCP KMS

To enhance the security of your Infisical projects, you can now encrypt your secrets using an external Key Management Service (KMS).
When external KMS is configured for your project, all encryption and decryption operations will be handled by the chosen KMS.
This guide will walk you through the steps needed to configure external KMS support with Google Cloud KMS.

## Prerequisites

Before you begin, you'll first need to set up a GCP Service Account, add a KMS key and set the required permissions.

<Steps>
  <Step title="Create a GCP Service Account">
    1. Navigate to the [Create Service Account](https://console.cloud.google.com/iam-admin/serviceaccounts/create) page in your GCP Console.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/kms/gcp/service-account-form.png" alt="GCP Service Account Creation" />

    2. Give the service account a suitable **name** and **description**. Then click **Create and Continue**.

    3. Under **Grant this service account access to project**, click **Select a role** and select the
       **Cloud KMS Viewer** and **Cloud KMS CryptoKey Encrypter/Decrypter**\* roles, then click **Continue**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/kms/gcp/service-account-permissions.png" alt="GCP Service Account Permissions" />

    4. You can skip the **Grant users access to this service account** options.

    5. Click Done.

    6. You should see the service account in the list of service accounts. Click it to view the service account details.

    7. Select the **Keys** tab, click **Add Key**, select **Create new key**, select **JSON** as the key type, then click **Create**.

    8. You will be prompted to download a JSON file that we will need later on.

    <Info>
      Remember to keep the JSON file in a secure location. It will be used to authenticate your GCP service account.

      Once you have successfully set up GCP KMS with Infisical, you should permanently delete the JSON file.
    </Info>
  </Step>

  <Step title="Add a GCP KMS Key">
    1. Navigate to the [KMS](https://console.cloud.google.com/security/kms) page in your GCP Console.

    <Info>
      If you have not used GCP KMS before, you will be redirected to the **Cloud Key Management Service (KMS) API** page.

      Click **Enable** to enable the KMS API, then continue the steps below.

      It may take a few minutes for the API to be enabled and KMS section of the Cloud Console to become viewable.
    </Info>

    2. In the KMS section, click **Create Key Ring**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/kms/gcp/keyring-create.png" alt="GCP Create Key Ring" />

    3. Give the key ring a **Name** and select a **Region**, then click **Create**.

    <Info>
      We don't currently support multi-region key rings.
    </Info>

    4. On the "Create Key" page, give the key a **Name** and set the **Protection Level** based on your requirements (or use default *Software*), then click **Continue**.

    5. Under **Key Material**, select **Generated Key**, then click **Continue**.

    6. Under **Purpose**, select **Symmetric encrypt/decrypt**, then click **Continue**.

    7. For **Key Rotation Period**, select **Never (manual rotation)**, then click **Continue** followed by **Create**.

    8. You should see the key in the list of keys. We're now ready to set it up in Infisical.
  </Step>
</Steps>

## Setup GCP KMS in the Organization Settings

Next, you will need to follow the steps listed below to add GCP KMS for your organization.

<Steps>
  <Step title="Navigate to the organization settings and select the 'Encryption' tab.">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/kms/encryption-org-settings.png" alt="Open encryption org settings" />
  </Step>

  <Step title="Click on the 'Add' button">
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/kms/encryption-org-settings-add.png" alt="Add encryption org settings" />
    Click the 'Add' button to begin adding a new external KMS.
  </Step>

  <Step title="Select 'GCP KMS'">
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/kms/encryption-modal-provider-select.png" alt="Select Encryption Provider" />
    Choose 'GCP KMS' from the list of encryption providers.
  </Step>

  <Step title="Provide the inputs for GCP KMS">
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/kms/gcp/gcp-add-modal-filled.png" alt="GCP Create KMS Modal" />
    Selecting GCP as the provider will require you input the following fields.

    <ParamField path="Alias" type="string" required>
      Name for referencing the GCP KMS key within the organization.
    </ParamField>

    <ParamField path="Description" type="string">
      Short description of the GCP KMS key.
    </ParamField>

    <ParamField path="GCP Region" type="dropdown" required>
      The GCP region where the GCP KMS key ring is located.
    </ParamField>

    <ParamField path="Service Account Credential JSON" type="file" required>
      Upload the JSON file you downloaded earlier when creating the GCP service account.
    </ParamField>

    <ParamField path="GCP Key Name" type="dropdown" required>
      This field will be populated with the list of GCP KMS keys in the selected region. Select the key you created earlier.
    </ParamField>
  </Step>

  <Step title="Click Save">
    Save your configuration to apply the settings.
  </Step>
</Steps>

You now have a GCP KMS Key configured at the organization level. You can assign these GCP KMS keys to existing Infisical projects by visiting the 'Project Settings' page.

## Assign GCP KMS Key to an Existing Project

To assign the GCP KMS key you added to your organization, follow the steps below.

<Steps>
  <Step title="Open Project Settings and select to the Encryption Tab">
        <img
          src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/kms/gcp/project-settings.png"
          alt="Open encryption project
    settings"
        />
  </Step>

  <Step title="Under the Key Management section, select your newly added GCP KMS key from the dropdown">
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/kms/gcp/select-gcp-kms-in-project.png" alt="Select encryption project
    settings" />
    Choose the GCP KMS key you configured earlier.
  </Step>

  <Step title="Click Save">
    Once you have selected the KMS of choice, click save.
  </Step>
</Steps>


# Key Management Service (KMS) Configuration
Source: https://infisical.com/docs/documentation/platform/kms-configuration/overview

Learn how to configure your project's encryption

## Introduction

Infisical leverages a Key Management Service (KMS) to securely encrypt and decrypt secrets in your projects.

## Overview

Infisical's KMS ensures the security of your project's secrets through the following mechanisms:

* Each project is assigned a unique workspace key, which is responsible for encrypting and decrypting secret values.
* The workspace key itself is encrypted using the project's configured KMS.
* When secrets are requested, the workspace key is derived from the configured KMS. This key is then used to decrypt the secret values on-demand before sending them to the requesting client.

## Configuration

You can set the KMS for new projects during project creation.
<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/kms/configure-kms-new.png" alt="Configure KMS new" />
For existing projects, you can configure the KMS from the Project Settings page.
<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/kms/configure-kms-existing.png" alt="Configure KMS existing" />

## External KMS

Infisical supports the use of external KMS solutions to enhance security and compliance. You can configure your project to use services like [AWS Key Management Service](./aws-kms) or [GCP Key Management Service](./gcp-kms) for managing encryption.


# HSM Integration
Source: https://infisical.com/docs/documentation/platform/kms/hsm-integration

Learn more about integrating an HSM with Infisical KMS.

<Note>
  Changing the encryption strategy for your instance is an Enterprise-only feature.
  This section is intended for users who have obtained an Enterprise license and are on-premise.

  Please reach out to [sales@infisical.com](mailto:sales@infisical.com) if you have any questions.
</Note>

## Overview

Infisical KMS currently supports two encryption strategies:

1. **Standard Encryption**: This is the default encryption strategy used by Infisical KMS. It uses a software-protected encryption key to encrypt KMS keys within your Infisical instance. The root encryption key is defined by setting the `ENCRYPTION_KEY` environment variable.
2. **Hardware Security Module (HSM)**: This encryption strategy uses a Hardware Security Module (HSM) to create a root encryption key that is stored on a physical device to encrypt the KMS keys within your instance.

## Hardware Security Module (HSM)

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/kms/hsm/hsm-illustration.png" alt="HSM Illustration" />

Using a hardware security module comes with the added benefit of having a secure and tamper-proof device to store your encryption keys. This ensures that your data is protected from unauthorized access.

<Warning>
  All encryption keys used for cryptographic operations are stored within the HSM. This means that if the HSM is lost or destroyed, you will no longer be able to decrypt your data stored within Infisical. Most providers offer recovery options for HSM devices, which you should consider when setting up an HSM device.
</Warning>

Enabling HSM encryption has a set of key benefits:

1. **Root Key Wrapping**: The root KMS encryption key that is used to secure your Infisical instance will be encrypted using the HSM device rather than the standard software-protected key.

#### Caveats

* **Performance**: Using an HSM device can have a performance impact on your Infisical instance. This is due to the additional latency introduced by the HSM device. This is however only noticeable when your instance(s) start up or when the encryption strategy is changed.
* **Key Recovery**: If the HSM device is lost or destroyed, you will no longer be able to decrypt your data stored within Infisical. Most HSM providers offer recovery options, which you should consider when setting up an HSM device.

## Requirements

* An HSM device *(PKCS#11 compatible library)* from a compatible provider such as [Thales Luna HSM](https://cpl.thalesgroup.com/encryption/data-protection-on-demand/services/luna-cloud-hsm), [AWS CloudHSM](https://aws.amazon.com/cloudhsm/), [Fortanix HSM](https://www.fortanix.com/platform/data-security-manager), or others.
  Infisical is validated to work with PKCS#11 2.30 and newer. If your HSM device doesn't follow the >=2.30 PKCS#11 standard you may see degraded performance.

## Environment Variable Configuration

To configure your Infisical instance to use an HSM, you must set the required environment variables. Below you'll find an example of the required environment variables.
For further instructions on how to configure the HSM device for your Infisical instance, please see the [Setup Instructions](#setup-instructions) section.

```dotenv  theme={"dark"}
HSM_LIB_PATH=/usr/local/lib/cloudhsm/cloudhsm.so
HSM_SLOT=1
HSM_KEY_LABEL=infisical-key
HSM_PIN=your:pin
```

* `HSM_LIB_PATH`: The path to the PKCS#11 library provided by the HSM provider. This usually comes in the form of a `.so` for Linux and MacOS, or a `.dll` file for Windows. For Docker, you need to mount the library path as a volume. Further instructions can be found below. If you are using Docker, make sure to set the HSM\_LIB\_PATH environment variable to the path where the library is mounted in the container.
* `HSM_PIN`: The PKCS#11 PIN to use for authentication with the HSM device.
* `HSM_SLOT`: The slot number to use for the HSM device. This is typically between `0` and `5` for most HSM devices.
* `HSM_KEY_LABEL`: The label of the key to use for encryption. **Please note that if no key is found with the provided label, the HSM will create a new key with the provided label.**

You can read more about the [default instance configurations](/self-hosting/configuration/envars) here.

## PKCS#11 Key Attributes

If no AES key or HMAC key already exists with the label you defined on the `HSM_KEY_LABEL` environment variable, then Infisical will create one for you automatically using the label specified on `HSM_KEY_LABEL`.
Below you'll find a list of the attributes each key will be created with.

### AES Key

<Accordion title="Bring your own key minimum requirements (optional)">
  If you bring your own AES key and don't let Infisical create it for you it must have at least the following attributes:

  * `CKA_CLASS`: `CKO_SECRET_KEY`  Defines the key class *(secret key)*.
  * `CKA_KEY_TYPE`: `CKO_AES`  Defines the key type *(AES key)*.
  * `CKA_VALUE_LEN`: `32`  256-bit key size.
  * `CKA_ENCRYPT`: `true`  Encryption capabilities enabled.
  * `CKA_DECRYPT`: `true`  Decryption capabilities enabled.
  * `CKA_TOKEN`: `true`  The key material will persist in your HSM so it can be reused.

  <Warning>
    Note that for security reasons it is highly recommended to create an AES key with the full set of key attributes seen below if you're going to bring your own key.
  </Warning>
</Accordion>

* `CKA_CLASS`: `CKO_SECRET_KEY`  Defines the key class *(secret key)*.
* `CKA_KEY_TYPE`: `CKO_AES`  Defines the key type *(AES key)*.
* `CKA_VALUE_LEN`: `32`  256-bit key size.
* `CKA_LABEL`: Your specified label in the `HSM_KEY_LABEL` environment variable.
* `CKA_ENCRYPT`: `true`  Encryption capabilities enabled.
* `CKA_DECRYPT`: `true`  Decryption capabilities enabled.
* `CKA_TOKEN`: `true`  The key material will persist in your HSM so it can be reused.
* `CKA_EXTRACTABLE`: `false`  The key material is not extractable from the HSM.
* `CKA_SENSITIVE`: `true`  The key material is marked as sensitive.
* `CKA_PRIVATE`: `true`  The key material is marked as private to the slot and can't be accessed from other slots.

### HMAC Key

<Accordion title="Bring your own key minimum requirements (optional)">
  If you bring your own HMAC key and don't let Infisical create it for you it must have at least the following attributes:

  * `CKA_CLASS`: `CKO_SECRET_KEY`  Defines the key class *(secret key)*.
  * `CKA_KEY_TYPE`: `CKO_GENERIC_SECRET`  Defines the key class *(generic secret key)*.
  * `CKA_VALUE_LEN`: `32`  256-bit key size
  * `CKA_SIGN`: `true`  Signing capabilities enabled
  * `CKA_VERIFY`: `true`  Verifying capabilities enabled.
  * `CKA_TOKEN`: `true`  The key material will persist in your HSM so it can be reused.

  <Warning>
    Note that for security reasons it is highly recommended to create an HMAC key with the full set of key attributes seen below if you're going to bring your own key.
  </Warning>
</Accordion>

* `CKA_CLASS`: `CKO_SECRET_KEY`  Defines the key class *(secret key)*.
* `CKA_KEY_TYPE`: `CKO_GENERIC_SECRET`  Defines the key class *(generic secret key)*.
* `CKA_VALUE_LEN`: `32`  256-bit key size.
* `CKA_LABEL`: Your specified label in the `HSM_KEY_LABEL` environment variable, suffixed with `_HMAC`. If you specify `infisical-key-v1`, then the HMAC key label will become `infisical-key-v1_HMAC`.
* `CKA_SIGN`: `true`  Signing capabilities enabled
* `CKA_VERIFY`: `true`  Verifying capabilities enabled.
* `CKA_TOKEN`: `true`  The key material will persist in your HSM so it can be reused.
* `CKA_EXTRACTABLE`: `false`  The key material is not extractable from the HSM.
* `CKA_SENSITIVE`: `true`  The key material is marked as sensitive.
* `CKA_PRIVATE`: `true`  The key material is marked as private to the slot and can't be accessed from other slots.

## Setup Instructions

<Steps>
  <Step title="Setting up an HSM Device">
    To set up HSM encryption, you need to configure an HSM provider and HSM key. The HSM provider is used to connect to the HSM device, and the HSM key is used to encrypt Infisical's KMS keys. We recommend using a Cloud HSM provider such as [Thales Luna HSM](https://cpl.thalesgroup.com/encryption/data-protection-on-demand/services/luna-cloud-hsm), [AWS CloudHSM](https://aws.amazon.com/cloudhsm/), or [Fortanix HSM](https://www.fortanix.com/platform/data-security-manager).

    You need to follow the instructions provided by the HSM provider to set up the HSM device. Once the HSM device is set up, the HSM device can be used within Infisical.

    After setting up the HSM from your provider, you will have a set of files that you can use to access the HSM. These files need to be present on the machine where Infisical is running.
    If you are using containers, you will need to mount the folder where these files are stored as a volume in the container.

    The setup process for an HSM device varies depending on the provider. We have created guides for Thales Luna Cloud HSM and Fortanix HSM, which you can find below.
  </Step>

  <Step title="Configure HSM on Infisical">
    <Warning>
      Are you using Docker or Kubernetes for your deployment? If you are using Docker or Kubernetes, please follow the instructions in the [Using HSM's in your Deployment](#using-hsms-in-your-deployment) section.
    </Warning>

    Configuring the HSM on Infisical requires setting a set of environment variables:

    * `HSM_LIB_PATH`: The path to the PKCS#11 library provided by the HSM provider. This usually comes in the form of a `.so` for Linux and MacOS, or a `.dll` file for Windows. For Docker, you need to mount the library path as a volume. Further instructions can be found below. If you are using Docker, make sure to set the HSM\_LIB\_PATH environment variable to the path where the library is mounted in the container.
    * `HSM_PIN`: The PKCS#11 PIN to use for authentication with the HSM device.
    * `HSM_SLOT`: The slot number to use for the HSM device. This is typically between `0` and `5` for most HSM devices.
    * `HSM_KEY_LABEL`: The label of the key to use for encryption. **Please note that if no key is found with the provided label, the HSM will create a new key with the provided label.**

    You can read more about the [default instance configurations](/self-hosting/configuration/envars) here.
  </Step>

  <Step title="Restart Instance">
    After setting up the HSM, you need to restart the Infisical instance for the changes to take effect.
  </Step>

  <Step title="Navigate to the Server Admin Console">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/kms/hsm/server-admin-console.png" alt="Server Admin Console" />
  </Step>

  <Step title="Update the KMS Encryption Strategy to HSM">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/kms/hsm/encryption-strategy.png" alt="Set Encryption Strategy" />

    Once you press the 'Save' button, your Infisical instance will immediately switch to the HSM encryption strategy. This will re-encrypt your KMS key with keys from the HSM device.
  </Step>

  <Step title="Verify Encryption Strategy">
    To verify that the HSM was correctly configured, you can try creating a new secret in one of your projects. If the secret is created successfully, the HSM is now being used for encryption.
  </Step>
</Steps>

## Using HSMs In Your Deployment

<Tabs>
  <Tab title="Docker">
    When using Docker, you need to mount the path containing the HSM client files. This section covers how to configure your Infisical instance to use an HSM with Docker.

    <Tabs>
      <Tab title="Thales Luna Cloud HSM">
        <Steps>
          <Step title="Create HSM client folder">
            When using Docker, you are able to set your HSM library path to any location on your machine. In this example, we are going to be using `/etc/luna-docker`.

            ```bash  theme={"dark"}
              mkdir /etc/luna-docker
            ```

            After [setting up your Luna Cloud HSM client](https://thalesdocs.com/gphsm/luna/7/docs/network/Content/install/client_install/add_dpod.htm), you should have a set of files, referred to as the HSM client. You don't need all the files, but for simplicity we recommend copying all the files from the client.

            A folder structure of a client folder will often look like this:

            ```
            partition-ca-certificate.pem
            partition-certificate.pem
            server-certificate.pem
            Chrystoki.conf
            /plugins
              libcloud.plugin
            /lock
            /libs
              /64
                libCryptoki2.so
            /jsp
              LunaProvider.jar
              /64
                libLunaAPI.so
            /etc
              openssl.cnf
            /bin
              /64
                ckdemo
                lunacm
                multitoken
                vtl
            ```

            The most important parts of the client folder is the `Chrystoki.conf` file, and the `libs`, `plugins`, and `jsp` folders. You need to copy these files to the folder you created in the first step.

            ```bash  theme={"dark"}
              cp -r /<path-to-where-your-luna-client-is-located> /etc/luna-docker
            ```
          </Step>

          <Step title="Update Chrystoki.conf">
            The `Chrystoki.conf` file is used to configure the HSM client. You need to update the `Chrystoki.conf` file to point to the correct file paths.

            In this example, we will be mounting the `/etc/luna-docker` folder to the Docker container under a different path. The path we will use in this example is `/usr/safenet/lunaclient`. This means `/etc/luna-docker` will be mounted to `/usr/safenet/lunaclient` in the Docker container.

            An example config file will look like this:

            ```Chrystoki.conf  theme={"dark"}
                Chrystoki2 = {
                  # This path points to the mounted path, /usr/safenet/lunaclient
                  LibUNIX64 = /usr/safenet/lunaclient/libs/64/libCryptoki2.so;
                }

                Luna = {
                  DefaultTimeOut = 500000;
                  PEDTimeout1 = 100000;
                  PEDTimeout2 = 200000;
                  PEDTimeout3 = 20000;
                  KeypairGenTimeOut = 2700000;
                  CloningCommandTimeOut = 300000;
                  CommandTimeOutPedSet = 720000;
                }

                CardReader = {
                  LunaG5Slots = 0;
                  RemoteCommand = 1;
                }

                Misc = {
                  # Update the paths to point to the mounted path if your folder structure is different from the one mentioned in the previous step.
                  PluginModuleDir = /usr/safenet/lunaclient/plugins;
                  MutexFolder = /usr/safenet/lunaclient/lock;
                  PE1746Enabled = 1;
                  ToolsDir = /usr/bin;

                }

                Presentation = {
                  ShowEmptySlots = no;
                }

                LunaSA Client = {
                  ReceiveTimeout = 20000;
                  # Update the paths to point to the mounted path if your folder structure is different from the one mentioned in the previous step.
                  SSLConfigFile = /usr/safenet/lunaclient/etc/openssl.cnf;
                  ClientPrivKeyFile = ./etc/ClientNameKey.pem;
                  ClientCertFile = ./etc/ClientNameCert.pem;
                  ServerCAFile = ./etc/CAFile.pem;
                  NetClient = 1;
                  TCPKeepAlive = 1;
                }


                REST = {
                  AppLogLevel = error
                  ServerName = <REDACTED>;
                  ServerPort = 443;
                  AuthTokenConfigURI = <REDACTED>;
                  AuthTokenClientId = <REDACTED>;
                  AuthTokenClientSecret = <REDACTED>;
                  RestClient = 1;
                  ClientTimeoutSec = 120;
                  ClientPoolSize = 32;
                  ClientEofRetryCount = 15;
                  ClientConnectRetryCount = 900;
                  ClientConnectIntervalMs = 1000;
                }
                XTC = {
                  Enabled = 1;
                  TimeoutSec = 600;
                }
            ```

            Save the file after updating the paths.
          </Step>

          <Step title="Run Docker">
            Running Docker with HSM encryption requires setting the HSM-related environment variables as mentioned previously in the [HSM setup instructions](#setup-instructions). You can set these environment variables in your Docker run command.

            We are setting the environment variables for Docker via the command line in this example, but you can also pass in a `.env` file to set these environment variables.

            <Warning>
              If no key is found with the provided key label, the HSM will create a new key with the provided label.
              Infisical depends on an AES and HMAC key to be present in the HSM. If these keys are not present, Infisical will create them. The AES key label will be the value of the `HSM_KEY_LABEL` environment variable, and the HMAC key label will be the value of the `HSM_KEY_LABEL` environment variable with the suffix `_HMAC`.
            </Warning>

            ```bash  theme={"dark"}
            docker run -p 80:8080 \
              -v /etc/luna-docker:/usr/safenet/lunaclient \
              -e HSM_LIB_PATH="/usr/safenet/lunaclient/libs/64/libCryptoki2.so" \
              -e HSM_PIN="<your-hsm-device-pin>" \
              -e HSM_SLOT=<hsm-device-slot> \
              -e HSM_KEY_LABEL="<your-key-label>" \

              # The rest are unrelated to HSM setup...
              -e ENCRYPTION_KEY="<>" \
              -e AUTH_SECRET="<>" \
              -e DB_CONNECTION_URI="<>" \
              -e REDIS_URL="<>" \
              -e SITE_URL="<>" \
              infisical/infisical:<version> # Replace <version> with the version you want to use
            ```

            We recommend reading further about [using Infisical with Docker](/self-hosting/deployment-options/standalone-infisical).
          </Step>
        </Steps>

        After following these steps, your Docker setup will be ready to use HSM encryption.
      </Tab>

      <Tab title="Fortanix HSM">
        <Steps>
          <Step title="Set up Fortanix HSM">
            To use Fortanix HSM with Infisical, you need to:

            1. Create an App in Fortanix:
               * Set Interface value to be PKCS#11
               * Select API key as authentication method
               * Assign app to a group

                        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/kms/hsm/fortanix-hsm-setup.png" alt="Fortanix HSM Setup" />

            2. Take note of the domain (e.g., apac.smartkey.io). You will need this to set up the configuration file for the Fortanix client.
          </Step>

          <Step title="Install PKCS11 Library">
            The easiest approach would be to download the `.so` file for Linux directly from the [Fortanix PKCS#11 installation page](https://fortanix.zendesk.com/hc/en-us/sections/4408769080724-PKCS-11).

            Create a configuration file named `pkcs11.conf` with the following content:

            ```
            api_endpoint = "https://apac.smartkey.io"
            prevent_duplicate_opaque_objects = true
            retry_timeout_millis = 60000
            ```

            Note: Replace `apac.smartkey.io` with your actual Fortanix domain if different. For more details about the configuration file format and additional options, refer to the [Fortanix PKCS#11 Configuration File Documentation](https://support.fortanix.com/docs/clients-pkcs11-library#511-configuration-file-format).
          </Step>

          <Step title="Create a directory for Fortanix files">
            Create a directory to store the Fortanix library and configuration file:

            ```bash  theme={"dark"}
            mkdir -p /etc/fortanix-hsm
            ```

            Copy the downloaded `.so` file and the `pkcs11.conf` file to this directory:

            ```bash  theme={"dark"}
            cp /path/to/fortanix_pkcs11_4.37.2554.so /etc/fortanix-hsm/
            cp /path/to/pkcs11.conf /etc/fortanix-hsm/
            ```
          </Step>

          <Step title="Run Docker">
            Run Docker with Fortanix HSM by mounting the directory and setting the required environment variables:

            ```bash  theme={"dark"}
            docker run -p 80:8080 \
              -v /etc/fortanix-hsm:/etc/fortanix-hsm \
              -e HSM_LIB_PATH="/etc/fortanix-hsm/fortanix_pkcs11_4.37.2554.so" \  # Path to the PKCS#11 library
              -e HSM_PIN="MDE3YWUxO..." \  # Your Fortanix app API key used for authentication
              -e HSM_SLOT=0 \              # Slot value (arbitrary for Fortanix HSM)
              -e HSM_KEY_LABEL="hsm-key-label" \  # Label to identify the encryption key in the HSM
              -e FORTANIX_PKCS11_CONFIG_PATH="/etc/fortanix-hsm/pkcs11.conf" \  # Path to Fortanix configuration file
              
              # The rest are unrelated to HSM setup...
              -e ENCRYPTION_KEY="<>" \
              -e AUTH_SECRET="<>" \
              -e DB_CONNECTION_URI="<>" \
              -e REDIS_URL="<>" \
              -e SITE_URL="<>" \
              infisical/infisical:<version> # Replace <version> with the version you want to use
            ```

            <Warning>
              Note: Fortanix HSM integration only works for AMD64 CPU architectures.
            </Warning>
          </Step>
        </Steps>

        After following these steps, your Docker setup will be ready to use Fortanix HSM encryption.
      </Tab>

      <Tab title="AWS CloudHSM">
        ### Prerequisites

        * An [activated AWS CloudHSM cluster](https://docs.aws.amazon.com/cloudhsm/latest/userguide/activate-cluster.html) with at least 1 HSM device.
        * A [HSM user with the `Crypto User` role](https://docs.aws.amazon.com/cloudhsm/latest/userguide/cloudhsm_cli-user-create.html). In this guide we are using a user with the username `testUser` and the password `testPassword`.

        <Steps>
          <Step title="Configure CloudHSM client">
            Before using the CloudHSM client, it must be configured properly so Infisical can use it for cryptographic operations.

            **1. Download the AWS CloudHSM client**

            You can download the AWS CloudHSM client from [the AWS documentation](https://docs.aws.amazon.com/cloudhsm/latest/userguide/pkcs11-library-install.html).

            <Note>
              Note that the AWS CloudHSM client is only available for Linux and Windows.
              If you're on a different operating system, you'll need to access a Linux machine to configure the client, such as an AWS EC2 Debian instance.
            </Note>

            **2. Configure the CloudHSM client**

            After installing the CloudHSM client, you should see all related files in the `/opt/cloudhsm/` directory on your machine.

            You need to run the `configure-pkcs11` binary which will configure the client to connect with your AWS CloudHSM cluster. Depending on if you have multiple HSM's inside your cluster, you'll need to run the command with different arguments. Below you'll find the appropriate command for your use case:

            <AccordionGroup>
              <Accordion title="Single HSM">
                ```bash  theme={"dark"}
                sudo /opt/cloudhsm/bin/configure-pkcs11 -a <HSM_ENI_IPV4_ADDRESS> --disable-key-availability-check
                ```

                <Info>
                  To use a single HSM, you must first manage client key durability settings by setting `disable_key_availability_check` to true by passing the `--disable-key-availability-check` flag. For more information read the [Key Synchronization](https://docs.aws.amazon.com/cloudhsm/latest/userguide/manage-key-sync.html) section in the AWS CloudHSM documentation.
                </Info>
              </Accordion>

              <Accordion title="Multiple HSM's">
                ```bash  theme={"dark"}
                sudo /opt/cloudhsm/bin/configure-pkcs11 -a <HSM_ENI_IPV4_ADDRESS_1> <HSM_ENI_IPV4_ADDRESS_2> ... --disable-key-availability-check
                ```
              </Accordion>
            </AccordionGroup>

            At this point you should have:

            1. [Activated the CloudHSM cluster](https://docs.aws.amazon.com/cloudhsm/latest/userguide/activate-cluster.html)
            2. [Created a Crypto User HSM user](https://docs.aws.amazon.com/cloudhsm/latest/userguide/cloudhsm_cli-user-create.html)
            3. Downloaded and configured the CloudHSM client as described in the previous steps.

            **3. Download the configured HSM client files**

            After configuring the CloudHSM client, you should notice that the PKCS11 configuration file has been updated to include the HSM's ENI IP address. You can find this file in the `/opt/cloudhsm/etc/cloudhsm-pkcs11.cfg` directory, and it should look like this:

            ```json cloudhsm-pkcs11.cfg theme={"dark"}
            {
              "clusters": [
                {
                  "type": "hsm1",
                  "cluster": {
                    // Your issuing CA certificate.
                    // As per AWS documentation, this defaults to `/opt/cloudhsm/etc/customerCA.crt`.
                    "hsm_ca_file": "/opt/cloudhsm/etc/customerCA.crt",
                    "servers": [
                      {
                        "hostname": "<HSM_ENI_IPV4_ADDRESS_1>",
                        "port": 2223,
                        "enable": true
                      },
                      {
                        "hostname": "<HSM_ENI_IPV4_ADDRESS_2>",
                        "port": 2223,
                        "enable": true
                      }
                    ],
                    // Only relevant if you passed the --disable-key-availability-check flag
                    "options": {
                      "disable_key_availability_check": true
                    }
                  }
                }
              ],
              "logging": {
                "log_type": "file",
                "log_file": "/opt/cloudhsm/run/cloudhsm-pkcs11.log",
                "log_level": "info",
                "log_interval": "daily"
              }
            }
            ```

            Save the entire `/opt/cloudhsm` folder, as you will need to mount this to your Infisical Docker container in the later steps. In this guide we will be saving all the files from the folder as `/etc/cloudhsm` and mounting it to the `/etc/cloudhsm` directory in the Docker container.
          </Step>

          <Step title="Find HSM slot number">
            On the same machine that you configured the CloudHSM client, you can use `pkcs11-tool` to find the HSM slot number and to verify that the client is working correctly.

            First, install the `pkcs11-tool` package:

            ```bash  theme={"dark"}
            sudo apt-get install opensc -y
            ```

            Then, run the following command to find the HSM slot number:

            ```bash  theme={"dark"}
            pkcs11-tool --module /opt/cloudhsm/lib/libcloudhsm_pkcs11.so --list-slots --login
            ```

            It'll prompt you to log in with your PIN, which is your username and password separated by a colon. Example: `testUser:testPassword`.

            This will output the HSM slot number like so:

            ```bash  theme={"dark"}
            ubuntu@ec-2:~$ pkcs11-tool --module /opt/cloudhsm/lib/libcloudhsm_pkcs11.so --list-slots
            Available slots:
            Slot 0 (0x2000000000000001): hsm1
              token label        : hsm1
              token manufacturer : Marvell Semiconductors, Inc.
              token model        : LS2
              token flags        : login required, rng, token initialized
              hardware version   : 66.48
              firmware version   : 10.2
              serial num         : 
              pin min/max        : 8/32
            ```

            In this case we see that the HSM has a slot in the position of `0`. This slot number will be used in the later steps to set the `HSM_SLOT` environment variable.
          </Step>

          <Step title="Download the HSM issuing CA certificate">
            When you initialized your HSM, you were prompted to download the cluster CSR and sign it.
            In order to use the HSM with Infisical, you need to obtain the issuer CA certificate that was used to sign the cluster CSR.

            If you followed [the official AWS documentation](https://docs.aws.amazon.com/cloudhsm/latest/userguide/initialize-cluster.html), you should have a CA certificate called `customerCA.crt`.

            Save the CA certificate to a path, as this will need to be mounted as a Docker volume in the next step. For this example, we'll save it to `/aws-files/customerCA.crt`.
          </Step>

          <Step title="Run Docker">
            Running Docker with HSM encryption requires setting the HSM-related environment variables as mentioned previously in the [HSM setup instructions](#setup-instructions). You can set these environment variables in your Docker run command.

            We are setting the environment variables for Docker via the command line in this example, but you can also pass in a `.env` file to set these environment variables.

            <Warning>
              If no key is found with the provided key label, the HSM will create a new key with the provided label.
              Infisical depends on an AES and HMAC key to be present in the HSM. If these keys are not present, Infisical will create them. The AES key label will be the value of the `HSM_KEY_LABEL` environment variable, and the HMAC key label will be the value of the `HSM_KEY_LABEL` environment variable with the suffix `_HMAC`.
            </Warning>

            ```bash  theme={"dark"}
            docker run -p 80:8080 \

              # Mount the HSM client files to "/opt/cloudhsm"
              -v /etc/cloudhsm:/opt/cloudhsm \
              # Mount the issuer CA certificate to "/opt/cloudhsm/etc/customerCA.crt"
              -v /aws-files/customerCA.crt:/opt/cloudhsm/etc/customerCA.crt \

              # Set the HSM library path to whats expected within Docker (/opt/cloudhsm/lib/libcloudhsm_pkcs11.so)
              -e HSM_LIB_PATH="/opt/cloudhsm/lib/libcloudhsm_pkcs11.so" \
              # Set the HSM PIN to the username and password of the HSM user, separated by a colon
              -e HSM_PIN=CryptoUserUsername:CryptoUserPassword \
              # Set the HSM slot number to the slot number of the HSM device as found in the previous step
              -e HSM_SLOT=<hsm-device-slot> \
              # Set the HSM key label to a label that will be used to identify the encryption key in the HSM. This key label does not need to exist before hand.
              -e HSM_KEY_LABEL=infisical-crypto-key \

              # The rest of your environment variables ...
              # -e ...
              infisical/infisical:<version> # Replace <version> with the version you want to use
            ```

            We recommend reading further about [using Infisical with Docker](/self-hosting/deployment-options/standalone-infisical).
          </Step>
        </Steps>

        After following these steps, your Docker setup will be ready to use HSM encryption.
      </Tab>
    </Tabs>
  </Tab>

  <Tab title="Kubernetes">
    When you are deploying Infisical with the [Kubernetes self-hosting option](/self-hosting/deployment-options/kubernetes-helm), you can still use HSM encryption, but you need to ensure that the HSM client files are present in the container.

    <Tabs>
      <Tab title="Thales Luna Cloud HSM">
        <Note>
          This is only supported on helm chart version `1.7.1` and above. Please see the [Helm Chart Changelog](https://github.com/Infisical/infisical/blob/main/helm-charts/infisical-standalone-postgres/CHANGELOG.md#141-march-19-2025) for more information.
        </Note>

        <Steps>
          <Step title="Create HSM client folder">
            When using Kubernetes, you need to mount the path containing the HSM client files. This section covers how to configure your Infisical instance to use an HSM with Kubernetes. In this example, we are going to be using `/etc/luna-docker`.

            ```bash  theme={"dark"}
            mkdir /etc/luna-docker
            ```

            After [setting up your Luna Cloud HSM client](https://thalesdocs.com/gphsm/luna/7/docs/network/Content/install/client_install/add_dpod.htm), you should have a set of files, referred to as the HSM client. You don't need all the files, but for simplicity we recommend copying all the files from the client.

            A folder structure of a client folder will often look like this:

            ```
            partition-ca-certificate.pem
            partition-certificate.pem
            server-certificate.pem
            Chrystoki.conf
            /plugins
              libcloud.plugin
            /lock
            /libs
              /64
                libCryptoki2.so
            /jsp
              LunaProvider.jar
              /64
                libLunaAPI.so
            /etc
              openssl.cnf
            /bin
              /64
                ckdemo
                lunacm
                multitoken
                vtl
            ```

            The most important parts of the client folder is the `Chrystoki.conf` file, and the `libs`, `plugins`, and `jsp` folders. You need to copy these files to the folder you created in the first step.

            ```bash  theme={"dark"}
              cp -r /<path-to-where-your-luna-client-is-located>/* /etc/luna-docker
            ```

            <Note>
              The `/*` wildcard will copy all files and folders within the HSM client. The wildcard is important to ensure that the file structure is inline with the rest of this guide.
            </Note>

            After copying the files, the `/etc/luna-docker` directory should have the following file structure:

            ```bash  theme={"dark"}
            $ ls -R /etc/luna-docker
            Chrystoki.conf etc lock server-certificate.pem
            Chrystoki.conf.tmp2E jsp partition-ca-certificate.pem setenv
            lch-support-linux-64bit partition-certificate.pem
            bin libs plugins

            /etc/luna-docker/bin:
            64

            /etc/luna-docker/bin/64:
            ckdemo cmu lunacm multitoken vtl

            /etc/luna-docker/etc:
            openssl.cnf

            /etc/luna-docker/jsp:
            64 LunaProvider.jar

            /etc/luna-docker/jsp/64:
            libLunaAPI.so

            /etc/luna-docker/libs:
            64

            /etc/luna-docker/libs/64:
            libCryptoki2.so

            /etc/luna-docker/lock:

            /etc/luna-docker/plugins:
            libcloud.plugin
            ```
          </Step>

          <Step title="Update Chrystoki.conf">
            The `Chrystoki.conf` file is used to configure the HSM client. You need to update the `Chrystoki.conf` file to point to the correct file paths.

            In this example, we will be mounting the `/etc/luna-docker` folder from the host to containers in our deployment's pods at the path `/usr/safenet/lunaclient`. This means the contents of `/etc/luna-docker` on the host will be accessible at `/usr/safenet/lunaclient` within the containers.

            An example config file will look like this:

            ```Chrystoki.conf  theme={"dark"}
              Chrystoki2 = {
                # This path points to the mounted path, /usr/safenet/lunaclient
                LibUNIX64 = /usr/safenet/lunaclient/libs/64/libCryptoki2.so;
              }

              Luna = {
                DefaultTimeOut = 500000;
                PEDTimeout1 = 100000;
                PEDTimeout2 = 200000;
                PEDTimeout3 = 20000;
                KeypairGenTimeOut = 2700000;
                CloningCommandTimeOut = 300000;
                CommandTimeOutPedSet = 720000;
              }

              CardReader = {
                LunaG5Slots = 0;
                RemoteCommand = 1;
              }

              Misc = {
                # Update the paths to point to the mounted path if your folder structure is different from the one mentioned in the previous step.
                PluginModuleDir = /usr/safenet/lunaclient/plugins;
                MutexFolder = /usr/safenet/lunaclient/lock;
                PE1746Enabled = 1;
                ToolsDir = /usr/bin;

              }

              Presentation = {
                ShowEmptySlots = no;
              }

              LunaSA Client = {
                ReceiveTimeout = 20000;
                # Update the paths to point to the mounted path if your folder structure is different from the one mentioned in the previous step.
                SSLConfigFile = /usr/safenet/lunaclient/etc/openssl.cnf;
                ClientPrivKeyFile = ./etc/ClientNameKey.pem;
                ClientCertFile = ./etc/ClientNameCert.pem;
                ServerCAFile = ./etc/CAFile.pem;
                NetClient = 1;
                TCPKeepAlive = 1;
              }


              REST = {
                AppLogLevel = error
                ServerName = <REDACTED>;
                ServerPort = 443;
                AuthTokenConfigURI = <REDACTED>;
                AuthTokenClientId = <REDACTED>;
                AuthTokenClientSecret = <REDACTED>;
                RestClient = 1;
                ClientTimeoutSec = 120;
                ClientPoolSize = 32;
                ClientEofRetryCount = 15;
                ClientConnectRetryCount = 900;
                ClientConnectIntervalMs = 1000;
              }
              XTC = {
                Enabled = 1;
                TimeoutSec = 600;
              }
            ```

            Save the file after updating the paths.
          </Step>

          <Step title="Creating Persistent Volume Claim (PVC)">
            You need to create a Persistent Volume Claim (PVC) to mount the HSM client files to the Infisical deployment.

            ```bash  theme={"dark"}
            kubectl apply -f - <<EOF
            apiVersion: v1
            kind: PersistentVolumeClaim
            metadata:
              name: infisical-data-pvc
            spec:
              accessModes:
                - ReadWriteOnce
              resources:
                requests:
                  storage: 500Mi
            EOF
            ```

            The above command will create a PVC named `infisical-data-pvc` with a storage size of `500Mi`. You can change the storage size if needed.

            Next we need to create a temporary pod with the PVC mounted as a volume, allowing us to copy the HSM client files into this mounted storage.

            ```bash  theme={"dark"}
            kubectl apply -f - <<EOF
            apiVersion: v1
            kind: Pod
            metadata:
              name: hsm-setup-pod
            spec:
              containers:
              - name: setup
                image: busybox
                command: ["/bin/sh", "-c", "sleep 3600"]
                volumeMounts:
                - name: hsm-data
                  mountPath: /data
              volumes:
              - name: hsm-data
                persistentVolumeClaim:
                  claimName: infisical-data-pvc
            EOF
            ```

            The above command will create a pod named `hsm-setup-pod` with a busybox image. The pod will sleep for 3600 seconds *(one hour)*, which is enough time to upload the HSM client files to the PVC.

            Ensure that the pod is running and is healthy by running the following command:

            ```bash  theme={"dark"}
            kubectl wait --for=condition=Ready pod/hsm-setup-pod --timeout=60s
            ```

            Next we need to copy the HSM client files into the PVC.

            ```bash  theme={"dark"}
            kubectl exec hsm-setup-pod -- mkdir -p /data/ # Create the data directory
            kubectl cp /etc/luna-docker/. hsm-setup-pod:/data/ # Copy the HSM client files into the PVC
            kubectl exec hsm-setup-pod -- chmod -R 755 /data/ # Set the correct permissions for the HSM client files
            ```

            Finally, we are ready to delete the temporary pod, as we have successfully uploaded the HSM client files to the PVC. This step may take a few minutes to complete.

            ```bash  theme={"dark"}
            kubectl delete pod hsm-setup-pod
            ```
          </Step>

          <Step title="Updating your environment variables">
            Next we need to update the environment variables used for the deployment. If you followed the [setup instructions for Kubernetes deployments](/self-hosting/deployment-options/kubernetes-helm), you should have a Kubernetes secret called `infisical-secrets`.
            We need to update the secret with the following environment variables:

            * `HSM_LIB_PATH` - The path to the HSM client library *(mapped to `/usr/safenet/lunaclient/libs/64/libCryptoki2.so`)*
            * `HSM_PIN` - The PIN for the HSM device that you created when setting up your Luna Cloud HSM client
            * `HSM_SLOT` - The slot number for the HSM device that you selected when setting up your Luna Cloud HSM client
            * `HSM_KEY_LABEL` - The label for the HSM key. If no key is found with the provided key label, the HSM will create a new key with the provided label.

            The following is an example of the secret that you should update:

            ```yaml  theme={"dark"}
            apiVersion: v1
            kind: Secret
            metadata:
              name: infisical-secrets
            type: Opaque
            stringData:
              # ... Other environment variables ...
              HSM_LIB_PATH: "/usr/safenet/lunaclient/libs/64/libCryptoki2.so" # If you followed this guide, this will be the path of the Luna Cloud HSM client
              HSM_PIN: "<your-hsm-device-pin>"
              HSM_SLOT: "<hsm-device-slot>"
              HSM_KEY_LABEL: "<your-key-label>"
            ```

            Save the file after updating the environment variables, and apply the secret changes

            ```bash  theme={"dark"}
            kubectl apply -f ./secret-file-name.yaml
            ```
          </Step>

          <Step title="Updating the Deployment">
            After we've successfully configured the PVC and updated our environment variables, we are ready to update the deployment configuration so that the pods it creates can access the HSM client files.

            ```yaml  theme={"dark"}
              # ... The rest of the values.yaml file ...
              
              image:
                repository: infisical/infisical
                tag: "v0.117.1-postgres"
                pullPolicy: IfNotPresent

              extraVolumeMounts:
                - name: hsm-data
                  mountPath: /usr/safenet/lunaclient # The path we will mount the HSM client files to

              extraVolumes:
                - name: hsm-data 
                  persistentVolumeClaim:
                    claimName: infisical-data-pvc # The PVC we created in the previous step

              # ... The rest of the values.yaml file ...
            ```
          </Step>

          <Step title="Upgrading the Helm Chart">
            After updating the values.yaml file, you need to upgrade the Helm chart in order for the changes to take effect.

            ```bash  theme={"dark"}
            helm upgrade --install infisical infisical-helm-charts/infisical-standalone --values /path/to/values.yaml
            ```
          </Step>

          <Step title="Restarting the Deployment">
            After upgrading the Helm chart, you need to restart the deployment in order for the changes to take effect.

            ```bash  theme={"dark"}
            kubectl rollout restart deployment/infisical-infisical
            ```
          </Step>
        </Steps>

        After following these steps, your Kubernetes setup will be ready to use HSM encryption.
      </Tab>

      <Tab title="Fortanix HSM">
        <Steps>
          <Step title="Set up Fortanix HSM">
            First, you need to set up Fortanix HSM by:

            1. Creating an App in Fortanix:
               * Set Interface value to be PKCS#11
               * Select API key as authentication method
               * Assign app to a group

                        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/kms/hsm/fortanix-hsm-setup.png" alt="Fortanix HSM Setup" />

            2. Take note of the domain (e.g., apac.smartkey.io). You will need this when setting up the configuration file.
          </Step>

          <Step title="Create configuration files">
            Create a directory to store the Fortanix configuration files:

            ```bash  theme={"dark"}
            mkdir -p /etc/fortanix-hsm
            ```

            Download the Fortanix PKCS#11 library for Linux from the [Fortanix PKCS#11 installation page](https://fortanix.zendesk.com/hc/en-us/sections/4408769080724-PKCS-11).

            Create a configuration file named `pkcs11.conf` with the following content:

            ```
            api_endpoint = "https://apac.smartkey.io"
            prevent_duplicate_opaque_objects = true
            retry_timeout_millis = 60000
            ```

            Note: Replace `apac.smartkey.io` with your actual Fortanix domain if different.
          </Step>

          <Step title="Creating a Persistent Volume Claim (PVC)">
            Create a Persistent Volume Claim to store the Fortanix files:

            ```bash  theme={"dark"}
            kubectl apply -f - <<EOF
            apiVersion: v1
            kind: PersistentVolumeClaim
            metadata:
              name: fortanix-hsm-pvc
            spec:
              accessModes:
                - ReadWriteOnce
              resources:
                requests:
                  storage: 100Mi
            EOF
            ```

            Create a temporary pod to upload the files:

            ```bash  theme={"dark"}
            kubectl apply -f - <<EOF
            apiVersion: v1
            kind: Pod
            metadata:
              name: fortanix-setup-pod
            spec:
              containers:
              - name: setup
                image: busybox
                command: ["/bin/sh", "-c", "sleep 3600"]
                volumeMounts:
                - name: fortanix-data
                  mountPath: /data
              volumes:
              - name: fortanix-data
                persistentVolumeClaim:
                  claimName: fortanix-hsm-pvc
            EOF
            ```

            Ensure the pod is running:

            ```bash  theme={"dark"}
            kubectl wait --for=condition=Ready pod/fortanix-setup-pod --timeout=60s
            ```

            Copy the Fortanix files to the PVC:

            ```bash  theme={"dark"}
            kubectl exec fortanix-setup-pod -- mkdir -p /data/
            kubectl cp /etc/fortanix-hsm/fortanix_pkcs11_4.37.2554.so fortanix-setup-pod:/data/
            kubectl cp /etc/fortanix-hsm/pkcs11.conf fortanix-setup-pod:/data/
            kubectl exec fortanix-setup-pod -- chmod -R 755 /data/
            ```

            Delete the temporary pod:

            ```bash  theme={"dark"}
            kubectl delete pod fortanix-setup-pod
            ```
          </Step>

          <Step title="Update the Kubernetes Secret">
            Update your Kubernetes secret with the Fortanix HSM environment variables:

            ```yaml  theme={"dark"}
            apiVersion: v1
            kind: Secret
            metadata:
              name: infisical-secrets
            type: Opaque
            stringData:
              # ... Other environment variables ...
              HSM_LIB_PATH: "/etc/fortanix-hsm/fortanix_pkcs11_4.37.2554.so"  # Path to the PKCS#11 library in the container
              HSM_PIN: "<your-fortanix-api-key>"  # Your Fortanix app API key used for authentication
              HSM_SLOT: "0"            # Slot value (can be set to 0 for Fortanix HSM as it's arbitrary)
              HSM_KEY_LABEL: "hsm-key-label"  # Label to identify the encryption key in the HSM
              FORTANIX_PKCS11_CONFIG_PATH: "/etc/fortanix-hsm/pkcs11.conf"  # Path to Fortanix configuration file
            ```

            Apply the updated secret:

            ```bash  theme={"dark"}
            kubectl apply -f ./secret-file-name.yaml
            ```
          </Step>

          <Step title="Update Helm Values">
            Update your Helm values to mount the Fortanix HSM files:

            ```yaml  theme={"dark"}
            # ... The rest of the values.yaml file ...

            image:
              repository: infisical/infisical
              tag: "v0.117.1-postgres"
              pullPolicy: IfNotPresent

            extraVolumeMounts:
              - name: fortanix-data
                mountPath: /etc/fortanix-hsm  # The path where Fortanix files will be available

            extraVolumes:
              - name: fortanix-data
                persistentVolumeClaim:
                  claimName: fortanix-hsm-pvc

            # ... The rest of the values.yaml file ...
            ```

            <Warning>
              Note: Fortanix HSM integration only works for AMD64 CPU architectures.
            </Warning>
          </Step>

          <Step title="Upgrade and Restart">
            Upgrade the Helm chart with the new values:

            ```bash  theme={"dark"}
            helm upgrade --install infisical infisical-helm-charts/infisical-standalone --values /path/to/values.yaml
            ```

            Restart the deployment:

            ```bash  theme={"dark"}
            kubectl rollout restart deployment/infisical-infisical
            ```
          </Step>
        </Steps>

        After following these steps, your Kubernetes setup will be ready to use Fortanix HSM encryption.
      </Tab>

      <Tab title="AWS CloudHSM">
        ### Prerequisites

        * An [activated AWS CloudHSM cluster](https://docs.aws.amazon.com/cloudhsm/latest/userguide/activate-cluster.html) with at least 1 HSM device.
        * A [HSM user with the `Crypto User` role](https://docs.aws.amazon.com/cloudhsm/latest/userguide/cloudhsm_cli-user-create.html). In this guide we are using a user with the username `testUser` and the password `testPassword`.
        * A Kubernetes cluster

        <Note>
          AWS CloudHSM is supported on helm chart version `1.7.1` and above. Please see the [Helm Chart Changelog](https://github.com/Infisical/infisical/blob/main/helm-charts/infisical-standalone-postgres/CHANGELOG.md#141-march-19-2025) for more information.
        </Note>

        <Steps>
          <Step title="Creating Persistent Volume Claim (PVC)">
            <Accordion title="Prerequisites for using AWS EKS">
              If you're using AWS EKS, you need to specify a storage class for the PVC and ensure that the EBS CSI Driver is installed and running.

              By default, EKS exposes `gp2` as the default storage class. Below are the steps required for setting the default storage class and ensuring the EBS CSI Driver is installed and running:

              <Steps>
                <Step title="Enable OIDC authentication">
                  Enable OIDC authentication for the EKS cluster:

                  ```bash  theme={"dark"}
                  eksctl utils associate-iam-oidc-provider \
                  --region <your-region> \
                  --cluster <your-cluster-name> \
                  --approve
                  ```

                  * Replace `<your-region>` with your AWS region.
                  * Replace `<your-cluster-name>` with your cluster name.
                </Step>

                <Step title="Check if the EBS CSI Driver is installed and running">
                  1. Check if EBS CSI Driver is installed and running by running the following command:

                  ```bash  theme={"dark"}
                  kubectl get pods -n kube-system | grep ebs-csi
                  ```

                  If you see no pods, you need to install the EBS CSI Driver as seen in the next step.
                </Step>

                <Step title="Install EBS CSI Driver using eksctl">
                  Create a new IAM service account for the EBS CSI Driver:

                  ```bash  theme={"dark"}
                  eksctl create iamserviceaccount \
                    --name ebs-csi-controller-sa \
                    --namespace kube-system \
                    --region <your-region> \
                    --cluster <your-cluster-name> \
                    --attach-policy-arn arn:aws:iam::aws:policy/service-role/AmazonEBSCSIDriverPolicy \
                    --approve \
                    --role-name AmazonEKS_EBS_CSI_DriverRole
                  ```

                  * Replace `<your-cluster-name>` with your cluster name.
                  * Replace `<your-region>` with your AWS region.

                  Install the EBS CSI Driver:

                  ```bash  theme={"dark"}
                  eksctl create addon \
                  --name aws-ebs-csi-driver \
                  --cluster <your-cluster-name> \
                  --region <your-region> \
                  --service-account-role-arn arn:aws:iam::<account-id>:role/AmazonEKS_EBS_CSI_DriverRole \
                  --force
                  ```

                  * Replace `<your-cluster-name>` with your cluster name.
                  * Replace `<your-region>` with your AWS region.
                  * Replace `<account-id>` with your actual account ID. Can be obtained by running `aws sts get-caller-identity --query Account --output text`.
                </Step>

                <Step title="Verify the EBS CSI Driver is installed and running">
                  Verify the EBS CSI Driver is installed and running by running the following command:

                  ```bash  theme={"dark"}
                  kubectl get pods -n kube-system | grep ebs-csi
                  ```

                  You should see an output like this:

                  ```bash  theme={"dark"}
                  kubectl get pods -n kube-system | grep ebs-csi
                  ebs-csi-controller-6b6bbf996-rvf8r   6/6     Running   0          21s
                  ebs-csi-controller-6b6bbf996-vk4ng   6/6     Running   0          21s
                  ebs-csi-node-c6vbb                   3/3     Running   0          21s
                  ebs-csi-node-s9zlr                   3/3     Running   0          21s
                  ```
                </Step>

                <Step title="Find the enabled storage class">
                  You can find the enabled storage class by running the following command:

                  ```bash  theme={"dark"}
                  kubectl get storageclass
                  ```

                  You should see an output like this:

                  ```bash  theme={"dark"}
                  $ kubectl get storageclass

                  NAME   PROVISIONER             RECLAIMPOLICY   VOLUMEBINDINGMODE      ALLOWVOLUMEEXPANSION   AGE
                  gp2    kubernetes.io/aws-ebs   Delete          WaitForFirstConsumer   false                  65m
                  ```

                  In this case, the enabled storage class is `gp2`.
                </Step>

                <Step title="Set the default storage class">
                  You can set the default PVC storage class by patching the storage class with the following command:

                  ```bash  theme={"dark"}
                  kubectl patch storageclass gp2 -p '{"metadata": {"annotations":{"storageclass.kubernetes.io/is-default-class":"true"}}}'
                  ```

                  This will set the `gp2` storage class as the default storage class.

                  Now when you run `kubectl get storageclass`, you should see that `gp2` is the default storage class.

                  ```bash  theme={"dark"}
                  $ kubectl get storageclass 

                  NAME            PROVISIONER             RECLAIMPOLICY   VOLUMEBINDINGMODE      ALLOWVOLUMEEXPANSION   AGE
                  gp2 (default)   kubernetes.io/aws-ebs   Delete          WaitForFirstConsumer   false                  68m
                  ```

                  Notice the `(default)` next to the `gp2` storage class.
                </Step>
              </Steps>
            </Accordion>

            You need to create a Persistent Volume Claim (PVC) to mount the HSM client files to the Infisical deployment.

            ```bash  theme={"dark"}
            kubectl apply -f - <<EOF
            apiVersion: v1
            kind: PersistentVolumeClaim
            metadata:
              name: cloudhsm-data-pvc
            spec:
              accessModes:
                - ReadWriteOnce
              resources:
                requests:
                  storage: 500Mi
            EOF
            ```

            The above command will create a PVC named `cloudhsm-data-pvc` with a storage size of `500Mi`. You can change the storage size if needed.

            Next we need to create a temporary pod with the PVC mounted as a volume, allowing us to copy the HSM client files into this mounted storage.

            ```bash  theme={"dark"}
            kubectl apply -f - <<EOF
            apiVersion: v1
            kind: Pod
            metadata:
              name: cloudhsm-setup-pod
            spec:
              containers:
              - name: setup
                image: debian:bookworm
                command: ["/bin/sh", "-c", "sleep 7200"]
                volumeMounts:
                - name: cloudhsm-data
                  mountPath: /data
              volumes:
              - name: cloudhsm-data
                persistentVolumeClaim:
                  claimName: cloudhsm-data-pvc
            EOF
            ```

            The above command will create a pod named `cloudhsm-setup-pod` with a Debian image. The pod will sleep for 7200 seconds *(two hours)*, which is enough time to set up the PVC and configure the HSM client.

            Ensure that the pod is running and is healthy by running the following command:

            ```bash  theme={"dark"}
            kubectl wait --for=condition=Ready pod/cloudhsm-setup-pod --timeout=120s
            ```
          </Step>

          <Step title="Configure the PVC">
            We need to configure the PVC to work with the CloudHSM, so Infisical can consume the HSM client files.

            **2.1. Start a shell in the PVC pod:**

            This will allow us to run commands directly within the setup pod. We'll use this to configure the CloudHSM client and to validate that it's working correctly.

            ```bash  theme={"dark"}
            kubectl exec -it cloudhsm-setup-pod -- /bin/sh
            ```

            **2.2. Install the necessary packages:**

            This will install the necessary packages to allow us to test and install the CloudHSM client.

            ```bash  theme={"dark"}
            apt-get update -y
            apt-get install opensc telnet wget -y
            ```

            **2.3. Try to reach the HSM device:**

            We need to validate that we're able to reach the HSM device from within Kubernetes. You can use telnet to ping the HSM device like so:

            ```bash  theme={"dark"}
            telnet <HSM_ENI_IPV4_ADDRESS> 2223
            ```

            You should see an output like this:

            ```bash  theme={"dark"}
            $ telnet <HSM_ENI_IPV4_ADDRESS> 2223                                                 
            Trying <HSM_ENI_IPV4_ADDRESS>...
            Connected to <HSM_ENI_IPV4_ADDRESS>.
            ```

            If it gets stuck on `Trying ....`, you may have configured your HSM client's security group incorrectly. Make sure you configure the security group to allow traffic from EKS on port 2223-2225.

            **2.4. Install the AWS CloudHSM client:**

            The Infisical images run on Debian, so we need to install a Debian-compatible version of the AWS CloudHSM client.

            ```bash  theme={"dark"}
            wget https://s3.amazonaws.com/cloudhsmv2-software/CloudHsmClient/Jammy/cloudhsm-pkcs11_latest_u22.04_amd64.deb
            apt-get install ./cloudhsm-pkcs11_latest_u22.04_amd64.deb -y
            ```

            **2.5. Configure the CloudHSM client:**

            After installing the CloudHSM client, you should see all related files in the `/opt/cloudhsm/` directory on the CloudHSM setup pod.

            You need to run the `configure-pkcs11` binary which will configure the client to connect with your AWS CloudHSM cluster. Depending on if you have multiple HSM's inside your cluster, you'll need to run the command with different arguments. Below you'll find the appropriate command for your use case:

            <AccordionGroup>
              <Accordion title="Single HSM">
                ```bash  theme={"dark"}
                /opt/cloudhsm/bin/configure-pkcs11 -a <HSM_ENI_IPV4_ADDRESS> --disable-key-availability-check
                ```

                <Info>
                  To use a single HSM, you must first manage client key durability settings by setting `disable_key_availability_check` to true by passing the `--disable-key-availability-check` flag. For more information read the [Key Synchronization](https://docs.aws.amazon.com/cloudhsm/latest/userguide/manage-key-sync.html) section in the AWS CloudHSM documentation.
                </Info>
              </Accordion>

              <Accordion title="Multiple HSM's">
                ```bash  theme={"dark"}
                /opt/cloudhsm/bin/configure-pkcs11 -a <HSM_ENI_IPV4_ADDRESS_1> <HSM_ENI_IPV4_ADDRESS_2> ... --disable-key-availability-check
                ```
              </Accordion>
            </AccordionGroup>

            **2.6. Verify the CloudHSM client is configured correctly:**

            You can verify the CloudHSM client is configured correctly by running the following command:

            ```bash  theme={"dark"}
            cat /opt/cloudhsm/etc/cloudhsm-pkcs11.cfg
            ```

            You should see an output like this:

            ```json  theme={"dark"}
            {
              "clusters": [
                {
                  "type": "hsm1",
                  "cluster": {
                    "hsm_ca_file": "/opt/cloudhsm/etc/customerCA.crt",
                    "servers": [
                      {
                        "hostname": "172.31.39.155",
                        "port": 2223,
                        "enable": true
                      }
                    ],
                    "options": {
                      "disable_key_availability_check": true
                    }
                  }
                }
              ],
              "logging": {
                "log_type": "file",
                "log_file": "/opt/cloudhsm/run/cloudhsm-pkcs11.log",
                "log_level": "info",
                "log_interval": "daily"
              }
            }
            ```

            **2.7. Exit the pod:**

            Exit the pod by running the following command:

            ```bash  theme={"dark"}
            exit
            ```

            **2.8. Copy your issuer CA certificate to the PVC:**

            When you initialized your HSM, you were prompted to download the cluster CSR and sign it.
            In order to use the HSM with Infisical, you need to obtain the issuer CA certificate that was used to sign the cluster CSR.

            If you followed [the official AWS documentation](https://docs.aws.amazon.com/cloudhsm/latest/userguide/initialize-cluster.html), you should have a CA certificate called `customerCA.crt`.

            Copy the CA certificate from your local machine to the setup pod:

            ```bash  theme={"dark"}
            kubectl cp /path/to/customerCA.crt cloudhsm-setup-pod:/opt/cloudhsm/etc/customerCA.crt
            ```

            Ensure that the file is at `/opt/cloudhsm/etc/customerCA.crt` inside the setup pod by running the following command:

            ```bash  theme={"dark"}
            kubectl exec -it cloudhsm-setup-pod -- cat /opt/cloudhsm/etc/customerCA.crt
            ```

            **2.9. Test the HSM client:**

            Finally, after we're done configuring the HSM client, we need to test it to ensure that it's working correctly.

            First, start a new shell into the setup pod by running the same shell command as before:

            ```bash  theme={"dark"}
            kubectl exec -it cloudhsm-setup-pod -- /bin/sh
            ```

            Next, try generating a random 32 bytes long string by running the following command:

            ```bash  theme={"dark"}
            pkcs11-tool --module /opt/cloudhsm/lib/libcloudhsm_pkcs11.so \
              --login --pin <crypto-user-username>:<crypto-user-password> \
              --generate-random 32 | base64
            ```

            You should see an output like this:

            ```bash  theme={"dark"}
            Using slot 0 with a present token (0x2000000000000001)
            av1dlhVEsssjpcTNS+ysGUoKWH6+/PCaEDIdal5oQc0=
            ```

            <Note>
              Replace the `<crypto-user-username>:<crypto-user-password>` with your username and password combination of the Crypto user you have created that you want to use to perform cryptographic operations.

              In AWS CloudHSM, the PIN is always the username and password separated by a colon.
            </Note>

            **2.10. Copy the configured client to the PVC:**

            Copy from the HSM files into the `/data` directory in the PVC, which is what will be mounted for the Infisical deployment.

            ```bash  theme={"dark"}
            cp -r /opt/cloudhsm/. /data/
            ```

            Verify the files were copied correctly by running the following command:

            ```bash  theme={"dark"}
            ls -la /data/
            ```

            You should see an output like this:

            ```bash  theme={"dark"}
            drwxr-xr-x. 8 root root 4096 Oct 13 18:50 .
            drwxr-xr-x. 1 root root  131 Oct 13 18:29 ..
            drwxr-xr-x. 2 root root 4096 Oct 13 18:50 bin
            drwxr-xr-x. 3 root root 4096 Oct 13 18:50 doc
            drwxr-xr-x. 2 root root 4096 Oct 13 18:50 etc
            drwxr-xr-x. 3 root root 4096 Oct 13 18:50 include
            drwxr-xr-x. 2 root root 4096 Oct 13 18:50 lib
            drwxr-xr-t. 2 root root 4096 Oct 13 18:50 run
            ```

            **2.11. Set the correct permissions for the HSM client files:**

            ```bash  theme={"dark"}
            chmod -R 755 /data/
            ```

            **2.12. Exit the pod:**

            Exit the pod by running the following command:

            ```bash  theme={"dark"}
            exit
            ```

            **2.13. Delete the setup pod:**

            Delete the setup pod by running the following command:

            ```bash  theme={"dark"}
            kubectl delete pod cloudhsm-setup-pod
            ```
          </Step>

          <Step title="Updating your environment variables">
            Next we need to update the environment variables used for the deployment. If you followed the [setup instructions for Kubernetes deployments](/self-hosting/deployment-options/kubernetes-helm), you should have a Kubernetes secret called `infisical-secrets`.
            We need to update the secret with the following environment variables:

            * `HSM_LIB_PATH` - The path to the CloudHSM PKCS#11 library *(mapped to `/opt/cloudhsm/lib/libcloudhsm_pkcs11.so`)*
            * `HSM_PIN` - The PIN for the HSM device, which is the username and password of your Crypto User separated by a colon (e.g., `testUser:testPassword`)
            * `HSM_SLOT` - The slot number for the HSM device that you found in the previous step
            * `HSM_KEY_LABEL` - The label for the HSM key. If no key is found with the provided key label, the HSM will create a new key with the provided label.

            The following is an example of the secret that you should update:

            ```yaml  theme={"dark"}
            apiVersion: v1
            kind: Secret
            metadata:
              name: infisical-secrets
            type: Opaque
            stringData:
              # ... Other environment variables ...
              HSM_LIB_PATH: "/opt/cloudhsm/lib/libcloudhsm_pkcs11.so"
              HSM_PIN: "testUser:testPassword"  # Replace with your actual Crypto User credentials
              HSM_SLOT: "0"  # Replace with your actual slot number
              HSM_KEY_LABEL: "infisical-crypto-key"
            ```

            Save the file after updating the environment variables, and apply the secret changes

            ```bash  theme={"dark"}
            kubectl apply -f ./secret-file-name.yaml
            ```
          </Step>

          <Step title="Updating the Deployment">
            After we've successfully configured the PVC and updated our environment variables, we are ready to update the deployment configuration so that the pods it creates can access the HSM client files.

            ```yaml  theme={"dark"}
              # ... The rest of the values.yaml file ...
              infisical:
                image:
                  repository: infisical/infisical
                  tag: "v0.151.0"
                  pullPolicy: IfNotPresent

                extraVolumeMounts:
                  - name: cloudhsm-data
                    mountPath: /opt/cloudhsm  # The path we will mount the HSM client files to

                extraVolumes:
                  - name: cloudhsm-data 
                    persistentVolumeClaim:
                      claimName: cloudhsm-data-pvc  # The PVC we created in the previous step

              # ... The rest of the values.yaml file ...
            ```

            <Warning>
              Make sure to set the `tag` to **`v0.151.0-nightly-20251013.1` or above**, as this is the minimum Infisical version that supports AWS CloudHSM.
            </Warning>

            <Warning>
              Ensure that the configuration file at `/opt/cloudhsm/etc/cloudhsm-pkcs11.cfg` references the correct path for the issuer CA certificate (`/opt/cloudhsm/etc/customerCA.crt`). This should already be configured correctly if you followed the previous steps.
            </Warning>
          </Step>

          <Step title="Upgrading the Helm Chart">
            After updating the values.yaml file, you need to upgrade the Helm chart in order for the changes to take effect.

            ```bash  theme={"dark"}
            helm repo update
            helm upgrade --install infisical infisical-helm-charts/infisical-standalone --values /path/to/values.yaml
            ```
          </Step>

          <Step title="Restarting the Deployment">
            After upgrading the Helm chart, you need to restart the deployment in order for the changes to take effect.

            ```bash  theme={"dark"}
            kubectl rollout restart deployment/infisical-infisical-standalone-infisical
            ```
          </Step>
        </Steps>

        After following these steps, your Kubernetes setup will be ready to use AWS CloudHSM encryption.
      </Tab>
    </Tabs>
  </Tab>
</Tabs>

## Disabling HSM Encryption

To disable HSM encryption, navigate to Infisical's Server Admin Console and set the KMS encryption strategy to `Software-based Encryption`. This will revert the encryption strategy back to the default software-based encryption.

<Note>
  In order to disable HSM encryption, the Infisical instance must be able to access the HSM device. If the HSM device is no longer accessible, you will not be able to disable HSM encryption.
</Note>


# KMIP Integration
Source: https://infisical.com/docs/documentation/platform/kms/kmip

Learn more about integrating with Infisical KMS using KMIP (Key Management Interoperability Protocol).

<Note>
  KMIP integration is an Enterprise-only feature. Please reach out to
  [sales@infisical.com](mailto:sales@infisical.com) if you have any questions.
</Note>

Infisical KMS provides Key Management Interoperability Protocol (KMIP) support for integration with KMIP-compatible clients. This allows for enhanced key management across various applications that support the KMIP 1.4 protocol.

## How KMIP Works with Infisical

At a high level, the KMIP integration follows this architecture:

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/kmip-diagram.png" alt="KMIP Architecture Diagram" />

At a high level, the KMIP integration works as follows:

1. KMIP clients (your applications or tools) communicate with the KMIP server
2. The KMIP server acts as a proxy and forwards requests to Infisical KMS
3. The KMIP server authenticates to Infisical using a machine identity

The KMIP server itself is deployed using the Infisical CLI (`infisical kmip start` command) and serves as an intermediary between your KMIP clients and Infisical's key management system.

### Supported Operations

The Infisical KMIP server supports the following operations for symmetric keys:

* **Create** - Generate symmetric keys
* **Register** - Register externally created keys
* **Locate** - Find keys using attributes
* **Get** - Retrieve keys securely
* **Activate** - Enable keys for usage
* **Revoke** - Revoke existing keys
* **Destroy** - Permanently remove keys
* **Get Attributes** - Retrieve metadata associated with keys
* **Query** - Query server capabilities and supported operations

### Compatibility

Infisical KMIP supports KMIP versions 1.0 to 1.4, ensuring compatibility with a wide range of clients and security tools.

### Network Requirements

Ensure the following network connectivity is in place:

* **KMIP Client  KMIP Server**: KMIP clients must be able to reach the KMIP server on port 5696 (or your configured port). Ensure firewalls allow this traffic and DNS resolution works if using hostnames.

* **KMIP Server  Infisical Platform**: The KMIP server needs outbound HTTP access to Infisical. For self-hosted instances, ensure connectivity to your custom domain.

## Configure and Deploy the KMIP Server

Follow these steps in order to set up KMIP integration with Infisical:

<Steps>
  <Step title="Enable KMIP at the Organization Level">
    First, you need to enable KMIP for your entire Infisical organization and set up its PKI infrastructure.

    Navigate to **Organization Settings > KMIP** and click **Setup KMIP**.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/kms/kmip/kmip-org-setup-navigation.png" alt="KMIP org navigate" />

    In the modal, select the desired key algorithm to use for the KMIP PKI of your organization, then click **Continue**.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/kms/kmip/kmip-org-setup-modal.png" alt="KMIP org PKI setup" />

    This generates the KMIP PKI for your organization, creating the cryptographic foundation that will be used for secure KMIP communications.

    <Info>
      You do not need to manage these certificates yourself; Infisical handles the PKI infrastructure for you.
    </Info>
  </Step>

  <Step title="Create a Machine Identity for the KMIP Server">
    The KMIP server needs a machine identity to authenticate with Infisical and proxy requests on behalf of clients.

    Configure a [machine identity](/documentation/platform/identities/machine-identities#machine-identities) by heading to your organization's **Access Control** and switching over to the **identities** tab.
    From there you can click **Create Identity**.

    This guide assumes you'll be using the [Universal Auth](/documentation/platform/identities/universal-auth) method for the machine identity but you can choose any supported authentication method.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/kms/kmip/kmip-create-mi.png" alt="KMIP create machine identity" />

    This machine identity will be used by the KMIP server to authenticate and forward client requests to Infisical KMS.
  </Step>

  <Step title="Create a Custom Organization Role with Proxy KMIP Permission">
    The machine identity needs permission to proxy KMIP requests.

    Create a custom organization role and give it the **Proxy KMIP** permission.

    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/kms/kmip/kmip-create-custom-role.png" alt="KMIP create custom role" />
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/kms/kmip/kmip-assign-custom-role-proxy.png" alt="KMIP assign proxy to role" />

    This permission allows the KMIP server to act as an intermediary between KMIP clients and Infisical.
  </Step>

  <Step title="Assign the Organization Role to the Machine Identity">
    Now connect the machine identity to the role you just created.

    Assign the machine identity to the custom organization role.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/kms/kmip/kmip-assign-mi-to-role.png" alt="KMIP assign role to machine identity" />

    This grants the machine identity the ability to serve KMIP client requests and forward them from your KMIP server to Infisical.
  </Step>

  <Step title="Deploy the KMIP Server">
    Now you're ready to deploy the KMIP server.
    You can run the KMIP server on any infrastructure that can reach the Infisical platform, such as a VM or container.

    Once you have your infrastructure ready, you'll need to install the Infisical CLI on the server where you want to run the KMIP server.

    To install the latest Infisical CLI visit [Infisical CLI instructions](https://infisical.com/docs/cli/overview).
    If you need to install specific versions of the CLI, you can find them on the [Infisical CLI GitHub Releases](https://github.com/Infisical/cli/releases).

    Then, launch the KMIP server with the following command:

    ```bash  theme={"dark"}
    infisical kmip start \
      --identity-client-id=example-client-id \
      --identity-client-secret=example-client-secret \
      --domain=https://my-infisical-instance.com \
      --listen-address="0.0.0.0:5696" \
      --hostnames-or-ips="my-kmip-server.com"
    ```

    **Available flags:**

    * **listen-address** (default: localhost:5696): The address the KMIP server listens on. In most cases you'll want to listen on all interfaces (0.0.0.0:5696)
    * **identity-auth-method** (default: universal-auth): The authentication method for the machine identity
    * **identity-client-id**: The client ID of the machine identity (can be set via `INFISICAL_UNIVERSAL_AUTH_CLIENT_ID` env var)
    * **identity-client-secret**: The client secret of the machine identity (can be set via `INFISICAL_UNIVERSAL_AUTH_CLIENT_SECRET` env var)
    * **server-name** (default: "kmip-server"): The name of the KMIP server
    * **certificate-ttl** (default: "1y"): The duration for which the server certificate is valid
    * **hostnames-or-ips**: The IP address or the hostname of the server where you have deployed the KMIP server.

    Once started, your KMIP server is now running and ready to accept client connections. It will authenticate to Infisical using the machine identity and proxy all KMIP operations.
  </Step>

  <Step title="Navigate to Your KMS Project">
    Now that the KMIP server is running, you need to register KMIP clients that will connect to it.

    Navigate to the desired KMS project if you already have one or create a new project of type KMS, then select **KMIP** once inside the project, and click **Add KMIP Client**.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/kms/kmip/kmip-client-overview.png" alt="KMIP client overview" />
  </Step>

  <Step title="Configure the KMIP Client">
    Define the client and its permissions.

    In the modal, provide the details of your client. The selected permissions determine what KMIP operations (Create, Get, Revoke, etc.) can be performed in your KMS project.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/kms/kmip/kmip-client-modal.png" alt="KMIP client modal" />

    This creates a KMIP client entity in Infisical that will be authenticated via mTLS certificates.
  </Step>

  <Step title="Generate Client Certificate">
    Each KMIP client needs its own certificate for mTLS authentication.

    Click **Generate Certificate** for your newly created client.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/kms/kmip/kmip-client-generate-cert.png" alt="KMIP generate client cert" />

    Provide the desired TTL (time-to-live) and key algorithm, then click **Generate Client Certificate**.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/kms/kmip/kmip-client-cert-config-modal.png" alt="KMIP client cert config" />

    Download the generated client certificate, certificate chain, and private key.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/kms/kmip/kmip-client-certificate-modal.png" alt="KMIP client cert modal" />

    Configure your KMIP-compatible applications or tools to use these credentials when connecting to the KMIP server. The client will now authenticate via mTLS and perform authorized key management operations through the KMIP server, which proxies requests to Infisical KMS.
  </Step>
</Steps>

## Connecting your KMIP Client to Infisical

After completing the setup, configure your KMIP compatible application to connect to the KMIP server.

While exact configuration steps vary by application, you'll generally need to provide:

1. **KMIP Server Address**: The hostname or IP and port where your KMIP server is listening (e.g., `my-kmip-server.com:5696`)

2. **Client Certificates**: The certificate credentials generated from your Infisical KMS project:
   * **Client Certificate** (`client-cert.pem`) - Identifies your KMIP client
   * **Client Private Key** (`client-key.pem`) - Used for mTLS authentication
   * **Certificate Chain** (`cert-chain.pem`) - Verifies the KMIP server

### General Configuration Steps

<Steps>
  <Step title="Identify Your KMIP Server Endpoint">
    Determine the address where your KMIP server is accessible. This should match one of the hostnames or IPs you specified when starting the KMIP server with the `--hostnames-or-ips` flag.

    **Example endpoints:**

    * `my-kmip-server.com:5696`
    * `10.0.1.50:5696`
    * `kmip.example.com:5696`

    The default port is `5696`, but this can be changed using the `--listen-address` flag when starting the server.
  </Step>

  <Step title="Prepare Certificate Files">
    Organize the certificate materials you downloaded when generating the client certificate from the Infisical KMS project. You should have three files:

    * **client-cert.pem** - The client certificate
    * **cert-chain.pem** - The certificate chain (includes intermediate and root CA certificates)
    * **client-key.pem** - The private key

    Most KMIP clients require these files in PEM format, which is what Infisical provides by default.
  </Step>

  <Step title="Configure Your KMIP Client Application">
    The exact configuration steps vary depending on your KMIP client application. Generally, you'll need to specify:

    **Common configuration parameters:**

    * **Server hostname/IP**: Your KMIP server address (e.g., `my-kmip-server.com`)
    * **Server port**: Default is `5696`
    * **Client certificate**: Path to `client-cert.pem`
    * **Client private key**: Path to `client-key.pem`
    * **CA certificate**: Path to `cert-chain.pem` (used to verify the server)
    * **Protocol version**: KMIP 1.0 through 1.4 are supported

    **Example configuration for PyKMIP:**

    ```ini  theme={"dark"}
    [client]
    host=my-kmip-server.com
    port=5696
    certfile=/path/to/client-cert.pem
    keyfile=/path/to/client-key.pem
    ca_certs=/path/to/cert-chain.pem
    ```
  </Step>

  <Step title="Test the Connection">
    Once configured, test the connection by performing a simple KMIP operation, such as:

    * Querying server capabilities
    * Creating a test key
    * Listing available keys

    If the connection is successful, your KMIP client is now integrated with Infisical KMS and can perform key management operations according to the permissions you assigned.

    **Troubleshooting connection issues:**

    * Verify network connectivity between your KMIP client and the KMIP server
    * Check that certificate files are readable and in the correct format
    * Ensure the KMIP server is running and accessible
    * Review KMIP server logs for authentication errors
    * Confirm the client certificate has not expired

    If you require further verification of your certificate details and connectivity to the KMIP server from your KMIP client, you can use the following command from your client machine:

    ```bash  theme={"dark"}
    openssl s_client -connect kmip-server-ip-here:5696 --cert /path/to/client-cert.pem --key /path/to/client-cert.pem --CAfile /path/to/cert-chain.pem --tls1_2 --showcerts --state --debug
    ```

    This command attempts to establish a TLS connection to the KMIP server using your client certificate and key, displaying detailed information about the handshake process.
    If the connection is successful, you'll see the server's certificate chain and a message indicating that the handshake was completed.
  </Step>
</Steps>


# Kubernetes Encryption with KMS
Source: https://infisical.com/docs/documentation/platform/kms/kubernetes-encryption





# Key Management Service (KMS)
Source: https://infisical.com/docs/documentation/platform/kms/overview

Learn how to manage and use cryptographic keys with Infisical.

## Concept

Infisical can be used as a Key Management System (KMS), referred to as Infisical KMS, to centralize management of keys to be used for cryptographic operations like encryption/decryption.

By default your Infisical data such as projects and the data within them are encrypted at rest using Infisical's own KMS. This ensures that your data is secure and protected from unauthorized access.

If you are on-premise, your KMS root key will be created at random with the `ROOT_ENCRYPTION_KEY` environment variable. You can also use a Hardware Security Module (HSM), to create the root key. Read more about [HSM](/documentation/platform/kms/hsm-integration).

<Note>
  Keys managed in KMS are not extractable from the platform. Additionally, data
  is never stored when performing cryptographic operations.
</Note>

## Workflow

The typical workflow for using Infisical KMS consists of the following steps:

1. Creating a KMS key. As part of this step, you specify a name for the key and the encryption algorithm meant to be used for it (e.g. `AES-GCM-128`, `AES-GCM-256`).
2. Encryption: To encrypt data, you would make a request to the Infisical KMS API endpoint, specifying the base64-encoded plaintext and the intended key to use for encryption; the API would return the base64-encoded ciphertext.
3. Decryption: To decrypt data, you would make a request to the Infisical KMS API endpoint, specifying the base64-encoded ciphertext and the intended key to use for decryption; the API would return the base64-encoded plaintext.

<Note>
  Note that this workflow can be executed via the Infisical UI or manually such
  as via API.
</Note>

## Encryption

### Guide to Encrypting Data

In the following steps, we explore how to generate a key and use it to encrypt data.

<Tabs>
  <Tab title="Infisical UI">
    <Steps>
      <Step title="Creating a KMS key">
        Navigate to Project > Key Management and tap on the **Add Key** button.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/kms/infisical-kms/kms-add-key.png" alt="kms add key button" />

        Specify your key details. Here's some guidance on each field:

        * Name: A slug-friendly name for the key.
        * Key Usage: The type of key to create (e.g `Encrypt/Decrypt` for encryption, and `Sign/Verify` for signing).
        * Algorithm: The encryption algorithm associated with the key (e.g. `AES-GCM-256`).
        * Description: An optional description of what the intended usage is for the key.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/kms/infisical-kms/kms-add-key-modal.png" alt="kms add key modal" />
      </Step>

      <Step title="Encrypting data with the KMS key">
        Once your key is generated, open the options menu for the newly created key and select encrypt data.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/kms/infisical-kms/kms-key-options.png" alt="kms key options" />

        Populate the text area with your data and tap on the Encrypt button.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/kms/infisical-kms/kms-encrypt-data.png" alt="kms encrypt data" />

        <Note>
          If your data is already Base64 encoded make sure to toggle the respective switch on to avoid
          redundant encoding.
        </Note>

        Copy and store the encrypted data.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/kms/infisical-kms/kms-encrypted-data.png" alt="kms encrypted data" />
      </Step>
    </Steps>
  </Tab>

  <Tab title="API">
    <Steps>
      <Step title="Creating a KMS key">
        To create a cryptographic key, make an API request to the [Create KMS
        Key](/api-reference/endpoints/kms/keys/create) API endpoint.

        ### Sample request

        ```bash Request theme={"dark"}
        curl --request POST \
        --url https://app.infisical.com/api/v1/kms/keys \
        --header 'Content-Type: application/json' \
        --data '{
            "projectId": "<project-id>",
            "name": "my-secret-key",
            "description": "...",
            "encryptionAlgorithm": "aes-256-gcm"
        }'
        ```

        ### Sample response

        ```bash Response theme={"dark"}
        {
            "key": {
                "id": "<key-id>",
                "description": "...",
                "isDisabled": false,
                "isReserved": false,
                "orgId": "<org-id>",
                "name": "my-secret-key",
                "createdAt": "2023-11-07T05:31:56Z",
                "updatedAt": "2023-11-07T05:31:56Z",
                "projectId": "<project-id>"
            }
        }
        ```
      </Step>

      <Step title="Encrypting data with the KMS key">
        To encrypt data, make an API request to the [Encrypt
        Data](/api-reference/endpoints/kms/encryption/encrypt) API endpoint,
        specifying the key to use.

        <Note>
          Make sure your data is Base64 encoded
        </Note>

        ### Sample request

        ```bash Request theme={"dark"}
        curl --request POST \
        --url https://app.infisical.com/api/v1/kms/keys/<key-id>/encrypt \
        --header 'Content-Type: application/json' \
        --data '{
            "plaintext": "lUFHM5Ggwo6TOfpuN1S==" // base64 encoded plaintext
        }'
        ```

        ### Sample response

        ```bash Response theme={"dark"}
        {
            "ciphertext": "HwFHwSFHwlMF6TOfp==" // base64 encoded ciphertext
        }
        ```
      </Step>
    </Steps>
  </Tab>
</Tabs>

### Guide to Decrypting Data

In the following steps, we explore how to use decrypt data using an existing key in Infisical KMS.

<Tabs>
  <Tab title="Infisical UI">
    <Steps>
      <Step title="Accessing your key">
        Navigate to Project > Key Management and open the options menu for the key used to encrypt the data
        you want to decrypt.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/kms/infisical-kms/kms-decrypt-options.png" alt="kms key options" />
      </Step>

      <Step title="Decrypting your data">
        Paste your encrypted data into the text area and tap on the Decrypt button. Optionally, if your data was
        originally plain text, enable the decode Base64 switch.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/kms/infisical-kms/kms-decrypt-data.png" alt="kms decrypt data" />

        Your decrypted data will be displayed and can be copied for use.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/kms/infisical-kms/kms-decrypted-data.png" alt="kms decrypted data" />
      </Step>
    </Steps>
  </Tab>

  <Tab title="API">
    <Steps>
      <Step title="Decrypting data">
        To decrypt data, make an API request to the [Decrypt
        Data](/api-reference/endpoints/kms/encryption/decrypt) API endpoint,
        specifying the key to use.

        ### Sample request

        ```bash Request theme={"dark"}
        curl --request POST \
        --url https://app.infisical.com/api/v1/kms/keys/<key-id>/decrypt \
        --header 'Content-Type: application/json' \
        --data '{
            "ciphertext": "HwFHwSFHwlMF6TOfp==" // base64 encoded ciphertext
        }'
        ```

        ### Sample response

        ```bash Response theme={"dark"}
        {
            "plaintext": "lUFHM5Ggwo6TOfpuN1S==" // base64 encoded plaintext
        }
        ```
      </Step>
    </Steps>
  </Tab>
</Tabs>

## Signing

### Guide to Signing Data

In the following steps, we explore how to generate a key and use it to sign data.

<Tabs>
  <Tab title="Infisical UI">
    <Steps>
      <Step title="Creating a KMS key">
        Navigate to Project > Key Management and tap on the **Add Key** button.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/kms/infisical-kms/kms-add-key.png" alt="kms add key button" />

        Specify your key details. Here's some guidance on each field:

        * Name: A slug-friendly name for the key.
        * Key Usage: The type of key to create (e.g `Encrypt/Decrypt` for encryption, and `Sign/Verify` for signing).
        * Algorithm: The signing algorithm associated with the key (e.g. `RSA_4096`).
        * Description: An optional description of what the intended usage is for the key.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/kms/infisical-kms/signing/add-new-rsa-key.png" alt="kms add key modal" />
      </Step>

      <Step title="Signing data with the KMS key">
        Once your key is generated, open the options menu for the newly created key and select sign data.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/kms/infisical-kms/signing/sign-options.png" alt="kms key options" />

        Populate the text area with your data and tap on the Sign button.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/kms/infisical-kms/signing/sign-data-modal.png" alt="kms sign data" />

        Make sure to select the appropriate signing algorithm that will be used to sign the data.
        Supported signing algorithms are:

        **For RSA keys:**

        * `RSASSA PSS SHA 512`: Not deterministic, and includes random salt.
        * `RSASSA PSS SHA 384`: Not deterministic, and includes random salt.
        * `RSASSA PSS SHA 256`: Not deterministic, and includes random salt.
        * `RSASSA PKCS1 V1.5 SHA 512`: Deterministic, and does not include randomness.
        * `RSASSA PKCS1 V1.5 SHA 384`: Deterministic, and does not include randomness.
        * `RSASSA PKCS1 V1.5 SHA 256`: Deterministic, and does not include randomness.

        **For ECC keys:**

        * `ECDSA SHA 512`: Not deterministic, and includes randomness.
        * `ECDSA SHA 384`: Not deterministic, and includes randomness.
        * `ECDSA SHA 256`: Not deterministic, and includes randomness.

        In this example, we'll use the `RSASSA PSS SHA 512` signing algorithm.

        <Note>
          If your data is already Base64 encoded make sure to toggle the respective switch on to avoid
          redundant encoding.
        </Note>

        Copy and store the signature of your data.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/kms/infisical-kms/signing/copy-signature.png" alt="kms signed data" />
      </Step>
    </Steps>
  </Tab>

  <Tab title="API">
    <Steps>
      <Step title="Signing data">
        To sign data, make an API request to the [Sign
        Data](/api-reference/endpoints/kms/signing/sign) API endpoint,
        specifying the key to use.

        ### Sample request

        ```bash Request theme={"dark"}
        curl --request POST \
        --url https://app.infisical.com/api/v1/kms/keys/<key-id>/sign \
        --header 'Content-Type: application/json' \
        --data '{
            "data": "SGVsbG8sIFdvcmxkIQ==", // base64 encoded data
            "signingAlgorithm": "RSASSA_PKCS1_V1_5_SHA_512",
        }'
        ```

        ### Sample response

        ```bash Response theme={"dark"}
        {
            "signature": "JYuiBt1Ta9pbqFIW9Ou6qzBsFhjYbMJp9k4dP87ILrO+F2MPnp85g3nOlXK1ttZmRoGWsWnLNDRn9W3rf5VtkeaixPqUW/KvY/fM3CxdMyIV3BuxlGgDksjL8X34Eqkrz4CCPo9hjB5uT+rBCOxCgZqRbOdATPipAneUapI9npseNquEeh3jPklwviBix83PJHV9PW2t03AGGUXuMY55ZaFEIMv+IrI1WYdnPVIXDyIitYsS3y+/6KRfhVeTcPNJ5Rw+FE9y1eZzDEZtTNpxOfUT3QIoXmpZlYL4HbhRuJBZ+Yx54C7uPiUIN9U69XbyXt+Kkynykw2HPaagwuCZxiqCU5sFfLnrVbc3dmZxQcX2yRrs2gmFamzBx+uVbi648H4mb7WuE5UPTBjjA11jRsBjCY0YS2T4Vgfe1RlzlPQkZgjP/bnCCGDqXa3/VZAlZX1nTI51X995bPHBQI0rq2sNDlIXenwiAy1wJSITbSI8DbUx09Cr83xCEaYAE6R6PUfog/tbIUXi0VbrYsCVkAGCK446Wb1vW6q7HR8jrjXNwmXlqN9eLbSVWqdWj7N7fieeTYSrECtUaAjxtUYTIVsH2bfT6FOEM9gMWKffOpFowVzzr3B9bNQLIhnEEwebxBw947i4OcxyVIcEUuumWxoKvcbSPxzJ8v1M3SoBBh4=", // base64 encoded signature
            "keyId": "62b2c14e-58af-4199-9842-02995c63edf9",
            "signingAlgorithm": "RSASSA_PKCS1_V1_5_SHA_512",
        }
        ```

        <Note>
          To sign predigested data, you can pass `"isDigest": true` in the request body. This requires the data to be a base64 encoded digest of the data you wish to sign.
          It's important that the digest is created using the same hashing algorithm as the signing algorithm. As an example, you would create the digest with `SHA512` if you are using the `RSASSA_PKCS1_V1_5_SHA_512` signing algorithm.
        </Note>
      </Step>
    </Steps>
  </Tab>
</Tabs>

### Guide to Verifying Data

In the following steps, we explore how to verify data using an existing key in Infisical KMS.

<Tabs>
  <Tab title="Infisical UI">
    <Steps>
      <Step title="Accessing your key">
        Navigate to Project > Key Management and open the options menu for the key used to sign the data
        you want to verify.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/kms/infisical-kms/signing/sign-options.png" alt="kms key options" />
      </Step>

      <Step title="Verifying data with the KMS key">
        Paste your signature and data into the text areas and tap on the Verify button.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/kms/infisical-kms/signing/verify-data-modal.png" alt="kms verify data" />

        Your verification result will be displayed and can be copied for use.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/kms/infisical-kms/signing/signature-verified.png" alt="kms verified data" />

        If the signature is invalid, you'll see an error message indicating that the signature is invalid, and the "Signature Status" field will be `Invalid`.
      </Step>
    </Steps>
  </Tab>

  <Tab title="API">
    <Steps>
      <Step title="Verifying data">
        To verify data, make an API request to the [Verify
        Data](/api-reference/endpoints/kms/signing/verify) API endpoint,
        specifying the key to use.

        ### Sample request

        ```bash Request theme={"dark"}
        curl --request POST \
        --url https://app.infisical.com/api/v1/kms/keys/<key-id>/verify \
        --header 'Content-Type: application/json' \
        --data '{
            "data": "SGVsbG8sIFdvcmxkIQ==", // base64 encoded data
            "signature": "JYuiBt1Ta9pbqFIW9Ou6qzBsFhjYbMJp9k4dP87ILrO+F2MPnp85g3nOlXK1ttZmRoGWsWnLNDRn9W3rf5VtkeaixPqUW/KvY/fM3CxdMyIV3BuxlGgDksjL8X34Eqkrz4CCPo9hjB5uT+rBCOxCgZqRbOdATPipAneUapI9npseNquEeh3jPklwviBix83PJHV9PW2t03AGGUXuMY55ZaFEIMv+IrI1WYdnPVIXDyIitYsS3y+/6KRfhVeTcPNJ5Rw+FE9y1eZzDEZtTNpxOfUT3QIoXmpZlYL4HbhRuJBZ+Yx54C7uPiUIN9U69XbyXt+Kkynykw2HPaagwuCZxiqCU5sFfLnrVbc3dmZxQcX2yRrs2gmFamzBx+uVbi648H4mb7WuE5UPTBjjA11jRsBjCY0YS2T4Vgfe1RlzlPQkZgjP/bnCCGDqXa3/VZAlZX1nTI51X995bPHBQI0rq2sNDlIXenwiAy1wJSITbSI8DbUx09Cr83xCEaYAE6R6PUfog/tbIUXi0VbrYsCVkAGCK446Wb1vW6q7HR8jrjXNwmXlqN9eLbSVWqdWj7N7fieeTYSrECtUaAjxtUYTIVsH2bfT6FOEM9gMWKffOpFowVzzr3B9bNQLIhnEEwebxBw947i4OcxyVIcEUuumWxoKvcbSPxzJ8v1M3SoBBh4=", // base64 encoded signature
            "signingAlgorithm": "RSASSA_PKCS1_V1_5_SHA_512"
        }'
        ```

        ### Sample response

        ```bash Response theme={"dark"}
        {
            "signatureValid": true,
            "keyId": "62b2c14e-58af-4199-9842-02995c63edf9",
            "signingAlgorithm": "RSASSA_PKCS1_V1_5_SHA_512"
        }
        ```

        <Note>
          To verify predigested data, you can pass `"isDigest": true` in the request body. This requires the data to be a base64 encoded digest of the data you wish to verify.
          It's important that the digest is created using the same hashing algorithm as the signing algorithm. As an example, you would create the digest with `SHA512` if you are using the `RSASSA_PKCS1_V1_5_SHA_512` signing algorithm.
        </Note>
      </Step>
    </Steps>
  </Tab>
</Tabs>

## FAQ

<AccordionGroup>
  <Accordion title="Is my data stored in Infisical KMS?">
    No. Infisical's KMS only provides cryptographic services and does not store
    any encrypted or decrypted data.
  </Accordion>

  <Accordion title="Can key material be accessed outside of Infisical KMS?">
    No. Infisical's KMS will never expose your keys, encrypted or decrypted, to
    external sources.
  </Accordion>

  <Accordion title="What algorithms does Infisical KMS support?">
    Currently Infisical supports 4 different key algorithms with different purposes:

    * `RSA_4096`: For signing and verifying data.

    * `ECC_NIST_P256`: For signing and verifying data.

    * `AES-256-GCM`: For encryption and decryption operations.

    * `AES-128-GCM`: For encryption and decryption operations.

    We anticipate to further expand our supported algorithms and support cryptographic operations in the future.
  </Accordion>

  <Accordion title="How do I sign and verify a digest using the Infisical KMS?">
    To sign and verify a digest using the Infisical KMS, you can use the `Sign` and `Verify` endpoints respectively.
    You will need to pass `"isDigest": true` in the request body to indicate that you are signing or verifying a digest.
    The data you are signing or verifying will need to be a base64 encoded digest of the data you wish to sign or verify.
    It's important that the digest is created using the same hashing algorithm as the signing algorithm. As an example, you would create the digest with `SHA512` if you are using the `RSASSA_PKCS1_V1_5_SHA_512` signing algorithm.

    To create a SHA512 digest of your data, you can use the following command with OpenSSL:

    ```bash  theme={"dark"}
    echo -n "Hello, World" | openssl dgst -sha512 -binary | openssl base64
    ```

    ### Sample request for signing a digest

    ```bash Request theme={"dark"}
    curl --request POST \
    --url https://app.infisical.com/api/v1/kms/keys/<key-id>/sign \
    --header 'Content-Type: application/json' \
    --data '{
    "data": <digest-output-of-openssl-command>,
    "signingAlgorithm": "RSASSA_PKCS1_V1_5_SHA_512",
    "isDigest": true
    }'
    ```

    ### Sample response for signing a digest

    ```bash Response theme={"dark"}
    {
        "signature": <base64-encoded-signature>,
        "keyId": <key-id>,
        "signingAlgorithm": "RSASSA_PKCS1_V1_5_SHA_512"
    }
    ```

    ### Sample request for verifying a digest

    ```bash Request theme={"dark"}
    curl --request POST \
    --url https://app.infisical.com/api/v1/kms/keys/<key-id>/verify \
    --header 'Content-Type: application/json' \
    --data '{
    "data": <digest-output-of-openssl-command>,
    "signature": <base64-encoded-signature>,
    "signingAlgorithm": "RSASSA_PKCS1_V1_5_SHA_512",
    "isDigest": true
    }'
    ```

    ### Sample response for verifying a digest

    ```bash Response theme={"dark"}
    {
        "signatureValid": true,
        "keyId": <key-id>,
        "signingAlgorithm": "RSASSA_PKCS1_V1_5_SHA_512"
    }
    ```

    <Note>
      Please note that `RSA PSS` signing algorithms are not supported for digest signing and verification. Please use `RSA PKCS1 V1.5` signing algorithms for digest signing and verification, or `ECDSA` if you're using an ECC key.
    </Note>
  </Accordion>
</AccordionGroup>


# General LDAP
Source: https://infisical.com/docs/documentation/platform/ldap/general

Learn how to log in to Infisical with LDAP.

<Info>
  LDAP is a paid feature. If you're using Infisical Cloud, then it is available
  under the **Enterprise Tier**. If you're self-hosting Infisical, then you
  should contact [sales@infisical.com](mailto:sales@infisical.com) to purchase an enterprise license to use
  it.
</Info>

You can configure your organization in Infisical to have members authenticate with the platform via [LDAP](https://en.wikipedia.org/wiki/Lightweight_Directory_Access_Protocol)

Prerequisites:

* You must have an email address to use LDAP, regardless of whether or not you use that email address to sign in.

<Steps>
  <Step title="Prepare the LDAP configuration in Infisical">
    In Infisical, head to the **Single Sign-On (SSO)** page and select the **General** tab. Select **Connect** for **LDAP**.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/connect-ldap.png" alt="LDAP SSO Connect" />

    Next, input your LDAP server settings.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/ldap/ldap-config.png" alt="LDAP configuration" />

    Here's some guidance for each field:

    * URL: The LDAP server to connect to such as `ldap://ldap.your-org.com`, `ldaps://ldap.myorg.com:636` (for connection over SSL/TLS), etc.
    * Bind DN: The distinguished name of object to bind when performing the user search such as `cn=infisical,ou=Users,dc=acme,dc=com`.
    * Bind Pass: The password to use along with `Bind DN` when performing the user search.
    * User Search Base / User DN: Base DN under which to perform user search such as `ou=Users,dc=acme,dc=com`.
    * Unique User Attribute: The attribute to use as the unique identifier of LDAP users such as `sAMAccountName`, `cn`, `uid`, `objectGUID` ... If left blank, defaults to `uidNumber`
    * User Search Filter (optional): Template used to construct the LDAP user search filter such as `(uid={{username}})`; use literal `{{username}}` to have the given username used in the search. The default is `(uid={{username}})` which is compatible with several common directory schemas.
    * Group Search Base / Group DN (optional): LDAP search base to use for group membership search such as `ou=Groups,dc=acme,dc=com`.
    * Group Filter (optional): Template used when constructing the group membership query such as `(&(objectClass=posixGroup)(memberUid={{.Username}}))`. The template can access the following context variables: \[`UserDN`, `UserName`]. The default is `(|(memberUid={{.Username}})(member={{.UserDN}})(uniqueMember={{.UserDN}}))` which is compatible with several common directory schemas.
    * CA Certificate: The CA certificate to use when verifying the LDAP server certificate.

    <Note>
      The **Group Search Base / Group DN** and **Group Filter** fields are both required if you wish to sync LDAP groups to Infisical.
    </Note>
  </Step>

  <Step title="Test the LDAP connection">
    Once you've filled out the LDAP configuration, you can test that part of the configuration is correct by pressing the **Test Connection** button.

    Infisical will attempt to bind to the LDAP server using the provided **URL**, **Bind DN**, and **Bind Pass**. If the operation is successful, then Infisical will display a success message; if not, then Infisical will display an error message and provide a fuller error in the server logs.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/ldap/ldap-test-connection.png" alt="LDAP test connection" />
  </Step>

  <Step title="Define mappings from LDAP groups to groups in Infisical">
    In order to sync LDAP groups to Infisical, head to the **LDAP Group Mappings** section to define mappings from LDAP groups to groups in Infisical.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/ldap/ldap-group-mappings-section.png" alt="LDAP group mappings section" />

    Group mappings ensure that users who log into Infisical via LDAP are added to or removed from the Infisical group(s) that corresponds to the LDAP group(s) they are a member of.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/ldap/ldap-group-mappings-table.png" alt="LDAP group mappings table" />

    Each group mapping consists of two parts:

    * LDAP Group CN: The common name of the LDAP group to map.
    * Infisical Group: The Infisical group to map the LDAP group to.

    For example, suppose you want to automatically add a user who is part of the LDAP group with CN `Engineers` to the Infisical group `Engineers` when the user sets up their account with Infisical.

    In this case, you would specify a mapping from the LDAP group with CN `Engineers` to the Infisical group `Engineers`.
    Now when the user logs into Infisical via LDAP, Infisical will check the LDAP groups that the user is a part of whilst referencing the group mappings you created earlier. Since the user is a member of the LDAP group with CN `Engineers`, they will be added to the Infisical group `Engineers`.
    In the future, if the user is no longer part of the LDAP group with CN `Engineers`, they will be removed from the Infisical group `Engineers` upon their next login.

    <Note>
      Prior to defining any group mappings, ensure that you've created the Infisical groups that you want to map the LDAP groups to.
      You can read more about creating (user) groups in Infisical [here](/documentation/platform/groups).
    </Note>
  </Step>

  <Step title="Enable LDAP in Infisical">
    Enabling LDAP allows members in your organization to log into Infisical via LDAP.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/ldap/ldap-toggle.png" alt="LDAP toggle" />
  </Step>
</Steps>


# JumpCloud LDAP
Source: https://infisical.com/docs/documentation/platform/ldap/jumpcloud

Learn how to configure JumpCloud LDAP for authenticating into Infisical.

<Info>
  LDAP is a paid feature. If you're using Infisical Cloud, then it is available
  under the **Enterprise Tier**. If you're self-hosting Infisical, then you
  should contact [sales@infisical.com](mailto:sales@infisical.com) to purchase an enterprise license to use
  it.
</Info>

Prerequisites:

* You must have an email address to use LDAP, regardless of whether or not you use that email address to sign in.

<Steps>
  <Step title="Prepare LDAP in JumpCloud">
    In JumpCloud, head to USER MANAGEMENT > Users and create a new user via the **Manual user entry** option. This user
    will be used as a privileged service account to facilitate Infisical's ability to bind/search the LDAP directory.

    When creating the user, input their **First Name**, **Last Name**, **Username** (required), **Company Email** (required), and **Description**.
    Also, create a password for the user.

    Next, under User Security Settings and Permissions > Permission Settings, check the box next to **Enable as LDAP Bind DN**.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/ldap/jumpcloud/ldap-jumpcloud-enable-bind-dn.png" alt="LDAP JumpCloud" />
  </Step>

  <Step title="Prepare the LDAP configuration in Infisical">
    In Infisical, head to the **Single Sign-On (SSO)** page and select the **General** tab. Select **Connect** for **LDAP**.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/connect-ldap.png" alt="LDAP SSO Connect" />

    Next, input your JumpCloud LDAP server settings.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/ldap/ldap-config.png" alt="LDAP configuration" />

    Here's some guidance for each field:

    * URL: The LDAP server to connect to (`ldaps://ldap.jumpcloud.com:636`).
    * Bind DN: The distinguished name of object to bind when performing the user search (`uid=<ldap-user-username>,ou=Users,o=<your-org-id>,dc=jumpcloud,dc=com`).
    * Bind Pass: The password to use along with `Bind DN` when performing the user search.
    * User Search Base / User DN: Base DN under which to perform user search (`ou=Users,o=<your-org-id>,dc=jumpcloud,dc=com`).
    * Unique User Attribute: The attribute to use as the unique identifier of LDAP users such as `sAMAccountName`, `cn`, `uid`, `objectGUID` ... If left blank, defaults to `uidNumber`
    * User Search Filter (optional): Template used to construct the LDAP user search filter (`(uid={{username}})`).
    * Group Search Base / Group DN (optional): LDAP search base to use for group membership search (`ou=Users,o=<your-org-id>,dc=jumpcloud,dc=com`).
    * Group Filter (optional): Template used when constructing the group membership query (`(&(objectClass=groupOfNames)(member=uid={{.Username}},ou=Users,o=<your-org-id>,dc=jumpcloud,dc=com))`)
    * CA Certificate: The CA certificate to use when verifying the LDAP server certificate (instructions to obtain the certificate for JumpCloud [here](https://jumpcloud.com/support/connect-to-ldap-with-tls-ssl)).

    <Tip>
      When filling out the **Bind DN** and **Bind Pass** fields, refer to the username and password of the user created in Step 1.

      Also, for the **Bind DN** and **Search Base / User DN** fields, you'll want to use the organization ID that appears
      in your LDAP instance **ORG DN**.
    </Tip>
  </Step>

  <Step title="Test the LDAP connection">
    Once you've filled out the LDAP configuration, you can test that part of the configuration is correct by pressing the **Test Connection** button.

    Infisical will attempt to bind to the LDAP server using the provided **URL**, **Bind DN**, and **Bind Pass**. If the operation is successful, then Infisical will display a success message; if not, then Infisical will display an error message and provide a fuller error in the server logs.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/ldap/ldap-test-connection.png" alt="LDAP test connection" />
  </Step>

  <Step title="Define mappings from LDAP groups to groups in Infisical">
    In order to sync LDAP groups to Infisical, head to the **LDAP Group Mappings** section to define mappings from LDAP groups to groups in Infisical.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/ldap/ldap-group-mappings-section.png" alt="LDAP group mappings section" />

    Group mappings ensure that users who log into Infisical via LDAP are added to or removed from the Infisical group(s) that corresponds to the LDAP group(s) they are a member of.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/ldap/ldap-group-mappings-table.png" alt="LDAP group mappings table" />

    Each group mapping consists of two parts:

    * LDAP Group CN: The common name of the LDAP group to map.
    * Infisical Group: The Infisical group to map the LDAP group to.

    For example, suppose you want to automatically add a user who is part of the LDAP group with CN `Engineers` to the Infisical group `Engineers` when the user sets up their account with Infisical.

    In this case, you would specify a mapping from the LDAP group with CN `Engineers` to the Infisical group `Engineers`.
    Now when the user logs into Infisical via LDAP, Infisical will check the LDAP groups that the user is a part of whilst referencing the group mappings you created earlier. Since the user is a member of the LDAP group with CN `Engineers`, they will be added to the Infisical group `Engineers`.
    In the future, if the user is no longer part of the LDAP group with CN `Engineers`, they will be removed from the Infisical group `Engineers` upon their next login.

    <Note>
      Prior to defining any group mappings, ensure that you've created the Infisical groups that you want to map the LDAP groups to.
      You can read more about creating (user) groups in Infisical [here](/documentation/platform/groups).
    </Note>
  </Step>

  <Step title="Enable LDAP in Infisical">
    Enabling LDAP allows members in your organization to log into Infisical via LDAP.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/ldap/ldap-toggle.png" alt="LDAP toggle" />
  </Step>
</Steps>

Resources:

* [JumpCloud Cloud LDAP Guide](https://jumpcloud.com/support/use-cloud-ldap)


# LDAP Overview
Source: https://infisical.com/docs/documentation/platform/ldap/overview

Learn how to authenticate into Infisical with LDAP.

<Info>
  LDAP is a paid feature.

  If you're using Infisical Cloud, then it is available under the **Enterprise Tier**. If you're self-hosting Infisical,
  then you should contact [sales@infisical.com](mailto:sales@infisical.com) to purchase an enterprise license to use it.
</Info>

You can configure your organization in Infisical to have members authenticate with the platform via [LDAP](https://en.wikipedia.org/wiki/Lightweight_Directory_Access_Protocol).

LDAP providers:

* Active Directory
* [JumpCloud LDAP](/documentation/platform/ldap/jumpcloud)
* AWS Directory Service
* Foxpass

Read the general instructions for configuring LDAP [here](/documentation/platform/ldap/general).

If the documentation for your required identity provider is not shown in the list above, please reach out to [team@infisical.com](mailto:team@infisical.com) for assistance.

## FAQ

<AccordionGroup>
  <Accordion title="Why does Infisical require additional email verification for users connected via LDAP?">
    By default, Infisical Cloud is configured to not trust emails from external
    identity providers to prevent any malicious account takeover attempts via
    email spoofing. Accordingly, Infisical creates a new user for anyone provisioned
    through an external identity provider and requires an additional email
    verification step upon their first login.

    If you're running a self-hosted instance of Infisical and would like it to trust emails from external identity providers,
    you can configure this behavior in the Server Admin Console.
  </Accordion>
</AccordionGroup>


# Multi-factor Authentication
Source: https://infisical.com/docs/documentation/platform/mfa

Learn how to secure your Infisical account with MFA.

MFA requires users to provide multiple forms of identification to access their account.

## Email 2FA

If 2-factor authentication is enabled in the Personal settings page, email will be used for MFA by default.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/mfa-email.png" alt="Email-based MFA" />

## Mobile Authenticator 2FA

You can use any mobile authenticator app (Authy, Google Authenticator, Duo, etc.) to secure your account. After registration with an authenticator, select **Mobile Authenticator** as your 2FA method.
<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/mfa-authenticator.png" alt="Authenticator-based MFA" />

## Entra ID / Azure AD MFA

<Note>
  Before proceeding make sure you've enabled [SAML SSO for Entra ID / Azure AD](./sso/azure).

  We also encourage you to have your team download and setup the
  [Microsoft Authenticator App](https://www.microsoft.com/en-us/security/mobile-authenticator-app) prior to enabling MFA.
</Note>

<Steps>
  <Step title="Open your Infisical Application in the Microsoft Entra Admin Center">
        <img
          src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/mfa/entra/mfa_entra_infisical_app.png"
          alt="Entra Infisical
    app"
        />
  </Step>

  <Step title="Tap on Conditional Access under the Security Tab">
        <img
          src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/mfa/entra/mfa_entra_conditional_access.png"
          alt="conditional
    access"
        />
  </Step>

  <Step title="Tap on Create New Policy from Templates">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/mfa/entra/mfa_entra_create_policy.png" alt="create policy" />
  </Step>

  <Step title="Select Require MFA for All Users and Tap on Review + Create">
        <img
          src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/mfa/entra/mfa_entra_review_policy.png"
          alt="require MFA and review
    policy"
        />

    <Note>
      By default all users except the configuring admin will be setup to require
      MFA. Microsoft encourages keeping at least one admin excluded from MFA to
      prevent accidental lockout.
    </Note>
  </Step>

  <Step title="Set Policy State to Enabled and Tap on Create">
        <img
          src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/mfa/entra/mfa_entra_confirm_policy.png"
          alt="enable policy and
    confirm"
        />
  </Step>

  <Step title="MFA is now Required When Accessing Infisical">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/mfa/entra/mfa_entra_login.png" alt="mfa login" />

    <Note>
      If users have not setup MFA for Entra / Azure they will be prompted to do
      so at this time.
    </Note>
  </Step>
</Steps>


# Organizations
Source: https://infisical.com/docs/documentation/platform/organization

Learn more and understand the concept of Infisical organizations.

Infisical is structured around organizations and [projects](/documentation/platform/project).

## Organizations

An organization represents a company or high-level entity (e.g. Acme Corp) and acts as the root scope for managing members and machine identities, projects, usage and billing, global integrations and configuration (such as single sign-on, provisioning, etc), and more.

Within an organization, you can create any number of projectseach tied to a specific product type such as Secrets Management or PKI that determines the functionality available.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/organization/organization.png" alt="organization" />

## Projects

The *Projects* tab shows a list of projects that you have access to.

If you're an organization admin, you also have the option to view *All Projects*a complete view of every project within the organization, including those you are not currently a member of and gain access to any project.

Admins can gain access to any project in the organization by opening the options menu () next to a project and selecting Access. This will add you to the project as an admin and allow full visibility and control.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/organization/organization-projects.png" alt="organization projects" />

## Roles and Access Control

The *Access Control* tab lets you view and manage roles and permissions for users, machine identities, and groups across your organization.

Users are invited to an organization and assigned organization-level roles such as `Admin` or `Member`. You can also define [custom roles](/documentation/platform/access-controls/role-based-access-controls#creating-custom-roles) at the organization level to fit your permission model.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/organization/organization-users.png" alt="organization users" />

Infisical supports [user identities](/documentation/platform/identities/user-identities) (representing people) and [machine identities](/documentation/platform/identities/machine-identities) (representing services, CI/CD pipelines, or agents). The same roles and permissions can be applied to either type of identity.

To manage access at scale, Infisical also supports [user groups](/documentation/platform/groups)  roles assigned to a group apply to all of its members automatically.

Note that Infisical distinguishes between organization-level and project-level access control:

* [Organization-level access control](/documentation/platform/access-controls/role-based-access-controls#organization-level-access-controls): Roles and permissions governing access to organization-level resources and controls such as billing, member management, and identity provider configuration.
* [Project-level access control](/documentation/platform/access-controls/role-based-access-controls#project-level-access-controls): Roles and permissions governing access to resources and workflows within a specific project (e.g., secrets, certificates, SSH hosts).

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/organization/organization-roles.png" alt="organization roles" />

To learn more about how permissions work in detail, refer to the [access control documentation](/documentation/platform/access-controls/overview).

<Info>
  Infisical provides immutable roles such as `admin` and `member` for free.

  If you're using Infisical Cloud, the ability to create custom roles is available under the **Pro Tier**.

  If you're self-hosting Infisical, then you should contact [sales@infisical.com](mailto:sales@infisical.com) to purchase an enterprise license to use it.
</Info>

## Usage & Billing

The *Usage & Billing* tab provides an overview of your organization's billing information and platform usage.

Infisical calculates usage at the organization levelaggregating activity across all projects and product types (e.g., Secrets Management, SSH, PKI). From this tab, you can track usage, view billing details, and manage your Infisical Cloud subscription.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/organization/organization-billing.png" alt="organization billing" />

## Audit Logs

Infisical provides a unified view of [audit logs](/documentation/platform/audit-logs) at the organization level. All platform activityincluding secret access, certificate issuance, platform logins across the organization is recorded and searchable in a central log view.

Audit logs are also viewable at the project level, where they are scoped to show only events relevant to that specific project. This allows project administrators to monitor activity and investigate changes without requiring organization-wide access.

## App Connections

Infisical supports [app connections](/integrations/app-connections/overview)  integrations configured at the organization level with third-party platforms such as AWS, GCP, GitHub, and many others.

Once configured, these connections can be reused across multiple projects as part of any feature that requires third-party integrationssuch as [secret syncing](/integrations/secret-syncs/overview) or [dynamic credential generation](/documentation/platform/dynamic-secrets/overview).

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/organization/organization-app-connections.png" alt="organization app connections" />

To learn more, refer to the [app connections documentation](/integrations/app-connections/overview).

## Organization Settings

The *Organization Settings* tab lets you configure global behavior and security controls for the organization.

Key configuration areas include:

* General: Manage the organizations name, slug, and default role for newly invited members.
* Single Sign-On (SSO): Enable [SAML](/documentation/platform/sso/overview), [LDAP](/documentation/platform/ldap/overview), or [OIDC-based](/documentation/platform/sso/general-oidc/overview) authentication for user login.
* Provisioning: Enable [SCIM](/documentation/platform/scim/overview) to automatically provision and deprovision users and groups from an identity provider.
* Security Policies: Enforce MFA and configure session duration limits.
* Encryption: Integrate with external KMS systems or bring your own encryption keys (BYOK).
* [Audit Log Streaming](/documentation/platform/audit-log-streams/audit-log-streams): Forward audit events to third-party logging tools like SIEMs or cloud storage.
* Workflow Integrations: Trigger [Slack](/documentation/platform/workflow-integrations/slack-integration) or [Microsoft Teams](/documentation/platform/workflow-integrations/microsoft-teams-integration) notifications for events like access requests.
* [Project Templates](/documentation/platform/project-templates): Define default environments, roles, and settings to standardize project creation.
* KMIP (Enterprise): Connect to KMIP-compatible HSMs for hardware-backed key storage and operations.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/organization/organization-settings.png" alt="organization settings" />


# Infisical PAM
Source: https://infisical.com/docs/documentation/platform/pam/overview

Learn how to manage access to resources like databases, servers, and accounts with policy-based controls and approvals.

Infisical Privileged Access Management (PAM) provides a centralized way to manage and secure access to your critical infrastructure. It allows you to enforce fine-grained, policy-based controls over resources like databases, servers, and more, ensuring that only authorized users can access sensitive systems, and only when they need to.

### How it Works

Infisical PAM employs a resource-based model to organize and manage access. This model is designed to be intuitive and scalable.

#### 1. Create a Resource

The first step is to define a resource you want to manage. A resource represents a target system, such as a PostgreSQL database. When creating a resource, you'll provide the necessary connection details, like the host and port.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/pam/overview/create-resource.png" alt="Create Resource" />

#### 2. Add Accounts to the Resource

Once a resource is created, you can add accounts to it. An account represents a specific set of credentials (e.g., a username and password) that can be used to access the resource. This allows you to manage multiple sets of credentials for a single database or server from one place.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/pam/overview/create-account.png" alt="Create Account" />

### Infisical PAM Features

#### Session Logging and Auditing

* **Session Logging**: All user sessions are extensively logged, providing a detailed and searchable record of activities performed during a session.
* **Audit Logging**: Every significant event, such as a user starting a session or accessing an account's credentials, is recorded in audit logs. This gives you complete visibility over your project.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/pam/overview/session-page.png" alt="Session Page" />

#### Automated Credential Rotation

Infisical PAM can automatically rotate account credentials to enhance your security posture.

Heres how it works:

1. **Add a Rotation Account**: On the resource level, you configure a "rotation account." This is a master or privileged account that has the necessary permissions to change the passwords of other accounts on that same resource.
   <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/pam/overview/credential-rotation-account.png" alt="Credential Rotation Account" />

2. **Configure Rotation on Accounts**: For each individual account you want to rotate, you can simply enable rotation and set a desired interval (e.g., every 30 days).
   <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/pam/overview/rotate-credentials-account.png" alt="Rotate Credentials Account" />

Infisical will then use the rotation account on the resource to automatically update the credentials of the target account at the specified interval, eliminating credential staleness.


# Session Recording
Source: https://infisical.com/docs/documentation/platform/pam/session-recording

Learn how Infisical records and stores session activity for auditing and monitoring.

Infisical's Privileged Access Management (PAM) provides robust session recording capabilities to help you audit and monitor user activity across your infrastructure.

## How It Works

When a user initiates a session through the Infisical Gateway, a recording of the session begins. The gateway securely caches all recording data in temporary encrypted files on its local system.

Once the session concludes, the gateway transmits the complete recording to the Infisical platform for long-term, centralized storage. This asynchronous process ensures that sessions remain operational even if the connection to the Infisical platform is temporarily lost. After the upload is complete, administrators can search and review the session logs in the Infisical UI.

## What's Captured

The content captured during a session depends on the type of resource being accessed.

### Database Sessions

For database connections, Infisical captures all queries executed and their corresponding responses.

<Note>
  Support for additional resource types like SSH, RDP, Kubernetes, and MCP is coming soon.
</Note>

## Viewing Recordings

To review session recordings:

1. Navigate to the **PAM Sessions** page in your project.
2. Click on a session from the list to view its details.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/pam/session-recording/sessions-page.png" alt="PAM Sessions" />

The session details page provides key information, including the complete session logs, connection status, the user who initiated it, and more.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/pam/session-recording/individual-session-page.png" alt="PAM Individual Session" />

### Searching Logs

You can use the search bar to quickly find relevant information:

* **On the main Sessions page:** Search across all session logs to locate specific queries or outputs.
* **On an individual session page:** Search within that specific session's logs to pinpoint activity.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/pam/session-recording/sessions-page-search.png" alt="PAM Sessions Search" />

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/pam/session-recording/individual-session-page-search.png" alt="PAM Individual Session Search" />

## FAQ

<AccordionGroup>
  <Accordion title="Are session recordings encrypted?">
    Yes. All session recordings are encrypted at rest by default, ensuring your audit data is always secure.
  </Accordion>

  <Accordion title="Why aren't recordings streamed in real-time?">
    Currently, Infisical uses an asynchronous approach where the gateway records the entire session locally before uploading it. This design makes your PAM sessions more resilient, as they don't depend on a constant, active connection to the Infisical platform. We may introduce live streaming capabilities in a future release.
  </Accordion>
</AccordionGroup>


# Point-in-Time Recovery
Source: https://infisical.com/docs/documentation/platform/pit-recovery

Learn how to rollback secrets and configurations to any snapshot with Infisical.

<Info>
  Point-in-Time Recovery is a paid feature. If you're using Infisical Cloud,
  then it is available under the **Pro Tier**. If you're self-hosting Infisical,
  then you should contact [sales@infisical.com](mailto:sales@infisical.com) to purchase an enterprise license
  to use it.
</Info>

Infisical's point-in-time recovery functionality allows secrets to be rolled back to any point in time for any given [folder](./folder) or [environment](/documentation/platform/project#project-environments).

<Tabs>
  <Tab title="Commits Interface">
    ## Understanding Commits

    Similar to Git, a commit in Infisical represents a snapshot of changes made to your project's resources at a specific point in time. Each commit is scoped to an environment and [folder](./folder) within it. Unlike the legacy snapshot system, the new commits interface provides granular tracking of individual changes, allowing you to see exactly what was modified, added, or removed in each commit.

    ### Accessing Commits

    From your secrets management interface, you can access the commits functionality by clicking the **Commits Button**. This button is located in the top-right area of your secrets view and shows the number of commits for the current folder (e.g., "4 Commits").

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/pit-recovery/pit-recovery-revamp/pit-commits-button.png" alt="Commits Button" />

    ### Commits List View

    The commits page displays a comprehensive chronological history of all changes made to your environment and folders:

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/pit-recovery/pit-recovery-revamp/pit-commits-history.png" alt="Commits List View" />

    * **Chronological Sorting**: Commits are grouped by date
    * **Commit Information**: Each commit shows:
      * Commit message
      * Author information
      * Relative timestamp
      * Unique commit hash identifier
    * **Search Functionality**: Use the search bar to quickly find specific commits
    * **Sorting Options**: Sort commits by various criteria using the sort controls

    ### Detailed Commit Inspection

    Clicking on any commit from the list opens a detailed view showing the list of changes made in that commit.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/pit-recovery/pit-recovery-revamp/pit-commit-changes.png" alt="Detailed Commit Inspection" />

    #### Change Categories

    The commit changes details can be grouped into the following categories:

    **Folder Changes**

    * Shows folder additions, modifications, or deletions
    * Displays the folder properties changes in JSON format, including:
      * Folder name
      * Folder description

    **Secret Changes**

    * Lists all secrets that were added, updated, or removed
    * Shows the complete secret configuration including:
      * Secret key and value
      * Comments, tags  and metadata
      * Encoding settings (e.g., skipMultilineEncoding)
    * Values are displayed with appropriate masking for security

    **Visual Indicators**

    * Green "+" indicators show additions
    * Red "-" indicators show deletions
    * Modified content shows both old and new states

    ### Restoration Options

    Each commit provides two distinct restoration methods accessible via the **Restore Options** dropdown:

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/pit-recovery/pit-recovery-revamp/pit-commit-changes-options.png" alt="Restore Options" />

    #### Revert changes

    This option provides surgical precision for undoing specific modifications:

    * **Granular Control**: Reverts only the specific changes introduced in that individual commit
    * **Selective Restoration**: Preserves all other changes made after the commit
    * **Targeted Undo**: Perfect for reversing a specific problematic change without affecting other work
    * **Minimal Impact**: Only affects the resources that were modified in that particular commit
    * **Use Case**: Ideal when you want to undo a specific change while keeping all other modifications intact

    #### Roll back to this commit

    This option performs a complete restoration to the selected point in time:

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/pit-recovery/pit-recovery-revamp/pit-commit-restore.png" alt="Rollback" />

    * **Complete State Restoration**: Returns the entire folder to its exact state at the time of this commit
    * **Restore All Child Folders**: If enabled, it'll also restore all nested folders to their exact state at the time of this commit.
    * **Destructive Operation**: Discards ALL changes made after the selected commit
    * **New Commit Creation**: Creates a new commit representing this rollback operation
    * **Use Case**: Ideal when you want to completely undo a series of changes and return to a known good state

    **Warning**: This operation will undo all modifications made after the selected commit, which may include multiple secrets and configuration changes.
  </Tab>

  <Tab title="Legacy Snapshots (Deprecated)">
    <Warning>
      The snapshots interface is deprecated and will be removed in a future version. Please use the new Commits interface for more granular point-in-time recovery operations.
    </Warning>

    ## Snapshots

    Similar to Git, a commit (also known as snapshot) in Infisical is the state of your project's secrets at a specific point in time scoped to
    an environment and [folder](./folder) within it.

    To view a list of snapshots for the current folder, press the **Commits** button.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/pit-recovery/pit-recovery-commits.png" alt="PIT commits" />

    This opens up a sidebar from which you can select to view a particular snapshot:

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/pit-recovery/pit-recovery-commits-drawer.png" alt="PIT snapshots" />

    ## Rolling back

    After pressing on a snapshot from the sidebar, you can view it and roll back the state
    of the folder to that point in time by pressing the **Rollback** button.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/pit-recovery/pit-recovery-rollback.png" alt="PIT snapshot" />

    Rolling back secrets to a past snapshot creates a snapshot at the top of the stack and updates secret versions.

    <Note>
      Rollbacks are localized to not affect other folders within the same environment. This means each [folder](./folder) maintains its own independent history of changes, offering precise and isolated control over rollback actions.
      Put differently, every [folder](./folder) possesses a distinct and separate timeline, providing granular control when managing your secrets.
    </Note>
  </Tab>
</Tabs>


# Alerting
Source: https://infisical.com/docs/documentation/platform/pki/alerting

Learn how to set up alerting for expiring certificates with Infisical

## Concept

In order to ensure that your certificates are always up-to-date and not expired, you can set up alerting in Infisical for expiring CA and leaf certificates based on customizable filters.

## Guide to Creating an Alert

To create an alert, head to your Certificate Management Project > Alerting and press **Create Certificate Alert**.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/pki/alerting/alert-create.png" alt="pki alerting" />

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/pki/alerting/alert-create-modal.png" alt="pki alerting modal" />

Here's some guidance for each field in the alert configuration sequence:

* Alert Type: The type of alert to create such as **Certificate Expiration**.
* Alert Name: A slug-friendly name for the alert such as `tls-expiry-alert`.
* Description: An optional description for the alert.
* Alert Before: The time before certificate expiration to trigger the alert such as 30 days denoted by `30d`.
* Filters: A list of filters that determine which certificates the alert applies to. Each row includes a **Field**, **Operator**, and **Value** to match against. For example, you can filter for certificates with a common name containing `example.com` by setting the field to **Common Name**, the operator to **Contains**, and the value to `example.com`.
* Channels / Email Recipients: A list of email addresses to notify when the alert triggers.


# ACME-compatible CA
Source: https://infisical.com/docs/documentation/platform/pki/ca/acme-ca

Learn how to connect Infisical to an ACME-compatible CA to issue certificates.

## Concept

Infisical can connect to any upstream ACME-compatible CA (e.g. Lets's Encrypt, DigiCert, etc.) supporting the [ACME protocol](https://en.wikipedia.org/wiki/Automatic_Certificate_Management_Environment) to issue certificates back to your end-entities. This integration uses the [DNS-01 challenge](https://letsencrypt.org/docs/challenge-types/#dns-01-challenge) method as part of the ACME domain validation challenge workflow for a requested certificate.

The upstream ACME-compatible CA integration lets you connect Infisical to providers by specifying
their **ACME Directory URL** such as:

* [Let's Encrypt](/documentation/platform/pki/ca/lets-encrypt): `https://acme-v02.api.letsencrypt.org/directory`.
* [DigiCert](/documentation/platform/pki/ca/digicert): `https://acme.digicert.com/v2/acme/directory`.
* Google GTS: `https://dv.acme-v02.api.pki.goog/directory`.
* Buypass: `https://api.buypass.com/acme/directory`.
* ZeroSSL: `https://acme.zerossl.com/v2/DV90`.
* SSL.com: `https://acme.ssl.com/sslcom-dv-rsa`.

When Infisical requests a certificate from an ACME-compatible CA, it creates a TXT record at `_acme-challenge.{your-domain}` in your configured DNS provider (e.g. Route53, Cloudflare, etc.); this TXT record contains the challenge token issued by the ACME-compatible CA to validate domain control for the requested certificate.
The ACME provider checks for the existence of this TXT record to verify domain control before issuing the certificate back to Infisical.

After validation completes successfully, Infisical automatically removes the TXT record from your DNS provider.

<div align="center">
  ```mermaid  theme={"dark"}
  graph TD
      A[ACME-compatible CA] <-->|ACME v2 Protocol| B[Infisical]
      B -->|Creates TXT Records<br>via DNS Provider| C[DNS Validation]
      B -->|Manages Certificates| D[End-Entities]
  ```
</div>

We recommend reading about [ACME protocol](https://tools.ietf.org/html/rfc8555) and [DNS-01 challenges](https://letsencrypt.org/docs/challenge-types/#dns-01-challenge) for a fuller understanding of the underlying workflow.

## Workflow

A typical workflow for using Infisical with an external ACME-compatible CA consists of the following steps:

1. Setting up your DNS provider (e.g. Route53, Cloudflare, etc.) with appropriate DNS permissions.
2. Creating an [App Connection](/integrations/app-connections/overview) in Infisical to store credentials for Infisical to connect to your DNS provider and create/remove DNS records as part of the DNS-01 challenge.
3. Registering an [External CA](/documentation/platform/pki/ca/external-ca) in Infisical with the ACME type and inputting required configuration including the **ACME Directory URL** of the upstream ACME-compatible CA and the **App Connection** for your DNS provider.

Once this is complete, you can create a [certificate profile](/documentation/platform/pki/certificates/profiles) linked to the External CA proceed to request a certificate against it.

## Guide to Connecting Infisical to an ACME-compatible CA

In the following steps, we explore how to connect Infisical to an ACME-compatible CA.

<Steps>
  <Step title="Create an App Connection to your DNS provider">
    Before registering an ACME-compatible CA with Infisical, you need to set up an [App Connection](/integrations/app-connections/overview) with the appropriate permissions for Infisical to perform the DNS-01 challenge with your DNS provider.

    If you dont see a specific DNS provider listed below or need a dedicated one, please reach out to [sales@infisical.com](mailto:sales@infisical.com) and well help get that enabled for you.

    <Tabs>
      <Tab title="Route53">
        1. Navigate to your Certificate Management Project > App Connections and create a new AWS connection.

        2. Ensure your AWS connection has the following minimum permissions for Route53 DNS validation:

        ```json  theme={"dark"}
        {
          "Version": "2012-10-17",
          "Statement": [
            {
              "Effect": "Allow",
              "Action": "route53:GetChange",
              "Resource": "arn:aws:route53:::change/*"
            },
            {
              "Effect": "Allow",
              "Action": "route53:ListHostedZonesByName",
              "Resource": "*"
            },
            {
              "Effect": "Allow",
              "Action": [
                "route53:ListResourceRecordSets"
              ],
              "Resource": [
                "arn:aws:route53:::hostedzone/YOUR_HOSTED_ZONE_ID"
              ]
            },
            {
              "Effect": "Allow",
              "Action": [
                "route53:ChangeResourceRecordSets"
              ],
              "Resource": [
                "arn:aws:route53:::hostedzone/YOUR_HOSTED_ZONE_ID"
              ],
              "Condition": {
                "ForAllValues:StringEquals": {
                  "route53:ChangeResourceRecordSetsRecordTypes": [
                    "TXT"
                  ]
                }
              }
            }
          ]
        }
        ```

        Replace `YOUR_HOSTED_ZONE_ID` with your actual Route53 hosted zone ID.

        For detailed instructions on setting up an AWS connection, see the [AWS Connection](/integrations/app-connections/aws) documentation.
      </Tab>

      <Tab title="Cloudflare">
        1. Navigate to your Certificate Management Project > App Connections and create a new Cloudflare connection.

        2. Ensure your Cloudflare token has the following minimum permissions for DNS validation:

        ```
        Account:Account Settings:Read
        Zone:DNS:Edit
        ```

        For detailed instructions on setting up a Cloudflare connection, see the [Cloudflare Connection](/integrations/app-connections/cloudflare) documentation.
      </Tab>
    </Tabs>
  </Step>

  <Step title="Register an ACME-compatible CA">
    <Tabs>
      <Tab title="Infisical UI">
        To register an ACME-compatible CA, head to your Certificate Management Project > Certificate Authorities > External Certificate Authorities and press **Create CA**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/pki/ca/external-ca/create-external-ca-button.png" alt="pki register external ca" />

        Here, set the **CA Type** to **ACME** and fill out details for it.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/pki/ca/external-ca/create-external-ca-form.png" alt="pki register external ca details" />

        Here's some guidance for each field:

        * Name: A slug-friendly name for the ACME-compatible CA such as `lets-encrypt-production`.
        * DNS App Connection: The App Connection from Step 1 used for Infisical to connect to your DNS provider and create/remove DNS records as part of the DNS-01 challenge in ACME.
        * Zone / Zone ID: Enter the Zone / Zone ID for the domain(s) you'll be requesting certificates for.
        * Directory URL: Enter the **ACME Directory URL** for your desired upstream ACME-compatible CA such as `https://acme-v02.api.letsencrypt.org/directory` for Let's Encrypt.
        * Account Email: The email address to associate with your ACME account. This email will receive important notifications about your certificates.
        * EAB Key Identifier (KID): (Optional) The Key Identifier (KID) provided by your ACME CA for External Account Binding (EAB). This is required by some ACME providers (e.g., ZeroSSL, DigiCert) to link your ACME account to an external account you've pre-registered with them.
        * EAB HMAC Key: (Optional) The HMAC Key provided by your ACME CA for External Account Binding (EAB). This key is used in conjunction with the KID to prove ownership of the external account during ACME account registration.

        Finally, press **Create** to register the ACME-compatible CA with Infisical.

        Great! Youve successfully registered an external ACME-compatible CA with Infisical. Now check out the [Certificates](/documentation/platform/pki/certificates/overview) section to learn more about how to issue X.509 certificates using the ACME-compatible CA.
      </Tab>

      <Tab title="API">
        To register an ACME CA with Infisical using the API, make a request to the [Create External CA](https://infisical.com/docs/api-reference/endpoints/certificate-authorities/acme/create) endpoint:

        ### Sample request

        ```bash Request theme={"dark"}
        curl 'https://app.infisical.com/api/v1/pki/ca/acme' \
          -H 'Authorization: Bearer <your-access-token>' \
          -H 'Content-Type: application/json' \
          --data-raw '{
            "projectId": "0fccb6ee-1381-4ff1-8d5f-0cb93c6cc4d6",
            "name": "lets-encrypt-production",
            "type": "acme",
            "status": "active",
            "enableDirectIssuance": true,
            "configuration": {
              "dnsAppConnection": {
                "id": "1e5f8c0d-09d2-492c-9b28-469acd8e841b",
                "name": "acme-dns-test-connection"
              },
              "dnsProviderConfig": {
                "provider": "route53",
                "hostedZoneId": "Z040441124N1GOOMCQYX1"
              },
              "directoryUrl": "https://acme-v02.api.letsencrypt.org/directory",
              "accountEmail": "admin@example.com",
              "dnsAppConnectionId": "1e5f8c0d-09d2-492c-9b28-469acd8e841b"
            }
          }'
        ```

        ### Sample response

        ```bash Response theme={"dark"}
        {
            "id": "c48b701e-a20c-4a9a-8119-68f54e5fbb05",
            "name": "lets-encrypt-production",
            "type": "acme",
            "status": "active",
            "projectId": "0fccb6ee-1381-4ff1-8d5f-0cb93c6cc4d6",
            "enableDirectIssuance": true,
            "configuration": {
                "accountEmail": "admin@example.com",
                "directoryUrl": "https://acme-v02.api.letsencrypt.org/directory",
                "dnsAppConnection": {
                "id": "1e5f8c0d-09d2-492c-9b28-469acd8e841b",
                "name": "acme-dns-test-connection"
                },
                "dnsAppConnectionId": "1e5f8c0d-09d2-492c-9b28-469acd8e841b",
                "dnsProviderConfig": {
                "provider": "route53",
                "hostedZoneId": "Z040441124N1GOOMCQYX1"
                }
            }
        }
        ```
      </Tab>
    </Tabs>
  </Step>
</Steps>

## FAQ

<AccordionGroup>
  <Accordion title="What DNS validation methods are supported?">
    Currently, Infisical supports DNS-01 validation through AWS Route53 or Cloudflare. The DNS-01 challenge method is preferred for ACME integrations because it:

    * Works with wildcard certificates
    * Doesn't require your servers to be publicly accessible
    * Can be fully automated without manual intervention

    Support for additional DNS providers is planned for future releases.
  </Accordion>

  <Accordion title="Can I use wildcard certificates with ACME CAs?">
    Yes! ACME CAs like Let's Encrypt support wildcard certificates (e.g., `*.example.com`) when using DNS-01 validation. Simply specify the wildcard domain in your subscriber configuration.

    Note that wildcard certificates still require DNS-01 validation - HTTP-01 validation cannot be used for wildcard certificates.
  </Accordion>

  <Accordion title="How long are ACME certificates valid?">
    Most ACME providers issue certificates with 90-day validity periods. This shorter validity period is designed to:

    * Encourage automation of certificate management
    * Reduce the impact of compromised certificates
    * Ensure systems stay up-to-date with certificate management practices
  </Accordion>

  <Accordion title="Can I use multiple ACME providers?">
    Yes. You can register multiple ACME CAs in the same project.
  </Accordion>
</AccordionGroup>


# Microsoft AD CS
Source: https://infisical.com/docs/documentation/platform/pki/ca/azure-adcs

Learn how to issue and manage certificates using Microsoft Active Directory Certificate Services (ADCS) with Infisical.

Issue and manage certificates using Microsoft Active Directory Certificate Services (ADCS) for enterprise-grade certificate management integrated with your existing Windows infrastructure.

## Prerequisites

Before setting up ADCS integration, ensure you have:

* Microsoft Active Directory Certificate Services (ADCS) server running and accessible
* Domain administrator account with certificate management permissions
* ADCS web enrollment enabled on your server
* Network connectivity from Infisical to the ADCS server
* **IP whitelisting**: Your ADCS server must allow connections from Infisical's IP addresses
  * For Infisical Cloud instances, see [Networking Configuration](/documentation/setup/networking) for the list of IPs to whitelist
  * For self-hosted instances, whitelist your Infisical server's IP address
* Azure ADCS app connection configured (see [Azure ADCS Connection](/integrations/app-connections/azure-adcs))

## Complete Workflow: From Setup to Certificate Issuance

This section walks you through the complete end-to-end process of setting up Azure ADCS integration and issuing your first certificate.

<Steps>
  <Step title="Navigate to External Certificate Authorities">
    In your Infisical project, go to your **Certificate Project** 
    **Certificate Authority** to access the external CAs page. <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/pki/azure-adcs/azure-adcs-external-ca-page.png" alt="External CA
    Page" />
  </Step>

  <Step title="Create New Azure ADCS Certificate Service CA">
    Click **Create CA** and configure: - **Type**: Choose **Active Directory
    Certificate Services (AD CS)** - **Name**: Friendly name for this CA (e.g.,
    "Production ADCS CA") - **App Connection**: Choose your ADCS connection from
    the dropdown <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/pki/azure-adcs/azure-adcs-external-ca-form.png" alt="External CA
    Form" />
  </Step>

  <Step title="Certificate Authority Created">
    Once created, your Azure ADCS Certificate Authority will appear in the list
    and be ready for use. <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/pki/azure-adcs/azure-adcs-external-ca-created.png" alt="External CA
    Created" />
  </Step>

  <Step title="Navigate to Subscribers">
    Go to **Subscribers** to access the subscribers page. <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/pki/azure-adcs/azure-adcs-subscribers-page.png" alt="Subscribers
    Page" />
  </Step>

  <Step title="Create New Subscriber">
    Click **Add Subscriber** and configure: - **Name**: Unique subscriber name
    (e.g., "web-server-certs") - **Certificate Authority**: Select your ADCS CA -
    **Common Name**: Certificate CN (e.g., "api.example.com") - **Certificate
    Template**: Select from dynamically loaded ADCS templates - **Subject
    Alternative Names**: DNS names, IP addresses, or email addresses - **TTL**:
    Certificate validity period (e.g., "1y" for 1 year) - **Additional Subject
    Fields**: Organization, OU, locality, state, country, email (if required by
    template) <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/pki/azure-adcs/azure-adcs-subscribers-form.png" alt="Subscribers
    Form" />
  </Step>

  <Step title="Subscriber Created">
    Your subscriber is now created and ready to issue certificates. <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/pki/azure-adcs/azure-adcs-subscribers-created.png" alt="Subscriber
    Created" />
  </Step>

  <Step title="Issue New Certificate">
    Click into your subscriber and click **Order Certificate** to generate a new
    certificate using your ADCS template. <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/pki/azure-adcs/azure-adcs-subscriber-issue-new-certificate.png" alt="Issue New
    Certificate" />
  </Step>

  <Step title="Certificate Created">
    Your certificate has been successfully issued by the ADCS server and is ready
    for use. <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/pki/azure-adcs/azure-adcs-certificate-created.png" alt="Certificate
    Created" />
  </Step>

  <Step title="View Certificate Details">
    Navigate to **Certificates** to view detailed information about all issued
    certificates, including expiration dates, serial numbers, and certificate
    chains. <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/pki/azure-adcs/azure-adcs-certificates-page.png" alt="Certificates
    Page" />
  </Step>
</Steps>

## Certificate Templates

Infisical automatically retrieves available certificate templates from your ADCS server, ensuring you can only select templates that are properly configured and accessible. The system dynamically discovers templates during the certificate authority setup and certificate issuance process.

### Common Template Types

ADCS templates you might see include:

* **Web Server**: For SSL/TLS certificates with server authentication
* **Computer**: For machine authentication certificates
* **User**: For client authentication certificates
* **Basic EFS**: For Encrypting File System certificates
* **EFS Recovery Agent**: For EFS data recovery
* **Administrator**: For administrative certificates
* **Subordinate Certification Authority**: For issuing CA certificates

### Template Requirements

Ensure your ADCS templates are configured with:

* **Enroll permissions** for your connection account
* **Auto-enroll permissions** if using automated workflows
* **Subject name requirements** matching your certificate requests
* **Key usage extensions** appropriate for your use case

<Info>
  **Dynamic Template Discovery**: Infisical queries your ADCS server in
  real-time to populate available templates. Only templates you have permission
  to use will be displayed during certificate issuance.
</Info>

## Certificate Issuance Limitations

### Immediate Issuance Only

<Warning>
  **Manual Approval Not Supported**: Infisical currently supports only
  **immediate certificate issuance**. Certificates that require manual approval
  or are held by ADCS policies cannot be issued through Infisical yet.
</Warning>

For successful certificate issuance, ensure your ADCS templates and policies are configured to:

* **Auto-approve** certificate requests without manual intervention
* **Not require** administrator approval for the templates you plan to use
* **Allow** the connection account to request and receive certificates immediately

### What Happens with Manual Approval

If a certificate request requires manual approval:

1. The request will be submitted to ADCS successfully
2. Infisical will attempt to retrieve the certificate with exponential backoff (up to 5 retries over \~1 minute)
3. If the certificate is not approved within this timeframe, the request will **fail**
4. **No background polling**: Currently, Infisical does not check for certificates that might be approved hours or days later

<Info>
  **Future Enhancement**: Background polling for delayed certificate approvals
  is planned for future releases.
</Info>

### Certificate Revocation

<Warning>
  Certificate revocation is **not supported** by the Azure ADCS connector due to
  security and complexity considerations.
</Warning>

## Advanced Configuration

### Custom Validity Periods

Enable custom certificate validity periods on your ADCS server:

```cmd  theme={"dark"}
# Run on ADCS server as Administrator
certutil -setreg policy\EditFlags +EDITF_ATTRIBUTEENDDATE
net stop certsvc
net start certsvc
```

This allows Infisical to control certificate expiration dates directly.

## Troubleshooting

### Common Issues

**Certificate Request Denied**

* Verify ADCS template permissions for your connection account
* Check template subject name requirements
* Ensure template allows the requested key algorithm and size

**Revocation Service Unavailable**

* Verify IIS is running and the revocation endpoint is accessible
* Check IIS application pool permissions
* Test endpoint connectivity from Infisical

**Template Not Found**

* Verify template exists on ADCS server and is published
* Check that your connection account has enrollment permissions for the template
* Ensure the template is properly configured and available in the ADCS web enrollment interface
* Templates are dynamically loaded - refresh the PKI Subscriber form if templates don't appear

**Certificate Request Pending/Timeout**

* Check if your ADCS template requires manual approval - Infisical only supports immediate issuance
* Verify the certificate template is configured for auto-approval
* Ensure your connection account has sufficient permissions to request certificates without approval
* Review ADCS server policies that might be holding the certificate request

**Network Connectivity Issues**

* Verify your ADCS server's firewall allows connections from Infisical
* For Infisical Cloud: Ensure Infisical's IP addresses are whitelisted (see [Networking Configuration](/documentation/setup/networking))
* For self-hosted: Whitelist your Infisical server's IP address on the ADCS server
* Test HTTPS connectivity to the ADCS web enrollment endpoint
* Check for any network security appliances blocking the connection

**Authentication Failures**

* Verify ADCS connection credentials
* Check domain account permissions
* Ensure network connectivity to ADCS server

**SSL/TLS Certificate Errors**

* For ADCS servers with self-signed or private certificates: disable "Reject Unauthorized" in the SSL tab of your Azure ADCS app connection, or provide the certificate in PEM format
* Common SSL errors: `UNABLE_TO_VERIFY_LEAF_SIGNATURE`, `SELF_SIGNED_CERT_IN_CHAIN`, `CERT_HAS_EXPIRED`
* The SSL configuration applies to all HTTPS communications between Infisical and your ADCS server
* Only HTTPS URLs are supported - HTTP connections are not allowed for security reasons


# DigiCert
Source: https://infisical.com/docs/documentation/platform/pki/ca/digicert

Learn how to connect Infisical to DigiCert to issue certificates.

## Concept

Infisical can connect to [DigiCert](https://www.digicert.com/) using the [ACME-compatible CA integration](/documentation/platform/pki/ca/acme-ca) to issue certificates back to your end-entities.

## Guide to Connecting Infisical to DigiCert CA

To connect Infisical to DigiCert, follow the steps in the [ACME-compatible CA integration](/documentation/platform/pki/ca/acme-ca) guide but use the DigiCert **ACME Directory URL**: `https://acme.digicert.com/v2/acme/directory`.

DigiCert requires **External Account Binding (EAB)** for all ACME registrations. You will need to obtain both a Key Identifier (KID) and an HMAC Key from your DigiCert account before registering the ACME CA in Infisical.

DigiCert typically issues certificates with a 90-day validity period.


# External CA
Source: https://infisical.com/docs/documentation/platform/pki/ca/external-ca

Learn how to connect External Certificate Authorities with Infisical.

## Concept

Infisical lets you integrate with External Certificate Authorities (CAs), allowing you to use existing PKI infrastructure or connect to public CAs to issue certificates for your end-entities.

<div align="center">
  ```mermaid  theme={"dark"}
  graph TD
      A1[External Public CA<br>e.g. Let's Encrypt, ZeroSSL, ...] --> Infisical
      A2[External Private CA<br>e.g. AWS Private CA, HashiCorp Vault PKI, ...] --> Infisical
  ```
</div>

As shown above, these CAs commonly fall under two categories:

* External Private CAs: CAs like AWS Private CA, HashiCorp Vault PKI, Azure ADCS, etc. that are privately owned and are used to issue certificates for internal services; these are often either cloud-hosted private CAs or on-prem / enterprise CAs.
* External Public CAs: CAs like Let's Encrypt, DigiCert, GlobalSign, etc. that are publicly trusted and are used to issue certificates for public-facing services.

Note that Infisical can act as an *ACME client*, allowing you to integrate upstream with any [ACME-compatible CA](/documentation/platform/pki/ca/acme-ca) to automate certificate issuance and renewal.

## Workflow

A typical workflow for integrating an External CA with Infisical consists of choosing the desired External CA type
and specifying the configuration or connection details necessary to connect to the CA.

The specific steps and requirements vary depending on the External CA type you choose to integrate.

## Supported External CA Types

Infisical currently supports the following External CA types out of the box:

* [ACME CA](/documentation/platform/pki/ca/acme-ca): An ACME-compatible CA that supports the ACME protocol, such as Let's Encrypt, ZeroSSL, Buypass, Digicert, etc.
* [Azure ADCS](/documentation/platform/pki/ca/azure-adcs): A Microsoft Active Directory Certificate Services (ADCS) that supports the ADCS protocol, such as AWS Private CA, Azure ADCS, etc.

If you dont see a specific external CA listed here or need a dedicated integration guide, please reach out to [sales@infisical.com](mailto:sales@infisical.com) and well help you set up the integration for your external CA.

## FAQ

<AccordionGroup>
  <Accordion title="Can I use both Private CAs and External CAs in the same project?">
    Yes. You can have both Private and External CAs in the same project.
  </Accordion>
</AccordionGroup>


# Let's Encrypt
Source: https://infisical.com/docs/documentation/platform/pki/ca/lets-encrypt

Learn how to connect Infisical to Let's Encrypt to issue certificates.

## Concept

Infisical can connect to [Let's Encrypt](https://letsencrypt.org/) using the [ACME-compatible CA integration](/documentation/platform/pki/ca/acme-ca) to issue certificates back to your end-entities.

## Guide to Connecting Infisical to Let's Encrypt CA

To connect Infisical to Let's Encrypt, follow the steps in the [ACME-compatible CA integration](/documentation/platform/pki/ca/acme-ca) guide but use the Let's Encrypt **ACME Directory URL**: `https://acme-v02.api.letsencrypt.org/directory`.

Note that Lets Encrypt issues 90-day certificates and enforces a limit of 50 certificates per registered domain per week.

We strongly recommend testing your setup against the Let's Encrypt staging environment first at the **ACME Directory URL** `https://acme-staging-v02.api.letsencrypt.org/directory` prior to switching to the production environment. This allows you to verify your DNS configuration and certificate issuance process without consuming production rate limits.


# Overview
Source: https://infisical.com/docs/documentation/platform/pki/ca/overview



Before issuing and managing certificates with Infisical, you'll need to configure a Certificate Authority (CA).

This is the trusted entity that signs and validates the X.509 certificates used to secure your end-entities.

Infisical supports two categories of CAs:

* [Internal CA](/documentation/platform/pki/ca/private-ca): Internally operated root and intermediate CAs managed within Infisical. This is useful if you need complete control over your PKI and are issuing certificates for private networks, internal services, or managed devices.
* [External CA](/documentation/platform/pki/ca/external-ca): Third-party public (e.g. Let's Encrypt, DigiCert) or private (e.g. AWS Private CA, HashiCorp Vault PKI, etc.) CAs that can be integrated with Infisical. This is useful if you want to leverage existing PKI infrastructure or issue publicly trusted certificates.


# Internal CA
Source: https://infisical.com/docs/documentation/platform/pki/ca/private-ca

Learn how to create a Private CA hierarchy with Infisical.

## Concept

Infisical lets you build your Internal PKI through a Private Certificate Authority (CA) hierarchy, enabling you to issue and manage digital certificates for your end-entities.

<div align="center">
  ```mermaid  theme={"dark"}
  graph TD
      A[Root CA]
      A --> B[Intermediate CA]
      A --> C[Intermediate CA]
  ```
</div>

## Workflow

A typical workflow for setting up a Private CA hierarchy consists of the following steps:

1. Configuring an Infisical root CA with details like name, validity period, and path length  This step is optional if you wish to use an external root CA with Infisical only serving the intermediate CAs.
2. Configuring and chaining intermediate CA(s) with details like name, validity period, path length, and imported certificate to your Root CA.
3. Managing the CA lifecycle events such as CA succession.

<Note>
  Note that this workflow can be executed via the Infisical UI or manually such
  as via API. If manually executing the workflow, you may have to create a
  Certificate Signing Request (CSR) for the intermediate CA, create an
  intermediate certificate using the root CA private key and CSR, and import the
  intermediate certificate back to the intermediate CA as part of Step 2.
</Note>

## Guide to Creating a CA Hierarchy

In the following steps, we explore how to create a simple Private CA hierarchy
consisting of an (optional) root CA and an intermediate CA.

<Tabs>
  <Tab title="Infisical UI">
    <Steps>
      <Step title="Creating a root CA">
        If you wish to use an external root CA, you can skip this step and head to step 2 to create an intermediate CA.

        To create a root CA, head to your Certificate Management Project > Certificate Authorities > Internal Certificate Authorities and press **Create CA**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/pki/ca/ca-create.png" alt="pki create ca" />

        Here, set the **CA Type** to **Root** and fill out details for the root CA.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/pki/ca/ca-create-root.png" alt="pki create root ca" />

        Here's some guidance for each field:

        * Valid Until: The date until which the CA is valid in the date time string format specified [here](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date#date_time_string_format). For example, the following formats would be valid: `YYYY`, `YYYY-MM`, `YYYY-MM-DD`, `YYYY-MM-DDTHH:mm:ss.sssZ`.
        * Path Length: The maximum number of intermediate CAs that can be chained to this CA. A path of `-1` implies no limit; a path of `0` implies no intermediate CAs can be chained.
        * Key Algorithm: The type of public key algorithm and size, in bits, of the key pair that the CA creates when it issues a certificate. Supported key algorithms are `RSA 2048`, `RSA 4096`, `ECDSA P-256`, and `ECDSA P-384` with the default being `RSA 2048`.
        * Name: A slug-friendly name for the CA.
        * Organization (O): The organization name.
        * Country (C): The country code.
        * State or Province Name: The state or province.
        * Locality Name: The city or locality.
        * Common Name: The name of the CA.

        <Note>
          The Organization, Country, State or Province Name, Locality Name, and Common Name make up the **Distinguished Name (DN)** or **subject** of the CA.
          At least one of these fields must be filled out.
        </Note>
      </Step>

      <Step title="Creating an intermediate CA">
        2.1. To create an intermediate CA, press **Create CA** again but this time specifying the **CA Type** to be **Intermediate**. Fill out the details for the intermediate CA.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/pki/ca/ca-create-intermediate.png" alt="pki create intermediate ca" />

        2.2. Next, press the **Install Certificate** option on the intermediate CA from step 1.1.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/pki/ca/ca-install-intermediate-opt.png" alt="pki install cert opt" />

        2.3a. If you created a root CA in step 1, select **Infisical CA** for the **Parent CA Type** field.

        Next, set the **Parent CA** to the root CA created in step 1 and configure the intended **Valid Until** and **Path Length** fields on the intermediate CA; feel free to use the prefilled values.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/pki/ca/ca-install-intermediate.png" alt="pki install cert" />

        Here's some guidance on each field:

        * Parent CA: The parent CA to which this intermediate CA will be chained. In this case, it should be the root CA created in step 1.
        * Valid Until: The date until which the CA is valid in the date time string format specified [here](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date#date_time_string_format). The date must be within the validity period of the parent CA.
        * Path Length: The maximum number of intermediate CAs that can be chained to this CA. The path length must be less than the path length of the parent CA.

        Finally, press **Install** to chain the intermediate CA to the root CA; this creates a Certificate Signing Request (CSR) for the intermediate CA, creates an intermediate certificate using the root CA private key and CSR, and imports the signed certificate back to the intermediate CA.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/pki/ca/cas.png" alt="pki cas" />

        Great! You've successfully created a Private CA hierarchy with a root CA and an intermediate CA. Now check out the [Certificates section](/documentation/platform/pki/certificates/overview) to learn more about how to issue X.509 certificates using the intermediate CA.

        2.3b. If you have an external root CA, select **External CA** for the **Parent CA Type** field.

        Next, use the provided intermediate CSR to generate a certificate from your external root CA and paste the PEM-encoded certificate back into the **Certificate Body** field; the PEM-encoded external root CA certificate should be pasted under the **Certificate Chain** field.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/pki/ca/ca-install-intermediate-csr.png" alt="pki ca csr" />

        Finally, press **Install** to import the certificate and certificate chain as part of the installation step for the intermediate CA

        Great! You've successfully created a Private CA hierarchy with an intermediate CA chained to an external root CA.
        Now check out the [Certificates section](/documentation/platform/pki/certificates/overview) to learn more about how to issue X.509 certificates using the intermediate CA.
      </Step>
    </Steps>
  </Tab>

  <Tab title="API">
    <Steps>
      <Step title="Creating a root CA">
        If you wish to use an external root CA, you can skip this step and head to step 2 to create an intermediate CA.

        To create a root CA, make an API request to the [Create CA](/api-reference/endpoints/certificate-authorities/create) API endpoint, specifying the `type` as `root`.

        ### Sample request

        ```bash Request theme={"dark"}
        curl --location --request POST 'https://app.infisical.com/api/v1/pki/ca' \
          --header 'Authorization: Bearer <access-token>' \
          --header 'Content-Type: application/json' \
          --data-raw '{
              "projectSlug": "<your-project-slug>",
              "type": "root",
              "commonName": "My Root CA"
          }'
        ```

        ### Sample response

        ```bash Response theme={"dark"}
        {
          ca: {
            id: "<root-ca-id>",
            type: "root",
            commonName: "My Root CA",
            ...
          }
        }
        ```

        By default, Infisical creates a root CA with the `RSA_2048` key algorithm, validity period of 10 years, with no restrictions on path length;
        you may override these defaults by specifying your own options when making the API request.
      </Step>

      <Step title="Creating an intermediate CA">
        2.1. To create an intermediate CA, make an API request to the [Create CA](/api-reference/endpoints/certificate-authorities/create) API endpoint, specifying the `type` as `intermediate`.

        ### Sample request

        ```bash Request theme={"dark"}
        curl --location --request POST 'https://app.infisical.com/api/v1/pki/ca' \
          --header 'Authorization: Bearer <access-token>' \
          --header 'Content-Type: application/json' \
          --data-raw '{
              "projectSlug": "<your-project-slug>",
              "type": "intermediate",
              "commonName": "My Intermediate CA"
          }'
        ```

        ### Sample response

        ```bash Response theme={"dark"}
        {
          ca: {
            id: "<intermediate-ca-id>",
            type: "intermediate",
            commonName: "My Intermediate CA",
            ...
          }
        }
        ```

        2.2. Next, get a certificate signing request from the intermediate CA by making an API request to the [Get CSR](/api-reference/endpoints/certificate-authorities/csr) API endpoint.

        ### Sample request

        ```bash Request theme={"dark"}
        curl --location --request GET 'https://app.infisical.com/api/v1/pki/ca/<intermediate-ca-id>/csr' \
          --header 'Authorization: Bearer <access-token>' \
          --data-raw ''
        ```

        ### Sample response

        ```bash Response theme={"dark"}
        {
          csr: "..."
        }
        ```

        If using an external root CA, then use the CSR to generate a certificate for the intermediate CA using your external root CA and skip to step 2.4.

        2.3. Next, create an intermediate certificate by making an API request to the [Sign Intermediate](/api-reference/endpoints/certificate-authorities/sign-intermediate) API endpoint
        containing the CSR from step 2.2, referencing the root CA created in step 1.

        ### Sample request

        ```bash Request theme={"dark"}
        curl --location --request POST 'https://app.infisical.com/api/v1/pki/ca/<root-ca-id>/sign-intermediate' \
          --header 'Content-Type: application/json' \
          --data-raw '{
              "csr": "<csr>",
              "notAfter": "2029-06-12"
          }'
        ```

        ### Sample response

        ```bash Response theme={"dark"}
        {
          certificate: "...",
          certificateChain: "...",
          issuingCaCertificate: "...",
          serialNumber: "...",
        }
        ```

        <Note>
          The `notAfter` value must be within the validity period of the root CA that is if the root CA is valid until `2029-06-12`, the intermediate CA must be valid until a date before `2029-06-12`.
        </Note>

        2.4. Finally, import the intermediate certificate and certificate chain from step 2.3 back to the intermediate CA by making an API request to the [Import Certificate](/api-reference/endpoints/certificate-authorities/import-cert) API endpoint.

        If using an external root CA, then import the generated certificate and root CA certificate under certificate chain back into the intermediate CA.

        ### Sample request

        ```bash Request theme={"dark"}
        curl --location --request POST 'https://app.infisical.com/api/v1/pki/ca/<intermediate-ca-id>/import-certificate' \
          --header 'Authorization: Bearer <access-token>' \
          --header 'Content-Type: application/json' \
          --data-raw '{
              "certificate": "<certificate>",
              "certificateChain": "<certificate-chain>"
          }'
        ```

        ### Sample response

        ```bash Response theme={"dark"}
        {
          message: "Successfully imported certificate to CA",
          caId: "..."
        }
        ```

        Great! Youve successfully created a Private CA hierarchy with a root CA and an intermediate CA. Now check out the [Subscribers](/documentation/platform/pki/subscribers) page to learn more about how to issue X.509 certificates using the intermediate CA.
      </Step>
    </Steps>
  </Tab>
</Tabs>

## Guide to CA Renewal

In the following steps, we explore how to renew a CA certificate.

<Note>
  If renewing an intermediate CA chained to an Infisical CA, then Infisical will
  automate the process of generating a new certificate for the intermediate CA for you.

  If renewing an intermediate CA chained to an external parent CA, you'll be
  required to generate a new certificate from the external parent CA and manually import
  the certificate back to the intermediate CA.
</Note>

<Tabs>
  <Tab title="Infisical UI">
    Head to the CA Page of the CA you wish you renew and press **Renew CA** on
    the left side. <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/pki/ca-renewal-page.png" alt="pki ca renewal
    page" /> Input a new **Valid Until**
    date to be used for the renewed CA certificate and press **Renew** to renew
    the CA. <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/pki/ca-renewal-modal.png" alt="pki ca renewal. modal" />

    <Note>
      The new **Valid Until** date must be within the validity period of the
      parent CA.
    </Note>
  </Tab>

  <Tab title="API">
    To renew a CA certificate, make an API request to the [Renew CA](/api-reference/endpoints/certificate-authorities/renew) API endpoint, specifying the new `notAfter` date for the CA.

    ### Sample request

    ```bash Request theme={"dark"}
    curl --location --request POST 'https://app.infisical.com/api/v1/pki/ca/<ca-id>/renew' \
      --header 'Authorization: Bearer <access-token>' \
      --header 'Content-Type: application/json' \
      --data-raw '{
          "type": "existing",
          "notAfter": "2029-06-12"
      }'
    ```

    ### Sample response

    ```bash Response theme={"dark"}
    {
      certificate: "...",
      certificateChain: "...",
      serialNumber: "..."
    }
    ```
  </Tab>
</Tabs>

## FAQ

<AccordionGroup>
  <Accordion title="What key algorithms are supported as part of private key generation and certificate signing?">
    Infisical supports `RSA 2048`, `RSA 4096`, `ECDSA P-256`, `ECDSA P-384` key
    algorithms specified at the time of creating a CA.
  </Accordion>

  <Accordion title="Does Infisical support CA renewal via new key pair">
    At the moment, Infisical only supports CA renewal via same key pair. We
    anticipate supporting CA renewal via new key pair in the coming month.
  </Accordion>

  <Accordion title="Does Infisical support chaining an Intermediate CA to an external CA?">
    Yes. You may obtain a CSR from the Intermediate CA and use it to generate a
    certificate from your external CA. The certificate, along with the external
    CA certificate chain, can be imported back to the Intermediate CA as part of
    the CA installation step.
  </Accordion>
</AccordionGroup>


# AWS Certificate Manager
Source: https://infisical.com/docs/documentation/platform/pki/certificate-syncs/aws-certificate-manager

Learn how to configure an AWS Certificate Manager Certificate Sync for Infisical PKI.

**Prerequisites:**

* Create an [AWS Connection](/integrations/app-connections/aws)

<Note>
  The AWS Certificate Manager Certificate Sync requires the following ACM permissions to be set on the IAM user/role
  for Infisical to sync certificates to AWS Certificate Manager: `acm:ListCertificates`, `acm:DescribeCertificate`, `acm:ImportCertificate`, `acm:DeleteCertificate`, and `acm:ListTagsForCertificate`.

  These permissions allow Infisical to list, import, tag, and manage certificates in your AWS Certificate Manager service.
</Note>

<Note>
  Certificates synced to AWS Certificate Manager will be stored as imported
  certificates, preserving both the certificate and private key components.
</Note>

<Tabs>
  <Tab title="Infisical UI">
    1. Navigate to **Project** > **Integrations** > **Certificate Syncs** and press **Add Sync**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/pki/certificate-syncs/general/create-certificate-sync.png" alt="Certificate Syncs Tab" />

    2. Select the **AWS Certificate Manager** option.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/pki/certificate-syncs/aws-certificate-manager/select-acm-option.png" alt="Select ACM" />

    3. Configure the **Destination** to where certificates should be deployed, then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/pki/certificate-syncs/aws-certificate-manager/acm-destination.png" alt="Configure Destination" />

    * **AWS Connection**: The AWS Connection to authenticate with.
    * **AWS Region**: The AWS region where certificates should be stored.

    4. Configure the **Sync Options** to specify how certificates should be synced, then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/pki/certificate-syncs/aws-certificate-manager/acm-options.png" alt="Configure Options" />

    * **Enable Removal of Expired/Revoked Certificates**: If enabled, Infisical will remove certificates from the destination if they are no longer active in Infisical.
    * **Preserve ARN on Renewal**: If enabled, Infisical will sync renewed certificates to the destination under the same ARN as the original synced certificate instead of creating a new certificate with a new ARN.
    * **Certificate Name Schema** (Optional): Customize how certificate tags are generated in AWS Certificate Manager. Must include `{{certificateId}}` as a placeholder for the certificate ID to ensure proper certificate identification and management. If not specified, defaults to `Infisical-{{certificateId}}`.
    * **Auto-Sync Enabled**: If enabled, certificates will automatically be synced when changes occur. Disable to enforce manual syncing only.

    5. Configure the **Details** of your AWS Certificate Manager Certificate Sync, then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/pki/certificate-syncs/aws-certificate-manager/acm-details.png" alt="Configure Details" />

       * **Name**: The name of your sync. Must be slug-friendly.
       * **Description**: An optional description for your sync.

    6. Select which certificates should be synced to AWS Certificate Manager.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/pki/certificate-syncs/aws-certificate-manager/acm-certificates.png" alt="Select Certificates" />

    7. Review your AWS Certificate Manager Certificate Sync configuration, then click **Create Sync**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/pki/certificate-syncs/aws-certificate-manager/acm-review.png" alt="Confirm Configuration" />

    8. If enabled, your AWS Certificate Manager Certificate Sync will begin syncing your certificates to the destination endpoint.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/pki/certificate-syncs/aws-certificate-manager/acm-synced.png" alt="Sync Certificates" />
  </Tab>

  <Tab title="API">
    To create an **AWS Certificate Manager Certificate Sync**, make an API request to the [Create AWS Certificate Manager Certificate Sync](/api-reference/endpoints/pki/syncs/aws-certificate-manager/create) API endpoint.

    ### Sample request

    <Note>
      You can optionally specify `certificateIds` during sync creation to immediately add certificates to the sync.
      If not provided, you can add certificates later using the certificate management endpoints.
    </Note>

    ```bash Request theme={"dark"}
    curl --request POST \
    --url https://app.infisical.com/api/v1/pki/syncs/aws-certificate-manager \
    --header 'Authorization: Bearer <access-token>' \
    --header 'Content-Type: application/json' \
    --data '{
        "name": "my-acm-cert-sync",
        "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
        "description": "an example certificate sync",
        "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
        "destination": "aws-certificate-manager",
        "isAutoSyncEnabled": true,
        "certificateIds": [
            "550e8400-e29b-41d4-a716-446655440000",
            "660f1234-e29b-41d4-a716-446655440001"
        ],
        "syncOptions": {
            "canRemoveCertificates": true,
            "preserveArnOnRenewal": true,
            "certificateNameSchema": "myapp-{{certificateId}}"
        },
        "destinationConfig": {
            "region": "us-east-1"
        }
    }'
    ```

    ### Sample response

    ```json Response theme={"dark"}
    {
        "pkiSync": {
            "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "name": "my-acm-cert-sync",
            "description": "an example certificate sync",
            "destination": "aws-certificate-manager",
            "isAutoSyncEnabled": true,
            "destinationConfig": {
                "region": "us-east-1"
            },
            "syncOptions": {
                "canRemoveCertificates": true,
                "preserveArnOnRenewal": true,
                "certificateNameSchema": "myapp-{{certificateId}}"
            },
            "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "createdAt": "2023-01-01T00:00:00.000Z",
            "updatedAt": "2023-01-01T00:00:00.000Z"
        }
    }
    ```
  </Tab>
</Tabs>

## Certificate Management

Your AWS Certificate Manager Certificate Sync will:

* **Automatic Deployment**: Deploy certificates in Infisical to AWS Certificate Manager.
* **Certificate Updates**: Update certificates in AWS Certificate Manager when renewals occur.
* **Expiration Handling**: Optionally remove expired certificates from AWS Certificate Manager (if enabled).
* **Tagging**: Automatically tag certificates with an InfisicalCertificate tag for easy identification and management

<Note>
  AWS Certificate Manager Certificate Syncs support both automatic and manual
  synchronization modes. When auto-sync is enabled, certificates are
  automatically deployed as they are issued or renewed.
</Note>

## Manual Certificate Sync

You can manually trigger certificate synchronization to AWS Certificate Manager using the sync certificates functionality. This is useful for:

* Initial setup when you have existing certificates to deploy
* One-time sync of specific certificates
* Testing certificate sync configurations
* Force sync after making changes

To manually sync certificates, use the [Sync Certificates](/api-reference/endpoints/pki/syncs/aws-certificate-manager/sync-certificates) API endpoint or the manual sync option in the Infisical UI.

<Note>
  AWS Certificate Manager does not support importing certificates back into
  Infisical due to security limitations where private keys cannot be extracted
  from AWS Certificate Manager. Only certificates imported into ACM (not
  AWS-issued certificates) can be managed by the sync.
</Note>


# Azure Key Vault
Source: https://infisical.com/docs/documentation/platform/pki/certificate-syncs/azure-key-vault

Learn how to configure an Azure Key Vault Certificate Sync for Infisical PKI.

**Prerequisites:**

* Create an [Azure Key Vault Connection](/integrations/app-connections/azure-key-vault)
* Ensure your network security policies allow incoming requests from Infisical to this certificate sync provider, if network restrictions apply.

<Note>
  The Azure Key Vault Certificate Sync requires the following certificate permissions to be set on the user / service principal
  for Infisical to sync certificates to Azure Key Vault: `certificates/list`, `certificates/get`, `certificates/import`, `certificates/delete`.

  Any role with these permissions would work such as the **Key Vault Certificates Officer** role.
</Note>

<Note>
  Certificates synced to Azure Key Vault will be stored as certificate objects,
  preserving both the certificate and private key components.
</Note>

<Tabs>
  <Tab title="Infisical UI">
    1. Navigate to **Project** > **Integrations** > **Certificate Syncs** and press **Add Sync**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/pki/certificate-syncs/general/create-certificate-sync.png" alt="Certificate Syncs Tab" />

    2. Select the **Azure Key Vault** option.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/pki/certificate-syncs/azure-key-vault/select-akv-option.png" alt="Select Key Vault" />

    3. Configure the **Destination** to where certificates should be deployed, then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/pki/certificate-syncs/azure-key-vault/akv-destination.png" alt="Configure Destination" />

       * **Azure Connection**: The Azure Connection to authenticate with.
       * **Vault Base URL**: The URL of your Azure Key Vault.

    4. Configure the **Sync Options** to specify how certificates should be synced, then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/pki/certificate-syncs/azure-key-vault/akv-options.png" alt="Configure Options" />

       * **Enable Removal of Expired/Revoked Certificates**: If enabled, Infisical will remove certificates from the destination if they are no longer active in Infisical.
       * **Enable Versioning on Renewal**: If enabled, Infisical will sync renewed certificates to the destination under a new version of the original synced certificate instead of creating a new certificate.
       * **Certificate Name Schema** (Optional): Customize how certificate names are generated in Azure Key Vault. Use `{{certificateId}}` as a placeholder for the certificate ID. If not specified, defaults to `Infisical-{{certificateId}}`.
       * **Auto-Sync Enabled**: If enabled, certificates will automatically be synced when changes occur. Disable to enforce manual syncing only.

    <Tip>
      **Azure Key Vault Soft Delete**: When certificates are removed from Azure Key Vault, they are placed in a soft-deleted state rather than being permanently deleted. This means:

      * Subsequent syncs will not re-add these soft-deleted certificates automatically
      * To resync removed certificates, you must either manually **purge** them from Azure Key Vault or **recover** them through the Azure portal/CLI
    </Tip>

    5. Configure the **Details** of your Azure Key Vault Certificate Sync, then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/pki/certificate-syncs/azure-key-vault/akv-details.png" alt="Configure Details" />

       * **Name**: The name of your sync. Must be slug-friendly.
       * **Description**: An optional description for your sync.

    6. Select which certificates should be synced to Azure Key Vault.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/pki/certificate-syncs/azure-key-vault/akv-certificates.png" alt="Select Certificates" />

    7. Review your Azure Key Vault Certificate Sync configuration, then click **Create Sync**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/pki/certificate-syncs/azure-key-vault/akv-review.png" alt="Confirm Configuration" />

    8. If enabled, your Azure Key Vault Certificate Sync will begin syncing your certificates to the destination endpoint.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/pki/certificate-syncs/azure-key-vault/akv-synced.png" alt="Sync Certificates" />
  </Tab>

  <Tab title="API">
    To create an **Azure Key Vault Certificate Sync**, make an API request to the [Create Azure Key Vault Certificate Sync](/api-reference/endpoints/pki/syncs/azure-key-vault/create) API endpoint.

    ### Sample request

    <Note>
      You can optionally specify `certificateIds` during sync creation to immediately add certificates to the sync.
      If not provided, you can add certificates later using the certificate management endpoints.
    </Note>

    ```bash Request theme={"dark"}
    curl --request POST \
    --url https://app.infisical.com/api/v1/pki/syncs/azure-key-vault \
    --header 'Authorization: Bearer <access-token>' \
    --header 'Content-Type: application/json' \
    --data '{
        "name": "my-key-vault-cert-sync",
        "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
        "description": "an example certificate sync",
        "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
        "destination": "azure-key-vault",
        "isAutoSyncEnabled": true,
        "certificateIds": [
            "550e8400-e29b-41d4-a716-446655440000",
            "660f1234-e29b-41d4-a716-446655440001"
        ],
        "syncOptions": {
            "canRemoveCertificates": true,
            "enableVersioningOnRenewal": true,
            "certificateNameSchema": "myapp-{{certificateId}}"
        },
        "destinationConfig": {
            "vaultBaseUrl": "https://my-key-vault.vault.azure.net"
        }
    }'
    ```

    ### Sample response

    ```json Response theme={"dark"}
    {
        "pkiSync": {
            "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "name": "my-key-vault-cert-sync",
            "description": "an example certificate sync",
            "destination": "azure-key-vault",
            "isAutoSyncEnabled": true,
            "destinationConfig": {
                "vaultBaseUrl": "https://my-key-vault.vault.azure.net"
            },
            "syncOptions": {
                "canRemoveCertificates": true,
                "enableVersioningOnRenewal": true,
                "certificateNameSchema": "myapp-{{certificateId}}"
            },
            "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "createdAt": "2023-01-01T00:00:00.000Z",
            "updatedAt": "2023-01-01T00:00:00.000Z"
        }
    }
    ```
  </Tab>
</Tabs>

## Certificate Management

Your Azure Key Vault Certificate Sync will:

* **Automatic Deployment**: Deploy certificates in Infisical to Azure Key Vault.
* **Certificate Updates**: Update certificates in Azure Key Vault when renewals occur
* **Expiration Handling**: Optionally remove expired certificates from Azure Key Vault (if enabled)
* **Format Preservation**: Maintain certificate format and metadata during sync operations

<Note>
  Azure Key Vault Certificate Syncs support both automatic and manual
  synchronization modes. When auto-sync is enabled, certificates are
  automatically deployed as they are issued or renewed.
</Note>

## Manual Certificate Sync

You can manually trigger certificate synchronization to Azure Key Vault using the sync certificates functionality. This is useful for:

* Initial setup when you have existing certificates to deploy
* One-time sync of specific certificates
* Testing certificate sync configurations
* Force sync after making changes

To manually sync certificates, use the [Sync Certificates](/api-reference/endpoints/pki/syncs/azure-key-vault/sync-certificates) API endpoint or the manual sync option in the Infisical UI.

<Note>
  Azure Key Vault does not support importing certificates back into Infisical
  due to security limitations where private keys cannot be extracted from Azure
  Key Vault.
</Note>


# null
Source: https://infisical.com/docs/documentation/platform/pki/certificate-syncs/overview

Learn how to sync certificates from Infisical PKI to third-party services.

Certificate Syncs enable you to push certificates from Infisical to third-party services using [App Connections](/integrations/app-connections/overview).

<Note>
  Certificate Syncs are designed to automatically deploy certificates issued by
  your Certificate Authority to external services, ensuring your certificates
  are always up-to-date across your infrastructure.
</Note>

## Concept

Certificate Syncs are a project-level resource used to push certificates, via an [App Connection](/integrations/app-connections/overview), from Infisical
to a third-party service (destination). When paired with [server-side auto-renewal](/documentation/platform/pki/certificates/certificates#server-driven-certificate-renewal), renewed certificates are automatically synced to the destination,
ensuring your certificates stay current.

<br />

<div align="center">
  ```mermaid  theme={"dark"}
  %%{init: {'flowchart': {'curve': 'linear'} } }%%
  graph LR
  A[App Connection]
  B[Certificate Sync]
  C[Certificate 1]
  D[Certificate 2]
  E[Certificate 3]
  F[Third-Party Service]
  G[Certificate 1]
  H[Certificate 2]
  I[Certificate 3]

  B --> A
  C --> B
  D --> B
  E --> B
  A --> F
  F --> G
  F --> H
  F --> I

  classDef default fill:#ffffff,stroke:#666,stroke-width:2px,rx:10px,color:black
  classDef connection fill:#FFF2B2,stroke:#E6C34A,stroke-width:2px,color:black,rx:15px
  classDef certificate fill:#E6F4FF,stroke:#0096D6,stroke-width:2px,color:black,rx:15px
  classDef sync fill:#F4FFE6,stroke:#96D600,stroke-width:2px,color:black,rx:15px
  classDef service fill:#E6E6FF,stroke:#6B4E96,stroke-width:2px,color:black,rx:15px
  classDef subscriber fill:#FFE6E6,stroke:#D63F3F,stroke-width:2px,color:black,rx:15px

  class A connection
  class B sync
  class C,D,E,G,H,I certificate
  class F service
  class J subscriber
  ```
</div>

## Workflow

Configuring a Certificate Sync requires three components: The certificates that you'd like to push,
a <strong>destination</strong> endpoint to deploy certificates to, and <strong>configuration options</strong> to determine how your certificates
should be synced. Follow these steps to start syncing:

<Note>
  For step-by-step guides on syncing to a particular third-party service, refer
  to the Certificate Syncs section in the Navigation Bar.
</Note>

1. <strong>Create App Connection:</strong> If you have not already done so, create
   an [App Connection](/integrations/app-connections/overview) via the UI or API
   for the third-party service you intend to sync certificates to.

2. <strong>Create Certificate Sync:</strong> Configure a Certificate Sync in the
   desired project by specifying the following parameters via the UI or API:

   * <strong>Destination:</strong> The App Connection to utilize and the destination
     endpoint to deploy certificates to such as [AWS Certificate Manager](/documentation/platform/pki/certificate-syncs/aws-certificate-manager)
     or [Azure Key Vault](/documentation/platform/pki/certificate-syncs/azure-key-vault).
   * <strong>Certificates:</strong> The certificates you wish to push to the destination.
   * <strong>Options:</strong> Customize how certificates should be synced, including:
     * Whether certificates should be removed from the destination when they expire.
     * Certificate naming schema to control how certificate names are generated in
       the destination.

<Note>
  Only certificates managed by Infisical will be affected during sync
  operations. Certificates not created or managed by Infisical will remain
  untouched, and changes made to Infisical-managed certificates directly in the
  destination service may be overwritten by future syncs.
</Note>

<Info>
  Some third-party services do not support removing expired certificates
  automatically.
</Info>

3. <strong>Utilize Sync:</strong> Selected certificates will now be pushed to the
   destination endpoint and automatically redeployed whenever they are renewed.

<Note>
  Infisical is continuously expanding its Certificate Sync third-party service
  support. If the service you need isn't available, contact us at
  [team@infisical.com](mailto:team@infisical.com) to make a request.
</Note>

## Certificate Naming

Certificate Syncs support flexible certificate naming through configurable naming schemas. This allows you to customize how certificate names appear in your destination services.

### Default Naming

By default, certificates are named using the pattern `Infisical-{certificateId}` where `{certificateId}` is the unique identifier of the certificate with hyphens removed for compatibility with services like Azure Key Vault.

### Custom Naming Schema

You can customize certificate naming by providing a **Certificate Name Schema** when creating or updating a Certificate Sync. The schema supports the following placeholders:

* `{{certificateId}}` - The unique certificate identifier (required)

**Examples:**

* `myapp-{{certificateId}}`  `myapp-abc123def456`
* `ssl/{{certificateId}}`  `ssl/abc123def456`

**Rules:**

* Must include exactly one `{{certificateId}}` placeholder
* Only alphanumeric characters, dashes (-), underscores (\_), and slashes (/) are allowed
* Certificate names matching your schema will be managed by Infisical during sync operations


# Certificates
Source: https://infisical.com/docs/documentation/platform/pki/certificates/certificates



<Note>
  PKI architecture is a complex topic and there are many ways to orchestrate
  certificate management including renewal operations. For specific guidance and
  access to enterprise features, we recommend reaching out to
  [sales@infisical.com](mailto:sales@infisical.com) to schedule a demo.
</Note>

## Concept

A certificate is the (X.509) leaf certificate issued for a certificate profile.

Once issued, a certificate is kept track of in the certificate inventory
where you can manage various aspects of its lifecycle including deployment to cloud key stores, server-side auto-renewal behavior, revocation, and more.

## Guide to Issuing Certificates

To issue a certificate, you must first create a [certificate profile](/documentation/platform/pki/certificates/profiles) and a [certificate template](/documentation/platform/pki/certificates/templates) to go along with it.

The [enrollment method](/documentation/platform/pki/enrollment-methods/overview) configured on the certificate profile determines how a certificate is issued for it.
Refer to the documentation for each enrollment method to learn more about how to issue certificates using it.

## Guide to Renewing Certificates

To [renew a certificate](/documentation/platform/pki/concepts/certificate-lifecycle#renewal), you can either request a new certificate from a certificate profile or have the platform
automatically request a new one for you. Whether you pursue a client-driven or server-driven approach is totally dependent on the enrollment method configured on your certificate
profile as well as your infrastructure use-case.

### Client-Driven Certificate Renewal

Client-driven certificate renewal is when renewal is initiated client-side by the end-entity consuming the certificate.
This is the most common approach to certificate renewal and is suitable for most use-cases.

### Server-Driven Certificate Renewal

Server-driven certificate renewal is when renewal is initiated server-side by Infisical rather than by the end-entity consuming the certificate.
When a certificate considered for auto-renewal meets a specified *renewal days before expiration* threshold, Infisical reaches out to the issuing CA bound to the [certificate profile](/documentation/platform/pki/certificates/profiles) of the expiring certificate
to request for a new one.
The resulting renewed certificate is stored in the platform and made available to be fetched back or pushed downstream to end-entities or external systems such as cloud key stores.

Note that server-driven certificate renewal is only available for certificates issued via the [API enrollment method](/documentation/platform/pki/enrollment-methods/api) where key pairs are generated server-side.
A certificate can be considered for auto-renewal at time of issuance if the **Enable Auto-Renewal By Default** option is selected on its [certificate profile](/documentation/platform/pki/certificates/profiles) or after issuance by toggling this option manually.

<Info>
  For server-driven certificate renewal workflows, you can programmatically
  fetch the latest active certificate bundle for a certificate profile using the
  [Get Latest Active Certificate
  Bundle](/api-reference/endpoints/certificate-profiles/get-latest-active-bundle)
  API endpoint. This ensures you always retrieve the most current valid
  certificate, including any that have been automatically renewed, making it
  particularly useful for deployment pipelines and automation workflows where
  you don't want to track individual serial numbers.
</Info>

The following examples demonstrate different approaches to certificate renewal:

* Using the [ACME enrollment method](/documentation/platform/pki/enrollment-methods/acme), you may connect an ACME client like [certbot](https://certbot.eff.org/) to fetch back and renew certificates for [Apache](/documentation/platform/pki/integration-guides/apache-certbot), [Nginx](/documentation/platform/pki/integration-guides/nginx-certbot), or other server. The ACME client will pursue a client-driven approach and submit certificate requests upon certificate expiration for you, saving renewed certificates back to the server's configuration.
* Using the [ACME enrollment method](/documentation/platform/pki/enrollment-methods/acme), you may use [cert-manager](https://cert-manager.io/) with Infisical to issue and renew certificates for Kubernetes workloads; cert-manager will pursue a client-driven approach and submit certificate requests upon certificate expiration for you, saving renewed certificates back to Kubernetes secrets.
* Using the [API enrollment method](/documentation/platform/pki/enrollment-methods/api), you may push and auto-renew certificates to AWS and Azure using [certificate syncs](/documentation/platform/pki/certificate-syncs/overview). Certificates issued over the API enrollment method, where key pairs are generated server-side, are also eligible for server-side auto-renewal; once renewed, certificates are automatically pushed back to their sync destination.

## Guide to Downloading Certificates

In the following steps, we explore different options for exporting already-issued certificates from Infisical in different formats for use in your applications and infrastructure.

### Download Latest Profile Certificate

You can download the latest certificate issued against a [certificate profile](/documentation/platform/pki/certificates/profiles) using the [latest certificate bundle](/api-reference/endpoints/certificate-profiles/get-latest-active-bundle) endpoint.

### Download Specific Certificate

To export a specific certificate, first navigate to your project's certificate inventory and locate the certificate you want to export. Click on the **Export Certificate** option from the certificate's action menu.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/pki/certificate/cert-export-option.png" alt="pki export certificate option" />

<Tabs>
  <Tab title="PEM Format">
    <Steps>
      <Step title="Exporting in PEM Format">
        In the export modal, choose **PEM** as the format and click **Export**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/pki/certificate/cert-export-pem.png" alt="pki export certificate pem" />

        The PEM export modal will display the certificate details including:

        * **Serial Number**: The unique identifier for the certificate
        * **Certificate Body**: The X.509 certificate in PEM format
        * **Certificate Chain**: The intermediate and root CA certificates
        * **Private Key**: The private key associated with the certificate (if available)

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/pki/certificate/cert-export-pem-modal.png" alt="pki export certificate pem modal" />

        You can copy each component individually or use the **Copy All** button to copy the complete certificate bundle.
      </Step>

      <Step title="Using PEM Certificates">
        PEM format certificates can be used directly with most web servers and applications:

        * **Apache HTTP Server**: Configure SSL certificates in your virtual host
        * **Nginx**: Use the certificate and private key files in your server configuration
        * **Docker containers**: Mount certificate files for TLS-enabled applications
        * **Load balancers**: Upload PEM certificates to AWS ALB, Azure Application Gateway, etc.

        Example Nginx configuration:

        ```nginx  theme={"dark"}
        server {
            listen 443 ssl;
            server_name example.com;

            ssl_certificate /path/to/certificate.pem;
            ssl_certificate_key /path/to/private-key.pem;
        }
        ```
      </Step>
    </Steps>
  </Tab>

  <Tab title="PKCS12 Format">
    <Steps>
      <Step title="Exporting in PKCS12 Format">
        In the export modal, choose **PKCS12** as the format and provide the required configuration:

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/pki/certificate/cert-export-pkcs12.png" alt="pki export certificate pkcs12" />

        * **Password**: A secure password to protect the PKCS12 keystore
        * **Alias**: A friendly name for the certificate within the keystore

        Click **Export** to generate and download the `.p12` file containing the certificate, certificate chain, and private key.
      </Step>

      <Step title="Using PKCS12 Certificates">
        PKCS12 files (`.p12` extension) are binary keystore files that contain the certificate, certificate chain, and private key in a single encrypted file:

        * **Java applications**: Import directly into Java KeyStore (JKS) or use with SSL/TLS
        * **Windows IIS**: Import the PKCS12 file for web server SSL configuration
        * **Browser certificates**: Install client certificates for authentication
        * **Mobile applications**: Deploy certificates to iOS and Android applications

        To verify the contents of a PKCS12 file:

        ```bash  theme={"dark"}
        openssl pkcs12 -in certificate.p12 -nokeys -clcerts
        ```

        To extract the private key:

        ```bash  theme={"dark"}
        openssl pkcs12 -in certificate.p12 -nocerts -out private-key.pem
        ```

        <Info>
          If you need to convert the PKCS12 file to Java KeyStore (JKS) format for applications running on Java 8 or earlier, use the following keytool command:

          ```bash  theme={"dark"}
          keytool -importkeystore \
              -srckeystore certificate.p12 \
              -srcstoretype PKCS12 \
              -srcstorepass <p12-password> \
              -destkeystore certificate.jks \
              -deststoretype JKS \
              -deststorepass <jks-password>
          ```

          Replace `<p12-password>` with the password you used when exporting the PKCS12 file, and `<jks-password>` with your desired JKS keystore password.

          The resulting `.jks` file can then be used with Java applications that require JKS format keystores.
        </Info>
      </Step>
    </Steps>
  </Tab>
</Tabs>

## Guide to Revoking Certificates

In the following steps, we explore how to revoke a X.509 certificate and obtain a Certificate Revocation List (CRL) for a CA.

<Tabs>
  <Tab title="Infisical UI">
    <Steps>
      <Step title="Revoking a Certificate">
        Assuming that you've issued a certificate under a CA, you can revoke it by
        selecting the **Revoke Certificate** option for it and specifying the reason
        for revocation.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/pki/certificate/cert-revoke.png" alt="pki revoke certificate" />

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/pki/certificate/cert-revoke-modal.png" alt="pki revoke certificate modal" />
      </Step>

      <Step title="Obtaining a CRL">
        In order to check the revocation status of a certificate, you can check it
        against the CRL of a CA by heading to its Issuing CA and downloading the CRL.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/pki/ca/ca-crl.png" alt="pki view crl" />

        To verify a certificate against the
        downloaded CRL with OpenSSL, you can use the following command:

        ```bash  theme={"dark"}
        openssl verify -crl_check -CAfile chain.pem -CRLfile crl.pem cert.pem
        ```

        Note that you can also obtain the CRL from the certificate itself by
        referencing the CRL distribution point extension on the certificate.

        To check a certificate against the CRL distribution point specified within it with OpenSSL, you can use the following command:

        ```bash  theme={"dark"}
        openssl verify -verbose -crl_check -crl_download -CAfile chain.pem cert.pem
        ```
      </Step>
    </Steps>
  </Tab>

  <Tab title="API">
    <Steps>
      <Step title="Revoking a certificate">
        Assuming that you've issued a certificate under a CA, you can revoke it by making an API request to the [Revoke Certificate](/api-reference/endpoints/certificates/revoke) API endpoint,
        specifying the serial number of the certificate and the reason for revocation.

        ### Sample request

        ```bash Request theme={"dark"}
        curl --location --request POST 'https://app.infisical.com/api/v1/pki/certificates/<cert-serial-number>/revoke' \
          --header 'Authorization: Bearer <access-token>' \
          --header 'Content-Type: application/json' \
          --data-raw '{
              "revocationReason": "UNSPECIFIED"
          }'
        ```

        ### Sample response

        ```bash Response theme={"dark"}
        {
          message: "Successfully revoked certificate",
          serialNumber: "...",
          revokedAt: "..."
        }
        ```
      </Step>

      <Step title="Obtaining a CRL">
        In order to check the revocation status of a certificate, you can check it against the CRL of the issuing CA.
        To obtain the CRLs of the CA, make an API request to the [List CRLs](/api-reference/endpoints/certificate-authorities/crl) API endpoint.

        ### Sample request

        ```bash Request theme={"dark"}
        curl --location --request GET 'https://app.infisical.com/api/v1/pki/ca/<ca-id>/crls' \
          --header 'Authorization: Bearer <access-token>'
        ```

        ### Sample response

        ```bash Response theme={"dark"}
        [
          {
            id: "...",
            crl: "..."
          },
          ...
        ]
        ```

        To verify a certificate against the CRL with OpenSSL, you can use the following command:

        ```bash  theme={"dark"}
        openssl verify -crl_check -CAfile chain.pem -CRLfile crl.pem cert.pem
        ```
      </Step>
    </Steps>
  </Tab>
</Tabs>


# Overview
Source: https://infisical.com/docs/documentation/platform/pki/certificates/overview



To issue a certificate with Infisical, you create a certificate profile and a certificate template to go along with it. You then issue a certificate against
a specific profile depending on the enrollment method associated with it.

There are three components to understand:

* [Certificate Profile](/documentation/platform/pki/certificates/profiles): A configuration set specifying how certificates should be issued under that profile including the [issuing CA](/documentation/platform/pki/ca/overview), a certificate template, and the [enrollment method](/documentation/platform/pki/enrollment-methods/overview) (such as ACME, EST, API, etc.) used to enroll certificates.

* [Certificate Template](/documentation/platform/pki/certificates/templates): A policy structure specifying the permitted attributes for requested certificates including subject naming conventions, SAN fields, key usages, and extended key usages.

* [Certificate](/documentation/platform/pki/certificates/certificates): The actual X.509 certificate issued for a profile. Once issued, a certificate kept track of in the certificate inventory.


# Certificate Profiles
Source: https://infisical.com/docs/documentation/platform/pki/certificates/profiles



## Concept

A certificate profile is a configuration set specifying how leaf certificates should be issued for a group of end-entities including the [issuing CA](/documentation/platform/pki/ca/overview), a [certificate template](/documentation/platform/pki/certificates/templates), and the [enrollment method](/documentation/platform/pki/enrollment-methods/overview) (e.g. ACME, EST, API, etc.) used to enroll certificates.

You typically request certificates against a certificate profile through its associated enrollment method. Each method defines its own interaction flow which you can read more about in its respective documentation.

## Guide to Creating a Certificate Profile

To create a certificate profile, head to your Certificate Management Project > Certificates > Certificate Profiles and press **Create Profile**.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/pki/certificate/cert-profile.png" alt="pki certificate profile" />

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/pki/certificate/cert-profile-modal.png" alt="pki certificate profile modal" />

Here's some guidance on each field:

* Name: A slug-friendly name for the profile such as `web-servers`.
* Description: An optional description for the profile.
* Issuing CA: The [issuing CA](/documentation/platform/pki/ca/overview) that should be used to issue certificates for the profile.
* Certificate Template: The [certificate template](/documentation/platform/pki/certificates/templates) that should be used to validate certificate requests for the profile.
* Enrollment Method: The enrollment method that should be used to enroll certificates for the profile such as ACME, EST, API, etc.

Depending on which enrollment method you choose, you may be presented with additional enrollment-specific configuration fields.


# Certificate Templates
Source: https://infisical.com/docs/documentation/platform/pki/certificates/templates



## Concept

A certificate template is a policy structure specifying permitted attributes for requested certificates. This includes constraints around subject naming conventions, SAN fields, key usages, and extended key usages.

Each certificate requested against a [certificate profile](/documentation/platform/pki/certificates/profiles) is validated against the template bound to that profile. If the request fails any criteria included in the template, the certificate is not issued. This helps administrators enforce uniformity and security standards across all issued certificates.

## Guide to Creating a Certificate Template

To create a certificate template, head to your Certificate Management Project > Certificates > Certificate Templates and press **Create Template**.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/pki/certificate/cert-template.png" alt="pki certificate template" />

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/pki/certificate/cert-template-modal.png" alt="pki certificate template modal" />

Here's some guidance on each field:

* Template Name: A slug-friendly name for the template such as `tls-server`.
* Description: An optional description for the template.
* Subject Attributes: A list of common names that can be included in the certificate subject. Each row accepts a fixed value or pattern such as `example.com` or `*.example.com` and whether it is allowed or denied.
* Subject Alternative Names (SANs): A list of SANs that can appear in the certificate. Each row accepts a SAN type (e.g. DNS, IP, Email, URI), a fixed value or pattern such as `example.com` or `*.example.com`, and an allow or deny flag.
* Allowed Signature Algorithms: The set of signature algorithms permitted to sign certificates under this template such as `SHA256-RSA`, `SHA512-RSA`, etc.
* Allowed Key Algorithms: The set of public key algorithms permitted for certificate requests such as `RSA-2048`, `RSA-4096`, etc.
* Key Usages: The cryptographic purposes of the certificate such as Digital Signature, Key Encipherment, etc.
* Extended Key Usages: The higher-level intended uses of the certificate such as Server Authentication, Client Authentication, etc.
* Certificate Validity: The maximum lifetime of certificates that can be requested for certificates validated against this template. You can specify both a duration and unit (days, months, or years).


# Certificate Lifecycle
Source: https://infisical.com/docs/documentation/platform/pki/concepts/certificate-lifecycle

Learn what is the certificate lifecycle and how it works.

## Certificate Lifecycle

Typically, a certificate goes through a series of stages during its lifetime from creation to retirement. This is called the certificate lifecycle. The exact names of these stages may vary from vendor to vendor, but they typically include [discovery](/documentation/platform/pki/concepts/certificate-lifecycle#discovery), [enrollment](/documentation/platform/pki/concepts/certificate-lifecycle#enrollment), [deployment](/documentation/platform/pki/concepts/certificate-lifecycle#deployment), [renewal](/documentation/platform/pki/concepts/certificate-lifecycle#renewal), [revocation](/documentation/platform/pki/concepts/certificate-lifecycle#revocation), and [retirement](/documentation/platform/pki/concepts/certificate-lifecycle#retirement).

Note that not every stage is needed. For instance:

* You are not required to discover certificates in order to start issuing and managing them.
* You may not need to revoke a certificate explicitly if it expires naturally and is replaced during routine renewal.

## Discovery

Certificate discovery is the process of identifying all active and inactive certificates across an environment, including those found on web servers, load balancers, services, and devices. A complete inventory prevents outages from forgotten certificates and creates the foundation for automation and monitoring.

## Enrollment (Request / Issuance)

Certificate enrollment is the process of requesting a certificate from a CA and can follow different approaches depending on the system or protocol in use.

Common approaches to certificate enrollment include:

* CSR-based enrollment: The client generates a key pair locally and submits a Certificate Signing Request (CSR) to a CA for certificate issuance.
* CSR-less enrollment: The client requests a certificate directly from a CA which may handle key generation internally and return the key pair in the response.

Enrollment can be manually completed via API or fully automated using protocols like EST or ACME. The choice of enrollment method depends on security requirements, operational constraints, and integration context.

## Deployment

Certificate deployment involves installing the issued certificate on the appropriate systems and services, such as web servers, load balancers, or internal endpoints. It can also include distributing or [synchronizing certificates](/documentation/platform/pki/certificate-syncs/overview) to external systems like cloud key stores (e.g., AWS Secrets Manager, Google Secret Manager, Azure Key Vault) so they can be securely consumed by workloads running in the cloud.

Deployment can happen manually or through automated mechanisms such as configuration pipelines, agents, or webhook integrations.

## Renewal

Certificate renewal is the process of requesting a new certificate from a CA before it expires to maintain trust and availability; this process can involve reusing the same key pair or rotating to a new one.

The renewal process can be server-driven or client-driven:

* Server-driven: Infisical automatically renews the certificate on your behalf. The renewed certificate is stored in the platform and can be synchronized to external systems such as cloud key stores.
* Client-driven: An external client, such as an agent or workload, initiates the renewal against Infisical. This is useful when key material needs to remain under client control or when rotation is tied to application-specific logic.

This flexibility allows certificates to be renewed in a way that aligns with different security, automation, and infrastructure models.

## Revocation

Certificate revocation is the process of invalidating a certificate to prevent it from being used. This is required when a certificate is compromised, misconfigured, or no longer needed. The CA signals this status to clients through CRLs or OCSP. A new certificate can be issued and deployed if needed.

## Retirement

Certificate retirement is the process of removing a certificate from the system. This is typically done when a certificate is no longer needed or has expired.


# Certificate Management
Source: https://infisical.com/docs/documentation/platform/pki/concepts/certificate-mgmt

Learn what is certificate management and why it matters for building secure systems.

## What is a Certificate?

A (digital) *certificate* is a file that is tied to a cryptographic key pair and is used to verify the identity of a website, user, device, or service. It helps establish trust and secure, encrypted communication between systems.

For example, when you visit a website over HTTPS, your browser checks the TLS certificate deployed on the web server or load balancer to make sure its really the site it claims to be. If the certificate is valid, your browser establishes an encrypted connection with the server.

Certificates contain information about the subject (who it identifies), the public key, and a digital signature from the CA that issued the certificate. They also include additional fields such as key usages, validity periods, and extensions that define how and where the certificate can be used. When a certificate expires, the service presenting it is no longer trusted, and clients won't be able to establish a secure connection to the service.

## What is Certificate Management?

As infrastructure scales and systems become more distributed, certificates sprawl. Without proper visibility and automation in place, certificates scatter across IT infrastructure, creating blind spots that can lead to service outages when certificates aren't renewed in time.

To solve certificate sprawl and avoid outages, organizations rely on certificate management: the practice of centralizing and automating the certificate lifecycle from issuance through renewal and revocation.

A consistent approach makes it easier to keep certificates valid and trusted, reduce operational risk, and maintain secure communication across environments.


# Certificate Enrollment via ACME
Source: https://infisical.com/docs/documentation/platform/pki/enrollment-methods/acme



## Concept

The ACME enrollment method allows you to issue and manage certificates against a specific [certificate profile](/documentation/platform/pki/certificates/profiles) using the [ACME protocol](https://en.wikipedia.org/wiki/Automatic_Certificate_Management_Environment).
This method is suitable for web servers, load balancers, and other general-purpose servers that can run an [ACME client](https://letsencrypt.org/docs/client-options/) for automated certificate management.

Infisical's ACME enrollment method is based on [RFC 8555](https://datatracker.ietf.org/doc/html/rfc8555/).

## Prerequisites

Install an [ACME client](https://letsencrypt.org/docs/client-options/) onto your server. This client will handle [ACME challenges](https://letsencrypt.org/docs/challenge-types/) and request/renew certificates from Infisical.

## Guide to Certificate Enrollment via ACME

In the following steps, we explore how to issue a X.509 certificate using the ACME enrollment method.

<Steps>
  <Step title="Create a certificate profile in Infisical">
    Create a [certificate
    profile](/documentation/platform/pki/certificates/profiles) with **ACME**
    selected as the enrollment method.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/pki/enrollment-methods/acme/acme-config.png" alt="pki acme config" />
  </Step>

  <Step title="Obtain the ACME configuration">
    Once you've created the certificate profile, you can obtain its ACME configuration details by clicking the **Reveal ACME EAB** option on the profile.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/pki/enrollment-methods/acme/acme-eab.png" alt="pki acme eab config" />

    From the ACME configuration, gather the following values:

    * ACME Directory URL: The URL that the ACME client will use to communicate with Infisical's ACME server.
    * EAB Key Identifier (KID): A unique identifier that tells Infisical which ACME account is making the request.
    * EAB Secret: A secret key that authenticates your ACME client with Infisical.
  </Step>

  <Step title="Configure your ACME client">
    Provide the **ACME Directory URL**, **EAB KID**, and **EAB Secret** from Step 2 to your ACME client to authenticate with Infisical and request a certificate.

    For example, if using [Certbot](https://certbot.eff.org/) as an ACME client, you can configure and start requesting certificates with the following command:

    ```bash  theme={"dark"}
    sudo certbot certonly \
      --standalone \
      --server "https://your-infisical-instance.com/api/v1/pki/certificate-profiles/{profile-id}/acme/directory" \
      --eab-kid "your-eab-kid" \
      --eab-hmac-key "your-eab-secret" \
      -d example.infisical.com \
      --email admin@example.com \
      --agree-tos \
      --non-interactive
    ```

    Certbot stores the private key and resulting leaf certificate and full certificate chain in `/etc/letsencrypt/live/{domain-name}/`.

    For client-specific setup and usage instructions, refer to the documentation for your ACME client.
  </Step>
</Steps>


# Certificate Enrollment via API
Source: https://infisical.com/docs/documentation/platform/pki/enrollment-methods/api



## Concept

The API enrollment method allows you to issue certificates against a specific [certificate profile](/documentation/platform/pki/certificates/profiles) over Web UI or by making an API request to Infisical.

## Guide to Certificate Enrollment via API

In the following steps, we explore how to issue a X.509 certificate using the API enrollment method.

<Tabs>
  <Tab title="Infisical UI">
    <Steps>
      <Step title="Create a certificate profile in Infisical">
        Create a [certificate
        profile](/documentation/platform/pki/certificates/profiles) with **API**
        selected as the enrollment method.

        Notice that the API enrollment method supports an option called **Enable Auto-Renewal By Default**.
        If selected, *eligible* certificates are automatically considered for server-side auto-renewal based
        on a specified renewal days before expiration threshold at the time of issuance; for more information
        about server-side auto-renewal, refer to the documentation [here](/documentation/platform/pki/certificates/certificates#guide-to-renewing-certificates).
      </Step>

      <Step title="Issue a certificate">
        To create a certificate, head to your Project > Certificates > Certificates and press **Issue**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/pki/certificate/cert-issue.png" alt="pki certificates" />

        Here, select the certificate profile from step 1 that will be used to issue the certificate and fill out the rest of the details for the certificate to be issued.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/pki/certificate/cert-issue-modal.png" alt="pki certificate issue modal" />
      </Step>

      <Step title="Download the certificate details">
        Once you have created the certificate from step 1, you'll be presented with the certificate details including the **Certificate Body**, **Certificate Chain**, and **Private Key**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/pki/certificate/cert-body.png" alt="pki certificate body" />

        <Note>
          Make sure to download and store the **Private Key** in a secure location as it
          will only be displayed once at the time of certificate issuance. The
          **Certificate Body** and **Certificate Chain** will remain accessible and can
          be copied at any time.
        </Note>
      </Step>
    </Steps>
  </Tab>

  <Tab title="API">
    <Steps>
      <Step title="Create a certificate profile in Infisical">
        To create a certificate [profile](/documentation/platform/pki/certificates/profiles), make an API request to the [Create Certificate Profile](/api-reference/endpoints/certificate-profiles/create) API endpoint.

        ### Sample request

        ```bash Request theme={"dark"}
        curl --location --request POST 'https://app.infisical.com/api/v1/pki/certificate-profiles' \
          --header 'Authorization: Bearer <access-token>' \
          --header 'Content-Type: application/json' \
          --data-raw '{
              "projectId": "<project-id>",
              "caId": "<ca-id>",
              "certificateTemplateId": "<certificate-template-id>",
              "slug": "my-api-profile",
              "description": "Certificate profile for API enrollment",
              "enrollmentType": "API",
              "apiConfig": {
                  "autoRenew": true,
                  "renewBeforeDays": 7
              }
          }'
        ```

        ### Sample response

        ```bash Response theme={"dark"}
        {
          "certificateProfile": {
            "id": "550e8400-e29b-41d4-a716-446655440000",
            "projectId": "65f0a4b0-c123-4567-8901-23456789abcd",
            "caId": "550e8400-e29b-41d4-a716-446655440000",
            "certificateTemplateId": "660f1234-e29b-41d4-a716-446655440001",
            "slug": "my-api-profile",
            "description": "Certificate profile for API enrollment",
            "enrollmentType": "API",
            "apiConfigId": "770g2345-e29b-41d4-a716-446655440002",
            "createdAt": "2023-01-19T09:44:36.267Z",
            "updatedAt": "2023-01-19T09:44:36.267Z"
          }
        }
        ```
      </Step>

      <Step title="Issue a certificate">
        To issue a certificate against the certificate profile, make an API request to the [Issue Certificate](/api-reference/endpoints/certificates/issue-certificate) API endpoint.

        ### Sample request

        ```bash Request theme={"dark"}
        curl --location --request POST 'https://app.infisical.com/api/v3/pki/certificates/issue-certificate' \
          --header 'Authorization: Bearer <access-token>' \
          --header 'Content-Type: application/json' \
          --data-raw '{
              "profileId": "<certificate-profile-id>",
              "commonName": "service.acme.com",
              "ttl": "1y",
              "signatureAlgorithm": "RSA-SHA256",
              "keyAlgorithm": "RSA_2048",
              "keyUsages": ["digital_signature", "key_encipherment"],
              "extendedKeyUsages": ["server_auth"],
              "altNames": [
                  {
                      "type": "DNS",
                      "value": "service.acme.com"
                  },
                  {
                      "type": "DNS",
                      "value": "www.service.acme.com"
                  }
              ]
          }'
        ```

        ### Sample response

        ```bash Response theme={"dark"}
        {
          "certificate": "-----BEGIN CERTIFICATE-----\nMIIEpDCCAowCCQD...\n-----END CERTIFICATE-----",
          "certificateChain": "-----BEGIN CERTIFICATE-----\nMIIEpDCCAowCCQD...\n-----END CERTIFICATE-----",
          "issuingCaCertificate": "-----BEGIN CERTIFICATE-----\nMIIEpDCCAowCCQD...\n-----END CERTIFICATE-----",
          "privateKey": "-----BEGIN PRIVATE KEY-----\nMIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQC...\n-----END PRIVATE KEY-----",
          "serialNumber": "123456789012345678",
          "certificateId": "880h3456-e29b-41d4-a716-446655440003"
        }
        ```

        <Note>
          Make sure to store the `privateKey` as it is only returned once here at the time of certificate issuance. The `certificate` and `certificateChain` will remain accessible and can be retrieved at any time.
        </Note>

        If you have an external private key, you can also issue a certificate by making an API request containing a pem-encoded CSR (Certificate Signing Request) to the [Sign Certificate](/api-reference/endpoints/certificates/sign-certificate) API endpoint.

        ### Sample request

        ```bash Request theme={"dark"}
        curl --location --request POST 'https://app.infisical.com/api/v3/pki/certificates/sign-certificate' \
          --header 'Authorization: Bearer <access-token>' \
          --header 'Content-Type: application/json' \
          --data-raw '{
              "profileId": "<certificate-profile-id>",
              "csr": "-----BEGIN CERTIFICATE REQUEST-----\nMIICvDCCAaQCAQAwdzELMAkGA1UEBhMCVVMxDTALBgNVBAgMBE9oaW8...\n-----END CERTIFICATE REQUEST-----",
              "ttl": "1y"
          }'
        ```

        ### Sample response

        ```bash Response theme={"dark"}
        {
          "certificate": "-----BEGIN CERTIFICATE-----\nMIIEpDCCAowCCQD...\n-----END CERTIFICATE-----",
          "certificateChain": "-----BEGIN CERTIFICATE-----\nMIIEpDCCAowCCQD...\n-----END CERTIFICATE-----",
          "issuingCaCertificate": "-----BEGIN CERTIFICATE-----\nMIIEpDCCAowCCQD...\n-----END CERTIFICATE-----",
          "serialNumber": "123456789012345679",
          "certificateId": "990i4567-e29b-41d4-a716-446655440004"
        }
        ```
      </Step>
    </Steps>
  </Tab>
</Tabs>


# Certificate Enrollment via EST
Source: https://infisical.com/docs/documentation/platform/pki/enrollment-methods/est



## Concept

The EST enrollment method allows you to issue and manage certificates against a specific [certificate profile](/documentation/platform/pki/certificates/profiles) using the [EST protocol](https://en.wikipedia.org/wiki/Enrollment_over_Secure_Transport).
This method is suitable for environments requiring strong authentication and encrypted communication, such as in IoT, enterprise networks, and secure web services.

Infisical's EST service is based on [RFC 7030](https://datatracker.ietf.org/doc/html/rfc7030) and implements the following endpoints:

* **cacerts** - provides the necessary CA chain for the client to validate certificates issued by the CA.
* **simpleenroll** - allows an EST client to request a new certificate from Infisical's EST server
* **simplereenroll** - similar to the /simpleenroll endpoint but is used for renewing an existing certificate.

These EST endpoints are exposed on port 8443 under the .well-known/est path
and structured under `https://app.infisical.com:8443/.well-known/est/{profile_id}/...`

## Prerequisites

* Your client devices need to have a bootstrap/pre-installed certificate.
* Your client devices must trust the server certificates used by Infisical's EST server. If the devices are new or lack existing trust configurations, you need to manually establish trust for the appropriate certificates.

<Note>
  For Infisical Cloud users, the devices must be configured to trust the [Amazon
  root CA certificates](https://www.amazontrust.com/repository).
</Note>

## Guide to Certificate Enrollment via EST

In the following steps, we explore how to issue a X.509 certificate using the EST enrollment method.

<Steps>
  <Step title="Create a certificate profile in Infisical">
    Create a [certificate
    profile](/documentation/platform/pki/certificates/profiles) with **EST**
    selected as the enrollment method and fill in EST-specific configuration.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/pki/enrollment-methods/est/est-config.png" alt="pki est config" />

    Here's some guidance on each EST-specific configuration field:

    * Disable Bootstrap CA Validation: Enable this if your devices are not configured with a bootstrap certificate.
    * EST Passphrase: This is also used to authenticate your devices with Infisical's EST server. When configuring the clients, use the value defined here as the EST password.
    * CA Chain Certificate: This is the certificate chain used to validate your devices' manufacturing/pre-installed certificates. This will be used to authenticate your devices with Infisical's EST server.
  </Step>

  <Step title="Obtain the EST label">
    Once the EST enrollment method configuration is complete, you can use the ID of the associated certificate profile
    `profile_id` as the EST label when enrolling EST clients with Infisical.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/pki/enrollment-methods/est/est-label.png" alt="pki est label" />

    The complete URL structure of the supported EST endpoints may look like the following:

    * [https://app.infisical.com:8443/.well-known/est/\{profile\_id}/cacerts](https://app.infisical.com:8443/.well-known/est/\{profile_id}/cacerts)
    * [https://app.infisical.com:8443/.well-known/est/\{profile\_id}/simpleenroll](https://app.infisical.com:8443/.well-known/est/\{profile_id}/simpleenroll)
    * [https://app.infisical.com:8443/.well-known/est/\{profile\_id}/simplereenroll](https://app.infisical.com:8443/.well-known/est/\{profile_id}/simplereenroll)
  </Step>

  <Step title="Configure EST clients">
    To use the EST passphrase in your clients, configure it as the EST password. The EST username can be set to any arbitrary value.
    Use the appropriate client certificates for invoking the EST endpoints.

    * For `simpleenroll`, use the bootstrapped/manufacturer client certificate.
    * For `simplereenroll`, use a valid EST-issued client certificate.
      When configuring the PKCS#12 objects for the client certificates, only include the leaf certificate and the private key.
  </Step>
</Steps>


# Overview
Source: https://infisical.com/docs/documentation/platform/pki/enrollment-methods/overview



Enrollment methods determine how certificates are issued and managed for a [certificate profile](/documentation/platform/pki/certificates/profiles).

Refer to the documentation for each enrollment method below to learn more about how to enroll certificates using it.

* [API](/documentation/platform/pki/enrollment-methods/api): Enroll certificates via API.
* [ACME](/documentation/platform/pki/enrollment-methods/acme): Enroll certificates using the ACME protocol.
* [EST](/documentation/platform/pki/enrollment-methods/est): Enroll certificates using the EST protocol.

Note that beyond using an enrollment method, you can also deliver a certificate to a target destination using supported [certificate syncs](https://infisical.com/docs/documentation/platform/pki/certificate-syncs/overview).


# Apache Server
Source: https://infisical.com/docs/documentation/platform/pki/integration-guides/apache-certbot

Learn how to issue SSL/TLS certificates from Infisical using ACME enrollment on Apache Server with Certbot

This guide demonstrates how to use Infisical to issue SSL/TLS certificates for your [Apache HTTP Server](https://httpd.apache.org/).

It uses [Certbot](https://certbot.eff.org/), an installable [ACME](https://en.wikipedia.org/wiki/Automatic_Certificate_Management_Environment) client, to request and renew certificates from Infisical using the [ACME enrollment method](/documentation/platform/pki/enrollment-methods/acme) configured on a [certificate profile](/documentation/platform/pki/certificates/profiles). Apache benefits from excellent Certbot integration, allowing both certificate-only mode and automatic SSL configuration.

## Prerequisites

Before you begin, make sure you have:

* An [Apache HTTP Server](https://httpd.apache.org/) running on a Linux system with administrative access.
* A [certificate profile](/documentation/platform/pki/certificates/profiles) configured with the [ACME enrollment method](/documentation/platform/pki/enrollment-methods/acme) in Infisical.
* Network connectivity from your Apache server to Infisical.
* Port 80 open and reachable for ACME [HTTP-01](https://letsencrypt.org/docs/challenge-types/#http-01-challenge) validation.

## Guide

<Steps>
  <Step title="Obtain ACME Configuration from Infisical">
    Navigate to your certificate management project in Infisical and locate your [certificate profile](/documentation/platform/pki/certificates/profiles) configured with the [ACME enrollment method](/documentation/platform/pki/enrollment-methods/acme).
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/pki/acme/certificate-profile-acme-option.png" alt="Certificate profile with ACME enrollment option" />

    Click the **Reveal ACME EAB** option to view the ACME configuration details.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/pki/acme/acme-configuration-modal.png" alt="ACME configuration modal showing directory URL and EAB credentials" />

    From the ACME configuration, gather the following values:

    * ACME Directory URL: The URL that Certbot will use to communicate with Infisical's ACME server. This takes the form `https://your-infisical-instance.com/api/v1/pki/certificate-profiles/{profile-id}/acme/directory`.
    * EAB Key Identifier (KID): A unique identifier that tells Infisical which ACME account is making the request.
    * EAB Secret: A secret key that authenticates your ACME client with Infisical.

    <Note>
      Keep your EAB credentials secure as they authenticate your ACME client with Infisical PKI. These credentials are unique to each [certificate profile](/documentation/platform/pki/certificates/profiles) and should not be shared.
    </Note>
  </Step>

  <Step title="Install Certbot">
    Install Certbot with the Apache plugin on the server where Apache is running by following the official Certbot [installation guide](https://certbot.eff.org/instructions).

    The installation guide provides up-to-date instructions for various Linux distributions and package managers, ensuring you get the most current version and proper Apache plugin integration.

    After installation, you can verify that Certbot has been installed correctly by running:

    ```bash  theme={"dark"}
    certbot --version
    ```
  </Step>

  <Step title="Request Certificate Using Certbot">
    Run the following command to request a certificate from Infisical:

    ```bash  theme={"dark"}
    sudo certbot certonly \
      --apache \
      --server "https://your-infisical-instance.com/api/v1/pki/certificate-profiles/{profile-id}/acme/directory" \
      --eab-kid "your-eab-key-identifier" \
      --eab-hmac-key "your-eab-secret" \
      -d example.infisical.com \
      --email admin@example.com \
      --agree-tos \
      --non-interactive
    ```

    For guidance on each parameter:

    * `certonly`: Instructs Certbot to request a certificate without modifying your Apache configuration files; this mode is recommended if you prefer to manage your Apache SSL configuration manually or have a complex setup.
    * `--apache`: Specifies the Apache plugin so Certbot can solve the [HTTP-01](https://letsencrypt.org/docs/challenge-types/#http-01-challenge) challenge by creating temporary files served by Apache.
    * `--server`: The Infisical ACME directory URL from Step 1. This instructs Certbot to communicate with Infisical's ACME server instead of Let's Encrypt.
    * `--eab-kid`: Your External Account Binding (EAB) Key Identifier from Step 1.
    * `--eab-hmac-key`: The EAB secret associated with the KID from Step 1.
    * `-d`: Specifies the domain name for which the certificate is being requested.
    * `--email`: The contact email for expiration notices and account recovery.
    * `--agree-tos`: Accepts the ACME server's Terms of Service.
    * `--non-interactive`: Runs Certbot without prompting for user input (recommended for automation).

    The Certbot command generates a private key on your server, creates a Certificate Signing Request (CSR) using that key, and sends the CSR to Infisical for certificate issuance. Certbot stores the private key and resulting leaf certificate and full certificate chain in `/etc/letsencrypt/live/{domain-name}/`.

    If `--certonly` is used: Certbot does **not** modify your Apache configuration, so you must manually update your Apache virtual host to reference the new certificate files and reload the server to apply the changes.

    Here's an example SSL virtual host configuration for Apache:

    ```apache  theme={"dark"}
    <VirtualHost *:443>
        ServerName example.infisical.com
        DocumentRoot /var/www/html

        SSLEngine on
        SSLCertificateFile /etc/letsencrypt/live/example.infisical.com/cert.pem
        SSLCertificateKeyFile /etc/letsencrypt/live/example.infisical.com/privkey.pem
        SSLCertificateChainFile /etc/letsencrypt/live/example.infisical.com/chain.pem

        # Your existing configuration...
    </VirtualHost>
    ```

    After updating the virtual host configuration, test and reload Apache to apply the changes:

    ```bash  theme={"dark"}
    sudo apache2ctl configtest
    sudo systemctl reload apache2
    ```

    If `--certonly` was **not** used: Certbot uses installer mode, which attempts to automatically configure HTTPS by updating your Apache virtual host configuration and reloading the server if needed.

    At this point, your Apache server should be successfully serving HTTPS using the certificate issued by Infisical.
  </Step>

  <Step title="Verify Certificate Installation">
    After configuring Apache SSL, verify that your certificate was issued correctly and Apache is serving it properly.

    Check that the certificate files were created by Certbot:

    ```bash  theme={"dark"}
    sudo ls -la /etc/letsencrypt/live/example.infisical.com/
    ```

    You should see files like:

    * `cert.pem` (your certificate)
    * `chain.pem` (certificate chain)
    * `fullchain.pem` (certificate + chain)
    * `privkey.pem` (private key)
  </Step>

  <Step title="Renew Your Certificate with Certbot">
    Certbot automatically installs a `systemd` timer during installation. This timer runs twice per day and checks whether any certificates are due for renewal. Because Certbot stores the ACME server URL and EAB credentials from your initial request, renewal will automatically use the same Infisical ACME configurationno additional settings are required.

    Note that Certbot automatically renews certificates when they are within 30 days of expiration; renewal settings can be adjusted in `/etc/letsencrypt/renewal/{domain-name}.conf`.

    ```ini  theme={"dark"}
    # ... your existing configuration ...

    renew_before_expiry = 30 days
    ```

    To test the renewal process, run the following command:

    ```bash  theme={"dark"}
    sudo certbot renew --dry-run
    ```

    This command simulates the full renewal process without modifying your active certificate. If the dry run succeeds, automatic renewal will work as expected.

    To trigger an actual renewal immediately, run the following command:

    ```bash  theme={"dark"}
    sudo certbot renew --force-renewal
    ```

    Note that after a certificate is renewed, Apache must be reloaded so it can begin using the new certificate. To do this, run the following command:

    ```bash  theme={"dark"}
    sudo systemctl reload apache2
    ```

    To automate the process of renewing a certificate and reloading Apache, you can create a simple deploy hook that Certbot will run after every successful renewal.

    Inside `/etc/letsencrypt/renewal-hooks/deploy/reload-apache.sh`, add the following:

    ```bash  theme={"dark"}
    #!/bin/sh
    systemctl reload apache2
    ```

    Then make the hook executable:

    ```bash  theme={"dark"}
    sudo chmod +x /etc/letsencrypt/renewal-hooks/deploy/reload-apache.sh
    ```

    Alternatively, you can use the `--post-hook` option when manually renewing:

    ```bash  theme={"dark"}
    sudo certbot renew --post-hook "systemctl reload apache2"
    ```

    <Note>
      Certbot automatically renews certificates when they are within 30 days of expiration using its built-in systemd timer. The deploy hook above will run after each successful renewal, handling the Apache reload automatically. Apache has native Certbot plugin integration, so no additional configuration is typically needed.
    </Note>
  </Step>
</Steps>


# Gloo Mesh
Source: https://infisical.com/docs/documentation/platform/pki/integration-guides/gloo-mesh

Learn how to automatically provision and manage Istio intermediate CA certificates for Gloo Mesh using Infisical PKI

This guide will provide a high level overview on how you can use Infisical PKI and cert-manager to issue Istio intermediate CA certificates for your Gloo Mesh workload clusters. For more background about Istio certificates, see the [Istio CA overview](https://istio.io/latest/docs/concepts/security/#pki).

## Overview

In this setup, we will use Infisical PKI to generate and store your root CA and subordinate CAs that are used to generate Istio intermediate CAs for your Gloo Mesh workload clusters.
To manage the lifecycle of Istio intermediate CA certificates, you'll also install [cert-manager](https://cert-manager.io/).
Cert-manager is a Kubernetes controller that helps you automate the process of obtaining and renewing certificates from various PKI providers.

With this approach, you get the following benefits:

* Securely store your root CA certificates and private keys.
* Leverage Infisical subordinate CAs for an extra layer of protection beneath your root CA.
* Use cert-manager to automatically issue and renew Istio intermediate CA certificates from the same root, ensuring cross-cluster workload communication.
* Increased auditability of private key infrastructure.

## General Setup

The certificate provisioning workflow begins with setting up your PKI hierarchy in Infisical, where you create root and subordinate certificate authorities.
When you deploy a `Certificate` CRD in your workload cluster, `cert-manager` uses the Infisical PKI Issuer controller to authenticate with Infisical using machine identity credentials and request an intermediate CA certificate.
Infisical verifies the request against your certificate templates and returns the signed certificate.
From there, Istio's control plane will automatically use this intermediate CA to sign leaf certificates for workloads in the service mesh, enabling secure mTLS communication across your entire Gloo Mesh infrastructure.

Follow the [Infisical PKI Issuer guide](/documentation/platform/pki/pki-issuer) for detailed instructions on how to set up the Infisical PKI Issuer and cert-manager for your Istio intermediate CA certificates in Gloo Mesh clusters.

For Gloo Mesh-specific configuration, ensure that:

* The Certificate resource targets the `istio-system` namespace with `secretName: cacerts`
* Certificate templates in Infisical PKI are configured for intermediate CA usage with appropriate key usage and constraints
* Multiple workload clusters use the same Infisical PKI root to enable cross-cluster mTLS communication

## Using the certificates

Once the `cacerts` Kubernetes secret is created in the `istio-system` namespace, Istio automatically uses the custom CA certificate instead of the default self-signed certificate.
When you deploy applications to your Gloo Mesh service mesh, the workloads will receive leaf certificates signed by your Infisical PKI intermediate CA, enabling secure mTLS communication across your entire mesh infrastructure.


# JBoss/WildFly
Source: https://infisical.com/docs/documentation/platform/pki/integration-guides/jboss-certbot

Learn how to issue SSL/TLS certificates from Infisical using ACME enrollment on JBoss/WildFly with Certbot

This guide demonstrates how to use Infisical to issue SSL/TLS certificates for your [JBoss](https://www.jboss.org/)/[WildFly](https://wildfly.org/) application server.

It uses [Certbot](https://certbot.eff.org/), an installable [ACME](https://en.wikipedia.org/wiki/Automatic_Certificate_Management_Environment) client, to request and renew certificates from Infisical using the [ACME enrollment method](/documentation/platform/pki/enrollment-methods/acme) configured on a [certificate profile](/documentation/platform/pki/certificates/profiles). JBoss/WildFly requires certificates in Java keystore format, which this guide addresses through the certificate conversion process.

## Prerequisites

Before you begin, make sure you have:

* A [JBoss](https://www.jboss.org/)/[WildFly](https://wildfly.org/) application server running on a Linux system with administrative access.
* A [certificate profile](/documentation/platform/pki/certificates/profiles) configured with the [ACME enrollment method](/documentation/platform/pki/enrollment-methods/acme) in Infisical.
* Network connectivity from your JBoss/WildFly server to Infisical.
* Port 80 open and reachable for ACME [HTTP-01](https://letsencrypt.org/docs/challenge-types/#http-01-challenge) validation.
* [Java Development Kit (JDK)](https://openjdk.org/) installed for keystore management tools.

## Guide

<Steps>
  <Step title="Obtain ACME Configuration from Infisical">
    Navigate to your certificate management project in Infisical and locate your [certificate profile](/documentation/platform/pki/certificates/profiles) configured with the [ACME enrollment method](/documentation/platform/pki/enrollment-methods/acme).
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/pki/acme/certificate-profile-acme-option.png" alt="Certificate profile with ACME enrollment option" />

    Click the **Reveal ACME EAB** option to view the ACME configuration details.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/pki/acme/acme-configuration-modal.png" alt="ACME configuration modal showing directory URL and EAB credentials" />

    From the ACME configuration, gather the following values:

    * ACME Directory URL: The URL that Certbot will use to communicate with Infisical's ACME server. This takes the form `https://your-infisical-instance.com/api/v1/pki/certificate-profiles/{profile-id}/acme/directory`.
    * EAB Key Identifier (KID): A unique identifier that tells Infisical which ACME account is making the request.
    * EAB Secret: A secret key that authenticates your ACME client with Infisical.

    <Note>
      Keep your EAB credentials secure as they authenticate your ACME client with Infisical PKI. These credentials are unique to each [certificate profile](/documentation/platform/pki/certificates/profiles) and should not be shared.
    </Note>
  </Step>

  <Step title="Install Certbot">
    Install Certbot on the server where JBoss/WildFly is running by following the official Certbot [installation guide](https://certbot.eff.org/instructions).

    The installation guide provides up-to-date instructions for various Linux distributions and package managers, ensuring you get the most current version of Certbot.

    After installation, you can verify that Certbot has been installed correctly by running:

    ```bash  theme={"dark"}
    certbot --version
    ```
  </Step>

  <Step title="Request Certificate Using Certbot">
    Since JBoss/WildFly doesn't have a native Certbot plugin, use the standalone authenticator to obtain certificates. **Important**: You must stop JBoss/WildFly before running this command as Certbot needs to bind to port 80 for the [HTTP-01](https://letsencrypt.org/docs/challenge-types/#http-01-challenge) challenge.

    Stop your JBoss/WildFly server:

    ```bash  theme={"dark"}
    sudo systemctl stop wildfly
    # or for older JBoss versions
    # sudo systemctl stop jboss
    ```

    Run the following command to request a certificate from Infisical:

    ```bash  theme={"dark"}
    sudo certbot certonly \
      --standalone \
      --server "https://your-infisical-instance.com/api/v1/pki/certificate-profiles/{profile-id}/acme/directory" \
      --eab-kid "your-eab-key-identifier" \
      --eab-hmac-key "your-eab-secret" \
      -d example.infisical.com \
      --email admin@example.com \
      --agree-tos \
      --non-interactive
    ```

    For guidance on each parameter:

    * `certonly`: Instructs Certbot to request a certificate without modifying your JBoss/WildFly configuration; this mode is recommended because JBoss/WildFly requires certificates in Java keystore format rather than the PEM format that Certbot provides.
    * `--standalone`: Uses Certbot's standalone authenticator to solve the [HTTP-01](https://letsencrypt.org/docs/challenge-types/#http-01-challenge) challenge by starting a temporary web server on port 80.
    * `--server`: The Infisical ACME directory URL from Step 1. This instructs Certbot to communicate with Infisical's ACME server instead of Let's Encrypt.
    * `--eab-kid`: Your External Account Binding (EAB) Key Identifier from Step 1.
    * `--eab-hmac-key`: The EAB secret associated with the KID from Step 1.
    * `-d`: Specifies the domain name for which the certificate is being requested.
    * `--email`: The contact email for expiration notices and account recovery.
    * `--agree-tos`: Accepts the ACME server's Terms of Service.
    * `--non-interactive`: Runs Certbot without prompting for user input (recommended for automation).

    The Certbot command generates a private key on your server, creates a Certificate Signing Request (CSR) using that key, and sends the CSR to Infisical for certificate issuance. Certbot stores the private key and resulting leaf certificate and full certificate chain in `/etc/letsencrypt/live/{domain-name}/`.

    Because JBoss/WildFly requires certificates in Java keystore format, you'll need to convert the PEM certificates provided by Certbot in the next step.
  </Step>

  <Step title="Convert Certificate to Java Keystore">
    JBoss/WildFly requires certificates in Java keystore format rather than the PEM format provided by Certbot. Convert the PEM certificates to PKCS#12 format, which is supported by modern JBoss/WildFly versions.

    Create a PKCS#12 keystore from the PEM files:

    ```bash  theme={"dark"}
    sudo openssl pkcs12 -export \
      -out /opt/wildfly/standalone/configuration/keystore.p12 \
      -inkey /etc/letsencrypt/live/example.infisical.com/privkey.pem \
      -in /etc/letsencrypt/live/example.infisical.com/cert.pem \
      -certfile /etc/letsencrypt/live/example.infisical.com/chain.pem \
      -passout pass:changeit
    ```

    Set appropriate file permissions for security:

    ```bash  theme={"dark"}
    sudo chown wildfly:wildfly /opt/wildfly/standalone/configuration/keystore.p12
    sudo chmod 600 /opt/wildfly/standalone/configuration/keystore.p12
    ```

    You will need to configure JBoss/WildFly to use the new keystore. This process varies depending on your JBoss/WildFly version and security configuration (legacy security realms vs. Elytron subsystem). Refer to your [JBoss](https://access.redhat.com/documentation/en-us/red_hat_jboss_enterprise_application_platform)/[WildFly](https://docs.wildfly.org/) administration guide for specific SSL/TLS configuration steps.

    <Note>
      Replace `changeit` with a strong password and adjust the WildFly installation path based on your environment. Modern WildFly versions support PKCS#12 keystores directly, while older versions may require conversion to JKS format using the [keytool](https://docs.oracle.com/javase/8/docs/technotes/tools/unix/keytool.html) utility.
    </Note>
  </Step>

  <Step title="Verify Certificate Installation">
    After configuring JBoss/WildFly SSL, verify that your certificate was issued correctly and the keystore was created properly.

    Check that the certificate files were created by Certbot:

    ```bash  theme={"dark"}
    sudo ls -la /etc/letsencrypt/live/example.infisical.com/
    ```

    You should see files like:

    * `cert.pem` (your certificate)
    * `chain.pem` (certificate chain)
    * `fullchain.pem` (certificate + chain)
    * `privkey.pem` (private key)

    Verify the PKCS#12 keystore was created:

    ```bash  theme={"dark"}
    sudo ls -la /opt/wildfly/standalone/configuration/keystore.p12
    ```

    Test the keystore contents (optional):

    ```bash  theme={"dark"}
    sudo keytool -list -storetype PKCS12 -keystore /opt/wildfly/standalone/configuration/keystore.p12 -storepass changeit
    ```

    Once you've configured JBoss/WildFly to use the keystore and restarted the service, you can verify HTTPS is working by accessing your application over SSL.
  </Step>

  <Step title="Renew Your Certificate with Certbot">
    Unlike standard web servers, JBoss/WildFly certificate renewal requires additional steps because certificates must be converted to Java keystore format and the application server must be restarted to use the new certificates.

    To test the renewal process without affecting your live certificates, run the following command:

    ```bash  theme={"dark"}
    sudo certbot renew --dry-run
    ```

    This command simulates the full renewal process without modifying your active certificate. If the dry run succeeds, the renewal mechanism itself will work as expected.

    For actual renewal, since JBoss/WildFly requires the standalone authenticator, you'll need to stop the server, perform the renewal, convert the certificate, and restart:

    ```bash  theme={"dark"}
    # Stop JBoss/WildFly
    sudo systemctl stop wildfly

    # Renew the certificate
    sudo certbot renew --quiet

    # Convert to keystore format
    sudo openssl pkcs12 -export \
      -out /opt/wildfly/standalone/configuration/keystore.p12 \
      -inkey /etc/letsencrypt/live/example.infisical.com/privkey.pem \
      -in /etc/letsencrypt/live/example.infisical.com/cert.pem \
      -certfile /etc/letsencrypt/live/example.infisical.com/chain.pem \
      -passout pass:changeit

    # Set permissions
    sudo chown wildfly:wildfly /opt/wildfly/standalone/configuration/keystore.p12
    sudo chmod 600 /opt/wildfly/standalone/configuration/keystore.p12

    # Start JBoss/WildFly
    sudo systemctl start wildfly
    ```

    To automate this process, you can create a renewal script. Create `/etc/letsencrypt/renewal-hooks/deploy/jboss-renewal.sh`:

    ```bash  theme={"dark"}
    #!/bin/bash
    # JBoss/WildFly certificate renewal hook

    DOMAIN="example.infisical.com"
    KEYSTORE_PATH="/opt/wildfly/standalone/configuration/keystore.p12"
    KEYSTORE_PASSWORD="changeit"

    # Convert certificate to keystore format
    openssl pkcs12 -export \
      -out "$KEYSTORE_PATH" \
      -inkey "/etc/letsencrypt/live/$DOMAIN/privkey.pem" \
      -in "/etc/letsencrypt/live/$DOMAIN/cert.pem" \
      -certfile "/etc/letsencrypt/live/$DOMAIN/chain.pem" \
      -passout "pass:$KEYSTORE_PASSWORD"

    # Set permissions
    chown wildfly:wildfly "$KEYSTORE_PATH"
    chmod 600 "$KEYSTORE_PATH"

    # Restart WildFly to load new certificate
    systemctl restart wildfly
    ```

    Make the hook executable:

    ```bash  theme={"dark"}
    sudo chmod +x /etc/letsencrypt/renewal-hooks/deploy/jboss-renewal.sh
    ```

    <Note>
      Certbot automatically renews certificates when they are within 30 days of expiration using its built-in systemd timer. The deploy hook above will run after each successful renewal, handling the keystore conversion and service restart automatically. Because JBoss/WildFly requires the standalone authenticator (which stops the service temporarily), plan for brief service interruptions during renewal.
    </Note>
  </Step>
</Steps>


# Nginx
Source: https://infisical.com/docs/documentation/platform/pki/integration-guides/nginx-certbot

Learn how to issue SSL/TLS certificates from Infisical using ACME enrollment on Nginx with Certbot

This guide demonstrates how to use Infisical to issue SSL/TLS certificates for your [Nginx](https://nginx.org/) server.

It uses [Certbot](https://certbot.eff.org/), an installable [ACME](https://en.wikipedia.org/wiki/Automatic_Certificate_Management_Environment) client, to request and renew certificates from Infisical using the [ACME enrollment method](/documentation/platform/pki/enrollment-methods/acme) configured on a [certificate profile](/documentation/platform/pki/certificates/profiles).

## Prerequisites

Before you begin, make sure you have:

* An [Nginx](https://nginx.org/) web server running on a Linux system with administrative access.
* A [certificate profile](/documentation/platform/pki/certificates/profiles) configured with the [ACME enrollment method](/documentation/platform/pki/enrollment-methods/acme) in Infisical.
* Network connectivity from your Nginx server to Infisical.
* Port 80 open and reachable for ACME [HTTP-01](https://letsencrypt.org/docs/challenge-types/#http-01-challenge) validation.

## Guide

<Steps>
  <Step title="Obtain ACME Configuration from Infisical">
    Navigate to your certificate management project in Infisical and locate your [certificate profile](/documentation/platform/pki/certificates/profiles) configured with the [ACME enrollment method](/documentation/platform/pki/enrollment-methods/acme).
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/pki/acme/certificate-profile-acme-option.png" alt="Certificate profile with ACME enrollment option" />

    Click the **Reveal ACME EAB** option to view the ACME configuration details.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/pki/acme/acme-configuration-modal.png" alt="ACME configuration modal showing directory URL and EAB credentials" />

    From the ACME configuration, gather the following values:

    * ACME Directory URL: The URL that Certbot will use to communicate with Infisical's ACME server. This takes the form `https://your-infisical-instance.com/api/v1/pki/certificate-profiles/{profile-id}/acme/directory`.
    * EAB Key Identifier (KID): A unique identifier that tells Infisical which ACME account is making the request.
    * EAB Secret: A secret key that authenticates your ACME client with Infisical.

    <Note>
      Keep your EAB credentials secure as they authenticate your ACME client with Infisical PKI. These credentials are unique to each [certificate profile](/documentation/platform/pki/certificates/profiles) and should not be shared.
    </Note>
  </Step>

  <Step title="Install Certbot">
    Install Certbot on the server where Nginx is running by following the official Certbot [installation guide](https://certbot.eff.org/instructions).

    The installation guide provides up-to-date instructions for various Linux distributions and package managers, ensuring you get the most current version and proper Nginx plugin integration.

    After installation, you can verify that Certbot has been installed correctly by running:

    ```bash  theme={"dark"}
    certbot --version
    ```
  </Step>

  <Step title="Request Certificate Using Certbot">
    Run the following command to request a certificate from Infisical:

    ```bash  theme={"dark"}
    sudo certbot certonly \
      --nginx \
      --server "https://your-infisical-instance.com/api/v1/pki/certificate-profiles/{profile-id}/acme/directory" \
      --eab-kid "your-eab-key-identifier" \
      --eab-hmac-key "your-eab-secret" \
      -d example.infisical.com \
      --email admin@example.com \
      --agree-tos \
      --non-interactive
    ```

    For guidance on each parameter:

    * `certonly`: Instructs Certbot to request a certificate without modifying and reloading your Nginx configuration file(s); this mode is recommended if you prefer to manage your Nginx TLS configuration manually, use automation tools, or integrate certificates into an existing deployment workflow.
    * `--nginx`: Specifies the Nginx plugin so Certbot can solve the [HTTP-01](https://letsencrypt.org/docs/challenge-types/#http-01-challenge) challenge by creating temporary files served by Nginx.
    * `--server`: The Infisical ACME directory URL from Step 1. This instructs Certbot to communicate with Infisical's ACME server instead of Let's Encrypt.
    * `--eab-kid`: Your External Account Binding (EAB) Key Identifier from Step 1.
    * `--eab-hmac-key`: The EAB secret associated with the KID from Step 1.
    * `-d`: Specifies the domain name for which the certificate is being requested.
    * `--email`: The contact email for expiration notices and account recovery.
    * `--agree-tos`: Accepts the ACME servers Terms of Service.
    * `--non-interactive`: Runs Certbot without prompting for user input (recommended for automation).

    The Certbot command generates a private key on your server, creates a Certificate Signing Request (CSR) using that key, and sends the CSR to Infisical for certificate issuance. Certbot stores the private key and resulting leaf certificate and full certificate chain in `/etc/letsencrypt/live/{domain-name}/`.

    If `--certonly` is used: Certbot does **not** modify your Nginx configuration, so you must manually update your Nginx server block to reference the new certificate files and reload the server to apply the changes.

    Here's how you can configure your server block:

    ```nginx  theme={"dark"}
    server {
        listen 443 ssl;
        server_name example.infisical.com;

        ssl_certificate     /etc/letsencrypt/live/example.infisical.com/fullchain.pem;
        ssl_certificate_key /etc/letsencrypt/live/example.infisical.com/privkey.pem;

        # ...your existing configuration...
    }

    ```

    After updating the server block, you should test and reload Nginx to apply the changes:

    ```bash  theme={"dark"}
    sudo nginx -t
    sudo systemctl reload nginx
    ```

    If `--certonly` was **not** used: Certbot uses Nginx installer mode, which attempts to automatically configure HTTPS by updating your Nginx server block and reloading the server if needed.

    At this point, your Nginx server should be successfully serving HTTPS using the certificate issued by Infisical.
  </Step>

  <Step title="Verify Certificate Installation">
    After configuring Nginx SSL, verify that your certificate was issued correctly and Nginx is serving it properly.

    Check that the certificate files were created by Certbot:

    ```bash  theme={"dark"}
    sudo ls -la /etc/letsencrypt/live/example.infisical.com/
    ```

    You should see files like:

    * `cert.pem` (your certificate)
    * `chain.pem` (certificate chain)
    * `fullchain.pem` (certificate + chain)
    * `privkey.pem` (private key)
  </Step>

  <Step title="Renew Your Certificate with Certbot">
    Certbot automatically installs a `systemd` timer during installation. This timer runs twice per day and checks whether any certificates are due for renewal. Because Certbot stores the ACME server URL and EAB credentials from your initial request, renewal will automatically use the same Infisical ACME configurationno additional settings are required.

    Note that Certbot automatically renews certificates when they are within 30 days of expiration; renewal settings can be adjusted in `/etc/letsencrypt/renewal/{domain-name}.conf`.

    ```ini  theme={"dark"}
    # ... your existing configuration ...

    renew_before_expiry = 30 days
    ```

    To test the renewal process, run the following command:

    ```bash  theme={"dark"}
    sudo certbot renew --dry-run
    ```

    This command simulates the full renewal process without modifying your active certificate. If the dry run succeeds, automatic renewal will work as expected.

    To trigger an actual renewal immediately, run the following command:

    ```bash  theme={"dark"}
    sudo certbot renew --force-renewal
    ```

    Note that after a certificate is renewed, Nginx must be reloaded so it can begin using the new certificate. To do this, run the following command:

    ```bash  theme={"dark"}
    systemctl reload nginx
    ```

    To automate the process of renewing a certificate and reloading Nginx, you can create a simple deploy hook that Certbot will run after every successful renewal.

    Inside `/etc/letsencrypt/renewal-hooks/deploy/reload-nginx.sh`, add the following:

    ```bash  theme={"dark"}
    #!/bin/sh
    systemctl reload nginx
    ```

    Then make the hook executable:

    ```bash  theme={"dark"}
    sudo chmod +x /etc/letsencrypt/renewal-hooks/deploy/reload-nginx.sh
    ```
  </Step>
</Steps>


# Tomcat
Source: https://infisical.com/docs/documentation/platform/pki/integration-guides/tomcat-certbot

Learn how to issue SSL/TLS certificates from Infisical using ACME enrollment on Tomcat with Certbot

This guide demonstrates how to use Infisical to issue SSL/TLS certificates for your [Apache Tomcat](https://tomcat.apache.org/) application server.

It uses [Certbot](https://certbot.eff.org/), an installable [ACME](https://en.wikipedia.org/wiki/Automatic_Certificate_Management_Environment) client, to request and renew certificates from Infisical using the [ACME enrollment method](/documentation/platform/pki/enrollment-methods/acme) configured on a [certificate profile](/documentation/platform/pki/certificates/profiles). Unlike web servers with native Certbot plugins, Tomcat requires certificates to be manually configured after issuance.

## Prerequisites

Before you begin, make sure you have:

* An [Apache Tomcat](https://tomcat.apache.org/) application server running on a Linux system with administrative access.
* A [certificate profile](/documentation/platform/pki/certificates/profiles) configured with the [ACME enrollment method](/documentation/platform/pki/enrollment-methods/acme) in Infisical.
* Network connectivity from your Tomcat server to Infisical.
* Port 80 open and reachable for ACME [HTTP-01](https://letsencrypt.org/docs/challenge-types/#http-01-challenge) validation.

## Guide

<Steps>
  <Step title="Obtain ACME Configuration from Infisical">
    Navigate to your certificate management project in Infisical and locate your [certificate profile](/documentation/platform/pki/certificates/profiles) configured with the [ACME enrollment method](/documentation/platform/pki/enrollment-methods/acme).
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/pki/acme/certificate-profile-acme-option.png" alt="Certificate profile with ACME enrollment option" />

    Click the **Reveal ACME EAB** option to view the ACME configuration details.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/pki/acme/acme-configuration-modal.png" alt="ACME configuration modal showing directory URL and EAB credentials" />

    From the ACME configuration, gather the following values:

    * ACME Directory URL: The URL that Certbot will use to communicate with Infisical's ACME server. This takes the form `https://your-infisical-instance.com/api/v1/pki/certificate-profiles/{profile-id}/acme/directory`.
    * EAB Key Identifier (KID): A unique identifier that tells Infisical which ACME account is making the request.
    * EAB Secret: A secret key that authenticates your ACME client with Infisical.

    <Note>
      Keep your EAB credentials secure as they authenticate your ACME client with Infisical PKI. These credentials are unique to each [certificate profile](/documentation/platform/pki/certificates/profiles) and should not be shared.
    </Note>
  </Step>

  <Step title="Install Certbot">
    Install Certbot on the server where Tomcat is running by following the official Certbot [installation guide](https://certbot.eff.org/instructions).

    The installation guide provides up-to-date instructions for various Linux distributions and package managers, ensuring you get the most current version of Certbot.

    After installation, you can verify that Certbot has been installed correctly by running:

    ```bash  theme={"dark"}
    certbot --version
    ```
  </Step>

  <Step title="Request Certificate Using Certbot">
    Since Tomcat doesn't have a native Certbot plugin, use the standalone authenticator to obtain certificates. **Important**: You must stop Tomcat before running this command as Certbot needs to bind to port 80 for the [HTTP-01](https://letsencrypt.org/docs/challenge-types/#http-01-challenge) challenge.

    Stop your Tomcat server:

    ```bash  theme={"dark"}
    sudo systemctl stop tomcat
    ```

    Run the following command to request a certificate from Infisical:

    ```bash  theme={"dark"}
    sudo certbot certonly \
      --standalone \
      --server "https://your-infisical-instance.com/api/v1/pki/certificate-profiles/{profile-id}/acme/directory" \
      --eab-kid "your-eab-key-identifier" \
      --eab-hmac-key "your-eab-secret" \
      -d example.infisical.com \
      --email admin@example.com \
      --agree-tos \
      --non-interactive
    ```

    For guidance on each parameter:

    * `certonly`: Instructs Certbot to request a certificate without modifying your Tomcat configuration; this mode is recommended because Tomcat requires manual SSL connector configuration in its server.xml file.
    * `--standalone`: Uses Certbot's standalone authenticator to solve the [HTTP-01](https://letsencrypt.org/docs/challenge-types/#http-01-challenge) challenge by starting a temporary web server on port 80.
    * `--server`: The Infisical ACME directory URL from Step 1. This instructs Certbot to communicate with Infisical's ACME server instead of Let's Encrypt.
    * `--eab-kid`: Your External Account Binding (EAB) Key Identifier from Step 1.
    * `--eab-hmac-key`: The EAB secret associated with the KID from Step 1.
    * `-d`: Specifies the domain name for which the certificate is being requested.
    * `--email`: The contact email for expiration notices and account recovery.
    * `--agree-tos`: Accepts the ACME server's Terms of Service.
    * `--non-interactive`: Runs Certbot without prompting for user input (recommended for automation).

    The Certbot command generates a private key on your server, creates a Certificate Signing Request (CSR) using that key, and sends the CSR to Infisical for certificate issuance. Certbot stores the private key and resulting leaf certificate and full certificate chain in `/etc/letsencrypt/live/{domain-name}/`.

    Because Tomcat requires manual SSL configuration, you'll need to configure the SSL connector in your Tomcat server.xml file to reference these certificate files. You can restart Tomcat after the certificate is issued, but SSL won't be enabled until you complete the server configuration.

    ```bash  theme={"dark"}
    sudo systemctl start tomcat
    ```
  </Step>

  <Step title="Configure Tomcat SSL Connector">
    To enable SSL/TLS in Tomcat, you need to configure an SSL connector in the server.xml configuration file. Tomcat can use the PEM certificates directly without conversion to Java keystore format (available in Tomcat 8.5+ with the NIO or NIO2 connector).

    Edit your Tomcat server.xml file (typically located at `/opt/tomcat/conf/server.xml` or `/usr/share/tomcat/conf/server.xml`):

    ```xml  theme={"dark"}
    <Connector port="8443"
               protocol="org.apache.coyote.http11.Http11NioProtocol"
               maxThreads="150"
               SSLEnabled="true">
        <SSLHostConfig>
            <Certificate certificateFile="/etc/letsencrypt/live/example.infisical.com/cert.pem"
                       certificateKeyFile="/etc/letsencrypt/live/example.infisical.com/privkey.pem"
                       certificateChainFile="/etc/letsencrypt/live/example.infisical.com/chain.pem"
                       type="RSA" />
        </SSLHostConfig>
    </Connector>
    ```

    Restart Tomcat to apply the SSL configuration:

    ```bash  theme={"dark"}
    sudo systemctl restart tomcat
    ```

    You can verify SSL is working by accessing your Tomcat application at `https://example.infisical.com:8443`. For production deployments, consider configuring a reverse proxy (like [Apache HTTP Server](https://httpd.apache.org/) or [Nginx](https://nginx.org/)) to handle SSL termination on standard port 443.

    <Note>
      The certificate paths must be readable by the Tomcat user. You may need to adjust file permissions or copy the certificates to a location accessible by Tomcat. For security, ensure the private key file has restricted permissions (600) and is owned by the Tomcat user.
    </Note>
  </Step>

  <Step title="Verify Certificate Installation">
    After configuring Tomcat SSL, verify that your certificate was issued correctly and Tomcat is serving it properly.

    Check that the certificate files were created by Certbot:

    ```bash  theme={"dark"}
    sudo ls -la /etc/letsencrypt/live/example.infisical.com/
    ```

    You should see files like:

    * `cert.pem` (your certificate)
    * `chain.pem` (certificate chain)
    * `fullchain.pem` (certificate + chain)
    * `privkey.pem` (private key)
  </Step>

  <Step title="Renew Your Certificate with Certbot">
    Unlike web servers with native Certbot plugins, Tomcat certificate renewal requires stopping the server, renewing the certificate, and restarting to load the new certificates.

    To test the renewal process without affecting your live certificates, run the following command:

    ```bash  theme={"dark"}
    sudo certbot renew --dry-run
    ```

    This command simulates the full renewal process without modifying your active certificate. If the dry run succeeds, the renewal mechanism will work as expected.

    For actual renewal, since Tomcat requires the standalone authenticator, you'll need to stop the server, perform the renewal, and restart:

    ```bash  theme={"dark"}
    # Stop Tomcat
    sudo systemctl stop tomcat

    # Renew the certificate
    sudo certbot renew --quiet

    # Start Tomcat
    sudo systemctl start tomcat
    ```

    **Important considerations for Tomcat renewal:**

    Because Tomcat uses the standalone authenticator, the server must be stopped during renewal. This creates a service interruption that requires manual coordination:

    1. **Plan maintenance windows** for certificate renewals (typically every 60-90 days)
    2. **Monitor renewal dates** to schedule downtime appropriately
    3. **Consider load balancers** or multiple instances for high availability during renewals

    Create a deploy hook to automate post-renewal tasks. Create `/etc/letsencrypt/renewal-hooks/deploy/tomcat-renewal.sh`:

    ```bash  theme={"dark"}
    #!/bin/bash
    # Tomcat certificate renewal hook
    # This runs AFTER Certbot successfully renews certificates

    DOMAIN="example.infisical.com"
    TOMCAT_USER="tomcat"

    # Ensure certificate files are readable by Tomcat
    chown root:$TOMCAT_USER "/etc/letsencrypt/live/$DOMAIN/cert.pem"
    chown root:$TOMCAT_USER "/etc/letsencrypt/live/$DOMAIN/privkey.pem"
    chown root:$TOMCAT_USER "/etc/letsencrypt/live/$DOMAIN/chain.pem"
    chown root:$TOMCAT_USER "/etc/letsencrypt/live/$DOMAIN/fullchain.pem"

    # Set appropriate permissions
    chmod 640 "/etc/letsencrypt/live/$DOMAIN/cert.pem"
    chmod 640 "/etc/letsencrypt/live/$DOMAIN/privkey.pem"
    chmod 640 "/etc/letsencrypt/live/$DOMAIN/chain.pem"
    chmod 640 "/etc/letsencrypt/live/$DOMAIN/fullchain.pem"

    # Start Tomcat (it was stopped for renewal)
    systemctl start tomcat

    # Wait for startup and verify service is running
    sleep 10
    if ! systemctl is-active --quiet tomcat; then
        echo "ERROR: Tomcat failed to start after certificate renewal"
        exit 1
    fi

    echo "Tomcat certificate renewal completed successfully"
    ```

    Make the hook executable:

    ```bash  theme={"dark"}
    sudo chmod +x /etc/letsencrypt/renewal-hooks/deploy/tomcat-renewal.sh
    ```

    <Note>
      Certbot automatically renews certificates when they are within 30 days of expiration using its built-in systemd timer. The deploy hook above will run after each successful renewal, handling the certificate permissions and service restart automatically. Because Tomcat requires the standalone authenticator (which stops the service temporarily), plan for brief service interruptions during renewal.
    </Note>
  </Step>

  <Step title="Using Renewed Certificates Manually">
    If you need to manually apply renewed certificates to Tomcat (when the deploy hook isn't used), follow these steps:

    **Step 1: Set certificate file permissions**

    After Certbot renews your certificates, ensure they're readable by Tomcat:

    ```bash  theme={"dark"}
    sudo chown root:tomcat /etc/letsencrypt/live/example.infisical.com/cert.pem
    sudo chown root:tomcat /etc/letsencrypt/live/example.infisical.com/privkey.pem
    sudo chown root:tomcat /etc/letsencrypt/live/example.infisical.com/chain.pem
    sudo chmod 640 /etc/letsencrypt/live/example.infisical.com/cert.pem
    sudo chmod 640 /etc/letsencrypt/live/example.infisical.com/privkey.pem
    sudo chmod 640 /etc/letsencrypt/live/example.infisical.com/chain.pem
    ```

    **Step 2: Restart Tomcat to load new certificates**

    ```bash  theme={"dark"}
    sudo systemctl restart tomcat
    ```

    That's it! Tomcat will automatically use the renewed certificates since your `server.xml` already points to the Let's Encrypt certificate files.

    <Note>
      Since Tomcat reads certificates from the file system on startup, you only need to restart the service after certificate renewal. The certificate file paths in `/etc/letsencrypt/live/` are symbolic links that automatically point to the latest certificates.
    </Note>
  </Step>
</Steps>


# Windows Server
Source: https://infisical.com/docs/documentation/platform/pki/integration-guides/windows-server-acme

Learn how to issue SSL/TLS certificates from Infisical using ACME enrollment on Windows Server with win-acme

This guide demonstrates how to use Infisical to issue SSL/TLS certificates for your [Windows Server](https://www.microsoft.com/en-us/windows-server) environments.

It uses [win-acme](https://www.win-acme.com/), a feature-rich [ACME](https://en.wikipedia.org/wiki/Automatic_Certificate_Management_Environment) client designed specifically for Windows, to request and renew certificates from Infisical using the [ACME enrollment method](/documentation/platform/pki/enrollment-methods/acme) configured on a [certificate profile](/documentation/platform/pki/certificates/profiles). Win-acme offers excellent integration with IIS, Windows Certificate Store, and various certificate storage options.

## Prerequisites

Before you begin, make sure you have:

* A [Windows Server](https://www.microsoft.com/en-us/windows-server) instance running with administrative access.
* A [certificate profile](/documentation/platform/pki/certificates/profiles) configured with the [ACME enrollment method](/documentation/platform/pki/enrollment-methods/acme) in Infisical.
* Network connectivity from your Windows Server to Infisical.

## Guide

<Steps>
  <Step title="Obtain ACME Configuration from Infisical">
    Navigate to your certificate management project in Infisical and locate your [certificate profile](/documentation/platform/pki/certificates/profiles) configured with the [ACME enrollment method](/documentation/platform/pki/enrollment-methods/acme).
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/pki/acme/certificate-profile-acme-option.png" alt="Certificate profile with ACME enrollment option" />

    Click the **Reveal ACME EAB** option to view the ACME configuration details.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/pki/acme/acme-configuration-modal.png" alt="ACME configuration modal showing directory URL and EAB credentials" />

    From the ACME configuration, gather the following values:

    * ACME Directory URL: The URL that win-acme will use to communicate with Infisical's ACME server. This takes the form `https://your-infisical-instance.com/api/v1/pki/certificate-profiles/{profile-id}/acme/directory`.
    * EAB Key Identifier (KID): A unique identifier that tells Infisical which ACME account is making the request.
    * EAB Secret: A secret key that authenticates your ACME client with Infisical.

    <Note>
      Keep your EAB credentials secure as they authenticate your ACME client with Infisical PKI. These credentials are unique to each [certificate profile](/documentation/platform/pki/certificates/profiles) and should not be shared.
    </Note>
  </Step>

  <Step title="Install win-acme">
    Install win-acme on your Windows Server using one of the following methods.

    <Tabs>
      <Tab title="Download from GitHub">
        1. Visit the [win-acme releases page](https://github.com/win-acme/win-acme/releases).
        2. Download the latest stable release ZIP file.
        3. Extract the contents to a folder (e.g., `C:\win-acme`).
        4. Open Command Prompt or PowerShell as Administrator.
        5. Navigate to the win-acme folder.

        ```powershell  theme={"dark"}
        cd C:\win-acme
        ```
      </Tab>

      <Tab title=".NET Tool (Global Install)">
        If you have [.NET Core](https://dotnet.microsoft.com/en-us/download) installed, you can install win-acme as a global tool:

        ```powershell  theme={"dark"}
        dotnet tool install win-acme --global
        ```

        This makes the `wacs` command available system-wide.
      </Tab>
    </Tabs>
  </Step>

  <Step title="Request Certificate Using Command Line">
    Run the following win-acme command to request a certificate from Infisical:

    ```powershell  theme={"dark"}
    wacs.exe --target manual --host example.infisical.com --baseuri "https://your-infisical-instance.com/api/v1/pki/certificate-profiles/{profile-id}/acme/directory" --eab-key-identifier "your-eab-key-identifier" --eab-key "your-eab-secret" --validation selfhosting --store pemfiles --pemfilespath "C:\certificates" --verbose
    ```

    For guidance on each parameter:

    * `--target manual`: Specifies manual target configuration for domain specification.
    * `--host`: The domain name for which the certificate is being requested.
    * `--baseuri`: The Infisical ACME directory URL from Step 1. This instructs win-acme to communicate with Infisical's ACME server instead of other ACME providers.
    * `--eab-key-identifier`: Your External Account Binding (EAB) Key Identifier from Step 1.
    * `--eab-key`: The EAB secret associated with the KID from Step 1.
    * `--validation selfhosting`: Uses self-hosting validation method to solve the [HTTP-01](https://letsencrypt.org/docs/challenge-types/#http-01-challenge) challenge.
    * `--store pemfiles`: Stores certificates as PEM files in a specified directory.
    * `--pemfilespath`: Directory where certificates will be saved on your Windows Server.
    * `--verbose`: Enables detailed logging for troubleshooting and monitoring the certificate request process.

    The win-acme command generates a private key on your server, creates a Certificate Signing Request (CSR) using that key, and sends the CSR to Infisical for certificate issuance. Win-acme stores the private key and resulting leaf certificate and full certificate chain in the specified directory path.

    <Note>
      Replace the placeholder values with your actual configuration:

      * `example.infisical.com`: Your actual domain name
      * `https://your-infisical-instance.com/api/v1/pki/certificate-profiles/{profile-id}/acme/directory`: Your Infisical ACME endpoint from Step 1
      * `your-eab-key-identifier` and `your-eab-secret`: Your External Account Binding credentials from Step 1
      * `C:\certificates`: Your desired certificate storage location
    </Note>
  </Step>

  <Step title="Alternative Storage Options">
    Win-acme supports various certificate storage options beyond PEM files. Here are common alternatives for different deployment scenarios:

    <Tabs>
      <Tab title="Windows Certificate Store">
        Store certificates directly in the [Windows Certificate Store](https://docs.microsoft.com/en-us/windows-hardware/drivers/install/certificate-stores) for integration with IIS and other Windows services:

        ```powershell  theme={"dark"}
        wacs.exe --target manual --host example.infisical.com --baseuri "https://your-infisical-instance.com/api/v1/pki/certificate-profiles/{profile-id}/acme/directory" --eab-key-identifier "your-eab-key-identifier" --eab-key "your-eab-secret" --validation selfhosting --store certificatestore --verbose
        ```
      </Tab>

      <Tab title="PFX Files">
        Generate [PFX files](https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/certutil) with password protection for easy deployment across Windows environments:

        ```powershell  theme={"dark"}
        wacs.exe --target manual --host example.infisical.com --baseuri "https://your-infisical-instance.com/api/v1/pki/certificate-profiles/{profile-id}/acme/directory" --eab-key-identifier "your-eab-key-identifier" --eab-key "your-eab-secret" --validation selfhosting --store pfxfile --pfxfilepath "C:\certificates" --pfxpassword "your-secure-password" --verbose
        ```
      </Tab>

      <Tab title="IIS Central SSL">
        For IIS Central SSL store integration in high-scale environments:

        ```powershell  theme={"dark"}
        wacs.exe --target manual --host example.infisical.com --baseuri "https://your-infisical-instance.com/api/v1/pki/certificate-profiles/{profile-id}/acme/directory" --eab-key-identifier "your-eab-key-identifier" --eab-key "your-eab-secret" --validation selfhosting --store centralssl --centralsslstore "C:\CentralSSL" --verbose
        ```
      </Tab>
    </Tabs>
  </Step>

  <Step title="Configure Automatic Renewal">
    Win-acme can automatically create a [Windows Scheduled Task](https://docs.microsoft.com/en-us/windows/win32/taskschd/about-the-task-scheduler) for certificate renewal. Because win-acme stores the ACME server URL and EAB credentials from your initial request, renewal will automatically use the same Infisical ACME configurationno additional settings are required.

    **Option 1: Enable during initial certificate request**

    Include the `--setuptaskscheduler` parameter in your initial command to automatically create the renewal task:

    ```powershell  theme={"dark"}
    wacs.exe --target manual --host example.infisical.com --baseuri "https://your-infisical-instance.com/api/v1/pki/certificate-profiles/{profile-id}/acme/directory" --eab-key-identifier "your-eab-key-identifier" --eab-key "your-eab-secret" --validation selfhosting --store pemfiles --pemfilespath "C:\certificates" --setuptaskscheduler --verbose
    ```

    **Option 2: Test manual renewal**

    You can test the renewal process manually before setting up automation to ensure the configuration works correctly:

    ```powershell  theme={"dark"}
    wacs.exe --renew --force --verbose
    ```

    This command simulates the full renewal process and verifies that win-acme can successfully contact Infisical and renew your certificate using the stored configuration.

    **Option 3: Verify scheduled task creation**

    Check that the scheduled task was created successfully:

    ```powershell  theme={"dark"}
    Get-ScheduledTask -TaskName "*win-acme*"
    ```

    The automatic renewal task will:

    * Run under the SYSTEM account for elevated privileges.
    * Check certificates daily for renewal eligibility.
    * Automatically renew certificates that are within the renewal threshold (typically 30 days before expiration).
    * Log renewal activities to Windows Event Viewer and win-acme log files for monitoring and troubleshooting.

    <Note>
      Win-acme stores renewal configurations automatically in its settings directory, so once a certificate is created, the renewal process will use the same parameters (ACME endpoint, EAB credentials, storage options) for future renewals. The renewal threshold can be adjusted in the win-acme configuration files if needed.
    </Note>
  </Step>

  <Step title="Verify Certificate Installation">
    After successful certificate issuance, verify that the certificate files have been created correctly based on your chosen storage method.

    <Tabs>
      <Tab title="PEM Files">
        Check your specified PEM files directory to ensure all certificate components are present:

        ```powershell  theme={"dark"}
        Get-ChildItem "C:\certificates" -Filter "*.pem"
        ```

        You should see files like:

        * `example.infisical.com-crt.pem` (certificate)
        * `example.infisical.com-key.pem` (private key)
        * `example.infisical.com-chain.pem` (complete certificate chain)
        * `example.infisical.com-chain-only.pem` (only certificate chain)

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/pki/integrations/windows-server/certificates-created.png" alt="Windows Server Generated PEM files" />
      </Tab>

      <Tab title="Windows Certificate Store">
        If you used the certificate store option, check that the certificate was properly installed using PowerShell:

        ```powershell  theme={"dark"}
        Get-ChildItem -Path Cert:\LocalMachine\My | Where-Object {$_.Subject -like "*example.infisical.com*"}
        ```

        The certificate should appear in the [Local Computer Personal certificate store](https://docs.microsoft.com/en-us/dotnet/framework/wcf/feature-details/working-with-certificates#certificate-stores), making it available for use with IIS, other Windows services, and applications that integrate with the Windows Certificate Store.
      </Tab>
    </Tabs>
  </Step>
</Steps>


# Certificate Management
Source: https://infisical.com/docs/documentation/platform/pki/overview

Manage Certificate Authorities and automate X.509 certificate lifecycle management.

Infisical can be used to create and manage Certificate Authorities (CAs) and issue digital X.509 certificates. This allows you to manage PKI infrastructure and issue certificates for end-entities such as load balancers, web servers, devices, and more.

It helps teams automate certificate management including enrollment and renewal, and adopt secure workflows to ensure certificates remain valid, trusted, and synchronized across infrastructure.

Core capabilities include:

* [Private CA](/documentation/platform/pki/ca/private-ca): Create and manage your own private CA hierarchy including root and intermediate CAs.
* [External CA integration](/documentation/platform/pki/ca/external-ca): Integrate with external public and private CAs including [Azure ADCS](/documentation/platform/pki/ca/azure-adcs) and [ACME-compatible CAs](/documentation/platform/pki/ca/acme-ca) like Let's Encrypt and DigiCert.
* [Certificate Enrollment](/documentation/platform/pki/enrollment-methods/overview): Support enrollment methods including [API](/documentation/platform/pki/enrollment-methods/api), [ACME](/documentation/platform/pki/enrollment-methods/acme), [EST](/documentation/platform/pki/enrollment-methods/est), and more to automate certificate issuance for services, devices, and workloads.
* Certificate Inventory: Track and monitor issued X.509 certificates, maintaining a comprehensive inventory of all active and expired certificates.
* Certificate Lifecycle Automation: Automate issuance, [renewal](/documentation/platform/pki/certificates/certificates#guide-to-renewing-certificates), and [revocation](/documentation/platform/pki/certificates/certificates#guide-to-revoking-certificates) with policy-based workflows, ensuring certificates remain valid, compliant, and up to date across your infrastructure.
* [Certificate Syncs](/documentation/platform/pki/certificate-syncs/overview): Push certificates to cloud certificate managers like [AWS Certificate Manager](/documentation/platform/pki/certificate-syncs/aws-certificate-manager) and [Azure Key Vault](/documentation/platform/pki/certificate-syncs/azure-key-vault).
* [Certificate Alerts](/documentation/platform/pki/alerting): Receive alerts and webhook events for certificate lifecycle changes such as certificate expiration.


# Kubernetes Issuer
Source: https://infisical.com/docs/documentation/platform/pki/pki-issuer

Learn how to automatically provision and manage TLS certificates in Kubernetes using Infisical PKI

## Concept

The Infisical PKI Issuer is an installable Kubernetes [cert-manager](https://cert-manager.io/) controller that uses Infisical PKI to sign certificate requests. The issuer is perfect for getting X.509 certificates for ingresses and other Kubernetes resources and capable of automatically renewing certificates as needed.

As part of the workflow, you install `cert-manager`, the Infisical PKI Issuer, and configure resources to represent the connection details to your Infisical PKI and the certificates you wish to issue. Each issued certificate and corresponding private key is made available in a Kubernetes secret.

We recommend reading the [cert-manager documentation](https://cert-manager.io/docs/) for a fuller understanding of all the moving parts.

## Workflow

A typical workflow for using the Infisical PKI Issuer to issue certificates for your Kubernetes resources consists of the following steps:

1. Creating a machine identity in Infisical.
2. Creating a Kubernetes secret to store the credentials of the machine identity.
3. Installing `cert-manager` into your Kubernetes cluster.
4. Installing the Infisical PKI Issuer controller into your Kubernetes cluster.
5. Creating an `Issuer` or `ClusterIssuer` resource in your Kubernetes cluster to represent the Infisical PKI issuer you wish to use.
6. Create the approver policy to accept certificate request.
7. Creating a `Certificate` resource in your Kubernetes cluster to represent a certificate you wish to issue. As part of this step, you specify the Kubernetes `Secret` to create and store the issued certificate and private key.
8. Consuming the issued certificate across your Kubernetes resources from the specified Kubernetes `Secret`.

## Guide

In the following steps, we explore how to install the Infisical PKI Issuer using [kubectl](https://github.com/kubernetes/kubectl) and use it to obtain certificates for your Kubernetes resources.

<Steps>
  <Step title="Create an identity in Infisical">
    Follow the instructions [here](/documentation/platform/identities/universal-auth) to configure a [machine identity](/documentation/platform/identities/machine-identities) in Infisical with Universal Auth.

    By the end of this step, you should have a **Client ID** and **Client Secret** on hand as part of the Universal Auth configuration for the Infisical PKI Issuer to authenticate with Infisical; this will be useful in steps 4 and 5.

    <Note>
      Currently, the Infisical PKI Issuer only supports authenticating with Infisical via the [Universal Auth](/documentation/platform/identities/universal-auth) authentication method.

      We're planning to add support for [Kubernetes Auth](/documentation/platform/identities/kubernetes-auth) in the near future.
    </Note>
  </Step>

  <Step title="Install cert-manager">
    Install `cert-manager` into your Kubernetes cluster by following the instructions [here](https://cert-manager.io/docs/installation/) or by running the following command:

    ```bash  theme={"dark"}
    kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.15.3/cert-manager.yaml
    ```
  </Step>

  <Step title="Install the Issuer Controller">
    Install the Infisical PKI Issuer controller into your Kubernetes cluster using one of the following methods:

    <Tabs>
      <Tab title="Helm">
        ```bash  theme={"dark"}
        helm repo add infisical-helm-charts 'https://dl.cloudsmith.io/public/infisical/helm-charts/helm/charts/'
        helm install infisical-pki-issuer infisical-helm-charts/infisical-pki-issuer
        ```
      </Tab>

      <Tab title="kubectl">
        ```bash  theme={"dark"}
        kubectl apply -f https://raw.githubusercontent.com/Infisical/infisical-issuer/main/build/install.yaml
        ```
      </Tab>
    </Tabs>
  </Step>

  <Step title="Create Kubernetes Secret for Infisical PKI Issuer">
    Start by creating a Kubernetes `Secret` containing the **Client Secret** from step 1. As mentioned previously, this will be used by the Infisical PKI issuer to authenticate with Infisical.

    <Tabs>
      <Tab title="kubectl command">
        ```bash  theme={"dark"}
        kubectl create secret generic issuer-infisical-client-secret \
            --namespace <namespace_you_want_to_issue_certificates_in> \
            --from-literal=clientSecret=<client_secret>
        ```
      </Tab>

      <Tab title="Configuration file">
        ```yaml secret-issuer.yaml theme={"dark"}
        apiVersion: v1
        kind: Secret
        metadata:
            name: issuer-infisical-client-secret
            namespace: <namespace_you_want_to_issue_certificates_in>
        data:
            clientSecret: <client_secret>
        ```

        ```bash  theme={"dark"}
        kubectl apply -f secret-issuer.yaml
        ```
      </Tab>
    </Tabs>
  </Step>

  <Step title="Create Infisical PKI Issuer">
    Next, create the Infisical PKI Issuer by filling out `url`, `clientId`, `projectId` or `certificateTemplateName`, and applying the following configuration file for the `Issuer` resource.
    This configuration file specifies the connection details to your Infisical PKI CA to be used for issuing certificates.

    ```yaml infisical-issuer.yaml theme={"dark"}
    apiVersion: infisical-issuer.infisical.com/v1alpha1
    kind: Issuer
    metadata:
        name: issuer-infisical
        namespace: <namespace_you_want_to_issue_certificates_in>
    spec:
        url: "https://app.infisical.com" # the URL of your Infisical instance
        projectId: <project_id> # the ID of the project you want to use to issue certificates
        certificateTemplateName: <certificate_template_name> # the name of the certificate template you want to use to issue certificates against
        authentication:
            universalAuth:
                clientId: <client_id> # the Client ID from step 1
                secretRef: # reference to the Secret created in step 4
                    name: "issuer-infisical-client-secret"
                    key: "clientSecret"
    ```

    ```
    kubectl apply -f infisical-issuer.yaml
    ```

    You can check that the issuer was created successfully by running the following command:

    ```bash  theme={"dark"}
    kubectl get issuers.infisical-issuer.infisical.com -n <namespace_of_issuer> -o wide
    ```

    ```bash  theme={"dark"}
    NAME               AGE
    issuer-infisical   21h
    ```

    <Note>
      An `Issuer` is a namespaced resource, and it is not possible to issue certificates from an `Issuer` in a different namespace.
      This means you will need to create an `Issuer` in each namespace you wish to obtain `Certificates` in.

      If you want to create a single `Issuer` that can be consumed in multiple namespaces, you should consider creating a `ClusterIssuer` resource. This is almost identical to the `Issuer` resource, however is non-namespaced so it can be used to issue `Certificates` across all namespaces.

      You can read more about the `Issuer` and `ClusterIssuer` resources [here](https://cert-manager.io/docs/configuration/).
    </Note>
  </Step>

  <Step title="Create Approver Policy">
    If you create a `CertificateRequest` now, you'll notice it's neither approved nor denied. This is expected because by default cert-manager approver controller requires an approver-policy.

    To enable approval, create the following YAML file and apply it:

    ```yaml infisical-approver-policy.yaml theme={"dark"}
    apiVersion: rbac.authorization.k8s.io/v1
    kind: ClusterRole
    metadata:
     name: infisical-issuer-approver
    rules:
     # Permission to approve or deny CertificateRequests for signers in cert-manager.io API group
     - apiGroups: ['cert-manager.io']
       resources: ['signers']
       verbs: ['approve']
       resourceNames:
         # Grant approval permissions for namespaced issuers
         - "issuers.infisical-issuer.infisical.com/default.issuer-infisical"
         # Grant approval permissions for cluster-scoped issuers
         - "clusterissuers.infisical-issuer.infisical.com/clusterissuer-infisical"
    ---
    # Bind the cert-manager service account to the new role
    apiVersion: rbac.authorization.k8s.io/v1
    kind: ClusterRoleBinding
    metadata:
     name: infisical-issuer-approver-binding
    subjects:
     - kind: ServiceAccount
       name: cert-manager
       namespace: cert-manager
    roleRef:
     apiGroup: rbac.authorization.k8s.io
     kind: ClusterRole
     name: infisical-issuer-approver
    ```

    ```
    kubectl apply -f infisical-approver-policy.yaml
    ```

    This configuration creates a `ClusterRole` named `infisical-issuer-approver` that grants approval permissions for specific Infisical issuer types. It then binds this role to the cert-manager service account, allowing it to approve certificate requests from your Infisical issuers.

    For information, check out [cert manager approval policy doc](https://cert-manager.io/docs/policy/approval/approver-policy/).
  </Step>

  <Step title="Create Certificate">
    Finally, create a `Certificate` by applying the following configuration file.
    This configuration file specifies the details of the (end-entity/leaf) certificate to be issued.

    ```yaml certificate-issuer.yaml theme={"dark"}
    apiVersion: cert-manager.io/v1
    kind: Certificate
    metadata:
        name: certificate-by-issuer
        namespace: <namespace_you_want_to_issue_certificates_in>
    spec:
        commonName: certificate-by-issuer.example.com # the common name for the certificate
        secretName: certificate-by-issuer # the name of the Kubernetes Secret to create and store the certificate and private key in
        issuerRef:
            name: issuer-infisical
            group: infisical-issuer.infisical.com
            kind: Issuer
        privateKey: # the algorithm and key size to use
            algorithm: ECDSA
            size: 256
        duration: 48h # the ttl for the certificate
        renewBefore: 12h # the time before the certificate expiry that the certificate should be automatically renewed
    ```

    The above sample configuration file specifies a certificate to be issued with the common name `certificate-by-issuer.example.com` and ECDSA private key using the P-256 curve, valid for 48 hours; the certificate will be automatically renewed by `cert-manager` 12 hours before expiry.
    The certificate is issued by the issuer `issuer-infisical` created in the previous step and the resulting certificate and private key will be stored in a secret named `certificate-by-issuer`.

    Note that the full list of the fields supported on the `Certificate` resource can be found in the API reference documentation [here](https://cert-manager.io/docs/reference/api-docs/#cert-manager.io/v1.CertificateSpec).

    You can check that the certificate was created successfully by running the following command:

    ```bash  theme={"dark"}
    kubectl get certificates -n <namespace_of_your_certificate> -o wide
    ```

    ```bash  theme={"dark"}
    NAME                    READY   SECRET                  ISSUER             STATUS                                          AGE
    certificate-by-issuer   True    certificate-by-issuer   issuer-infisical   Certificate is up to date and has not expired   20h
    ```
  </Step>

  <Step title="Use Certificate in Kubernetes Secret">
    Since the actual certificate and private key are stored in a Kubernetes secret, we can check that the secret was created successfully by running the following command:

    ```bash  theme={"dark"}
    kubectl get secret certificate-by-issuer -n <namespace_of_your_certificate>
    ```

    ```bash  theme={"dark"}
    NAME                    TYPE                DATA   AGE
    certificate-by-issuer   kubernetes.io/tls   2      26h
    ```

    We can `describe` the secret to get more information about it:

    ```bash  theme={"dark"}
    kubectl describe secret certificate-by-issuer -n default
    ```

    ```bash  theme={"dark"}
    Name:         certificate-by-issuer
    Namespace:    default
    Labels:       controller.cert-manager.io/fao=true
    Annotations:  cert-manager.io/alt-names:
                cert-manager.io/certificate-name: certificate-by-issuer
                cert-manager.io/common-name: certificate-by-issuer.example.com
                cert-manager.io/ip-sans:
                cert-manager.io/issuer-group: infisical-issuer.infisical.com
                cert-manager.io/issuer-kind: Issuer
                cert-manager.io/issuer-name: issuer-infisical
                cert-manager.io/uri-sans:

    Type:  kubernetes.io/tls

    Data
    ====
    ca.crt: 1306 bytes
    tls.crt: 2380 bytes
    tls.key:  227 bytes
    ```

    Here, `ca.crt` is the Root CA certificate, `tls.crt` is the requested certificate followed by the certificate chain, and `tls.key` is the private key for the certificate.

    We can decode the certificate and print it out using `openssl`:

    ```bash  theme={"dark"}
    kubectl get secret certificate-by-issuer -n default -o jsonpath='{.data.tls\.crt}' | base64 --decode | openssl x509 -text -noout
    ```

    In any case, the certificate is ready to be used as Kubernetes Secret by your Kubernetes resources.
  </Step>
</Steps>

## FAQ

<AccordionGroup>
  <Accordion title="What fields can be configured on the Certificate resource?">
    The full list of the fields supported on the `Certificate` resource can be found in the API reference documentation [here](https://cert-manager.io/docs/reference/api-docs/#cert-manager.io/v1.CertificateSpec).

    <Note>
      Currently, not all fields are supported by the Infisical PKI Issuer.
    </Note>
  </Accordion>

  <Accordion title="Can certificates be renewed automatically?">
    Yes. `cert-manager` will automatically renew certificates according to the `renewBefore` threshold of expiry as
    specified in the corresponding `Certificate` resource.

    You can read more about the `renewBefore` field [here](https://cert-manager.io/docs/reference/api-docs/#cert-manager.io/v1.CertificateSpec).
  </Accordion>

  <Accordion title="Why is my CertificateRequest not being approved, showing 'CertificateRequest has not been approved yet. Ignoring.'?">
    If you see log messages similar to:

    ```
    "CertificateRequest has not been approved yet. Ignoring.","controller":"certificaterequest","controllerGroup":"cert-manager.io","controllerKind":"CertificateRequest","CertificateRequest":{"name":"skynet-infisical-rta-rsa2048-1","namespace":"infisical-system"},"namespace":"infisical-system","name":"skynet-infisical-rta-rsa2048-1","reconcileID":"bfb7cad9-d867-45b5-b3a3-0139e731b7a6"}
    ```

    This indicates that the `CertificateRequest` has been created, but `cert-manager` has not yet approved it. This typically occurs because a necessary approver policy is missing. Refer to the documentation above to create an approver policy.
  </Accordion>
</AccordionGroup>


# Approval Workflows
Source: https://infisical.com/docs/documentation/platform/pr-workflows

Learn how to enable a set of policies to manage changes to sensitive secrets and environments.

<Info>
  Approval Workflows is a paid feature.

  If you're using Infisical Cloud, then it is available under the **Pro Tier** and **Enterprise Tier**.
  If you're self-hosting Infisical, then you should contact [sales@infisical.com](mailto:sales@infisical.com) to purchase an enterprise license to use it.
</Info>

## Problem at hand

Updating secrets in high-stakes environments (e.g., production) can have a number of problematic issues:

* Most developers should not have access to secrets in production environments. Yet, they are the ones who often need to add new secrets or change the existing ones. Many organizations have in-house policies with regards to what person should be contacted in the case of needing to make changes to secrets. This slows down software development lifecycle and distracts engineers from working on things that matter the most.
* As a general rule, before making changes in production environments, those changes have to be looked over by at least another person. An extra pair of eyes can help reduce the risk of human error and make sure that the change will not affect the application in an unintended way.
* After making updates to secrets, the corresponding applications need to be redeployed with the right set of secrets and configurations. This process is often not automated and hence prone to human error.

## Solution

As a wide-spread software engineering practice, developers have to submit their code as a PR that needs to be approved before the code is merged into the main branch.

In a similar way, to solve the above-mentioned issues, Infisical provides a feature called `Approval Workflows` for secret management. This is a set of policies and workflows that help advance access controls, compliance procedures, and stability of a particular environment. In other words, **Approval Workflows** help you secure, stabilize, and streamline the change of secrets in high-stakes environments.

### Setting a policy

First, you would need to create a set of policies for a certain environment. In the example below, a generic change policy for a production environment is shown. In this case, any user who submits a change to `prod` would first have to get an approval by a predefined approver (or multiple approvers).

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/pr-workflows/secret-update-policy.png" alt="create secret update policy" />

### Policy enforcement levels

The enforcement level determines how strict the policy is. A **Hard** enforcement level means that any change that matches the policy will need full approval prior merging. A **Soft** enforcement level allows for break glass functionality on the request. If a change request is bypassed, the approvers will be notified via email.

<Note>
  Enabling the "Bypass Approvals" toggle during policy creation will create a **Soft** enforcement level. Disabling the toggle makes the enforcement level **Hard**.
</Note>

If you choose to allow approval bypasses (Soft Enforcement), you may select specific users or groups that can perform the bypass for that specific policy. Not choosing users or groups will allow anyone to bypass the policy.

A policy bypasser cannot bypass requests from others; the bypass action can only be performed by the request creator.

### Self approvals

If the **Self Approvals** option is enabled, users who are designated as approvers on the policy can approve requests that they themselves have submitted.

### Example of creating a change policy

When creating a policy, you can choose the type of policy you want to create. In this case, we will be creating a `Change Policy`. Other types of policies include `Access Policy` that creates policies for **[Access Requests](/documentation/platform/access-controls/access-requests)**.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/pr-workflows/create-change-policy.png" alt="create panel secret update policy" />

### Example of updating secrets with Approval workflows

When a user submits a change to an environment that is under a particular policy, a corresponding change request will go to a predefined approver (or multiple approvers).

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/pr-workflows/secret-update-request.png" alt="secret update change requests" />

Approvers are notified by email and/or Slack as soon as the request is initiated. In the Infisical Dashboard, they will be able to `approve` and `merge` (or `deny`) a request for a change in a particular environment. After that, depending on the workflows setup, the change will be automatically propagated to the right applications (e.g., using [Infisical Kubernetes Operator](https://infisical.com/docs/integrations/platforms/kubernetes)).

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/pr-workflows/secret-update-pr.png" alt="secrets update pull request" />

## FAQ

<AccordionGroup>
  <Accordion title="Is it possible to disable self-approval for policies?">
    Yes, if you'd like to require an approval from an approver other than the one who created the request, then you can disable the **Self Approvals** feature inside of your target policy.
  </Accordion>
</AccordionGroup>


# Overview
Source: https://infisical.com/docs/documentation/platform/project

Learn more and understand the concept of Infisical projects.

## Projects

A project defines a specific scope of work for a given product line in Infisical.

Projects are created within an [organization](/documentation/platform/organization), and an organization can contain multiple projects across different product types.

## Project Types

Infisical supports project types, each representing a different security product with its own dashboard, workflows, and capabilities.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/project/project-types.png" alt="project types" />

The supported project types are:

* [Secrets Management](/documentation/platform/secrets-mgmt/overview): Securely store, access, and distribute secrets across environments with fine-grained controls, automatic rotation, and audit logging.
* [Secrets Scanning](/documentation/platform/secret-scanning/overview): Detect hardcoded secrets in code, CI pipelines, and infrastructureintegrated with GitHub, GitLab, Bitbucket, and more.
* [Infisical PKI](/documentation/platform/pki/overview): Issue and manage X.509 certificates using protocols like EST, with support for internal and external CAs.
* [Infisical SSH](/documentation/platform/ssh/overview): Provide short-lived SSH access to servers using certificate-based authentication, replacing static keys with policy-driven, time-bound control.
* [Infisical KMS](/documentation/platform/kms/overview): Encrypt and decrypt data using centrally managed keys with enforced access policies and full audit visibility.
* [Infisical PAM](/documentation/platform/pam/overview): Manage access to resources like databases, servers, and accounts with policy-based controls and approvals.

## Roles and Access Control

[Users](/documentation/platform/identities/user-identities) and [machine identities](/documentation/platform/identities/machine-identities) must be added to a project to access its resources. Each identity is assigned a [project-level role](/documentation/platform/access-controls/role-based-access-controls#project-level-access-controls) that defines what they can managesuch as secrets, certificates, or SSH access. These roles apply to both individuals and [user groups](/documentation/platform/groups), enabling scalable access across teams and environments.

Project access is strictly scoped: only members of a project can view or manage its resources. If someone needs access but isnt part of the project, they can submit an access request.

Each project in Infisical has its own [access control model](/documentation/platform/access-controls/role-based-access-controls#project-level-access-controls), distinct from [organization-level access control](/documentation/platform/access-controls/role-based-access-controls#organization-level-access-controls). While organization roles govern broader administrative access, project-level roles control what users, groups, and machine identities can do within the boundaries of a specific projectsuch as managing secrets, issuing certificates, or configuring SSH access.

Depending on the project type (e.g. Secrets Management, PKI, SSH), project-level access control supports advanced features like [temporary access](/documentation/platform/access-controls/temporary-access), [access requests](/documentation/platform/access-controls/access-requests), and [additional privileges](/documentation/platform/access-controls/additional-privileges).

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/project/project-roles.png" alt="project roles" />

To learn more about how permissions work in detail, refer to the [access control documentation](/documentation/platform/access-controls/overview).

## Audit Logs

Infisical provides [audit logging](/documentation/platform/audit-logs) at the project level to help teams monitor activity and maintain accountability within a specific project. These logs capture all relevant eventssuch as secret access, certificate issuance, and SSH activitythat occur within the boundaries of that project.

Unlike the organization-level audit view, which aggregates logs across all projects in one centralized interface, the project-level audit view is scoped to a single project. This enables relevant project admins and contributors to review activity relevant to their work without having broader access to audit logs in other projects that they are not part of.

## Project Settings

Each project has its own settings panel, with options that vary depending on the selected product type. These may include
setup and configuration for environments, tags, behaviors, encryption strategies, and other options.

Project settings are fully independent and reflect the capabilities of the associated product.


# Project Templates
Source: https://infisical.com/docs/documentation/platform/project-templates

Learn how to manage and apply project templates

## Concept

Project Templates streamline your ability to set up projects by providing customizable templates to configure projects quickly with a predefined set of environments and roles.

<Note>
  Project Templates is a paid feature.
  If you're using Infisical Cloud, then it is available under the **Enterprise Tier**. If you're self-hosting Infisical,
  then you should contact [team@infisical.com](mailto:team@infisical.com) to purchase an enterprise license to use it.
</Note>

## Workflow

The typical workflow for using Project Templates consists of the following steps:

1. <strong>Creating a project template:</strong> As part of this step, you will configure a set of environments and roles to be created when applying this template to a project.
2. <strong>Using a project template:</strong> When creating new projects, optionally specify a project template to provision the project with the configured roles and environments.

<Note>
  Note that this workflow can be executed via the Infisical UI or through the API.
</Note>

## Guide to Creating a Project Template

In the following steps, we'll explore how to set up a project template.

<Tabs>
  <Tab title="Infisical UI">
    <Steps>
      <Step title="Creating a Project Template">
        Navigate to the **Project Templates** tab on the Feature Settings page for the project type you want to create a template for and tap on the **Add Template** button.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/project-templates/project-template-add-button.png" alt="project template add button" />

        Specify your template details. Here's some guidance on each field:

        * <strong>Name:</strong> A slug-friendly name for the template.
        * <strong>Description:</strong> An optional description of the intended usage of this template.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/project-templates/project-template-create.png" alt="project template create modal" />
      </Step>

      <Step title="Configuring a Project Template">
        Once your template is created, you'll be directed to the configuration section.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/project-templates/project-template-edit-form.png" alt="project template edit form" />

        Customize the environments and roles to your needs.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/project-templates/project-template-customized.png" alt="project template customized" />

        <Note>
          Be sure to save your environment and role changes.
        </Note>
      </Step>
    </Steps>
  </Tab>

  <Tab title="API">
    To create a project template, make an API request to the [Create Project Template](/api-reference/endpoints/project-templates/create) API endpoint.

    ### Sample request

    ```bash Request theme={"dark"}
    curl --request POST \
    --url https://app.infisical.com/api/v1/project-templates \
    --header 'Content-Type: application/json' \
    --data '{
        "name": "my-project-template",
        "type": "secret-manager",
        "description": "...",
        "environments": "[...]",
        "roles": "[...]",
    }'
    ```

    ### Sample response

    ```bash Response theme={"dark"}
    {
        "projectTemplate": {
            "id": "<template-id>",
            "name": "my-project-template",
            "description": "...",
            "environments": "[...]",
            "roles": "[...]",
            "orgId": "<org-id>",
            "createdAt": "2023-11-07T05:31:56Z",
            "updatedAt": "2023-11-07T05:31:56Z",
        }
    }
    ```
  </Tab>
</Tabs>

## Guide to Using a Project Template

In the following steps, we'll explore how to use a project template when creating a project.

<Tabs>
  <Tab title="Infisical UI">
    When creating a new project, select the desired template from the dropdown menu in the create project modal.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/project-templates/project-template-apply.png" alt="kms key options" />

    Your project will be provisioned with the configured template roles and environments.
  </Tab>

  <Tab title="API">
    To use a project template, make an API request to the [Create Project](/api-reference/endpoints/projects/create-project) API endpoint with the specified template name included.

    ### Sample request

    ```bash Request theme={"dark"}
    curl --request POST \
    --url https://app.infisical.com/api/v1/projects \
    --header 'Authorization: Bearer <token>' \
    --header 'Content-Type: application/json' \
    --data '{
        "projectName": "My Project",
        "template": "<template-name>", // defaults to "default"
    }'
    ```

    ### Sample response

    ```bash Response theme={"dark"}
    {
        "project": {
            "id": "<project-id>",
            "environments": "[...]", // configured environments
            ...
        }
    }
    ```

    <Note>
      Note that configured roles are not included in the project response.
    </Note>
  </Tab>
</Tabs>

## FAQ

<AccordionGroup>
  <Accordion title="Do changes to templates propagate to existing projects?">
    No. Project templates only apply at the time of project creation.
  </Accordion>
</AccordionGroup>


# Azure SCIM
Source: https://infisical.com/docs/documentation/platform/scim/azure

Learn how to configure SCIM provisioning with Azure for Infisical.

<Info>
  Azure SCIM provisioning is a paid feature.

  If you're using Infisical Cloud, then it is available under the **Enterprise Tier**. If you're self-hosting Infisical,
  then you should contact [sales@infisical.com](mailto:sales@infisical.com) to purchase an enterprise license to use it.
</Info>

Prerequisites:

* [Configure Azure SAML for Infisical](/documentation/platform/sso/azure)

<Steps>
  <Step title="Create a SCIM token in Infisical">
    In Infisical, head to the **Single Sign-On (SSO)** page and select the **Provisioning** tab. Under SCIM Configuration,
    press the **Enable SCIM provisioning** toggle to allow Azure to provision/deprovision users for your organization.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/scim/scim-enable-provisioning.png" alt="SCIM enable provisioning" />

    Next, press **Manage SCIM Tokens** and then **Create** to generate a SCIM token for Azure.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/scim/scim-create-token.png" alt="SCIM create token" />

    Next, copy the **SCIM URL** and **New SCIM Token** to use when configuring SCIM in Azure.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/scim/scim-copy-token.png" alt="SCIM copy token" />
  </Step>

  <Step title="Add Users and Groups in Azure">
    In Azure, navigate to Enterprise Application > Users and Groups. Add any users and/or groups to your application that you would like
    to be provisioned over to Infisical.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/scim/azure/scim-azure-add-users-and-groups.png" alt="SCIM Azure Users and Groups" />
  </Step>

  <Step title="Configure SCIM in Azure">
    In Azure, head to your Enterprise Application > Provisioning > Overview and press **Get started**.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/scim/azure/scim-azure-get-started.png" alt="SCIM Azure" />

    Next, set the following fields:

    * Provisioning Mode: Select **Automatic**.
    * Tenant URL: Input **SCIM URL** from Step 1.
    * Secret Token: Input the **New SCIM Token** from Step 1.

    Afterwards, click **Enable SCIM** and press the **Test Connection** button to check that SCIM is configured properly.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/scim/azure/scim-azure-config.png" alt="SCIM Azure" />

    After you hit **Save**, select **Provision Microsoft Entra ID Users** under the **Mappings** subsection.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/scim/azure/scim-azure-select-user-mappings.png" alt="SCIM Azure" />

    Next, adjust the mappings so you have them configured as below:

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/scim/azure/scim-azure-user-mappings.png" alt="SCIM Azure" />

    Finally, head to your Enterprise Application > Provisioning and set the **Provisioning Status** to **On**.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/scim/azure/scim-azure-provisioning-status.png" alt="SCIM Azure" />

    Alternatively, you can go to **Overview** and press **Start provisioning** to have Azure start provisioning/deprovisioning users to Infisical.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/scim/azure/scim-azure-start-provisioning.png" alt="SCIM Azure" />

    Now Azure can provision/deprovision users to/from your organization in Infisical.
  </Step>
</Steps>

**FAQ**

<AccordionGroup>
  <Accordion title="Why do SCIM-provisioned users have to finish setting up their account?">
    Infisical's SCIM implmentation accounts for retaining the end-to-end encrypted architecture of Infisical because we decouple the **authentication** and **decryption** steps in the platform.

    For this reason, SCIM-provisioned users are initialized but must finish setting up their account when logging in the first time by creating a master encryption/decryption key. With this implementation, IdPs and SCIM providers cannot and will not have access to the decryption key needed to decrypt your secrets.
  </Accordion>
</AccordionGroup>


# SCIM Group Mappings
Source: https://infisical.com/docs/documentation/platform/scim/group-mappings

Learn how to enhance your SCIM implementation using group mappings

<Info>
  SCIM provisioning, and by extension group mapping, is a paid feature.

  If you're using Infisical Cloud, then it is available under the **Enterprise Tier**. If you're self-hosting Infisical,
  then you should contact [sales@infisical.com](mailto:sales@infisical.com) to purchase an enterprise license to use it.
</Info>

## SCIM Group to Organization Role Mapping

By default, when users are provisioned via SCIM, they will be assigned the default organization role configured in [Organization General Settings](/documentation/platform/organization#settings).

For more precise control over membership roles, you can set up SCIM Group to Organization Role Mappings. This enables you to assign specific roles based on the group from which a user is provisioned.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/scim/scim-group-mapping.png" alt="SCIM Group Mapping" />

To configure a mapping, simply enter the SCIM group's name and select the role you would like users to be assigned from this group. Be sure
to tap **Update Mappings** once complete.

<Note>
  SCIM Group Mappings only apply when users are first provisioned. Previously provisioned users will not be affected, allowing you to customize user roles after they are added.
</Note>


# JumpCloud SCIM
Source: https://infisical.com/docs/documentation/platform/scim/jumpcloud

Learn how to configure SCIM provisioning with JumpCloud for Infisical.

<Info>
  JumpCloud SCIM provisioning is a paid feature.

  If you're using Infisical Cloud, then it is available under the **Enterprise Tier**. If you're self-hosting Infisical,
  then you should contact [sales@infisical.com](mailto:sales@infisical.com) to purchase an enterprise license to use it.
</Info>

Prerequisites:

* [Configure JumpCloud SAML for Infisical](/documentation/platform/sso/jumpcloud)

<Steps>
  <Step title="Create a SCIM token in Infisical">
    In Infisical, head to the **Single Sign-On (SSO)** page and select the **Provisioning** tab. Under SCIM Configuration,
    press the **Enable SCIM provisioning** toggle to allow JumpCloud to provision/deprovision users and user groups for your organization.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/scim/scim-enable-provisioning.png" alt="SCIM enable provisioning" />

    Next, press **Manage SCIM Tokens** and then **Create** to generate a SCIM token for JumpCloud.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/scim/scim-create-token.png" alt="SCIM create token" />

    Next, copy the **SCIM URL** and **New SCIM Token** to use when configuring SCIM in JumpCloud.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/scim/scim-copy-token.png" alt="SCIM copy token" />
  </Step>

  <Step title="Configure SCIM in JumpCloud">
    In JumpCloud, head to your Application > Identity Management > Configuration settings and make sure that
    **API Type** is set to **SCIM API** and **SCIM Version** is set to **SCIM 2.0**.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/scim/jumpcloud/scim-jumpcloud-api-type.png" alt="SCIM JumpCloud" />

    Next, set the following SCIM connection fields:

    * Base URL: Input the **SCIM URL** from Step 1.
    * Token Key: Input the **New SCIM Token** from Step 1.
    * Test User Email: Input a test user email to be used by JumpCloud for testing the SCIM connection.

    Alos, under HTTP Header > Authorization: Bearer, input the **New SCIM Token** from Step 1.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/scim/jumpcloud/scim-jumpcloud-config.png" alt="SCIM JumpCloud" />

    Next, press **Test Connection** to check that SCIM is configured properly. Finally, press **Activate**
    to have JumpCloud start provisioning/deprovisioning users to Infisical.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/scim/jumpcloud/scim-jumpcloud-test-connection.png" alt="SCIM JumpCloud" />

    Now JumpCloud can provision/deprovision users and user groups to/from your organization in Infisical.
  </Step>
</Steps>

**FAQ**

<AccordionGroup>
  <Accordion title="Why do SCIM-provisioned users have to finish setting up their account?">
    Infisical's SCIM implmentation accounts for retaining the end-to-end encrypted architecture of Infisical because we decouple the **authentication** and **decryption** steps in the platform.

    For this reason, SCIM-provisioned users are initialized but must finish setting up their account when logging in the first time by creating a master encryption/decryption key. With this implementation, IdPs and SCIM providers cannot and will not have access to the decryption key needed to decrypt your secrets.
  </Accordion>
</AccordionGroup>


# Okta SCIM
Source: https://infisical.com/docs/documentation/platform/scim/okta

Learn how to configure SCIM provisioning with Okta for Infisical.

<Info>
  Okta SCIM provisioning is a paid feature.

  If you're using Infisical Cloud, then it is available under the **Enterprise Tier**. If you're self-hosting Infisical,
  then you should contact [sales@infisical.com](mailto:sales@infisical.com) to purchase an enterprise license to use it.
</Info>

Prerequisites:

* [Configure Okta SAML for Infisical](/documentation/platform/sso/okta)

<Steps>
  <Step title="Create a SCIM token in Infisical">
    In Infisical, head to the **Single Sign-On (SSO)** page and select the **Provisioning** tab. Under SCIM Configuration,
    press the **Enable SCIM provisioning** toggle to allow Okta to provision/deprovision users and user groups for your organization.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/scim/scim-enable-provisioning.png" alt="SCIM enable provisioning" />

    Next, press **Manage SCIM Tokens** and then **Create** to generate a SCIM token for Okta.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/scim/scim-create-token.png" alt="SCIM create token" />

    Next, copy the **SCIM URL** and **New SCIM Token** to use when configuring SCIM in Okta.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/scim/scim-copy-token.png" alt="SCIM copy token" />
  </Step>

  <Step title="Configure SCIM in Okta">
    In Okta, head to your Application > General > App Settings. Next, select **Edit** and check the box
    labled **Enable SCIM provisioning**.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/scim/okta/scim-okta-enable-provisioning.png" alt="SCIM Okta" />

    Next, head to Provisioning > Integration and set the following SCIM connection fields:

    * SCIM connector base URL: Input the **SCIM URL** from Step 1.
    * Unique identifier field for users: Input `email`.
    * Supported provisioning actions: Select **Push New Users**, **Push Profile Updates**, and **Push Groups**.
    * Authentication Mode: `HTTP Header`.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/scim/okta/scim-okta-config.png" alt="SCIM Okta" />

    Under HTTP Header > Authorization: Bearer, input the **New SCIM Token** from Step 1.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/scim/okta/scim-okta-auth.png" alt="SCIM Okta" />

    Next, press **Test Connector Configuration** to check that SCIM is configured properly.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/scim/okta/scim-okta-test.png" alt="SCIM Okta" />

    Next, head to Provisioning > To App and check the boxes labeled **Enable** for **Create Users**, **Update User Attributes**, and **Deactivate Users**.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/scim/okta/scim-okta-app-settings.png" alt="SCIM Okta" />

    Now Okta can provision/deprovision users and user groups to/from your organization in Infisical.
  </Step>
</Steps>

**FAQ**

<AccordionGroup>
  <Accordion title="Why do SCIM-provisioned users have to finish setting up their account?">
    Infisical's SCIM implmentation accounts for retaining the end-to-end encrypted architecture of Infisical because we decouple the **authentication** and **decryption** steps in the platform.

    For this reason, SCIM-provisioned users are initialized but must finish setting up their account when logging in the first time by creating a master encryption/decryption key. With this implementation, IdPs and SCIM providers cannot and will not have access to the decryption key needed to decrypt your secrets.
  </Accordion>
</AccordionGroup>


# SCIM Overview
Source: https://infisical.com/docs/documentation/platform/scim/overview

Learn how to provision users for Infisical via SCIM.

<Note>
  SCIM provisioning can only be enabled when either SAML or OIDC is setup for
  the organization.
</Note>

<Info>
  SCIM provisioning is a paid feature. If you're using Infisical Cloud, then it
  is available under the **Enterprise Tier**. If you're self-hosting Infisical,
  then you should contact [sales@infisical.com](mailto:sales@infisical.com) to purchase an enterprise license
  to use it.
</Info>

You can configure your organization in Infisical to have users and user groups be provisioned/deprovisioned using [SCIM](https://scim.cloud/#Implementations2) via providers like Okta, Azure, JumpCloud, etc.

* Provisioning: The SCIM provider pushes user information to Infisical. If the user exists in Infisical, Infisical sends an email invitation to add them to the relevant organization in Infisical; if not, Infisical initializes a new user and sends them an email invitation to finish setting up their account in the organization.
* Deprovisioning: The SCIM provider instructs Infisical to remove user(s) from an organization in Infisical.

SCIM providers:

* [Okta SCIM](/documentation/platform/scim/okta)
* [Azure SCIM](/documentation/platform/scim/azure)
* [JumpCloud SCIM](/documentation/platform/scim/jumpcloud)
* [PingOne SCIM](/documentation/platform/scim/pingone)


# PingOne SCIM
Source: https://infisical.com/docs/documentation/platform/scim/pingone

Learn how to configure SCIM provisioning with PingOne for Infisical.

<Info>
  PingOne SCIM provisioning is a paid feature.

  If you're using Infisical Cloud, then it is available under the **Enterprise Tier**. If you're self-hosting Infisical,
  then you should contact [sales@infisical.com](mailto:sales@infisical.com) to purchase a self-hosted license to use it.
</Info>

Prerequisites:

* [Configure PingOne OIDC for Infisical](/documentation/platform/sso/pingone-oidc)

<Steps>
  <Step title="Create a SCIM token in Infisical">
    In Infisical, head to the **Single Sign-On (SSO)** page and select the **Provisioning** tab. Under SCIM Configuration,
    press the **Enable SCIM provisioning** toggle to allow PingOne to provision/deprovision users for your organization.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/scim/scim-enable-provisioning.png" alt="SCIM enable provisioning" />

    Next, press **Manage SCIM Tokens** and then **Create** to generate a SCIM token for PingOne.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/scim/scim-create-token.png" alt="SCIM create token" />

    Next, copy the **SCIM URL** and **New SCIM Token** to use when configuring SCIM in PingOne.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/scim/scim-copy-token.png" alt="SCIM copy token" />
  </Step>

  <Step title="Add Users and Groups in PingOne">
    Inside your PingOne environment, navigate to Directory > Users. Add any users and/or groups to your application that you would like
    to be provisioned over to Infisical.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/scim/pingone/pingone-create-user.png" alt="SCIM PingOne Users and Groups" />
  </Step>

  <Step title="Configure SCIM Connection in PingOne">
    **1. Create a new connection**

    In PingOne, head to Integrations > Provisioning, and inside provisioning, press the **Connections** tab. Here you'll see a plus icon to add a new connection.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/scim/pingone/pingone-new-connection.png" alt="SCIM PingOne Connections" />

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/scim/pingone/pingone-new-connection-identity-store.png" alt="SCIM PingOne Connections" />

    Select the "Identity Store" option.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/scim/pingone/pingone-connection-select-scim-outbound.png" alt="SCIM PingOne SCIM Outbound" />

    Search for the "SCIM Outbound" option to start the configuration process for SCIM. Finally, press the **Next** button. Give the connection a name and optionally add a description.

    **2. Configure the connection**

    Once you have selected the SCIM Outbound option, you'll be prompted to enter the authentication details that PingOne will use to authenticate with Infisical SCIM. This is the **SCIM URL** and **New SCIM Token** from the previous step.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/scim/pingone/pingone-connection-auth.png" alt="SCIM PingOne SCIM Outbound" />

    Set the following fields:

    * `SCIM BASE URL`: Input the **SCIM URL** from the previous step.
    * `Users Resource`: Leave as default, `/Users`.
    * `Groups Resource`: Leave as default, `/Groups`.
    * `SCIM Version`: Leave as default, `2.0`.
    * `Authentication Method`: Select `OAuth 2 Bearer Token`.
    * `Oauth Access Token`: Input the **New SCIM Token** from step 1.
    * `Auth Type Header`: Select `Bearer`.

    Once this is done, you can press the **Test Connection** button to check that SCIM is configured properly. You should see a success message saying "Connection Successful".
    If the connection is successful, press the "Next" button.

    In the final step, you'll be prompted to configure the mappings for the connection.

    Set the following fields:

    * `User Filter Expression`: `email.value Eq "%s"`.
    * `User Identifier`: `workEmail`.
    * `Deprovision on Rule Deletion:` Enabled.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/scim/pingone/pingone-connection-preferences.png" alt="SCIM PingOne Connection Mappings" />

    Once this is configured, press the "Save" button.

    **3. Enable the connection**

    Finally, remember to enable the connection by pressing the enable toggle.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/scim/pingone/pingone-connection-enable.png" alt="SCIM PingOne Connection Enable" />
  </Step>

  <Step title="Configure SCIM Provisioning in PingOne">
    **1. Create a new rule**

    After creating a connection, you can now access the "Rules" tab under the Provisioning section. Here you can configure the rules for the connection.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/scim/pingone/pingone-new-rule-1.png" alt="SCIM PingOne Create New Rule 1" />

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/scim/pingone/pingone-new-rule-2.png" alt="SCIM PingOne Create New Rule 2" />

    Select the "New Rule" button and choose a name for the rule, then press the "Create Rule" button.

    **2. Configure the rule connection**

    Once you have created a rule, you now need to configure the connection to use for the rule.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/scim/pingone/pingone-rule-select-connection.png" alt="SCIM PingOne Create New Rule 3" />

    Select the connection you created in the previous step and press the "Save" button.

    **3. Configure the rule user filter**

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/scim/pingone/pingone-rule-select-user-filter.png" alt="SCIM PingOne Create New Rule 4" />

    Select the Edit pencil icon to open the user filter configuration. This step dictates which users will be provisioned to Infisical.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/scim/pingone/pingone-rule-user-filter.png" alt="SCIM PingOne Create New Rule 5" />

    In this case, we are provisioning all users that are enabled in PingOne. Configure your user filter to match your desired users, and then press the "Save" button.

    **4. Configure Groups**

    This step is optional and only relevant if you want to provision PingOne groups to Infisical.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/scim/pingone/pingone-rule-group-provisioning-tab.png" alt="SCIM PingOne Create New Rule 6" />

    Open the "Group Provisioning" tab and press the "Add Groups" button to select which groups will be provisioned to Infisical.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/scim/pingone/pingone-select-group.png" alt="SCIM PingOne Create New Rule 7" />

    Select the groups you want to provision to Infisical and press the "Save" button.

    **5. Enable the rule**

    Once you have configured the rule, you can enable it by pressing the "Enable" toggle.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/scim/pingone/pingone-rule-enable.png" alt="SCIM PingOne Create New Rule 8" />
  </Step>
</Steps>

**FAQ**

<AccordionGroup>
  <Accordion title="Why do SCIM-provisioned users have to finish setting up their account?">
    Infisical's SCIM implementation accounts for retaining the end-to-end encrypted architecture of Infisical because we decouple the **authentication** and **decryption** steps in the platform.

    For this reason, SCIM-provisioned users are initialized but must finish setting up their account when logging in the first time by creating a master encryption/decryption key. With this implementation, IdPs and SCIM providers cannot and will not have access to the decryption key needed to decrypt your secrets.
  </Accordion>
</AccordionGroup>


# Secret Referencing and Importing
Source: https://infisical.com/docs/documentation/platform/secret-reference

Learn the fundamentals of secret referencing and importing in Infisical.

## Secret Referencing

Infisical's secret referencing functionality makes it possible to reference the value of a "base" secret when defining the value of another secret.
This means that updating the value of a base secret propagates directly to other secrets whose values depend on the base secret.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/secret-references-imports/secret-reference.png" alt="secret referencing" />

Since secret referencing reconstructs values on the client side, any client (user, service token, or machine identity) fetching secrets must have proper permissions to access all base and dependent secrets. Without sufficient permissions, secret references will not resolve to their appropriate values.

For example, if secret A references values from secrets B and C located in different scopes, the client must have read access to all three scopes containing secrets A, B, and C. If permission to any referenced secret is missing, the reference will remain unresolved, potentially causing application errors or unexpected behavior.

This is an important security consideration when planning your secret access strategy, especially when working with cross-environment or cross-folder references.

<Tip>
  You can hold the `Cmd` (Mac) or `Ctrl` (Windows/Linux) key and click the secret reference to be redirected to it.
</Tip>

### Syntax

When defining a secret reference, interpolation syntax is used to define references to secrets in other environments and [folders](./folder).

Suppose you have some secret `MY_SECRET` at the root of some environment and want to reference part of its value from another base secret `BASE_SECRET` located elsewhere.
Then consider the following scenarios:

* If `BASE_SECRET` is in the same environment and folder as `MY_SECRET`, then you'd reference it using `${BASE_SECRET}`.
* If `BASE_SECRET` is at the root of another environment with the slug `dev`, then you'd reference it using `${dev.MY_SECRET}`.

Here are a few more helpful examples for how to reference secrets in different contexts:

| Reference syntax        | Environment | Folder                        | Secret Key |
| ----------------------- | ----------- | ----------------------------- | ---------- |
| `${KEY1}`               | same env    | same folder                   | KEY1       |
| `${dev.KEY2}`           | `dev`       | `/` (root of dev environment) | KEY2       |
| `${prod.frontend.KEY2}` | `prod`      | `/frontend`                   | KEY2       |

## Secret Imports

Infisical's Secret Imports functionality makes it possible to import the secrets from another environment or folder into the current folder context.
This can be useful if you have common secrets that need to be available across multiple environments/folders.

To add a secret import, press the downward chevron to the right of the **Add Secret** button; then press on the **Add Import** button.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/secret-references-imports/secret-import-add.png" alt="add secret import" />

Once added, a secret import will show up with a green import icon on the secrets dashboard.
In the example below, you can see that the items in the path `/some-folder` are being imported into
the current folder context.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/secret-references-imports/secret-import-added.png" alt="added secret import" />

To delete a secret import, hover over it and press the **X** button that appears on the right side.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/secret-references-imports/secret-import-delete.png" alt="delete secret import" />

Lastly, note that the order of secret imports matters. If two secret imports contain secrets with the same name, then the secret value from the bottom-most secret import is taken  "the last one wins."

To reorder a secret import, hover over it and drag the arrows handle to the position you want.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/secret-references-imports/secret-import-reorder.png" alt="reorder secret import" />

<iframe width="560" height="315" src="https://www.youtube.com/embed/o11bMU0pXRs?si=dCprt3xLWPrSOJxy" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen />


# Auth0 Client Secret Rotation
Source: https://infisical.com/docs/documentation/platform/secret-rotation/auth0-client-secret

Learn how to automatically rotate Auth0 Client Secrets.

<Note>
  Due to how Auth0 client secrets are rotated, retired credentials will not be able to
  authenticate with Auth0 during their [inactive period](./overview#how-rotation-works).

  This is a limitation of the Auth0 platform and cannot be
  rectified by Infisical.
</Note>

## Prerequisites

* Create an [Auth0 Connection](/integrations/app-connections/auth0) with the required **Secret Rotation** audience and permissions

## Create an Auth0 Client Secret Rotation in Infisical

<Tabs>
  <Tab title="Infisical UI">
    1. Navigate to your Secret Manager Project's Dashboard and select **Add Secret Rotation** from the actions dropdown.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/generic/add-secret-rotation.png" alt="Secret Manager Dashboard" />

    2. Select the **Auth0 Client Secret** option.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/auth0-client-secret/select-auth0-client-secret-option.png" alt="Select Auth0 Client Secret" />

    3. Select the **Auth0 Connection** to use and configure the rotation behavior. Then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/auth0-client-secret/auth0-client-secret-configuration.png" alt="Rotation Configuration" />

       * **Auth0 Connection** - the connection that will perform the rotation of the specified application's Client Secret.
       * **Rotation Interval** - the interval, in days, that once elapsed will trigger a rotation.
       * **Rotate At** - the local time of day when rotation should occur once the interval has elapsed.
       * **Auto-Rotation Enabled** - whether secrets should automatically be rotated once the rotation interval has elapsed. Disable this option to manually rotate secrets or pause secret rotation.

       <Note>
         Due to Auth0 Client Secret Rotations rotating a single credential set, auto-rotation may result in service interruptions. If you need to ensure service continuity, we recommend disabling this option.
       </Note>

    4. Select the Auth0 application whose Client Secret you want to rotate. Then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/auth0-client-secret/auth0-client-secret-parameters.png" alt="Rotation Parameters" />

    5. Specify the secret names that the client credentials should be mapped to. Then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/auth0-client-secret/auth0-client-secret-secrets-mapping.png" alt="Rotation Secrets Mapping" />

       * **Client ID** - the name of the secret that the application Client ID will be mapped to.
       * **Client Secret** - the name of the secret that the rotated Client Secret will be mapped to.

    6. Give your rotation a name and description (optional). Then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/auth0-client-secret/auth0-client-secret-details.png" alt="Rotation Details" />

       * **Name** - the name of the secret rotation configuration. Must be slug-friendly.
       * **Description** (optional) - a description of this rotation configuration.

    7. Review your configuration, then click **Create Secret Rotation**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/auth0-client-secret/auth0-client-secret-confirm.png" alt="Rotation Review" />

    8. Your **Auth0 Client Secret** credentials are now available for use via the mapped secrets.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/auth0-client-secret/auth0-client-secret-created.png" alt="Rotation Created" />
  </Tab>

  <Tab title="API">
    To create an Auth0 Client Secret Rotation, make an API request to the [Create Auth0
    Client Secret Rotation](/api-reference/endpoints/secret-rotations/auth0-client-secret/create) API endpoint.

    You will first need the **Client ID** of the Auth0 application you want to rotate the secret for. This can be obtained from the Applications dashboard.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/auth0-client-secret/auth0-app-client-id.png" alt="Auth0 Client ID" />

    ### Sample request

    ```bash Request theme={"dark"}
    curl --request POST \
    --url https://us.infisical.com/api/v2/secret-rotations/auth0-client-secret \
    --header 'Content-Type: application/json' \
    --data '{
        "name": "my-auth0-rotation",
        "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
        "description": "my client secret rotation",
        "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
        "environment": "dev",
        "secretPath": "/",
        "isAutoRotationEnabled": true,
        "rotationInterval": 30,
        "rotateAtUtc": {
            "hours": 0,
            "minutes": 0
        },
        "parameters": {
            "clientId": "...",
        },
        "secretsMapping": {
            "clientId": "AUTH0_CLIENT_ID",
            "clientSecret": "AUTH0_CLIENT_SECRET"
        }
    }'
    ```

    <Note>
      Due to Auth0 Client Secret Rotations rotating a single credential set, auto-rotation may result in service interruptions. If you need to ensure service continuity, we recommend disabling this option.
    </Note>

    ### Sample response

    ```bash Response theme={"dark"}
    {
        "secretRotation": {
            "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "name": "my-auth0-rotation",
            "description": "my client secret rotation",
            "secretsMapping": {
                "clientId": "AUTH0_CLIENT_ID",
                "clientSecret": "AUTH0_CLIENT_SECRET"
            },
            "isAutoRotationEnabled": true,
            "activeIndex": 0,
            "folderId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "createdAt": "2023-11-07T05:31:56Z",
            "updatedAt": "2023-11-07T05:31:56Z",
            "rotationInterval": 30,
            "rotationStatus": "success",
            "lastRotationAttemptedAt": "2023-11-07T05:31:56Z",
            "lastRotatedAt": "2023-11-07T05:31:56Z",
            "lastRotationJobId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "nextRotationAt": "2023-11-07T05:31:56Z",
            "connection": {
                "app": "auth0",
                "name": "my-auth0-connection",
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a"
            },
            "environment": {
                "slug": "dev",
                "name": "Development",
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a"
            },
            "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "folder": {
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                "path": "/"
            },
            "rotateAtUtc": {
                "hours": 0,
                "minutes": 0
            },
            "lastRotationMessage": null,
            "type": "auth0-client-secret",
            "parameters": {
                "clientId": "...",
            }
        }
    }
    ```
  </Tab>
</Tabs>


# AWS IAM User
Source: https://infisical.com/docs/documentation/platform/secret-rotation/aws-iam-user-secret

Learn how to automatically rotate Access Key Id and Secret Key of AWS IAM Users.

Infisical's AWS IAM User secret rotation capability lets you update the **Access key** and **Secret access key** credentials of a target IAM user from within Infisical
at a specified interval or on-demand.

## Prerequisites

* Create an [AWS Connection](/integrations/app-connections/aws) with the required **Secret Rotation** permissions
* Make sure to add the following permissions to your IAM Role/IAM User Permission policy set used by your AWS Connection:

  ```json  theme={"dark"}
  {
    "Version": "2012-10-17",
    "Statement": [
      {
        "Effect": "Allow",
        "Action": [
          "iam:ListAccessKeys",
          "iam:CreateAccessKey",
          "iam:UpdateAccessKey",
          "iam:DeleteAccessKey",
          "iam:ListUsers"
        ],
        "Resource": "*"
      }
    ]
  }
  ```

## Workflow

The typical workflow for using the AWS IAM User rotation strategy consists of four steps:

1. Creating the target IAM user whose credentials you wish to rotate.
2. Configuring the rotation strategy in Infisical with the credentials of the managing IAM user.
3. Pressing the **Rotate** button in the Infisical dashboard to trigger the rotation of the target IAM user's credentials. The strategy can also be configured to rotate the credentials automatically at a specified interval.

In the following steps, we explore the end-to-end workflow for setting up this strategy in Infisical.

<Steps>
  <Step title="Create the target IAM user">
    To begin, create an IAM user whose credentials you wish to rotate. If you already have an IAM user,
    then you can skip this step.
  </Step>

  <Step title="Configure the AWS IAM User secret rotation strategy in Infisical">
    <Tabs>
      <Tab title="Infisical UI">
        1. Navigate to your Secret Manager Project's Dashboard and select **Add Secret Rotation** from the actions dropdown.
           <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/generic/add-secret-rotation.png" alt="Secret Manager Dashboard" />

        2. Select the **AWS IAM User Secret** option.
           <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/aws-iam-user-secret/aws-iam-user-secret-option.png" alt="Select AWS IAM User Secret" />

        3. Select the **AWS Connection** to use and configure the rotation behavior. Then click **Next**.
           <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/aws-iam-user-secret/aws-iam-user-secret-configuration.png" alt="Rotation Configuration" />

           * **AWS Connection** - the connection that will perform the rotation of the specified application's Client Secret.
           * **Rotation Interval** - the interval, in days, that once elapsed will trigger a rotation.
           * **Rotate At** - the local time of day when rotation should occur once the interval has elapsed.
           * **Auto-Rotation Enabled** - whether secrets should automatically be rotated once the rotation interval has elapsed. Disable this option to manually rotate secrets or pause secret rotation.

        4. Select the AWS IAM user and the region of the user whose credentials you want to rotate. Then click **Next**.
           <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/aws-iam-user-secret/aws-iam-user-secret-parameters.png" alt="Rotation Parameters" />

        5. Specify the secret names that the AWS IAM access key credentials should be mapped to. Then click **Next**.
           <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/aws-iam-user-secret/aws-iam-user-secret-secrets-mapping.png" alt="Rotation Secrets Mapping" />

           * **Access Key ID** - the name of the secret that the AWS access key ID will be mapped to.
           * **Secret Access Key** - the name of the secret that the rotated secret access key will be mapped to.

        6. Give your rotation a name and description (optional). Then click **Next**.
           <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/aws-iam-user-secret/aws-iam-user-secret-details.png" alt="Rotation Details" />

           * **Name** - the name of the secret rotation configuration. Must be slug-friendly.
           * **Description** (optional) - a description of this rotation configuration.

        7. Review your configuration, then click **Create Secret Rotation**.
           <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/aws-iam-user-secret/aws-iam-user-secret-confirm.png" alt="Rotation Review" />

        8. Your **AWS IAM User** credentials are now available for use via the mapped secrets.
           <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/aws-iam-user-secret/aws-iam-user-secret-created.png" alt="Rotation Created" />
      </Tab>

      <Tab title="API">
        To create an AWS IAM User Rotation, make an API request to the [Create AWS IAM User Rotation](/api-reference/endpoints/secret-rotations/aws-iam-user-secret/create) API endpoint.

        You will first need the **User Name** of the AWS IAM user you want to rotate the secret for. This can be obtained from the IAM console, on Users tab.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/aws-iam-user-secret/aws-iam-user-secret-user-names.png" alt="Users" />

        ### Sample request

        ```bash Request theme={"dark"}
        curl --request POST \
        	--url https://us.infisical.com/api/v2/secret-rotations/aws-iam-user-secret \
        	--header 'Content-Type: application/json' \
        	--data '{
        	"name": "my-aws-rotation",
        	"projectId": "9602cfc5-20b9-4c35-a056-dd7372db0f25",
        	"description": "My rotation strategy description",
        	"connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
        	"environment": "dev",
        	"secretPath": "/",
        	"isAutoRotationEnabled": true,
        	"rotationInterval": 2,
        	"rotateAtUtc": {
        		"hours": 11.5,
        		"minutes": 29.5
        	},
        	"parameters": {
        		"userName": "testUser",
        		"region": "us-east-1"
        	},
        	"secretsMapping": {
        		"accessKeyId": "AWS_ACCESS_KEY_ID",
        		"secretAccessKey": "AWS_SECRET_ACCESS_KEY"
        	}
        }'
        ```

        ### Sample response

        ```bash Response theme={"dark"}
        {
        	"secretRotation": {
        		"id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
        		"name": "my-aws-rotation",
        		"description": "My rotation strategy description",
        		"secretsMapping": {
        			"accessKeyId": "AWS_ACCESS_KEY_ID",
        			"secretAccessKey": "AWS_SECRET_ACCESS_KEY"
        		},
        		"isAutoRotationEnabled": true,
        		"activeIndex": 0,
        		"folderId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
        		"connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
        		"createdAt": "2023-11-07T05:31:56Z",
        		"updatedAt": "2023-11-07T05:31:56Z",
        		"rotationInterval": 123,
        		"rotationStatus": "success",
        		"lastRotationAttemptedAt": "2023-11-07T05:31:56Z",
        		"lastRotatedAt": "2023-11-07T05:31:56Z",
        		"lastRotationJobId": null,
        		"nextRotationAt": "2023-11-07T05:31:56Z",
        		"isLastRotationManual": true,
        		"connection": {
        			"app": "aws",
        			"name": "my-aws-connection",
        			"id": "3c90c3cc-0d44-4b50-8888-8dd25736052a"
        		},
        		"environment": {
        			"slug": "dev",
        			"name": "Development",
        			"id": "3c90c3cc-0d44-4b50-8888-8dd25736052a"
        		},
        		"projectId": "9602cfc5-20b9-4c35-a056-dd7372db0f25",
        		"folder": {
        			"id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
        			"path": "/"
        		},
        		"rotateAtUtc": {
        			"hours": 11.5,
        			"minutes": 29.5
        		},
        		"lastRotationMessage": null,
        		"type": "aws-iam-user-secret",
        		"parameters": {
        			"userName": "testUser",
        			"region": "us-east-1"
        		}
        	}
        }
        ```
      </Tab>
    </Tabs>
  </Step>
</Steps>

**FAQ**

<AccordionGroup>
  <Accordion title="Why are my AWS IAM credentials not rotating?">
    There are a few reasons for why this might happen:

    * The strategy configuration is invalid (e.g. the managing IAM user's credentials are incorrect, the target AWS region is incorrect, etc.)
    * The managing IAM user is insufficiently permissioned to rotate the credentials of the target IAM user. For instance, you may have setup
      [paths](https://aws.amazon.com/blogs/security/optimize-aws-administration-with-iam-paths/) for the managing IAM user and the policy does not have the necessary
      permissions to rotate the credentials.
  </Accordion>
</AccordionGroup>


# Azure Client Secret
Source: https://infisical.com/docs/documentation/platform/secret-rotation/azure-client-secret

Learn how to automatically rotate Azure Client Secrets.

## Prerequisites

* Create an [Azure Client Secret Connection](/integrations/app-connections/azure-client-secrets).
* Ensure your network security policies allow incoming requests from Infisical to this rotation provider, if network restrictions apply.

## Create an Azure Client Secret Rotation in Infisical

<Tabs>
  <Tab title="Infisical UI">
    1. Navigate to your Secret Manager Project's Dashboard and select **Add Secret Rotation** from the actions dropdown.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/generic/add-secret-rotation.png" alt="Secret Manager Dashboard" />

    2. Select the **Azure Client Secret** option.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/azure-client-secret/azure-client-secret-option.png" alt="Select Azure Client Secret" />

    3. Select the **Azure Connection** to use and configure the rotation behavior. Then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/azure-client-secret/azure-client-secret-configuration.png" alt="Rotation Configuration" />

       * **Azure Connection** - the connection that will perform the rotation of the specified application's Client Secret.
       * **Rotation Interval** - the interval, in days, that once elapsed will trigger a rotation.
       * **Rotate At** - the local time of day when rotation should occur once the interval has elapsed.
       * **Auto-Rotation Enabled** - whether secrets should automatically be rotated once the rotation interval has elapsed. Disable this option to manually rotate secrets or pause secret rotation.

    4. Select the Azure application whose Client Secret you want to rotate. Then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/azure-client-secret/azure-client-secret-parameters.png" alt="Rotation Parameters" />

    5. Specify the secret names that the client credentials should be mapped to. Then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/azure-client-secret/azure-client-secret-mapping.png" alt="Rotation Secrets Mapping" />

       * **Client ID** - the name of the secret that the application Client ID will be mapped to.
       * **Client Secret** - the name of the secret that the rotated Client Secret will be mapped to.

    6. Give your rotation a name and description (optional). Then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/azure-client-secret/azure-client-secret-details.png" alt="Rotation Details" />

       * **Name** - the name of the secret rotation configuration. Must be slug-friendly.
       * **Description** (optional) - a description of this rotation configuration.

    7. Review your configuration, then click **Create Secret Rotation**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/azure-client-secret/azure-client-secret-review.png" alt="Rotation Review" />

    8. Your **Azure Client Secret** credentials are now available for use via the mapped secrets.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/azure-client-secret/azure-client-secret-created.png" alt="Rotation Created" />
  </Tab>

  <Tab title="API">
    To create an Azure Client Secret Rotation, make an API request to the [Create Azure
    Client Secret Rotation](/api-reference/endpoints/secret-rotations/azure-client-secret/create) API endpoint.

    You will first need the **Client ID** and **Object ID** of the Azure application you want to rotate the secret for. This can be obtained from the Applications dashboard.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/azure-client-secret/azure-app-client-id.png" alt="Azure Client ID" />

    ### Sample request

    ```bash Request theme={"dark"}
    curl --request POST \
    --url https://us.infisical.com/api/v2/secret-rotations/azure-client-secret \
    --header 'Content-Type: application/json' \
    --data '{
        "name": "my-azure-rotation",
        "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
        "description": "my client secret rotation",
        "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
        "environment": "dev",
        "secretPath": "/",
        "isAutoRotationEnabled": true,
        "rotationInterval": 30,
        "rotateAtUtc": {
            "hours": 0,
            "minutes": 0
        },
        "parameters": {
            "objectId": "...",
            "clientId": "...",
            "appName": "..."
        },
        "secretsMapping": {
            "clientId": "AZURE_CLIENT_ID",
            "clientSecret": "AZURE_CLIENT_SECRET"
        }
    }'
    ```

    ### Sample response

    ```bash Response theme={"dark"}
    {
        "secretRotation": {
            "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "name": "my-azure-rotation",
            "description": "my client secret rotation",
            "secretsMapping": {
                "clientId": "AZURE_CLIENT_ID",
                "clientSecret": "AZURE_CLIENT_SECRET"
            },
            "isAutoRotationEnabled": true,
            "activeIndex": 0,
            "folderId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "createdAt": "2023-11-07T05:31:56Z",
            "updatedAt": "2023-11-07T05:31:56Z",
            "rotationInterval": 30,
            "rotationStatus": "success",
            "lastRotationAttemptedAt": "2023-11-07T05:31:56Z",
            "lastRotatedAt": "2023-11-07T05:31:56Z",
            "lastRotationJobId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "nextRotationAt": "2023-11-07T05:31:56Z",
            "connection": {
                "app": "azure",
                "name": "my-azure-connection",
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a"
            },
            "environment": {
                "slug": "dev",
                "name": "Development",
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a"
            },
            "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "folder": {
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                "path": "/"
            },
            "rotateAtUtc": {
                "hours": 0,
                "minutes": 0
            },
            "lastRotationMessage": null,
            "type": "azure-client-secret",
            "parameters": {
                "objectId": "...",
                "appName": "...",
                "clientId": "..."
            }
        }
    }
    ```
  </Tab>
</Tabs>


# LDAP Password Rotation
Source: https://infisical.com/docs/documentation/platform/secret-rotation/ldap-password

Learn how to automatically rotate LDAP passwords.

<Note>
  Due to how LDAP passwords are rotated, retired credentials will not be able to
  authenticate with the LDAP provider during their [inactive period](./overview#how-rotation-works).

  This is a limitation of the LDAP provider and cannot be
  rectified by Infisical.
</Note>

## Prerequisites

* Create an [LDAP Connection](/integrations/app-connections/ldap) with the **Secret Rotation** requirements
* Ensure your network security policies allow incoming requests from Infisical to this rotation provider, if network restrictions apply.

## Create an LDAP Password Rotation in Infisical

<Tabs>
  <Tab title="Infisical UI">
    1. Navigate to your Secret Manager Project's Dashboard and select **Add Secret Rotation** from the actions dropdown.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/generic/add-secret-rotation.png" alt="Secret Manager Dashboard" />

    2. Select the **LDAP Password** option.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/ldap-password/select-ldap-password-option.png" alt="Select LDAP Password" />

    3. Select the **LDAP Connection** to use and configure the rotation behavior. Then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/ldap-password/ldap-password-configuration.png" alt="Rotation Configuration" />

       * **LDAP Connection** - the connection that will perform the rotation of the configured principal's password.

       <Note>
         LDAP Password Rotations require an LDAP Connection that uses ldaps\:// protocol.
       </Note>

       * **Rotation Interval** - the interval, in days, that once elapsed will trigger a rotation.
       * **Rotate At** - the local time of day when rotation should occur once the interval has elapsed.
       * **Auto-Rotation Enabled** - whether secrets should automatically be rotated once the rotation interval has elapsed. Disable this option to manually rotate secrets or pause secret rotation.

       <Note>
         Due to LDAP Password Rotations rotating a single credential set, auto-rotation may result in service interruptions. If you need to ensure service continuity, we recommend disabling this option.
       </Note>

    4. Configure the required Parameters for your rotation. Then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/ldap-password/ldap-password-parameters.png" alt="Rotation Parameters" />

    * **Rotation Method** - The method to use when rotating the target principal's password.
      * **Connection Principal** - Infisical will use the LDAP Connection's binding principal to rotate the target principal's password.
      * **Target Principal** - Infisical will bind with the target Principal to rotate their own password.
    * **DN/UPN** - The Distinguished Name (DN), or User Principal Name (UPN) if supported, of the principal whose password you want to rotate.
    * **Password** - The target principal's password (if **Rotation Method** is set to **Target Principal**).
    * **Password Requirements** - The constraints to apply when generating new passwords.

    5. Specify the secret names that the client credentials should be mapped to. Then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/ldap-password/ldap-password-secrets-mapping.png" alt="Rotation Secrets Mapping" />

       * **DN/UPN** - the name of the secret that the principal's Distinguished Name (DN) or User Principal Name (UPN) will be mapped to.
       * **Password** - the name of the secret that the rotated password will be mapped to.

    6. Give your rotation a name and description (optional). Then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/ldap-password/ldap-password-details.png" alt="Rotation Details" />

       * **Name** - the name of the secret rotation configuration. Must be slug-friendly.
       * **Description** (optional) - a description of this rotation configuration.

    7. Review your configuration, then click **Create Secret Rotation**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/ldap-password/ldap-password-confirm.png" alt="Rotation Review" />

    8. Your **LDAP Password** credentials are now available for use via the mapped secrets.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/ldap-password/ldap-password-created.png" alt="Rotation Created" />
  </Tab>

  <Tab title="API">
    To create an LDAP Password Rotation, make an API request to the [Create LDAP
    Password Rotation](/api-reference/endpoints/secret-rotations/ldap-password/create) API endpoint.

    ### Sample request

    ```bash Request theme={"dark"}
    curl --request POST \
    --url https://us.infisical.com/api/v2/secret-rotations/ldap-password \
    --header 'Content-Type: application/json' \
    --data '{
        "name": "my-ldap-rotation",
        "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
        "description": "my ldap password rotation",
        "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
        "environment": "dev",
        "secretPath": "/",
        "isAutoRotationEnabled": false,
        "rotationInterval": 30,
        "rotateAtUtc": {
            "hours": 0,
            "minutes": 0
        },
        "parameters": {
            "rotationMethod": "connection-principal",
            "dn": "CN=John,CN=Users,DC=example,DC=com",
            "passwordRequirements": {
                "length": 48,
                "required": {
                    "digits": 2,
                    "lowercase": 2,
                    "uppercase": 2,
                    "symbols": 2
                },
                "allowedSymbols": "-_.~!*"
            }
        },
        "secretsMapping": {
            "dn": "LDAP_DN",
            "password": "LDAP_PASSWORD"
        }
    }'
    ```

    <Note>
      Due to LDAP Password Rotations rotating a single credential set, auto-rotation may result in service interruptions. If you need to ensure service continuity, we recommend disabling this option.
    </Note>

    ### Sample response

    ```bash Response theme={"dark"}
    {
        "secretRotation": {
            "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "name": "my-ldap-rotation",
            "description": "my ldap password rotation",
            "secretsMapping": {
                "dn": "LDAP_DN",
                "password": "LDAP_PASSWORD"
            },
            "isAutoRotationEnabled": false,
            "activeIndex": 0,
            "folderId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "createdAt": "2023-11-07T05:31:56Z",
            "updatedAt": "2023-11-07T05:31:56Z",
            "rotationInterval": 30,
            "rotationStatus": "success",
            "lastRotationAttemptedAt": "2023-11-07T05:31:56Z",
            "lastRotatedAt": "2023-11-07T05:31:56Z",
            "lastRotationJobId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "nextRotationAt": "2023-11-07T05:31:56Z",
            "connection": {
                "app": "ldap",
                "name": "my-ldap-connection",
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a"
            },
            "environment": {
                "slug": "dev",
                "name": "Development",
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a"
            },
            "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "folder": {
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                "path": "/"
            },
            "rotateAtUtc": {
                "hours": 0,
                "minutes": 0
            },
            "lastRotationMessage": null,
            "type": "ldap-password",
            "parameters": {
                "rotationMethod": "connection-principal",
                "dn": "CN=John,CN=Users,DC=example,DC=com",
                "passwordRequirements": {
                    "length": 48,
                    "required": {
                        "digits": 2,
                        "lowercase": 2,
                        "uppercase": 2,
                        "symbols": 2
                    },
                    "allowedSymbols": "-_.~!*"
                }
            }
        }
    }
    ```
  </Tab>
</Tabs>


# Microsoft SQL Server Credentials Rotation
Source: https://infisical.com/docs/documentation/platform/secret-rotation/mssql-credentials

Learn how to automatically rotate Microsoft SQL Server credentials.

## Prerequisites

1. Create a [Microsoft SQL Server Connection](/integrations/app-connections/mssql) with the required **Secret Rotation** permissions
2. Create two designated database users for Infisical to rotate the credentials for. Be sure to grant each user login permissions for the desired database with the necessary privileges their use case will require.

An example creation statement might look like:

```SQL  theme={"dark"}
-- create server-level logins
CREATE LOGIN [infisical_user_1] WITH PASSWORD = 'my-password';
CREATE LOGIN [infisical_user_2] WITH PASSWORD = 'my-password';
GRANT CONNECT SQL TO [infisical_user_1];
GRANT CONNECT SQL TO [infisical_user_2];

-- create database-level users with login from above
USE my_database;
CREATE USER [infisical_user_1] FOR LOGIN [infisical_user_1];
CREATE USER [infisical_user_2] FOR LOGIN [infisical_user_2];

-- grant relevant permissions
GRANT SELECT, INSERT, UPDATE, DELETE ON SCHEMA::dbo TO [infisical_user_1];
GRANT SELECT, INSERT, UPDATE, DELETE ON SCHEMA::dbo TO [infisical_user_2];
```

<Tip>
  To learn more about Microsoft SQL Server's permission system, please visit their [documentation](https://learn.microsoft.com/en-us/sql/t-sql/statements/grant-transact-sql?view=sql-server-ver16).
</Tip>

3. Ensure your network security policies allow incoming requests from Infisical to this rotation provider, if network restrictions apply.

## Create a Microsoft SQL Server Credentials Rotation in Infisical

<Tabs>
  <Tab title="Infisical UI">
    1. Navigate to your Secret Manager Project's Dashboard and select **Add Secret Rotation** from the actions dropdown.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/generic/add-secret-rotation.png" alt="Secret Manager Dashboard" />

    2. Select the **Microsoft SQL Server Credentials** option.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/mssql-credentials/select-mssql-credentials-option.png" alt="Select Microsoft SQL Server Credentials" />

    3. Select the **Microsoft SQL Server Connection** to use and configure the rotation behavior. Then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/mssql-credentials/mssql-credentials-configuration.png" alt="Rotation Configuration" />

    * **Microsoft SQL Server Connection** - the connection that will perform the rotation of the configured database user credentials.
    * **Rotation Interval** - the interval, in days, that once elapsed will trigger a rotation.
    * **Rotate At** - the local time of day when rotation should occur once the interval has elapsed.
    * **Auto-Rotation Enabled** - whether secrets should automatically be rotated once the rotation interval has elapsed. Disable this option to manually rotate secrets or pause secret rotation.

    4. Input the usernames of the database users created above that will be used for rotation. Then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/mssql-credentials/mssql-credentials-parameters.png" alt="Rotation Parameters" />

    * **Database Username 1** - the username of the first user that will be used for rotation.
    * **Database Username 2** - the username of the second user that will be used for rotation.

    5. Specify the secret names that the active credentials should be mapped to. Then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/mssql-credentials/mssql-credentials-secrets-mapping.png" alt="Rotation Secrets Mapping" />

    * **Username** - the name of the secret that the active username will be mapped to.
    * **Password** - the name of the secret that the active password will be mapped to.

    6. Give your rotation a name and description (optional). Then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/mssql-credentials/mssql-credentials-details.png" alt="Rotation Details" />

    * **Name** - the name of the secret rotation configuration. Must be slug-friendly.
    * **Description** (optional) - a description of this rotation configuration.

    7. Review your configuration, then click **Create Secret Rotation**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/mssql-credentials/mssql-credentials-confirm.png" alt="Rotation Review" />

    8. Your **Microsoft SQL Server Credentials** are now available for use via the mapped secrets.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/mssql-credentials/mssql-credentials-created.png" alt="Rotation Created" />
  </Tab>

  <Tab title="API">
    To create a Microsoft SQL Server Credentials Rotation, make an API request to the [Create Microsoft SQL Server
    Credentials Rotation](/api-reference/endpoints/secret-rotations/mssql-credentials/create) API endpoint.

    ### Sample request

    ```bash Request theme={"dark"}
    curl --request POST \
    --url https://us.infisical.com/api/v2/secret-rotations/mssql-credentials \
    --header 'Content-Type: application/json' \
    --data '{
        "name": "my-mssql-rotation",
        "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
        "description": "my database credentials rotation",
        "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
        "environment": "dev",
        "secretPath": "/",
        "isAutoRotationEnabled": true,
        "rotationInterval": 30,
        "rotateAtUtc": {
            "hours": 0,
            "minutes": 0
        },
        "parameters": {
            "username1": "infisical_user_1",
            "username2": "infisical_user_2"
        },
        "secretsMapping": {
            "username": "MSSQL_DB_USERNAME",
            "password": "MSSQL_DB_PASSWORD"
        }
    }'
    ```

    ### Sample response

    ```bash Response theme={"dark"}
    {
        "secretRotation": {
            "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "name": "my-mssql-rotation",
            "description": "my database credentials rotation",
            "secretsMapping": {
                "username": "MSSQL_DB_USERNAME",
                "password": "MSSQL_DB_PASSWORD"
            },
            "isAutoRotationEnabled": true,
            "activeIndex": 0,
            "folderId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "createdAt": "2023-11-07T05:31:56Z",
            "updatedAt": "2023-11-07T05:31:56Z",
            "rotationInterval": 30,
            "rotationStatus": "success",
            "lastRotationAttemptedAt": "2023-11-07T05:31:56Z",
            "lastRotatedAt": "2023-11-07T05:31:56Z",
            "lastRotationJobId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "nextRotationAt": "2023-11-07T05:31:56Z",
            "connection": {
                "app": "mssql",
                "name": "my-mssql-connection",
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a"
            },
            "environment": {
                "slug": "dev",
                "name": "Development",
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a"
            },
            "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "folder": {
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                "path": "/"
            },
            "rotateAtUtc": {
                "hours": 0,
                "minutes": 0
            },
            "lastRotationMessage": null,
            "type": "mssql-credentials",
            "parameters": {
                "username1": "infisical_user_1",
                "username2": "infisical_user_2"
            }
        }
    }
    ```
  </Tab>
</Tabs>


# MySQL Credentials Rotation
Source: https://infisical.com/docs/documentation/platform/secret-rotation/mysql-credentials

Learn how to automatically rotate MySQL credentials.

## Prerequisites

1. Create a [MySQL Connection](/integrations/app-connections/mysql) with the required **Secret Rotation** permissions
2. Create two designated database users for Infisical to rotate the credentials for. Be sure to grant each user login permissions for the desired database with the necessary privileges their use case will require.

   An example creation statement might look like:

   ```SQL  theme={"dark"}
   -- create user roles
   CREATE USER 'infisical_user_1'@'%' IDENTIFIED BY 'temporary_password';
   CREATE USER 'infisical_user_2'@'%' IDENTIFIED BY 'temporary_password';

   -- grant all privileges
   GRANT ALL PRIVILEGES ON my_database.* TO 'infisical_user_1'@'%';
   GRANT ALL PRIVILEGES ON my_database.* TO 'infisical_user_2'@'%';

   -- apply the privilege changes
   FLUSH PRIVILEGES;
   ```

   <Tip>
     To learn more about the MySQL permission system, please visit their [documentation](https://dev.mysql.com/doc/refman/8.4/en/grant.html).
   </Tip>
3. Ensure your network security policies allow incoming requests from Infisical to this rotation provider, if network restrictions apply.

## Create a MySQL Credentials Rotation in Infisical

<Tabs>
  <Tab title="Infisical UI">
    1. Navigate to your Secret Manager Project's Dashboard and select **Add Secret Rotation** from the actions dropdown.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/generic/add-secret-rotation.png" alt="Secret Manager Dashboard" />

    2. Select the **MySQL Credentials** option.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/mysql-credentials/select-mysql-credentials-option.png" alt="Select MySQL Credentials" />

    3. Select the **MySQL Connection** to use and configure the rotation behavior. Then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/mysql-credentials/mysql-credentials-configuration.png" alt="Rotation Configuration" />

       * **MySQL Connection** - the connection that will perform the rotation of the configured database user credentials.
       * **Rotation Interval** - the interval, in days, that once elapsed will trigger a rotation.
       * **Rotate At** - the local time of day when rotation should occur once the interval has elapsed.
       * **Auto-Rotation Enabled** - whether secrets should automatically be rotated once the rotation interval has elapsed. Disable this option to manually rotate secrets or pause secret rotation.

    4. Input the usernames of the database users created above that will be used for rotation. Then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/mysql-credentials/mysql-credentials-parameters.png" alt="Rotation Parameters" />

       * **Database Username 1** - the username of the first user that will be used for rotation.
       * **Database Username 2** - the username of the second user that will be used for rotation.

    5. Specify the secret names that the active credentials should be mapped to. Then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/mysql-credentials/mysql-credentials-secrets-mapping.png" alt="Rotation Secrets Mapping" />

       * **Username** - the name of the secret that the active username will be mapped to.
       * **Password** - the name of the secret that the active password will be mapped to.

    6. Give your rotation a name and description (optional). Then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/mysql-credentials/mysql-credentials-details.png" alt="Rotation Details" />

       * **Name** - the name of the secret rotation configuration. Must be slug-friendly.
       * **Description** (optional) - a description of this rotation configuration.

    7. Review your configuration, then click **Create Secret Rotation**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/mysql-credentials/mysql-credentials-confirm.png" alt="Rotation Review" />

    8. Your **MySQL Credentials** are now available for use via the mapped secrets.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/mysql-credentials/mysql-credentials-created.png" alt="Rotation Created" />
  </Tab>

  <Tab title="API">
    To create a MySQL Credentials Rotation, make an API request to the [Create MySQL Credentials Rotation](/api-reference/endpoints/secret-rotations/mysql-credentials/create) API endpoint.

    ### Sample request

    ```bash Request theme={"dark"}
    curl --request POST \
    --url https://us.infisical.com/api/v2/secret-rotations/mysql-credentials \
    --header 'Content-Type: application/json' \
    --data '{
        "name": "my-mysql-rotation",
        "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
        "description": "my database credentials rotation",
        "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
        "environment": "dev",
        "secretPath": "/",
        "isAutoRotationEnabled": true,
        "rotationInterval": 30,
        "rotateAtUtc": {
            "hours": 0,
            "minutes": 0
        },
        "parameters": {
            "username1": "infisical_user_1",
            "username2": "infisical_user_2"
        },
        "secretsMapping": {
            "username": "MYSQL_USERNAME",
            "password": "MYSQL_PASSWORD"
        }
    }'
    ```

    ### Sample response

    ```bash Response theme={"dark"}
    {
        "secretRotation": {
            "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "name": "my-mysql-rotation",
            "description": "my database credentials rotation",
            "secretsMapping": {
                "username": "MYSQL_USERNAME",
                "password": "MYSQL_PASSWORD"
            },
            "isAutoRotationEnabled": true,
            "activeIndex": 0,
            "folderId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "createdAt": "2023-11-07T05:31:56Z",
            "updatedAt": "2023-11-07T05:31:56Z",
            "rotationInterval": 30,
            "rotationStatus": "success",
            "lastRotationAttemptedAt": "2023-11-07T05:31:56Z",
            "lastRotatedAt": "2023-11-07T05:31:56Z",
            "lastRotationJobId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "nextRotationAt": "2023-11-07T05:31:56Z",
            "connection": {
                "app": "mysql",
                "name": "my-mysql-connection",
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a"
            },
            "environment": {
                "slug": "dev",
                "name": "Development",
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a"
            },
            "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "folder": {
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                "path": "/"
            },
            "rotateAtUtc": {
                "hours": 0,
                "minutes": 0
            },
            "lastRotationMessage": null,
            "type": "mysql-credentials",
            "parameters": {
                "username1": "infisical_user_1",
                "username2": "infisical_user_2"
            }
        }
    }
    ```
  </Tab>
</Tabs>


# Okta Client Secret
Source: https://infisical.com/docs/documentation/platform/secret-rotation/okta-client-secret

Learn how to automatically rotate Okta Client Secrets.

## Prerequisites

* Create an [Okta Connection](/integrations/app-connections/okta).

## Create an Okta Client Secret Rotation in Infisical

<Tabs>
  <Tab title="Infisical UI">
    1. Navigate to your Secret Manager Project's Dashboard and select **Add Secret Rotation** from the actions dropdown.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/generic/add-secret-rotation.png" alt="Secret Manager Dashboard" />

    2. Select the **Okta Client Secret** option.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/okta-client-secret/select-okta.png" alt="Select Okta Client Secret" />

    3. Configure the rotation behavior, then click **Next**.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/okta-client-secret/configuration.png" alt="Rotation Configuration" />

    * **Okta Connection** - the connection that will perform the rotation of the specified application's Client Secret.
    * **Rotation Interval** - the interval, in days, that once elapsed will trigger a rotation.
    * **Rotate At** - the local time of day when rotation should occur once the interval has elapsed.
    * **Auto-Rotation Enabled** - whether secrets should automatically be rotated once the rotation interval has elapsed. Disable this option to manually rotate secrets or pause secret rotation.

    4. Select the Okta application whose Client Secret you want to rotate. Then click **Next**.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/okta-client-secret/parameters.png" alt="Rotation Parameters" />

    5. Specify the secret names that the client credentials should be mapped to. Then click **Next**.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/okta-client-secret/mappings.png" alt="Rotation Secrets Mapping" />

    * **Client ID** - the name of the secret that the application Client ID will be mapped to.
    * **Client Secret** - the name of the secret that the rotated Client Secret will be mapped to.

    6. Give your rotation a name and description (optional). Then click **Next**.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/okta-client-secret/details.png" alt="Rotation Details" />

    * **Name** - the name of the secret rotation configuration. Must be slug-friendly.
    * **Description** (optional) - a description of this rotation configuration.

    7. Review your configuration, then click **Create Secret Rotation**.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/okta-client-secret/review.png" alt="Rotation Review" />

    8. Your **Okta Client Secret** credentials are now available for use via the mapped secrets.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/okta-client-secret/created.png" alt="Rotation Created" />
  </Tab>

  <Tab title="API">
    To create an Okta Client Secret Rotation, make an API request to the [Create Okta Client Secret Rotation](/api-reference/endpoints/secret-rotations/okta-client-secret/create) API endpoint.

    You will first need the **Client ID** of the Okta application you want to rotate the secret for. This can be obtained from the applications dashboard.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/okta-client-secret/client-id.png" alt="Okta Client ID" />

    ### Sample request

    ```bash Request theme={"dark"}
    curl --request POST \
    --url https://us.infisical.com/api/v2/secret-rotations/okta-client-secret \
    --header 'Content-Type: application/json' \
    --data '{
        "name": "my-okta-rotation",
        "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
        "description": "my client secret rotation",
        "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
        "environment": "dev",
        "secretPath": "/",
        "isAutoRotationEnabled": true,
        "rotationInterval": 30,
        "rotateAtUtc": {
            "hours": 0,
            "minutes": 0
        },
        "parameters": {
            "clientId": "...",
        },
        "secretsMapping": {
            "clientId": "OKTA_CLIENT_ID",
            "clientSecret": "OKTA_CLIENT_SECRET"
        }
    }'
    ```

    ### Sample response

    ```bash Response theme={"dark"}
    {
        "secretRotation": {
            "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "name": "my-okta-rotation",
            "description": "my client secret rotation",
            "secretsMapping": {
                "clientId": "OKTA_CLIENT_ID",
                "clientSecret": "OKTA_CLIENT_SECRET"
            },
            "isAutoRotationEnabled": true,
            "activeIndex": 0,
            "folderId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "createdAt": "2023-11-07T05:31:56Z",
            "updatedAt": "2023-11-07T05:31:56Z",
            "rotationInterval": 30,
            "rotationStatus": "success",
            "lastRotationAttemptedAt": "2023-11-07T05:31:56Z",
            "lastRotatedAt": "2023-11-07T05:31:56Z",
            "lastRotationJobId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "nextRotationAt": "2023-11-07T05:31:56Z",
            "connection": {
                "app": "okta",
                "name": "my-okta-connection",
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a"
            },
            "environment": {
                "slug": "dev",
                "name": "Development",
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a"
            },
            "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "folder": {
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                "path": "/"
            },
            "rotateAtUtc": {
                "hours": 0,
                "minutes": 0
            },
            "lastRotationMessage": null,
            "type": "okta-client-secret",
            "parameters": {
                "clientId": "..."
            }
        }
    }
    ```
  </Tab>
</Tabs>


# OracleDB Credentials Rotation
Source: https://infisical.com/docs/documentation/platform/secret-rotation/oracledb-credentials

Learn how to automatically rotate Oracle Database credentials.

<Info>
  When working with SQL in Oracle databases, any values not surrounded by "quotes" will become UPPERCASE. Keep this in mind when creating users.
</Info>

## Prerequisites

1. Create a [OracleDB Connection](/integrations/app-connections/oracledb) with the required **Secret Rotation** permissions

2. Create two designated database users for Infisical to rotate the credentials for. Be sure to grant each user login permissions for the desired database with the necessary privileges their use case will require.

   An example creation statement might look like:

   ```SQL  theme={"dark"}
   -- create user roles
   CREATE USER INFISICAL_USER_1 IDENTIFIED BY "temporary_password";
   CREATE USER INFISICAL_USER_2 IDENTIFIED BY "temporary_password";

   -- grant necessary privileges
   GRANT ALL PRIVILEGES TO INFISICAL_USER_1;
   GRANT ALL PRIVILEGES TO INFISICAL_USER_2;
   ```

   <Note>
     Username must either be ALL UPPERCASE or not be surrounded by "quotes". Values not surrounded by quotes get automatically transformed to uppercase by Oracle Database.
   </Note>

   <Tip>
     To learn more about the Oracle Database permission system, please visit their [documentation](https://docs.oracle.com/en/database/oracle/oracle-database/19/dbseg/configuring-privilege-and-role-authorization.html).
   </Tip>

3. Ensure your network security policies allow incoming requests from Infisical to this rotation provider, if network restrictions apply.

## Create an Oracle Database Credentials Rotation in Infisical

<Tabs>
  <Tab title="Infisical UI">
    1. Navigate to your Secret Manager Project's Dashboard and select **Add Secret Rotation** from the actions dropdown.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/generic/add-secret-rotation.png" alt="Secret Manager Dashboard" />

    2. Select the **OracleDB Credentials** option.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/oracledb-credentials/select-oracledb-credentials-option.png" alt="Select OracleDB Credentials" />

    3. Select the **OracleDB Connection** to use and configure the rotation behavior. Then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/oracledb-credentials/oracledb-credentials-configuration.png" alt="Rotation Configuration" />

       * **OracleDB Connection** - the connection that will perform the rotation of the configured database user credentials.
       * **Rotation Interval** - the interval, in days, that once elapsed will trigger a rotation.
       * **Rotate At** - the local time of day when rotation should occur once the interval has elapsed.
       * **Auto-Rotation Enabled** - whether secrets should automatically be rotated once the rotation interval has elapsed. Disable this option to manually rotate secrets or pause secret rotation.

    4. Input the usernames of the database users created above that will be used for rotation. Then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/oracledb-credentials/oracledb-credentials-parameters.png" alt="Rotation Parameters" />

       * **Database Username 1** - the username of the first user that will be used for rotation.
       * **Database Username 2** - the username of the second user that will be used for rotation.

       <Note>
         If your Oracle usernames were created without "quotes", Oracle sees them as UPPERCASE. Please use UPPERCASE for those names in the fields above.
       </Note>

    5. Specify the secret names that the active credentials should be mapped to. Then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/oracledb-credentials/oracledb-credentials-secrets-mapping.png" alt="Rotation Secrets Mapping" />

       * **Username** - the name of the secret that the active username will be mapped to.
       * **Password** - the name of the secret that the active password will be mapped to.

    6. Give your rotation a name and description (optional). Then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/oracledb-credentials/oracledb-credentials-details.png" alt="Rotation Details" />

       * **Name** - the name of the secret rotation configuration. Must be slug-friendly.
       * **Description** (optional) - a description of this rotation configuration.

    7. Review your configuration, then click **Create Secret Rotation**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/oracledb-credentials/oracledb-credentials-confirm.png" alt="Rotation Review" />

    8. Your **OracleDB Credentials** are now available for use via the mapped secrets.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/oracledb-credentials/oracledb-credentials-created.png" alt="Rotation Created" />
  </Tab>

  <Tab title="API">
    To create a OracleDB Credentials Rotation, make an API request to the [Create OracleDB Credentials Rotation](/api-reference/endpoints/secret-rotations/oracledb-credentials/create) API endpoint.

    ### Sample request

    ```bash Request theme={"dark"}
    curl --request POST \
    --url https://us.infisical.com/api/v2/secret-rotations/oracledb-credentials \
    --header 'Content-Type: application/json' \
    --data '{
        "name": "my-oracledb-rotation",
        "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
        "description": "my database credentials rotation",
        "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
        "environment": "dev",
        "secretPath": "/",
        "isAutoRotationEnabled": true,
        "rotationInterval": 30,
        "rotateAtUtc": {
            "hours": 0,
            "minutes": 0
        },
        "parameters": {
            "username1": "INFISICAL_USER_1",
            "username2": "INFISICAL_USER_2"
        },
        "secretsMapping": {
            "username": "ORACLEDB_USERNAME",
            "password": "ORACLEDB_PASSWORD"
        }
    }'
    ```

    ### Sample response

    ```bash Response theme={"dark"}
    {
        "secretRotation": {
            "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "name": "my-oracledb-rotation",
            "description": "my database credentials rotation",
            "secretsMapping": {
                "username": "ORACLEDB_USERNAME",
                "password": "ORACLEDB_PASSWORD"
            },
            "isAutoRotationEnabled": true,
            "activeIndex": 0,
            "folderId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "createdAt": "2023-11-07T05:31:56Z",
            "updatedAt": "2023-11-07T05:31:56Z",
            "rotationInterval": 30,
            "rotationStatus": "success",
            "lastRotationAttemptedAt": "2023-11-07T05:31:56Z",
            "lastRotatedAt": "2023-11-07T05:31:56Z",
            "lastRotationJobId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "nextRotationAt": "2023-11-07T05:31:56Z",
            "connection": {
                "app": "oracledb",
                "name": "my-oracledb-connection",
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a"
            },
            "environment": {
                "slug": "dev",
                "name": "Development",
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a"
            },
            "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "folder": {
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                "path": "/"
            },
            "rotateAtUtc": {
                "hours": 0,
                "minutes": 0
            },
            "lastRotationMessage": null,
            "type": "oracledb-credentials",
            "parameters": {
                "username1": "INFISICAL_USER_1",
                "username2": "INFISICAL_USER_2"
            }
        }
    }
    ```
  </Tab>
</Tabs>


# Secret Rotation
Source: https://infisical.com/docs/documentation/platform/secret-rotation/overview

Learn how to set up automated secret rotation in Infisical.

## Introduction

Secret rotation is a security best practice that involves systematically updating credentials and access tokens at regular intervals to minimize the risk of compromise. By proactively replacing existing secrets with new ones, organizations reduce the potential impact of credential theft or leakage.

Examples of rotated secrets include:

* API keys and authentication tokens for cloud services and third-party integrations
* Database credentials across production, staging, and development environments

## How Rotation Works

Secret Rotation systematically replaces secrets at regular intervals while ensuring zero downtime for your applications. This overlapping lifecycle approach maintains continuous availability while enhancing your security posture.

### Visual Timeline

```mermaid  theme={"dark"}
gantt
    title Credential Lifecycle (Interval = 30 days)
    dateFormat  YYYY-MM-DD
    axisFormat %b %d

    section Credentials 1
    Active      :active, a1, 2023-01-01, 30d
    Inactive    :done, i1, after a1, 30d
    Revoked     :crit, r1, after i1, 30d

    section Credentials 2
    Active      :active, a2, 2023-01-31, 30d
    Inactive    :done, i2, after a2, 30d
    Revoked     :crit, r2, after i2, 30d

    section Credentials 3
    Active      :active, a3, 2023-03-02, 30d
    Inactive    :done, i3, after a3, 30d
    Revoked     :crit, r3, after i3, 30d
```

### Credential States

Each set of credentials transitions through three distinct states:

* **Active**: The primary credentials that will be used for new connections
* **Inactive**: These credentials are still valid but are no longer issued for new connections

  <Note>
    Some rotation providers utilize a single credential set due to technical constraints. As a result, inactive credentials for these providers will immediately become invalid once rotated.

    To avoid service interruptions, Infisical recommends manually rotating these credentials to prevent downtime.
  </Note>
* **Revoked**: Permanently invalidated and deleted from the system

### Rotation Cycle Example (30-Day Interval)

Using a **30-Day** rotation interval as an example, here's how the process unfolds:

1. **Day 0**
   * `Credential set 1` is issued and set to **Active**
   * Applications begin using this set for authentication

2. **Day 30**

   * `Credential set 2` is issued and set to **Active**
   * `Credential set 1` transitions to **Inactive** but remains valid
   * New connections utilize set 2 while existing connections with set 1 continue to work

   <Note>
     This overlapping validity period ensures that at any point during the active period of a credential set, you are guaranteed that retrieved credentials will be valid for the specified rotation period.
   </Note>

3. **Day 60**
   * `Credential set 3` is issued and set to **Active**
   * `Credential set 2` transitions to **Inactive** but remains valid
   * `Credential set 1` is **Revoked** and securely deleted
   * By now, all applications should have transitioned to using set 2 or 3

4. **Day 90**
   * `Credential set 4` is issued and set to **Active**
   * `Credential set 3` transitions to **Inactive** but remains valid
   * `Credential set 2` is **Revoked** and securely deleted
   * The cycle continues...

### Benefits of This Approach

* **Zero Downtime**: Applications always have valid credentials
* **Grace Period**: The inactive period gives applications time to update to new credentials
* **Reduced Risk**: Credentials are regularly cycled, limiting the impact of potential compromise
* **Predictable Schedule**: Makes credential management more systematic and easier to automate

### Implementation Considerations

* Choose a rotation interval appropriate for your security requirements and operational needs
* Ensure your applications can handle credential updates gracefully
* Monitor for applications still using credentials nearing revocation

## Infisical Secret Rotation Strategies

* [PostgreSQL Credentials](./postgres-credentials)
* [Microsoft SQL Server Credentials](./mssql-credentials)

## FAQ

<AccordionGroup>
  <Accordion title="Why do certain rotations only use a single credential set?">
    Some credential providers have limitations that affect rotation patterns:

    * The third-party provider's API only supports managing one active credential set at a time
    * The specific use-case (such as personal login accounts) is inherently limited to a single active credential

    In either scenario, when service continuity is critical, Infisical recommends disabling auto-rotation and performing manual credential rotation during scheduled maintenance windows.
  </Accordion>
</AccordionGroup>


# PostgreSQL Credentials Rotation
Source: https://infisical.com/docs/documentation/platform/secret-rotation/postgres-credentials

Learn how to automatically rotate PostgreSQL credentials.

## Prerequisites

1. Create a [PostgreSQL Connection](/integrations/app-connections/postgres) with the required **Secret Rotation** permissions

2. Create two designated database users for Infisical to rotate the credentials for. Be sure to grant each user login permissions for the desired database with the necessary privileges their use case will require.

   An example creation statement might look like:

   ```SQL  theme={"dark"}
   -- create user roles
   CREATE USER infisical_user_1 WITH ENCRYPTED PASSWORD 'temporary_password';
   CREATE USER infisical_user_2 WITH ENCRYPTED PASSWORD 'temporary_password';

   -- grant database connection permissions
   GRANT CONNECT ON DATABASE my_database TO infisical_user_1;
   GRANT CONNECT ON DATABASE my_database TO infisical_user_2;

   -- grant relevant table permissions
   GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO infisical_user_1;
   GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO infisical_user_2;
   ```

   <Tip>
     To learn more about PostgreSQL's permission system, please visit their [documentation](https://www.postgresql.org/docs/current/sql-grant.html).
   </Tip>

3. Ensure your network security policies allow incoming requests from Infisical to this rotation provider, if network restrictions apply.

## Create a PostgreSQL Credentials Rotation in Infisical

<Tabs>
  <Tab title="Infisical UI">
    1. Navigate to your Secret Manager Project's Dashboard and select **Add Secret Rotation** from the actions dropdown.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/generic/add-secret-rotation.png" alt="Secret Manager Dashboard" />

    2. Select the **PostgreSQL Credentials** option.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/postgres-credentials/select-postgres-credentials-option.png" alt="Select PostgreSQL Credentials" />

    3. Select the **PostgreSQL Connection** to use and configure the rotation behavior. Then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/postgres-credentials/postgres-credentials-configuration.png" alt="Rotation Configuration" />

       * **PostgreSQL Connection** - the connection that will perform the rotation of the configured database user credentials.
       * **Rotation Interval** - the interval, in days, that once elapsed will trigger a rotation.
       * **Rotate At** - the local time of day when rotation should occur once the interval has elapsed.
       * **Auto-Rotation Enabled** - whether secrets should automatically be rotated once the rotation interval has elapsed. Disable this option to manually rotate secrets or pause secret rotation.

    4. Input the usernames of the database users created above that will be used for rotation. Then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/postgres-credentials/postgres-credentials-parameters.png" alt="Rotation Parameters" />

       * **Database Username 1** - the username of the first user that will be used for rotation.
       * **Database Username 2** - the username of the second user that will be used for rotation.

    5. Specify the secret names that the active credentials should be mapped to. Then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/postgres-credentials/postgres-credentials-secrets-mapping.png" alt="Rotation Secrets Mapping" />

       * **Username** - the name of the secret that the active username will be mapped to.
       * **Password** - the name of the secret that the active password will be mapped to.

    6. Give your rotation a name and description (optional). Then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/postgres-credentials/postgres-credentials-details.png" alt="Rotation Details" />

       * **Name** - the name of the secret rotation configuration. Must be slug-friendly.
       * **Description** (optional) - a description of this rotation configuration.

    7. Review your configuration, then click **Create Secret Rotation**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/postgres-credentials/postgres-credentials-confirm.png" alt="Rotation Review" />

    8. Your **PostgreSQL Credentials** are now available for use via the mapped secrets.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/postgres-credentials/postgres-credentials-created.png" alt="Rotation Created" />
  </Tab>

  <Tab title="API">
    To create a PostgreSQL Credentials Rotation, make an API request to the [Create PostgreSQL
    Credentials Rotation](/api-reference/endpoints/secret-rotations/postgres-credentials/create) API endpoint.

    ### Sample request

    ```bash Request theme={"dark"}
    curl --request POST \
    --url https://us.infisical.com/api/v2/secret-rotations/postgres-credentials \
    --header 'Content-Type: application/json' \
    --data '{
        "name": "my-pg-rotation",
        "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
        "description": "my database credentials rotation",
        "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
        "environment": "dev",
        "secretPath": "/",
        "isAutoRotationEnabled": true,
        "rotationInterval": 30,
        "rotateAtUtc": {
            "hours": 0,
            "minutes": 0
        },
        "parameters": {
            "username1": "infisical_user_1",
            "username2": "infisical_user_2"
        },
        "secretsMapping": {
            "username": "POSTGRES_DB_USERNAME",
            "password": "POSTGRES_DB_PASSWORD"
        }
    }'
    ```

    ### Sample response

    ```bash Response theme={"dark"}
    {
        "secretRotation": {
            "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "name": "my-pg-rotation",
            "description": "my database credentials rotation",
            "secretsMapping": {
                "username": "POSTGRES_DB_USERNAME",
                "password": "POSTGRES_DB_PASSWORD"
            },
            "isAutoRotationEnabled": true,
            "activeIndex": 0,
            "folderId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "createdAt": "2023-11-07T05:31:56Z",
            "updatedAt": "2023-11-07T05:31:56Z",
            "rotationInterval": 30,
            "rotationStatus": "success",
            "lastRotationAttemptedAt": "2023-11-07T05:31:56Z",
            "lastRotatedAt": "2023-11-07T05:31:56Z",
            "lastRotationJobId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "nextRotationAt": "2023-11-07T05:31:56Z",
            "connection": {
                "app": "postgres",
                "name": "my-pg-connection",
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a"
            },
            "environment": {
                "slug": "dev",
                "name": "Development",
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a"
            },
            "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "folder": {
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                "path": "/"
            },
            "rotateAtUtc": {
                "hours": 0,
                "minutes": 0
            },
            "lastRotationMessage": null,
            "type": "postgres-credentials",
            "parameters": {
                "username1": "infisical_user_1",
                "username2": "infisical_user_2"
            }
        }
    }
    ```
  </Tab>
</Tabs>


# Redis Credentials Rotation
Source: https://infisical.com/docs/documentation/platform/secret-rotation/redis-credentials

Learn how to automatically rotate Redis credentials.

## Prerequisites

1. Create a [Redis Connection](/integrations/app-connections/redis) with the required **Secret Rotation** permissions
2. Ensure your network security policies allow incoming requests from Infisical to this rotation provider, if network restrictions apply.

Create a Redis Credentials Rotation in Infisical

<Tabs>
  <Tab title="Infisical UI">
    1. Navigate to your Secret Manager Project's Dashboard and select **Add Secret Rotation** from the actions dropdown.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/generic/add-secret-rotation.png" alt="Secret Manager Dashboard" />

    2. Select the **Redis Credentials** option.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/redis-credentials/select-redis-credentials-option.png" alt="Select Redis Credentials" />

    3. Select the **Redis Connection** to use and configure the rotation behavior. Then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/redis-credentials/redis-credentials-configuration.png" alt="Rotation Configuration" />

       * **Redis Connection** - the connection that will perform the rotation of the configured database user credentials.
       * **Rotation Interval** - the interval, in days, that once elapsed will trigger a rotation.
       * **Rotate At** - the local time of day when rotation should occur once the interval has elapsed.
       * **Auto-Rotation Enabled** - whether secrets should automatically be rotated once the rotation interval has elapsed. Disable this option to manually rotate secrets or pause secret rotation.

    4. Input the password requirements and permission scope for the Redis users that will be created for the rotation. Then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/redis-credentials/redis-credentials-parameters.png" alt="Rotation Parameters" />

       * **Permission Scope** - The scope of the Redis users that will be created for the rotation. This will default to `~* +@all` if not specified.
       * **Password Requirements** - The requirements for the password of the Redis users that will be created for the rotation.

    5. Specify the secret names that the active credentials should be mapped to. Then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/redis-credentials/redis-credentials-secrets-mapping.png" alt="Rotation Secrets Mapping" />

       * **Username** - the name of the secret that the active username will be mapped to.
       * **Password** - the name of the secret that the active password will be mapped to.

    6. Give your rotation a name and description (optional). Then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/redis-credentials/redis-credentials-details.png" alt="Rotation Details" />

       * **Name** - the name of the secret rotation configuration. Must be slug-friendly.
       * **Description** (optional) - a description of this rotation configuration.

    7. Review your configuration, then click **Create Secret Rotation**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/redis-credentials/redis-credentials-confirm.png" alt="Rotation Review" />

    8. Your **Redis Credentials** are now available for use via the mapped secrets.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-rotations-v2/redis-credentials/redis-credentials-created.png" alt="Rotation Created" />
  </Tab>

  <Tab title="API">
    To create a Redis Credentials Rotation, make an API request to the [Create Redis
    Credentials Rotation](/api-reference/endpoints/secret-rotations/redis-credentials/create) API endpoint.

    ### Sample request

    ```bash Request theme={"dark"}
    curl --request POST \
    --url https://us.infisical.com/api/v2/secret-rotations/redis-credentials \
    --header 'Content-Type: application/json' \
    --data '{
      "name": my-redis-rotation",
      "projectId": "<string>",
      "description": "<string>",
      "connectionId": "<redis-connection-id>",
      "environment": "dev|staging|prod",
      "secretPath": "<string>",
      "isAutoRotationEnabled": true,
      "rotationInterval": 2,
      "rotateAtUtc": {
        "hours": 11.5,
        "minutes": 29.5
      },
      "parameters": {
        "passwordRequirements": {
          "length": 64,
          "required": {
            "digits": 1,
            "lowercase": 1,
            "uppercase": 1,
            "symbols": 1
          },
          "allowedSymbols": "@!+"
        },
        "permissionScope": "~* +@all"
      },
      "secretsMapping": {
        "username": "REDIS_USERNAME",
        "password": "REDIS_PASSWORD"
      }
    }'
    ```

    ### Sample response

    ```bash Response theme={"dark"}
    {
        "secretRotation": {
            "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "name": "my-redis-rotation",
            "description": "my database credentials rotation",
            "isAutoRotationEnabled": true,
            "activeIndex": 0,
            "folderId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "createdAt": "2023-11-07T05:31:56Z",
            "updatedAt": "2023-11-07T05:31:56Z",
            "rotationInterval": 30,
            "rotationStatus": "success",
            "lastRotationAttemptedAt": "2023-11-07T05:31:56Z",
            "lastRotatedAt": "2023-11-07T05:31:56Z",
            "lastRotationJobId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "nextRotationAt": "2023-11-07T05:31:56Z",
            "connection": {
                "app": "redis",
                "name": "my-redis-connection",
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a"
            },
            "environment": {
                "slug": "dev",
                "name": "Development",
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a"
            },
            "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "folder": {
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                "path": "/"
            },
            "rotateAtUtc": {
                "hours": 0,
                "minutes": 0
            },
            "lastRotationMessage": null,
            "type": "redis-credentials",
            "parameters": {
                "passwordRequirements": { 
                    "length": 64,
                    "required": {
                        "digits": 1,
                        "lowercase": 1,
                        "uppercase": 1,
                        "symbols": 1
                    },
                    "allowedSymbols": "@!+"
                },
                "permissionScope": "~* +@all"
            },
            "secretsMapping": {
                "username": "REDIS_USERNAME",
                "password": "REDIS_PASSWORD"
            }
        }
    }
    ```
  </Tab>
</Tabs>


# Bitbucket Secret Scanning
Source: https://infisical.com/docs/documentation/platform/secret-scanning/bitbucket

Learn how to configure secret scanning for Bitbucket.

## Prerequisites

* Create a [Bitbucket Connection](/integrations/app-connections/bitbucket) with Secret Scanning permissions

## Create a Bitbucket Data Source in Infisical

<Tabs>
  <Tab title="Infisical UI">
    1. Navigate to your Secret Scanning Project's Dashboard and click the **Add Data Source** button.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/secret-scanning/github/github-data-source-step-1.png" alt="Secret Scanning Dashboard" />

    2. Select the **Bitbucket** option.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/secret-scanning/bitbucket/step-2.png" alt="Select Bitbucket" />

    3. Configure which workspace and repositories you would like to scan. Then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/secret-scanning/bitbucket/step-3.png" alt="Data Source Configuration" />

       * **Bitbucket Connection** - the connection that has access to the repositories you want to scan.
       * **Workspace** - the Bitbucket workspace to scan secrets in.
       * **Scan Repositories** - select which repositories you would like to scan.
         * **All Repositories** - Infisical will scan all repositories associated with your connection.
         * **Select Repositories** - Infisical will scan the selected repositories.
       * **Auto-Scan Enabled** - whether Infisical should automatically perform a scan when a push is made to configured repositories.

    4. Give your data source a name and description (optional). Then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/secret-scanning/bitbucket/step-4.png" alt="Data Source Details" />

       * **Name** - the name of the data source. Must be slug-friendly.
       * **Description** (optional) - a description of this data source.

    5. Review your data source, then click **Create Data Source**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/secret-scanning/bitbucket/step-5.png" alt="Data Source Review" />

    6. Your **Bitbucket Data Source** is now available and will begin a full scan if **Auto-Scan** is enabled.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/secret-scanning/bitbucket/step-6.png" alt="Data Source Created" />

    7. You can view repositories and scan results by clicking on your data source.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/secret-scanning/bitbucket/step-7.png" alt="Data Source Page" />

    8. In addition, you can review any findings from the **Findings Page**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/secret-scanning/bitbucket/step-8.png" alt="Findings Page" />
  </Tab>

  <Tab title="API">
    To create a Bitbucket Data Source, make an API request to the [Create Bitbucket Data Source](/api-reference/endpoints/secret-scanning/data-sources/bitbucket/create) API endpoint.

    ### Sample request

    ```bash Request theme={"dark"}
    curl --request POST \
    --url https://us.infisical.com/api/v2/secret-scanning/data-sources/bitbucket \
    --header 'Content-Type: application/json' \
    --data '{
        "name": "my-bitbucket-source",
        "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
        "description": "my bitbucket data source",
        "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
        "isAutoScanEnabled": true,
        "config": {
            "workspaceSlug": "my-workspace",
            "includeRepos": ["*"]
        }
    }'
    ```

    ### Sample response

    ```bash Response theme={"dark"}
    {
        "dataSource": {
            "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "externalId": "1234567890",
            "name": "my-bitbucket-source",
            "description": "my bitbucket data source",
            "isAutoScanEnabled": true,
            "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "createdAt": "2023-11-07T05:31:56Z",
            "updatedAt": "2023-11-07T05:31:56Z",
            "type": "bitbucket",
            "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "connection": {
                "app": "bitbucket",
                "name": "my-bitbucket-app",
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a"
            },
            "config": {
                "workspaceSlug": "my-workspace",
                "includeRepos": ["*"]
            }
        }
    }
    ```
  </Tab>
</Tabs>


# Secrets Scanning
Source: https://infisical.com/docs/documentation/platform/secret-scanning/concepts/secret-scanning

Learn what is secret scanning and why it matters for building secure systems.

## What is Secret Scanning?

*Secret scanning* is the process of monitoring code and related systems for exposed secrets  such as API keys, database credentials, and authentication tokens  that may have been accidentally committed or leaked.

As teams grow and development accelerates, it becomes easy for secrets to slip into version control, CI/CD pipelines, or shared files. Left undetected, secrets can fall into the wrong hands and give attackers direct access to production systems, third-party services, or internal APIs.

A secret scanning solution helps teams proactively identify and respond to these risks before they result in compromise. Rather than relying on manual review, secret scanning automates detection through pattern matching, entropy analysis, and contextual rules that surface secrets across your infrastructure and repositories.

## Secret Scanning in Infisical

Infisical Secret Scanning continuously monitors your source code and connected systems for exposed credentials. It integrates with platforms like [GitHub](/documentation/platform/secret-scanning/github), [GitLab](/documentation/platform/secret-scanning/gitlab), and [Bitbucket](/documentation/platform/secret-scanning/bitbucket) to scan codebases in real-time, detecting leaks as they happen and notifying administrators when action is needed.

Findings are surfaced with detailed context  including file location, commit metadata, and rule match  and can be tracked through their lifecycle using status labels like `Resolved`, `False Positive`, or `Ignored`. Teams can configure rules, exclusions, and thresholds to reduce noise and tailor detection to their environment.

In addition to real-time monitoring, Infisical supports both full repository scans and lightweight diff scans, as well as local pre-commit scanning via the [Infisical CLI](/cli/commands/scan). This allows teams to prevent secret leaks before they ever reach production.


# GitHub Secret Scanning
Source: https://infisical.com/docs/documentation/platform/secret-scanning/github

Learn how to configure secret scanning for GitHub.

## Prerequisites

* Create a [GitHub Radar Connection](/integrations/app-connections/github-radar)

## Create a GitHub Data Source in Infisical

<Tabs>
  <Tab title="Infisical UI">
    1. Navigate to your Secret Scanning Project's Dashboard and click the **Add Data Source** button.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/secret-scanning/github/github-data-source-step-1.png" alt="Secret Scanning Dashboard" />

    2. Select the **GitHub** option.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/secret-scanning/github/github-data-source-step-2.png" alt="Select GitHub Option" />

    3. Select the **GitHub Radar Connection** to use and configure which repositories you would like to scan. Then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/secret-scanning/github/github-data-source-step-3.png" alt="Data Source Configuration" />

       * **GitHub Radar Connection** - the connection that has access to the repositories you want to scan.
       * **Scan Repositories** - select which repositories you would like to scan.
         * **All Repositories** - Infisical will scan all repositories associated with your connection.
         * **Select Repositories** - Infisical will scan the selected repositories.
       * **Auto-Scan Enabled** - whether Infisical should automatically perform a scan when a push is made to configured repositories.

    4. Give your data source a name and description (optional). Then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/secret-scanning/github/github-data-source-step-4.png" alt="Data Source Details" />

       * **Name** - the name of the data source. Must be slug-friendly.
       * **Description** (optional) - a description of this data source.

    5. Review your data source, then click **Create Data Source**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/secret-scanning/github/github-data-source-step-5.png" alt="Data Source Review" />

    6. Your **GitHub Data Source** is now available and will begin a full scan if **Auto-Scan** is enabled.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/secret-scanning/github/github-data-source-step-6.png" alt="Data Source Created" />

    7. You can view repositories and scan results by clicking on your data source.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/secret-scanning/github/github-data-source-step-7.png" alt="Data Source Page" />

    8. In addition, you can review any findings from the **Findings Page**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/secret-scanning/github/github-data-source-step-8.png" alt="Findings Page" />
  </Tab>

  <Tab title="API">
    To create a GitHub Data Source, make an API request to the [Create GitHub Data Source](/api-reference/endpoints/secret-scanning/data-sources/github/create) API endpoint.

    ### Sample request

    ```bash Request theme={"dark"}
    curl --request POST \
    --url https://us.infisical.com/api/v2/secret-scanning/data-sources/github \
    --header 'Content-Type: application/json' \
    --data '{
        "name": "my-github-source",
        "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
        "description": "my github data source",
        "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
        "isAutoScanEnabled": true,
        "config": {
            "includeRepos": ["*"]
        }
    }'
    ```

    ### Sample response

    ```bash Response theme={"dark"}
    {
        "dataSource": {
            "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "externalId": "1234567890",
            "name": "my-github-source",
            "description": "my github data source",
            "isAutoScanEnabled": true,
            "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "createdAt": "2023-11-07T05:31:56Z",
            "updatedAt": "2023-11-07T05:31:56Z",
            "type": "github",
            "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "connection": {
                "app": "github-radar",
                "name": "my-radar-app",
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a"
            },
            "config": {
                "includeRepos": ["*"]
            }
        }
    }
    ```
  </Tab>
</Tabs>


# GitLab Secret Scanning
Source: https://infisical.com/docs/documentation/platform/secret-scanning/gitlab

Learn how to configure secret scanning for GitLab.

## Prerequisites

* Create a [GitLab Connection](/integrations/app-connections/gitlab) with Secret Scanning permissions

## Create a GitLab Data Source in Infisical

<Tabs>
  <Tab title="Infisical UI">
    1. Navigate to your Secret Scanning Project's Dashboard and click the **Add Data Source** button.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/secret-scanning/github/github-data-source-step-1.png" alt="Secret Scanning Dashboard" />

    2. Select the **GitLab** option.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/secret-scanning/gitlab/step-2.png" alt="Select GitLab" />

    3. Configure which workspace and repositories you would like to scan. Then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/secret-scanning/gitlab/step-3.png" alt="Data Source Configuration" />

       * **GitLab Connection** - the connection that has access to the repositories you want to scan.
       * **Scope** - the GitLab scope to scan secrets in.
         * **Project** - scan an individual GitLab project.
         * **Group** - scan one or more projects belonging to a GitLab group.
       * **Scan Repositories** - when using **Group Scope**, select which repositories you would like to scan.
         * **All Repositories** - Infisical will scan all repositories associated with your connection.
         * **Select Repositories** - Infisical will scan the selected repositories.
       * **Auto-Scan Enabled** - whether Infisical should automatically perform a scan when a push is made to configured repositories.

    4. Give your data source a name and description (optional). Then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/secret-scanning/gitlab/step-4.png" alt="Data Source Details" />

       * **Name** - the name of the data source. Must be slug-friendly.
       * **Description** (optional) - a description of this data source.

    5. Review your data source, then click **Create Data Source**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/secret-scanning/gitlab/step-5.png" alt="Data Source Review" />

    6. Your **GitLab Data Source** is now available and will begin a full scan if **Auto-Scan** is enabled.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/secret-scanning/gitlab/step-6.png" alt="Data Source Created" />

    7. You can view repositories and scan results by clicking on your data source.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/secret-scanning/gitlab/step-7.png" alt="Data Source Page" />

    8. In addition, you can review any findings from the **Findings Page**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/secret-scanning/gitlab/step-8.png" alt="Findings Page" />
  </Tab>

  <Tab title="API">
    To create a GitLab Data Source, make an API request to the [Create GitLab Data Source](/api-reference/endpoints/secret-scanning/data-sources/gitlab/create) API endpoint.

    ### Sample request

    ```bash Request theme={"dark"}
    curl --request POST \
    --url https://us.infisical.com/api/v2/secret-scanning/data-sources/gitlab \
    --header 'Content-Type: application/json' \
    --data '{
        "name": "my-gitlab-source",
        "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
        "description": "my gitlab data source",
        "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
        "isAutoScanEnabled": true,
        "config": {
            "scope": "project",
            "projectId": 123456789,
            "projectName": "my-group/my-project"
        }
    }'
    ```

    ### Sample response

    ```bash Response theme={"dark"}
    {
        "dataSource": {
            "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "externalId": "1234567890",
            "name": "my-gitlab-source",
            "description": "my gitlab data source",
            "isAutoScanEnabled": true,
            "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "createdAt": "2023-11-07T05:31:56Z",
            "updatedAt": "2023-11-07T05:31:56Z",
            "type": "gitlab",
            "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "connection": {
                "app": "gitlab",
                "name": "my-gitlab-app",
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a"
            },
            "config": {
                "scope": "project",
                "projectId": 123456789,
                "projectName": "my-group/my-project"
            }
        }
    }
    ```
  </Tab>
</Tabs>


# Secret Scanning
Source: https://infisical.com/docs/documentation/platform/secret-scanning/overview

Learn how to detect and respond to exposed secrets in code.

Infisical Secret Scanning helps teams detect leaked credentials  such as API keys, database passwords, and tokens  across source code and developer systems. It allows organizations to proactively catch exposed secrets before they can be exploited, and respond quickly when incidents occur.

Secret Scanning works across both cloud-connected repositories and local developer environments. It integrates with data sources like [GitHub](/documentation/platform/secret-scanning/github), [GitLab](/documentation/platform/secret-scanning/gitlab), and [Bitbucket](/documentation/platform/secret-scanning/bitbucket) to monitor repositories for exposed secrets in real time, and provides a CLI ([`infisical scan`](/cli/commands/scan)) for scanning local directories, Git history, or CI pipelines before changes are pushed.

Core capabilities include:

* Integrated Scanning Across Environments: Monitor secrets in real time across connected repositories like GitHub, GitLab, and Bitbucket, or scan locally using the infisical scan CLI.
* Detection Engine: Identify potential secrets using pattern matching, entropy analysis, and custom rules tailored to your codebase and workflows.
* Flexible Scan Modes: Run full scans manually or configure automatic diff scans triggered by new commits. CLI scans support Git history, file directories, or staged changes in CI pipelines.
* Findings and Lifecycle Management: Track detected secrets with context like file path, commit hash, and scanning rule. Findings can be resolved, ignored, or marked as false positives  with full visibility into scan results over time.
* Custom Configuration and Noise Reduction: Fine-tune scanning behavior with custom patterns, ignore rules (infisical-scan:ignore, .infisicalignore), entropy thresholds, and excluded paths to reduce false positives.


# Usage
Source: https://infisical.com/docs/documentation/platform/secret-scanning/usage

Learn what is secret scanning and why it matters for building secure systems.

## Introduction

Monitor and detect exposed secrets across your data sources, including code repositories, with Infisical Secret Scanning.

For additional security, we recommend using our [CLI Secret Scanner](/cli/scanning-overview#automatically-scan-changes-before-you-commit) to check for exposed secrets before pushing your code changes.

<Note>
  Secret Scanning is a paid feature. If you're using Infisical Cloud, then it is
  available under the **Enterprise Tier**. If you're self-hosting Infisical,
  then you should contact [team@infisical.com](mailto:team@infisical.com) to purchase an enterprise license
  to use it.
</Note>

## How Secret Scanning Works

Secret Scanning consists of several components that enable you to quickly respond to secret leaks:

* **Scanner Engine**: The core component that analyzes your code and detects potential secrets using pattern matching and entropy analysis
* **Real-time Monitoring**: Provides continuous surveillance of your repositories for immediate detection of exposed secrets
* **Alert System**: Notifies organization admins via email when secrets are detected
* **Risk Management**: Allows tracking and managing detected secrets with different status options
* **Data Sources**: Integrates with various data sources and version control systems
* **Customizable Rules**: Supports ignore patterns and custom configurations to reduce false positives

These components work together to provide comprehensive secret detection and incident response capabilities.

### Data Sources

Data sources are configured integrations with external platforms, such as a GitHub organization or a GitLab group, that establish secure connections for scanning purposes using [App Connections](/integrations/app-connections/overview).

A data source acts as a secure intermediary between the external system and the scanner engine. It manages a collection of scannable resources (such as repositories) and handles the authentication and communication required for scanning operations.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/secret-scanning/secret-scanning-data-sources.png" alt="data sources" />

### Resources

Resources are the atomic, scannable units, such as a repository, that can be monitored for secret exposure. Resources are added automatically when a data source is scanned and updated when scanning events are triggered, such as when a user pushes changes to GitHub.

Each resource maintains its own scanning history and status, allowing for granular monitoring and management of secret scanning across your organization.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/secret-scanning/secret-scanning-resources.png" alt="resources" />

### Scans

Scans can be initiated in two ways:

1. **Full Scan** - Manually triggered scan that comprehensively checks either all resources associated with a data source or a single selected resource.

2. **Diff Scan** - Automatically executed when **Auto-Scan** is enabled on a data source. This scan type specifically focuses on updates to existing resources.

All scan activities can be monitored in real-time through the Infisical UI, which displays:

* Current scan status
* Timestamp of the scan
* Resource(s) being scanned
* Detection results (whether any secrets were found)

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/secret-scanning/secret-scanning-scans.png" alt="scans" />

### Findings

Findings are automatically generated when secret leaks are detected during scanning operations. Each finding contains comprehensive information including:

* The specific scanning rule that identified the leak
* File location and line number where the secret was found
* Resource-specific details (e.g., commit hash and author for Git repositories)

Findings are initially marked as **Unresolved** and can be updated to one of the following statuses with additional remarks:

* **Resolved** - The issue has been addressed
* **False Positive** - The detection was incorrect
* **Ignore** - The finding can be safely disregarded

These status options help teams effectively track and manage the lifecycle of detected secret leaks.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/secret-scanning/secret-scanning-findings.png" alt="findings" />

### Configuration

You can configure custom scanning rules and exceptions by updating your project's scanning configuration via the UI or API.

The configuration options allow you to:

* Define custom scanning patterns and rules
* Set up ignore patterns to reduce false positives
* Specify file path exclusions
* Configure entropy thresholds for secret detection
* Add allowlists for known safe patterns

For detailed configuration options, expand the example configuration below.

<Accordion title="Example Configuration">
  ```toml  theme={"dark"}
  # Title for the configuration file
  title = "Some title"

  # This configuration is the foundation that can be expanded. If there are any overlapping rules
  # between this base and the expanded configuration, the rules in this base will take priority.
  # Another aspect of extending configurations is the ability to link multiple files, up to a depth of 2.
  # "Allowlist" arrays get appended and may have repeated elements.
  # "useDefault" and "path" cannot be used simultaneously. Please choose one.
  [extend]
  # useDefault will extend the base configuration with the default config:
  # https://raw.githubusercontent.com/Infisical/infisical/main/cli/config/infisical-scan.toml
  useDefault = true
  # or you can supply a path to a configuration. Path is relative to where infisical cli
  # was invoked, not the location of the base config.
  path = "common_config.toml"

  # An array of tables that contain information that define instructions
  # on how to detect secrets
  [[rules]]

  # Unique identifier for this rule
  id = "some-identifier-for-rule"

  # Short human readable description of the rule.
  description = "awesome rule 1"

  # Golang regular expression used to detect secrets. Note Golang's regex engine
  # does not support lookaheads.
  regex = '''one-go-style-regex-for-this-rule'''

  # Golang regular expression used to match paths. This can be used as a standalone rule or it can be used
  # in conjunction with a valid `regex` entry.
  path = '''a-file-path-regex'''

  # Array of strings used for metadata and reporting purposes.
  tags = ["tag","another tag"]

  # A regex match may have many groups, this allows you to specify the group that should be used as (which group the secret is contained in)
  # its entropy checked if `entropy` is set.
  secretGroup = 3

  # Float representing the minimum shannon entropy a regex group must have to be considered a secret.
  # Shannon entropy measures how random a data is. Since secrets are usually composed of many random characters, they typically have high entropy
  entropy = 3.5

  # Keywords are used for pre-regex check filtering.
  # If rule has keywords but the text fragment being scanned doesn't have at least one of it's keywords, it will be skipped for processing further.
  # Ideally these values should either be part of the identifier or unique strings specific to the rule's regex
  # (introduced in v8.6.0)
  keywords = [
      "auth",
      "password",
      "token",
  ]

  # You can include an allowlist table for a single rule to reduce false positives or ignore commits
  # with known/rotated secrets
  [rules.allowlist]
  description = "ignore commit A"
  commits = [ "commit-A", "commit-B"]
  paths = [
      '''go\.mod''',
      '''go\.sum'''
  ]
  # note: (rule) regexTarget defaults to check the _Secret_ in the finding.
  # if regexTarget is not specified then _Secret_ will be used.
  # Acceptable values for regexTarget are "match" and "line"
  regexTarget = "match"
  regexes = [
      '''process''',
      '''getenv''',
  ]
  # note: stopwords targets the extracted secret, not the entire regex match
  # if the extracted secret is found in the stopwords list, the finding will be skipped (i.e not included in report)
  stopwords = [
      '''client''',
      '''endpoint''',
  ]


  # This is a global allowlist which has a higher order of precedence than rule-specific allowlists.
  # If a commit listed in the `commits` field below is encountered then that commit will be skipped and no
  # secrets will be detected for said commit. The same logic applies for regexes and paths.
  [allowlist]
  description = "global allow list"
  commits = [ "commit-A", "commit-B", "commit-C"]
  paths = [
      '''gitleaks\.toml''',
      '''(.*?)(jpg|gif|doc)'''
  ]

  # note: (global) regexTarget defaults to check the _Secret_ in the finding.
  # if regexTarget is not specified then _Secret_ will be used.
  # Acceptable values for regexTarget are "match" and "line"
  regexTarget = "match"

  regexes = [
      '''219-09-9999''',
      '''078-05-1120''',
      '''(9[0-9]{2}|666)-\d{2}-\d{4}''',
  ]
  # note: stopwords targets the extracted secret, not the entire regex match
  # if the extracted secret is found in the stopwords list, the finding will be skipped (i.e not included in report)
  stopwords = [
      '''client''',
      '''endpoint''',
  ]
  ```
</Accordion>

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/secret-scanning/secret-scanning-config.png" alt="config" />

## Ignoring Known Secrets

If you're intentionally committing a test secret that the secret scanner might flag, you can instruct Infisical to overlook that secret with the methods listed below.

### infisical-scan:ignore

To ignore a secret contained in line of code, simply add `infisical-scan:ignore ` at the end of the line as comment in the given programming.

```js example.js theme={"dark"}
function helloWorld() {
  console.log("8dyfuiRyq=vVc3RRr_edRk-fK__JItpZ"); // infisical-scan:ignore
}
```

### .infisicalignore

An alternative method to exclude specific findings involves creating a .infisicalignore file at your repository's root.
You can then add the fingerprints of the findings you wish to exclude. The [Infisical scan](/cli/scanning-overview) report provides a unique Fingerprint for each secret found.
By incorporating these Fingerprints into the .infisicalignore file, Infisical will skip the corresponding secret findings in subsequent scans.

```.ignore .infisicalignore theme={"dark"}
bea0ff6e05a4de73a5db625d4ae181a015b50855:frontend/components/utilities/attemptLogin.js:stripe-access-token:147
bea0ff6e05a4de73a5db625d4ae181a015b50855:backend/src/json/integrations.json:generic-api-key:5
1961b92340e5d2613acae528b886c842427ce5d0:frontend/components/utilities/attemptLogin.js:stripe-access-token:148
```


# Secret Sharing
Source: https://infisical.com/docs/documentation/platform/secret-sharing

Learn how to share time & view-count bound secrets securely with anyone on the internet.

Developers frequently need to share secrets with team members, contractors, or other third parties, which can be risky due to potential leaks or misuse.
Infisical offers a secure solution for sharing secrets over the internet in a time and view-count bound manner. It is possible to share secrets without signing up via [share.infisical.com](https://share.infisical.com) or via Infisical Dashboard (which has more advanced functionality).

## Sharing a Secret

<Steps>
  <Step title="Navigate to the 'Secret Sharing' page and click 'Share Secret'">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/secret-sharing/overview.png" alt="Secret Sharing" />
  </Step>

  <Step title="Configure Secret Share">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/secret-sharing/create-new-secret.png" alt="Configure Secret" />

    * **Name (optional):** A friendly name for the shared secret.

    * **Your Secret:** The secret content.

    * **Password (optional):** A password which will be required when viewing the secret.

    * **Limit access to people within organization:** Only lets people within your organization view the secret. Enabling this feature requires secret viewers to log into Infisical.

    * **Expires In:** The time it'll take for the secret to expire.

    * **Max Views:** How many times the secret can be viewed before it's destroyed.

    * **Authorized Emails (optional):** Emails which are authorized to view this secret. Enabling this feature requires secret viewers to log into Infisical. Each email will receive the shared secret link in their inbox after creation.
  </Step>

  <Step title="Copy Link and Share Secret">
    After creating the shared secret, its link will be displayed. Share this with the intended recipients.

    <Info>
      If no organization or email restrictions are set, anyone with this link can view the secret before it expires.
    </Info>

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/secret-sharing/copy-url.png" alt="Copy URL" />
  </Step>

  <Step title="Access Shared Secret">
    Visiting the secret link will display its contents.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/secret-sharing/public-view.png" alt="Access Shared Secret" />
  </Step>
</Steps>

## Deleting a Shared Secret

To delete a shared secret, click the **Trash Can** icon on the relevant shared secret row in the [**Secret Sharing**](https://app.infisical.com/organization/secret-sharing?selectedTab=share-secret) page.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/secret-sharing/delete-secret.png" alt="Delete Secret" />

## FAQ

<AccordionGroup>
  <Accordion title="Can secrets be changed after they are shared?">
    No, secrets cannot be changed after they've been created. This is to ensure that secrets are not tampered with.
  </Accordion>
</AccordionGroup>


# Secret Versioning
Source: https://infisical.com/docs/documentation/platform/secret-versioning

Learn how secret versioning works in Infisical.

Every time a secret change is performed, a new version of the same secret is created.

Such versions can be accessed visually by opening up the [secret sidebar](/documentation/platform/project#drawer) (as seen below) or [retrieved via API](/api-reference/endpoints/secrets/read)
by specifying the `version` query parameter.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/secret-versioning-overview.png" alt="secret versioning overview" />
<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/secret-versioning.png" alt="secret versioning" />

The secret versioning functionality is heavily connected to [Point-in-time Recovery](/documentation/platform/pit-recovery) of secrets in Infisical.

<Note>
  You can copy and paste a secret version value to the "Value" input field "roll
  back" to that secret version. This creates a new secret version at the top of
  the stack. We're releasing the ability to automatically roll back to
  a secret version soon.
</Note>


# Scoping Secrets
Source: https://infisical.com/docs/documentation/platform/secrets-mgmt/concepts/access-control

Learn how access to secrets is controlled in Infisical.

## Secret Hierarchy

Every secret in Infisical is scoped to an environment and a path.

* An environment separates where secrets are used, such as `development`, `staging`, or `production`.
* A path is an (optional) namespace within an environment that groups related secrets such as `/postgres`, `/redis`, or per-service paths like `/service-a`.

This structure makes it easy to organize secrets by team, service, or environment, and sets the foundation for controlling who can access what.

## Access Control

Access control determines who (or what) can access a secret and under what conditions. Without clear policies, even securely stored secrets can be misused or exposed.

To control access to secrets, you configure role-based permissions at the project level. These permissions determine which environments and paths a user or machine identity with that role can access. For example, an engineer might have a role that allows them to read secrets in the `development` environment but not those in the `production` environment.

This model follows the [principle of least privilege](https://en.wikipedia.org/wiki/Principle_of_least_privilege) such that each user or machine identity has access only to the secrets it needs  and nothing more.

## Advanced Capabilities

Beyond basic role assignments, Infisical includes additional access control mechanisms for more advanced use cases:

* Access approvals: Users can request access to specific environments or paths. Access can be temporary and reviewed before it is granted, reducing long-term exposure.

* Secret change approvals: Updates to sensitive secrets can require approval before taking effect. This adds control in environments where unreviewed changes pose risk.

* Attribute-based access control (ABAC): Permissions can be matched against metadata on a user or machine identity  such as team, service, or environment  enabling dynamic access rules without manual role changes.

All access and approval actions are logged, so its always possible to trace who accessed what, when, and under what conditions.


# Dynamic Secrets
Source: https://infisical.com/docs/documentation/platform/secrets-mgmt/concepts/dynamic-secrets

Learn what dynamic secrets are, why they're useful, and how Infisical enables them.

## What is a Dynamic Secret?

A *dynamic secret* is a time-bound credential generated on demand for a specific user or system. Unlike *static secrets*, which are created and stored ahead of time, or rotated credentials, which are periodically replaced, dynamic secrets dont exist until theyre requested  and automatically expire shortly after use.

Each secret is unique to the identity that requested it, reducing the risk of reuse, long-term exposure, or accidental leaks. Because they are short-lived and tightly scoped, dynamic secrets are well suited for high-security environments, automated systems, and ephemeral workloads where access needs to be both temporary and auditable.

By limiting the lifespan and visibility of credentials, dynamic secrets offer a strong alternative to managing long-lived secrets manually.

## Dynamic Secrets in Infisical

Infisical generates dynamic secrets in real time when a user or machine identity requests access. Each secret is uniquely scoped to the requesting identity, valid just-in-time only for a limited duration, and automatically revoked after it expires.

Because they are short-lived and identity-specific, dynamic secrets reduce the risk of credential reuse, accidental exposure, or long-term persistence across environments.

When supported for a given integration, using dynamic secrets is strongly recommended. Infisical currently supports dynamic secret templates for commonly used systems including [PostgreSQL](/documentation/platform/dynamic-secrets/postgresql), [MySQL](/documentation/platform/dynamic-secrets/mysql), [Microsoft SQL Server](/documentation/platform/dynamic-secrets/mssql), [MongoDB Atlas](/documentation/platform/dynamic-secrets/mongo-db), [Redis](/documentation/platform/dynamic-secrets/redis), [AWS IAM](/documentation/platform/dynamic-secrets/aws-iam), [GCP IAM](/documentation/platform/dynamic-secrets/gcp-iam), [Azure Entra ID](/documentation/platform/dynamic-secrets/azure-entra-id), and more.

To learn more, refer to the [dynamic secrets documentation](/documentation/platform/dynamic-secrets/overview).


# Fetching Secrets
Source: https://infisical.com/docs/documentation/platform/secrets-mgmt/concepts/secrets-delivery

Learn how to deliver secrets from Infisical into the systems, applications, and environments that need them.

Once secrets are stored and scoped in Infisical, the next step is delivering them securely to the systems and applications that need them.

Infisical supports many delivery methods to match a wide range of environments  from [local development](/documentation/platform/secrets-mgmt/concepts/secrets-delivery#local-development%2C-scripts%2C-and-one-off-tasks) to [Kubernetes workloads](/documentation/platform/secrets-mgmt/concepts/secrets-delivery#kubernetes-workloads), [CI/CD pipelines](/documentation/platform/secrets-mgmt/concepts/secrets-delivery#ci%2Fcd-pipelines), [infrastructure-as-code tools](/documentation/platform/secrets-mgmt/concepts/secrets-delivery#infrastructure-as-code-and-automation-tools), and more.

The table below provides a quick overview of which delivery method may be suitable to use based on your environment and how secrets are consumed:

| Use Case / Environment                                | Recommended Method(s)                                                                                                                         | Consumes Secrets As          | Notes                                                              |
| ----------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------- | ------------------------------------------------------------------ |
| Local development or scripting                        | [Infisical CLI](/cli/overview)                                                                                                                | Environment variables        | Easiest way to inject secrets during local dev or debugging        |
| Application code fetching at runtime                  | [SDKs](/sdks/overview), [HTTP API](/api-reference/overview/introduction)                                                                      | In-memory / API call         | Full control in app code; supports dynamic or ephemeral fetching   |
| VMs, containers, or CI jobs needing preloaded secrets | [Infisical Agent](/integrations/platforms/infisical-agent)                                                                                    | Env vars or files            | Good for non-interactive workloads; avoids inline secret fetch     |
| GitHub Actions                                        | [Secrets Action](https://github.com/Infisical/secrets-action), [Secret Syncs](/integrations/secret-syncs/github)                              | Env vars or files            | Use Action for dynamic fetch; use Syncs to preload into GitHub     |
| GitLab CI, Jenkins, other CI                          | [Infisical CLI](/cli/overview), [Infisical Agent](/integrations/platforms/infisical-agent), [Secret Syncs](/integrations/secret-syncs/gitlab) | Env vars or files            | Choose based on timing  fetch at runtime vs. pre-populate ahead   |
| Kubernetes (declarative secrets)                      | [Kubernetes Operator](/integrations/platforms/kubernetes/overview)                                                                            | Kubernetes Secrets           | Syncs from Infisical into native Kubernetes Secrets                |
| Kubernetes (ESO-based workflows)                      | [External Secrets Operator (ESO)](https://external-secrets.io/latest/provider/infisical/)                                                     | Kubernetes Secrets           | Reuses existing ESO setup; Infisical acts as a provider            |
| Kubernetes (file-based, no K8s secrets)               | [Kubernetes Agent Injector](/integrations/platforms/kubernetes-injector)                                                                      | Mounted files                | Injects secrets via init container into volume at pod startup      |
| Kubernetes (file-based, with rotation)                | [Kubernetes CSI Provider](/integrations/platforms/kubernetes-csi)                                                                             | Mounted files                | Uses CSI driver to mount secrets as files with automatic rotation  |
| Image builds (VMs or containers)                      | [Packer Plugin](/integrations/frameworks/packer)                                                                                              | Env vars or files            | Inject secrets at image build time                                 |
| Ansible automation                                    | [Ansible Collection](/integrations/platforms/ansible)                                                                                         | Variables                    | Runtime secret fetching in playbooks using lookup plugin           |
| Terraform / Pulumi                                    | [Terraform Provider](https://registry.terraform.io/providers/Infisical/infisical/latest/docs), [Pulumi](/integrations/frameworks/pulumi)      | Inputs / ephemeral resources | Use ephemeral for security; avoids storing secrets in state        |
| Third-party platforms (GitHub, AWS, etc.)             | [Secret Syncs](/integrations/secret-syncs/overview)                                                                                           | Preloaded secrets            | Push secrets to platforms that can't fetch directly from Infisical |

From here, you can explore the delivery method that best matches your environment:

## Local Development, Scripts, and One-Off Tasks

For local development, one-off scripts, or basic automation, the [Infisical CLI](/cli/overview) is a quick and flexible option.

Instead of using a `.env` file, you can use [`infisical run`](/cli/commands/run) to inject secrets as environment variables directly into your development process. This provides a cleaner and more secure workflow. You can also use [`infisical secrets`](/cli/commands/secrets#infisical-secrets) to perform CRUD operations on secrets from the command line, which works well for debugging, local tooling, and lightweight scripting.

To learn more, refer to the [CLI quickstart](cli/usage).

## Applications and Services

When secrets need to be accessed directly from within application code, Infisical provides SDKs for [Node.js](https://github.com/Infisical/node-sdk-v2), [Python](https://github.com/Infisical/python-sdk-official), [Go](/sdks/languages/go), [Java](https://github.com/Infisical/java-sdk), [.NET](https://github.com/Infisical/infisical-dotnet-sdk), [C++](https://github.com/Infisical/infisical-cpp-sdk), [Rust](https://github.com/Infisical/rust-sdk), and [Ruby](/sdks/languages/ruby).

These SDKs let services fetch secrets at runtime or startup. For unsupported languages or if you prefer direct integration, you can use the fully documented [HTTP API](/api-reference/overview/introduction) to fetch secrets within your application logic.

This approach gives you fine-grained control but also requires managing authentication and caching.

## Virtual Machines(VMs), Containers, and CI Environments

For systems that shouldnt fetch secrets themselves  such as production VMs, Docker containers, or CI jobs  the [Infisical Agent](/integrations/platforms/infisical-agent) can be used to sync secrets into the local environment on their behalf.

The agent runs as a lightweight background process and supports injecting secrets into files, environment variables, or application config formats. It's especially useful for non-interactive workloads that expect secrets to already exist at runtime.

You can run the agent as a standalone binary, as a Docker sidecar, or embedded in automation scripts. It works well in environments like:

* VMs that need secrets provisioned at startup.
* [Docker Swarm](/integrations/platforms/docker-swarm-with-agent) services using shared volumes.
* [ECS tasks](/integrations/platforms/ecs-with-agent) using EFS for shared secret delivery.

## CI/CD Pipelines

For CI/CD pipelines, the right method depends on the platform.

* On GitHub Actions, the [Infisical Secrets Action](https://github.com/Infisical/secrets-action) provides a native integration that injects secrets as environment variables or `.env` files during workflows. It supports authentication via [AWS IAM](/documentation/platform/identities/aws-auth), [OIDC](/documentation/platform/identities/oidc-auth/github), or [Universal Auth](/documentation/platform/identities/universal-auth) using a Machine Identity.
* On other CI platforms like GitLab CI, CircleCI, or Jenkins, the CLI or Agent may be used depending on how secrets are consumed  whether at runtime or during setup.

Some CI/CD systems also support [Secret Syncs](/integrations/secret-syncs/overview) as an alternative. Instead of fetching secrets dynamically, you can configure Infisical to forward secrets into [GitHub Actions](/integrations/secret-syncs/github), [GitLab CI](/integrations/secret-syncs/gitlab), and similar platforms ahead of time  allowing them to be used as native environment secrets during jobs.

## Kubernetes Workloads

Infisical supports multiple options for delivering secrets into Kubernetes, each designed to match different operational models and consumption patterns:

* [Infisical Kubernetes Operator](/integrations/platforms/kubernetes/overview): A set of CRDs that sync secrets from Infisical into Kubernetes Secrets, push secrets from Kubernetes back to Infisical, and manage dynamic secrets with automatic leases. Best suited for teams using declarative workflows and wanting to treat secrets as part of infrastructure code.

* [External Secrets Operator (ESO)](https://external-secrets.io/latest/provider/infisical/): Enables syncing Infisical secrets into Kubernetes by defining ExternalSecret resources. Ideal if your team already uses ESO as a centralized way to fetch secrets from multiple providers.

* [Infisical Agent Injector](/integrations/platforms/kubernetes-injector): A Kubernetes mutating admission webhook that injects an init container into your pods. The injected container syncs secrets from Infisical into a shared volume at startup, making them available as files. Useful for workloads that expect file-based secrets and where avoiding Kubernetes Secrets entirely is preferred.

* [Infisical CSI Provider](/integrations/platforms/kubernetes-csi): Integrates with the Kubernetes Secrets Store CSI Driver to mount secrets as files in pods. Supports automatic rotation and fine-grained control over how secrets are structured and updated. Suitable for environments that require file-based secret delivery with rotation, without persisting Kubernetes Secrets.

These methods provide secure, declarative integrations with Kubernetes-native workflows.

## Forwarding to Third-Party Platforms

In some cases, secrets must be delivered into systems that cant fetch them from Infisical directly.

[Secret Syncs](/integrations/secret-syncs/overview) allow you to forward secrets to platforms such as [GitHub](/integrations/secret-syncs/github), [GitLab](/integrations/secret-syncs/gitlab), [AWS Secrets Manager](/integrations/secret-syncs/aws-secrets-manager), [Vercel](/integrations/secret-syncs/vercel), and more.

This is useful when external systems require secrets to be available ahead of time or expect them in a specific location.

## Infrastructure-as-Code and Automation Tools

Infisical integrates with common IaC and automation tools to help you securely inject secrets into your infrastructure provisioning workflows:

* [Terraform](https://registry.terraform.io/providers/Infisical/infisical/latest/docs): Use the official Infisical Terraform provider to fetch secrets either as ephemeral resources (never written to state files) or as traditional data sources. Ideal for managing cloud infrastructure while keeping secrets secure and version-safe.
* [Pulumi](/integrations/frameworks/pulumi): Integrate Infisical into Pulumi projects using the Terraform Bridge, allowing you to fetch and manage secrets in TypeScript, Go, Python, or C#  without changing your existing workflows.
* [Ansible](/integrations/platforms/ansible): Retrieve secrets from Infisical at runtime using the official Ansible Collection and lookup plugin. Works well for dynamic configuration during playbook execution.
* [Packer](/integrations/frameworks/packer): Inject secrets into VM or container images at build time using the Infisical Packer Plugin  useful for provisioning base images that require secure configuration values.


# Secrets Management
Source: https://infisical.com/docs/documentation/platform/secrets-mgmt/concepts/secrets-mgmt

Learn what is secrets management and why it matters for building secure systems.

## What is a Secret?

A *secret* is a confidential value used by an application such as database credential, API key, or other configuration.

In most cases, secrets allow applications to access systems and control how they behave across the development cycle  for example, an application might use a database password stored in an environment variable like `DB_PASSWORD` to connect to production data. These secrets must be kept secure to protect infrastructure and data.

## What is Secrets Management?

As infrastructure scales and systems become more distributed, [secrets sprawl](https://infisical.com/blog/what-is-secret-sprawl). Without consistent security practices, secrets get hardcoded in source code, exposed in environment variables, left unrotated for long periods, and scattered across systems without clear visibility into who can access them.

To solve secret sprawl, organizations rely on [secrets management](https://infisical.com/blog/what-is-secrets-management): the practice of centralizing secrets and managing them through well-defined workflows. This includes secure storage, fine-grained access controls, automatic rotation, audit logging, and support for dynamic, short-lived credentials.

A consistent approach makes it easier to keep secrets safe, reduce risk, and operate reliably across environments.


# Secrets Rotation
Source: https://infisical.com/docs/documentation/platform/secrets-mgmt/concepts/secrets-rotation

Learn what secrets rotation is, why it matters, and how Infisical enables it.

## What is Secrets Rotation?

Secrets rotation is the process of regularly replacing credentials like API keys, database passwords, and tokens to reduce the risk of long-term exposure. Even if a secret is compromised, frequent rotation limits how long it can be used.

Without rotation, secrets often go unchanged for months or years  hardcoded in codebases, embedded in CI pipelines, or shared across environments. Over time, this increases the risk of leaks, misuse, and operational blind spots.

## Secrets Rotation in Infisical

Infisical automates rotation using a rolling lifecycle model where new credentials are issued on a fixed schedule with previous ones remaining temporarily valid to give systems time to update without disruption. Each secret moves through three phases: active, inactive, and eventually revoked. This ensures that applications continue to function smoothly throughout the rotation process.

When rotation is applicable for a given secret type, using it is strongly recommended. Infisical supports configuring automatic rotation for a growing set of use cases including [PostgreSQL](/documentation/platform/secret-rotation/postgres-credentials), [MySQL](/documentation/platform/secret-rotation/mysql-credentials), [Microsoft SQL Server](/documentation/platform/secret-rotation/mssql-credentials), [OracleDB](/documentation/platform/secret-rotation/oracledb-credentials), [LDAP](/documentation/platform/secret-rotation/ldap-password), [AWS IAM users](/documentation/platform/secret-rotation/aws-iam-user-secret), [Azure](/documentation/platform/secret-rotation/azure-client-secret) and [Okta](/documentation/platform/secret-rotation/okta-client-secret) client secrets, and more.

To learn more, refer to the [secrets rotation documentation](/documentation/platform/secret-rotation/overview).


# Secrets Management
Source: https://infisical.com/docs/documentation/platform/secrets-mgmt/overview

Learn how to securely store, access, and manage sensitive application secrets.

Infisical provides a flexible platform for managing application secrets  such as API keys, database credentials, application configuration, and more  across every stage of the development lifecycle from local development to production.

It helps teams eliminate hardcoded secrets, enforce access controls, and adopt secure workflows like secret rotation, dynamic secrets, and secrets syncs to external platforms.

Core capabilities include:

* Secret Stores: Secure, versioned storage scoped by [project](/documentation/platform/secrets-mgmt/project), [environment](/documentation/platform/secrets-mgmt/project#project-environments), and [path](/documentation/platform/folder).
* [Access Control](/documentation/platform/access-controls/overview): Fine-grained, identity-aware permissions for users and machines
* [Secret Delivery](/documentation/platform/secrets-mgmt/concepts/secrets-delivery): Access secrets via [CLI](/cli/overview), [SDKs](/sdks/overview) (Go, Node.js, Python, etc.), [HTTP API](/api-reference/overview/introduction), [agents](/integrations/platforms/infisical-agent), [Kubernetes Operator](/integrations/platforms/kubernetes/overview), [External Secrets Operator (ESO)](https://external-secrets.io/latest/provider/infisical), and more.
* Lifecycle Automation: Automate [secret rotation](/documentation/platform/secrets-mgmt/concepts/secrets-rotation), generate [dynamic secrets](/documentation/platform/secrets-mgmt/concepts/dynamic-secrets), and enforce [approval-based workflows](/documentation/platform/pr-workflows).
* [Secrets Syncs](/integrations/secret-syncs/overview): Push secrets to external services like [GitHub](/integrations/secret-syncs/github), [GitLab](/integrations/secret-syncs/gitlab), [AWS Secrets Manager](/integrations/secret-syncs/aws-secrets-manager), [Vercel](/integrations/secret-syncs/vercel), and more.


# Projects
Source: https://infisical.com/docs/documentation/platform/secrets-mgmt/project

Learn more and understand the concept of Infisical projects.

A secrets management project in Infisical is a dedicated workspace for managing application secrets such as API keys, database credentials, configuration, etc. used by your applications.

Secrets are organized into a clear hierarchy of environments, folders, and individual secrets, making it easy to manage values across different stages of your development lifecycle (e.g., development, staging, production).

## Project environments

For both visual and organizational structure, Infisical allows splitting up secrets into environments (e.g., development, staging, production). In project settings, such environments can be
customized depending on the intended use case.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/project/project-environments.png" alt="project secrets overview" />

## Secrets Overview

The **Secrets Overview** page captures a birds-eye-view of secrets and [folders](/documentation/platform/folder) across environments.
This is useful for comparing secrets, identifying if anything is missing, and making quick changes.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/project/project-secrets-overview-open.png" alt="project secrets overview" />

## Secrets Dashboard

The **Secrets Dashboard** page appears when you press to manage the secrets of a specific environment.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/dashboard.png" alt="project dashboard" />

### Secrets

To add a secret, press **Add Secret** button at the top of the dashboard.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/project/project-secrets-add.png" alt="project add secret" />

For a new project, it can be convenient to populate the dashboard by dropping a `.env` file into the provided pane as shown below:

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/project/project-secrets-drop-env.png" alt="project drop env file" />

To delete a secret, hover over it and press the **X** button that appears on the right side.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/project/project-secrets-delete.png" alt="project delete secret" />

To delete multiple secrets at once, hover over and select the secrets you'd like to delete
and press the **Delete** button that appears at the top.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/project/project-secrets-delete-batch.png" alt="project delete secret batch" />

### Search

To search for specific secrets by their key name, you can use the search bar.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/project/project-secrets-search.png" alt="project search" />

To assist you with finding secrets, you can also group them by similar prefixes and filter them by tags (if applicable).

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/project/project-secrets-filter.png" alt="project filter" />

### Hide/Un-hide

To view/hide all secrets at once, toggle the hide or un-hide button.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/project/project-secrets-unhide.png" alt="project filter" />

### Download as .env

To download/export secrets back into a `.env` file, press the download button.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/project/project-secrets-download-env.png" alt="project download back env" />

### Tags

To better organize similar secrets, hover over them and label them with a tag.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/project/project-secrets-tag.png" alt="project tag secret" />

### Comments

To provide more context about a given secret, especially for your team, hover over it and press the comment button.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/project/project-secrets-comment.png" alt="project comment secret" />

### Personal overrides

Infisical employs the concept of **shared** and **personal** secrets to address the need
for common and custom secret values, or branching, amongst members of a team during software development.
To provide a helpful analogy: A shared value is to a `main` branch as a personal value is to a custom branch.

Consider:

* A team with users A, B, user C.
* A project with an environment containing a shared secret called D with the value E.

Suppose user A overrides the value of secret D with the value F.

Then:

* If user A fetches the secret D back, they get the value F.
* If users B and C fetch the secret D back, they both get the value E.

<Info>
  Please keep in mind that secret reminders won't work with personal overrides.
</Info>

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/project/project-secrets-override.png" alt="project override secret" />

### Drawer

To view the full details of each secret, you can hover over it and press on the ellipses button.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/project/project-secrets-ellipses.png" alt="project secrets ellipses" />

This opens up a side-drawer:

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/project/project-secrets-drawer.png" alt="project secrets drawer" />


# SSH Certificates
Source: https://infisical.com/docs/documentation/platform/ssh/concepts/ssh-certificates

Learn what SSH certificates are, why they're useful, and how they enable secure, scalable infrastructure access.

SSH access is ubiquitous  It's how engineers, scripts, and platforms across the world remotely administer Linux systems. That said, as teams and systems grow, managing access with static SSH keys becomes brittle and issues like key sprawl, unclear boundaries, and poor revocation hygiene start to emerge.

*SSH certificates* offer an alternative approach to securing and managing access at scale.

## What is an SSH Certificate?

An *SSH certificate* is a short-lived, signed credential that proves a user or hosts identity. Unlike static SSH keys, which are distributed and managed manually, SSH certificates rely on a centralized certificate authority (CA) to vouch for identities.
There are two types of SSH certificates:

* User certificates: Issued to users to authenticate with remote hosts
* Host certificates: Issued to hosts so clients can verify they're trusted

Because certificates are time-bound and centrally managed, theyre easier to audit, revoke, and scale across infrastructure.

## SSH with Infisical

Infisical SSH gives you a secure, scalable way to manage infrastructure access using SSH certificates  without the overhead of running your own certificate authority, wiring trust across hosts, or building issuance workflows from scratch.

It replaces long-lived SSH keys with short-lived, identity-bound certificates and handles all the moving parts for you: operating CAs, configuring trust between users and hosts, and issuing certificates on demand. With Infisical SSH, you can register a host with [`infisical ssh add-host`](/cli/commands/ssh#infisical-ssh-add-host), then connect with [`infisical ssh connect`](/cli/commands/ssh#infisical-ssh-connect)  thats all it takes.

The result is centralized, auditable SSH access thats easy to use and built to scale with your infrastructure.


# Host Groups
Source: https://infisical.com/docs/documentation/platform/ssh/host-groups

Learn how to organize SSH hosts into groups and manage access policies at scale.

## Concept

Infisical SSH lets you configure host groups to organize and manage multiple SSH hosts with shared access configuration.
These host groups can be created based on environments (`development`, `staging`, `production`), geographical regions (`us-east`, `eu-west`, `ap-northeast`), or functions (`web-servers`, `database-servers`, `worker-nodes`) to streamline access management across your infrastructure.

Using a host group, you can define login mappings at the group level and have them be applied to all hosts assigned to that group. For example, you can specify that `john@example.com` can login as `ubuntu` on all hosts assigned to the `production` host group.

## Workflow

The typical workflow for using Infisical SSH with host groups consists of the following steps:

1. The administrator creates host groups based on logical groupings (environments, regions, functions, etc.).
2. The administrator configures login mappings at the host group level to define access policies.
3. The administrator registers remote hosts with Infisical using the Infisical CLI via the `infisical ssh add-host` command and assigns them to appropriate host groups either using the `--host-group` flag or by adding them to the host group via UI.
4. User(s) access the remote hosts using the Infisical CLI via the `infisical ssh connect` command, with access determined by the login mappings defined at both host and host group levels.

## Admin Guide for Configuring Host Groups

In the following steps, we'll walk through how to create and configure Host Groups in Infisical SSH, and how to add hosts to these groups.

<Steps>
  <Step title="Create a host group">
    1.1. Navigate to your Infisical SSH project and select the **Hosts** tab.

    1.2. Click **Add Group** in the **Host Groups** section to create a new group.

    Enter a name (e.g., `production-servers` or `tokyo-region`) and login mapping(s) for the host group.

    A login mapping for a host group applies to all hosts assigned to the group and dictates what user(s) will be allowed access to the remote hosts
    in that group under specific login user(s); in the allowed principals, you should select user(s) part of the Infisical SSH project that will
    be allowed to login to the remote host as the login user.

    For instance, if you add a mapping to a host group with the login user `ec2-user` to some users John and Alice in Infisical, then they will be allowed to login to any remote host that is part of the group as `ec2-user` which is a system user that
    exists on the remote host(s).

    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/ssh/v2/ssh-group-add-group-1.png" alt="ssh group add group" />
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/ssh/v2/ssh-group-add-group-2.png" alt="ssh group add group 2" />

    1.3. Click **Add** to create the host group.
  </Step>

  <Step title="Add host(s) to the host group">
    After creating the host group, you can assign a host to it from inside the host group page in the **SSH Hosts** section. Generally, this is where you'll manage the hosts in a group.

    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/ssh/v2/ssh-group-add-host-1.png" alt="ssh group add group - add host" />
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/ssh/v2/ssh-group-add-host-2.png" alt="ssh group add group - added host" />
  </Step>
</Steps>


# Infisical SSH
Source: https://infisical.com/docs/documentation/platform/ssh/overview

Learn how to manage secure, short-lived SSH access to infrastructure using certificates.

Infisical SSH provides a secure, certificate-based solution for managing SSH access to infrastructure.
It replaces long-lived SSH keys with short-lived, identity-bound certificates to reduce key sprawl, simplify access control, and improve auditability.

Core capabilities include:

* Certificate Authority (CA): Managed CA infrastructure for issuing short-lived SSH certificates.
* Centralized Access Management: View all registered hosts, see who has access to each, and control permissions from a single interface.
* Easy Host Registration & Connection: Quickly register hosts and connect using short-lived certificates without manual key distribution.
* Audit Logging: Detailed records of certificate issuance and SSH access activity.


# Overview
Source: https://infisical.com/docs/documentation/platform/ssh/usage

Learn how to securely provision user SSH access to your infrastructure using SSH certificates.

## Concept

Infisical SSH can be configured to provide users on your team short-lived, secure SSH access to infrastructure. Under the hood, it uses SSH certificates
and improves upon traditional SSH key-based authentication by mitigating private key compromise, static key management,
unauthorized access, and SSH key sprawl.

The following entities are important to understand when configuring and using Infisical SSH:

* Administrator: An individual on your team who is responsible for configuring Infisical SSH.
* Users: Other individuals that gain access to remote hosts through Infisical SSH.
* Host: A remote machine (e.g. EC2 instance, GCP VM, Azure VM, on-prem Linux server, Raspberry Pi, VMware VM, etc.) that users need SSH access to that is registered with Infisical SSH.

## Workflow

The typical workflow for using Infisical SSH consists of the following steps:

1. The administrator registers a remote host with Infisical using the Infisical CLI via the `infisical ssh add-host` command.
2. The administrator configures Infisical SSH to grant users access to the remote host.
3. User(s) access the remote host using the Infisical CLI via the `infisical ssh connect` command.

## Admin Guide for Configuring Infisical SSH

In the following steps, we explore how to configure Infisical SSH to control and streamline your team's SSH access to infrastructure. As part of this guide,
we will register a remote host with Infisical through a [machine identity](/documentation/platform/identities/machine-identities) and configure Infisical to grant user(s) access to the remote host.

<Steps>
  <Step title="Create an Infisical SSH project">
    Start by creating a new Infisical SSH project in Infisical.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/ssh/v2/ssh-create-project.png" alt="ssh project create" />
  </Step>

  <Step title="Create a machine identity for bootstrapping Infisical SSH">
    2.1. Follow the instructions [here](/documentation/platform/identities/universal-auth) to configure a [machine identity](/documentation/platform/identities/machine-identities) in Infisical with Universal Auth.

    By the end of this step, you should have a **Client ID** and **Client Secret** on hand as part of the Universal Auth configuration for the identity to authenticate with Infisical
    as part of registering a remote host in step 3.

    <Note>
      You may use other authentication methods as suitable (e.g. [AWS Auth](/documentation/platform/identities/aws-auth), [Azure Auth](/documentation/platform/identities/azure-auth), [GCP Auth](/documentation/platform/identities/gcp-auth), etc.) as part of the machine identity configuration but, to keep this example simple, we will be using Universal Auth.
    </Note>

    2.2. Add the machine identity to the Infisical SSH project you created in the previous step and assign it the **SSH Host Bootstrapper** role.

    This role grants the ability to **Create** and **Issue Host Certificates** on the **SSH Host** resource; this will enable the linked machine identity to bootstrap a remote host with Infisical
    and establish the necessary configuration on it.

    <Tip>
      If you plan to use a custom role to bootstrap SSH hosts, ensure the role has the **Create** and **Issue Host Certificates** on the **SSH Host** resource.
    </Tip>

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/ssh/v2/ssh-add-identity-to-project.png" alt="ssh add identity to project" />
  </Step>

  <Step title="Configure the remote host">
    3.1. Follow the instructions [here](/cli/overview) to install the Infisical CLI onto the remote host.

    3.2. Run the commands below to register the remote host with Infisical.

    Use the **Client ID** and **Client Secret** from the machine identity you created in step 2.1 as part of the `infisical login` command
    to obtain an access token and save it as an environment variable.

    ```bash  theme={"dark"}
    export INFISICAL_TOKEN=$(infisical login --method=universal-auth --client-id=<identity-client-id> --client-secret=<identity-client-secret> --silent --plain)
    ```

    Next, use the `infisical ssh add-host` command to register the remote host with Infisical. As part of this command, input the ID of the Infisical SSH project you created in step 1 for the `--projectId` flag and the hostname of the remote host for the `--hostname` flag.

    ```bash  theme={"dark"}
    sudo infisical ssh add-host --projectId=<project-id> --hostname=<hostname> --token="$INFISICAL_TOKEN" --write-user-ca-to-file --write-host-cert-to-file --configure-sshd
    ```

    <Tip>
      Note that if you're self-hosting Infisical, you can use the `--domain` flag on the `infisical login` command to specify the domain of your Infisical instance.

      For more information on the `infisical ssh add-host` command, please refer to the Infisical CLI [documentation](/cli/overview).
    </Tip>

    If successful, you should see output similar to the following:

    ```bash  theme={"dark"}
     Successfully registered host: <hostname>
     Wrote User CA public key to: /etc/ssh/infisical_user_ca.pub
     Wrote host certificate to: /etc/ssh/ssh_host_ed25519_key-cert.pub
     Updated sshd_config entries
    ```

    Finally, use the following command to reload the SSH daemon on the remote host to apply the changes:

    ```bash  theme={"dark"}
    sudo systemctl reload sshd
    ```

    <Note>
      The command may differ depending on the host. For older versions of Ubuntu/Debian/CentOS, you may need to use `sudo service ssh reload` instead;
      for Alpine or minimal systems, `/etc/init.d/sshd reload`.
    </Note>

    Back in Infisical, you should now see the remote host you just registered in the Infisical SSH project you created in step 1 under the **Hosts** tab.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/ssh/v2/ssh-added-hosts.png" alt="ssh hosts" />
  </Step>

  <Step title="Grant users access to the remote host">
    4.1. Add the user(s) you wish to grant access to the remote host to the Infisical SSH project under Access Control > Users.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/ssh/v2/ssh-add-user.png" alt="ssh hosts" />

    4.2. On the registered host in the **Hosts** tab, click **Edit SSH Host** and add a login mapping for the user(s) you added in step 4.1.

    The login mapping dictates what user(s) will be allowed access to the remote host and under a specific login user; in the allowed principals,
    you should select user(s) part of the Infisical SSH project that will be allowed to login to the remote host as the login user.

    For instance, if you add a mapping with the login user `ec2-user` to some users John and Alice in Infisical, then they will be allowed to login to the remote host as `ec2-user` which is a system user that
    exists on the remote host.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/ssh/v2/ssh-host-login-mappings.png" alt="ssh host mappings" />

    <Note>
      Note that you should configure authorized principals files for each login user you add to the remote host.
    </Note>
  </Step>
</Steps>

## User Guide for SSHing to a Host

Once Infisical SSH is configured by an administrator, users can SSH to the remote host using the Infisical CLI.

<Steps>
  <Step title="Install the Infisical CLI">
    Follow the instructions [here](/cli/overview) to install the Infisical CLI onto your local machine.
  </Step>

  <Step title="Connect to the remote host">
    The `infisical ssh connect` command can be used in either interactive or non-interactive mode to connect to a remote host.

    <Tabs>
      <Tab title="Interactive Mode">
        In interactive mode, you'll first need to authenticate with Infisical by running:

        ```bash  theme={"dark"}
        infisical login
        ```

        Then simply run:

        ```bash  theme={"dark"}
        infisical ssh connect
        ```

        You'll be prompted to select an SSH Host from a list of accessible hosts; this is based on project membership and login mappings configured on hosts by
        the administrator.

        ```bash  theme={"dark"}
        Use the arrow keys to navigate:    
        ? Select an SSH Host:
         ec2-12-345-678-910.ap-northeast-1.compute.amazonaws.com
        ```

        After selecting a host, you'll be prompted to select a login user from a list of allowed login users:

        ```bash  theme={"dark"}
        ? Select Login User:
         ec2-user
        ```

        If successful, you should be able to SSH to the remote host.

        ```bash  theme={"dark"}
         ec2-54-199-104-116.ap-northeast-1.compute.amazonaws.com
         ec2-user
         SSH credentials successfully added to agent
        Connecting to ec2-user@ec2-12-345-678-910.ap-northeast-1.compute.amazonaws.com...
        ```
      </Tab>

      <Tab title="Non-Interactive Mode">
        For CI/CD pipelines or automation scenarios, you can use the non-interactive mode with an Infisical token:

        ```bash  theme={"dark"}
        infisical ssh connect \
          --hostname ec2-12-345-678-910.ap-northeast-1.compute.amazonaws.com \
          --login-user ec2-user \
          --out-file-path ~/.ssh/id_rsa-cert.pub \
          --token <your-infisical-token>
        ```

        This will:

        * Connect to the specified hostname
        * Use the specified login user
        * Write the SSH credentials to the specified path instead of adding them to the SSH agent
        * Authenticate using the provided Infisical token
      </Tab>
    </Tabs>
  </Step>
</Steps>


# Auth0 OIDC
Source: https://infisical.com/docs/documentation/platform/sso/auth0-oidc

Learn how to configure Auth0 OIDC for Infisical SSO.

<Info>
  Auth0 OIDC SSO is a paid feature. If you're using Infisical Cloud, then it is
  available under the **Pro Tier**. If you're self-hosting Infisical, then you
  should contact [sales@infisical.com](mailto:sales@infisical.com) to purchase a self-hosted license to use
  it.
</Info>

<Steps>
  <Step title="Setup application in Auth0">
    1.1. From the Application's Page, navigate to the settings tab of the Auth0 application you want to integrate with Infisical.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/auth0-oidc/application-settings.png" alt="OIDC auth0 list of applications" />

    1.2. In the Application URIs section, set the **Application Login URI** and **Allowed Web Origins** fields to `https://app.infisical.com` and the **Allowed Callback URL** field to `https://app.infisical.com/api/v1/sso/oidc/callback`.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/auth0-oidc/application-uris.png" alt="OIDC auth0 create application uris" />
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/auth0-oidc/application-origin.png" alt="OIDC auth0 create application origin" />

    <Info>
      If youre self-hosting Infisical, then you will want to replace [https://app.infisical.com](https://app.infisical.com) with your own domain.
    </Info>

    Once done, click **Save Changes**.

    1.3. Proceed to the Connections Tab and enable desired connections.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/auth0-oidc/application-connections.png" alt="OIDC auth0 application connections" />
  </Step>

  <Step title="Retrieve Identity Provider (IdP) Information from Auth0">
    2.1. From the application settings page, retrieve the **Client ID** and **Client Secret**
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/auth0-oidc/application-credential.png" alt="OIDC auth0 application credential" />

    2.2. In the advanced settings (bottom-most section), retrieve the **OpenID Configuration URL** from the Endpoints tab.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/auth0-oidc/application-urls.png" alt="OIDC auth0 application oidc url" />

    Keep these values handy as we will need them in the next steps.
  </Step>

  <Step title="Finish configuring OIDC in Infisical">
    3.1. Back in Infisical, head to the **Single Sign-On (SSO)** page and select the **General** tab. Click **Connect** for **OIDC**.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/connect-oidc.png" alt="OIDC SSO Connect" />

    3.2. For configuration type, select **Discovery URL**. Then, set **Discovery Document URL**, **JWT Signature Algorithm**, **Client ID**, and **Client Secret** from step 2.1 and 2.2.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/auth0-oidc/org-update-oidc.png" alt="OIDC auth0 paste values into Infisical" />

    <Info>
      Currently, the following JWT signature algorithms are supported: RS256, RS512, HS256, and EdDSA
    </Info>

    Once you've done that, press **Update** to complete the required configuration.
  </Step>

  <Step title="Enable OIDC in Infisical">
    Enabling OIDC allows members in your organization to log into Infisical via Auth0.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/enable-oidc.png" alt="OIDC auth0 enable OIDC" />
  </Step>

  <Step title="Enforce OIDC SSO in Infisical">
    Enforcing OIDC SSO ensures that members in your organization can only access Infisical
    by logging into the organization via Auth0.

    To enforce OIDC SSO, you're required to test out the OpenID connection by successfully authenticating at least one Auth0 user with Infisical.
    Once you've completed this requirement, you can toggle the **Enforce OIDC SSO** button to enforce OIDC SSO.

    <Warning>
      We recommend ensuring that your account is provisioned using the application in Auth0
      prior to enforcing OIDC SSO to prevent any unintended issues.
    </Warning>

    <Info>
      In case of a lockout, an organization admin can use the [Admin Login Portal](https://infisical.com/docs/documentation/platform/sso/overview#admin-login-portal) in the `/login/admin` path e.g. [https://app.infisical.com/login/admin](https://app.infisical.com/login/admin).
    </Info>
  </Step>
</Steps>

<Tip>
  If you are only using one organization on your Infisical instance, you can configure a default organization in the [Server Admin Console](../admin-panel/server-admin#default-organization) to expedite OIDC login.
</Tip>

<Note>
  If you're configuring OIDC SSO on a self-hosted instance of Infisical, make
  sure to set the `AUTH_SECRET` and `SITE_URL` environment variable for it to
  work:

  <div class="height:1px;" />

  * `AUTH_SECRET`: A secret key used for signing and verifying JWT. This
    can be a random 32-byte base64 string generated with `openssl rand -base64
      32`.

  <div class="height:1px;" />

  * `SITE_URL`: The absolute URL of your self-hosted instance of Infisical including the protocol (e.g. [https://app.infisical.com](https://app.infisical.com))
</Note>


# Auth0 SAML
Source: https://infisical.com/docs/documentation/platform/sso/auth0-saml

Learn how to configure Auth0 SAML for Infisical SSO.

<Info>
  Auth0 SAML SSO feature is a paid feature. If you're using Infisical Cloud,
  then it is available under the **Pro Tier**. If you're self-hosting Infisical,
  then you should contact [sales@infisical.com](mailto:sales@infisical.com) to purchase an enterprise license
  to use it.
</Info>

<Steps>
  <Step title="Prepare the SAML SSO configuration in Infisical">
    In Infisical, head to the **Single Sign-On (SSO)** page and select the **General** tab. Click **Connect** for **SAML** under the Connect to an Identity Provider section. Select **Auth0**, then click **Connect** again.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/connect-saml.png" alt="SSO connect section" />

    Next, note the **Application Callback URL** and **Audience** to use when configuring the Auth0 SAML application.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/auth0-saml/init-config.png" alt="Auth0 SAML initial configuration" />
  </Step>

  <Step title="Create a SAML application in Auth0">
    2.1. In your Auth0 account, head to Applications and create an application.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/auth0-saml/create-application.png" alt="Auth0 SAML app creation" />

    Select **Regular Web Application** and press **Create**.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/auth0-saml/create-application-2.png" alt="Auth0 SAML app creation" />

    2.2. In the Application head to Settings > Application URIs and add the **Application Callback URL** from step 1 into the **Allowed Callback URLs** field.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/auth0-saml/auth0-config.png" alt="Auth0 SAML allowed callback URLs" />

    2.3. In the Application head to Addons > SAML2 Web App and copy the **Issuer**, **Identity Provider Login URL**, and **Identity Provider Certificate** from the **Usage** tab.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/auth0-saml/auth0-config-2.png" alt="Auth0 SAML config" />

    2.4. Back in Infisical, set **Issuer**, **Identity Provider Login URL**, and **Certificate** to the corresponding items from step 2.3.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/auth0-saml/infisical-config.png" alt="Auth0 SAML Infisical config" />

    2.5. Back in Auth0, in the **Settings** tab, set the **Application Callback URL** to the **Application Callback URL** from step 1
    and update the **Settings** field with the JSON under the picture below (replacing `<audience-from-infisical>` with the **Audience** from step 1).

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/auth0-saml/auth0-config-3.png" alt="Auth0 SAML config" />

    ```json  theme={"dark"}
    {
    "audience": "<audience-from-infisical>",
    "mappings": {
        "email": "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/email",
        "given_name": "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/firstName",
        "family_name": "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/lastName"
    },
    "signatureAlgorithm": "rsa-sha256",
    "digestAlgorithm": "sha256",
    "signResponse": true
    }
    ```

    Click **Save**.

    <Warning>
      Make sure the `firstName` claim is mapped to a valid field of your Auth0 users. If your users don't have a `"given_name"` field available, you can replace it with `"name"` or another field that exists in your user profile on the left side of the mapping.
    </Warning>
  </Step>

  <Step title="Enable SAML SSO in Infisical">
    Enabling SAML SSO allows members in your organization to log into Infisical via Auth0.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/auth0-saml/enable-saml.png" alt="Auth0 SAML enable" />
  </Step>

  <Step title="Enforce SAML SSO in Infisical">
    Enforcing SAML SSO ensures that members in your organization can only access Infisical
    by logging into the organization via Auth0.

    To enforce SAML SSO, you're required to test out the SAML connection by successfully authenticating at least one Auth0 user with Infisical;
    Once you've completed this requirement, you can toggle the **Enforce SAML SSO** button to enforce SAML SSO.

    <Info>
      In case of a lockout, an organization admin can use the [Admin Login Portal](https://infisical.com/docs/documentation/platform/sso/overview#admin-login-portal) in the `/login/admin` path e.g. [https://app.infisical.com/login/admin](https://app.infisical.com/login/admin).
    </Info>
  </Step>
</Steps>

<Tip>
  If you are only using one organization on your Infisical instance, you can configure a default organization in the [Server Admin Console](../admin-panel/server-admin#default-organization) to expedite SAML login.
</Tip>

<Note>
  If you're configuring SAML SSO on a self-hosted instance of Infisical, make
  sure to set the `AUTH_SECRET` and `SITE_URL` environment variable for it to
  work:

  <div class="height:1px;" />

  * `AUTH_SECRET`: A secret key used for signing and verifying JWT. This
    can be a random 32-byte base64 string generated with `openssl rand -base64
        32`.

  <div class="height:1px;" />

  * `SITE_URL`: The absolute URL of your self-hosted instance of Infisical including the protocol (e.g. [https://app.infisical.com](https://app.infisical.com))
</Note>


# Entra ID / Azure AD SAML
Source: https://infisical.com/docs/documentation/platform/sso/azure

Learn how to configure Microsoft Entra ID for Infisical SSO.

<Info>
  Azure SAML SSO is a paid feature.

  If you're using Infisical Cloud, then it is available under the **Pro Tier**. If you're self-hosting Infisical,
  then you should contact [sales@infisical.com](mailto:sales@infisical.com) to purchase an enterprise license to use it.
</Info>

<Steps>
  <Step title="Prepare the SAML SSO configuration in Infisical">
    In Infisical, head to the **Single Sign-On (SSO)** page and select the **General** tab. Click **Connect** for **SAML** under the Connect to an Identity Provider section. Select **Azure / Entra**, then click **Connect** again.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/connect-saml.png" alt="SSO connect section" />

    Next, copy the **Reply URL (Assertion Consumer Service URL)** and **Identifier (Entity ID)** to use when configuring the Azure SAML application.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/azure/init-config.png" alt="Azure SAML initial configuration" />
  </Step>

  <Step title="Create a SAML application in Azure">
    In the Azure Portal, navigate to the Azure Active Directory and select **Enterprise applications**. On this screen, select **+ New application**.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/azure/enterprise-applications.png" alt="Azure SAML enterprise applications" />

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/azure/new-application.png" alt="Azure SAML new application" />

    On the next screen, press the **+ Create your own application** button.
    Give the application a unique name like Infisical; choose the "Integrate any other application you don't find in the gallery (Non-gallery)"
    option and hit the **Create** button.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/azure/create-own-application.png" alt="Azure SAML create own application" />

    On the application overview screen, select **Single sign-on** from the left sidebar. From there, select the **SAML** single sign-on method.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/azure/sso-method.png" alt="Azure SAML sign on method" />

    Next, select **Edit** in the **Basic SAML Configuration** section and add/set the **Identifier (Entity ID)** to **Entity ID** and add/set the **Reply URL (Assertion Consumer Service URL)** to **ACS URL** from step 1.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/azure/edit-basic-config.png" alt="Azure SAML edit basic configuration" />

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/azure/edit-basic-config-2.png" alt="Azure SAML edit basic configuration 2" />

    <Note>
      If you're self-hosting Infisical, then you will want to replace
      `https://app.infisical.com` with your own domain.
    </Note>

    Back in the **Set up Single Sign-On with SAML** screen, select **Edit** in the **Attributes & Claims** section and configure the following map:

    * `email -> user.userprincipalname`
    * `firstName -> user.givenname`
    * `lastName -> user.surname`

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/azure/edit-attributes-claims.png" alt="Azure SAML edit attributes and claims" />

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/azure/edit-attributes-claims-2.png" alt="Azure SAML edit attributes and claims 2" />

    Back in the **Set up Single Sign-On with SAML** screen, select **Edit** in the **SAML Certificates** section and set the **Signing Option** field to **Sign SAML response and assertion**.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/azure/edit-saml-certificate.png" alt="Azure SAML edit certificate" />

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/azure/edit-saml-certificate-2.png" alt="Azure SAML edit certificate signing option" />
  </Step>

  <Step title="Retrieve Identity Provider (IdP) Information from Azure">
    In the **Set up Single Sign-On with SAML** screen, copy the **Login URL** and **SAML Certificate** to use when finishing configuring Azure SAML in Infisical.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/azure/idp-values.png" alt="Azure SAML identity provider values 1" />

    In the **Properties** screen, copy the **Application ID** to use when finishing configuring Azure SAML in Infisical.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/azure/idp-values-2.png" alt="Azure SAML identity provider values 2" />
  </Step>

  <Step title="Finish configuring SAML in Infisical">
    Back in Infisical, set **Login URL**, **Azure Application ID**, and **SAML Certificate** from step 3. Once you've done that, press **Update** to complete the required configuration.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/azure/idp-values-3.png" alt="Azure SAML paste identity provider values" />

    <Note>
      When pasting the certificate into Infisical, you'll want to retain `-----BEGIN
            CERTIFICATE-----` and `-----END CERTIFICATE-----` at the first and last line
      of the text area respectively.

      Having trouble?, try copying the X509 certificate information from the Federation Metadata XML file in Azure.
    </Note>
  </Step>

  <Step title="Assign users in Azure to the application">
    Back in Azure, navigate to the **Users and groups** tab and select **+ Add user/group** to assign access to the login with SSO application on a user or group-level.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/azure/assignment.png" alt="Azure SAML assignment" />
  </Step>

  <Step title="Enable SAML SSO in Infisical">
    Enabling SAML SSO allows members in your organization to log into Infisical via Azure.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/azure/enable-saml.png" alt="Azure SAML assignment" />
  </Step>

  <Step title="Enforce SAML SSO in Infisical">
    Enforcing SAML SSO ensures that members in your organization can only access Infisical
    by logging into the organization via Azure.

    To enforce SAML SSO, you're required to test out the SAML connection by successfully authenticating at least one Azure user with Infisical;
    Once you've completed this requirement, you can toggle the **Enforce SAML SSO** button to enforce SAML SSO.

    <Warning>
      We recommend ensuring that your account is provisioned the application in Azure
      prior to enforcing SAML SSO to prevent any unintended issues.
    </Warning>

    <Info>
      In case of a lockout, an organization admin can use the [Admin Login Portal](https://infisical.com/docs/documentation/platform/sso/overview#admin-login-portal) in the `/login/admin` path e.g. [https://app.infisical.com/login/admin](https://app.infisical.com/login/admin).
    </Info>
  </Step>
</Steps>

<Tip>
  If you are only using one organization on your Infisical instance, you can configure a default organization in the [Server Admin Console](../admin-panel/server-admin#default-organization) to expedite SAML login.
</Tip>

<Note>
  If you're configuring SAML SSO on a self-hosted instance of Infisical, make
  sure to set the `AUTH_SECRET` and `SITE_URL` environment variable for it to
  work:

  <div class="height:1px;" />

  * `AUTH_SECRET`: A secret key used for signing and verifying JWT. This
    can be a random 32-byte base64 string generated with `openssl rand -base64
        32`.

  <div class="height:1px;" />

  * `SITE_URL`: The absolute URL of your self-hosted instance of Infisical including the protocol (e.g. [https://app.infisical.com](https://app.infisical.com))
</Note>

<Note>
  If you'd like to require Multi-factor Authentication for your team members to access Infisical check out our [Entra ID / Azure AD MFA](../mfa#entra-id-azure-ad-mfa) guide.
</Note>


# General OIDC Group Membership Mapping
Source: https://infisical.com/docs/documentation/platform/sso/general-oidc/group-membership-mapping

Learn how to sync OIDC group members to matching groups in Infisical.

You can have Infisical automatically sync group
memberships between your OIDC provider and Infisical by configuring a `groups` claim on your provider tokens.
When a user logs in via OIDC, they will be added to Infisical groups that are present in their OIDC `groups` claim,
and removed from any Infisical groups not present in the claim.

<Info>
  When enabled, manual
  management of Infisical group memberships will be disabled.
</Info>

<Warning>
  Group membership changes in your OIDC provider only sync with Infisical when a
  user logs in via OIDC. For example, if you remove a user from a group in your OIDC provider,
  this change will not be reflected in Infisical until their next OIDC login.
  To ensure this behavior, Infisical recommends enabling Enforce OIDC SSO in the OIDC settings.
</Warning>

<Steps>
  <Step title="Configure a groups claim in your OIDC provider">
    To enable OIDC Group Membership Mapping, you must configure a `groups` claim in your OIDC provider.

    Add a `groups` property with a list of the user's OIDC group names to your token.

    Example of expected token payload:

    ```json  theme={"dark"}
    {
        // "email": "john@provider.com",
        // "given_name": "John",
        // ...other claims
        "groups": ["Billing Group", "Sales Group"]
    }
    ```

    <Note>
      Setup varies between OIDC providers. Please refer to your OIDC provider's documentation for more information.
    </Note>
  </Step>

  <Step title="Setup groups in Infisical and enable OIDC Group Membership Mapping">
    2.1. In Infisical, create any groups you would like to sync users to. Make sure the name of the Infisical group is an exact match of the OIDC group name.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/keycloak-oidc/group-membership-mapping/create-infisical-group.png" alt="OIDC general infisical group" />

    2.2. Next, enable **OIDC Group Membership Mapping** on the **Single Sign-On (SSO)** page under the **General** tab.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/keycloak-oidc/group-membership-mapping/enable-group-membership-mapping.png" alt="OIDC general enable group membership mapping" />

    2.3. The next time a user logs in they will be synced to their matching OIDC groups.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/keycloak-oidc/group-membership-mapping/synced-users.png" alt="OIDC general synced users" />
  </Step>
</Steps>


# General OIDC
Source: https://infisical.com/docs/documentation/platform/sso/general-oidc/overview

Learn how to configure OIDC for Infisical SSO with any OIDC-compliant identity provider

<Info>
  OIDC SSO is a paid feature. If you're using Infisical Cloud, then it is
  available under the **Pro Tier**. If you're self-hosting Infisical, then you
  should contact [sales@infisical.com](mailto:sales@infisical.com) to purchase a self-hosted license to use
  it.
</Info>

You can configure your organization in Infisical to have members authenticate with the platform through identity providers via [OpenID Connect](https://openid.net/specs/openid-connect-core-1_0.html).

Prerequisites:

* The identity provider (Okta, Google, Azure AD, etc.) should support OIDC.
* Users in the IdP should have a configured `email` and `given_name`.

<Steps>
  <Step title="Setup Identity Provider">
    1.1. Register your application with the IdP to obtain a **Client ID** and **Client Secret**. These credentials are used by Infisical to authenticate with your IdP.

    1.2. Configure **Redirect URL** to be `https://app.infisical.com/api/v1/sso/oidc/callback`. If you're self-hosting Infisical, replace the domain with your own.

    1.3. Configure the scopes needed by Infisical (email, profile, openid) and ensure that they are mapped to the ID token claims.

    1.4. Access the IdPs OIDC discovery document (usually located at `https://<idp-domain>/.well-known/openid-configuration`). This document contains important endpoints such as authorization, token, userinfo, and keys.
  </Step>

  <Step title="Finish configuring OIDC in Infisical">
    2.1. Back in Infisical, head to the **Single Sign-On (SSO)** page and select the **General** tab. Select **Connect** for **OIDC**.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/connect-oidc.png" alt="OIDC SSO Connect" />

    2.2. You can configure OIDC either through the Discovery URL (Recommended) or by inputting custom endpoints.

    To configure OIDC via Discovery URL, set the **Configuration Type** field to **Discovery URL** and fill out the **Discovery Document URL** field.

    <Note>
      Note that the Discovery Document URL typically takes the form: `https://<idp-domain>/.well-known/openid-configuration`.
    </Note>

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/general-oidc/discovery-oidc-form.png" alt="OIDC general discovery config" />

    To configure OIDC via the custom endpoints, set the **Configuration Type** field to **Custom** and input the required endpoint fields.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/general-oidc/custom-oidc-form.png" alt="OIDC general custom config" />

    2.3. Select the appropriate JWT signature algorithm for your IdP. Currently, the supported options are RS256, RS512, HS256, and EdDSA.

    2.4. Optionally, you can define a whitelist of allowed email domains.

    Finally, fill out the **Client ID** and **Client Secret** fields and press **Update** to complete the required configuration.
  </Step>

  <Step title="Enable OIDC SSO in Infisical">
    Enabling OIDC SSO allows members in your organization to log into Infisical via the configured Identity Provider

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/general-oidc/org-oidc-enable.png" alt="OIDC general enable OIDC" />
  </Step>

  <Step title="Enforce OIDC SSO in Infisical">
    Enforcing OIDC SSO ensures that members in your organization can only access Infisical
    by logging into the organization via the Identity provider.

    To enforce OIDC SSO, you're required to test out the OpenID connection by successfully authenticating at least one IdP user with Infisical.
    Once you've completed this requirement, you can toggle the **Enforce OIDC SSO** button to enforce OIDC SSO.

    <Warning>
      We recommend ensuring that your account is provisioned using the identity provider prior to enforcing OIDC SSO to prevent any unintended issues.
    </Warning>

    <Info>
      In case of a lockout, an organization admin can use the [Admin Login Portal](https://infisical.com/docs/documentation/platform/sso/overview#admin-login-portal) in the `/login/admin` path e.g. [https://app.infisical.com/login/admin](https://app.infisical.com/login/admin).
    </Info>
  </Step>
</Steps>

<Tip>
  If you are only using one organization on your Infisical instance, you can configure a default organization in the [Server Admin Console](/documentation/platform/admin-panel/server-admin#default-organization) to expedite OIDC login.
</Tip>

<Note>
  If you're configuring OIDC SSO on a self-hosted instance of Infisical, make
  sure to set the `AUTH_SECRET` and `SITE_URL` environment variable for it to
  work:

  <div class="height:1px;" />

  * `AUTH_SECRET`: A secret key used for signing and verifying JWT. This
    can be a random 32-byte base64 string generated with `openssl rand -base64
      32`.

  <div class="height:1px;" />

  * `SITE_URL`: The absolute URL of your self-hosted instance of Infisical including the protocol (e.g. [https://app.infisical.com](https://app.infisical.com))
</Note>


# GitHub SSO
Source: https://infisical.com/docs/documentation/platform/sso/github

Learn how to configure GitHub SSO for Infisical.

Using GitHub SSO on a self-hosted instance of Infisical requires configuring an OAuth2 application in GitHub and registering your instance with it.

<Steps>
  <Step title="Create an OAuth application in GitHub">
    Navigate to your user Settings > Developer settings > OAuth Apps to create a new GitHub OAuth application.

    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/github/settings.png" alt="GitHub settings" />
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/github/dev-settings.png" alt="GitHub developer settings" />
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/github/new-app.png" alt="GitHub create new OAuth application" />

    Create the OAuth application. As part of the form, set the **Homepage URL** to your self-hosted domain `https://your-domain.com`
    and the **Authorization callback URL** to `https://your-domain.com/api/v1/sso/github`.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/github/new-app-form.png" alt="GitHub create new OAuth application form" />

    <Note>
      If you have a GitHub organization, you can create an OAuth application under it
      in your organization Settings > Developer settings > OAuth Apps > New Org OAuth App.
    </Note>
  </Step>

  <Step title="Add your OAuth application credentials to Infisical">
    Obtain the **Client ID** and generate a new **Client Secret** for your GitHub OAuth application.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/github/credentials.png" alt="GCP obtain OAuth2 credentials" />

    Back in your Infisical instance, make sure to set the following environment variables:

    * `CLIENT_ID_GITHUB_LOGIN`: The **Client ID** of your GitHub OAuth application.
    * `CLIENT_SECRET_GITHUB_LOGIN`: The **Client Secret** of your GitHub OAuth application.
    * `AUTH_SECRET`: A secret key used for signing and verifying JWT. This can be a random 32-byte base64 string generated with `openssl rand -base64 32`.
    * `SITE_URL`: The URL of your self-hosted instance of Infisical - should be an absolute URL including the protocol (e.g. [https://app.infisical.com](https://app.infisical.com))

    Once added, restart your Infisical instance and log in with GitHub.
  </Step>
</Steps>

## FAQ

<AccordionGroup>
  <Accordion title="Why is GitHub SSO not working?">
    It is likely that you have misconfigured your self-hosted instance of Infisical. You should:

    * Check that you have set the `CLIENT_ID_GITHUB_LOGIN`, `CLIENT_SECRET_GITHUB_LOGIN`,
      `AUTH_SECRET`, and `SITE_URL` environment variables.
    * Check that the **Authorization callback URL** specified in GitHub matches the `SITE_URL` environment variable.
      For example, if the former is `https://app.infisical.com/api/v1/sso/github` then the latter should be `https://app.infisical.com`.
  </Accordion>
</AccordionGroup>


# GitLab SSO
Source: https://infisical.com/docs/documentation/platform/sso/gitlab

Learn how to configure GitLab SSO for Infisical.

Using GitLab SSO on a self-hosted instance of Infisical requires configuring an OAuth application in GitLab and registering your instance with it.

<Steps>
  <Step title="Create an OAuth application in GitLab">
    Navigate to your user Settings > Applications to create a new GitLab application.

    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/gitlab/edit-profile.png" alt="sso gitlab config" />
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/gitlab/new-app.png" alt="sso gitlab config" />

    Create the application. As part of the form, set the **Redirect URI** to `https://your-domain.com/api/v1/sso/gitlab`.
    Note that only `read_user` is required as part of the **Scopes** configuration.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/gitlab/new-app-form.png" alt="sso gitlab config" />

    <Note>
      If you have a GitLab group, you can create an OAuth application under it
      in your group Settings > Applications.
    </Note>
  </Step>

  <Step title="Add your OAuth application credentials to Infisical">
    Obtain the **Application ID** and **Secret** for your GitLab application.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/gitlab/credentials.png" alt="sso gitlab config" />

    Back in your Infisical instance, make sure to set the following environment variables:

    * `CLIENT_ID_GITLAB_LOGIN`: The **Client ID** of your GitLab application.
    * `CLIENT_SECRET_GITLAB_LOGIN`: The **Secret** of your GitLab application.
    * (optional) `URL_GITLAB_LOGIN`: The URL of your self-hosted instance of GitLab where the OAuth application is registered. If no URL is passed in, this will default to `https://gitlab.com`.
    * `AUTH_SECRET`: A secret key used for signing and verifying JWT. This can be a random 32-byte base64 string generated with `openssl rand -base64 32`.
    * `SITE_URL`: The URL of your self-hosted instance of Infisical - should be an absolute URL including the protocol (e.g. [https://app.infisical.com](https://app.infisical.com))

    Once added, restart your Infisical instance and log in with GitLab.
  </Step>
</Steps>

## FAQ

<AccordionGroup>
  <Accordion title="Why is GitLab SSO not working?">
    It is likely that you have misconfigured your self-hosted instance of Infisical. You should:

    * Check that you have set the `CLIENT_ID_GITLAB_LOGIN`, `CLIENT_SECRET_GITLAB_LOGIN`,
      `AUTH_SECRET`, and `SITE_URL` environment variables.
    * Check that the **Redirect URI** specified in GitLab matches the `SITE_URL` environment variable.
      For example, if the former is `https://app.infisical.com/api/v1/sso/gitlab` then the latter should be `https://app.infisical.com`.
  </Accordion>
</AccordionGroup>


# Google SSO
Source: https://infisical.com/docs/documentation/platform/sso/google

Learn how to configure Google SSO for Infisical.

Using Google SSO on a self-hosted instance of Infisical requires configuring an OAuth2 application in GCP and registering your instance with it.

<Steps>
  <Step title="Create an OAuth2 application in GCP">
    Navigate to your project API & Services > Credentials to create a new OAuth2 application.

    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/google/api-services.png" alt="GCP API services" />
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/google/new-app.png" alt="GCP create new OAuth2 application" />

    Create the application. As part of the form, add to **Authorized redirect URIs**: `https://your-domain.com/api/v1/sso/google`.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/google/new-app-form.png" alt="GCP create new OAuth2 application form" />
  </Step>

  <Step title="Add your OAuth2 application credentials to Infisical">
    Obtain the **Client ID** and **Client Secret** for your GCP OAuth2 application.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/google/credentials.png" alt="GCP obtain OAuth2 credentials" />

    Back in your Infisical instance, make sure to set the following environment variables:

    * `CLIENT_ID_GOOGLE_LOGIN`: The **Client ID** of your GCP OAuth2 application.
    * `CLIENT_SECRET_GOOGLE_LOGIN`: The **Client Secret** of your GCP OAuth2 application.
    * `AUTH_SECRET`: A secret key used for signing and verifying JWT. This can be a random 32-byte base64 string generated with `openssl rand -base64 32`.
    * `SITE_URL`: The URL of your self-hosted instance of Infisical - should be an absolute URL including the protocol (e.g. [https://app.infisical.com](https://app.infisical.com))

    Once added, restart your Infisical instance and log in with Google
  </Step>
</Steps>

## FAQ

<AccordionGroup>
  <Accordion title="Why is Google SSO not working?">
    It is likely that you have misconfigured your self-hosted instance of Infisical. You should:

    * Check that you have set the `CLIENT_ID_GOOGLE_LOGIN`, `CLIENT_SECRET_GOOGLE_LOGIN`,
      `AUTH_SECRET`, and `SITE_URL` environment variables.
    * Check that the **Authorized redirect URI** specified in GCP matches the `SITE_URL` environment variable.
      For example, if the former is `https://app.infisical.com/api/v1/sso/google` then the latter should be `https://app.infisical.com`.
  </Accordion>
</AccordionGroup>


# Google SAML
Source: https://infisical.com/docs/documentation/platform/sso/google-saml

Learn how to configure Google SAML for Infisical SSO.

<Info>
  Google SAML SSO feature is a paid feature. If you're using Infisical Cloud,
  then it is available under the **Pro Tier**. If you're self-hosting Infisical,
  then you should contact [sales@infisical.com](mailto:sales@infisical.com) to purchase an enterprise license
  to use it.
</Info>

<Steps>
  <Step title="Prepare the SAML SSO configuration in Infisical">
    In Infisical, head to the **Single Sign-On (SSO)** page and select the **General** tab. Click **Connect** for **SAML** under the Connect to an Identity Provider section. Select **Google**, then click **Connect** again.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/connect-saml.png" alt="SSO connect section" />

    Next, note the **ACS URL** and **SP Entity ID** to use when configuring the Google SAML application.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/google-saml/init-config.png" alt="Google SAML initial configuration" />
  </Step>

  <Step title="Create a SAML application in Google">
    2.1. In your [Google Admin console](https://support.google.com/a/answer/182076), head to Menu > Apps > Web and mobile apps and
    create a **custom SAML app**.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/google-saml/create-custom-saml-app.png" alt="Google SAML app creation" />

    2.2. In the **App details** tab, give the application a unique name like Infisical.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/google-saml/name-custom-saml-app.png" alt="Google SAML app naming" />

    2.3. In the **Google Identity Provider details** tab, copy the **SSO URL**, **Entity ID** and **Certificate**.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/google-saml/custom-saml-app-config.png" alt="Google SAML custom app details" />

    2.4. Back in Infisical, set **SSO URL** and **Certificate** to the corresponding items from step 2.3.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/google-saml/infisical-config.png" alt="Google SAML Infisical config" />

    2.5. Back in the Google Admin console, in the **Service provider details** tab, set the **ACS URL** and **Entity ID** to the corresponding items from step 1.

    Also, check the **Signed response** checkbox.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/google-saml/custom-saml-app-config-2.png" alt="Google SAML app config 2" />

    2.6. In the **Attribute mapping** tab, configure the following map:

    * **First name** -> **firstName**
    * **Last name** -> **lastName**
    * **Primary email** -> **email**

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/google-saml/attribute-mapping.png" alt="Google SAML attribute mapping" />

    <Note>
      If you want to sync Google groups to Infisical groups, you can also configure:

      * **groups** -> **groups**

      This requires setting up group claims in Google Workspace. See the [Group Membership Mapping](#saml-group-membership-mapping) section below for details.
    </Note>

    Click **Finish**.
  </Step>

  <Step title="Assign users in Google Workspace to the application">
    Back in your [Google Admin console](https://support.google.com/a/answer/182076), head to Menu > Apps > Web and mobile apps > your SAML app
    and press on **User access**.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/google-saml/user-access.png" alt="Google SAML user access" />

    To assign everyone in your organization to the application, click **On for everyone** or **Off for everyone** and then click **Save**.

    You can also assign an organizational unit or set of users to an application; you can learn more about that [here](https://support.google.com/a/answer/6087519?hl=en#add_custom_saml\&turn_on\&verify_sso&\&zippy=%2Cstep-add-the-custom-saml-app%2Cstep-turn-on-your-saml-app%2Cstep-verify-that-sso-is-working-with-your-custom-app).

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/google-saml/user-access-assign.png" alt="Google SAML user access assignment" />
  </Step>

  <Step title="Enable SAML SSO in Infisical">
    Enabling SAML SSO allows members in your organization to log into Infisical via Google Workspace.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/google-saml/enable-saml.png" alt="Google SAML enable" />
  </Step>

  <Step title="Enforce SAML SSO in Infisical">
    Enforcing SAML SSO ensures that members in your organization can only access Infisical
    by logging into the organization via Google.

    To enforce SAML SSO, you're required to test out the SAML connection by successfully authenticating at least one Google user with Infisical;
    Once you've completed this requirement, you can toggle the **Enforce SAML SSO** button to enforce SAML SSO.

    <Warning>
      We recommend ensuring that your account is provisioned the application in Google
      prior to enforcing SAML SSO to prevent any unintended issues.
    </Warning>

    <Info>
      In case of a lockout, an organization admin can use the [Admin Login Portal](https://infisical.com/docs/documentation/platform/sso/overview#admin-login-portal) in the `/login/admin` path e.g. [https://app.infisical.com/login/admin](https://app.infisical.com/login/admin).
    </Info>
  </Step>
</Steps>

## SAML Group Membership Mapping

Automatically sync Google Workspace group memberships to Infisical.

<Steps>
  <Step title="Add groups attribute mapping in Google">
    In your Google Admin console SAML app, go to **Attribute mapping** and add:

    * **Google groups**: Include all groups you want to include in the SAML claim. Only these groups will be synced to Infisical.
    * **App attribute**: `groups`

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/google-saml/groups-attribute-mapping.png" alt="Google SAML groups attribute mapping" />
  </Step>

  <Step title="Enable SAML Group Membership Mapping in Infisical">
    Back in Infisical, under Organization Settings, enable **SAML Group Membership Mapping** in the **Single Sign-On (SSO)** tab.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/google-saml/group-membership-mapping.png" alt="Google SAML group membership mapping" />
  </Step>

  <Step title="Group synchronization on login">
    Once configured, Google groups will now be automatically synchronized when users log in through SAML. Users will be added to or removed from Infisical groups based on their current Google group memberships.
  </Step>
</Steps>

<Warning>
  Group membership changes in the SAML provider only sync with Infisical when a user logs in via SAML. For example, if you remove a user from a group in the SAML provider, this change will not be reflected in Infisical until their next SAML login. To ensure this behavior, Infisical recommends enabling Enforce SAML SSO.
</Warning>

<Tip>
  If you are only using one organization on your Infisical instance, you can configure a default organization in the [Server Admin Console](../admin-panel/server-admin#default-organization) to expedite SAML login.
</Tip>

<Note>
  If you're configuring SAML SSO on a self-hosted instance of Infisical, make
  sure to set the `AUTH_SECRET` and `SITE_URL` environment variable for it to
  work:

  <div class="height:1px;" />

  * `AUTH_SECRET`: A secret key used for signing and verifying JWT. This
    can be a random 32-byte base64 string generated with `openssl rand -base64
        32`.

  <div class="height:1px;" />

  * `SITE_URL`: The absolute URL of your self-hosted instance of Infisical including the protocol (e.g. [https://app.infisical.com](https://app.infisical.com))
</Note>

References:

* Google's guide to [set up your own custom SAML app](https://support.google.com/a/answer/6087519?hl=en#add_custom_saml\&turn_on\&verify_sso&\&zippy=%2Cstep-add-the-custom-saml-app%2Cstep-turn-on-your-saml-app%2Cstep-verify-that-sso-is-working-with-your-custom-app).


# JumpCloud SAML
Source: https://infisical.com/docs/documentation/platform/sso/jumpcloud

Learn how to configure JumpCloud SAML for Infisical SSO.

<Info>
  JumpCloud SAML SSO is a paid feature.

  If you're using Infisical Cloud, then it is available under the **Pro Tier**. If you're self-hosting Infisical,
  then you should contact [sales@infisical.com](mailto:sales@infisical.com) to purchase an enterprise license to use it.
</Info>

<Steps>
  <Step title="Prepare the SAML SSO configuration in Infisical">
    In Infisical, head to the **Single Sign-On (SSO)** page and select the **General** tab. Click **Connect** for **SAML** under the Connect to an Identity Provider section. Select **JumpCloud**, then click **Connect** again.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/connect-saml.png" alt="SSO connect section" />

    Next, copy the **ACS URL** and **SP Entity ID** to use when configuring the JumpCloud SAML application.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/jumpcloud/init-config.png" alt="JumpCloud SAML initial configuration" />
  </Step>

  <Step title="Create a SAML application in JumpCloud">
    2.1. In the JumpCloud Admin Portal, navigate to User Authentication > SSO and create an application. If this is your first application, select **Get Started**; if not, select **+Add New Application**

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/jumpcloud/new-application.png" alt="JumpCloud SAML new application" />

    2.2. Next, select **Custom SAML App** to open up the **New SSO** dialog.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/jumpcloud/custom-saml-app.png" alt="JumpCloud custom SAML app" />

    2.3. In the **General Info** tab, give the application a unique name like Infisical.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/jumpcloud/general-info.png" alt="JumpCloud general info" />

    2.4. In the **SSO** tab, set the **SP Entity ID** and **ACS URL** from step 1; set the **IdP Entity ID** to the same value as the **SP Entity ID**.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/jumpcloud/edit-basic-config.png" alt="JumpCloud edit basic config" />

    2.5. On the same tab, check the **Sign Assertion** checkbox and fill the **IDP URL** to something unique.
    Copy the **IDP URL** to use when finishing configuring the JumpCloud SAML in Infisical.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/jumpcloud/edit-basic-config-2.png" alt="JumpCloud edit basic config 2" />

    2.6. On the same tab, in the **Attributes** section, configure the following map:

    * `email -> email`
    * `firstName -> firstname`
    * `lastName -> lastname`

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/jumpcloud/attribute-statements.png" alt="JumpCloud attribute statements" />

    Finally press activate to create the SAML application.

    2.7. Next, select the newly created SAML application and select **Download certificate** under the **IDP Certificate Valid** dropdown

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/jumpcloud/download-saml-certificate.png" alt="JumpCloud download certificate" />
  </Step>

  <Step title="Finish configuring SAML in Infisical">
    Back in Infisical, set the **IDP URL** from step 2.5 and the **IdP Entity ID** from step 2.4. Also, paste the certificate from the previous step.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/jumpcloud/idp-values.png" alt="JumpCloud IdP values" />

    <Note>
      When pasting the certificate into Infisical, you'll want to retain `-----BEGIN
               CERTIFICATE-----` and `-----END CERTIFICATE-----` at the first and last line
      of the text area respectively.
    </Note>
  </Step>

  <Step title="Assign users in JumpCloud to the application">
    Back in JumpCloud, navigate to the **User Groups** tab and assign users to the newly created application.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/jumpcloud/assignment.png" alt="JumpCloud SAML assignment" />
  </Step>

  <Step title="Enable SAML SSO in Infisical">
    Enabling SAML SSO allows members in your organization to log into Infisical via JumpCloud.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/jumpcloud/enable-saml.png" alt="JumpCloud SAML assignment" />
  </Step>

  <Step title="Enforce SAML SSO in Infisical">
    Enforcing SAML SSO ensures that members in your organization can only access Infisical
    by logging into the organization via JumpCloud.

    To enforce SAML SSO, you're required to test out the SAML connection by successfully authenticating at least one JumpCloud user with Infisical;
    Once you've completed this requirement, you can toggle the **Enforce SAML SSO** button to enforce SAML SSO.

    <Warning>
      We recommend ensuring that your account is provisioned in the application in JumpCloud prior to enforcing SAML SSO to prevent any unintended issues.
    </Warning>

    <Info>
      In case of a lockout, an organization admin can use the [Admin Login Portal](https://infisical.com/docs/documentation/platform/sso/overview#admin-login-portal) in the `/login/admin` path e.g. [https://app.infisical.com/login/admin](https://app.infisical.com/login/admin).
    </Info>
  </Step>
</Steps>

<Tip>
  If you are only using one organization on your Infisical instance, you can configure a default organization in the [Server Admin Console](../admin-panel/server-admin#default-organization) to expedite SAML login.
</Tip>

<Note>
  If you're configuring SAML SSO on a self-hosted instance of Infisical, make
  sure to set the `AUTH_SECRET` and `SITE_URL` environment variable for it to
  work:

  <div class="height:1px;" />

  * `AUTH_SECRET`: A secret key used for signing and verifying JWT. This
    can be a random 32-byte base64 string generated with `openssl rand -base64
        32`.

  <div class="height:1px;" />

  * `SITE_URL`: The absolute URL of your self-hosted instance of Infisical including the protocol (e.g. [https://app.infisical.com](https://app.infisical.com))
</Note>


# Keycloak OIDC Group Membership Mapping
Source: https://infisical.com/docs/documentation/platform/sso/keycloak-oidc/group-membership-mapping

Learn how to sync Keycloak group members to matching groups in Infisical.

You can have Infisical automatically sync group
memberships between Keycloak and Infisical by configuring a group membership mapper in Keycloak.
When a user logs in via OIDC, they will be added to Infisical groups that match their Keycloak groups names, and removed from any
Infisical groups not present in their groups claim.

<Info>
  When enabled, manual
  management of Infisical group memberships will be disabled.
</Info>

<Warning>
  Group membership changes in the Keycloak only sync with Infisical when a
  user logs in via OIDC. For example, if you remove a user from a group in Keycloak, this change will not be reflected in Infisical until their next OIDC login. To ensure this behavior, Infisical recommends enabling Enforce OIDC
  SSO in the OIDC settings.
</Warning>

<Steps>
  <Step title="Configure a group membership mapper in Keycloak">
    1.1. In your realm, navigate to the **Clients** tab and select your Infisical client.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/keycloak-oidc/group-membership-mapping/select-client.png" alt="OIDC keycloak client" />

    1.2. Select the **Client Scopes** tab.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/keycloak-oidc/group-membership-mapping/select-client-scopes.png" alt="OIDC keycloak client scopes" />

    1.3. Next, select the dedicated scope for your Infisical client.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/keycloak-oidc/group-membership-mapping/select-dedicated-scope.png" alt="OIDC keycloak dedicated scope" />

    1.4. Click on the **Add mapper** button, and select the **By configuration** option.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/keycloak-oidc/group-membership-mapping/create-mapper-by-configuration.png" alt="OIDC keycloak add mapper by configuration" />

    1.5. Select the **Group Membership** option.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/keycloak-oidc/group-membership-mapping/select-group-membership-mapper.png" alt="OIDC keycloak group membership option" />

    1.6. Give your mapper a name and ensure the following properties are set to the following before saving:

    * **Token Claim Name** is set to `groups`
    * **Full group path** is disabled

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/keycloak-oidc/group-membership-mapping/create-group-membership-mapper.png" alt="OIDC keycloak group membership mapper" />
  </Step>

  <Step title="Setup groups in Infisical and enable OIDC Group Membership Mapping">
    2.1. In Infisical, create any groups you would like to sync users to. Make sure the name of the Infisical group is an exact match of the Keycloak group name.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/keycloak-oidc/group-membership-mapping/create-infisical-group.png" alt="OIDC keycloak infisical group" />

    2.2. Next, enable **OIDC Group Membership Mapping** on the **Single Sign-On (SSO)** page under the **General** tab.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/keycloak-oidc/group-membership-mapping/enable-group-membership-mapping.png" alt="OIDC keycloak enable group membership mapping" />

    2.3. The next time a user logs in they will be synced to their matching Keycloak groups.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/keycloak-oidc/group-membership-mapping/synced-users.png" alt="OIDC keycloak synced users" />
  </Step>
</Steps>


# Keycloak OIDC Overview
Source: https://infisical.com/docs/documentation/platform/sso/keycloak-oidc/overview

Learn how to configure Keycloak OIDC for Infisical SSO.

<Info>
  Keycloak OIDC SSO is a paid feature. If you're using Infisical Cloud, then it
  is available under the **Pro Tier**. If you're self-hosting Infisical, then
  you should contact [sales@infisical.com](mailto:sales@infisical.com) to purchase a self-hosted license to
  use it.
</Info>

<Steps>
  <Step title="Create an OIDC client application in Keycloak">
    1.1. In your realm, navigate to the **Clients** tab and click **Create client** to create a new client application.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/keycloak-oidc/clients-list.png" alt="OIDC keycloak list of clients" />

    <Info>
      You dont typically need to make a realm dedicated to Infisical. We recommend adding Infisical as a client to your primary realm.
    </Info>

    1.2. In the General Settings step, set **Client type** to **OpenID Connect**, the **Client ID** field to an appropriate identifier, and the **Name** field to a friendly name like **Infisical**.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/keycloak-oidc/create-client-general-settings.png" alt="OIDC keycloak create client general settings" />

    1.3. Next, in the Capability Config step, ensure that **Client Authentication** is set to On and that **Standard flow** is enabled in the Authentication flow section.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/keycloak-oidc/create-client-capability.png" alt="OIDC keycloak create client capability config settings" />

    1.4. In the Login Settings step, set the following values:

    * Root URL: `https://app.infisical.com`.
    * Home URL: `https://app.infisical.com`.
    * Valid Redirect URIs: `https://app.infisical.com/api/v1/sso/oidc/callback`.
    * Web origins: `https://app.infisical.com`.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/keycloak-oidc/create-client-login-settings.png" alt="OIDC keycloak create client login settings" />

    <Info>
      If youre self-hosting Infisical, then you will want to replace [https://app.infisical.com](https://app.infisical.com) (base URL) with your own domain.
    </Info>

    1.5. Next, navigate to the **Client scopes** tab and select the client's dedicated scope.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/keycloak-oidc/client-scope-list.png" alt="OIDC keycloak client scopes list" />

    1.6. Next, click **Add predefined mapper**.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/keycloak-oidc/client-scope-mapper-menu.png" alt="OIDC keycloak client mappers empty" />

    1.7. Select the **email**, **given name**, **family name** attributes and click **Add**.

    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/keycloak-oidc/scope-predefined-mapper-1.png" alt="OIDC keycloak client mappers predefined 1" />
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/keycloak-oidc/scope-predefined-mapper-2.png" alt="OIDC keycloak client mappers predefined 2" />

    Once you've completed the above steps, the list of mappers should look like the following:
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/keycloak-oidc/client-scope-complete-overview.png" alt="OIDC keycloak client mappers completed" />
  </Step>

  <Step title="Retrieve Identity Provider (IdP) Information from Keycloak">
    2.1. Back in Keycloak, navigate to Configure > Realm settings > General tab > Endpoints > OpenID Endpoint Configuration and copy the opened URL. This is what is to referred to as the Discovery Document URL and it takes the form: `https://keycloak-mysite.com/realms/myrealm/.well-known/openid-configuration`.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/keycloak-oidc/realm-setting-oidc-config.png" alt="OIDC keycloak realm OIDC metadata" />

    2.2. From the Clients page, navigate to the Credential tab and copy the **Client Secret** to be used in the next steps.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/keycloak-oidc/client-secret.png" alt="OIDC keycloak realm OIDC secret" />
  </Step>

  <Step title="Finish configuring OIDC in Infisical">
    3.1. Back in Infisical, head to the **Single Sign-On (SSO)** page and select the **General** tab. Click **Connect** for **OIDC**.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/connect-oidc.png" alt="OIDC SSO Connect" />

    3.2. For configuration type, select Discovery URL. Then, set the appropriate values for **Discovery Document URL**, **JWT Signature Algorithm**, **Client ID**, and **Client Secret**.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/keycloak-oidc/create-oidc.png" alt="OIDC keycloak paste values into Infisical" />

    <Info>
      Currently, the following JWT signature algorithms are supported: RS256, RS512, HS256, and EdDSA
    </Info>

    Once you've done that, press **Update** to complete the required configuration.
  </Step>

  <Step title="Enable OIDC SSO in Infisical">
    Enabling OIDC SSO allows members in your organization to log into Infisical via Keycloak.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/enable-oidc.png" alt="OIDC keycloak enable OIDC" />
  </Step>

  <Step title="Enforce OIDC SSO in Infisical">
    Enforcing OIDC SSO ensures that members in your organization can only access Infisical
    by logging into the organization via Keycloak.

    To enforce OIDC SSO, you're required to test out the OpenID connection by successfully authenticating at least one Keycloak user with Infisical.
    Once you've completed this requirement, you can toggle the **Enforce OIDC SSO** button to enforce OIDC SSO.

    <Warning>
      We recommend ensuring that your account is provisioned using the application in Keycloak
      prior to enforcing OIDC SSO to prevent any unintended issues.
    </Warning>

    <Info>
      In case of a lockout, an organization admin can use the [Admin Login Portal](https://infisical.com/docs/documentation/platform/sso/overview#admin-login-portal) in the `/login/admin` path e.g. [https://app.infisical.com/login/admin](https://app.infisical.com/login/admin).
    </Info>
  </Step>
</Steps>

<Tip>
  If you are only using one organization on your Infisical instance, you can configure a default organization in the [Server Admin Console](/documentation/platform/admin-panel/server-admin#default-organization) to expedite OIDC login.
</Tip>

<Note>
  If you're configuring OIDC SSO on a self-hosted instance of Infisical, make
  sure to set the `AUTH_SECRET` and `SITE_URL` environment variable for it to
  work:

  <div class="height:1px;" />

  * `AUTH_SECRET`: A secret key used for signing and verifying JWT. This
    can be a random 32-byte base64 string generated with `openssl rand -base64
        32`.

  <div class="height:1px;" />

  * `SITE_URL`: The absolute URL of your self-hosted instance of Infisical including the protocol (e.g. [https://app.infisical.com](https://app.infisical.com))
</Note>


# Keycloak SAML
Source: https://infisical.com/docs/documentation/platform/sso/keycloak-saml

Learn how to configure Keycloak SAML for Infisical SSO.

<Info>
  Keycloak SAML SSO is a paid feature.

  If you're using Infisical Cloud, then it is available under the **Pro Tier**. If you're self-hosting Infisical,
  then you should contact [sales@infisical.com](mailto:sales@infisical.com) to purchase an enterprise license to use it.
</Info>

<Steps>
  <Step title="Prepare the SAML SSO configuration in Infisical">
    In Infisical, head to the **Single Sign-On (SSO)** page and select the **General** tab. Click **Connect** for **SAML** under the Connect to an Identity Provider section. Select **Keycloak**, then click **Connect** again.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/connect-saml.png" alt="SSO connect section" />

    Next, copy the **Valid redirect URI** and **SP Entity ID** to use when configuring the Keycloak SAML application.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/keycloak/init-config.png" alt="Keycloak SAML initial configuration" />
  </Step>

  <Step title="Create a SAML client application in Keycloak">
    2.1. In your realm, navigate to the **Clients** tab and click **Create client** to create a new client application.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/keycloak/clients-list.png" alt="SAML keycloak list of clients" />

    <Info>
      You dont typically need to make a realm dedicated to Infisical. We recommend adding Infisical as a client to your primary realm.
    </Info>

    In the General Settings step, set **Client type** to **SAML**, the **Client ID** field to `https://app.infisical.com`, and the **Name** field to a friendly name like **Infisical**.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/keycloak/create-client-general-settings.png" alt="SAML keycloak create client general settings" />

    <Info>
      If youre self-hosting Infisical, then you will want to replace [https://app.infisical.com](https://app.infisical.com) with your own domain.
    </Info>

    Next, in the Login Settings step, set both the **Home URL** field and **Valid redirect URIs** field to the **Valid redirect URI** from step 1 and press **Save**.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/keycloak/create-client-login-settings.png" alt="SAML keycloak create client login settings" />

    2.2. Once you've created the client, under its **Settings** tab, make sure to set the following values:

    * Under **SAML Capabilities**:
      * Name ID format: email (or username).
      * Force name ID format: On.
      * Force POST binding: On.
      * Include AuthnStatement: On.
    * Under **Signature and Encryption**:
      * Sign documents: On.
      * Sign assertions: On.
      * Signature algorithm: RSA\_SHA256.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/keycloak/client-saml-capabilities.png" alt="SAML keycloak client SAML capabilities" />

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/keycloak/client-signature-encryption.png" alt="SAML keycloak client signature encryption" />

    2.3. Next, navigate to the **Client scopes** tab select the client's dedicated scope.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/keycloak/client-scopes-list.png" alt="SAML keycloak client scopes list" />

    Next click **Add predefined mapper**.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/keycloak/client-mappers-empty.png" alt="SAML keycloak client mappers empty" />

    Select the **X500 email**, **X500 givenName**, and **X500 surname** attributes and click **Add**.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/keycloak/client-mappers-predefined.png" alt="SAML keycloak client mappers predefined" />

    Now click on the **X500 email** mapper and set the **SAML Attribute Name** field to **email**.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/keycloak/client-mappers-email.png" alt="SAML keycloak client mappers email" />

    Repeat the same for **X500 givenName** and **X500 surname** mappers, setting the **SAML Attribute Name** field to **firstName** and **lastName** respectively.

    Next, back in the client scope's **Mappers**, click **Add mapper** and select **by configuration**.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/keycloak/client-mappers-by-configuration.png" alt="SAML keycloak client mappers by configuration" />

    Select **User Property**.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/keycloak/client-mappers-user-property.png" alt="SAML keycloak client mappers user property" />

    Set the the **Name** field to **Username**, the **Property** field to **username**, and the **SAML Attribute Name** to **username**.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/keycloak/client-mappers-username.png" alt="SAML keycloak client mappers username" />

    Repeat the same for the `id` attribute, setting the **Name** field to **ID**, the **Property** field to **id**, and the **SAML Attribute Name** to **id**.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/keycloak/client-mappers-id.png" alt="SAML keycloak client mappers id" />

    Once you've completed the above steps, the list of mappers should look like this:

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/keycloak/client-mappers-completed.png" alt="SAML keycloak client mappers completed" />
  </Step>

  <Step title="Retrieve Identity Provider (IdP) Information from Keycloak">
    Back in Keycloak, navigate to Configure > Realm settings > General tab > Endpoints > SAML 2.0 Identity Provider Metadata and copy the IDP URL. This should appear in various places and take the form: `https://keycloak-mysite.com/realms/myrealm/protocol/saml`.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/keycloak/realm-saml-metadata.png" alt="SAML keycloak realm SAML metadata" />

    Also, in the **Keys** tab, locate the RS256 key and copy the certificate to use when finishing configuring Keycloak SAML in Infisical.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/keycloak/realm-settings-keys.png" alt="SAML keycloak realm settings keys" />
  </Step>

  <Step title="Finish configuring SAML in Infisical">
    Back in Infisical, set **IDP URL** and **Certificate** to the items from step 3. Also, set the **Client ID** to the `https://app.infisical.com`.

    Once you've done that, press **Update** to complete the required configuration.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/keycloak/idp-values.png" alt="SAML Okta paste values into Infisical" />
  </Step>

  <Step title="Enable SAML SSO in Infisical">
    Enabling SAML SSO allows members in your organization to log into Infisical via Keycloak.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/keycloak/enable-saml.png" alt="SAML keycloak enable SAML" />
  </Step>

  <Step title="Enforce SAML SSO in Infisical">
    Enforcing SAML SSO ensures that members in your organization can only access Infisical
    by logging into the organization via Keycloak.

    To enforce SAML SSO, you're required to test out the SAML connection by successfully authenticating at least one Keycloak user with Infisical;
    Once you've completed this requirement, you can toggle the **Enforce SAML SSO** button to enforce SAML SSO.

    <Warning>
      We recommend ensuring that your account is provisioned the application in Keycloak
      prior to enforcing SAML SSO to prevent any unintended issues.
    </Warning>

    <Info>
      In case of a lockout, an organization admin can use the [Admin Login Portal](https://infisical.com/docs/documentation/platform/sso/overview#admin-login-portal) in the `/login/admin` path e.g. [https://app.infisical.com/login/admin](https://app.infisical.com/login/admin).
    </Info>
  </Step>
</Steps>

<Tip>
  If you are only using one organization on your Infisical instance, you can configure a default organization in the [Server Admin Console](../admin-panel/server-admin#default-organization) to expedite SAML login.
</Tip>

<Note>
  If you're configuring SAML SSO on a self-hosted instance of Infisical, make
  sure to set the `AUTH_SECRET` and `SITE_URL` environment variable for it to
  work:

  <div class="height:1px;" />

  * `AUTH_SECRET`: A secret key used for signing and verifying JWT. This
    can be a random 32-byte base64 string generated with `openssl rand -base64
        32`.

  <div class="height:1px;" />

  * `SITE_URL`: The absolute URL of your self-hosted instance of Infisical including the protocol (e.g. [https://app.infisical.com](https://app.infisical.com))
</Note>


# Okta SAML
Source: https://infisical.com/docs/documentation/platform/sso/okta

Learn how to configure Okta SAML 2.0 for Infisical SSO.

<Info>
  Okta SAML SSO is a paid feature. If you're using Infisical Cloud, then it is
  available under the **Pro Tier**. If you're self-hosting Infisical, then you
  should contact [sales@infisical.com](mailto:sales@infisical.com) to purchase an enterprise license to use
  it.
</Info>

<Steps>
  <Step title="Prepare the SAML SSO configuration in Infisical">
    In Infisical, head to the **Single Sign-On (SSO)** page and select the **General** tab. Click **Connect** for **SAML** under the Connect to an Identity Provider section. Select **Okta**, then click **Connect** again.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/connect-saml.png" alt="SSO connect section" />

    Next, copy the **Single sign-on URL** and **Audience URI (SP Entity ID)** to use when configuring the Okta SAML 2.0 application.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/okta/init-config.png" alt="Okta SAML initial configuration" />
  </Step>

  <Step title="Create a SAML application in Okta">
    In the Okta Admin Portal, select Applications > Applications from the navigation. On the Applications screen, select the **Create App Integration**
    button.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/okta/create-app-integration.png" alt="SAML Okta create app integration" />

    In the Create a New Application Integration dialog, select the **SAML 2.0** radio button:

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/okta/create-saml-app.png" alt="SAML Okta create SAML 2.0 integration" />

    On the General Settings screen, give the application a unique name like Infisical and select **Next**.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/okta/general-settings.png" alt="SAML Okta create SAML 2.0 integration" />

    On the Configure SAML screen, set the **Single sign-on URL** and **Audience URI (SP Entity ID)** from step 1.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/okta/configure-saml.png" alt="SAML Okta configure IdP fields" />

    <Note>
      If you're self-hosting Infisical, then you will want to replace
      `https://app.infisical.com` with your own domain.
    </Note>

    Also on the Configure SAML screen, configure the **Attribute Statements** to map:

    * `id -> user.id`,
    * `email -> user.email`,
    * `firstName -> user.firstName`
    * `lastName -> user.lastName`

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/okta/attribute-statements.png" alt="SAML Okta attribute statements" />

    Once configured, select **Next** to proceed to the Feedback screen and select **Finish**.
  </Step>

  <Step title="Retrieve Identity Provider (IdP) Information from Okta">
    Once your application is created, select the **Sign On** tab for the app and select the **View Setup Instructions** button located on the right side of the screen:

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/okta/view-setup-instructions.png" alt="SAML Okta view setup instructions" />

    Copy the **Identity Provider Single Sign-On URL**, the **Identity Provider Issuer**, and the **X.509 Certificate** to use when finishing configuring Okta SAML in Infisical.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/okta/idp-values.png" alt="SAML Okta IdP values" />
  </Step>

  <Step title="Finish configuring SAML in Infisical">
    Back in Infisical, set **Identity Provider Single Sign-On URL**, **Identity Provider Issuer**,
    and **Certificate** to **X.509 Certificate** from step 3. Once you've done that, press **Update** to complete the required configuration.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/okta/idp-values-2.png" alt="SAML Okta paste values into Infisical" />
  </Step>

  <Step title="Assign users in Okta to the application">
    Back in Okta, navigate to the **Assignments** tab and select **Assign**. You can assign access to the application on a user-by-user basis using the Assign to People option, or in-bulk using the Assign to Groups option.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/okta/assignment.png" alt="SAML Okta assignment" />

    At this point, you have configured everything you need within the context of the Okta Admin Portal.
  </Step>

  <Step title="Enable SAML SSO in Infisical">
    Enabling SAML SSO allows members in your organization to log into Infisical via Okta.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/okta/enable-saml.png" alt="SAML Okta enable SAML" />
  </Step>

  <Step title="Enforce SAML SSO in Infisical">
    Enforcing SAML SSO ensures that members in your organization can only access Infisical
    by logging into the organization via Okta.

    To enforce SAML SSO, you're required to test out the SAML connection by successfully authenticating at least one Okta user with Infisical;
    Once you've completed this requirement, you can toggle the **Enforce SAML SSO** button to enforce SAML SSO.

    <Warning>
      We recommend ensuring that your account is provisioned for the application in Okta prior to enforcing SAML SSO to prevent any unintended issues.
    </Warning>

    <Info>
      In case of a lockout, an organization admin can use the [Admin Login Portal](https://infisical.com/docs/documentation/platform/sso/overview#admin-login-portal) in the `/login/admin` path e.g. [https://app.infisical.com/login/admin](https://app.infisical.com/login/admin).
    </Info>
  </Step>
</Steps>

<Tip>
  If you are only using one organization on your Infisical instance, you can configure a default organization in the [Server Admin Console](../admin-panel/server-admin#default-organization) to expedite SAML login.
</Tip>

<Note>
  If you're configuring SAML SSO on a self-hosted instance of Infisical, make
  sure to set the `AUTH_SECRET` and `SITE_URL` environment variable for it to
  work:

  <div class="height:1px;" />

  * `AUTH_SECRET`: A secret key used for signing and verifying JWT. This
    can be a random 32-byte base64 string generated with `openssl rand -base64
        32`.

  <div class="height:1px;" />

  * `SITE_URL`: The absolute URL of your self-hosted instance of Infisical including the protocol (e.g. [https://app.infisical.com](https://app.infisical.com))
</Note>


# SSO Overview
Source: https://infisical.com/docs/documentation/platform/sso/overview

Learn how to log in to Infisical via SSO protocols.

<Info>
  Infisical offers Google SSO and GitHub SSO for free across both Infisical
  Cloud and Infisical Self-hosted. Infisical also offers SAML SSO authentication
  and OpenID Connect (OIDC) but as paid features that can be unlocked on
  Infisical Cloud's **Pro** tier or via enterprise license on self-hosted
  instances of Infisical. On this front, we support industry-leading providers
  including Okta, Azure AD, and JumpCloud; with any questions, please reach out
  to [team@infisical.com](mailto:team@infisical.com).
</Info>

You can configure your organization in Infisical to have members authenticate with the platform via protocols like [SAML 2.0](https://en.wikipedia.org/wiki/SAML_2.0) or [OpenID Connect](https://openid.net/specs/openid-connect-core-1_0.html).

## Identity providers

Infisical supports these and many other identity providers:

* [Google SSO](/documentation/platform/sso/google)
* [GitHub SSO](/documentation/platform/sso/github)
* [GitLab SSO](/documentation/platform/sso/gitlab)
* [Okta SAML](/documentation/platform/sso/okta)
* [Azure SAML](/documentation/platform/sso/azure)
* [JumpCloud SAML](/documentation/platform/sso/jumpcloud)
* [Keycloak SAML](/documentation/platform/sso/keycloak-saml)
* [Google SAML](/documentation/platform/sso/google-saml)
* [Auth0 SAML](/documentation/platform/sso/auth0-saml)
* [Keycloak OIDC](/documentation/platform/sso/keycloak-oidc)
* [Auth0 OIDC](/documentation/platform/sso/auth0-oidc)
* [General OIDC](/documentation/platform/sso/general-oidc)

If your required identity provider is not shown in the list above, please reach out to [team@infisical.com](mailto:team@infisical.com) for assistance.

<Info>
  For enhanced security, Infisical enforces PKCE (Proof Key for Code Exchange) with the OAuth 2.0-based SSO providers and OIDC. This provides additional protection against authorization code interception attacks and strengthens your authentication flow security.
</Info>

## SSO Break Glass

In the event your SSO provider experiences downtime, and you need to access Infisical, Organization Admins can utilize the Admin Login Portal to bypass SSO enforcement.

This portal is accessible at `/login/admin` (e.g., [https://app.infisical.com/login/admin](https://app.infisical.com/login/admin)).

<Note>
  To bypass SSO for an organization, you must be an **Organization Admin** for that specific organization. This **Organization Admin** role is independent of **Server Admin** status. Being a **Server Admin** alone does not grant permission to use this bypass feature.
</Note>

## FAQ

<AccordionGroup>
  <Accordion title="Why does Infisical require additional email verification for users connected via SAML?">
    By default, Infisical Cloud is configured to not trust emails from external
    identity providers to prevent any malicious account takeover attempts via
    email spoofing. Accordingly, Infisical creates a new user for anyone provisioned
    through an external identity provider and requires an additional email
    verification step upon their first login.

    If you're running a self-hosted instance of Infisical and would like it to trust emails from external identity providers,
    you can configure this behavior in the Server Admin Console.
  </Accordion>

  <Accordion title="Why do I get redirected to SSO when trying to use the Admin Login Portal?">
    You are likely being redirected because you do not have email authentication mode enabled, or you're not an **Organization Admin**. This portal requires **Organization Admin** status and direct credential login (email and password). **Server Admin** status alone is insufficient.
  </Accordion>
</AccordionGroup>


# PingOne OIDC
Source: https://infisical.com/docs/documentation/platform/sso/pingone-oidc

Learn how to configure PingOne OIDC for Infisical SSO.

<Info>
  PingOne OIDC SSO is a paid feature. If you're using Infisical Cloud, then it is
  available under the **Pro Tier**. If you're self-hosting Infisical, then you
  should contact [sales@infisical.com](mailto:sales@infisical.com) to purchase a self-hosted license to use
  it.
</Info>

<Steps>
  <Step title="Setup application in PingOne">
    1.1. From the Application's Page, create a new OIDC Web App application.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/pingone-oidc/pingone-create-application.png" alt="OIDC pingone create application" />

    1.2. Enable the application by pressing the "Enable" toggle.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/pingone-oidc/pingone-enable-application.png" alt="OIDC PingOne Enable Application" />

    1.3. In the Application "Configuration" tab, press the "Edit" pencil icon to configure the application callback URI.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/pingone-oidc/pingone-edit-application-configuration.png" alt="OIDC PingOne Edit Application Configuration" />

    1.4 Set the Redirect URL to `https://app.infisical.com/api/v1/sso/oidc/callback` and press the "Save" button.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/pingone-oidc/pingone-edit-application-redirect-uri.png" alt="OIDC PingOne Edit Redirect URI" />

    <Info>
      If you're self-hosting Infisical, then you will want to replace [https://app.infisical.com](https://app.infisical.com) with your own domain.
    </Info>

    1.5 After configuring the redirect URL, go to the "Attribute Mappings" tab and press the "Edit" pencil icon to configure the attribute mappings.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/pingone-oidc/pingone-edit-application-attribute-mappings.png" alt="OIDC PingOne Edit Attribute Mappings" />

    1.6 Map the following attributes:

    * `email` -> `Email Address`
    * `name` -> `Username`
      <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/pingone-oidc/pingone-edit-application-attribute-mappings-2.png" alt="OIDC PingOne Edit Attribute Mappings" />

    Once done, press the "Save" button.
  </Step>

  <Step title="Retrieve Identity Provider (IdP) Information from PingOne">
    2.1. Open the "Overview" tab and copy the **Client ID** and **Client Secret**.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/pingone-oidc/pingone-overview-credentials.png" alt="OIDC PingOne Application Credential" />

    2.2. Still in the "Overview" tab, scroll down to the Connection Details section and retrieve the **OIDC Discovery Endpoint**.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/pingone-oidc/pingone-overview-oidc-discovery-endpoint.png" alt="OIDC PingOne OIDC Discovery Endpoint" />

    Keep these values handy as we will need them in the next steps.
  </Step>

  <Step title="Finish configuring OIDC in Infisical">
    3.1. Back in Infisical, head to the **Single Sign-On (SSO)** page and select the **General** tab. Click **Connect** for **OIDC**.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/connect-oidc.png" alt="OIDC SSO Connect" />

    3.2. For configuration type, select **Discovery URL**. Then, set **Discovery Document URL**, **Client ID**, and **Client Secret** from step 2.1 and 2.2.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/pingone-oidc/infisical-configure-oidc.png" alt="OIDC PingOne paste values into Infisical" />

    <Info>
      Currently, the following JWT signature algorithms are supported: RS256, RS512, HS256, and EdDSA
    </Info>

    Once you've done that, press **Update** to complete the required configuration.
  </Step>

  <Step title="Enable OIDC in Infisical">
    Enabling OIDC allows members in your organization to log into Infisical via PingOne

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sso/enable-oidc.png" alt="OIDC PingOne enable OIDC" />
  </Step>

  <Step title="Enforce OIDC SSO in Infisical">
    Enforcing OIDC SSO ensures that members in your organization can only access Infisical
    by logging into the organization via PingOne.

    To enforce OIDC SSO, you're required to test out the OpenID connection by successfully authenticating at least one PingOne user with Infisical.
    Once you've completed this requirement, you can toggle the **Enforce OIDC SSO** button to enforce OIDC SSO.

    <Warning>
      We recommend ensuring that your account is provisioned using the application in PingOne
      prior to enforcing OIDC SSO to prevent any unintended issues.
    </Warning>

    <Info>
      In case of a lockout, an organization admin can use the [Admin Login Portal](https://infisical.com/docs/documentation/platform/sso/overview#admin-login-portal) in the `/login/admin` path e.g. [https://app.infisical.com/login/admin](https://app.infisical.com/login/admin).
    </Info>
  </Step>
</Steps>

<Tip>
  If you are only using one organization on your Infisical instance, you can configure a default organization in the [Server Admin Console](../admin-panel/server-admin#default-organization) to expedite OIDC login.
</Tip>

<Note>
  If you're configuring OIDC SSO on a self-hosted instance of Infisical, make
  sure to set the `AUTH_SECRET` and `SITE_URL` environment variable for it to
  work:

  <div class="height:1px;" />

  * `AUTH_SECRET`: A secret key used for signing and verifying JWT. This
    can be a random 32-byte base64 string generated with `openssl rand -base64
      32`.

  <div class="height:1px;" />

  * `SITE_URL`: The absolute URL of your self-hosted instance of Infisical including the protocol (e.g. [https://app.infisical.com](https://app.infisical.com))
</Note>


# Service Token
Source: https://infisical.com/docs/documentation/platform/token

Infisical service tokens allow users to programmatically interact with Infisical.

Service tokens are authentication credentials that services can use to access designated endpoints in the Infisical API to manage project resources like secrets.
Each service token can be provisioned scoped access to select environment(s) and path(s) within them.

## Service Tokens

You can manage service tokens in Access Control > Service Tokens (tab).

### Service Token (Current)

Service Token (ST) is the current widely-used authentication method for managing secrets.

Here's a few pointers to get you acquainted with it:

* When you create a ST, you get a token prefixed with `st`. The part after the last `.` delimiter is a symmetric key; everything
  before it is an access token. When authenticating with the Infisical API, it is important to send in only the access token portion
  of the token.
* ST supports expiration; it gets deleted automatically upon expiration.
* ST supports provisioning `read` and/or `write` permissions broadly applied to all accessible environment(s) and path(s).
* ST is not editable.

## Creating a service token

To create a service token, head to Access Control > Service Tokens as shown below and press **Create token**.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/project-token-old-add.png" alt="token add" />

Now input any token configuration details such as which environment(s) and path(s) you'd like to provision
the token access to. Here's some guidance for each field:

* Name: A friendly name for the token.
* Scopes: The environment(s) and path(s) the token should have access to.
* Permissions: You can indicate whether or not the token should have `read/write` access to the paths.
  Also, note that Infisical supports [glob patterns](https://www.malikbrowne.com/blog/a-beginners-guide-glob-patterns/) when defining access scopes to path(s).
* Expiration: The time when this token should be rendered inactive.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/project-token-old-permissions.png" alt="token add" />

In the above screenshot, you can see that we are creating a token token with `read` access to all subfolders at any depth
of the `/common` path within the development environment of the project; the token expires in 6 months and can be used from any IP address.

<Note>
  For a deeper understanding of service tokens, it is recommended to read [this
  guide](https://infisical.com/docs/internals/service-tokens).
</Note>

**FAQ**

<AccordionGroup>
  <Accordion title="Why is the Infisical API rejecting my service token?">
    There are a few reasons for why this might happen:

    * The service token has expired.
    * The service token is insufficiently permissioned to interact with the secrets in the given environment and path.
    * You are attempting to access a `/raw` secrets endpoint that requires your project to disable E2EE.
    * (If using ST V3) The service token has not been activated yet.
    * (If using ST V3) The service token is being used from an untrusted IP.
  </Accordion>

  <Accordion title="Can you provide examples for using glob patterns?">
    1. `/**`: This pattern matches all folders at any depth in the directory structure. For example, it would match folders like `/folder1/`, `/folder1/subfolder/`, and so on.

    2. `/*`: This pattern matches all immediate subfolders in the current directory. It does not match any folders at a deeper level. For example, it would match folders like `/folder1/`, `/folder2/`, but not `/folder1/subfolder/`.

    3. `/*/*`: This pattern matches all subfolders at a depth of two levels in the current directory. It does not match any folders at a shallower or deeper level. For example, it would match folders like `/folder1/subfolder/`, `/folder2/subfolder/`, but not `/folder1/` or `/folder1/subfolder/subsubfolder/`.

    4. `/folder1/*`: This pattern matches all immediate subfolders within the `/folder1/` directory. It does not match any folders outside of `/folder1/`, nor does it match any subfolders within those immediate subfolders. For example, it would match folders like `/folder1/subfolder1/`, `/folder1/subfolder2/`, but not `/folder2/subfolder/`.
  </Accordion>
</AccordionGroup>


# Webhooks
Source: https://infisical.com/docs/documentation/platform/webhooks

Learn the fundamentals of Infisical webhooks.

Webhooks can be used to trigger changes to your integrations when secrets are modified, providing smooth integration with other third-party applications.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/webhooks.png" alt="webhooks" />

To create a webhook for a particular project, go to `Project Settings > Webhooks`.

Infisical supports two webhook types - General and Slack. If you need to integrate with Slack, use the Slack type with an [Incoming Webhook](https://api.slack.com/messaging/webhooks). When creating a webhook, you can specify an environment and folder path to trigger only specific integrations.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/webhook-create.png" alt="webhook-create" />

## Secret Key Verification

A secret key is a way for users to verify that a webhook request was sent by Infisical and is intended for the correct integration.

When you provide a secret key, Infisical will sign the payload of the webhook request using the key and attach a header called `x-infisical-signature` to the request with a payload.

The header will be in the format `t=<timestamp>;<signature>`. You can then generate the signature yourself by generating a SHA256 hash of the payload with the secret key that you know.

If the signature in the header matches the signature that you generated, then you can be sure that the request was sent by Infisical and is intended for your integration. The timestamp in the header ensures that the request is not replayed.

### Webhook Payload Format

```json  theme={"dark"}
{
  "event": "secrets.modified",
  "project": {
    "workspaceId": "the workspace id",
    "environment": "project environment",
    "secretPath": "project folder path"
  },
  "timestamp": ""
}
```

```json  theme={"dark"}
{
  "event": "secrets.reminder-expired",
  "project": {
    "workspaceId": "the workspace id",
    "environment": "project environment",
    "secretPath": "project folder path",
    "secretName": "name of the secret",
    "secretId": "id of the secret",
    "reminderNote": "reminder note of the secret"
  },
  "timestamp": ""
}
```


# Microsoft Teams Integration
Source: https://infisical.com/docs/documentation/platform/workflow-integrations/microsoft-teams-integration

Learn how to setup the Microsoft Teams integration

This guide will provide step by step instructions on how to configure Microsoft Teams integration for your Infisical projects.

## Setting up Microsoft Teams integration in your projects

<Tabs>
  <Tab title="Infisical Cloud">
    ### Create Microsoft Teams workflow integration

    <Steps>
      <Step title="Install the Infisical Microsoft Teams App in Microsoft Teams tenant">
        Currently, Infisical requires you to install a custom Microsoft Teams app into your Microsoft Teams tenant.

        You can download the Infisical Microsoft Teams app package here:

        * [Infisical Microsoft Teams app package](https://infisical-microsoft-teams-app.s3.us-east-1.amazonaws.com/Infisical.zip)

        <Note>
          **Important for self-hosted users:**

          If you're self-hosting Infisical, you can skip the download step. Instead you should use the app package file you downloaded from the Microsoft Teams Developer Portal when you followed the Self-hosted guide.
        </Note>

        Once you've downloaded the app package, you can install the app in your Microsoft Teams tenant by navigating to the **Apps** > **Upload a custom app** page, and selecting the "Upload an app" button.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/workflow-integrations/microsoft-teams-integration/microsoft-teams-install-app.png" alt="microsoft-teams-install-app" />
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/workflow-integrations/microsoft-teams-integration/microsoft-teams-submit-app.png" alt="microsoft-teams-submit-app" />

        Once the app has been submitted, your Microsoft Teams tenant admin will need to approve the app in the [Microsoft Teams Admin Center](https://admin.teams.microsoft.com/policies/manage-apps).

        <Warning>
          After the app has been approved, it can take a few hours *(up to 24 hours in some cases)* for Microsoft Teams to reflect the new app. During this period, the Infisical app will not be visible in Microsoft Teams, and won't be usable.
        </Warning>

        Once the app has been approved, you will be able to use the Infisical Microsoft Teams integration in your projects.
      </Step>

      <Step title="Add the Infisical Microsoft Teams app to your Microsoft Teams teams">
        Once the app has been approved and installed in your Microsoft Teams tenant, you can add the app to your Microsoft Teams teams.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/workflow-integrations/microsoft-teams-integration/microsoft-teams-add-app.png" alt="microsoft-teams-add-app" />

        Navigate to **Apps** > **Built for your org**, select the "Infisical" app, and press the "Add" button to select the teams and channels you wish to add the app to.

        <Info>
          This can also be done later through the [Microsoft Teams Admin Center](https://admin.teams.microsoft.com/policies/manage-apps), or through the Microsoft Teams client itself by navigating to the individual team's app settings.
        </Info>

        Once the app has been added to the team, you will be able to use the Infisical Microsoft Teams integration in the team.
      </Step>

      <Step title="Navigate to the Workflow Integrations tab in your organization settings">
        After installing the Microsoft Teams app, you are now ready to configure the Microsoft Teams integration within Infisical.

        Navigate to the **Workflow Integrations** tab in your organization settings, and press the "Add" button.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/workflow-integrations/microsoft-teams-integration/infisical-org-overview.png" alt="org-integrations-overview" />
      </Step>

      <Step title="Create a Microsoft Teams workflow integration">
        In order to use the Infisical Microsoft Teams integration, you will need to grant admin consent to the app. Once the consent is granted, the Microsoft Teams workflow integration will be created in your Infisical organization.

        Press the "Add" button and select the "Microsoft Teams" platform option.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/workflow-integrations/microsoft-teams-integration/infisical-org-add-microsoft-teams-integration.png" alt="add-microsoft-teams-integration" />

        Select the Microsoft Teams integration you wish to configure, and press the "Configure" button.

        Here you will be prompted to enter an alias, tenant ID, and an optional description for your workflow integration.
        The tenant ID is the ID of the Microsoft 365 / Azure AD tenant that you installed the Infisical Microsoft Teams app in, in the previous steps.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/workflow-integrations/microsoft-teams-integration/infisical-org-microsoft-teams-integration-modal.png" alt="configure-microsoft-teams-integration" />

        Press the "Create Microsoft Teams Integration" button, and you'll be navigated to the Azure AD consent page.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/workflow-integrations/microsoft-teams-integration/microsoft-consent-page.png" alt="microsoft-consent-page" />

        <Note>
          Please note that you must be a privileged administrator user of your Microsoft 365 / Azure AD tenant in order to grant admin consent to the app.
        </Note>

        Once you've granted admin consent, you'll be navigated back to the Infisical organization settings, where you can now select the Microsoft Teams integration you just created.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/workflow-integrations/microsoft-teams-integration/microsoft-teams-workflow-integration-created.png" alt="microsoft-teams-workflow-integration-created" />
      </Step>
    </Steps>

    ### Configure project to use Microsoft Teams workflow integration

    <Steps>
      <Step title="Navigate to the Workflow Integrations tab in the project settings">
        To add a new Microsoft Teams workflow integration, navigate to **Project Settings** > **Workflow Integrations** and press the "Add".
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/workflow-integrations/microsoft-teams-integration/infisical-project-settings.png" alt="project-settings-workflow-integrations" />

        Select the "Microsoft Teams" option from the list of available workflow integrations.
      </Step>

      <Step title="Configure the Microsoft Teams workflow integration">
        Your project will send notifications to the connected Microsoft Teams team of the
        selected Microsoft Teams integration when the configured events are triggered.

        Press the "Save" button to save your Microsoft Teams workflow integration.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/workflow-integrations/microsoft-teams-integration/infisical-project-microsoft-teams-integration-save.png" alt="infisical-project-microsoft-teams-integration-save" />
      </Step>
    </Steps>

    Once you've created the project Microsoft Teams workflow integration, you will now receive Access Requests and Secret Approval Requests notifications in Microsoft Teams according to your configuration.
  </Tab>

  <Tab title="Self-hosted setup">
    ### Configure Azure Resources

    To create a Microsoft Teams bot, you must first create an Azure Bot from the Azure Marketplace, an app registration, and a Microsoft Teams app. The steps below document in detail how to create and configure these resources.

    <Steps>
      <Step title="Create Microsoft Teams app">
        Navigate to the [Microsoft Teams Developer Portal](https://dev.teams.microsoft.com/).

        Once you're on the Microsoft Teams Developer Portal, press the "Create a new app" button on the overview page. Give the bot a name and press the "Add" button.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/workflow-integrations/microsoft-teams-integration/teams-dev-portal-create-app.png" alt="microsoft-dev-portal" />
      </Step>

      <Step title="Create a Microsoft Teams bot">
        After creating the Microsoft Teams app, you'll need to create a Microsoft Teams bot.

        Navigate to the app's bot settings page and click "Create a new bot".

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/workflow-integrations/microsoft-teams-integration/teams-dev-portal-bot-app-feature.png" alt="microsoft-dev-portal-create-bot" />
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/workflow-integrations/microsoft-teams-integration/teams-dev-portal-create-a-new-bot.png" alt="microsoft-dev-portal-create-bot-2" />

        After clicking the "Create a new bot" button, you'll be navigated to the Teams Developer Portal for bot management. Press the "New bot" button, and enter the name of the bot.
        Please keep in mind that the name of the bot can only contain alphanumeric characters, dashes, and underscores.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/workflow-integrations/microsoft-teams-integration/teams-dev-portal-create-bot.png" alt="microsoft-dev-portal-create-bot-3" />
      </Step>

      <Step title="Add a message endpoint to the bot">
        After creating the bot, you'll need to add a message endpoint to the bot. Navigate to the "Configure" tab, and input the following endpoint under "Endpoint address":
        `https://<your-infisical-instance-url>/api/v1/workflow-integrations/microsoft-teams/message-endpoint`
        Replace `<your-infisical-instance-url>` with the URL of your Infisical instance.

        Press the "Save" button to save the changes.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/workflow-integrations/microsoft-teams-integration/teams-dev-portal-add-bot-endpoint.png" alt="microsoft-dev-portal-create-bot-4" />
      </Step>

      <Step title="Find the bot in Azure App Registrations">
        When you create a bot through the Teams Developer Portal, an Azure App Registration is also created.

        Open your [Azure Portal](https://portal.azure.com/) and navigate to the "App Registrations" section to find the newly created app registration.
        The name of the app registration will be the same as the name of the bot you created in the previous step.

        Press the app registration to open the app registration overview page.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/workflow-integrations/microsoft-teams-integration/azure-app-registrations-bot.png" alt="azure-app-registrations" />
      </Step>

      <Step title="Add API Permissions to the App Registration">
        Navigate to the "API Permissions" section of the app registration, and add the following permissions:

        * `AppCatalog.Read.All`
        * `ChannelSettings.Read.All`
        * `MultiTenantOrganization.Read.All`
        * `Organization.Read.All`
        * `Team.ReadBasic.All`
        * `TeamsAppInstallation.Read.All`

        After adding the API permissions, press the "Grant admin consent" button to grant the permissions.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/workflow-integrations/microsoft-teams-integration/azure-app-registration-api-permissions.png" alt="azure-app-registration-api-permissions" />
      </Step>

      <Step title="Add a new web application to the App Registration">
        Navigate to the "Authentication" section of the App Registration, and press the "Add a platform" button. Select the "Web" platform and enter the following redirect URI:
        `https://<your-infisical-instance-url>/organization/settings/oauth/callback`. Replace `<your-infisical-instance-url>` with the URL of your Infisical instance.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/workflow-integrations/microsoft-teams-integration/azure-app-registration-register-callback.png" alt="azure-app-registration-register-callback" />
      </Step>

      <Step title="Get App Registration Client ID and Client Secret">
        Next we need to get the application client ID and create a new client secret. **Save these values for later, as they're required to configure the Microsoft Teams integration in Infisical.**

        **Get the Application (Client) ID**

        To get the Application (Client) ID, press the "Copy" button next to the "Application (client) ID" field.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/workflow-integrations/microsoft-teams-integration/azure-app-registration-copy-client-id.png" alt="copy-client-id" />

        **Create a new client secret**

        Create a new client secret within the app registration. Navigate to the "Certificates & Secrets" section of the app registration, and press the "New client secret" button.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/workflow-integrations/microsoft-teams-integration/azure-app-registration-create-client-secret.png" alt="create-client-secret" />

        <Warning>
          Remember to rotate your client secret before it expires. Consider setting up a reminder or automated process to replace the secret and update your Infisical configuration before expiration.
        </Warning>
      </Step>

      <Step title="Get the Microsoft Teams App ID">
        Navigate back to the [Microsoft Teams Developer Portal](https://dev.teams.microsoft.com/), and press the "Apps" tab and select the app you created earlier.
        Here you can find the Microsoft Teams App ID in the overview page, which you need to copy and save for later.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/workflow-integrations/microsoft-teams-integration/teams-dev-portal-copy-app-id.png" alt="microsoft-teams-app-id" />
      </Step>

      <Step title="Link the Microsoft Teams App to the bot">
        You need to link the Microsoft Teams App with the bot/app registration you created earlier.
        Inside the [Microsoft Teams Developer Portal](https://dev.teams.microsoft.com/), navigate to the "Bot" tab and select the bot you created earlier. Navigate to the "App Features" section, and press the "Bot" button.

        Under the "What can your bot do?" section, enable `Only send notifications (one-way conversations)`.

        Under the "Select the scopes where people can use your bot" section, select `Personal`, `Team`, and `Group Chat`.

        Finally, press the "Save" button to save the changes.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/workflow-integrations/microsoft-teams-integration/teams-dev-portal-bot-app-feature.png" alt="microsoft-teams-app-features" />
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/workflow-integrations/microsoft-teams-integration/teams-dev-portal-configure-bot.png" alt="microsoft-teams-configure-bot" />
      </Step>

      <Step title="Run an app validation test (Recommended)">
        To ensure that the Microsoft Teams App is working correctly, you can run an app validation test. This step is optional, but recommended to ensure the app is working correctly.

        You should expect to see two errors related to sending welcome messages, because we haven't configured the Microsoft Teams App inside Infisical yet, which is required for proactive messages.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/workflow-integrations/microsoft-teams-integration/teams-dev-portal-app-validation.png" alt="microsoft-teams-app-validation-test" />

        <Note>
          You may see manifest validation errors. Before running an app validation test, you must ensure that your app has all errors resolved, such as having a description and a valid name.
        </Note>

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/workflow-integrations/microsoft-teams-integration/teams-dev-portal-app-validation-result.png" alt="microsoft-teams-app-validation-test-results" />

        <Note>
          If you see two errors for bot welcome messages, you can ignore them. This is expected until you configure the Microsoft Teams App inside Infisical.
        </Note>
      </Step>

      <Step title="Download the App Package">
        Once the Microsoft Teams App is working correctly, you can download the app package by navigating to the "Publish to Store" page, and pressing the "Download app package" button.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/workflow-integrations/microsoft-teams-integration/teams-dev-portal-download-app-package.png" alt="microsoft-teams-download-app-package" />
      </Step>
    </Steps>

    ### Configure Microsoft Teams Bot in Infisical

    After creating the Microsoft Teams App and Bot, you are ready to configure the Microsoft Teams integration in Infisical.
    Please note that you must be an instance admin in order to configure the Microsoft Teams instance-wide settings.

    <Steps>
      <Step title="Navigate to the Integrations tab in your Server Admin Console settings">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/workflow-integrations/microsoft-teams-integration/infisical-server-admin-console-tab.png" alt="server-admin-console-tab" />
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/workflow-integrations/microsoft-teams-integration/infisical-instance-configure-microsoft-teams.png" alt="infisical-instance-configure-microsoft-teams" />

        Enter the values you saved from the earlier steps into the respective fields.

        * **Application (Client) ID**: The Client ID of the App Registration from the previous steps.
        * **Client Secret**: The Client Secret of the App Registration from the previous steps.
        * **Microsoft Teams App ID**: The App ID of the Microsoft Teams App from the previous steps.

        Once completed, press the "Save" button to save your changes.
      </Step>
    </Steps>

    ### Create Microsoft Teams workflow integration

    <Steps>
      <Step title="Install the Infisical Microsoft Teams App in Microsoft Teams tenant">
        Currently, Infisical requires you to install a custom Microsoft Teams app into your Microsoft Teams tenant.

        You can download the Infisical Microsoft Teams app package here:

        * [Infisical Microsoft Teams app package](https://infisical-microsoft-teams-app.s3.us-east-1.amazonaws.com/Infisical.zip)

        <Note>
          **Important for self-hosted users:**

          If you're self-hosting Infisical, you can skip the download step. Instead you should use the app package file you downloaded from the Microsoft Teams Developer Portal when you followed the Self-hosted guide.
        </Note>

        Once you've downloaded the app package, you can install the app in your Microsoft Teams tenant by navigating to the **Apps** > **Upload a custom app** page, and selecting the "Upload an app" button.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/workflow-integrations/microsoft-teams-integration/microsoft-teams-install-app.png" alt="microsoft-teams-install-app" />
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/workflow-integrations/microsoft-teams-integration/microsoft-teams-submit-app.png" alt="microsoft-teams-submit-app" />

        Once the app has been submitted, your Microsoft Teams tenant admin will need to approve the app in the [Microsoft Teams Admin Center](https://admin.teams.microsoft.com/policies/manage-apps).

        <Warning>
          After the app has been approved, it can take a few hours *(up to 24 hours in some cases)* for Microsoft Teams to reflect the new app. During this period, the Infisical app will not be visible in Microsoft Teams, and won't be usable.
        </Warning>

        Once the app has been approved, you will be able to use the Infisical Microsoft Teams integration in your projects.
      </Step>

      <Step title="Add the Infisical Microsoft Teams app to your Microsoft Teams teams">
        Once the app has been approved and installed in your Microsoft Teams tenant, you can add the app to your Microsoft Teams teams.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/workflow-integrations/microsoft-teams-integration/microsoft-teams-add-app.png" alt="microsoft-teams-add-app" />

        Navigate to **Apps** > **Built for your org**, select the "Infisical" app, and press the "Add" button to select the teams and channels you wish to add the app to.

        <Info>
          This can also be done later through the [Microsoft Teams Admin Center](https://admin.teams.microsoft.com/policies/manage-apps), or through the Microsoft Teams client itself by navigating to the individual team's app settings.
        </Info>

        Once the app has been added to the team, you will be able to use the Infisical Microsoft Teams integration in the team.
      </Step>

      <Step title="Navigate to the Workflow Integrations tab in your organization settings">
        After installing the Microsoft Teams app, you are now ready to configure the Microsoft Teams integration within Infisical.

        Navigate to the **Workflow Integrations** tab in your organization settings, and press the "Add" button.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/workflow-integrations/microsoft-teams-integration/infisical-org-overview.png" alt="org-integrations-overview" />
      </Step>

      <Step title="Create a Microsoft Teams workflow integration">
        In order to use the Infisical Microsoft Teams integration, you will need to grant admin consent to the app. Once the consent is granted, the Microsoft Teams workflow integration will be created in your Infisical organization.

        Press the "Add" button and select the "Microsoft Teams" platform option.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/workflow-integrations/microsoft-teams-integration/infisical-org-add-microsoft-teams-integration.png" alt="add-microsoft-teams-integration" />

        Select the Microsoft Teams integration you wish to configure, and press the "Configure" button.

        Here you will be prompted to enter an alias, tenant ID, and an optional description for your workflow integration.
        The tenant ID is the ID of the Microsoft 365 / Azure AD tenant that you installed the Infisical Microsoft Teams app in, in the previous steps.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/workflow-integrations/microsoft-teams-integration/infisical-org-microsoft-teams-integration-modal.png" alt="configure-microsoft-teams-integration" />

        Press the "Create Microsoft Teams Integration" button, and you'll be navigated to the Azure AD consent page.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/workflow-integrations/microsoft-teams-integration/microsoft-consent-page.png" alt="microsoft-consent-page" />

        <Note>
          Please note that you must be a privileged administrator user of your Microsoft 365 / Azure AD tenant in order to grant admin consent to the app.
        </Note>

        Once you've granted admin consent, you'll be navigated back to the Infisical organization settings, where you can now select the Microsoft Teams integration you just created.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/workflow-integrations/microsoft-teams-integration/microsoft-teams-workflow-integration-created.png" alt="microsoft-teams-workflow-integration-created" />
      </Step>
    </Steps>

    ### Configure project to use Microsoft Teams workflow integration

    <Steps>
      <Step title="Navigate to the Workflow Integrations tab in the project settings">
        To add a new Microsoft Teams workflow integration, navigate to **Project Settings** > **Workflow Integrations** and press the "Add".
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/workflow-integrations/microsoft-teams-integration/infisical-project-settings.png" alt="project-settings-workflow-integrations" />

        Select the "Microsoft Teams" option from the list of available workflow integrations.
      </Step>

      <Step title="Configure the Microsoft Teams workflow integration">
        Your project will send notifications to the connected Microsoft Teams team of the
        selected Microsoft Teams integration when the configured events are triggered.

        Press the "Save" button to save your Microsoft Teams workflow integration.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/workflow-integrations/microsoft-teams-integration/infisical-project-microsoft-teams-integration-save.png" alt="infisical-project-microsoft-teams-integration-save" />
      </Step>
    </Steps>

    Once you've created the project Microsoft Teams workflow integration, you will now receive Access Requests and Secret Approval Requests notifications in Microsoft Teams according to your configuration.
  </Tab>
</Tabs>

## Troubleshooting

<Accordion title="Notifications are not being sent to Microsoft Teams even though the integration is configured">
  If you recently added the Microsoft Teams app to your tenant, **it may take up to 24 hours for Microsoft Teams to propagate the changes.**
  A common indication of propagation issues is that the workflow integration is shown as "Installed", and you're able to view the teams and channels when configuring the workflow integration on your project, but no notification is being sent.
</Accordion>

<Accordion title="Workflow Integration is stuck on 'Pending' status">
  The workflow integration can get stuck on Pending if you created the workflow integration before the Infisical Microsoft Teams bot was installed in the tenant.
  To resolve this, make sure you have installed the Infisical Microsoft Teams app in your tenant.

  You can manually recheck the installation status by pressing the "Check Installation Status" button in the workflow organization settings.

    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/workflow-integrations/microsoft-teams-integration/microsoft-teams-check-installation-status.png" alt="microsoft-teams-check-installation-status" />
</Accordion>


# Slack Integration
Source: https://infisical.com/docs/documentation/platform/workflow-integrations/slack-integration

Learn how to setup the Slack integration

This guide will provide step by step instructions on how to configure Slack integration for your Infisical projects.

## Setting up Slack integration in your projects

<Tabs>
  <Tab title="Infisical Cloud">
    ### Create Slack workflow integration

    <Steps>
      <Step title="Navigate to the Workflow Integrations tab in your organization settings">
        In order to use Slack integration in your projects, you will first have to
        configure a Slack workflow integration in your organization.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/workflow-integrations/slack-integration/org-slack-integration-overview.png" alt="org-slack-overview" />
      </Step>

      <Step title="Install Slack app to workspace">
        Press **Add** and select **Slack** as the platform.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/workflow-integrations/slack-integration/org-slack-integration-initial-add.png" alt="org-slack-initial-add" />

        Give your Slack integration a descriptive alias. You will use this to select the Slack integration for your project.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/workflow-integrations/slack-integration/org-slack-integration-add-form.png" alt="org-slack-add-form" />

        Press **Connect Slack**. This opens up the Slack app installation flow. Select the Slack workspace you want to install the custom Slack app to and press **Install Infisical**.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/workflow-integrations/slack-integration/cloud-org-slack-integration-authenticate.png" alt="org-slack-authenticate" />

        This completes the workflow integration creation flow. The projects in your organization can now use this Slack integration to send real-time updates to your Slack workspace.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/workflow-integrations/slack-integration/cloud-org-slack-integration-workspace.png" alt="org-slack-workspace" />
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/workflow-integrations/slack-integration/org-slack-integration-created.png" alt="org-slack-created" />
      </Step>
    </Steps>

    ### Configure project to use Slack workflow integration

    <Steps>
      <Step title="Navigate to the Workflow Integrations tab in the project settings">
        Press **Add** and select **Slack** as the platform.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/workflow-integrations/slack-integration/project-slack-integration-overview.png" alt="project-slack-overview" />
      </Step>

      <Step title="Select the Slack integration to use for the project">
        Your project will send notifications to the connected Slack workspace of the
        selected Slack integration when the configured events are triggered.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/workflow-integrations/slack-integration/project-slack-integration-select.png" alt="project-slack-select" />
      </Step>

      <Step title="Configure the Slack notification settings for the project and click Save.">
                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/workflow-integrations/slack-integration/project-slack-integration-config.png" alt="project-slack-select" />

        <Info>
          To enable notifications in private Slack channels, you need to invite the Infisical Slack bot to join those channels.
        </Info>

        You now have a working native integration with Slack!
      </Step>
    </Steps>
  </Tab>

  <Tab title="Self-hosted setup">
    ### Configure admin settings

    Note that this step only has to be done once for the entire instance.

    <Steps>
      <Step title="Navigate to the Integrations tab in the Admin settings">
        Before anything else, you need to setup the Slack app to be used by
        your Infisical instance. Because you're self-hosting, you will need to
        create this Slack application as demonstrated in the preceding step.

        Click the **Create Slack app** button. This will open up a new window with the
        custom app creation flow on Slack.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/workflow-integrations/slack-integration/admin-slack-integration-overview.png" alt="admin-settings-slack-overview" />
      </Step>

      <Step title="Create Slack app">
        Select the Slack workspace you want to integrate with Infisical.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/workflow-integrations/slack-integration/admin-slack-integration-app-workspace-select.png" alt="admin-slack-app-workspace-select" />

        The configuration values of your custom Slack app will be pre-filled for you. You can view or edit the app manifest by clicking **Edit Configurations**.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/workflow-integrations/slack-integration/admin-slack-integration-app-summary.png" alt="admin-slack-app-summary" />

        Once everything's confirmed, press Create.
      </Step>

      <Step title="Input app credentials from Slack">
        Copy the Client ID and Client Secret values from your newly created custom Slack app and add them to Infisical.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/workflow-integrations/slack-integration/admin-slack-integration-app-credentials.png" alt="admin-slack-app-credentials" />
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/workflow-integrations/slack-integration/admin-slack-integration-app-credential-form.png" alt="admin-slack-app-credentials-form" />
        Complete the admin setup by pressing **Save**.
      </Step>
    </Steps>

    ### Create Slack workflow integration

    <Steps>
      <Step title="Navigate to the Workflow Integrations tab in your organization settings">
        In order to use Slack integration in your projects, you will first have to
        configure a Slack workflow integration in your organization.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/workflow-integrations/slack-integration/org-slack-integration-overview.png" alt="org-slack-overview" />
      </Step>

      <Step title="Install Slack app to workspace">
        Press **Add** and select **Slack** as the platform.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/workflow-integrations/slack-integration/org-slack-integration-initial-add.png" alt="org-slack-initial-add" />

        Give your Slack integration a descriptive alias. You will use this to select the Slack integration for your project.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/workflow-integrations/slack-integration/org-slack-integration-add-form.png" alt="org-slack-add-form" />

        Press **Connect Slack**. This opens up the Slack app installation flow. Select the Slack workspace you want to install the custom Slack app to and press **Install Infisical**.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/workflow-integrations/slack-integration/org-slack-integration-authenticate.png" alt="org-slack-authenticate" />

        Your Slack bot will then be added to your selected Slack workspace. This completes the workflow integration creation flow. Your projects in the organization can now use this Slack integration to send real-time updates to your Slack workspace.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/workflow-integrations/slack-integration/org-slack-integration-workspace.png" alt="org-slack-workspace" />
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/workflow-integrations/slack-integration/org-slack-integration-created.png" alt="org-slack-created" />
      </Step>
    </Steps>

    ### Configure project to use Slack workflow integration

    <Steps>
      <Step title="Navigate to the Workflow Integrations tab in the project settings">
        Press **Add** and select **Slack** as the platform.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/workflow-integrations/slack-integration/project-slack-integration-overview.png" alt="project-slack-overview" />
      </Step>

      <Step title="Select the Slack integration to use for the project">
        Your project will send notifications to the connected Slack workspace of the
        selected Slack integration when the configured events are triggered.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/workflow-integrations/slack-integration/project-slack-integration-select.png" alt="project-slack-select" />
      </Step>

      <Step title="Configure the Slack notification settings for the project and click Save.">
                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/workflow-integrations/slack-integration/project-slack-integration-config.png" alt="project-slack-select" />

        <Info>
          To enable notifications in private Slack channels, you need to invite your Slack bot to join those channels.
        </Info>

        You now have a working native integration with Slack!
      </Step>
    </Steps>
  </Tab>
</Tabs>

## Using the Slack integration in your private channels

<Steps>
  <Step title="In the Apps section on Slack, find the Infisical app and view the app details">
        <img
          src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/workflow-integrations/slack-integration/private-slack-setup-menu.png"
          alt="private slack setup
    menu"
        />
  </Step>

  <Step title="Select Add this app to a channel">
        <img
          src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/workflow-integrations/slack-integration/private-slack-setup-add.png"
          alt="private slack setup
    add"
        />
  </Step>

  <Step title="Find the private channel you want to setup notifications for and press Add">
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/workflow-integrations/slack-integration/private-slack-setup-form.png" alt="private slack setup
    form" />
    You can now view the private channels in the Slack channel selection fields!
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/workflow-integrations/slack-integration/private-slack-setup-channel-field.png" alt="private slack setup
    channels" />
  </Step>
</Steps>

## Slack Events

The Slack integration supports the following events that can be configured for your projects. Each event is triggered when specific actions occur within your Infisical instance.

<Tabs>
  <Tab title="Access Request">
    ### Access Request

    This event is triggered when a user creates a new access approval request for a project. The notification includes details about the requester, the requested permissions, the secret path and environment, and whether the access is temporary or permanent.

    **When it's triggered:**

    * A user submits a new access approval request through the Infisical UI
    * The request requires approval based on configured access approval policies
    * The notification is sent to the configured access request channels

    **Notification includes:**

    * Requester's full name and email
    * Requested permissions (read, write, etc.)
    * Secret path and environment
    * Access type (temporary or permanent)
    * Optional user note
    * Direct link to review the request

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/workflow-integrations/slack-integration/access-request-notification.png" alt="access request notification" />

    ### Access Request Updated

    This event is triggered when an existing access approval request is modified or updated. This helps approvers stay informed about changes to pending requests.

    **When it's triggered:**

    * An access approval request is edited by the requester or another authorized user
    * Changes are made to permissions, temporary range, or notes
    * The notification is sent to the configured access request channels

    **Notification includes:**

    * Original requester's information
    * Editor's full name and email (who made the update)
    * Updated permissions
    * Updated secret path and environment
    * Editor's note explaining the changes
    * Direct link to review the updated request

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/workflow-integrations/slack-integration/access-request-updated-notification.png" alt="access request updated notification" />
  </Tab>

  <Tab title="Secret Approval">
    ### Secret Approval

    This event is triggered when a secret approval request is created. This occurs when a user attempts to create, update, or delete secrets that require approval based on secret approval policies.

    **When it's triggered:**

    * A user creates, updates, or deletes secrets in a path protected by a secret approval policy
    * The changes require approval before being applied
    * The notification is sent to the configured secret request channels

    **Notification includes:**

    * User's email who initiated the change
    * Environment and secret path
    * List of secret keys affected
    * Direct link to review and approve the secret changes

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/workflow-integrations/slack-integration/secret-approval-notification.png" alt="secret approval notification" />
  </Tab>

  <Tab title="Secret Sync Error">
    ### Secret Sync Error

    This event is triggered when a secret sync operation fails. Secret syncs allow you to synchronize secrets between Infisical and external systems like GitHub, GitLab, AWS Secrets Manager, and others.

    **When it's triggered:**

    * A secret sync fails to push secrets to the destination
    * A secret sync fails to pull secrets from the source
    * A secret sync fails to import secrets
    * A secret sync fails to remove secrets
    * Any other error occurs during the sync process

    **Notification includes:**

    * Sync name and destination
    * The action that failed
    * Environment and secret path
    * Project name
    * Detailed error message explaining the failure
    * Direct link to view and troubleshoot the sync configuration

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/workflow-integrations/slack-integration/secret-sync-error-notification.png" alt="secret sync error notification" />
  </Tab>
</Tabs>


# Networking
Source: https://infisical.com/docs/documentation/setup/networking

Network configuration details for Infisical Cloud

When integrating your infrastructure with Infisical Cloud, you may need to configure network access controls. This page provides the IP addresses that Infisical uses to communicate with your services.

## Infisical IP Addresses

Infisical Cloud operates from multiple regions. If your infrastructure has strict network policies, you may need to allow traffic from Infisical by adding the following IP addresses to your ingress rules. These are the IP addresses that Infisical uses when making outbound requests to your services.

<Tabs>
  <Tab title="US Region">
    ```
    3.213.63.16
    54.164.68.7
    ```
  </Tab>

  <Tab title="EU Region">
    ```
    3.77.89.19
    3.125.209.189
    ```
  </Tab>

  <Tab title="Dedicated Cloud">
    For dedicated Infisical deployments, please contact your account manager for the specific IP addresses used in your dedicated environment.
  </Tab>
</Tabs>

<Warning>
  These IP addresses are static and managed by Infisical. Any changes will be communicated with 60-day advance notice.
</Warning>

## What These IP Addresses Are Used For

These IP addresses represent the source IPs you'll see when Infisical Cloud makes connections to your infrastructure. All outbound traffic from Infisical Cloud originates from these IP addresses, ensuring predictable source IP addresses for your firewall rules.


# null
Source: https://infisical.com/docs/integrations/app-connections

Browse and search through all available app connections for Infisical.

export const AppConnectionsBrowser = () => {
  const [searchTerm, setSearchTerm] = useState('');
  const [selectedCategory, setSelectedCategory] = useState('All');
  const categories = ['All', 'Cloud Providers', 'Databases', 'CI/CD', 'Monitoring', 'Directory Services', 'Identity & Auth', 'Data Analytics', 'Hosting', 'DevOps Tools', 'Security'];
  const connections = [{
    "name": "AWS",
    "slug": "aws",
    "path": "/integrations/app-connections/aws",
    "description": "Learn how to connect your AWS applications to pull secrets from Infisical.",
    "category": "Cloud Providers"
  }, {
    "name": "Azure Key Vault",
    "slug": "azure-key-vault",
    "path": "/integrations/app-connections/azure-key-vault",
    "description": "Learn how to connect your Azure Key Vault to pull secrets from Infisical.",
    "category": "Cloud Providers"
  }, {
    "name": "Azure App Configuration",
    "slug": "azure-app-configuration",
    "path": "/integrations/app-connections/azure-app-configuration",
    "description": "Learn how to connect your Azure App Configuration to pull secrets from Infisical.",
    "category": "Cloud Providers"
  }, {
    "name": "Azure Client Secrets",
    "slug": "azure-client-secrets",
    "path": "/integrations/app-connections/azure-client-secrets",
    "description": "Learn how to connect your Azure Client Secrets to pull secrets from Infisical.",
    "category": "Cloud Providers"
  }, {
    "name": "Azure DevOps",
    "slug": "azure-devops",
    "path": "/integrations/app-connections/azure-devops",
    "description": "Learn how to connect your Azure DevOps to pull secrets from Infisical.",
    "category": "CI/CD"
  }, {
    "name": "Azure ADCS",
    "slug": "azure-adcs",
    "path": "/integrations/app-connections/azure-adcs",
    "description": "Learn how to connect your Azure ADCS to pull secrets from Infisical.",
    "category": "Cloud Providers"
  }, {
    "name": "GCP",
    "slug": "gcp",
    "path": "/integrations/app-connections/gcp",
    "description": "Learn how to connect your GCP applications to pull secrets from Infisical.",
    "category": "Cloud Providers"
  }, {
    "name": "HashiCorp Vault",
    "slug": "hashicorp-vault",
    "path": "/integrations/app-connections/hashicorp-vault",
    "description": "Learn how to connect your HashiCorp Vault to pull secrets from Infisical.",
    "category": "Security"
  }, {
    "name": "1Password",
    "slug": "1password",
    "path": "/integrations/app-connections/1password",
    "description": "Learn how to connect your 1Password to pull secrets from Infisical.",
    "category": "Security"
  }, {
    "name": "Vercel",
    "slug": "vercel",
    "path": "/integrations/app-connections/vercel",
    "description": "Learn how to connect your Vercel application to pull secrets from Infisical.",
    "category": "Hosting"
  }, {
    "name": "Netlify",
    "slug": "netlify",
    "path": "/integrations/app-connections/netlify",
    "description": "Learn how to connect your Netlify application to pull secrets from Infisical.",
    "category": "Hosting"
  }, {
    "name": "Railway",
    "slug": "railway",
    "path": "/integrations/app-connections/railway",
    "description": "Learn how to connect your Railway application to pull secrets from Infisical.",
    "category": "Hosting"
  }, {
    "name": "Fly.io",
    "slug": "flyio",
    "path": "/integrations/app-connections/flyio",
    "description": "Learn how to connect your Fly.io application to pull secrets from Infisical.",
    "category": "Hosting"
  }, {
    "name": "Render",
    "slug": "render",
    "path": "/integrations/app-connections/render",
    "description": "Learn how to connect your Render application to pull secrets from Infisical.",
    "category": "Hosting"
  }, {
    "name": "Heroku",
    "slug": "heroku",
    "path": "/integrations/app-connections/heroku",
    "description": "Learn how to connect your Heroku application to pull secrets from Infisical.",
    "category": "Hosting"
  }, {
    "name": "DigitalOcean",
    "slug": "digital-ocean",
    "path": "/integrations/app-connections/digital-ocean",
    "description": "Learn how to connect your DigitalOcean application to pull secrets from Infisical.",
    "category": "Hosting"
  }, {
    "name": "Supabase",
    "slug": "supabase",
    "path": "/integrations/app-connections/supabase",
    "description": "Learn how to connect your Supabase application to pull secrets from Infisical.",
    "category": "Databases"
  }, {
    "name": "Checkly",
    "slug": "checkly",
    "path": "/integrations/app-connections/checkly",
    "description": "Learn how to connect your Checkly application to pull secrets from Infisical.",
    "category": "Monitoring"
  }, {
    "name": "GitHub",
    "slug": "github",
    "path": "/integrations/app-connections/github",
    "description": "Learn how to connect your GitHub application to pull secrets from Infisical.",
    "category": "CI/CD"
  }, {
    "name": "GitHub Radar",
    "slug": "github-radar",
    "path": "/integrations/app-connections/github-radar",
    "description": "Learn how to connect your GitHub Radar to pull secrets from Infisical.",
    "category": "CI/CD"
  }, {
    "name": "GitLab",
    "slug": "gitlab",
    "path": "/integrations/app-connections/gitlab",
    "description": "Learn how to connect your GitLab application to pull secrets from Infisical.",
    "category": "CI/CD"
  }, {
    "name": "TeamCity",
    "slug": "teamcity",
    "path": "/integrations/app-connections/teamcity",
    "description": "Learn how to connect your TeamCity to pull secrets from Infisical.",
    "category": "CI/CD"
  }, {
    "name": "Bitbucket",
    "slug": "bitbucket",
    "path": "/integrations/app-connections/bitbucket",
    "description": "Learn how to connect your Bitbucket to pull secrets from Infisical.",
    "category": "CI/CD"
  }, {
    "name": "Terraform Cloud",
    "slug": "terraform-cloud",
    "path": "/integrations/app-connections/terraform-cloud",
    "description": "Learn how to connect your Terraform Cloud to pull secrets from Infisical.",
    "category": "DevOps Tools"
  }, {
    "name": "Cloudflare",
    "slug": "cloudflare",
    "path": "/integrations/app-connections/cloudflare",
    "description": "Learn how to connect your Cloudflare application to pull secrets from Infisical.",
    "category": "Cloud Providers"
  }, {
    "name": "Databricks",
    "slug": "databricks",
    "path": "/integrations/app-connections/databricks",
    "description": "Learn how to connect your Databricks to pull secrets from Infisical.",
    "category": "Data Analytics"
  }, {
    "name": "Windmill",
    "slug": "windmill",
    "path": "/integrations/app-connections/windmill",
    "description": "Learn how to connect your Windmill to pull secrets from Infisical.",
    "category": "DevOps Tools"
  }, {
    "name": "Camunda",
    "slug": "camunda",
    "path": "/integrations/app-connections/camunda",
    "description": "Learn how to connect your Camunda to pull secrets from Infisical.",
    "category": "DevOps Tools"
  }, {
    "name": "Humanitec",
    "slug": "humanitec",
    "path": "/integrations/app-connections/humanitec",
    "description": "Learn how to connect your Humanitec to pull secrets from Infisical.",
    "category": "DevOps Tools"
  }, {
    "name": "OCI",
    "slug": "oci",
    "path": "/integrations/app-connections/oci",
    "description": "Learn how to connect your OCI applications to pull secrets from Infisical.",
    "category": "Cloud Providers"
  }, {
    "name": "Zabbix",
    "slug": "zabbix",
    "path": "/integrations/app-connections/zabbix",
    "description": "Learn how to connect your Zabbix to pull secrets from Infisical.",
    "category": "Monitoring"
  }, {
    "name": "MySQL",
    "slug": "mysql",
    "path": "/integrations/app-connections/mysql",
    "description": "Learn how to connect your MySQL database to pull secrets from Infisical.",
    "category": "Databases"
  }, {
    "name": "PostgreSQL",
    "slug": "postgres",
    "path": "/integrations/app-connections/postgres",
    "description": "Learn how to connect your PostgreSQL database to pull secrets from Infisical.",
    "category": "Databases"
  }, {
    "name": "Microsoft SQL Server",
    "slug": "mssql",
    "path": "/integrations/app-connections/mssql",
    "description": "Learn how to connect your SQL Server database to pull secrets from Infisical.",
    "category": "Databases"
  }, {
    "name": "Oracle Database",
    "slug": "oracledb",
    "path": "/integrations/app-connections/oracledb",
    "description": "Learn how to connect your Oracle database to pull secrets from Infisical.",
    "category": "Databases"
  }, {
    "name": "Redis",
    "slug": "redis",
    "path": "/integrations/app-connections/redis",
    "description": "Learn how to connect Redis to pull secrets from Infisical.",
    "category": "Databases"
  }, {
    "name": "LDAP",
    "slug": "ldap",
    "path": "/integrations/app-connections/ldap",
    "description": "Learn how to connect your LDAP to pull secrets from Infisical.",
    "category": "Directory Services"
  }, {
    "name": "Auth0",
    "slug": "auth0",
    "path": "/integrations/app-connections/auth0",
    "description": "Learn how to connect your Auth0 to pull secrets from Infisical.",
    "category": "Identity & Auth"
  }, {
    "name": "Okta",
    "slug": "okta",
    "path": "/integrations/app-connections/okta",
    "description": "Learn how to connect your Okta to pull secrets from Infisical.",
    "category": "Identity & Auth"
  }, {
    "name": "Laravel Forge",
    "slug": "laravel-forge",
    "path": "/integrations/app-connections/laravel-forge",
    "description": "Learn how to connect your Laravel Forge to pull secrets from Infisical.",
    "category": "Hosting"
  }, {
    "name": "Chef",
    "slug": "chef",
    "path": "/integrations/app-connections/chef",
    "description": "Learn how to connect your Chef to pull secrets from Infisical.",
    "category": "DevOps Tools"
  }, {
    "name": "Northflank",
    "slug": "northflank",
    "path": "/integrations/app-connections/northflank",
    "description": "Learn how to connect your Northflank projects to pull secrets from Infisical.",
    "category": "Hosting"
  }].sort(function (a, b) {
    return a.name.toLowerCase().localeCompare(b.name.toLowerCase());
  });
  const filteredConnections = useMemo(() => {
    let filtered = connections;
    if (selectedCategory !== 'All') {
      filtered = filtered.filter(connection => connection.category === selectedCategory);
    }
    if (searchTerm) {
      filtered = filtered.filter(connection => connection.name.toLowerCase().includes(searchTerm.toLowerCase()) || connection.description.toLowerCase().includes(searchTerm.toLowerCase()) || connection.category.toLowerCase().includes(searchTerm.toLowerCase()));
    }
    return filtered;
  }, [searchTerm, selectedCategory]);
  return <div className="max-w-none">
      {}
      <div className="mb-6">
        <div className="relative w-full">
          <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
            <svg className="h-4 w-4 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
            </svg>
          </div>
          <input type="text" placeholder="Search app connections..." className="block w-full pl-9 pr-3 py-2 text-sm border border-gray-300 rounded-lg placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-yellow-500 focus:border-yellow-500 bg-white shadow-sm" value={searchTerm} onChange={e => setSearchTerm(e.target.value)} />
        </div>
      </div>

      {}
      <div className="mb-6">
        <div className="flex flex-wrap gap-2">
          {categories.map(category => <button key={category} onClick={() => setSelectedCategory(category)} className={`px-3 py-1.5 text-sm font-medium rounded-lg transition-colors shadow-sm ${selectedCategory === category ? 'bg-yellow-100 text-yellow-700 border border-yellow-200' : 'bg-white text-gray-700 border border-gray-200 hover:bg-yellow-50 hover:border-yellow-200'}`}>
              {category}
            </button>)}
        </div>
      </div>

      {}
      <div className="mb-4">
        <p className="text-sm text-gray-600">
          {filteredConnections.length} app connection{filteredConnections.length !== 1 ? 's' : ''} found
          {selectedCategory !== 'All' && ` in ${selectedCategory}`}
          {searchTerm && ` for "${searchTerm}"`}
        </p>
      </div>

      {}
      {filteredConnections.length > 0 ? <div className="space-y-4">
          {filteredConnections.map((connection, index) => <a key={connection.slug} href={connection.path} className="group block px-4 py-3 border border-gray-200 rounded-xl hover:border-yellow-200 hover:bg-yellow-50/50 hover:shadow-sm transition-all duration-200 bg-white shadow-sm">
              <div className="w-full">
                <div className="flex items-center justify-between mb-0.5">
                  <h3 className="text-base font-medium text-gray-900 leading-none m-0">
                    {connection.name}
                  </h3>
                  <span className="ml-3 inline-flex items-center px-3 py-1 rounded-full text-xs font-medium bg-yellow-100 text-yellow-700 flex-shrink-0">
                    {connection.category}
                  </span>
                </div>
                <p className="text-sm text-gray-600 leading-relaxed">
                  {connection.description}
                </p>
              </div>
            </a>)}
        </div> : <div className="text-center py-8">
          <div className="flex flex-col items-center space-y-2">
            <p className="text-gray-500">No app connections found matching your criteria</p>
            {searchTerm && <p className="text-gray-400 text-sm">Try adjusting your search terms or filters</p>}
          </div>
        </div>}
    </div>;
};

<AppConnectionsBrowser />


# 1Password Connection
Source: https://infisical.com/docs/integrations/app-connections/1password

Learn how to configure a 1Password Connection for Infisical.

Infisical supports the use of [Service Accounts](https://developer.1password.com/docs/service-accounts) to connect with 1Password.

## Setup 1Password Connect Server

<Note>
  If you already have a Connect Server for your vault you may skip this step.
</Note>

<Steps>
  <Step title="Navigate to 'Developer' and click 'Other'">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/1password/developer-page.png" alt="Developer Page" />
  </Step>

  <Step title="Select 'Connect Server'">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/1password/click-connect-server.png" alt="Click Connect Server" />
  </Step>

  <Step title="Configure Connect Server">
    1. Input a name for your Connect Server
    2. Click "Choose Vaults" and select the vaults you want to connect
    3. For each selected vault, click **Edit Access** and **Enable All**
    4. Click "Add Environment"

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/1password/configure-connect-server.png" alt="Configure Connect Server" />
  </Step>

  <Step title="Configure Access Token">
    1. Input a name and expiration for the token
    2. Click "Choose Vaults" and select the vaults you want to connect
    3. For each selected vault, click **Edit Access** and **Enable All**
    4. Click "Issue Token"

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/1password/set-up-access-token.png" alt="Set Up Access Token" />
  </Step>

  <Step title="Deploy Connect Server">
    Download the Credentials File and set up your Connect Server.

    <Note>
      Follow [this guide](https://developer.1password.com/docs/connect/get-started#step-2-deploy-1password-connect-server) to deploy a Connect Server.
    </Note>

    Make sure to save the **Access Token** for later use.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/1password/deploy-server.png" alt="Deploy Server" />
  </Step>
</Steps>

## Create 1Password Connection in Infisical

<Tabs>
  <Tab title="Infisical UI">
    <Steps>
      <Step title="Navigate to App Connections">
        In your Infisical dashboard, navigate to the **App Connections** page in the desired project.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/general/add-connection.png" alt="App Connections Tab" />
      </Step>

      <Step title="Select 1Password Connection">
        Click the **+ Add Connection** button and select the **1Password Connection** option from the available integrations.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/1password/app-connection-option.png" alt="Select 1Password Connection" />
      </Step>

      <Step title="Fill out the 1Password Connection Modal">
        Complete the 1Password Connection form by entering:

        * A descriptive name for the connection
        * An optional description for future reference
        * The URL at which your 1Password Connect Server instance is hosted
        * The Access Token from earlier steps

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/1password/app-connection-modal.png" alt="1Password Connection Modal" />
      </Step>

      <Step title="Connection Created">
        After clicking Create, your **1Password Connection** is established and ready to use with your Infisical project.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/1password/app-connection-created.png" alt="1Password Connection Created" />
      </Step>
    </Steps>
  </Tab>

  <Tab title="API">
    To create an 1Password Connection, make an API request to the [Create 1Password Connection](/api-reference/endpoints/app-connections/1password/create) API endpoint.

    ### Sample request

    ```bash Request theme={"dark"}
    curl    --request POST \
            --url https://app.infisical.com/api/v1/app-connections/1password \
            --header 'Content-Type: application/json' \
            --data '{
                "name": "my-1password-connection",
                "method": "api-token",
                "projectId": "7ffbb072-2575-495a-b5b0-127f88caef78",
                "credentials": {
                    "instanceUrl": "https://1pass.example.com",
                    "apiToken": "<YOUR-API-TOKEN>"
                }
            }'
    ```

    ### Sample response

    ```bash Response theme={"dark"}
    {
      "appConnection": {
          "id": "e5d18aca-86f7-4026-a95e-efb8aeb0d8e6",
          "name": "my-1password-connection",
          "projectId": "7ffbb072-2575-495a-b5b0-127f88caef78",
          "description": null,
          "version": 1,
          "orgId": "6f03caa1-a5de-43ce-b127-95a145d3464c",
          "createdAt": "2025-04-23T19:46:34.831Z",
          "updatedAt": "2025-04-23T19:46:34.831Z",
          "isPlatformManagedCredentials": false,
          "credentialsHash": "7c2d371dec195f82a6a0d5b41c970a229cfcaf88e894a5b6395e2dbd0280661f",
          "app": "1password",
          "method": "api-token",
          "credentials": {
            "instanceUrl": "https://1pass.example.com"
          }
      }
    }
    ```
  </Tab>
</Tabs>


# Auth0 Connection
Source: https://infisical.com/docs/integrations/app-connections/auth0

Learn how to configure an Auth0 Connection for Infisical.

Infisical supports the use of [Client Credentials](https://auth0.com/docs/get-started/authentication-and-authorization-flow/client-credentials-flow) to connect with your Auth0 applications.

## Configure a Machine-to-Machine Application in Auth0

<Steps>
  <Step title="Auth0 Applications Dashboard">
    Navigate to the **Applications** page in Auth0 via the sidebar and click **Create Application**.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/auth0/auth0-dashboard-applications.png" alt="Applications Page" />
  </Step>

  <Step title="Create a Machine-to-Machine Application">
    Give your application a name and select **Machine-to-Machine** for the application type.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/auth0/auth0-select-m2m.png" alt="Create Machine-to-Machine Application" />
  </Step>

  <Step title="Configure Authorization">
    Depending on your connection use case, authorize your application for the applicable API and grant the relevant permissions. Once done, click **Authorize**.

    <Tabs>
      <Tab title="Secret Rotation">
        Select the **Auth0 Management API** option from the dropdown and grant the `update:client_keys` and `read:clients` permission.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/auth0/auth0-secret-rotation-api-selection.png" alt="Secret Rotation Authorization" />
      </Tab>
    </Tabs>
  </Step>

  <Step title="Application Client Credentials">
    On your application page, select the **Settings** tab and copy the **Domain**, **Client ID** and **Client Secret** for later.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/auth0/auth0-client-credentials.png" alt="Client Credentials" />
  </Step>

  <Step title="Application Audience">
    Next, select the **APIs** tab and copy the **API Identifier**.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/auth0/auth0-audience.png" alt="Application Audience" />
  </Step>
</Steps>

## Setup Auth0 Connection in Infisical

<Tabs>
  <Tab title="Infisical UI">
    1. Navigate to the **App Connections** page in the desired project.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/general/add-connection.png" alt="App Connections Tab" />

    2. Select the **Auth0 Connection** option.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/auth0/select-auth0-connection.png" alt="Select Auth0 Connection" />

    3. Select the **Client Credentials** method option and provide the details obtained from the previous section and press **Connect to Auth0**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/auth0/client-credentials-create.png" alt="Create Auth0 Connection" />

    4. Your **Auth0 Connection** is now available for use.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/auth0/client_credentials_connection.png" alt="Assume Role Auth0 Connection" />
  </Tab>

  <Tab title="API">
    To create a Auth0 Connection, make an API request to the [Create Auth0
    Connection](/api-reference/endpoints/app-connections/auth0/create) API endpoint.

    ### Sample request

    ```bash Request theme={"dark"}
    curl    --request POST \
    --url https://app.infisical.com/api/v1/app-connections/auth0 \
    --header 'Content-Type: application/json' \
    --data '{
        "name": "my-auth0-connection",
        "method": "client-credentials",
        "projectId": "7ffbb072-2575-495a-b5b0-127f88caef78",
        "credentials": {
            "domain": "xxx-xxxxxxxxx.us.auth0.com",
            "clientId": "...",
            "clientSecret": "...",
            "audience": "https://xxx-xxxxxxxxx.us.auth0.com/api/v2/"
        }
    }'
    ```

    ### Sample response

    ```bash Response theme={"dark"}
    {
        "appConnection": {
            "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "name": "my-auth0-connection",
            "projectId": "7ffbb072-2575-495a-b5b0-127f88caef78",
            "version": 1,
            "orgId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "createdAt": "2023-11-07T05:31:56Z",
            "updatedAt": "2023-11-07T05:31:56Z",
            "app": "auth0",
            "method": "client-credentials",
            "credentials": {
                "domain": "xxx-xxxxxxxxx.us.auth0.com",
                "clientId": "...",
                "audience": "https://xxx-xxxxxxxxx.us.auth0.com/api/v2/"
            }
        }
    }
    ```
  </Tab>
</Tabs>


# AWS Connection
Source: https://infisical.com/docs/integrations/app-connections/aws

Learn how to configure an AWS Connection for Infisical.

Infisical supports two methods for connecting to AWS.

<Tabs>
  <Tab title="Assume Role (Recommended)">
    Infisical will assume the provided role in your AWS account securely, without the need to share any credentials.

    <Accordion title="Self-Hosted Instance">
      To connect your self-hosted Infisical instance with AWS, you need to set up an AWS IAM User account that can assume the configured AWS IAM Role.

      If your instance is deployed on AWS, the aws-sdk will automatically retrieve the credentials. Ensure that you assign the provided permission policy to your deployed instance, such as ECS or EC2.

      The following steps are for instances not deployed on AWS:

      <Steps>
        <Step title="Create an IAM User">
          Navigate to [Create IAM User](https://console.aws.amazon.com/iamv2/home#/users/create) in your AWS Console.
        </Step>

        <Step title="Create an Inline Policy">
          Attach the following inline permission policy to the IAM User to allow it to assume any IAM Roles:

          ```json  theme={"dark"}
          {
              "Version": "2012-10-17",
              "Statement": [
          {
              "Sid": "AllowAssumeAnyRole",
              "Effect": "Allow",
              "Action": "sts:AssumeRole",
              "Resource": "arn:aws:iam::*:role/*"
          }
              ]
          }
          ```
        </Step>

        <Step title="Obtain the IAM User Credentials">
          Obtain the AWS access key ID and secret access key for your IAM User by navigating to **IAM > Users > \[Your User] > Security credentials > Access keys**.

          <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/aws/integrations-aws-access-key-1.png" alt="Access Key Step 1" />
          <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/aws/integrations-aws-access-key-2.png" alt="Access Key Step 2" />
          <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/aws/integrations-aws-access-key-3.png" alt="Access Key Step 3" />
        </Step>

        <Step title="Set Up Connection Keys">
          1. Set the access key as **INF\_APP\_CONNECTION\_AWS\_ACCESS\_KEY\_ID**.
          2. Set the secret key as **INF\_APP\_CONNECTION\_AWS\_SECRET\_ACCESS\_KEY**.
        </Step>
      </Steps>
    </Accordion>

    <Steps>
      <Step title="Create the Managing User IAM Role for Infisical">
        1. Navigate to the [Create IAM Role](https://console.aws.amazon.com/iamv2/home#/roles/create?step=selectEntities) page in your AWS Console.
           <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/aws/integration-aws-iam-assume-role.png" alt="IAM Role Creation" />

        2. Select **AWS Account** as the **Trusted Entity Type**.

        3. Select **Another AWS Account** and provide the appropriate Infisical AWS Account ID: use **381492033652** for the **US region**, and **345594589636** for the **EU region**. This restricts the role to be assumed only by Infisical. If self-hosting, provide your AWS account number instead.

        <Note>
          **For Dedicated Instances**: Your AWS account ID differs from the one provided above. Please reach out to Infisical support to obtain your AWS account ID.
        </Note>

        4. (Recommended) <strong>Enable "Require external ID"</strong> and input your **Organization ID** to strengthen security and mitigate the [confused deputy problem](https://docs.aws.amazon.com/IAM/latest/UserGuide/confused-deputy.html).

        <Warning type="warning" title="Security Best Practice: Use External ID to Prevent Confused Deputy Attacks">
          When configuring an IAM Role that Infisical will assume, its highly recommended to enable the **"Require external ID"** option and specify your **Organization ID**.

          This precaution helps protect your AWS account against the [confused deputy problem](https://docs.aws.amazon.com/IAM/latest/UserGuide/confused-deputy.html), a potential security vulnerability where Infisical could be tricked into performing actions on your behalf by an unauthorized actor.

          <strong>Always enable "Require external ID" and use your Organization ID when setting up the IAM Role.</strong>
        </Warning>
      </Step>

      <Step title="Add Required Permissions to the IAM Role">
        Navigate to your IAM role permissions and click **Create Inline Policy**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/aws/assume-role-create-policy.png" alt="IAM Role Create Policy" />

        Depending on your use case, add one or more of the following policies to your IAM Role:

        <Tabs>
          <Tab title="Secret Sync">
            <AccordionGroup>
              <Accordion title="AWS Secrets Manager">
                Use the following custom policy to grant the minimum permissions required by Infisical to sync secrets to AWS Secrets Manager:

                                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/aws/secrets-manager-permissions.png" alt="IAM Role Secrets Manager Permissions" />

                ```json  theme={"dark"}
                {
                    "Version": "2012-10-17",
                    "Statement": [
                        {
                            "Sid": "AllowSecretsManagerAccess",
                            "Effect": "Allow",
                            "Action": [
                                "secretsmanager:ListSecrets",
                                "secretsmanager:GetSecretValue",
                                "secretsmanager:BatchGetSecretValue",
                                "secretsmanager:CreateSecret",
                                "secretsmanager:UpdateSecret",
                                "secretsmanager:DeleteSecret",
                                "secretsmanager:DescribeSecret",
                                "secretsmanager:TagResource",
                                "secretsmanager:UntagResource",
                                "kms:ListAliases", // if you need to specify the KMS key
                                "kms:Encrypt", // if you need to specify the KMS key
                                "kms:Decrypt", // if you need to specify the KMS key
                                "kms:DescribeKey" // if you need to specify the KMS key
                            ],
                            "Resource": "*"
                        }
                    ]
                }
                ```

                <Note>If using a custom KMS key, be sure to add the IAM user or role as a key user. <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/aws/kms-key-user.png" alt="KMS Key IAM Role User" /></Note>
              </Accordion>

              <Accordion title="AWS Parameter Store">
                Use the following custom policy to grant the minimum permissions required by Infisical to sync secrets to AWS Parameter Store:

                                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/aws/parameter-store-permissions.png" alt="IAM Role Secrets Manager Permissions" />

                ```json  theme={"dark"}
                {
                    "Version": "2012-10-17",
                    "Statement": [
                        {
                            "Sid": "AllowSSMAccess",
                            "Effect": "Allow",
                            "Action": [
                                "ssm:PutParameter",
                                "ssm:GetParameters",
                                "ssm:GetParametersByPath",
                                "ssm:DescribeParameters",
                                "ssm:DeleteParameters",
                                "ssm:ListTagsForResource", // if you need to add tags to secrets
                                "ssm:AddTagsToResource", // if you need to add tags to secrets
                                "ssm:RemoveTagsFromResource", // if you need to add tags to secrets
                                "kms:ListAliases", // if you need to specify the KMS key
                                "kms:Encrypt", // if you need to specify the KMS key
                                "kms:Decrypt", // if you need to specify the KMS key
                                "kms:DescribeKey" // if you need to specify the KMS key
                            ],
                            "Resource": "*"
                        }
                    ]
                }
                ```

                <Note>If using a custom KMS key, be sure to add the IAM user or role as a key user. <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/aws/kms-key-user.png" alt="KMS Key IAM Role User" /></Note>
              </Accordion>
            </AccordionGroup>
          </Tab>

          <Tab title="Secret Rotation">
            <AccordionGroup>
              <Accordion title="AWS IAM">
                Use the following custom policy to grant the minimum permissions required by Infisical to rotate secrets to AWS Access Keys:

                                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/aws/iam-role-secret-rotation-permissions.png" alt="IAM Role Secret Rotation Permissions" />

                ```json  theme={"dark"}
                {
                    "Version": "2012-10-17",
                    "Statement": [
                        {
                            "Effect": "Allow",
                            "Action": [
                                "iam:ListAccessKeys",
                                "iam:CreateAccessKey",
                                "iam:UpdateAccessKey",
                                "iam:DeleteAccessKey",
                                "iam:ListUsers"
                            ],
                            "Resource": "*"
                        }
                    ]
                }
                ```
              </Accordion>
            </AccordionGroup>
          </Tab>

          <Tab title="PKI Sync">
            <AccordionGroup>
              <Accordion title="AWS Certificate Manager">
                Use the following custom policy to grant the minimum permissions required by Infisical to sync certificates to AWS Certificate Manager:

                ```json  theme={"dark"}
                {
                    "Version": "2012-10-17",
                    "Statement": [
                        {
                            "Sid": "AllowCertificateManagerAccess",
                            "Effect": "Allow",
                            "Action": [
                                "acm:ListCertificates",
                                "acm:DescribeCertificate",
                                "acm:GetCertificate",
                                "acm:ImportCertificate",
                                "acm:ExportCertificate",
                                "acm:DeleteCertificate",
                                "acm:AddTagsToCertificate",
                                "acm:RemoveTagsFromCertificate",
                                "acm:ListTagsForCertificate"
                            ],
                            "Resource": "*"
                        }
                    ]
                }
                ```

                <Note>
                  * **ListCertificates**: Lists all certificates in the account
                  * **ImportCertificate**: Imports certificates from Infisical into AWS Certificate Manager
                  * **ExportCertificate**: Exports certificates for synchronization
                  * **DeleteCertificate**: Removes certificates that are no longer managed by Infisical
                  * **DescribeCertificate** and **GetCertificate**: Retrieves certificate details for comparison during sync
                  * Tag-related permissions: Manages certificate tags for identification and organization
                </Note>
              </Accordion>
            </AccordionGroup>
          </Tab>
        </Tabs>
      </Step>

      <Step title="Copy the AWS IAM Role ARN">
                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/aws/integration-aws-iam-assume-arn.png" alt="Copy IAM Role ARN" />
      </Step>

      <Step title="Setup AWS Connection in Infisical">
        <Tabs>
          <Tab title="Infisical UI">
            1. Navigate to the **App Connections** page in the desired project.
               <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/general/add-connection.png" alt="App Connections Tab" />

            2. Select the **AWS Connection** option.
               <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/aws/select-aws-connection.png" alt="Select AWS Connection" />

            3. Select the **Assume Role** method option and provide the **AWS IAM Role ARN** obtained from the previous step and press **Connect to AWS**.
               <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/aws/create-assume-role-method.png" alt="Create AWS Connection" />

            4. Your **AWS Connection** is now available for use.
               <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/aws/assume-role-connection.png" alt="Assume Role AWS Connection" />
          </Tab>

          <Tab title="API">
            To create an AWS Connection, make an API request to the [Create AWS
            Connection](/api-reference/endpoints/app-connections/aws/create) API endpoint.

            ### Sample request

            ```bash Request theme={"dark"}
            curl    --request POST \
                    --url https://app.infisical.com/api/v1/app-connections/aws \
                    --header 'Content-Type: application/json' \
                    --data '{
                        "name": "my-aws-connection",
                        "method": "assume-role",
                        "projectId": "7ffbb072-2575-495a-b5b0-127f88caef78",
                        "credentials": {
                            "roleArn": "...",
                        }
                    }'
            ```

            ### Sample response

            ```bash Response theme={"dark"}
            {
                "appConnection": {
                    "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                    "name": "my-aws-connection",
                    "projectId": "7ffbb072-2575-495a-b5b0-127f88caef78",
                    "version": 123,
                    "orgId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                    "createdAt": "2023-11-07T05:31:56Z",
                    "updatedAt": "2023-11-07T05:31:56Z",
                    "app": "aws",
                    "method": "assume-role",
                    "credentials": {}
                }
            }
            ```
          </Tab>
        </Tabs>
      </Step>
    </Steps>
  </Tab>

  <Tab title="Access Key">
    Infisical will use the provided **Access Key ID** and **Secret Key** to connect to your AWS instance.

    <Steps>
      <Step title="Add Required Permissions to the IAM User">
        Navigate to your IAM user permissions and click **Create Inline Policy**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/aws/access-key-create-policy.png" alt="User IAM Create Policy" />

        Depending on your use case, add one or more of the following policies to your user:

        <Tabs>
          <Tab title="Secret Sync">
            <AccordionGroup>
              <Accordion title="AWS Secrets Manager">
                Use the following custom policy to grant the minimum permissions required by Infisical to sync secrets to AWS Secrets Manager:

                                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/aws/secrets-manager-permissions.png" alt="IAM Role Secrets Manager Permissions" />

                ```json  theme={"dark"}
                {
                    "Version": "2012-10-17",
                    "Statement": [
                {
                    "Sid": "AllowSecretsManagerAccess",
                    "Effect": "Allow",
                    "Action": [
                        "secretsmanager:ListSecrets",
                        "secretsmanager:GetSecretValue",
                        "secretsmanager:BatchGetSecretValue",
                        "secretsmanager:CreateSecret",
                        "secretsmanager:UpdateSecret",
                        "secretsmanager:DeleteSecret",
                        "secretsmanager:DescribeSecret",
                        "secretsmanager:TagResource",
                        "secretsmanager:UntagResource",
                        "kms:ListAliases", // if you need to specify the KMS key
                        "kms:Encrypt", // if you need to specify the KMS key
                        "kms:Decrypt", // if you need to specify the KMS key
                        "kms:DescribeKey" // if you need to specify the KMS key
                    ],
                    "Resource": "*"
                }
                    ]
                }
                ```

                <Note>If using a custom KMS key, be sure to add the IAM user or role as a key user. <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/aws/kms-key-user.png" alt="KMS Key IAM Role User" /></Note>
              </Accordion>

              <Accordion title="AWS Parameter Store">
                Use the following custom policy to grant the minimum permissions required by Infisical to sync secrets to AWS Parameter Store:

                                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/aws/parameter-store-permissions.png" alt="IAM Role Secrets Manager Permissions" />

                ```json  theme={"dark"}
                {
                    "Version": "2012-10-17",
                    "Statement": [
                {
                    "Sid": "AllowSSMAccess",
                    "Effect": "Allow",
                    "Action": [
                        "ssm:PutParameter",
                        "ssm:GetParameters",
                        "ssm:GetParametersByPath",
                        "ssm:DescribeParameters",
                        "ssm:DeleteParameters",
                        "ssm:ListTagsForResource", // if you need to add tags to secrets
                        "ssm:AddTagsToResource", // if you need to add tags to secrets
                        "ssm:RemoveTagsFromResource", // if you need to add tags to secrets
                        "kms:ListAliases", // if you need to specify the KMS key
                        "kms:Encrypt", // if you need to specify the KMS key
                        "kms:Decrypt", // if you need to specify the KMS key
                        "kms:DescribeKey" // if you need to specify the KMS key
                    ],
                    "Resource": "*"
                }
                    ]
                }
                ```

                <Note>If using a custom KMS key, be sure to add the IAM user or role as a key user. <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/aws/kms-key-user.png" alt="KMS Key IAM Role User" /></Note>
              </Accordion>
            </AccordionGroup>
          </Tab>

          <Tab title="Secret Rotation">
            <AccordionGroup>
              <Accordion title="AWS IAM">
                Use the following custom policy to grant the minimum permissions required by Infisical to rotate secrets to AWS Access Keys:

                                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/aws/iam-role-secret-rotation-permissions.png" alt="IAM Role Secret Rotation Permissions" />

                ```json  theme={"dark"}
                {
                    "Version": "2012-10-17",
                    "Statement": [
                        {
                            "Effect": "Allow",
                            "Action": [
                                "iam:ListAccessKeys",
                                "iam:CreateAccessKey",
                                "iam:UpdateAccessKey",
                                "iam:DeleteAccessKey",
                                "iam:ListUsers"
                            ],
                            "Resource": "*"
                        }
                    ]
                }
                ```
              </Accordion>
            </AccordionGroup>
          </Tab>

          <Tab title="PKI Sync">
            <AccordionGroup>
              <Accordion title="AWS Certificate Manager">
                Use the following custom policy to grant the minimum permissions required by Infisical to sync certificates to AWS Certificate Manager:

                ```json  theme={"dark"}
                {
                    "Version": "2012-10-17",
                    "Statement": [
                        {
                            "Sid": "AllowCertificateManagerAccess",
                            "Effect": "Allow",
                            "Action": [
                                "acm:ListCertificates",
                                "acm:DescribeCertificate",
                                "acm:GetCertificate",
                                "acm:ImportCertificate",
                                "acm:ExportCertificate",
                                "acm:DeleteCertificate",
                                "acm:AddTagsToCertificate",
                                "acm:RemoveTagsFromCertificate",
                                "acm:ListTagsForCertificate"
                            ],
                            "Resource": "*"
                        }
                    ]
                }
                ```

                <Note>
                  * **ListCertificates**: Lists all certificates in the account
                  * **ImportCertificate**: Imports certificates from Infisical into AWS Certificate Manager
                  * **ExportCertificate**: Exports certificates for synchronization
                  * **DeleteCertificate**: Removes certificates that are no longer managed by Infisical
                  * **DescribeCertificate** and **GetCertificate**: Retrieves certificate details for comparison during sync
                  * Tag-related permissions: Manages certificate tags for identification and organization
                </Note>
              </Accordion>
            </AccordionGroup>
          </Tab>
        </Tabs>
      </Step>

      <Step title="Obtain Access Key ID and Secret Access Key">
        Retrieve an AWS **Access Key ID** and a **Secret Key** for your IAM user in **IAM > Users > User > Security credentials > Access keys**.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/aws/integrations-aws-access-key-1.png" alt="access key 1" />
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/aws/integrations-aws-access-key-2.png" alt="access key 2" />
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/aws/integrations-aws-access-key-3.png" alt="access key 3" />
      </Step>

      <Step title="Setup AWS Connection in Infisical">
        <Tabs>
          <Tab title="Infisical UI">
            1. Navigate to the **App Connections** page in the desired project.
               <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/general/add-connection.png" alt="App Connections Tab" />

            2. Select the **AWS Connection** option.
               <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/aws/select-aws-connection.png" alt="Select AWS Connection" />

            3. Select the **Access Key** method option and provide the **Access Key ID** and **Secret Key** obtained from the previous step and press **Connect to AWS**.
               <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/aws/create-access-key-method.png" alt="Create AWS Connection" />

            4. Your **AWS Connection** is now available for use.
               <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/aws/access-key-connection.png" alt="Assume Role AWS Connection" />
          </Tab>

          <Tab title="API">
            To create an AWS Connection, make an API request to the [Create AWS
            Connection](/api-reference/endpoints/app-connections/aws/create) API endpoint.

            ### Sample request

            ```bash Request theme={"dark"}
            curl    --request POST \
                    --url https://app.infisical.com/api/v1/app-connections/aws \
                    --header 'Content-Type: application/json' \
                    --data '{
                        "name": "my-aws-connection",
                        "method": "access-key",
                        "projectId": "7ffbb072-2575-495a-b5b0-127f88caef78",
                        "credentials": {
                            "accessKeyId": "...",
                            "secretKey": "..."
                        }
                    }'
            ```

            ### Sample response

            ```bash Response theme={"dark"}
            {
                "appConnection": {
                    "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                    "name": "my-aws-connection",
                    "projectId": "7ffbb072-2575-495a-b5b0-127f88caef78",
                    "version": 123,
                    "orgId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                    "createdAt": "2023-11-07T05:31:56Z",
                    "updatedAt": "2023-11-07T05:31:56Z",
                    "app": "aws",
                    "method": "access-key",
                    "credentials": {
                        "accessKeyId": "..."
                    }
                }
            }
            ```
          </Tab>
        </Tabs>
      </Step>
    </Steps>
  </Tab>
</Tabs>


# Azure ADCS Connection
Source: https://infisical.com/docs/integrations/app-connections/azure-adcs

Learn how to configure an Azure ADCS Connection for Infisical certificate management.

Connect Infisical to Microsoft Active Directory Certificate Services (ADCS) for automated certificate issuance and management.

## Prerequisites

* Microsoft Active Directory Certificate Services (ADCS) server running and accessible
* Domain administrator account with certificate management permissions
* Network connectivity from Infisical to the ADCS server
* ADCS web enrollment enabled on your server

## Connection Setup

<Steps>
  <Step title="Navigate to App Connections">
    Navigate to the **App Connections** tab on the **Organization Settings** page.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/general/add-connection.png" alt="App Connections Tab" />
  </Step>

  <Step title="Add Connection">
    Select the **Azure ADCS Connection** option from the connection options modal.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/azure-adcs/azure-adcs-select-connection.png" alt="Select Azure ADCS Connection" />
  </Step>

  <Step title="Configure Connection Details">
    **Configuration Tab:**

    * **Name**: Friendly name for this ADCS connection (e.g., "Production ADCS")
    * **ADCS URL**: Your ADCS HTTPS URL (e.g., `https://adcs.yourdomain.com/certsrv`) - only HTTPS is supported
    * **Username**: Domain administrator username (format: `DOMAIN\username` or `username@domain.com`)
    * **Password**: Password for the domain administrator account

    **SSL Tab:**

    * **SSL Certificate**: Optional PEM certificate for custom CA certificates or self-signed certificates
    * **Reject Unauthorized**: Whether to reject connections with invalid SSL certificates (it's recommended to keep it enabled)

    <Note>
      **Getting the SSL Certificate**: If your ADCS server uses a self-signed certificate or a certificate from a custom CA, you can obtain the certificate using OpenSSL or PowerShell:

      **Using OpenSSL:**

      ```bash  theme={"dark"}
      openssl s_client -connect your-adcs-server:443 -showcerts
      ```

      **Using PowerShell (from inside your ADCS Server):**

      ```powershell  theme={"dark"}
      Import-Module WebAdministration -ErrorAction SilentlyContinue
      $binding = Get-WebBinding -Protocol https -Port 443
      if ($binding -and $binding.certificateHash) {
          $cert = Get-ChildItem -Path "Cert:\LocalMachine\My\$($binding.certificateHash)"
          if ($cert) {
              $certBase64 = [System.Convert]::ToBase64String($cert.RawData)
              $certPem = "-----BEGIN CERTIFICATE-----`n" + ($certBase64 -replace '(.{64})', '$1`n') + "`n-----END CERTIFICATE-----"
              Write-Output $certPem
          }
      }
      ```

      Copy the certificate content (including `-----BEGIN CERTIFICATE-----` and `-----END CERTIFICATE-----` lines) and paste it into the SSL Certificate field.
    </Note>

    And click **Connect to ADCS** to establish the connection.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/azure-adcs/azure-adcs-app-connection-form.png" alt="Connect to ADCS" />
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/azure-adcs/azure-adcs-app-connection-form-ssl.png" alt="Connect to ADCS - SSL" />
  </Step>

  <Step title="Connection Created">
    Your **Azure ADCS Connection** is now available for use in your Infisical projects. <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/azure-adcs/azure-adcs-app-connection-created.png" alt="Azure ADCS Connection Created" />
  </Step>
</Steps>


# Azure App Configuration Connection
Source: https://infisical.com/docs/integrations/app-connections/azure-app-configuration

Learn how to configure a Azure App Configuration Connection for Infisical.

Infisical currently only supports two methods for connecting to Azure, which are OAuth and Client Secrets.

<Accordion title="Self-Hosted Instance">
  Using the Azure App Configuration connection on a self-hosted instance of Infisical requires configuring an application in Azure
  and registering your instance with it.

  **Prerequisites:**

  * Set up Azure and have an existing App Configuration instance.

  <Steps>
    <Step title="Create an application in Azure">
      Navigate to Azure Active Directory > App registrations to create a new application.

      <Info>
        Azure Active Directory is now Microsoft Entra ID.
      </Info>

      <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/azure-app-configuration/config-aad.png" alt="Azure app config" />
      <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/azure-app-configuration/config-new-app.png" alt="Azure app config" />

      Create the application. As part of the form, set the **Redirect URI** to `https://your-domain.com/organization/app-connections/azure/oauth/callback`.

      <Tip>
        The domain you defined in the Redirect URI should be equivalent to the `SITE_URL` configured in your Infisical instance.
      </Tip>

            <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/azure/register-callback.png" alt="Azure app config" />
    </Step>

    <Step title="Assign API permissions to the application">
      For the Azure Connection to work with App Configuration, you need to assign multiple permissions to the application.

      #### Azure App Configuration permissions

      Set the API permissions of the Azure application to include the following Azure App Configuration permissions: `KeyValue.Delete`, `KeyValue.Read`, and `KeyValue.Write`.
      <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/azure-app-configuration/app-api-permissions.png" alt="Azure app config" />
    </Step>

    <Step title="Add your application credentials to Infisical">
      Obtain the **Application (Client) ID** in Overview and generate a **Client Secret** in Certificate & secrets for your Azure application.

      <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/azure-app-configuration/config-credentials-1.png" alt="Azure app config" />
      <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/azure-app-configuration/config-credentials-2.png" alt="Azure app config" />
      <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/azure-app-configuration/config-credentials-3.png" alt="Azure app config" />

      Back in your Infisical instance, add two new environment variables for the credentials of your Azure application.

      * `INF_APP_CONNECTION_AZURE_APP_CONFIGURATION_CLIENT_ID`: The **Application (Client) ID** of your Azure application.
      * `INF_APP_CONNECTION_AZURE_APP_CONFIGURATION_CLIENT_SECRET`: The **Client Secret** of your Azure application.

      Once added, restart your Infisical instance and use the Azure App Configuration connection.
    </Step>
  </Steps>
</Accordion>

<Accordion title="Client Secret Authentication">
  To use client secret authentication, ensure your Azure Service Principal has the required permissions and is connected to the Azure App Configuration resources you want to use.

  **Prerequisites:**

  * Set up Azure and have an existing App Configuration instance.
  * The service principal must be connected to your target Azure App Configuration resource(s)

  <Steps>
    <Step title="Assign API permissions to the service principal">
      Configure the required API permissions for your App Registration to interact with Azure App Configuration:

      #### Azure App Configuration permissions

      Set the API permissions of your Azure service principal to include the following Azure App Configuration permissions: `KeyValue.Delete`, `KeyValue.Read`, and `KeyValue.Write`.

            <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/azure-app-configuration/app-api-permissions.png" alt="Azure app config" />
    </Step>
  </Steps>
</Accordion>

## Setup Azure Connection in Infisical

<Steps>
  <Step title="Navigate to App Connections">
    Navigate to the **App Connections** page in the desired project. <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/general/add-connection.png" alt="App Connections
    Tab" />
  </Step>

  <Step title="Add Connection">
    Select the **Azure Connection** option from the connection options modal. <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/azure/app-configuration/select-connection.png" alt="Select Azure Connection" />
  </Step>

  <Step title="Create Connection">
    <Tabs>
      <Tab title="OAuth">
        <Step title="Authorize Connection">
          You can optionally authenticate against a specific tenant by providing the Azure Tenant or Directory ID.

          Now select the **OAuth** method and click **Connect to Azure**.

                    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/azure/app-configuration/create-oauth-method.png" alt="Connect via Azure OAUth" />
        </Step>

        <Step title="Grant Access">
          You will then be redirected to Azure to grant Infisical access to your Azure account. Once granted,
          you will redirect you back to Infisical's App Connections page. <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/azure/grant-access.png" alt="Azure App Configuration
          Authorization" />
        </Step>
      </Tab>

      <Tab title="Client Secret">
        <Step title="Create Connection">
          Fill in the **Tenant ID**, **Client ID** and **Client Secret** fields with the Directory (Tenant) ID, Application (Client) ID and Client Secret you obtained in the previous step.

                    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/azure/app-configuration/create-client-secrets-method.png" alt="Connect via Azure OAUth" />
        </Step>
      </Tab>
    </Tabs>
  </Step>

  <Step title="Connection Created">
    Your **Azure App Configuration Connection** is now available for use. <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/azure/app-configuration/oauth-connection.png" alt="Assume Role AWS Connection" />
  </Step>
</Steps>


# Azure Client Secrets Connection
Source: https://infisical.com/docs/integrations/app-connections/azure-client-secrets

Learn how to configure an Azure Client Secrets Connection for Infisical.

Infisical currently only supports two methods for connecting to Azure, which are OAuth and Client Secrets.

<Accordion title="Self-Hosted Instance">
  Using the Azure Client Secrets connection on a self-hosted instance of Infisical requires configuring an application in Azure
  and registering your instance with it.

  **Prerequisites:**

  * Set up Azure.

  <Steps>
    <Step title="Create an application in Azure">
      Navigate to Azure Active Directory > App registrations to create a new application.

      <Info>
        Azure Active Directory is now Microsoft Entra ID.
      </Info>

      <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/azure-app-configuration/config-aad.png" alt="Azure client secrets" />
      <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/azure-app-configuration/config-new-app.png" alt="Azure client secrets" />

      Create the application. As part of the form, set the **Redirect URI** to `https://your-domain.com/organization/app-connections/azure/oauth/callback`.

      <Tip>
        The domain you defined in the Redirect URI should be equivalent to the `SITE_URL` configured in your Infisical instance.
      </Tip>

            <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/azure/register-callback.png" alt="Azure client secrets" />
    </Step>

    <Step title="Assign API permissions to the application">
      For the Azure Connection to work with Client Secrets, you need to assign the following permission to the application.

      #### Azure Client Secrets permissions

      Set the API permissions of the Azure application to include the following permissions:

      * Microsoft Graph
        * `Application.ReadWrite.All`
        * `Application.ReadWrite.OwnedBy`
        * `Application.ReadWrite.All` (Delegated)
        * `Directory.ReadWrite.All` (Delegated)
        * `User.Read` (Delegated)

            <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/azure-client-secrets/app-api-permissions.png" alt="Azure client secrets" />
    </Step>

    <Step title="Add your application credentials to Infisical">
      Obtain the **Application (Client) ID** and **Directory (Tenant) ID** (this will be used later in the Infisical connection) in Overview and generate a **Client Secret** in Certificate & secrets for your Azure application.

      <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/azure/client-secrets/config-credentials-1.png" alt="Azure client secrets" />
      <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/azure-app-configuration/config-credentials-2.png" alt="Azure client secrets" />
      <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/azure-app-configuration/config-credentials-3.png" alt="Azure client secrets" />

      Back in your Infisical instance, add two new environment variables for the credentials of your Azure application.

      * `INF_APP_CONNECTION_AZURE_CLIENT_SECRETS_CLIENT_ID`: The **Application (Client) ID** of your Azure application.
      * `INF_APP_CONNECTION_AZURE_CLIENT_SECRETS_CLIENT_SECRET`: The **Client Secret** of your Azure application.

      Once added, restart your Infisical instance and use the Azure Client Secrets connection.
    </Step>
  </Steps>
</Accordion>

<AccordionGroup>
  <Accordion title="Client Secret Authentication">
    Ensure your Azure application has the required permissions that Infisical needs for the Azure Client Secrets connection to work.

    **Prerequisites:**

    * An active Azure setup.

    <Steps>
      <Step title="Assign API permissions to the application">
        For the Azure Client Secrets connection to work, assign the following permissions to your Azure application:

        #### Required API Permissions

        **Microsoft Graph**

        * `Application.ReadWrite.All`
        * `Application.ReadWrite.OwnedBy`
        * `Application.ReadWrite.All` (Delegated)
        * `Directory.ReadWrite.All` (Delegated)
        * `User.Read` (Delegated)

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/azure-client-secrets/app-api-permissions.png" alt="Azure client secrets" />
      </Step>
    </Steps>
  </Accordion>

  <Accordion title="Certificate Authentication">
    Ensure your Azure application has the required permissions that Infisical needs for the Azure Client Secrets connection to work.

    **Prerequisites:**

    * An active Azure setup.

    <Steps>
      <Step title="Assign API permissions to the application">
        For the Azure Client Secrets connection to work, assign the following permissions to your Azure application:

        #### Required API Permissions

        **Microsoft Graph**

        * `Application.ReadWrite.All`
        * `Application.ReadWrite.OwnedBy`
        * `Application.ReadWrite.All` (Delegated)
        * `Directory.ReadWrite.All` (Delegated)
        * `User.Read` (Delegated)

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/azure-client-secrets/app-api-permissions.png" alt="Azure client secrets" />
      </Step>

      <Step title="Upload your certificate to your Azure App Registration">
        Navigate to the **Certificates & secrets** section of your Azure App Registration, and press the **Upload certificate** button.

        Select the **Upload** button and upload your certificate.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/azure/client-secrets/upload-certificate.png" alt="Upload certificate" />

        <Tip>
          Keep in mind that both the certificate and its private key are required to configure the Azure Client Secrets connection in Infisical.
        </Tip>
      </Step>
    </Steps>
  </Accordion>
</AccordionGroup>

## Setup Azure Connection in Infisical

<Steps>
  <Step title="Navigate to App Connections">
    Navigate to the **App Connections** page in the desired project. <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/general/add-connection.png" alt="App Connections
    Tab" />
  </Step>

  <Step title="Add Connection">
    Select the **Azure Connection** option from the connection options modal. <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/azure/client-secrets/select-connection.png" alt="Select Azure Connection" />
  </Step>

  <Step title="Create Connection">
    <Tabs>
      <Tab title="OAuth">
        <Step title="Authorize Connection">
          Fill in the **Tenant ID** field with the Directory (Tenant) ID you obtained in the previous step.

          Now select the **OAuth** method and click **Connect to Azure**.

                    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/azure/client-secrets/create-oauth-method.png" alt="Connect via Azure OAUth" />
        </Step>

        <Step title="Grant Access">
          You will then be redirected to Azure to grant Infisical access to your Azure account. Once granted,
          you will be redirected back to Infisical's App Connections page. <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/azure/grant-access.png" alt="Azure Client Secrets
          Authorization" />
        </Step>
      </Tab>

      <Tab title="Client Secret">
        <Step title="Create Connection">
          Fill in the **Tenant ID**, **Client ID** and **Client Secret** fields with the Directory (Tenant) ID, Application (Client) ID and Client Secret you obtained in the previous step.

                    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/azure/client-secrets/create-client-secrets-method.png" alt="Connect via Azure OAUth" />
        </Step>
      </Tab>

      <Tab title="Certificate">
        <Step title="Create Connection">
          Fill in the **Tenant ID**, **Client ID**, **Certificate (PEM format)**, and **Private Key** fields with the Directory (Tenant) ID, Application (Client) ID, Certificate and Private Key you obtained in the [previous step](#certificate-authentication).

          <Tip>
            The private key is never transmitted to Azure, and it is only used to sign the client assertion used to authenticate with Azure.
          </Tip>

                    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/azure/client-secrets/create-certificate-method.png" alt="Connect via Azure Certificate" />
        </Step>
      </Tab>
    </Tabs>
  </Step>

  <Step title="Connection Created">
    Your **Azure Client Secrets Connection** is now available for use. <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/azure/client-secrets/oauth-connection.png" alt="Azure Client Secrets" />
  </Step>
</Steps>


# Azure DevOps Connection
Source: https://infisical.com/docs/integrations/app-connections/azure-devops

Learn how to configure an Azure DevOps Connection for Infisical.

Infisical currently supports three methods for connecting to Azure DevOps, which are OAuth, Azure DevOps Personal Access Token and Client Secrets.

<Accordion title="Azure OAuth on a Self-Hosted Instance">
  Using the Azure DevOps <b>OAuth connection</b> on a self-hosted instance of Infisical requires configuring an application in Azure
  and registering your instance with it.

  **Prerequisites:**

  * Set up Azure.

  <Steps>
    <Step title="Create an application in Azure">
      Navigate to Azure Active Directory > App registrations to create a new application.

      <Info>
        Azure Active Directory is now Microsoft Entra ID.
      </Info>

      <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/azure-app-configuration/config-aad.png" alt="Azure devops" />
      <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/azure-app-configuration/config-new-app.png" alt="Azure devops" />

      Create the application. As part of the form, set the **Redirect URI** to `https://your-domain.com/organization/app-connections/azure/oauth/callback`.

      <Tip>
        The domain you defined in the Redirect URI should be equivalent to the `SITE_URL` configured in your Infisical instance.
      </Tip>

            <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/azure/register-callback.png" alt="Azure devops" />
    </Step>

    <Step title="Assign API permissions to the application">
      For the Azure Connection to work with DevOps Pipelines, you need to assign the following permission to the application.

      #### Azure DevOps permissions

      Set the API permissions of the Azure application to include the following permissions:

      * Azure DevOps
        * `user_impersonation`
        * `vso.project_write`
        * `vso.variablegroups_manage`
        * `vso.variablegroups_write`

            <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/azure-devops/app-api-permissions.png" alt="Azure devops" />
    </Step>

    <Step title="Add your application credentials to Infisical">
      Obtain the **Application (Client) ID** and **Directory (Tenant) ID** (this will be used later in the Infisical connection) in Overview and generate a **Client Secret** in Certificate & secrets for your Azure application.

      <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/azure/client-secrets/config-credentials-1.png" alt="Azure devops" />
      <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/azure-app-configuration/config-credentials-2.png" alt="Azure devops" />
      <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/azure-app-configuration/config-credentials-3.png" alt="Azure devops" />

      Back in your Infisical instance, add two new environment variables for the credentials of your Azure application.

      * `INF_APP_CONNECTION_AZURE_DEVOPS_CLIENT_ID`: The **Application (Client) ID** of your Azure application.
      * `INF_APP_CONNECTION_AZURE_DEVOPS_CLIENT_SECRET`: The **Client Secret** of your Azure application.

      Once added, restart your Infisical instance and use the Azure Client Secrets connection.
    </Step>
  </Steps>
</Accordion>

<Accordion title="Azure DevOps personal access token (PAT)">
  #### Create a new Azure DevOps personal access token (PAT)

  When using the Azure DevOps <b>Access Token connection</b> you'll need to create a new personal access token (PAT) in order to authenticate Infisical with Azure DevOps.

  <Steps>
    <Step title="Navigate to Azure DevOps">
            <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/azure-devops/overview-page.png" alt="integrations" />
    </Step>

    <Step title="Create a new token">
      Make sure the newly created token has Read/Write access to the Release scope.
      <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/azure-devops/create-new-token.png" alt="integrations" />

      <Note>
        Please make sure that the token has access to the following scopes: Variable Groups *(read, create, & manage)*, Release *(read/write)*, Project and Team *(read)*, Service Connections *(read & query)*
      </Note>
    </Step>

    <Step title="Copy the new access token">
      Copy the newly created token as this will be used to authenticate Infisical with Azure DevOps.
      <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/azure-devops/new-token-created.png" alt="integrations" />
    </Step>
  </Steps>
</Accordion>

<Accordion title="Client Secret Authentication">
  To use client secret authentication, ensure your Azure Service Principal has the required permissions and is connected to the Azure DevOps organization and projects you want to use.

  **Prerequisites:**

  * Set up Azure and have an existing Azure DevOps organization.
  * The service principal must be connected to your target Azure DevOps organization and project(s)

  <Steps>
    <Step title="Assign API permissions to the service principal">
      Configure the required API permissions for your App Registration to interact with Azure DevOps:

      #### Azure DevOps permissions

      Set the API permissions of your Azure service principal to include the following Azure DevOps permissions:

      * Azure DevOps
        * `user_impersonation`
        * `vso.project_write`
        * `vso.variablegroups_manage`
        * `vso.variablegroups_write`

            <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/azure-devops/app-api-permissions.png" alt="Azure devops" />
    </Step>
  </Steps>
</Accordion>

## Setup Azure Connection in Infisical

<Steps>
  <Step title="Navigate to App Connections">
    Navigate to the **App Connections** page in the desired project. <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/general/add-connection.png" alt="App Connections
    Tab" />
  </Step>

  <Step title="Add Connection">
    Select the **Azure Connection** option from the connection options modal. <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/azure/devops/select-connection.png" alt="Select Azure Connection" />
  </Step>

  <Step title="Create Connection">
    <Tabs>
      <Tab title="OAuth">
        <Steps>
          <Step title="Fill in Connection Details">
            Fill in the **Tenant ID** field with the Directory (Tenant) ID you obtained in the previous [step](#azure-oauth-on-a-self-hosted-instance). Also fill in the organization name of the Azure DevOps organization you want to connect to.
            <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/azure/devops/fill-in-connection-details-oauth.png" alt="Fill in Connection Details" />

            <Tip>
              You can find the **Organization Name** on [https://dev.azure.com/](https://dev.azure.com/)
            </Tip>
          </Step>

          <Step title="Grant Access">
            You will then be redirected to Azure to grant Infisical access to your Azure account. Once granted,
            you will be redirected back to Infisical's App Connections page. <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/azure/grant-access.png" alt="Azure Client Secrets
            Authorization" />
          </Step>
        </Steps>
      </Tab>

      <Tab title="Access Token">
        <Steps>
          <Step title="Fill in Connection Details">
            Fill in the **Access Token** field with the Access Token you obtained in the previous step. And the organization name of the Azure DevOps organization you want to connect to.
            <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/azure/devops/fill-in-connection-details-token.png" alt="Fill in Connection Details" />

            <Tip>
              You can find the **Organization Name** on [https://dev.azure.com/](https://dev.azure.com/)
            </Tip>
          </Step>
        </Steps>
      </Tab>

      <Tab title="Client Secret">
        <Steps>
          <Step title="Create Connection">
            Fill in the **Tenant ID**, **Client ID**, **Client Secret** and **Organization Name** fields with the Directory (Tenant) ID, Application (Client) ID, Client Secret and the organization name you obtained in the previous step.

            <Tip>
              You can find the **Organization Name** on [https://dev.azure.com/](https://dev.azure.com/)
            </Tip>

                        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/azure/devops/create-client-secrets-method.png" alt="Connect via Azure OAUth" />
          </Step>
        </Steps>
      </Tab>
    </Tabs>
  </Step>

  <Step title="Connection Created">
    Your **Azure DevOps Connection** is now available for use. <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/azure/devops/devops-connection.png" alt="Azure DevOps" />
  </Step>
</Steps>


# Azure Key Vault Connection
Source: https://infisical.com/docs/integrations/app-connections/azure-key-vault

Learn how to configure a Azure Key Vault Connection for Infisical.

Infisical currently only supports two methods for connecting to Azure, which are OAuth and Client Secrets.

<Accordion title="Self-Hosted Instance">
  Using the Azure Key Vault connection on a self-hosted instance of Infisical requires configuring an application in Azure
  and registering your instance with it.

  **Prerequisites:**

  * Set up Azure and have an existing Key Vault instance.

  <Steps>
    <Step title="Create an application in Azure">
      Navigate to Azure Active Directory > App registrations to create a new application.

      <Info>
        Azure Active Directory is now Microsoft Entra ID.
      </Info>

      <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/azure-app-configuration/config-aad.png" alt="Azure key vault" />
      <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/azure-app-configuration/config-new-app.png" alt="Azure key vault" />

      Create the application. As part of the form, set the **Redirect URI** to `https://your-domain.com/organization/app-connections/azure/oauth/callback`.

      <Tip>
        The domain you defined in the Redirect URI should be equivalent to the `SITE_URL` configured in your Infisical instance.
      </Tip>

            <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/azure/register-callback.png" alt="Azure key vault" />
    </Step>

    <Step title="Assign API permissions to the application">
      For the Azure Connection to work with Key Vault, you need to assign multiple permissions to the application.

      #### Azure Key Vault permissions

      Set the API permissions of the Azure application to include `user.impersonation` for the Key Vault API.
      <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/azure/keyvault-azure-permissions.png" alt="Azure key vault" />
    </Step>

    <Step title="Add your application credentials to Infisical">
      Obtain the **Application (Client) ID** in Overview and generate a **Client Secret** in Certificate & secrets for your Azure application.

      <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/azure-app-configuration/config-credentials-1.png" alt="Azure key vault" />
      <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/azure-app-configuration/config-credentials-2.png" alt="Azure key vault" />
      <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/azure-app-configuration/config-credentials-3.png" alt="Azure key vault" />

      Back in your Infisical instance, add two new environment variables for the credentials of your Azure application.

      * `INF_APP_CONNECTION_AZURE_KEY_VAULT_CLIENT_ID`: The **Application (Client) ID** of your Azure application.
      * `INF_APP_CONNECTION_AZURE_KEY_VAULT_CLIENT_SECRET`: The **Client Secret** of your Azure application.

      Once added, restart your Infisical instance and use the Azure Key Vault connection.
    </Step>
  </Steps>
</Accordion>

<Accordion title="Client Secret Authentication">
  To use client secret authentication, ensure your Azure Service Principal has the required permissions and is connected to the Azure Key Vault instances you want to use.

  **Prerequisites:**

  * Set up Azure and have an existing Key Vault instance.
  * The service principal must be connected to your target Azure Key Vault instance(s)

  <Steps>
    <Step title="Assign API permissions to the service principal">
      Configure the required API permissions for your App Registration to interact with Azure Key Vault:

      #### Azure Key Vault permissions

      Set the API permissions of your Azure service principal to include `user_impersonation` for the Key Vault API.
      <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/azure/keyvault-azure-permissions.png" alt="Azure key vault" />
    </Step>
  </Steps>
</Accordion>

## Setup Azure Connection in Infisical

<Steps>
  <Step title="Navigate to App Connections">
    Navigate to the **App Connections** page in the desired project. <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/general/add-connection.png" alt="App Connections
    Tab" />
  </Step>

  <Step title="Add Connection">
    Select the **Azure Connection** option from the connection options modal. <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/azure/key-vault/select-connection.png" alt="Select Azure Connection" />
  </Step>

  <Step title="Create Connection">
    <Tabs>
      <Tab title="OAuth">
        <Steps>
          <Step title="Authorize Connection">
            You can optionally authenticate against a specific tenant by providing the Azure Tenant or Directory ID.

            Now select the **OAuth** method and click **Connect to Azure**.

                        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/azure/key-vault/create-oauth-method.png" alt="Connect via Azure OAUth" />
          </Step>

          <Step title="Grant Access">
            You will then be redirected to Azure to grant Infisical access to your Azure account. Once granted,
            you will redirect you back to Infisical's App Connections page. <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/azure/grant-access.png" alt="Azure Key Vault
            Authorization" />
          </Step>
        </Steps>
      </Tab>

      <Tab title="Client Secret">
        <Steps>
          <Step title="Create Connection">
            Fill in the **Tenant ID**, **Client ID**, **Client Secret** fields with the Directory (Tenant) ID, Application (Client) ID, Client Secret you obtained in the previous step.
            <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/azure/key-vault/create-client-secrets-method.png" alt="Connect via Azure OAUth" />
          </Step>
        </Steps>
      </Tab>
    </Tabs>
  </Step>

  <Step title="Connection Created">
    Your **Azure Key Vault Connection** is now available for use. <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/azure/key-vault/oauth-connection.png" alt="Assume Role AWS Connection" />
  </Step>
</Steps>


# Bitbucket Connection
Source: https://infisical.com/docs/integrations/app-connections/bitbucket

Learn how to configure a Bitbucket Connection for Infisical.

Infisical supports the use of [API Tokens](https://support.atlassian.com/bitbucket-cloud/docs/api-tokens/) to connect with Bitbucket.

<Tip>
  Infisical recommends creating a dedicated Bitbucket account with access restricted to only the resources your use case requires.
</Tip>

## Create Bitbucket Access Token

<Steps>
  <Step title="Create API Token">
    Go to [Account API Tokens](https://id.atlassian.com/manage-profile/security/api-tokens) and click **Create API token with scopes**.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/bitbucket/step-1.png" alt="Create API Token" />
  </Step>

  <Step title="Set Name and Expiry">
    Set the name and expiration date of the token, then click **Next**.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/bitbucket/step-2.png" alt="Set Name and Expiry" />

    <Note>
      Keep in mind that you'll need to manually replace the token after it expires.
    </Note>
  </Step>

  <Step title="Select Bitbucket">
    Select **Bitbucket** and then click **Next**.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/bitbucket/step-3.png" alt="Select Bitbucket" />
  </Step>

  <Step title="Configure Permissions">
    Configure permissions according to your app's use case:

    <Tabs>
      <Tab title="Secret Scanning">
        ```
        read:workspace:bitbucket
        read:user:bitbucket
        read:webhook:bitbucket
        write:webhook:bitbucket
        delete:webhook:bitbucket
        read:repository:bitbucket
        ```

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/bitbucket/step-4.png" alt="Configure Permissions" />
      </Tab>

      <Tab title="Secret Sync">
        ```
        read:workspace:bitbucket
        admin:workspace:bitbucket
        read:user:bitbucket
        read:repository:bitbucket
        read:pipeline:bitbucket
        write:pipeline:bitbucket
        admin:pipeline:bitbucket
        ```

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/bitbucket/step-4-secret-sync.png" alt="Configure Permissions" />
      </Tab>
    </Tabs>

    Click **Next**.
  </Step>

  <Step title="Copy Token">
    Save the API Token for later steps.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/bitbucket/step-5.png" alt="Save Token" />
  </Step>
</Steps>

## Create Bitbucket Connection in Infisical

<Tabs>
  <Tab title="Infisical UI">
    <Steps>
      <Step title="Navigate to App Connections">
        In your Infisical dashboard, navigate to the **App Connections** page in the desired project.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/general/add-connection.png" alt="App Connections Tab" />
      </Step>

      <Step title="Select Bitbucket Connection">
        Click the **Add new connection** button and select **Bitbucket** from the list of available connections.
      </Step>

      <Step title="Fill out the Bitbucket Connection Modal">
        Complete the Bitbucket Connection form by entering:

        * A descriptive name for the connection
        * An optional description for future reference
        * Your Bitbucket email
        * The API Token from earlier steps

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/bitbucket/step-6.png" alt="Bitbucket Connection Modal" />
      </Step>

      <Step title="Connection Created">
        After clicking Create, your **Bitbucket Connection** is established and ready to use with your Infisical project.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/bitbucket/step-7.png" alt="Bitbucket Connection Created" />
      </Step>
    </Steps>
  </Tab>

  <Tab title="API">
    To create a Bitbucket Connection, make an API request to the [Create Bitbucket Connection](/api-reference/endpoints/app-connections/bitbucket/create) API endpoint.

    ### Sample request

    ```bash Request theme={"dark"}
    curl    --request POST \
            --url https://app.infisical.com/api/v1/app-connections/bitbucket \
            --header 'Content-Type: application/json' \
            --data '{
                "name": "my-bitbucket-connection",
                "method": "api-token",
                "projectId": "7ffbb072-2575-495a-b5b0-127f88caef78",
                "credentials": {
                    "email": "user@example.com",
                    "apiToken": "<YOUR-API-TOKEN>"
                }
            }'
    ```

    ### Sample response

    ```bash Response theme={"dark"}
    {
      "appConnection": {
          "id": "e5d18aca-86f7-4026-a95e-efb8aeb0d8e6",
          "name": "my-bitbucket-connection",
          "projectId": "7ffbb072-2575-495a-b5b0-127f88caef78",
          "description": null,
          "version": 1,
          "orgId": "6f03caa1-a5de-43ce-b127-95a145d3464c",
          "createdAt": "2025-04-23T19:46:34.831Z",
          "updatedAt": "2025-04-23T19:46:34.831Z",
          "isPlatformManagedCredentials": false,
          "credentialsHash": "7c2d371dec195f82a6a0d5b41c970a229cfcaf88e894a5b6395e2dbd0280661f",
          "app": "bitbucket",
          "method": "api-token",
          "credentials": {
              "email": "user@example.com"
          }
      }
    }
    ```
  </Tab>
</Tabs>


# Camunda Connection
Source: https://infisical.com/docs/integrations/app-connections/camunda

Learn how to configure a Camunda Connection for Infisical.

Infisical supports connecting to Camunda APIs using [client credentials](https://docs.camunda.io/docs/apis-tools/administration-api/authentication/#client-credentials-and-scopes).

## Configure Client Credentials for Infisical

<Steps>
  <Step title="Navigate to Organization Management">
    In your Camunda Cloud Console, navigate to the **Organization** tab in the top navigation menu.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/camunda/camunda-console.png" alt="Organization Management" />
  </Step>

  <Step title="Access Administration API">
    From the Organization Management tabs, click on **Administration API** to manage your API credentials and click the **Create client credentials** button.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/camunda/camunda-organization-page.png" alt="Create Client Credentials" />
  </Step>

  <Step title="Name Your Client">
    Enter a recognizable name for your client, such as "my-infisical-client". The name can contain letters, dashes, underscores, and digits.
  </Step>

  <Step title="Set Credential Permissions">
    In the "Create new client credentials" modal, select the following permissions required for secret syncs:

    * **Cluster**: Enable read access (Get)
    * **Connector secrets**: Enable all operations (Get, Create, Update, Delete)

    These specific permissions are required for Infisical to properly sync and manage your Camunda secrets.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/camunda/camunda-create-client-1.png" alt="Set Permissions" />
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/camunda/camunda-create-client-2.png" alt="Set Permissions 2" />
  </Step>

  <Step title="Complete Creation">
    Click the **Create** button to generate your client credentials.
  </Step>

  <Step title="Save Your Credentials">
    After creation, you'll be shown your client credentials. For the Infisical connection, you'll need:

    * **Client ID** (`CAMUNDA_CONSOLE_CLIENT_ID`)
    * **Client Secret** (`CAMUNDA_CONSOLE_CLIENT_SECRET`)

    **IMPORTANT**: Make sure to securely save the Client Secret, as it will not be shown again after you close this dialog.

    You can download these credentials or copy them to use in the next section.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/camunda/camunda-client-credentials.png" alt="Client Credentials" />
  </Step>
</Steps>

## Setup Camunda Connection in Infisical

<Steps>
  <Step title="Navigate to App Connections">
    Navigate to the **App Connections** page in the desired project. <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/general/add-connection.png" alt="App Connections
    Tab" />
  </Step>

  <Step title="Add Connection">
    Select the **Camunda Connection** option from the connection options modal.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/camunda/camunda-app-connection-select.png" alt="Select Camunda
    Connection" />
  </Step>

  <Step title="Input Credentials">
    Select the **Client Credentials** method and enter the Camunda client
    credentials you created:

    * **Client ID**: Your `CAMUNDA_CONSOLE_CLIENT_ID` value
    * **Client Secret**: Your `CAMUNDA_CONSOLE_CLIENT_SECRET` value

    Infisical will automatically configure the connection using these credentials to access the Camunda API. Click **Connect to Camunda** to establish the connection. <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/camunda/camunda-app-connection-form.png" alt="Connect to Camunda" />
  </Step>

  <Step title="Connection Created">
    Your **Camunda Connection** is now available for use in your Infisical
    projects. <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/camunda/camunda-app-connection-created.png" alt="Camunda Connection
    Created" />
  </Step>
</Steps>


# Checkly Connection
Source: https://infisical.com/docs/integrations/app-connections/checkly

Learn how to configure a Checkly Connection for Infisical.

Infisical supports the use of [API Keys](https://app.checklyhq.com/settings/user/api-keys) to connect with Checkly.

<Note>
  Checkly requires the account user to have Read/Write or Admin permissions
</Note>

## Create a Checkly API Token

<Steps>
  <Step title="Click the profile image in the top-right corner and select 'User Settings'">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/checkly/checkly-app-connection-profile.png" alt="Dashboard Page" />
  </Step>

  <Step title="In the user settings sidebar, select 'API Keys'">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/checkly/checkly-app-connection-api-keys.png" alt="User Settings Page" />
  </Step>

  <Step title="In the api keys page, click on 'Create API Key'">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/checkly/checkly-app-connection-create-api-key.png" alt="Api Keys Page" />
  </Step>

  <Step title="Enter a token name and click on 'Create API Key'">
    Provide a descriptive name for the token.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/checkly/checkly-app-connection-create-form.png" alt="Enter Name" />
  </Step>

  <Step title="Copy the generated key and save it">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/checkly/checkly-app-connection-key-generated.png" alt="Create Token" />
  </Step>
</Steps>

## Create a Checkly Connection in Infisical

<Tabs>
  <Tab title="Infisical UI">
    <Steps>
      <Step title="Navigate to App Connections">
        In your Infisical dashboard, navigate to the **App Connections** page in the desired project.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/general/add-connection.png" alt="App Connections Tab" />
      </Step>

      <Step title="Select Checkly Connection">
        Click **+ Add Connection** and choose **Checkly Connection** from the list of integrations.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/checkly/checkly-app-connection-option.png" alt="Select Checkly Connection" />
      </Step>

      <Step title="Fill out the Checkly Connection form">
        Complete the form by providing:

        * A descriptive name for the connection
        * An optional description
        * The API Key value from the previous step

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/checkly/checkly-app-connection-form.png" alt="Checkly Connection Modal" />
      </Step>

      <Step title="Connection created">
        After submitting the form, your **Checkly Connection** will be successfully created and ready to use with your Infisical project.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/checkly/checkly-app-connection-generated.png" alt="Checkly Connection Created" />
      </Step>
    </Steps>
  </Tab>

  <Tab title="API">
    To create a Checkly Connection via API, send a request to the [Create Checkly Connection](/api-reference/endpoints/app-connections/checkly/create) endpoint.

    ### Sample request

    ```bash Request theme={"dark"}
    curl    --request POST \
            --url https://app.infisical.com/api/v1/app-connections/checkly \
            --header 'Content-Type: application/json' \
            --data '{
                "name": "my-checkly-connection",
                "method": "api-key",
                "projectId": "7ffbb072-2575-495a-b5b0-127f88caef78",
                "credentials": {
                    "apiKey": "[API KEY]"
                }
            }'
    ```

    ### Sample response

    ```bash Response theme={"dark"}
    {
      "appConnection": {
          "id": "e5d18aca-86f7-4026-a95e-efb8aeb0d8e6",
          "name": "my-checkly-connection",
          "projectId": "7ffbb072-2575-495a-b5b0-127f88caef78",
          "description": null,
          "version": 1,
          "orgId": "6f03caa1-a5de-43ce-b127-95a145d3464c",
          "createdAt": "2025-04-23T19:46:34.831Z",
          "updatedAt": "2025-04-23T19:46:34.831Z",
          "isPlatformManagedCredentials": false,
          "credentialsHash": "7c2d371dec195f82a6a0d5b41c970a229cfcaf88e894a5b6395e2dbd0280661f",
          "app": "checkly",
          "method": "api-key",
          "credentials": {}
      }
    }
    ```
  </Tab>
</Tabs>


# Chef Connection
Source: https://infisical.com/docs/integrations/app-connections/chef

Learn how to configure a Chef Connection for Infisical.

<Info>
  Chef App Connection is a paid feature.

  If you're using Infisical Cloud, then it is available under the **Enterprise Tier**. If you're self-hosting Infisical,
  then you should contact [team@infisical.com](mailto:team@infisical.com) to purchase an enterprise license to use it.
</Info>

Infisical supports the use of User Private Key to connect with Chef Server.

Please access your **starter kit** to get all the required information to create a Chef Connection.

<Accordion title="If you don't have a starter kit">
  <Warning>
    If you download a new starter kit, your previous private key/user key will
    no longer be valid. Please make sure to update all the places that use the
    previous private key.
  </Warning>

  <Steps>
    <Step title="Navigate to your Chef Server Dashboard, and click on the 'Organizations' tab">
            <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/chef/chef-dashboard.png" alt="Chef Server User Keys" />
    </Step>

    <Step title="Click on the organization you want to connect to, and then click on the 'Starter Kit' button">
            <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/chef/starter-kit.png" alt="Starter Kit" />
    </Step>

    <Step title="Click on the 'Download Starter Kit' button to download the starter kit">
            <img
              src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/chef/download-starter-kit.png"
              alt="Download Starter
      Kit"
            />
    </Step>

    <Step title="Download the starter kit zip file and extract the contents">
            <img
              src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/chef/extract-starter-kit.png"
              alt="Extract Starter
      Kit"
            />
    </Step>
  </Steps>
</Accordion>

<Steps>
  <Step title="Open your starter kit's folder">
    Open your starter kit's folder(or `chef-repo`) and navigate to the `.chef`
    folder.

    <Note>
      Please make sure you have hidden files visible in your file explorer.
    </Note>

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/chef/chef-folder.png" alt=".chef folder" />
  </Step>

  <Step title="Copy the private key">
    In the `.chef` folder, you will find a `[your-username].pem` file. <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/chef/private-key-file.png" alt="Private
    Key File" />

    **Private Key:** Copy the content of the private key file.
  </Step>

  <Step title="Open the config.rb file">
    Open the `config.rb` file and copy the content of the file.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/chef/chef-connection-details.png" alt="Config.rb File Content" />

    **User Name(1):** The user name of the chef user.

    **Server URL(2):** The server url of the chef server.

    **Organization Name(3):** The organization name of the chef server.
  </Step>
</Steps>

## Create a Chef Connection in Infisical via UI

<Tabs>
  <Tab title="Infisical UI">
    <Steps>
      <Step title="Navigate to App Connections">
        In your Infisical dashboard, navigate to the **App Connections** page in the desired project.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/general/add-connection.png" alt="App Connections Tab" />
      </Step>

      <Step title="Select Chef Connection">
        Click **+ Add Connection** and choose **Chef** Connection from the list of integrations.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/chef/app-connection-option.png" alt="Select Chef Connection" />
      </Step>

      <Step title="Fill out the Chef Connection form">
        Complete the form by providing:

        * A descriptive name for the connection
        * An optional description
        * Server URL(optional): The URL of the Chef server to connect with (defaults to [https://api.chef.io](https://api.chef.io))
        * Organization short name
        * User name
        * Private key: Your Chef user's private key (.pem file)

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/chef/app-connection-form.png" alt="Chef Connection Modal" />
      </Step>

      <Step title="Connection created">
        After submitting the form, your **Chef Connection** will be successfully created and ready to use with your Infisical project.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/chef/app-connection-generated.png" alt="Chef Connection Created" />
      </Step>
    </Steps>
  </Tab>

  <Tab title="API">
    To create a Chef Connection via API, send a request to the [Create Chef Connection](/api-reference/endpoints/app-connections/chef/create) endpoint.

    ### Sample request

    ```bash Request theme={"dark"}
    curl    --request POST \
            --url https://app.infisical.com/api/v1/app-connections/chef \
            --header 'Content-Type: application/json' \
            --data '{
                "name": "my-chef-connection",
                "method": "user-key",
                "projectId": "7ffbb072-2575-495a-b5b0-127f88caef78",
                "credentials": {
                    "orgName": "my-org",
                    "userName": "my-user",
                    "privateKey": "your-private-key"
                }
            }'
    ```

    ### Sample response

    ```bash Response theme={"dark"}
    {
      "appConnection": {
          "id": "a1b2c3d4-5678-90ab-cdef-1234567890ab",
          "name": "my-chef-connection",
          "description": null,
          "projectId": "7ffbb072-2575-495a-b5b0-127f88caef78",
          "version": 1,
          "orgId": "abcdef12-3456-7890-abcd-ef1234567890",
          "createdAt": "2025-10-13T10:15:00.000Z",
          "updatedAt": "2025-10-13T10:15:00.000Z",
          "isPlatformManagedCredentials": false,
          "credentialsHash": "d41d8cd98f00b204e9800998ecf8427e",
          "app": "chef",
          "method": "user-key",
          "credentials": {
            "orgName": "my-org",
            "userName": "my-user",
          }
      }
    }
    ```
  </Tab>
</Tabs>


# Cloudflare Connection
Source: https://infisical.com/docs/integrations/app-connections/cloudflare

Learn how to configure a Cloudflare Connection for Infisical.

Infisical supports connecting to Cloudflare using API tokens and Account ID for secure access to your Cloudflare services.

## Configure API Token and Account ID for Infisical

<Steps>
  <Step title="Create API Token">
    Navigate to your Cloudflare dashboard and go to **Profile**.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/cloudflare/cloudflare-navigate-profile.png" alt="Navigate Cloudflare Profile" />

    Click **API Tokens > Create Token** to generate a new API token.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/cloudflare/cloudflare-create-token.png" alt="Create API Token" />
  </Step>

  <Step title="Configure Token Permissions">
    Configure your API token with the necessary permissions for your Cloudflare services.

    Depending on your use case, add one or more of the following permission sets to your API token:

    <Tabs>
      <Tab title="Secret Sync">
        <AccordionGroup>
          <Accordion title="Cloudflare Pages">
            Use the following permissions to grant Infisical access to sync secrets to Cloudflare Pages:

                        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/cloudflare/cloudflare-pages-configure-permissions.png" alt="Configure Token" />

            **Required Permissions:**

            * **Account** - **Cloudflare Pages** - **Edit**
            * **Account** - **Account Settings** - **Read**

            Add these permissions to your API token and click **Continue to summary**, then **Create Token** to generate your API token.
          </Accordion>

          <Accordion title="Cloudflare Workers">
            Use the following permissions to grant Infisical access to sync secrets to Cloudflare Workers:

                        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/cloudflare/cloudflare-workers-configure-permissions.png" alt="Configure Token" />

            **Required Permissions:**

            * **Account** - **Workers Scripts** - **Edit**
            * **Account** - **Account Settings** - **Read**

            Add these permissions to your API token and click **Continue to summary**, then **Create Token** to generate your API token.
          </Accordion>
        </AccordionGroup>
      </Tab>

      <Tab title="PKI">
        Use the following permissions to grant Infisical access to verify certificates using DNS TXT records with ACME:

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/cloudflare/cloudflare-dns-configure-permissions.png" alt="Configure Token" />

        **Required Permissions:**

        * **Account** - **Account Settings** - **Read**
        * **Zone** - **DNS** - **Edit**

        Add these permissions to your API token and click **Continue to summary**, then **Create Token** to generate your API token.
      </Tab>
    </Tabs>
  </Step>

  <Step title="Save Your API Token">
    After creation, copy and securely store your API token as it will not be shown again.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/cloudflare/cloudflare-generated-token.png" alt="Generated API Token" />

    <Warning>
      Keep your API token secure and do not share it. Anyone with access to this token can manage your Cloudflare resources based on the permissions granted.
    </Warning>
  </Step>

  <Step title="Get Account ID">
    From your Cloudflare Account Home page, click on the account information dropdown and select **Copy account ID**.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/cloudflare/cloudflare-account-id.png" alt="Account ID" />

    Save your Account ID for use in the next step.
  </Step>
</Steps>

## Setup Cloudflare Connection in Infisical

<Steps>
  <Step title="Navigate to App Connections">
    Navigate to the **App Connections** page in the desired project. <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/general/add-connection.png" alt="App Connections
    Tab" />
  </Step>

  <Step title="Add Connection">
    Select the **Cloudflare Connection** option from the connection options
    modal. <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/cloudflare/cloudflare-app-connection-select.png" alt="Select Cloudflare
    Connection" />
  </Step>

  <Step title="Input Credentials">
    Enter your Cloudflare API token and Account ID in the provided fields and
    click **Connect to Cloudflare** to establish the connection. <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/cloudflare/cloudflare-app-connection-form.png" alt="Connect to
    Cloudflare" />
  </Step>

  <Step title="Connection Created">
    Your **Cloudflare Connection** is now available for use in your Infisical
    projects. <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/cloudflare/cloudflare-app-connection-created.png" alt="Cloudflare Connection
    Created" />
  </Step>
</Steps>

<Info>
  API token connections require manual token rotation when your Cloudflare API
  token expires or is regenerated. Monitor your connection status and update the
  token as needed.
</Info>


# Databricks Connection
Source: https://infisical.com/docs/integrations/app-connections/databricks

Learn how to configure a Databricks Connection for Infisical.

Infisical supports the use of [service principals](https://docs.databricks.com/en/admin/users-groups/service-principals.html) to connect with your Databricks workspaces.

## Configure a Service Principal for Infisical

<Steps>
  <Step title="Databricks Workspace Settings">
    Navigate to your Databricks Workspace **Settings** via the dropdown in the top right.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/databricks/workspace-settings.png" alt="Workspace Settings Page" />
  </Step>

  <Step title="Manage Service Principals">
    Under the **Identity & Access** tab, click the **Manage** button in the **Service Principals** section.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/databricks/manage-service-principals.png" alt="Manage Service Principals" />
  </Step>

  <Step title="Service Principal Management">
    Click the **Add Service Principal** button.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/databricks/add-service-principal.png" alt="Add Service Principal" />
  </Step>

  <Step title="Add Service Principal">
    Select the **Add New** option and create a service principal for Infisical.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/databricks/create-service-principal.png" alt="Create Service Principal" />
  </Step>

  <Step title="Generate Service Principal Secret">
    Click on your new service principal, select the **Secrets** tab and click the **Generate Secret** button.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/databricks/service-principal-secrets.png" alt="Generate Secret" />
  </Step>

  <Step title="Service Principal Secret">
    Copy your service principal **Secret** and **Client ID** for use in the following steps.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/databricks/service-principal-ids.png" alt="Generate Secret" />
  </Step>
</Steps>

## Setup Databricks Connection in Infisical

<Steps>
  <Step title="Navigate to App Connections">
    Navigate to the **App Connections** page in the desired project. <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/general/add-connection.png" alt="App Connections
    Tab" />
  </Step>

  <Step title="Add Connection">
    Select the **Databricks Connection** option from the connection options modal.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/databricks/select-databricks-connection.png" alt="Select Databricks
    Connection" />
  </Step>

  <Step title="Authorize Connection">
    Select the **Service Principal** method, add your **workspace URL** and **service principal credentials**, then click **Connect to
    Databricks**. <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/databricks/create-databricks-service-principal-method.png" alt="Connect via Databricks
    service principal" />
  </Step>

  <Step title="Connection Created">
    Your **Databricks Connection** is now available for use. <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/databricks/databricks-service-principal-connection.png" alt="Databricks Service Principal
    Connection" />
  </Step>
</Steps>


# DigitalOcean Connection
Source: https://infisical.com/docs/integrations/app-connections/digital-ocean

Learn how to configure a DigitalOcean Connection for Infisical.

Infisical supports the use of [API Tokens](https://cloud.digitalocean.com/account/api/tokens) to connect with DigitalOcean.

## Create a DigitalOcean API Token

<Steps>
  <Step title="From the bottom left sidebar, select 'API'">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/digital-ocean/app-connection-profile.png" alt="DigitalOcean Dashboard" />
  </Step>

  <Step title="In the API section, click on 'Generate New Token'">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/digital-ocean/app-connection-create-api-key.png" alt="API Section" />
  </Step>

  <Step title="Provide a name and select custom scopes">
    Give your token a descriptive name and ensure custom scopes is selected.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/digital-ocean/app-connection-create-form.png" alt="Token Form" />
  </Step>

  <Step title="Select appropriate scopes and Click 'Generate Token'">
    ```
      read:account
      read:actions
      read:regions
      read:sizes
      read:app/projects
      update:app
    ```

    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/digital-ocean/app-connection-create-form-roles.png" alt="Token Form" />
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/digital-ocean/app-connection-create-required-roles.png" alt="Token Form" />
  </Step>

  <Step title="Generate and copy the API token">
    Make sure to copy the token nowyou won't be able to see it again.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/digital-ocean/app-connection-key-generated.png" alt="Token Generated" />
  </Step>
</Steps>

## Create a DigitalOcean Connection in Infisical

<Tabs>
  <Tab title="Infisical UI">
    <Steps>
      <Step title="Navigate to App Connections">
        In your Infisical dashboard, navigate to the **App Connections** page in the desired project.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/general/add-connection.png" alt="App Connections Tab" />
      </Step>

      <Step title="Select DigitalOcean Connection">
        Click **+ Add Connection** and choose **DigitalOcean Connection** from the list of integrations.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/digital-ocean/app-connection-option.png" alt="Select DigitalOcean Connection" />
      </Step>

      <Step title="Fill out the DigitalOcean Connection form">
        Complete the form by providing:

        * A descriptive name for the connection
        * An optional description
        * The API Token from the previous step

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/digital-ocean/app-connection-form.png" alt="DigitalOcean Connection Modal" />
      </Step>

      <Step title="Connection created">
        After submitting the form, your **DigitalOcean Connection** will be successfully created and ready to use with your Infisical project.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/digital-ocean/app-connection-generated.png" alt="DigitalOcean Connection Created" />
      </Step>
    </Steps>
  </Tab>

  <Tab title="API">
    To create a DigitalOcean Connection via API, send a request to the [Create DigitalOcean Connection](/api-reference/endpoints/app-connections/digital-ocean/create) endpoint.

    ### Sample request

    ```bash Request theme={"dark"}
    curl    --request POST \
            --url https://app.infisical.com/api/v1/app-connections/digital-ocean \
            --header 'Content-Type: application/json' \
            --data '{
                "name": "my-digitalocean-connection",
                "method": "api-token",
                "projectId": "7ffbb072-2575-495a-b5b0-127f88caef78",
                "credentials": {
                    "apiToken": "[API TOKEN]"
                }
            }'
    ```

    ### Sample response

    ```bash Response theme={"dark"}
    {
      "appConnection": {
          "id": "a1b2c3d4-5678-90ab-cdef-1234567890ab",
          "name": "my-digitalocean-connection",
          "projectId": "7ffbb072-2575-495a-b5b0-127f88caef78",
          "description": null,
          "version": 1,
          "orgId": "abcdef12-3456-7890-abcd-ef1234567890",
          "createdAt": "2025-07-19T10:15:00.000Z",
          "updatedAt": "2025-07-19T10:15:00.000Z",
          "isPlatformManagedCredentials": false,
          "credentialsHash": "d41d8cd98f00b204e9800998ecf8427e",
          "app": "digital-ocean",
          "method": "api-token",
          "credentials": {}
      }
    }
    ```
  </Tab>
</Tabs>


# Fly.io Connection
Source: https://infisical.com/docs/integrations/app-connections/flyio

Learn how to configure a Fly.io Connection for Infisical.

Infisical supports the use of [Access Tokens](https://fly.io/docs/security/tokens/) to connect with Fly.io.

## Create Fly.io Access Token

<Steps>
  <Step title="Navigate to 'Access Tokens'">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/flyio/dashboard-page.png" alt="Dashboard Page" />
  </Step>

  <Step title="Click 'Create Token'">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/flyio/create-token.png" alt="Click Create Token" />
  </Step>

  <Step title="Provide Token Information">
    Ensure that you give this token access to the correct app, then click 'Create Token'.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/flyio/create-token-page.png" alt="Create Token Page" />
  </Step>

  <Step title="Save Token">
    After clicking 'Create Token', a modal containing your access token will appear. Save this token for later steps.
  </Step>
</Steps>

## Create Fly.io Connection in Infisical

<Tabs>
  <Tab title="Infisical UI">
    <Steps>
      <Step title="Navigate to App Connections">
        In your Infisical dashboard, navigate to the **App Connections** page in the desired project.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/general/add-connection.png" alt="App Connections Tab" />
      </Step>

      <Step title="Select Fly.io Connection">
        Click the **+ Add Connection** button and select the **Fly.io Connection** option from the available integrations.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/flyio/app-connection-option.png" alt="Select Fly.io Connection" />
      </Step>

      <Step title="Fill out the Fly.io Connection Modal">
        Complete the Fly.io Connection form by entering:

        * A descriptive name for the connection
        * An optional description for future reference
        * The Access Token from earlier steps

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/flyio/app-connection-modal.png" alt="Fly.io Connection Modal" />
      </Step>

      <Step title="Connection Created">
        After clicking Create, your **Fly.io Connection** is established and ready to use with your Infisical project.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/flyio/app-connection-created.png" alt="Fly.io Connection Created" />
      </Step>
    </Steps>
  </Tab>

  <Tab title="API">
    To create a Fly.io Connection, make an API request to the [Create Fly.io Connection](/api-reference/endpoints/app-connections/flyio/create) API endpoint.

    ### Sample request

    ```bash Request theme={"dark"}
    curl    --request POST \
            --url https://app.infisical.com/api/v1/app-connections/flyio \
            --header 'Content-Type: application/json' \
            --data '{
                "name": "my-flyio-connection",
                "method": "access-token",
                "projectId": "7ffbb072-2575-495a-b5b0-127f88caef78",
                "credentials": {
                    "accessToken": "[PRIVATE TOKEN]"
                }
            }'
    ```

    ### Sample response

    ```bash Response theme={"dark"}
    {
      "appConnection": {
          "id": "e5d18aca-86f7-4026-a95e-efb8aeb0d8e6",
          "name": "my-flyio-connection",
          "projectId": "7ffbb072-2575-495a-b5b0-127f88caef78",
          "description": null,
          "version": 1,
          "orgId": "6f03caa1-a5de-43ce-b127-95a145d3464c",
          "createdAt": "2025-04-23T19:46:34.831Z",
          "updatedAt": "2025-04-23T19:46:34.831Z",
          "isPlatformManagedCredentials": false,
          "credentialsHash": "7c2d371dec195f82a6a0d5b41c970a229cfcaf88e894a5b6395e2dbd0280661f",
          "app": "flyio",
          "method": "access-token",
          "credentials": {}
      }
    }
    ```
  </Tab>
</Tabs>


# GCP Connection
Source: https://infisical.com/docs/integrations/app-connections/gcp

Learn how to configure a GCP Connection for Infisical.

Infisical supports [service account impersonation](https://cloud.google.com/iam/docs/service-account-impersonation) to connect with your GCP projects.

<Accordion title="Self-Hosted Instance">
  Using the GCP integration on a self-hosted instance of Infisical requires configuring a service account on GCP and
  configuring your instance to use it.

  <Steps>
    <Step title="Enable the IAM Service Account Credentials API">
            <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/gcp/service-account-credentials-api.png" alt="Service Account API" />
    </Step>

    <Step title="Navigate to IAM & Admin > Service Accounts in Google Cloud Console">
            <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/gcp/service-account-overview.png" alt="Service Account IAM Page" />
    </Step>

    <Step title="Create a Service Account">
      Create a new service account that will be used to impersonate other GCP service accounts for your app connections.
      <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/gcp/create-instance-service-account.png" alt="Create Service Account Page" />

      Press "DONE" after creating the service account.
    </Step>

    <Step title="Generate Service Account Key">
      Download the JSON key file for your service account. This will be used to authenticate your instance with GCP.
      <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/gcp/create-service-account-credential.png" alt="Service Account Credential Page" />
    </Step>

    <Step title="Configure Your Instance">
      1. Copy the entire contents of the downloaded JSON key file.
      2. Set it as a string value for the `INF_APP_CONNECTION_GCP_SERVICE_ACCOUNT_CREDENTIAL` environment variable.
      3. Restart your Infisical instance to apply the changes.
      4. You can now use GCP integration with service account impersonation.
    </Step>
  </Steps>
</Accordion>

## Configure Service Account for Infisical

<Steps>
  <Step title="Navigate to IAM & Admin > Service Accounts in Google Cloud Console">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/gcp/service-account-overview.png" alt="Service Account Page" />
  </Step>

  <Step title="Create Service Account">
    Create a new service account with an ID that follows this requirement:

    Your service account ID must end with the first two sections of your Infisical organization ID.

    Example:

    * Infisical organization ID: `df92581a-0fe9-42b5-b526-0a1e88ec8085`
    * Required service account ID suffix: `df92581a-0fe9`

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/gcp/create-service-account.png" alt="Create Service Account" />
  </Step>

  <Step title="Configure Service Account Permissions">
    <Tabs>
      <Tab title="Secret Sync">
        Add the required permissions for secret syncs:
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/gcp/service-account-secret-sync-permission.png" alt="Assign Service Account Permission" />
      </Tab>
    </Tabs>

    After configuring the appropriate roles, press "DONE".
  </Step>

  <Step title="Enable Service Account Impersonation">
    To enable service account impersonation, you'll need to grant the **Service Account Token Creator** role to the Infisical instance's service account. This configuration allows Infisical to securely impersonate the new service account.

    * Navigate to the IAM & Admin > Service Accounts section in your Google Cloud Console
    * Select the newly created service account
    * Click on the "PERMISSIONS" tab
    * Click "Grant Access" to add a new principal

    If you're using Infisical Cloud US, use the following service account: [infisical-us@infisical-us.iam.gserviceaccount.com](mailto:infisical-us@infisical-us.iam.gserviceaccount.com)

    If you're using Infisical Cloud EU, use the following service account: [infisical-eu@infisical-eu.iam.gserviceaccount.com](mailto:infisical-eu@infisical-eu.iam.gserviceaccount.com)

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/gcp/service-account-grant-access.png" alt="Service Account Page" />
  </Step>
</Steps>

## Setup GCP Connection in Infisical

<Steps>
  <Step title="Navigate to App Connections">
    Navigate to the **App Connections** page in the desired project. <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/general/add-connection.png" alt="App Connections
    Tab" />
  </Step>

  <Step title="Add Connection">
    Select the **GCP Connection** option from the connection options modal.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/gcp/select-gcp-connection.png" alt="Select GCP
    Connection" />
  </Step>

  <Step title="Authorize Connection">
    Select the **Service Account Impersonation** method and click **Connect to
    GCP**. <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/gcp/create-gcp-impersonation-method.png" alt="Connect via GCP
    impersonation" />
  </Step>

  <Step title="Connection Created">
    Your **GCP Connection** is now available for use. <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/gcp/gcp-app-impersonation-connection.png" alt="Impersonation GCP
    Connection" />
  </Step>
</Steps>


# GitHub Connection
Source: https://infisical.com/docs/integrations/app-connections/github

Learn how to configure a GitHub Connection for Infisical.

Infisical supports three methods for connecting to GitHub.

<Tabs>
  <Tab title="GitHub App (Recommended)">
    Infisical will use a GitHub App with finely grained permissions to connect to GitHub.

    <Accordion title="Self-Hosted Instance">
      Using the GitHub integration with app authentication on a self-hosted instance of Infisical requires configuring an application on GitHub
      and registering your instance with it.

      <Steps>
        <Step title="Create an application on GitHub">
          Navigate to the GitHub app settings [here](https://github.com/settings/apps). Click **New GitHub App**.

                    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/github/app/self-hosted-github-app-create.png" alt="integrations github app create" />

          Give the application a name, a homepage URL (your self-hosted domain i.e. `https://your-domain.com`), and a callback URL (i.e. `https://your-domain.com/organization/app-connections/github/oauth/callback`).

                    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/github/app/self-hosted-github-app-basic-details.png" alt="integrations github app basic details" />

          Enable request user authorization during app installation.
          <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/github/app/self-hosted-github-app-enable-oauth.png" alt="integrations github app enable auth" />

          Disable webhook by unchecking the Active checkbox.
          <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/github/app/self-hosted-github-app-webhook.png" alt="integrations github app webhook" />

          Set the repository permissions as follows: Metadata: Read-only, Secrets: Read and write, Environments: Read and write, Actions: Read.
          <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/github/app/self-hosted-github-app-repository.png" alt="integrations github app repository" />

          Similarly, set the organization permissions as follows: Secrets: Read and write.
          <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/github/app/self-hosted-github-app-organization.png" alt="integrations github app organization" />

          Create the Github application.
          <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/github/app/self-hosted-github-app-create-confirm.png" alt="integrations github app create confirm" />

          <Note>
            If you have a GitHub organization, you can create an application under it
            in your organization Settings > Developer settings > GitHub Apps > New GitHub App.
          </Note>
        </Step>

        <Step title="Add your application credentials to Infisical">
          Generate a new **Client Secret** for your GitHub application.
          <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/github/app/self-hosted-github-app-secret.png" alt="integrations github app create secret" />

          Generate a new **Private Key** for your Github application.
          <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/github/app/self-hosted-github-app-private-key.png" alt="integrations github app create private key" />

          Obtain the necessary Github application credentials. This would be the application slug, client ID, app ID, client secret, and private key.
          <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/github/app/self-hosted-github-app-credentials.png" alt="integrations github app credentials" />

          Back in your Infisical instance, you can configure the GitHub App credentials in one of two ways:

          **Option 1: Server Admin Panel (Recommended)**

          Navigate to the server admin panel > **Integrations** > **GitHub App** and enter the GitHub application credentials:
          <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/github/app/self-hosted-github-app-admin-panel.png" alt="integrations github app admin panel" />

          * **Client ID**: The Client ID of your GitHub application
          * **Client Secret**: The Client Secret of your GitHub application
          * **App Slug**: The Slug of your GitHub application (found in the URL)
          * **App ID**: The App ID of your GitHub application
          * **Private Key**: The Private Key of your GitHub application

          **Option 2: Environment Variables**

          Alternatively, you can add the new environment variables for the credentials of your GitHub application:

          * `INF_APP_CONNECTION_GITHUB_APP_CLIENT_ID`: The **Client ID** of your GitHub application.
          * `INF_APP_CONNECTION_GITHUB_APP_CLIENT_SECRET`: The **Client Secret** of your GitHub application.
          * `INF_APP_CONNECTION_GITHUB_APP_SLUG`: The **Slug** of your GitHub application. This is the one found in the URL.
          * `INF_APP_CONNECTION_GITHUB_APP_ID`: The **App ID** of your GitHub application.
          * `INF_APP_CONNECTION_GITHUB_APP_PRIVATE_KEY`: The **Private Key** of your GitHub application.

          Once configured, you can use the GitHub integration via app authentication. If you configured the credentials using environment variables, restart your Infisical instance for the changes to take effect. If you configured them through the server admin panel, allow approximately 5 minutes for the changes to propagate.
        </Step>
      </Steps>
    </Accordion>

    ## Setup GitHub Connection in Infisical

    <Steps>
      <Step title="Navigate to App Connections">
        Navigate to the **App Connections** page in the desired project.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/general/add-connection.png" alt="App Connections Tab" />
      </Step>

      <Step title="Add Connection">
        Select the **GitHub Connection** option from the connection options modal.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/github/select-github-connection.png" alt="Select GitHub Connection" />
      </Step>

      <Step title="Authorize Connection">
        Select the **GitHub App** method and click **Connect to GitHub**.

        You may optionally configure GitHub Enterprise options:

        * **Gateway:** The gateway connected to your private network
        * **Hostname:** The hostname at which to access your GitHub Enterprise instance

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/github/create-github-app-method.png" alt="Connect via GitHub App" />
      </Step>

      <Step title="Install GitHub App">
        You will then be redirected to the GitHub app installation page.

        Install and authorize the GitHub application. This will redirect you back to Infisical's App Connections page.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/github/install-github-app.png" alt="Install GitHub App" />
      </Step>

      <Step title="Connection Created">
        Your **GitHub Connection** is now available for use.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/github/github-app-connection.png" alt="Assume Role AWS Connection" />
      </Step>
    </Steps>
  </Tab>

  <Tab title="OAuth">
    Infisical will use an OAuth App to connect to GitHub.

    <Accordion title="Self-Hosted Instance">
      Using the GitHub integration on a self-hosted instance of Infisical requires configuring an OAuth application in GitHub
      and registering your instance with it.

      <Steps>
        <Step title="Create an OAuth application in GitHub">
          Navigate to your user Settings > Developer settings > OAuth Apps to create a new GitHub OAuth application.

          <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/github/integrations-github-config-settings.png" alt="integrations github config" />
          <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/github/integrations-github-config-dev-settings.png" alt="integrations github config" />
          <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/github/integrations-github-config-new-app.png" alt="integrations github config" />

          Create the OAuth application. As part of the form, set the **Homepage URL** to your self-hosted domain `https://your-domain.com`
          and the **Authorization callback URL** to `https://your-domain.com/organization/app-connections/github/oauth/callback`.

                    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/github/integrations-github-config-new-app-form.png" alt="integrations github config" />

          <Note>
            If you have a GitHub organization, you can create an OAuth application under it
            in your organization Settings > Developer settings > OAuth Apps > New Org OAuth App.
          </Note>
        </Step>

        <Step title="Add your OAuth application credentials to Infisical">
          Obtain the **Client ID** and generate a new **Client Secret** for your GitHub OAuth application.

                    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/github/integrations-github-config-credentials.png" alt="integrations github config" />

          Back in your Infisical instance, add two new environment variables for the credentials of your GitHub OAuth application:

          * `INF_APP_CONNECTION_GITHUB_OAUTH_CLIENT_ID`: The **Client ID** of your GitHub OAuth application.
          * `INF_APP_CONNECTION_GITHUB_OAUTH_CLIENT_SECRET`: The **Client Secret** of your GitHub OAuth application.

          Once added, restart your Infisical instance and use the GitHub integration.
        </Step>
      </Steps>
    </Accordion>

    ## Setup GitHub Connection in Infisical

    <Steps>
      <Step title="Navigate to App Connections">
        Navigate to the **App Connections** page in the desired project.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/general/add-connection.png" alt="App Connections Tab" />
      </Step>

      <Step title="Add Connection">
        Select the **GitHub Connection** option from the connection options modal.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/github/select-github-connection.png" alt="Select GitHub Connection" />
      </Step>

      <Step title="Authorize Connection">
        Select the **OAuth** method and click **Connect to GitHub**.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/github/create-oauth-method.png" alt="Connect via GitHub App" />
      </Step>

      <Step title="Grant Access">
        You will then be redirected to the GitHub to grant Infisical access to your GitHub account (organization and repo privileges).
        Once granted, you will redirect you back to Infisical's App Connections page.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/github/integrations-github-auth.png" alt="GitHub Authorization" />
      </Step>

      <Step title="Connection Created">
        Your **GitHub Connection** is now available for use.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/github/oauth-connection.png" alt="Assume Role AWS Connection" />
      </Step>
    </Steps>
  </Tab>

  <Tab title="Personal Access Token">
    Infisical will use a Personal Access Token to connect to GitHub.

    ## Create a Personal Access Token

    <Steps>
      <Step title="Create a Personal Access Token in GitHub">
        Navigate to your user Settings > Developer settings > Personal Access Tokens to create a new Personal Access Token.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/github/integrations-github-config-settings.png" alt="integrations github config" />
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/github/integrations-github-config-dev-settings.png" alt="integrations github config" />
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/github/integrations-github-config-new-pat.png" alt="integrations github config" />

        Click **Generate new token** to create the token.
      </Step>

      <Step title="Fill in the Personal Access Token details">
        Fill in the Personal Access Token details:

        * **Token name:** A descriptive name for the token (e.g., "infisical-connection-token")
        * **Repository access:** Select the repositories you want to grant access to
          * Select `All repositories` or `Only selected repositories` to be able to manage the secrets in the selected repositories.
        * **Select scopes:** Add the following scopes:
          * **Metadata**: Read-only
          * **Environments**: Read and write
          * **Secrets**: Read and write

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/github/create-pat-form.png" alt="Personal Access Token Form" />

        Click **Generate token** to create the token.
      </Step>

      <Step title="Copy the Personal Access Token">
        Copy the generated token immediately as it won't be shown again.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/github/create-pat-token-generated.png" alt="Personal Access Token Generated" />

        <Warning>
          Keep your Personal Access Token secure and do not share it. Anyone with access to this token can access your GitHub account and repositories.
        </Warning>
      </Step>
    </Steps>

    ## Setup GitHub Connection in Infisical

    <Steps>
      <Step title="Navigate to App Connections">
        Navigate to the **App Connections** page in the desired project.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/general/add-connection.png" alt="App Connections Tab" />
      </Step>

      <Step title="Add Connection">
        Select the **GitHub Connection** option from the connection options modal.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/github/select-github-connection.png" alt="Select GitHub Connection" />
      </Step>

      <Step title="Authorize Connection">
        Select the **Personal Access Token** method and fill in the **Personal Access Token** field with your Personal Access Token.

        You may optionally configure GitHub Enterprise options:

        * **Gateway:** The gateway connected to your private network
        * **Hostname:** The hostname at which to access your GitHub Enterprise instance

        Click **Create Connection**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/github/create-pat-method.png" alt="Personal Access Token" />
      </Step>

      <Step title="Connection Created">
        Your **GitHub Connection** is now available for use.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/github/pat-connection.png" alt="Personal Access Token Connection" />
      </Step>
    </Steps>
  </Tab>
</Tabs>


# GitHub Radar Connection
Source: https://infisical.com/docs/integrations/app-connections/github-radar

Learn how to configure a GitHub Radar Connection for Infisical.

Infisical supports GitHub App installation for creating a GitHub Radar Connection.

<Note>
  GitHub Radar Connections are specifically configured for [Secret Scanning](/documentation/platform/secret-scanning/overview) and require specific permissions and webhook configuration.

  Check out our [GitHub Connection](/integrations/app-connections/github) for secret management features such as [Secret Syncs](/integrations/secret-syncs/overview).
</Note>

<Accordion title="Self-Hosted Instance">
  Using a GitHub Radar Connection with app authentication on a self-hosted instance of Infisical requires configuring an application on GitHub
  and registering your instance with it.

  <Steps>
    <Step title="Create an application on GitHub">
      Navigate to the GitHub App Settings [here](https://github.com/settings/apps). Click **New GitHub App**.

      <Note>
        If you have a GitHub organization, you can create an application under it
        in your organization Settings > Developer settings > GitHub Apps > New GitHub App.
      </Note>

            <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/github-radar/self-hosted-github-radar-step-1.png" alt="create github radar app" />

      Configure the following fields:

      1. **Name** - give your app a name
      2. **Homepage URL** - your self-hosted domain (i.e. `https://your-domain.com`)
      3. **Callback URL** - the callback URL for your domain (i.e. `https://your-domain.com/organization/app-connections/github-radar/oauth/callback`)
      4. **User Authorization** - enable request user authorization on app installation

            <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/github-radar/self-hosted-github-radar-step-2.png" alt="github radar app details" />

      Enable and configure the Webhook fields:

      * **Webhook URL** - the webhook URL for your domain (i.e. `https://your-domain.com/secret-scanning/webhooks/github`)
      * **Webhook Secret** - a strong, generated secret to verify webhook payloads
      * **SSL Verification** - enable SSL verification

            <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/github-radar/self-hosted-github-radar-step-3.png" alt="github radar app webhook" />

      Set the following repository permissions:

      * **Contents**: `Read-only`
      * **Metadata**: `Read-only`

      <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/github-radar/self-hosted-github-radar-step-4.png" alt="github radar app permissions 1" />
      <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/github-radar/self-hosted-github-radar-step-5.png" alt="github radar app permissions 2" />

      Subscribe to the following events:

      * **Push**

            <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/github-radar/self-hosted-github-radar-step-6.png" alt="github radar app events" />

      Create the Github application.
      <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/github-radar/self-hosted-github-radar-step-7.png" alt="github radar app complete" />
    </Step>

    <Step title="Add your application credentials to Infisical">
      Generate a new **Client Secret** for your GitHub application.
      <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/github-radar/self-hosted-github-radar-step-8.png" alt="github radar app client secret" />

      Generate a new **Private Key** for your Github application.

      <Info>You will need to copy the contents of the .pem file downloaded</Info>

            <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/github-radar/self-hosted-github-radar-step-9.png" alt="github radar app private key" />

      Obtain the following credentials:

      1. **Slug** - the slug of your application found in the URL
      2. **App ID** - the ID of your application
      3. **Client ID** - the client ID of your application
      4. **Client Secret** - the client secret generated above
      5. **Private Key** - the contents of the private key .pem file generated above
      6. **Webhook Secret** - the secret generated in the previous step when configuring the webhook

            <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/github-radar/self-hosted-github-radar-step-10.png" alt="github radar app credentials" />

      Back in your Infisical instance, add the six new environment variables for the credentials of your GitHub Radar application:

      * `INF_APP_CONNECTION_GITHUB_RADAR_APP_CLIENT_ID`: The **Client ID** of your GitHub application.
      * `INF_APP_CONNECTION_GITHUB_RADAR_APP_CLIENT_SECRET`: The **Client Secret** of your GitHub application.
      * `INF_APP_CONNECTION_GITHUB_RADAR_APP_SLUG`: The **Slug** of your GitHub application. This is the one found in the URL.
      * `INF_APP_CONNECTION_GITHUB_RADAR_APP_ID`: The **App ID** of your GitHub application.
      * `INF_APP_CONNECTION_GITHUB_RADAR_APP_PRIVATE_KEY`: The **Private Key** of your GitHub application.
      * `INF_APP_CONNECTION_GITHUB_RADAR_APP_WEBHOOK_SECRET`: The **Webhook Secret** of your GitHub application.

      Once added, restart your Infisical instance and use the GitHub integration via app authentication.
    </Step>
  </Steps>
</Accordion>

## Setup GitHub Radar Connection in Infisical

<Steps>
  <Step title="Navigate to App Connections">
    Navigate to the **App Connections** page in the desired project.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/general/add-connection.png" alt="App Connections Tab" />
  </Step>

  <Step title="Add Connection">
    Select the **GitHub Radar Connection** option from the connection options modal.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/github-radar/select-github-radar-connection.png" alt="Select GitHub Radar Connection" />
  </Step>

  <Step title="Authorize Connection">
    Select the **GitHub App** method and click **Connect to GitHub**.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/github-radar/create-github-radar-app-method.png" alt="Connect via GitHub App" />
  </Step>

  <Step title="Install GitHub App">
    You will then be redirected to the GitHub App installation page.

    Install and authorize the GitHub application. This will redirect you back to Infisical's App Connections page.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/github-radar/github-radar-authorize.png" alt="Install GitHub App" />
  </Step>

  <Step title="Connection Created">
    Your **GitHub Radar Connection** is now available for use.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/github-radar/github-radar-app-created.png" alt="GitHub Radar Connection" />
  </Step>
</Steps>


# GitLab Connection
Source: https://infisical.com/docs/integrations/app-connections/gitlab

Learn how to configure a GitLab Connection for Infisical using OAuth or Access Token methods.

Infisical supports two methods for connecting to GitLab: **OAuth** and **Access Token**. Choose the method that best fits your setup and security requirements.

<Tabs>
  <Tab title="OAuth Method">
    The OAuth method provides secure authentication through GitLab's OAuth flow.

    <Accordion title="Self-Hosted Instance Setup">
      Using the GitLab Connection with OAuth on a self-hosted instance of Infisical requires configuring an OAuth application in GitLab and registering your instance with it.

      **Prerequisites:**

      * A GitLab account with existing projects
      * Self-hosted Infisical instance

      <Steps>
        <Step title="Create an OAuth application in GitLab">
          Navigate to your user Settings > Applications to create a new GitLab application.

          <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/gitlab/gitlab-dashboard.png" alt="GitLab Dashboard" />
          <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/gitlab/gitlab-applications.png" alt="GitLab Applications Settings" />

          Create the application. As part of the form, set the **Redirect URI** to `https://your-domain.com/organization/app-connections/gitlab/oauth/callback`.

          Depending on your use case, add one or more of the following scopes to your application:

          <Tabs>
            <Tab title="Secret Sync">
              For Secret Syncs, your application will require the `api` scope:

              <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/gitlab/gitlab-create-application-top-secret-sync.png" alt="GitLab New Application Form" />
              <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/gitlab/gitlab-create-application-bottom-secret-sync.png" alt="GitLab New Application Form" />
            </Tab>

            <Tab title="Secret Scanning">
              For Secret Scanning, your application will require the `api` and `read_repository` scopes:

              <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/gitlab/gitlab-create-application-top-secret-scanning.png" alt="GitLab New Application Form" />
              <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/gitlab/gitlab-create-application-bottom-secret-scanning.png" alt="GitLab New Application Form" />
            </Tab>
          </Tabs>

          <Tip>
            The domain you defined in the Redirect URI should be equivalent to the `SITE_URL` configured in your Infisical instance.
          </Tip>

          <Note>
            If you have a GitLab group, you can create an OAuth application under it in your group Settings > Applications.
          </Note>
        </Step>

        <Step title="Add your GitLab OAuth application credentials to Infisical">
          Obtain the **Application ID** and **Secret** for your GitLab OAuth application.

                    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/gitlab/gitlab-config-credentials.png" alt="GitLab Application Credentials" />

          Back in your Infisical instance, add two new environment variables for the credentials of your GitLab OAuth application:

          * `INF_APP_CONNECTION_GITLAB_OAUTH_CLIENT_ID`: The **Application ID** of your GitLab OAuth application.
          * `INF_APP_CONNECTION_GITLAB_OAUTH_CLIENT_SECRET`: The **Secret** of your GitLab OAuth application.

          Once added, restart your Infisical instance and use the GitLab Connection.
        </Step>
      </Steps>
    </Accordion>

    ## Setup GitLab OAuth Connection in Infisical

    <Steps>
      <Step title="Navigate to App Connections">
        Navigate to the **App Connections** page in the desired project.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/general/add-connection.png" alt="App Connections Tab" />
      </Step>

      <Step title="Add Connection">
        Select the **GitLab Connection** option from the connection options modal.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/gitlab/select-gitlab-connection.png" alt="Select GitLab Connection" />
      </Step>

      <Step title="Choose OAuth Method">
        Select the **OAuth** method and click **Connect to GitLab**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/gitlab/create-gitlab-oauth-connection.png" alt="Connect via GitLab OAuth" />
      </Step>

      <Step title="Grant Access">
        You will be redirected to GitLab to grant Infisical access to your GitLab account. Once granted, you will be redirected back to Infisical's App Connections page.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/gitlab/gitlab-authorization-page.png" alt="GitLab Authorization" />
      </Step>

      <Step title="Connection Created">
        Your **GitLab Connection** is now available for use.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/gitlab/gitlab-oauth-connection.png" alt="GitLab OAuth Connection" />
      </Step>
    </Steps>
  </Tab>

  <Tab title="Access Token Method">
    The Access Token method uses a GitLab access token for authentication, providing a straightforward setup process.

    ## Generate GitLab Access Token

    <Tabs>
      <Tab title="Personal Access Token">
        Personal access tokens provide access to your GitLab account and all projects you have access to.

        <Steps>
          <Step title="Navigate to Access Tokens">
            Log in to your GitLab account and navigate to User Settings > Access tokens. Click **Add new token** to create a new personal access token.

                        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/gitlab/gitlab-add-access-token.png" alt="GitLab Personal Access Tokens" />
          </Step>

          <Step title="Configure Token">
            Fill in the token details:

            * **Token name**: A descriptive name for the token (e.g., "connection-token")
            * **Expiration date**: Set an appropriate expiration date
            * **Select scopes**: Depending on your use case, add one or more of the following scopes:

            <Tabs>
              <Tab title="Secret Sync">
                For Secret Syncs, your token will require the `api` scope:

                                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/gitlab/gitlab-personal-access-token-form-secret-sync.png" alt="GitLab Personal Token Form" />
              </Tab>

              <Tab title="Secret Scanning">
                For Secret Scanning, your token will require the `api` and `read_repository` scopes:

                                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/gitlab/gitlab-personal-access-token-form-secret-scanning.png" alt="GitLab Personal Token Form" />
              </Tab>
            </Tabs>

            <Info>
              Personal Access Token connections require manual token rotation when your GitLab access token expires or is regenerated. Monitor your connection status and update the token as needed.
            </Info>
          </Step>

          <Step title="Copy Token">
            Copy the generated token immediately as it won't be shown again.

                        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/gitlab/gitlab-copy-token.png" alt="GitLab Personal Token Created" />

            <Warning>
              Keep your access token secure and do not share it. Anyone with access to this token can access your GitLab account and projects.
            </Warning>
          </Step>
        </Steps>
      </Tab>

      <Tab title="Project Access Token">
        Project access tokens provide access to a specific GitLab project, offering more granular control.

        <Steps>
          <Step title="Navigate to Project Settings">
            Go to your GitLab project and navigate to Settings > Access Tokens. Click **Add new token** to create a new project access token.

                        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/gitlab/gitlab-project-access-token-list.png" alt="GitLab Project Access Tokens" />
          </Step>

          <Step title="Configure Token">
            Fill in the token details:

            * **Token name**: A descriptive name for the token
            * **Expiration date**: Set an appropriate expiration date
            * **Select role and scopes**: Depending on your use case, add the required role and one or more of the following scopes:

            <Tabs>
              <Tab title="Secret Sync">
                For Secret Syncs, your token will require the `api` scope and at least the **Owner** role:

                                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/gitlab/gitlab-project-access-token-form-secret-sync.png" alt="GitLab Create Project Token" />
              </Tab>

              <Tab title="Secret Scanning">
                For Secret Scanning, your token will require the `api` and `read_repository` scopes and the **Maintainer** role:

                                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/gitlab/gitlab-project-access-token-form-secret-scanning.png" alt="GitLab Create Project Token" />
              </Tab>
            </Tabs>

            <Info>
              Project Access Token connections require manual token rotation when your GitLab access token expires or is regenerated. Monitor your connection status and update the token as needed.
            </Info>
          </Step>

          <Step title="Copy Token">
            Copy the generated token immediately as it won't be shown again.

                        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/gitlab/gitlab-project-access-token-created.png" alt="GitLab Project Token Form" />

            <Warning>
              Keep your access token secure and do not share it. Anyone with access to this token can access your GitLab account and projects.
            </Warning>
          </Step>
        </Steps>
      </Tab>

      <Tab title="Group Access Token">
        Group access tokens provide access to all projects within a GitLab group, offering group-level control.

        <Steps>
          <Step title="Navigate to Group Settings">
            Go to your GitLab group and navigate to Settings > Access Tokens. Click **Add new token** to create a new group access token.
            <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/gitlab/gitlab-group-access-token-list.png" alt="GitLab Group Access Tokens" />
          </Step>

          <Step title="Configure Token">
            Fill in the token details:

            * **Token name**: A descriptive name for the token
            * **Expiration date**: Set an appropriate expiration date
            * **Select role and scopes**: Depending on your use case, add the required role and one or more of the following scopes:

            <Tabs>
              <Tab title="Secret Sync">
                For Secret Syncs, the required role depends on your sync destination:

                * **Project variables**: Requires **Maintainer** role or higher
                * **Group variables**: Requires **Owner** role

                Your token will require the `api` scope.

                                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/gitlab/gitlab-group-access-token-form-secret-sync.png" alt="GitLab Create Group Token" />

                Click **Create group access token** to create the token.

                <Note>
                  Use the **Owner** role if you need to sync to group-level variables. The **Maintainer** role is sufficient only for project-level variables.
                </Note>
              </Tab>

              <Tab title="Secret Scanning">
                To set up Secret Scanning, the required permissions depend on the data source level:

                * **Project-level data source:** Requires **Maintainer** role or higher
                * **Group-level data source:** Requires **Owner** role

                Your token will require the `api` scope.

                                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/gitlab/gitlab-group-access-token-form-secret-sync.png" alt="GitLab Create Group Token" />

                Click **Create group access token** to create the token.
              </Tab>
            </Tabs>

            <Info>
              Group Access Token connections require manual token rotation when your GitLab access token expires or is regenerated. Monitor your connection status and update the token as needed.
            </Info>
          </Step>

          <Step title="Copy Token">
            Copy the generated token immediately as it won't be shown again.
            <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/gitlab/gitlab-group-access-token-created.png" alt="GitLab Group Token Created" />

            <Warning>
              Keep your access token secure and do not share it. Anyone with access to this token can access all projects within your GitLab group.
            </Warning>
          </Step>
        </Steps>
      </Tab>
    </Tabs>

    ## Setup GitLab Access Token Connection in Infisical

    <Steps>
      <Step title="Navigate to App Connections">
        Navigate to the **App Connections** page in the desired project.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/general/add-connection.png" alt="App Connections Tab" />
      </Step>

      <Step title="Add Connection">
        Select the **GitLab Connection** option from the connection options modal.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/gitlab/select-gitlab-connection.png" alt="Select GitLab Connection" />
      </Step>

      <Step title="Configure Access Token">
        Select the **Access Token** method, paste your GitLab access token in the provided field, and select the appropriate token type.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/gitlab/create-gitlab-access-token-connection.png" alt="Configure Access Token" />

        Click **Connect** to establish the connection.
      </Step>

      <Step title="Connection Created">
        Your **GitLab Connection** is now available for use.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/gitlab/gitlab-access-token-connection.png" alt="GitLab Access Token Connection" />
      </Step>
    </Steps>
  </Tab>
</Tabs>


# Hashicorp Vault Connection
Source: https://infisical.com/docs/integrations/app-connections/hashicorp-vault

Learn how to configure a Hashicorp Vault Connection for Infisical.

<Note>
  Infisical is compatible with Vault Self-hosted, HCP Vault Dedicated, and HCP Vault Enterprise deployments. Please note that HCP Generic Secrets are currently not supported.
</Note>

Infisical supports two methods for connecting to Hashicorp Vault.

<Tabs>
  <Tab title="App Role (Recommended)">
    <Steps>
      <Step title="Navigate to Vault Access">
                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/hashicorp-vault/vault-access.png" alt="Vault Access" />
      </Step>

      <Step title="Enable New Method">
        In the **Authentication Methods** tab, click on **Enable new method**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/hashicorp-vault/vault-authentication-methods.png" alt="Vault Enable Method" />
      </Step>

      <Step title="Select AppRole">
                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/hashicorp-vault/vault-approle.png" alt="Vault AppRole" />
      </Step>

      <Step title="Enable Method">
        You may change the name of the method, but we suggest keeping it as `approle`.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/hashicorp-vault/vault-enable-method.png" alt="Vault Enable Method" />
      </Step>

      <Step title="Navigate to Vault Policies">
        From the home page, navigate to **Policies**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/hashicorp-vault/vault-policies-navigate.png" alt="Vault Policies Navigate" />
      </Step>

      <Step title="Create ACL Policy">
                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/hashicorp-vault/vault-policies-page.png" alt="Vault Policies Page" />
      </Step>

      <Step title="Create Policy">
        You may name your policy whatever you want, but remember the name as it will be used in future steps.

        Depending on your use case, you may have different policy configurations:

        <Tabs>
          <Tab title="Secret Sync">
            ```hcl  theme={"dark"}
            path "demo_mount/data/*" {
              capabilities = [ "create", "read", "update" ]
            }

            path "sys/mounts" {
              capabilities = ["read"]
            }
            ```

            * **demo\_mount**: The name of the target secrets engine (e.g., 'secret', 'kv').
            * **data/\***: The path within the secrets engine used for storing secrets. The wildcard (\*) grants access to all secrets within this mount point.

            <Note>
              Make sure to replace the policy path with the specific path where you intend to sync your secrets. For better security and control, it's recommended to use a more granular path instead of a wildcard (\*). You can also specify a path that doesnt yet existInfisical will automatically create it for you during the sync process.
            </Note>
          </Tab>
        </Tabs>

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/hashicorp-vault/vault-create-policy.png" alt="Vault Create Policy" />
      </Step>

      <Step title="Run Shell Commands">
        **Open Vault Shell**

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/hashicorp-vault/vault-shell.png" alt="Vault Shell" />

        <Note>
          If you used custom approle or policy names in previous steps, you'll need to customize the following commands.
        </Note>

        **Create Infisical Role**

        ```hcl  theme={"dark"}
        vault write auth/approle/role/infisical token_policies="infisical-policy" token_ttl=30s token_max_ttl=2m
        ```

        **Read RoleID**

        ```hcl  theme={"dark"}
        vault read auth/approle/role/infisical/role-id
        ```

        **Generate New SecretID**

        ```hcl  theme={"dark"}
        vault write -force auth/approle/role/infisical/secret-id
        ```

        Your shell output should look similar to the image below. Save the RoleID and SecretID values for later steps.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/hashicorp-vault/vault-shell-output.png" alt="Vault Shell Output" />
      </Step>
    </Steps>
  </Tab>

  <Tab title="Access Token">
    ## Get a Hashicorp Vault Access Token

    Open your profile dropdown and click **Copy token**. This token will be used in later steps.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/hashicorp-vault/vault-profile-token.png" alt="Vault Profile Copy Token" />
  </Tab>
</Tabs>

## Getting Vault Instance URL

<Tabs>
  <Tab title="Self Hosted">
    For self-hosted instances, locate and copy your vault's base URL (for example: `https://vault.example.com`).

    Save the URL for later steps.
  </Tab>

  <Tab title="Hashicorp Cloud Platform">
    On HCP instances, you may need to navigate to **Cluster Overview** to see your cluster URL. Save this value for later steps.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/hashicorp-vault/vault-cluster-urls.png" alt="Vault Cluster URLs" />

    <Note>
      Cluster Overview is found in the HCP dashboard, not in your cluster's web UI.
    </Note>
  </Tab>
</Tabs>

## Setup Vault Connection in Infisical

<Tabs>
  <Tab title="Infisical UI">
    <Steps>
      <Step title="Navigate to App Connections">
        In your Infisical dashboard, navigate to the **App Connections** page in the desired project.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/general/add-connection.png" alt="App Connections Tab" />
      </Step>

      <Step title="Add Connection">
        Click the **+ Add Connection** button and select the **Hashicorp Vault Connection** option.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/hashicorp-vault/vault-infisical-connect-page.png" alt="Select Vault Connection" />
      </Step>

      <Step title="Configure Connection">
        Configure your Vault Connection using the Instance URL and credentials from the steps above. **Depending on if you chose to authenticate with an Access Token or AppRole, you may need to input different information.**

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/hashicorp-vault/vault-infisical-connect-modal.png" alt="Vault Configure Connection" />

        <Tabs>
          <Tab title="App Role">
            * **Name**: The name of the connection being created. Must be slug-friendly.
            * **Description**: An optional description to provide details about this connection.
            * **Gateway (optional):** The gateway connected to your private network. All requests made to your Vault instance will be made through the configured gateway.
            * **Instance URL**: The URL of your Hashicorp Vault instance.
            * **Namespace (optional)**: The namespace within your vault. Self-hosted and enterprise clusters may not use namespaces.
            * **Role ID**: The Role ID generated in the steps above.
            * **Secret ID**: The Secret ID generated in the steps above.
          </Tab>

          <Tab title="Access Token">
            * **Name**: The name of the connection being created. Must be slug-friendly.
            * **Description**: An optional description to provide details about this connection.
            * **Gateway (optional):** The gateway connected to your private network. All requests made to your Vault instance will be made through the configured gateway.
            * **Instance URL**: The URL of your Hashicorp Vault instance.
            * **Namespace (optional)**: The namespace within your vault. Self-hosted and enterprise clusters may not use namespaces.
            * **Access Token**: The Access Token generated in the steps above.
          </Tab>
        </Tabs>
      </Step>

      <Step title="Connection Created">
        Your Vault Connection is now available for use.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/hashicorp-vault/vault-infisical-connect-success.png" alt="Vault Connection Created" />
      </Step>
    </Steps>
  </Tab>

  <Tab title="API">
    To create a Vault Connection, make an API request to the [Create Hashicorp Vault
    Connection](/api-reference/endpoints/app-connections/hashicorp-vault/create) API endpoint.

    ### Sample request

    ```bash Request theme={"dark"}
    curl    --request POST \
            --url https://app.infisical.com/api/v1/app-connections/hashicorp-vault \
            --header 'Content-Type: application/json' \
            --data '{
                "name": "my-vault-connection",
                "method": "app-role",
                "projectId": "7ffbb072-2575-495a-b5b0-127f88caef78",
                "credentials": {
                    "instanceUrl": "https://vault.example.com",
                    "roleId": "4797c4fa-7794-71f0-c8b1-7c87759df5bf",
                    "secretId": "ad24df93-19c8-c865-9997-6b8513253d3a"
                }
            }'
    ```

    ### Sample response

    ```bash Response theme={"dark"}
    {
        "appConnection": {
            "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "name": "my-vault-connection",
            "projectId": "7ffbb072-2575-495a-b5b0-127f88caef78",
            "version": 1,
            "orgId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "createdAt": "2025-04-01T05:31:56Z",
            "updatedAt": "2025-04-01T05:31:56Z",
            "app": "hashicorp-vault",
            "method": "app-role",
            "credentials": {
                "instanceUrl": "https://vault.example.com",
                "roleId": "4797c4fa-7794-71f0-c8b1-7c87759df5bf"
            }
        }
    }
    ```
  </Tab>
</Tabs>


# Heroku Connection
Source: https://infisical.com/docs/integrations/app-connections/heroku

Learn how to configure a Heroku Connection for Infisical using OAuth or Auth Token methods.

Infisical supports two methods for connecting to Heroku: **OAuth** and **Auth Token**. Choose the method that best fits your setup and security requirements.

<Tabs>
  <Tab title="OAuth Method">
    The OAuth method provides secure authentication through Heroku's OAuth flow.

    <Accordion title="Self-Hosted Instance Setup">
      Using the Heroku Connection with OAuth on a self-hosted instance of Infisical requires configuring an API client in Heroku and registering your instance with it.

      **Prerequisites:**

      * A Heroku account with existing applications
      * Self-hosted Infisical instance

      <Steps>
        <Step title="Create an API client in Heroku">
          Navigate to your user Account settings > Applications to create a new API client.

          <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/heroku/integrations-heroku-config-settings.png" alt="Heroku config settings" />
          <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/heroku/integrations-heroku-config-applications.png" alt="Heroku config applications" />
          <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/heroku/integrations-heroku-config-new-app.png" alt="Heroku config new app" />

          Create the API client. As part of the form, set the **OAuth callback URL** to `https://your-domain.com/organization/app-connections/heroku/oauth/callback`.

          <Tip>
            The domain you defined in the OAuth callback URL should be equivalent to the `SITE_URL` configured in your Infisical instance.
          </Tip>

                    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/heroku/integrations-heroku-config-new-app-form.png" alt="Heroku config new app form" />
        </Step>

        <Step title="Add your Heroku API client credentials to Infisical">
          Obtain the **Client ID** and **Client Secret** for your Heroku API client.

                    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/heroku/integrations-heroku-config-credentials.png" alt="Heroku config credentials" />

          Back in your Infisical instance, add two new environment variables for the credentials of your Heroku API client:

          * `INF_APP_CONNECTION_HEROKU_OAUTH_CLIENT_ID`: The **Client ID** of your Heroku API client.
          * `INF_APP_CONNECTION_HEROKU_OAUTH_CLIENT_SECRET`: The **Client Secret** of your Heroku API client.

          Once added, restart your Infisical instance and use the Heroku Connection.
        </Step>
      </Steps>
    </Accordion>

    ## Setup Heroku OAuth Connection in Infisical

    <Steps>
      <Step title="Navigate to App Connections">
        Navigate to the **App Connections** page in the desired project.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/general/add-connection.png" alt="App Connections Tab" />
      </Step>

      <Step title="Add Connection">
        Select the **Heroku Connection** option from the connection options modal.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/heroku/heroku-select-connection.png" alt="Select Heroku Connection" />
      </Step>

      <Step title="Choose OAuth Method">
        Select the **OAuth** method and click **Connect to Heroku**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/heroku/heroku-create-oauth-method.png" alt="Connect via Heroku OAuth" />
      </Step>

      <Step title="Grant Access">
        You will be redirected to Heroku to grant Infisical access to your Heroku account. Once granted, you will be redirected back to Infisical's App Connections page.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/heroku/integrations-heroku-auth.png" alt="Heroku Authorization" />
      </Step>

      <Step title="Connection Created">
        Your **Heroku Connection** is now available for use.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/heroku/heroku-connection.png" alt="Heroku OAuth Connection" />
      </Step>
    </Steps>
  </Tab>

  <Tab title="Auth Token Method">
    The Auth Token method uses a Heroku API token for authentication, providing a straightforward setup process.

    ## Setup Heroku Auth Token Connection in Infisical

    <Steps>
      <Step title="Generate Heroku API Token">
        Log in to your Heroku account and navigate to Account Settings.

        Under the **Authorizations** section on the **Applications** tab, reveal and copy your Authorization token. If you don't have one, click **Create Authorization** to create a new token.

        <Warning>
          Keep your Authorization token secure and do not share it. Anyone with access to this token can manage your Heroku applications.
        </Warning>

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/heroku/heroku-api-token.png" alt="Heroku API Token" />
      </Step>

      <Step title="Navigate to App Connections">
        Navigate to the **App Connections** page in the desired project.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/general/add-connection.png" alt="App Connections Tab" />
      </Step>

      <Step title="Add Connection">
        Select the **Heroku Connection** option from the connection options modal.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/heroku/heroku-select-connection.png" alt="Select Heroku Connection" />
      </Step>

      <Step title="Configure Auth Token">
        Select the **Auth Token** method and paste your Heroku Authorization token in the provided field.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/heroku/heroku-create-token-method.png" alt="Configure Auth Token" />

        Click **Connect** to establish the connection.
      </Step>

      <Step title="Connection Created">
        Your **Heroku Connection** is now available for use.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/heroku/heroku-connection.png" alt="Heroku Auth Token Connection" />
      </Step>
    </Steps>

    <Info>
      Auth Token connections require manual token rotation when your Heroku Authorization expires or is regenerated. Monitor your connection status and update the token as needed.
    </Info>
  </Tab>
</Tabs>


# Humanitec Connection
Source: https://infisical.com/docs/integrations/app-connections/humanitec

Learn how to configure a Humanitec Connection for Infisical.

Infisical supports connecting to Humanitec using a service user.

## Setup Humanitec Connection in Infisical

<Steps>
  <Step title="Move to Service Users on Humanitec">
    Navigate to the Humanitec **Service Users** tab.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/humanitec/humanitec-service-users.png" alt="Humanitec Service Users Tab" />
  </Step>

  <Step title="Create a Service User">
    Create a new service user. Take into account that the role set here will affect the permissions of the API Token so be sure to set it so the Service User has access permissions to the App you want to integrate to Infisical.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/humanitec/humanitec-create-new-user.png" alt="Humanitec Create New Service User" />
  </Step>

  <Step title="Add API Token for the Service User">
    Add a new API token for the service user.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/humanitec/humanitec-add-api-token.png" alt="Humanitec Add API Token" />
  </Step>

  <Step title="Create the API Token for the Service User">
    Create the API token for the service user.
    This token's permission will be limited to the **Service User** role.

    <Note>
      If you configure an expiry date for your API token you will need to manually rotate to a new token prior to expiration to avoid integration downtime.
    </Note>

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/humanitec/humanitec-create-api-token.png" alt="Humanitec Create API Token" />
  </Step>

  <Step title="Copy the API Token">
    A modal with the API token will be displayed. Save the token in a secure location for later use in the following steps.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/humanitec/humanitec-copy-api-token.png" alt="Humanitec Copy API Token" />
  </Step>

  <Step title="Service User has been successfully created">
    After following the previous steps the Service User has been successfully created, and now should be visible on the Service Users tab.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/humanitec/humanitec-service-account-filled.png" alt="Humanitec Service User Created" />
  </Step>

  <Step title="Add Service User to Application">
    Move to the **Applications** tab and add the Service User to the Application you want to sync with Infisical.
    Clicking on the App Title will open the App details page.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/humanitec/humanitec-applications-tab.png" alt="Humanitec Applications Tab" />
  </Step>

  <Step title="Add new member to this Application">
    Move to the **People** tab and add a new member to this Application. The recently created User Service should be visible on the dropdown shown.
    Make sure to assign at least Developer role as Write permissions are required.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/humanitec/humanitec-add-user.png" alt="Humanitec Add User to Application" />
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/humanitec/humanitec-add-user-options.png" alt="Humanitec Add User Options" />
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/humanitec/humanitec-add-user-role.png" alt="Humanitec Add User Role" />
  </Step>

  <Step title="Connection Created">
    Your **Humanitec Connection** is now available for use.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/humanitec/humanitec-user-added.png" alt="Humanitec Connection Created" />
  </Step>

  <Step title="Navigate to App Connections">
    Navigate to the **App Connections** page in the desired project.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/general/add-connection.png" alt="App Connections Tab" />
  </Step>

  <Step title="Add Connection">
    Select the **Humanitec Connection** option from the connection options modal.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/humanitec/humanitec-app-connection-option.png" alt="Select Humanitec Connection" />
  </Step>

  <Step title="Fill the Humanitec Connection Modal">
    Fill the Humanitec Connection modal, here you will need to provide the User Service API Token generated in the previous step.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/humanitec/humanitec-app-connection-modal.png" alt="Humanitec Connection Modal" />
  </Step>

  <Step title="Connection Created">
    Your **Humanitec Connection** is now available for use.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/humanitec/humanitec-app-connection-created.png" alt="Humanitec Connection Created" />
  </Step>
</Steps>


# Laravel Forge Connection
Source: https://infisical.com/docs/integrations/app-connections/laravel-forge

Learn how to configure a Laravel Forge Connection for Infisical.

Infisical supports the use of [API Tokens](https://forge.laravel.com/docs/api#create-a-new-api-token) to connect with Laravel Forge.

## Create Laravel Forge API Token

<Steps>
  <Step title="From your Laravel Forge dashboard, click on your user avatar and go to 'API'">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/laravel-forge/app-connection-profile.png" alt="Laravel Forge User Settings" />
  </Step>

  <Step title="Click 'Create Token'">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/laravel-forge/app-connection-create-api-token.png" alt="Applications Tab" />
  </Step>

  <Step title="Provide Token Information">
    Provide a name for your token and select the following permissions:

    * `user:view`
    * `organization:view`
    * `server:view`
    * `site:manage-environment`

    Then click 'Add token'.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/laravel-forge/api-token-create-form.png" alt="Token Form" />
  </Step>

  <Step title="Copy the token securely">
    Make sure to copy the token nowyou wont be able to access it again.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/laravel-forge/api-token-generated.png" alt="Token Generated" />
  </Step>
</Steps>

## Create a Laravel Forge Connection in Infisical

<Tabs>
  <Tab title="Infisical UI">
    <Steps>
      <Step title="Navigate to App Connections">
        In your Infisical dashboard, navigate to the **App Connections** page in the desired project.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/general/add-connection.png" alt="App Connections Tab" />
      </Step>

      <Step title="Select Laravel Forge Connection">
        Click **+ Add Connection** and choose **Laravel Forge** Connection from the list of integrations.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/laravel-forge/app-connection-option.png" alt="Select Laravel Forge Connection" />
      </Step>

      <Step title="Fill out the Laravel Forge Connection form">
        Complete the form by providing:

        * A descriptive name for the connection
        * An optional description
        * The API Token from the previous step
          <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/laravel-forge/app-connection-form.png" alt="Laravel Forge Connection Modal" />
      </Step>

      <Step title="Connection created">
        After submitting the form, your **Laravel Forge Connection** will be successfully created and ready to use with your Infisical project.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/laravel-forge/app-connection-generated.png" alt="Laravel Forge Connection Created" />
      </Step>
    </Steps>
  </Tab>

  <Tab title="API">
    To create a Laravel Forge Connection via API, send a request to the [Create Laravel Forge Connection](/api-reference/endpoints/app-connections/laravel-forge/create) endpoint.

    ### Sample request

    ```bash Request theme={"dark"}
    curl    --request POST \
            --url https://app.infisical.com/api/v1/app-connections/laravel-forge \
            --header 'Content-Type: application/json' \
            --data '{
                "name": "my-laravel-forge-connection",
                "method": "api-token",
                "projectId": "7ffbb072-2575-495a-b5b0-127f88caef78",
                "credentials": {
                    "apiToken": "[API TOKEN]"
                }
            }'
    ```

    ### Sample response

    ```bash Response theme={"dark"}
    {
      "appConnection": {
          "id": "a1b2c3d4-5678-90ab-cdef-1234567890ab",
          "name": "my-laravel-forge-connection",
          "description": null,
          "projectId": "7ffbb072-2575-495a-b5b0-127f88caef78",
          "version": 1,
          "orgId": "abcdef12-3456-7890-abcd-ef1234567890",
          "createdAt": "2025-10-13T10:15:00.000Z",
          "updatedAt": "2025-10-13T10:15:00.000Z",
          "isPlatformManagedCredentials": false,
          "credentialsHash": "d41d8cd98f00b204e9800998ecf8427e",
          "app": "laravel-forge",
          "method": "api-token",
          "credentials": {}
      }
    }
    ```
  </Tab>
</Tabs>


# LDAP Connection
Source: https://infisical.com/docs/integrations/app-connections/ldap

Learn how to configure an LDAP Connection for Infisical.

Infisical supports the use of [Simple Binding](https://ldap.com/the-ldap-bind-operation) to connect with your LDAP provider.

## Prerequisites

You will need the following information to establish an LDAP connection:

* **LDAP URL** - The LDAP/LDAPS URL to connect to (e.g., ldap\://domain-or-ip:389 or ldaps\://domain-or-ip:636)
* **Binding DN/UPN** - The Distinguished Name (DN), or User Principal Name (UPN) if supported, of the principal to bind with (e.g., 'CN=John,CN=Users,DC=example,DC=com')
* **Binding Password** - The password to bind with for authentication
* **CA Certificate** - The SSL certificate (PEM format) to use for secure connection when using ldaps\:// with a self-signed certificate

Depending on how you intend to use your LDAP connection, there may be additional requirements:

<Tabs>
  <Tab title="Secret Rotation">
    <Note>
      For Password Rotation, the following requirements must additionally be met:

      * You must use an LDAPS connection
      * The binding user must either have:
        * Permission to change other users passwords if rotating directory users' passwords
        * Permission to update their own password if rotating their personal password
    </Note>
  </Tab>
</Tabs>

## Setup LDAP Connection in Infisical

<Tabs>
  <Tab title="Infisical UI">
    1. Navigate to the **App Connections** page in the desired project.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/general/add-connection.png" alt="App Connections Tab" />

    2. Select the **LDAP Connection** option.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/ldap/select-ldap-connection.png" alt="Select LDAP Connection" />

    3. Select the **Simple Bind** method option and provide the details obtained from the previous section and press **Connect to Provider**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/ldap/create-simple-bind-method.png" alt="Create LDAP Connection" />

    4. Your **LDAP Connection** is now available for use.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/ldap/simple-bind-connection.png" alt="Assume Role LDAP Connection" />
  </Tab>

  <Tab title="API">
    To create an LDAP Connection, make an API request to the [Create LDAP
    Connection](/api-reference/endpoints/app-connections/ldap/create) API endpoint.

    ### Sample request

    ```bash Request theme={"dark"}
    curl    --request POST \
        --url https://app.infisical.com/api/v1/app-connections/ldap \
        --header 'Content-Type: application/json' \
        --data '{
            "name": "my-ldap-connection",
            "method": "simple-bind",
            "projectId": "7ffbb072-2575-495a-b5b0-127f88caef78",
            "credentials": {
                "provider": "active-directory",
                "url": "ldaps://domain-or-ip:636",
                "dn": "CN=John,CN=Users,DC=example,DC=com",
                "password": "<your-secure-password>",
                "sslRejectUnauthorized": true,
                "sslCertificate": "..."
            }
        }'
    ```

    ### Sample response

    ```bash Response theme={"dark"}
    {
        "appConnection": {
            "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "name": "my-ldap-connection",
            "projectId": "7ffbb072-2575-495a-b5b0-127f88caef78",
            "version": 1,
            "orgId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "createdAt": "2023-11-07T05:31:56Z",
            "updatedAt": "2023-11-07T05:31:56Z",
            "app": "ldap",
            "method": "simple-bind",
            "credentials": {
                "provider": "active-directory",
                "url": "ldaps://domain-or-ip:636",
                "dn": "CN=John,CN=Users,DC=example,DC=com",
                "sslRejectUnauthorized": true,
                "sslCertificate": "..."
            }
        }
    }
    ```
  </Tab>
</Tabs>


# Microsoft SQL Server Connection
Source: https://infisical.com/docs/integrations/app-connections/mssql

Learn how to configure a Microsoft SQL Server Connection for Infisical.

Infisical supports connecting to Microsoft SQL Server using database principals.

## Configure a Microsoft SQL Server Principal for Infisical

<Steps>
  <Step title="Create a Principal">
    Infisical recommends creating a designated server login and database user in your Microsoft SQL Server database for your connection.

    ```SQL  theme={"dark"}
    -- Create login at the server level
    CREATE LOGIN [infisical_app] WITH PASSWORD = 'my-password';

    -- Grant server-level connect permission
    GRANT CONNECT SQL TO [infisical_app];

    -- If you intend to use Platform Managed Credentials (see below)
    GRANT ALTER ANY LOGIN TO [infisical_app];

    -- Switch to the specific database where you want to create the user
    USE my_database;

    -- Create the database user mapped to the login
    CREATE USER [infisical_app] FOR LOGIN [infisical_app];
    ```
  </Step>

  <Step title="Grant Relevant Permissions">
    Depending on how you intend to use your Microsoft SQL Server connection, you'll need to grant one or more of the following permissions.

    <Tip>
      To learn more about Microsoft SQL Server's permission system, please visit their [documentation](https://learn.microsoft.com/en-us/sql/t-sql/statements/grant-transact-sql?view=sql-server-ver16).
    </Tip>

    <Tabs>
      <Tab title="Secret Rotation">
        For Secret Rotations, your Infisical user will require the ability to alter other logins' passwords:

        ```SQL  theme={"dark"}
        GRANT ALTER ANY LOGIN TO infisical_login;
        ```
      </Tab>
    </Tabs>
  </Step>

  <Step title="Get Connection Details">
    You'll need the following information to create your Microsoft SQL Server connection:

    * `host` - The hostname or IP address of your Microsoft SQL Server server
    * `port` - The port number your Microsoft SQL Server server is listening on (default: 1433)
    * `database` - The name of the specific database you want to connect to
    * `username` - The username of the login created in the steps above
    * `password` - The password of the login created in the steps above
    * `sslCertificate` (optional) - The SSL certificate required for connection (if configured)

    <Note>
      If you are self-hosting Infisical and intend to connect to an internal/private IP address, be sure to set the `ALLOW_INTERNAL_IP_CONNECTIONS` environment variable to `true`.
    </Note>
  </Step>
</Steps>

## Create Connection in Infisical

<Tabs>
  <Tab title="Infisical UI">
    1. Navigate to the **App Connections** page in the desired project.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/general/add-connection.png" alt="App Connections Tab" />

    2. Select the **Microsoft SQL Server Connection** option.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/mssql/select-mssql-connection.png" alt="Select Microsoft SQL Server Connection" />

    3. Select the **Username & Password** method option and provide the details obtained from the previous section and press **Connect to Microsoft SQL Server**.

    <Note>
      Optionally, if you'd like Infisical to manage the credentials of this connection, you can enable the Platform Managed Credentials option.
      If enabled, Infisical will update the password of the connection on creation to prevent external access to this database role.
    </Note>

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/mssql/create-username-and-password-method.png" alt="Create Microsoft SQL Server Connection" />

    4. Your **Microsoft SQL Server Connection** is now available for use.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/mssql/username-and-password-connection.png" alt="Assume Role Microsoft SQL Server Connection" />
  </Tab>

  <Tab title="API">
    To create a Microsoft SQL Server Connection, make an API request to the [Create Microsoft SQL Server
    Connection](/api-reference/endpoints/app-connections/mssql/create) API endpoint.

    <Note>
      Optionally, if you'd like Infisical to manage the credentials of this connection, you can set the `isPlatformManagedCredentials` option to `true`.
      If enabled, Infisical will update the password of the connection on creation to prevent external access to this database role.
    </Note>

    ### Sample request

    ```bash Request theme={"dark"}
    curl    --request POST \
    --url https://app.infisical.com/api/v1/app-connections/mssql \
    --header 'Content-Type: application/json' \
    --data '{
        "name": "my-mssql-connection",
        "method": "username-and-password",
        "projectId": "7ffbb072-2575-495a-b5b0-127f88caef78",
        "isPlatformManagedCredentials": true,
        "credentials": {
            "host": "123.4.5.6",
            "port": 1433,
            "database": "default",
            "username": "infisical_login",
            "password": "my-password",
            "sslEnabled": true,
            "sslRejectUnauthorized": true
        },
    }'
    ```

    ### Sample response

    ```bash Response theme={"dark"}
    {
        "appConnection": {
            "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "name": "my-mssql-connection",
            "projectId": "7ffbb072-2575-495a-b5b0-127f88caef78",
            "version": 1,
            "orgId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "createdAt": "2023-11-07T05:31:56Z",
            "updatedAt": "2023-11-07T05:31:56Z",
            "app": "mssql",
            "method": "username-and-password",
            "isPlatformManagedCredentials": true,
            "credentials": {
                "host": "123.4.5.6",
                "port": 1433,
                "database": "default",
                "username": "infisical_login",
                "sslEnabled": true,
                "sslRejectUnauthorized": true
            }
        }
    }
    ```
  </Tab>
</Tabs>


# MySQL Connection
Source: https://infisical.com/docs/integrations/app-connections/mysql

Learn how to configure a MySQL Connection for Infisical.

Infisical supports connecting to MySQL using a database role.

## Configure a MySQL Role for Infisical

<Steps>
  <Step title="Create a Role">
    Infisical recommends creating a designated role in your MySQL database for your connection.

    ```SQL  theme={"dark"}
    -- create user role
    CREATE USER 'infisical_role'@'%' IDENTIFIED BY 'my-password';
    ```
  </Step>

  <Step title="Grant Relevant Permissions">
    Depending on how you intend to use your MySQL connection, you'll need to grant one or more of the following permissions.

    <Tip>
      To learn more about MySQL's permission system, please visit their [documentation](https://dev.mysql.com/doc/refman/8.4/en/grant.html).
    </Tip>

    <Tabs>
      <Tab title="Secret Rotation">
        For Secret Rotations, your Infisical user will require the ability to alter other users' passwords:

        ```SQL  theme={"dark"}
        -- enable permissions to alter login credentials
        GRANT CREATE USER ON *.* TO 'infisical_role'@'%';

        -- Apply changes
        FLUSH PRIVILEGES;
        ```
      </Tab>
    </Tabs>
  </Step>

  <Step title="Get Connection Details">
    You'll need the following information to create your MySQL connection:

    * `host` - The hostname or IP address of your MySQL server
    * `port` - The port number your MySQL server is listening on (default: 3306)
    * `database` - The name of the specific database you want to connect to
    * `username` - The role name of the login created in the steps above
    * `password` - The role password of the login created in the steps above
    * `sslCertificate` (optional) - The SSL certificate required for connection (if configured)

    <Note>
      If you are self-hosting Infisical and intend to connect to an internal/private IP address, be sure to set the `ALLOW_INTERNAL_IP_CONNECTIONS` environment variable to `true`.
    </Note>
  </Step>
</Steps>

## Create Connection in Infisical

<Tabs>
  <Tab title="Infisical UI">
    1. Navigate to the **App Connections** page in the desired project.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/general/add-connection.png" alt="App Connections Tab" />

    2. Select the **MySQL Connection** option.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/mysql/select-mysql-connection.png" alt="Select MySQL Connection" />

    3. Select the **Username & Password** method option and provide the details obtained from the previous section and press **Connect to MySQL**.

    <Note>
      Optionally, if you'd like Infisical to manage the credentials of this connection, you can enable the Platform Managed Credentials option.
      If enabled, Infisical will update the password of the connection on creation to prevent external access to this database role.
    </Note>

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/mysql/create-username-and-password-method.png" alt="Create MySQL Connection" />

    4. Your **MySQL Connection** is now available for use.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/mysql/username-and-password-connection.png" alt="Assume Role MySQL Connection" />
  </Tab>

  <Tab title="API">
    To create a MySQL Connection, make an API request to the [Create MySQL Connection](/api-reference/endpoints/app-connections/mysql/create) API endpoint.

    <Note>
      Optionally, if you'd like Infisical to manage the credentials of this connection, you can set the `isPlatformManagedCredentials` option to `true`.
      If enabled, Infisical will update the password of the connection on creation to prevent external access to this database role.
    </Note>

    ### Sample request

    ```bash Request theme={"dark"}
    curl    --request POST \
    --url https://app.infisical.com/api/v1/app-connections/mysql \
    --header 'Content-Type: application/json' \
    --data '{
        "name": "my-mysql-connection",
        "method": "username-and-password",
        "isPlatformManagedCredentials": true,
        "projectId": "7ffbb072-2575-495a-b5b0-127f88caef78",
        "credentials": {
            "host": "123.4.5.6",
            "port": 3306,
            "database": "default",
            "username": "infisical_role",
            "password": "my-password",
            "sslEnabled": true,
            "sslRejectUnauthorized": true
        },
    }'
    ```

    ### Sample response

    ```bash Response theme={"dark"}
    {
        "appConnection": {
            "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "name": "my-mysql-connection",
            "projectId": "7ffbb072-2575-495a-b5b0-127f88caef78",
            "version": 1,
            "orgId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "createdAt": "2023-11-07T05:31:56Z",
            "updatedAt": "2023-11-07T05:31:56Z",
            "app": "mysql",
            "method": "username-and-password",
            "isPlatformManagedCredentials": true,
            "credentials": {
                "host": "123.4.5.6",
                "port": 3306,
                "database": "default",
                "username": "infisical_role",
                "sslEnabled": true,
                "sslRejectUnauthorized": true
            }
        }
    }
    ```
  </Tab>
</Tabs>


# Netlify Connection
Source: https://infisical.com/docs/integrations/app-connections/netlify

Learn how to configure a Netlify Connection for Infisical.

Infisical supports the use of [Personal Access Tokens](https://docs.netlify.com/api/get-started/#get-access-tokens) to connect with Netlify.

<Note>
  Netlify requires the token to have **full access** to enable secret management for your sites and services.
</Note>

## Create a Netlify Personal Access Token

<Steps>
  <Step title="From your Netlify dashboard, click on your user avatar and go to 'User settings'">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/netlify/app-connection-profile.png" alt="Netlify User Settings" />
  </Step>

  <Step title="In the left sidebar, click on 'Applications' and scroll to 'Personal Access Tokens'">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/netlify/app-connection-create-api-key.png" alt="Applications Tab" />
  </Step>

  <Step title="Click 'New access token'">
    Provide a name for your token and generate it.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/netlify/app-connection-create-form.png" alt="Token Form" />
  </Step>

  <Step title="Copy the token securely">
    Make sure to copy the token nowyou wont be able to access it again.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/netlify/app-connection-key-generated.png" alt="Token Generated" />
  </Step>
</Steps>

## Create a Netlify Connection in Infisical

<Tabs>
  <Tab title="Infisical UI">
    <Steps>
      <Step title="Navigate to App Connections">
        In your Infisical dashboard, navigate to the **App Connections** page in the desired project.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/general/add-connection.png" alt="App Connections Tab" />
      </Step>

      <Step title="Select Netlify Connection">
        Click **+ Add Connection** and choose **Netlify Connection** from the list of integrations.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/netlify/app-connection-option.png" alt="Select Netlify Connection" />
      </Step>

      <Step title="Fill out the Netlify Connection form">
        Complete the form by providing:

        * A descriptive name for the connection
        * An optional description
        * The API Token from the previous step

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/netlify/app-connection-form.png" alt="Netlify Connection Modal" />
      </Step>

      <Step title="Connection created">
        After submitting the form, your **Netlify Connection** will be successfully created and ready to use with your Infisical project.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/netlify/app-connection-generated.png" alt="Netlify Connection Created" />
      </Step>
    </Steps>
  </Tab>

  <Tab title="API">
    To create a Netlify Connection via API, send a request to the [Create Netlify Connection](/api-reference/endpoints/app-connections/netlify/create) endpoint.

    ### Sample request

    ```bash Request theme={"dark"}
    curl    --request POST \
            --url https://app.infisical.com/api/v1/app-connections/netlify \
            --header 'Content-Type: application/json' \
            --data '{
                "name": "my-netlify-connection",
                "method": "access-token",
                "projectId": "7ffbb072-2575-495a-b5b0-127f88caef78",
                "credentials": {
                    "accessToken": "[ACCESS TOKEN]"
                }
            }'
    ```

    ### Sample response

    ```bash Response theme={"dark"}
    {
      "appConnection": {
          "id": "a1b2c3d4-5678-90ab-cdef-1234567890ab",
          "name": "my-netlify-connection",
          "description": null,
          "projectId": "7ffbb072-2575-495a-b5b0-127f88caef78",
          "version": 1,
          "orgId": "abcdef12-3456-7890-abcd-ef1234567890",
          "createdAt": "2025-07-19T10:15:00.000Z",
          "updatedAt": "2025-07-19T10:15:00.000Z",
          "isPlatformManagedCredentials": false,
          "credentialsHash": "d41d8cd98f00b204e9800998ecf8427e",
          "app": "netlify",
          "method": "access-token",
          "credentials": {}
      }
    }
    ```
  </Tab>
</Tabs>


# Northflank Connection
Source: https://infisical.com/docs/integrations/app-connections/northflank

Learn how to configure a Northflank Connection for Infisical.

Infisical supports the use of [API Tokens](https://northflank.com/docs/v1/api/use-the-api) to connect with Northflank.

<Tip>
  Infisical recommends creating a specific API role for the app connection and only giving access to projects that will use the integration.
</Tip>

## Create a Northflank API Token

<Steps>
  <Step title="Create an API Role">
    Navigate to your team page and click **Create token**.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/northflank/step-1.png" alt="Create API Role" />

    Click on **Create API role**.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/northflank/step-2.png" alt="Create API Role" />

    Select all the projects you want this role to have access to, or leave this unchecked if you want to give access to all projects.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/northflank/step-3.png" alt="Create API Role" />

    Add the **Projects** -> **Manage** -> **Read** permission.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/northflank/step-4-1.png" alt="Create API Role" />

    Add the **Config & Secrets** -> **Secret Groups** -> **List**, **Update** and **Read Values** permissions.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/northflank/step-4-2.png" alt="Create API Role" />

    Scroll to the bottom and save the API role.
  </Step>

  <Step title="Create an API Token">
    Click on the **API** -> **Tokens** menu on the left and then click the **Create API token** button.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/northflank/step-5.png" alt="Create API Token" />

    Give a name to the API token and click the **Use role** button for the new API role you just created.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/northflank/step-6.png" alt="Create API Token" />

    Click the **View API token** icon to view and copy your token.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/northflank/step-7.png" alt="Create API Token" />
  </Step>
</Steps>

## Create a Northflank Connection in Infisical

<Tabs>
  <Tab title="Infisical UI">
    <Steps>
      <Step title="Navigate to App Connections">
        In your Infisical dashboard, navigate to the **App Connections** page in the desired project.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/general/add-connection.png" alt="App Connections Tab" />
      </Step>

      <Step title="Select Northflank Connection">
        Click **+ Add Connection** and choose **Northflank Connection** from the list of integrations.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/northflank/northflank-app-connection-option.png" alt="Select Northflank Connection" />
      </Step>

      <Step title="Fill out the Northflank Connection form">
        Complete the form by providing:

        * A descriptive name for the connection
        * An optional description
        * The API Token from the previous step

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/northflank/northflank-app-connection-form.png" alt="Northflank Connection Modal" />
      </Step>

      <Step title="Connection created">
        After submitting the form, your **Northflank Connection** will be successfully created and ready to use with your Infisical project.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/northflank/northflank-app-connection-generated.png" alt="Northflank Connection Created" />
      </Step>
    </Steps>
  </Tab>

  <Tab title="API">
    To create a Northflank Connection via API, send a request to the [Create Northflank Connection](/api-reference/endpoints/app-connections/northflank/create) endpoint.

    ### Sample request

    ```bash Request theme={"dark"}
    curl    --request POST \
            --url https://app.infisical.com/api/v1/app-connections/northflank \
            --header 'Content-Type: application/json' \
            --data '{
                "name": "my-northflank-connection",
                "method": "api-token",
                "projectId": "abcdef12-3456-7890-abcd-ef1234567890",
                "credentials": {
                    "apiToken": "[API TOKEN]"
                }
            }'
    ```

    ### Sample response

    ```bash Response theme={"dark"}
    {
      "appConnection": {
          "id": "a1b2c3d4-5678-90ab-cdef-1234567890ab",
          "name": "my-northflank-connection",
          "description": null,
          "projectId": "abcdef12-3456-7890-abcd-ef1234567890",
          "version": 1,
          "orgId": "abcdef12-3456-7890-abcd-ef1234567890",
          "createdAt": "2025-01-23T10:15:00.000Z",
          "updatedAt": "2025-01-23T10:15:00.000Z",
          "isPlatformManagedCredentials": false,
          "credentialsHash": "d41d8cd98f00b204e9800998ecf8427e",
          "app": "northflank",
          "method": "api-token",
          "credentials": {}
      }
    }
    ```
  </Tab>
</Tabs>


# OCI Connection
Source: https://infisical.com/docs/integrations/app-connections/oci

Learn how to configure an Oracle Cloud Infrastructure Connection for Infisical.

<Info>
  OCI App Connection is a paid feature.

  If you're using Infisical Cloud, then it is available under the **Enterprise Tier**. If you're self-hosting Infisical,
  then you should contact [team@infisical.com](mailto:team@infisical.com) to purchase an enterprise license to use it.
</Info>

Infisical supports the use of [API Signing Key Authentication](https://docs.oracle.com/en-us/iaas/Content/API/Concepts/apisigningkey.htm) to connect with OCI.

## Create OCI User

<Steps>
  <Step title="Search for 'Domains' and click as shown">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/oci/search-domains.png" alt="Search Domains" />
  </Step>

  <Step title="Select domain">
    Select the domain in which you want to create the Infisical user account.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/oci/select-domain.png" alt="Select Domain" />
  </Step>

  <Step title="Navigate to 'Users'">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/oci/select-users.png" alt="Select Users" />
  </Step>

  <Step title="Click 'Create user'">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/oci/click-create-user.png" alt="Click Create User" />
  </Step>

  <Step title="Create user">
    The name, email, and username can be anything.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/oci/create-user.png" alt="Create User" />
  </Step>

  <Step title="Navigate to 'API keys'">
    After you've created a user, you'll be redirected to the user's page. Navigate to 'API keys'.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/oci/select-api-keys.png" alt="Select API Keys" />
  </Step>

  <Step title="Add API key">
    Click on 'Add API key' and then download or import the private key. After you've obtained the private key, click 'Add'.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/oci/add-api-key.png" alt="Add API Key" />
  </Step>

  <Step title="Store configuration">
    After creating the API key, you'll be shown a modal with relevant information. Save the highlighted values (and the private key) for later steps.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/oci/user-info.png" alt="User Info" />
  </Step>
</Steps>

## Create OCI Group

<Steps>
  <Step title="Search for 'Domains' and click as shown">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/oci/search-domains.png" alt="Search Domains" />
  </Step>

  <Step title="Select domain">
    Select the domain in which you want to create the Infisical user account.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/oci/select-domain.png" alt="Select Domain" />
  </Step>

  <Step title="Navigate to 'Groups'">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/oci/select-groups.png" alt="Select Groups" />
  </Step>

  <Step title="Create group">
    The name and description can be anything. **Ensure that you assign the user created in earlier steps to this group**.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/oci/create-group.png" alt="Create Group" />
  </Step>

  <Step title="Store group name">
    After creating the group, take note of its name. It will be used in later steps.
  </Step>
</Steps>

## Create OCI Policy

<Steps>
  <Step title="Search for 'Policies' and click as shown">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/oci/search-policies.png" alt="Search Policies" />
  </Step>

  <Step title="Click 'Create Policy'">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/oci/click-create-policy.png" alt="Click Create Policy" />
  </Step>

  <Step title="Create policy">
    The name and description can be anything. Click 'Show manual editor' and paste in the policy rules relevant to your task:

    <Tabs>
      <Tab title="Secret Sync">
        ```
        Allow group <group name> to manage secret-family in compartment <compartment name>
        Allow group <group name> to use keys in compartment <compartment name>
        Allow group <group name> to use vaults in compartment <compartment name>
        Allow group <group name> to inspect compartments in tenancy
        ```

        * **Group Name:** The name of the group you created in earlier steps.
        * **Compartment Name:** The name of the compartment which has your secrets vault.

        If you'd like to grant Infisical access to all compartments, replace instances of `compartment <compartment name>` with `tenancy`.
      </Tab>
    </Tabs>

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/oci/create-policy.png" alt="Create Policy" />

    <Note>
      **You must create this policy on the root compartment**, otherwise some functionality may not work.
    </Note>
  </Step>
</Steps>

## Create OCI Connection in Infisical

<Tabs>
  <Tab title="Infisical UI">
    <Steps>
      <Step title="Navigate to App Connections">
        In your Infisical dashboard, navigate to the **App Connections** page in the desired project.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/general/add-connection.png" alt="App Connections Tab" />
      </Step>

      <Step title="Select OCI Connection">
        Click the **+ Add Connection** button and select the **OCI Connection** option from the available integrations.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/oci/app-connection-option.png" alt="Select OCI Connection" />
      </Step>

      <Step title="Fill out the OCI Connection Modal">
        Complete the OCI Connection form by entering:

        * A descriptive name for the connection
        * An optional description for future reference
        * The User OCID from [earlier steps](https://infisical.com/docs/integrations/app-connections/oci#create-oci-user)
        * The Tenancy OCID from [earlier steps](https://infisical.com/docs/integrations/app-connections/oci#create-oci-user)
        * The Region from [earlier steps](https://infisical.com/docs/integrations/app-connections/oci#create-oci-user)
        * The Fingerprint from [earlier steps](https://infisical.com/docs/integrations/app-connections/oci#create-oci-user)
        * The Private Key PEM from [earlier steps](https://infisical.com/docs/integrations/app-connections/oci#create-oci-user)

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/oci/app-connection-modal.png" alt="OCI Connection Modal" />
      </Step>

      <Step title="Connection Created">
        After clicking Create, your **OCI Connection** is established and ready to use with your Infisical project.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/oci/app-connection-created.png" alt="OCI Connection Created" />
      </Step>
    </Steps>
  </Tab>

  <Tab title="API">
    To create an OCI Connection, make an API request to the [Create OCI Connection](/api-reference/endpoints/app-connections/oci/create) API endpoint.

    ### Sample request

    ```bash Request theme={"dark"}
    curl    --request POST \
            --url https://app.infisical.com/api/v1/app-connections/oci \
            --header 'Content-Type: application/json' \
            --data '{
                "name": "my-oci-connection",
                "method": "access-key",
                "projectId": "7ffbb072-2575-495a-b5b0-127f88caef78",
                "credentials": {
                    "userOcid": "ocid1.user.oc1..aaaaaaaagrp35tbkvvad4y2j7sug7xonua7dl2gfp4at2u5i5xj4ghnitg3a",
                    "tenancyOcid": "ocid1.tenancy.oc1..aaaaaaaaotfma465m4zumfe2ua64mj2m5dwmlw2llh4g4dnfttnakiifonta",
                    "region": "us-ashburn-1",
                    "fingerprint": "9c:f6:18:23:92:73:f8:e1:85:2c:6a:e3:2c:7d:ec:8f",
                    "privateKey": "[PRIVATE KEY PEM]"
                }
            }'
    ```

    ### Sample response

    ```bash Response theme={"dark"}
    {
      "appConnection": {
          "id": "e5d18aca-86f7-4026-a95e-efb8aeb0d8e6",
          "name": "my-oci-connection",
          "projectId": "7ffbb072-2575-495a-b5b0-127f88caef78",
          "description": null,
          "version": 1,
          "orgId": "6f03caa1-a5de-43ce-b127-95a145d3464c",
          "createdAt": "2025-04-23T19:46:34.831Z",
          "updatedAt": "2025-04-23T19:46:34.831Z",
          "isPlatformManagedCredentials": false,
          "credentialsHash": "7c2d371dec195f82a6a0d5b41c970a229cfcaf88e894a5b6395e2dbd0280661f",
          "app": "oci",
          "method": "access-key",
          "credentials": {
            "userOcid": "ocid1.user.oc1..aaaaaaaagrp35tbkvvad4y2j7sug7xonua7dl2gfp4at2u5i5xj4ghnitg3a",
            "tenancyOcid": "ocid1.tenancy.oc1..aaaaaaaaotfma465m4zumfe2ua64mj2m5dwmlw2llh4g4dnfttnakiifonta",
            "region": "us-ashburn-1",
            "fingerprint": "9c:f6:18:23:92:73:f8:e1:85:2c:6a:e3:2c:7d:ec:8f"
          }
      }
    }
    ```
  </Tab>
</Tabs>


# Okta Connection
Source: https://infisical.com/docs/integrations/app-connections/okta

Learn how to configure an Okta Connection for Infisical.

Infisical supports the use of [API Tokens](https://developer.okta.com/docs/guides/create-an-api-token/main/) to connect with Okta.

## Create Okta API Token

<Steps>
  <Step title="Create API Token">
    From the Okta admin dashboard, navigate to **Security > API > Tokens** and click **Create token**.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/okta/step-1.png" alt="Create API Token" />
  </Step>

  <Step title="Provide Info">
    Enter the token name and select **Any IP** for the second dropdown, then click **Create token**.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/okta/step-2.png" alt="Provide Info" />
  </Step>

  <Step title="Copy Token">
    Copy the token from the modal for later steps.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/okta/step-3.png" alt="Copy Token" />
  </Step>
</Steps>

## Create Okta Connection in Infisical

<Tabs>
  <Tab title="Infisical UI">
    <Steps>
      <Step title="Navigate to App Connections">
        In your Infisical dashboard, navigate to the **App Connections** page in the desired project.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/general/add-connection.png" alt="App Connections Tab" />
      </Step>

      <Step title="Select Okta Connection">
        Click the **Add Connection** button and select **Okta** from the list of available connections.
      </Step>

      <Step title="Fill out Connection Modal">
        Complete the Okta Connection form by entering:

        * A descriptive name for the connection
        * An optional description for future reference
        * Your Okta instance URL
        * The API Token from earlier steps

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/okta/step-4.png" alt="Connection Modal" />
      </Step>

      <Step title="Connection Created">
        After clicking Create, your **Okta Connection** is established and ready to use with your Infisical project.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/okta/step-5.png" alt="Connection Created" />
      </Step>
    </Steps>
  </Tab>

  <Tab title="API">
    To create a Okta Connection, make an API request to the [Create Okta Connection](/api-reference/endpoints/app-connections/okta/create) API endpoint.

    ### Sample request

    ```bash Request theme={"dark"}
    curl    --request POST \
            --url https://app.infisical.com/api/v1/app-connections/okta \
            --header 'Content-Type: application/json' \
            --data '{
                "name": "my-okta-connection",
                "method": "api-token",
                "projectId": "7ffbb072-2575-495a-b5b0-127f88caef78",
                "credentials": {
                    "instanceUrl": "https://example.okta.com",
                    "apiToken": "<YOUR-API-TOKEN>"
                }
            }'
    ```

    ### Sample response

    ```bash Response theme={"dark"}
    {
      "appConnection": {
          "id": "e5d18aca-86f7-4026-a95e-efb8aeb0d8e6",
          "name": "my-okta-connection",
          "projectId": "7ffbb072-2575-495a-b5b0-127f88caef78",
          "description": null,
          "version": 1,
          "orgId": "6f03caa1-a5de-43ce-b127-95a145d3464c",
          "createdAt": "2025-04-23T19:46:34.831Z",
          "updatedAt": "2025-04-23T19:46:34.831Z",
          "isPlatformManagedCredentials": false,
          "credentialsHash": "7c2d371dec195f82a6a0d5b41c970a229cfcaf88e894a5b6395e2dbd0280661f",
          "app": "okta",
          "method": "api-token",
          "credentials": {
              "instanceUrl": "https://example.okta.com"
          }
      }
    }
    ```
  </Tab>
</Tabs>


# OracleDB Connection
Source: https://infisical.com/docs/integrations/app-connections/oracledb

Learn how to configure a Oracle Database Connection for Infisical.

<Info>
  OracleDB App Connection is a paid feature.

  If you're using Infisical Cloud, then it is available under the **Enterprise Tier**. If you're self-hosting Infisical,
  then you should contact [team@infisical.com](mailto:team@infisical.com) to purchase an enterprise license to use it.
</Info>

Infisical supports connecting to OracleDB using a database user.

## Configure an Oracle Database User for Infisical

<Steps>
  <Step title="Create a User">
    Infisical recommends creating a designated user in your Oracle Database for your connection.

    ```SQL  theme={"dark"}
    -- create user
    CREATE USER infisical IDENTIFIED BY "my-password";

    -- grant create session privileges
    GRANT CREATE SESSION TO infisical;
    ```

    <Note>
      Username must either be ALL UPPERCASE or not be surrounded by "quotes". Values not surrounded by quotes get automatically transformed to uppercase by Oracle Database.
    </Note>
  </Step>

  <Step title="Grant Relevant Permissions">
    Depending on how you intend to use your OracleDB connection, you'll need to grant one or more of the following permissions.

    <Tip>
      To learn more about the Oracle Database permission system, please visit their [documentation](https://docs.oracle.com/en/database/oracle/oracle-database/19/dbseg/configuring-privilege-and-role-authorization.html).
    </Tip>

    <Tabs>
      <Tab title="Secret Rotation">
        For Secret Rotations, your Infisical user will require the ability to alter other users' passwords:

        ```SQL  theme={"dark"}
        -- enable permissions to alter login credentials
        GRANT ALTER USER TO infisical;
        ```
      </Tab>
    </Tabs>
  </Step>

  <Step title="Get Connection Details">
    You'll need the following information to create your Oracle Database connection:

    * `host` - The hostname or IP address of your Oracle Database server
    * `port` - The port number your Oracle Database server is listening on (default: 1521)
    * `database` - The Oracle Service Name or SID (System Identifier) for the database you are connecting to. For example: `ORCL`, `FREEPDB1`, `XEPDB1`
    * `username` - The user name of the login created in the steps above
    * `password` - The user password of the login created in the steps above
    * `sslCertificate` (optional) - The SSL certificate required for connection (if configured)

    <Note>
      If you are self-hosting Infisical and intend to connect to an internal/private IP address, be sure to set the `ALLOW_INTERNAL_IP_CONNECTIONS` environment variable to `true`.
    </Note>
  </Step>
</Steps>

## Create Connection in Infisical

<Tabs>
  <Tab title="Infisical UI">
    1. Navigate to the **App Connections** page in the desired project.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/general/add-connection.png" alt="App Connections Tab" />

    2. Select the **OracleDB Connection** option.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/oracledb/select-oracledb-connection.png" alt="Select OracleDB Connection" />

    3. Select the **Username & Password** method option and provide the details obtained from the previous section and press **Connect to OracleDB**.

    <Note>
      Optionally, if you'd like Infisical to manage the credentials of this connection, you can enable the Platform Managed Credentials option.
      If enabled, Infisical will update the password of the connection on creation to prevent external access to this database user.
    </Note>

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/oracledb/create-username-and-password-method.png" alt="Create OracleDB Connection" />

    4. Your **OracleDB Connection** is now available for use.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/oracledb/username-and-password-connection.png" alt="Assume User OracleDB Connection" />
  </Tab>

  <Tab title="API">
    To create an Oracle Database Connection, make an API request to the [Create OracleDB Connection](/api-reference/endpoints/app-connections/oracledb/create) API endpoint.

    <Note>
      Optionally, if you'd like Infisical to manage the credentials of this connection, you can set the `isPlatformManagedCredentials` option to `true`.
      If enabled, Infisical will update the password of the connection on creation to prevent external access to this database user.
    </Note>

    ### Sample request

    ```bash Request theme={"dark"}
    curl    --request POST \
    --url https://app.infisical.com/api/v1/app-connections/oracledb \
    --header 'Content-Type: application/json' \
    --data '{
        "name": "my-oracledb-connection",
        "method": "username-and-password",
        "isPlatformManagedCredentials": true,
        "projectId": "7ffbb072-2575-495a-b5b0-127f88caef78",
        "credentials": {
            "host": "123.4.5.6",
            "port": 1521,
            "database": "FREEPDB1",
            "username": "infisical",
            "password": "my-password",
            "sslEnabled": true,
            "sslRejectUnauthorized": true
        },
    }'
    ```

    ### Sample response

    ```bash Response theme={"dark"}
    {
        "appConnection": {
            "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "name": "my-oracledb-connection",
            "projectId": "7ffbb072-2575-495a-b5b0-127f88caef78",
            "version": 1,
            "orgId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "createdAt": "2023-11-07T05:31:56Z",
            "updatedAt": "2023-11-07T05:31:56Z",
            "app": "oracledb",
            "method": "username-and-password",
            "isPlatformManagedCredentials": true,
            "credentials": {
                "host": "123.4.5.6",
                "port": 1521,
                "database": "FREEPDB1",
                "username": "infisical",
                "sslEnabled": true,
                "sslRejectUnauthorized": true
            }
        }
    }
    ```
  </Tab>
</Tabs>


# null
Source: https://infisical.com/docs/integrations/app-connections/overview

Learn how to manage and configure third-party app connections with Infisical.

App Connections enable you to integrate your Infisical projects with third-party services in a secure and versatile way.

<Note>
  App connections can also be created and managed independently in projects now.
</Note>

## Concept

App Connections can be used to establish connections with third-party applications
that can be used across multiple features. Example use cases include syncing secrets, rotating credentials, scanning repositories for secret leaks, and more.

<br />

<div align="center">
  ```mermaid  theme={"dark"}
  %%{init: {'flowchart': {'curve': 'linear'} } }%%
  graph TD
  A[AWS]
  B[AWS Connection]
  C[Project 1 Secret Sync]
  D[Project 2 Secret Sync]
  E[Project 3 Generate Dynamic Secret]

  B --> A
  C --> B
  D --> B
  E --> B

  classDef default fill:#ffffff,stroke:#666,stroke-width:2px,rx:10px,color:black
  classDef aws fill:#FFF2B2,stroke:#E6C34A,stroke-width:2px,color:black,rx:15px
  classDef project fill:#E6F4FF,stroke:#0096D6,stroke-width:2px,color:black,rx:15px
  classDef connection fill:#F4FFE6,stroke:#96D600,stroke-width:2px,color:black,rx:15px

  class A aws
  class B connection
  class C,D,E project
  ```
</div>

## Workflow

App Connections require initial setup in both your third-party application and Infisical. Follow these steps to establish a secure connection:

<Note>
  For step-by-step guides specific to each application, refer to the App Connections section in the Navigation Bar.
</Note>

1. <strong>Create Access Entity:</strong> If necessary, create an entity such as a service account or role within the third-party application you want to connect to. Be sure
   to limit the access of this entity to the minimal permission set required to perform the operations you need. For example:
   * For secret syncing: Read/write permissions to specific secret stores
   * For dynamic secrets: Permissions to create temporary credentials

<Tip>
  Whenever possible, Infisical encourages creating a designated service account for your App Connection to limit the scope of permissions based on your use-case.
</Tip>

2. <strong>Generate Authentication Credentials:</strong> Obtain the required credentials from your third-party application. These can vary between applications and might be:
   * an API key or access token
   * A client ID and secret pair
   * other credentials, etc.

3. <strong>Create App Connection:</strong> Configure the connection in Infisical using your generated credentials through either the UI or API.

<Info>
  Some App Connections can only be created via the UI such as connections using OAuth.
</Info>

4. <strong>Utilize the Connection:</strong> Use your App Connection for various features across Infisical such as our Secrets Sync by selecting it via the dropdown menu
   in the UI or by passing the associated `connectionId` when generating resources via the API.

<Note>
  Infisical is continuously expanding its third-party application support. If your desired application isn't listed,
  you can still use previous methods of connecting to it such as our Native Integrations.
</Note>

## Platform Managed Credentials

Some App Connections support the ability to have their credentials managed by Infisical. By enabling this option,
Infisical will modify the credentials to prevent external use of the configured access entity.


# PostgreSQL Connection
Source: https://infisical.com/docs/integrations/app-connections/postgres

Learn how to configure a PostgreSQL Connection for Infisical.

Infisical supports connecting to PostgreSQL using a database role.

## Configure a PostgreSQL Role for Infisical

<Steps>
  <Step title="Create a Role">
    Infisical recommends creating a designated role in your PostgreSQL database for your connection.

    ```SQL  theme={"dark"}
    -- create user role
    CREATE ROLE infisical_role WITH LOGIN PASSWORD 'my-password';

    -- grant login access to the specified database
    GRANT CONNECT ON DATABASE my_database TO infisical_role;
    ```
  </Step>

  <Step title="Grant Relevant Permissions">
    Depending on how you intend to use your PostgreSQL connection, you'll need to grant one or more of the following permissions.

    <Tip>
      To learn more about PostgreSQL's permission system, please visit their [documentation](https://www.postgresql.org/docs/current/sql-grant.html).
    </Tip>

    <Tabs>
      <Tab title="Secret Rotation">
        For Secret Rotations, your Infisical user will require the ability to alter other users' passwords:

        ```SQL  theme={"dark"}
        -- enable permissions to alter login credentials
        ALTER ROLE infisical_role WITH CREATEROLE;
        ```

        <Tip>
          In some configurations, the role performing the rotation must be explicitly granted access to manage each user. To do this, grant the user's role to the rotation role with:

          ```SQL  theme={"dark"}
          -- grant each user role to admin user for password rotation
          GRANT <secret_rotation_user> TO <infisical_role> WITH ADMIN OPTION;
          ```

          Replace `<secret_rotation_user>` with each specific username whose credentials will be rotated, and `<infisical_role>` with the role that will perform the rotation.
        </Tip>
      </Tab>
    </Tabs>
  </Step>

  <Step title="Get Connection Details">
    You'll need the following information to create your PostgreSQL connection:

    * `host` - The hostname or IP address of your PostgreSQL server
    * `port` - The port number your PostgreSQL server is listening on (default: 5432)
    * `database` - The name of the specific database you want to connect to
    * `username` - The role name of the login created in the steps above
    * `password` - The role password of the login created in the steps above
    * `sslCertificate` (optional) - The SSL certificate required for connection (if configured)

    <Note>
      If you are self-hosting Infisical and intend to connect to an internal/private IP address, be sure to set the `ALLOW_INTERNAL_IP_CONNECTIONS` environment variable to `true`.
    </Note>
  </Step>
</Steps>

## Create Connection in Infisical

<Tabs>
  <Tab title="Infisical UI">
    1. Navigate to the **App Connections** page in the desired project.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/general/add-connection.png" alt="App Connections Tab" />

    2. Select the **PostgreSQL Connection** option.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/postgres/select-postgres-connection.png" alt="Select PostgreSQL Connection" />

    3. Select the **Username & Password** method option and provide the details obtained from the previous section and press **Connect to PostgreSQL**.

    <Note>
      Optionally, if you'd like Infisical to manage the credentials of this connection, you can enable the Platform Managed Credentials option.
      If enabled, Infisical will update the password of the connection on creation to prevent external access to this database role.
    </Note>

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/postgres/create-username-and-password-method.png" alt="Create PostgreSQL Connection" />

    4. Your **PostgreSQL Connection** is now available for use.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/postgres/username-and-password-connection.png" alt="Assume Role PostgreSQL Connection" />
  </Tab>

  <Tab title="API">
    To create a PostgreSQL Connection, make an API request to the [Create PostgreSQL
    Connection](/api-reference/endpoints/app-connections/postgres/create) API endpoint.

    <Note>
      Optionally, if you'd like Infisical to manage the credentials of this connection, you can set the `isPlatformManagedCredentials` option to `true`.
      If enabled, Infisical will update the password of the connection on creation to prevent external access to this database role.
    </Note>

    ### Sample request

    ```bash Request theme={"dark"}
    curl    --request POST \
    --url https://app.infisical.com/api/v1/app-connections/postgres \
    --header 'Content-Type: application/json' \
    --data '{
        "name": "my-pg-connection",
        "method": "username-and-password",
        "isPlatformManagedCredentials": true,
        "projectId": "7ffbb072-2575-495a-b5b0-127f88caef78",
        "credentials": {
            "host": "123.4.5.6",
            "port": 5432,
            "database": "default",
            "username": "infisical_role",
            "password": "my-password",
            "sslEnabled": true,
            "sslRejectUnauthorized": true
        },
    }'
    ```

    ### Sample response

    ```bash Response theme={"dark"}
    {
        "appConnection": {
            "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "name": "my-pg-connection",
            "projectId": "7ffbb072-2575-495a-b5b0-127f88caef78",
            "version": 1,
            "orgId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "createdAt": "2023-11-07T05:31:56Z",
            "updatedAt": "2023-11-07T05:31:56Z",
            "app": "postgres",
            "method": "username-and-password",
            "isPlatformManagedCredentials": true,
            "credentials": {
                "host": "123.4.5.6",
                "port": 5432,
                "database": "default",
                "username": "infisical_role",
                "sslEnabled": true,
                "sslRejectUnauthorized": true
            }
        }
    }
    ```
  </Tab>
</Tabs>


# Railway Connection
Source: https://infisical.com/docs/integrations/app-connections/railway

Learn how to configure a Railway Connection for Infisical.

Infisical supports the use of [API Tokens](https://docs.railway.com/guides/public-api#creating-a-token) to connect with Railway.

## Create a Railway API Token

<Tabs>
  <Tab title="Team Token">
    A team token provides access to all resources within a team. It cannot be used to access personal resources in Railway.

    <Steps>
      <Step title="Click the profile image in the top-right corner and select 'Account Settings'">
                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/railway/railway-app-connection-account-settings.png" alt="Dashboard Page" />
      </Step>

      <Step title="In the personal settings sidebar, click on 'Tokens'">
                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/railway/railway-app-connection-account-settings-tokens.png" alt="Account Settings Page" />
      </Step>

      <Step title="Enter a token name and select a team">
        Make sure to provide a descriptive name and select the correct team.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/railway/railway-app-connection-team-token-form.png" alt="Enter Name and Select Team" />
      </Step>

      <Step title="Click on 'Create'">
                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/railway/railway-app-connection-team-token-create.png" alt="Create Token" />
      </Step>

      <Step title="Save the token">
        After clicking 'Create', your access token will be displayed. Save it securely for later use.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/railway/railway-app-connection-team-token-created.png" alt="Copy Token Modal" />
      </Step>
    </Steps>
  </Tab>

  <Tab title="Account Token">
    If no team is selected, the token will be associated with your personal Railway account and will have access to all your individual and team resources.

    <Steps>
      <Step title="Click the profile image in the top-right corner and select 'Account Settings'">
                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/railway/railway-app-connection-account-settings.png" alt="Dashboard Page" />
      </Step>

      <Step title="In the personal settings sidebar, click on 'Tokens'">
                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/railway/railway-app-connection-account-settings-tokens.png" alt="Account Settings Page" />
      </Step>

      <Step title="Enter a token name and select 'No workspace'">
        Provide a descriptive name and ensure no team is selected. This will create an account-level token.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/railway/railway-app-connection-account-token-form.png" alt="Enter Name" />
      </Step>

      <Step title="Click on 'Create'">
                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/railway/railway-app-connection-account-token-create.png" alt="Create Token" />
      </Step>

      <Step title="Save the token">
        After clicking 'Create', your access token will be shown. Save it for future use.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/railway/railway-app-connection-account-token-created.png" alt="Copy Token Modal" />
      </Step>
    </Steps>
  </Tab>

  <Tab title="Project Token">
    Project tokens are limited to a specific environment within a project and can only be used to authenticate requests to that environment.

    <Steps>
      <Step title="Open your Railway dashboard and click on a project">
                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/railway/railway-app-connection-project-token-dashboard.png" alt="Dashboard Page" />
      </Step>

      <Step title="On the project page, click 'Settings' in the top-right corner">
                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/railway/railway-app-connection-project-token-project.png" alt="Project Settings Page" />
      </Step>

      <Step title="In the left sidebar, scroll to the bottom and click on 'Tokens'">
                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/railway/railway-app-connection-project-token-settings.png" alt="Project Token Settings Page" />
      </Step>

      <Step title="Enter a token name and select an environment">
        Provide a descriptive name and select the appropriate environment for the token.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/railway/railway-app-connection-project-token-form.png" alt="Enter Name and Select environment" />
      </Step>

      <Step title="Click on 'Create'">
                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/railway/railway-app-connection-project-token-create.png" alt="Create Token" />
      </Step>

      <Step title="Save the token">
        After clicking 'Create', the access token will be displayed. Be sure to save it for later use.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/railway/railway-app-connection-project-token-created.png" alt="Copy Token Modal" />
      </Step>
    </Steps>
  </Tab>
</Tabs>

## Create a Railway Connection in Infisical

<Tabs>
  <Tab title="Infisical UI">
    <Steps>
      <Step title="Navigate to App Connections">
        In your Infisical dashboard, navigate to the **App Connections** page in the desired project.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/general/add-connection.png" alt="App Connections Tab" />
      </Step>

      <Step title="Select Railway Connection">
        Click **+ Add Connection** and choose **Railway Connection** from the list of integrations.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/railway/railway-app-connection-option.png" alt="Select Railway Connection" />
      </Step>

      <Step title="Fill out the Railway Connection form">
        Complete the form by providing:

        * A descriptive name for the connection
        * An optional description
        * The type of token you created earlier
        * The token value from the previous step

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/railway/railway-app-connection-form.png" alt="Railway Connection Modal" />
      </Step>

      <Step title="Connection created">
        After submitting the form, your **Railway Connection** will be successfully created and ready to use with your Infisical project.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/railway/railway-app-connection-generated.png" alt="Railway Connection Created" />
      </Step>
    </Steps>
  </Tab>

  <Tab title="API">
    To create a Railway Connection via API, send a request to the [Create Railway Connection](/api-reference/endpoints/app-connections/railway/create) endpoint.

    ### Sample request

    ```bash Request theme={"dark"}
    curl    --request POST \
            --url https://app.infisical.com/api/v1/app-connections/railway \
            --header 'Content-Type: application/json' \
            --data '{
                "name": "my-railway-connection",
                "method": "team-token",
                "projectId": "7ffbb072-2575-495a-b5b0-127f88caef78",
                "credentials": {
                    "apiToken": "[TEAM TOKEN]"
                }
            }'
    ```

    ### Sample response

    ```bash Response theme={"dark"}
    {
      "appConnection": {
          "id": "e5d18aca-86f7-4026-a95e-efb8aeb0d8e6",
          "name": "my-railway-connection",
          "projectId": "7ffbb072-2575-495a-b5b0-127f88caef78",
          "description": null,
          "version": 1,
          "orgId": "6f03caa1-a5de-43ce-b127-95a145d3464c",
          "createdAt": "2025-04-23T19:46:34.831Z",
          "updatedAt": "2025-04-23T19:46:34.831Z",
          "isPlatformManagedCredentials": false,
          "credentialsHash": "7c2d371dec195f82a6a0d5b41c970a229cfcaf88e894a5b6395e2dbd0280661f",
          "app": "railway",
          "method": "team-token",
          "credentials": {}
      }
    }
    ```
  </Tab>
</Tabs>


# Redis Connection
Source: https://infisical.com/docs/integrations/app-connections/redis

Learn how to configure a Redis Connection for Infisical.

Infisical supports the use of Username & Password authentication to connect with Redis databases

## Configure a Redis user for Infisical

<Steps>
  <Step title="Create a Redis user">
    Infisical recommends creating a designated user in your Redis database for your connection.

    ```bash  theme={"dark"}
    ACL SETUSER user_manager on >[ENTER-YOUR-USER-PASSWORD]
    ```
  </Step>

  <Step title="Grant Relevant Permissions">
    Depending on how you intend to use your Redis connection, you'll need to grant one or more of the following permissions.

    <Tip>
      To learn more about Redis's permission system, please visit their [documentation](https://redis.io/docs/latest/operate/oss_and_stack/management/security/acl/).
    </Tip>

    <Tabs>
      <Tab title="Secret Rotation">
        For Secret Rotations, your Infisical user will require the ability to set and delete users:

        ```bash  theme={"dark"}
        ACL SETUSER user_manager +acl|setuser +acl|deluser ~*
        ```
      </Tab>
    </Tabs>
  </Step>
</Steps>

## Create Redis Connection in Infisical

<Tabs>
  <Tab title="Infisical UI">
    <Steps>
      <Step title="Navigate to App Connections">
        In your Infisical dashboard, navigate to the **App Connections** page in the desired project.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/general/add-connection.png" alt="App Connections Tab" />
      </Step>

      <Step title="Select Redis Connection">
        Click the **+ Add Connection** button and select the **Redis Connection** option from the available integrations.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/redis/redis-app-connection-option.png" alt="Select Redis Connection" />
      </Step>

      <Step title="Fill out the Redis Connection Modal">
        Complete the Redis Connection form by entering:

        * A descriptive name for the connection
        * An optional description for future reference
        * The Redis host URL for your database
        * The Redis port for your Redis database
        * The Redis username for your Redis database
        * The Redis password for your Redis database

        You can optionally configure SSL/TLS for your Redis connection in the **SSL** section.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/redis/redis-app-connection-form.png" alt="Redis Connection Modal" />
      </Step>

      <Step title="Connection Created">
        After clicking Create, your **Redis Connection** is established and ready to use with your Infisical project.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/redis/redis-app-connection-generated.png" alt="Redis Connection Created" />
      </Step>
    </Steps>
  </Tab>

  <Tab title="API">
    To create a Redis Connection, make an API request to the [Create Redis Connection](/api-reference/endpoints/app-connections/redis/create) API endpoint.

    ### Sample request

    ```bash Request theme={"dark"}
    curl    --request POST \
            --url https://app.infisical.com/api/v1/app-connections/redis \
            --header 'Content-Type: application/json' \
            --data '{
                "name": "my-redis-connection",
                "method": "username-and-password",
                "projectId": "7ffbb072-2575-495a-b5b0-127f88caef78",
                "credentials": {
                    "host": "[REDIS HOST]",
                    "port": 6379,
                    "username": "[REDIS USERNAME]",
                    "password": "[REDIS PASSWORD]",
                }
            }'
    ```

    ### Sample response

    ```bash Response theme={"dark"}
    {
      "appConnection": {
          "id": "e5d18aca-86f7-4026-a95e-efb8aeb0d8e6",
          "name": "my-redis-connection",
          "projectId": "7ffbb072-2575-495a-b5b0-127f88caef78",
          "description": null,
          "version": 1,
          "orgId": "6f03caa1-a5de-43ce-b127-95a145d3464c",
          "createdAt": "2025-04-23T19:46:34.831Z",
          "updatedAt": "2025-04-23T19:46:34.831Z",
          "isPlatformManagedCredentials": false,
          "credentialsHash": "7c2d371dec195f82a6a0d5b41c970a229cfcaf88e894a5b6395e2dbd0280661f",
          "app": "redis",
          "method": "username-and-password",
          credentials: {
            "host": "<redis-host>",
            "port": 6379,
            "username": "<redis-username>",
            "sslEnabled": true,
            "sslRejectUnauthorized": false,
            "sslCertificate": "<redis-ssl-certificate>"
          }
      }
    }
    ```
  </Tab>
</Tabs>


# Render Connection
Source: https://infisical.com/docs/integrations/app-connections/render

Learn how to configure a Render Connection for Infisical.

Infisical supports connecting to Render using API keys for secure access to your Render services.

## Configure API Key for Infisical

<Steps>
  <Step title="Access Account Settings">
    Navigate to your Render dashboard and click on **Account Settings** in the
    top right corner. <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/render/render-account-settings.png" alt="Account
    Settings" />
  </Step>

  <Step title="Generate API Key">
    In the Account Settings page, scroll down to the **API Keys** section and
    click **Create API Key**. <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/render/render-create-api-key.png" alt="Create API
    Key" />
  </Step>

  <Step title="Name Your API Key">
    Enter a descriptive name for your API key (e.g., "production")
    and click **Create API Key**. <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/render/render-name-api-key.png" alt="Name API
    Key" />
  </Step>

  <Step title="Save Your API Key">
    After creation, you'll be shown your API key. Make sure to copy and securely
    store this key as it will not be shown again.
  </Step>
</Steps>

## Setup Render Connection in Infisical

<Steps>
  <Step title="Navigate to App Connections">
    Navigate to the **App Connections** page in the desired project. <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/general/add-connection.png" alt="App Connections
    Tab" />
  </Step>

  <Step title="Add Connection">
    Select the **Render Connection** option from the connection options modal.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/render/render-app-connection-select.png" alt="Select Render
    Connection" />
  </Step>

  <Step title="Input API Key">
    Enter your Render API key in the provided field and click **Connect to
    Render** to establish the connection. <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/render/render-app-connection-form.png" alt="Connect to
    Render" />
  </Step>

  <Step title="Connection Created">
    Your **Render Connection** is now available for use in your Infisical
    projects. <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/render/render-app-connection-created.png" alt="Render Connection
    Created" />
  </Step>
</Steps>


# Supabase Connection
Source: https://infisical.com/docs/integrations/app-connections/supabase

Learn how to configure a Supabase Connection for Infisical.

Infisical supports the use of [Personal Access Tokens](https://supabase.com/dashboard/account/tokens) to connect with Supabase.

## Create a Supabase Personal Access Token

<Steps>
  <Step title="Click the profile image in the top-right corner and select 'Account Preferences'">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/supabase/app-connection-user-settings.png" alt="Account Preferences" />
  </Step>

  <Step title="In the sidebar, select 'Access Tokens'">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/supabase/app-connection-api-keys.png" alt="Settings Page" />
  </Step>

  <Step title="In the access tokens page, click on 'Generate New Token'">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/supabase/app-connection-create-api-key.png" alt="Access Tokens Page" />
  </Step>

  <Step title="Enter a token name and click on 'Generate Token'">
    Provide a descriptive name for the token.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/supabase/app-connection-create-form.png" alt="Enter Name" />
  </Step>

  <Step title="Copy the generated token and save it">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/supabase/app-connection-key-generated.png" alt="Create Token" />
  </Step>
</Steps>

## Create a Supabase Connection in Infisical

<Tabs>
  <Tab title="Infisical UI">
    <Steps>
      <Step title="Navigate to App Connections">
        In your Infisical dashboard, navigate to the **App Connections** page in the desired project.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/general/add-connection.png" alt="App Connections Tab" />
      </Step>

      <Step title="Select Supabase Connection">
        Click **+ Add Connection** and choose **Supabase Connection** from the list of integrations.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/supabase/app-connection-option.png" alt="Select Supabase Connection" />
      </Step>

      <Step title="Fill out the Supabase Connection form">
        Complete the form by providing:

        * A descriptive name for the connection
        * An optional description
        * Supabase instance URL (e.g., `https://your-domain.com` or `https://api.supabase.com`)
        * The Access Token value from the previous step

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/supabase/app-connection-form.png" alt="Supabase Connection Modal" />
      </Step>

      <Step title="Connection created">
        After submitting the form, your **Supabase Connection** will be successfully created and ready to use with your Infisical project.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/supabase/app-connection-generated.png" alt="Supabase Connection Created" />
      </Step>
    </Steps>
  </Tab>

  <Tab title="API">
    To create a Supabase Connection via API, send a request to the [Create Supabase Connection](/api-reference/endpoints/app-connections/supabase/create) endpoint.

    ### Sample request

    ```bash Request theme={"dark"}
    curl    --request POST \
            --url https://app.infisical.com/api/v1/app-connections/supabase \
            --header 'Content-Type: application/json' \
            --data '{
                "name": "my-supabase-connection",
                "method": "access-token",
                "projectId": "7ffbb072-2575-495a-b5b0-127f88caef78",
                "credentials": {
                    "accessToken": "[Access Token]",
                    "instanceUrl": "https://api.supabase.com"
                }
            }'
    ```

    ### Sample response

    ```bash Response theme={"dark"}
    {
      "appConnection": {
          "id": "e5d18aca-86f7-4026-a95e-efb8aeb0d8e6",
          "name": "my-supabase-connection",
          "projectId": "7ffbb072-2575-495a-b5b0-127f88caef78",
          "description": null,
          "version": 1,
          "orgId": "6f03caa1-a5de-43ce-b127-95a145d3464c",
          "createdAt": "2025-04-23T19:46:34.831Z",
          "updatedAt": "2025-04-23T19:46:34.831Z",
          "isPlatformManagedCredentials": false,
          "credentialsHash": "7c2d371dec195f82a6a0d5b41c970a229cfcaf88e894a5b6395e2dbd0280661f",
          "app": "supabase",
          "method": "access-token",
          "credentials": {
            "instanceUrl": "https://api.supabase.com"
          }
      }
    }
    ```
  </Tab>
</Tabs>


# TeamCity Connection
Source: https://infisical.com/docs/integrations/app-connections/teamcity

Learn how to configure a TeamCity Connection for Infisical.

Infisical supports connecting to TeamCity using Access Tokens.

## Setup TeamCity Connection in Infisical

<Steps>
  <Step title="Navigate to your profile on TeamCity">
    Navigate to the TeamCity **Profile** page by clicking on your profile icon in the bottom-left corner.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/teamcity/teamcity-main-page.png" alt="TeamCity Main Page" />
  </Step>

  <Step title="Select Access Tokens Tab">
    Select the **Access Tokens** tab from the left sidebar navigation menu.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/teamcity/teamcity-token-page.png" alt="TeamCity Token Page" />
  </Step>

  <Step title="Create the Access Token">
    Click the **Create access token** button and provide a name for your token (e.g., "Infisical Integration"). You may set an expiration date or leave it blank for no expiry.
    The permission scope can either be **Same as current user** or **Limit per project**.

    If you're choosing **Limit per project**, make sure you select the relevant project and enable the permissions relevant to your use case:

    <Tabs>
      <Tab title="Secret Sync Permissions">
        * View build configuration settings
        * Edit project
      </Tab>
    </Tabs>

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/teamcity/teamcity-token-popup.png" alt="TeamCity Token Popup" />

    <Note>
      Setting your permission scope to **Same as current user** will allow your integration to access multiple projects as long as the current user has read and write access to them.
    </Note>

    <Note>
      If you configure an expiry date for your access token, you must manually rotate to a new token before the expiration date to prevent service interruption.
    </Note>
  </Step>

  <Step title="Copy the Access Token">
    After creation, a modal with the Access Token will be displayed. Copy this token immediately and store it securely, as you won't be able to view it again after closing this dialog.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/teamcity/teamcity-token-copy.png" alt="TeamCity Token Copy Popup" />
  </Step>

  <Step title="Token Created">
    You should now see your newly created token in the list of access tokens.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/teamcity/teamcity-token-created.png" alt="TeamCity Token Created" />
  </Step>

  <Step title="Setup TeamCity Connection in Infisical">
    <Tabs>
      <Tab title="Infisical UI">
        1. Navigate to App Connections

           In your Infisical dashboard, navigate to the **App Connections** page in the desired project.
           <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/general/add-connection.png" alt="App Connections Tab" />
        2. Add Connection

           Click the **+ Add Connection** button and select the **TeamCity Connection** option from the available integrations.
           <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/teamcity/teamcity-app-connection-option.png" alt="Select TeamCity Connection" />
        3. Fill the TeamCity Connection Modal

           Complete the TeamCity Connection form by entering:

           * A descriptive name for the connection
           * The Access Token you generated in steps 3-4
           * The URL of your TeamCity instance
           * An optional description for future reference

           <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/teamcity/teamcity-app-connection-modal.png" alt="TeamCity Connection Modal" />
        4. Connection Created

           After clicking Create, your **TeamCity Connection** is established and ready to use with your Infisical project.
           <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/teamcity/teamcity-app-connection-created.png" alt="TeamCity Connection Created" />
      </Tab>

      <Tab title="API">
        To create a TeamCity Connection, make an API request to the [Create TeamCity
        Connection](/api-reference/endpoints/app-connections/teamcity/create) API endpoint.

        ### Sample request

        ```bash Request theme={"dark"}
        curl    --request POST \
                --url https://app.infisical.com/api/v1/app-connections/teamcity \
                --header 'Content-Type: application/json' \
                --data '{
                    "name": "my-teamcity-connection",
                    "method": "access-token",
                    "projectId": "7ffbb072-2575-495a-b5b0-127f88caef78",
                    "credentials": {
                        "accessToken": "...",
                        "instanceUrl": "https://yourcompany.teamcity.com"
                    }
                }'
        ```

        ### Sample response

        ```bash Response theme={"dark"}
        {
          "appConnection": {
            "id": "e5d18aca-86f7-4026-a95e-efb8aeb0d8e6",
            "name": "my-teamcity-connection",
            "projectId": "7ffbb072-2575-495a-b5b0-127f88caef78",
            "description": null,
            "version": 1,
            "orgId": "6f03caa1-a5de-43ce-b127-95a145d3464c",
            "createdAt": "2025-04-23T19:46:34.831Z",
            "updatedAt": "2025-04-23T19:46:34.831Z",
            "isPlatformManagedCredentials": false,
            "credentialsHash": "7c2d371dec195f82a6a0d5b41c970a229cfcaf88e894a5b6395e2dbd0280661f",
            "app": "teamcity",
            "method": "access-token",
            "credentials": {
              "instanceUrl": "https://yourcompany.teamcity.com"
            }
          }
        }
        ```
      </Tab>
    </Tabs>
  </Step>
</Steps>


# Terraform Cloud Connection
Source: https://infisical.com/docs/integrations/app-connections/terraform-cloud

Learn how to configure a Terraform Cloud Connection for Infisical.

Infisical supports connecting to Terraform Cloud using a service user.

## Setup Terraform Cloud Connection in Infisical

<Steps>
  <Step title="Move to Account Settings on Terraform Cloud">
    Navigate to the Terraform Cloud **Account Settings** tab.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/terraform-cloud/terraform-cloud-account-settings.png" alt="Terraform Cloud Account Settings" />
  </Step>

  <Step title="Move to Tokens Tab">
    Move to the **Tokens** tab.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/terraform-cloud/terraform-cloud-tokens-tab.png" alt="Terraform Cloud Tokens Tab" />
  </Step>

  <Step title="Create the API Token">
    Create the API token to be used by Infisical.

    <Note>
      If you configure an expiry date for your API token you will need to manually rotate to a new token prior to expiration to avoid integration downtime.
    </Note>

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/terraform-cloud/terraform-cloud-create-api-token.png" alt="Terraform Cloud Create API Token" />
  </Step>

  <Step title="Copy the API Token">
    The API token will be displayed after creating it. Save the token in a secure location for later use in the following steps.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/terraform-cloud/terraform-cloud-copy-api-token.png" alt="Terraform Cloud Copy API Token" />
  </Step>

  <Step title="Add Terraform Cloud Connection in Infisical">
    <Tabs>
      <Tab title="Infisical UI">
        1. Navigate to the **App Connections** page in the desired project.
           <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/general/add-connection.png" alt="App Connections Tab" />
        2. Select the **Terraform Cloud Connection** option from the connection options modal.
           <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/terraform-cloud/terraform-cloud-app-connection-option.png" alt="Select Terraform Cloud Connection" />
        3. Fill out the Terraform Cloud Connection modal, here you will need to provide the API Token generated in the previous step.
           <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/terraform-cloud/terraform-cloud-app-connection-modal.png" alt="Terraform Cloud Connection Modal" />
        4. Your **Terraform Cloud Connection** is now available for use.
           <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/terraform-cloud/terraform-cloud-app-connection-created.png" alt="Terraform Cloud Connection Created" />
      </Tab>

      <Tab title="API">
        To create an Terraform Cloud Connection, make an API request to the [Create Terraform Cloud
        Connection](/api-reference/endpoints/app-connections/terraform-cloud/create) API endpoint.

        ### Sample request

        ```bash Request theme={"dark"}
        curl    --request POST \
                --url https://app.infisical.com/api/v1/app-connections/terraform-cloud \
                --header 'Content-Type: application/json' \
                --data '{
                    "name": "my-terraform-cloud-connection",
                    "method": "api-token",
                    "projectId": "7ffbb072-2575-495a-b5b0-127f88caef78",
                    "credentials": {
                        "apiToken": "...",
                    }
                }'
        ```

        ### Sample response

        ```bash Response theme={"dark"}
        {
            "appConnection": {
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                "name": "my-terraform-cloud-connection",
                "projectId": "7ffbb072-2575-495a-b5b0-127f88caef78",
                "version": 123,
                "orgId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                "createdAt": "2023-11-07T05:31:56Z",
                "updatedAt": "2023-11-07T05:31:56Z",
                "app": "terraform-cloud",
                "method": "api-token",
                "credentials": {
                    "apiToken": "..."
                }
            }
        }
        ```
      </Tab>
    </Tabs>
  </Step>
</Steps>


# Vercel Connection
Source: https://infisical.com/docs/integrations/app-connections/vercel

Learn how to configure a Vercel Connection for Infisical.

Infisical supports connecting to Vercel using API Tokens.

## Setup Vercel Connection in Infisical

<Steps>
  <Step title="Move to API Tokens on Vercel">
    Navigate to the Vercel **Account Settings** page by clicking on your profile icon in the top-right corner.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/vercel/vercel-main-page.png" alt="Vercel API Tokens Tab" />
  </Step>

  <Step title="Open API Tokens Tab">
    Select the **API Tokens** tab from the left sidebar navigation menu.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/vercel/vercel-settings-page.png" alt="Vercel API Tokens Tab" />
  </Step>

  <Step title="Create the API Token">
    Click the **Create** button and provide a name for your token (e.g., "Infisical Integration").
    Choose appropriate scope permissions based on your requirements.

    <Note>
      If you configure an expiry date for your API token, you will need to manually rotate to a new token prior to expiration to avoid integration downtime. Consider setting a calendar reminder for this task.
    </Note>

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/vercel/vercel-create-token.png" alt="Vercel Create API Token" />
  </Step>

  <Step title="Copy the API Token">
    After creation, a modal with the API token will be displayed. Copy this token immediately and store it securely, as you won't be able to view it again after closing this dialog.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/vercel/vercel-copy-token.png" alt="Vercel Copy API Token" />
  </Step>

  <Step title="Token Created">
    You should now see your newly created token in the list of API tokens on the Vercel dashboard.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/vercel/vercel-token-created.png" alt="Vercel Connection Created" />
  </Step>

  <Step title="Setup Vercel Connection in Infisical">
    <Tabs>
      <Tab title="Infisical UI">
        1. Navigate to App Connections

           In your Infisical dashboard, navigate to the **App Connections** page in the desired project.
           <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/general/add-connection.png" alt="App Connections Tab" />
        2. Add Connection

           Click the **+ Add Connection** button and select the **Vercel Connection** option from the available integrations.
           <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/vercel/vercel-app-connection-option.png" alt="Select Vercel Connection" />
        3. Fill the Vercel Connection Modal

           Complete the Vercel Connection form by entering:

           * A descriptive name for the connection
           * The API Token you generated in steps 3-4
           * An optional description for future reference
             <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/vercel/vercel-app-connection-modal.png" alt="Vercel Connection Modal" />
        4. Connection Created

           After clicking Create, your **Vercel Connection** is established and ready to use with your Infisical project.
           <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/vercel/vercel-app-connection-created.png" alt="Vercel Connection Created" />
      </Tab>

      <Tab title="API">
        To create a Vercel Connection, make an API request to the [Create Vercel
        Connection](/api-reference/endpoints/app-connections/vercel/create) API endpoint.

        ### Sample request

        ```bash Request theme={"dark"}
        curl    --request POST \
                --url https://app.infisical.com/api/v1/app-connections/vercel \
                --header 'Content-Type: application/json' \
                --data '{
                    "name": "my-vercel-connection",
                    "projectId": "7ffbb072-2575-495a-b5b0-127f88caef78",
                    "method": "api-token",
                    "credentials": {
                        "apiToken": "...",
                    }
                }'
        ```

        ### Sample response

        ```bash Response theme={"dark"}
        {
            "appConnection": {
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                "name": "my-vercel-connection",
                "projectId": "7ffbb072-2575-495a-b5b0-127f88caef78",
                "version": 123,
                "orgId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                "createdAt": "2025-04-01T05:31:56Z",
                "updatedAt": "2025-04-01T05:31:56Z",
                "app": "vercel",
                "method": "api-token",
                "credentials": {}
            }
        }
        ```
      </Tab>
    </Tabs>
  </Step>
</Steps>


# Windmill Connection
Source: https://infisical.com/docs/integrations/app-connections/windmill

Learn how to configure a Windmill Connection for Infisical.

Infisical supports connecting to Windmill using Access Tokens.

## Get a Windmill Access Token

Ensure the user generating the access token has the required role and permissions based on your use-case:

<Tabs>
  <Tab title="Secret Sync">
    <Note>
      The user generating the access token should be at least a `Developer` in the configured workspace and have `write` permissions for the workspace path secrets will be synced to.
    </Note>
  </Tab>
</Tabs>

<Steps>
  <Step title="Navigate to Account Settings">
    In Windmill, click on your user in the sidebar and select **Account Settings**.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/windmill/windmill-account-settings.png" alt="Windmill Account Settings" />
  </Step>

  <Step title="Access Token Section">
    In the **Tokens** section on the drawer, click **Create token**.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/windmill/windmill-create-token.png" alt="Windmill Create Token" />
  </Step>

  <Step title="Create Access Token">
    Give your token a name and click **New token**.

    <Note>
      If you configure an expiry date for your access token, you must manually rotate to a new token before the expiration date to prevent service interruption.
    </Note>

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/windmill/windmill-new-token.png" alt="Windmill New Token" />
  </Step>

  <Step title="Copy Access Token">
    Copy your new access token and save it for the steps below.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/windmill/windmill-copy-token.png" alt="Windmill Copy Token" />
  </Step>
</Steps>

## Setup Windmill Connection in Infisical

<Tabs>
  <Tab title="Infisical UI">
    <Steps>
      <Step title="Navigate to App Connections">
        In your Infisical dashboard, navigate to the **App Connections** page in the desired project.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/general/add-connection.png" alt="App Connections Tab" />
      </Step>

      <Step title="Add Connection">
        Click the **+ Add Connection** button and select the **Windmill Connection** option.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/windmill/select-windmill-connection.png" alt="Select Windmill Connection" />
      </Step>

      <Step title="Configure Connection">
        Configure your Windmill Connection using the access token generated in the steps above. Then click **Connect to Windmill**.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/windmill/create-windmill-access-token.png" alt="Windmill Configure Connection" />

        * **Name**: The name of the connection to be created. Must be slug-friendly.
        * **Description**: An optional description to provide details about this connection.
        * **Instance URL**: The URL of your Windmill instance. If you are not self-hosting Windmill you can leave this field blank.
        * **Access Token**: The access token generated in the steps above.
      </Step>

      <Step title="Connection Created">
        Your Windmill Connection is now available for use.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/windmill/windmill-access-token-created.png" alt="Windmill Connection Created" />
      </Step>
    </Steps>
  </Tab>

  <Tab title="API">
    To create a Windmill Connection, make an API request to the [Create Windmill
    Connection](/api-reference/endpoints/app-connections/windmill/create) API endpoint.

    ### Sample request

    ```bash Request theme={"dark"}
    curl    --request POST \
            --url https://app.infisical.com/api/v1/app-connections/windmill \
            --header 'Content-Type: application/json' \
            --data '{
                "name": "my-windmill-connection",
                "method": "access-token",
                "projectId": "7ffbb072-2575-495a-b5b0-127f88caef78",
                "credentials": {
                    "token": "...",
                    "instanceUrl": "https://app.windmill.dev"
                }
            }'
    ```

    ### Sample response

    ```bash Response theme={"dark"}
    {
        "appConnection": {
            "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "name": "my-windmill-connection",
            "projectId": "7ffbb072-2575-495a-b5b0-127f88caef78",
            "version": 123,
            "orgId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "createdAt": "2025-04-01T05:31:56Z",
            "updatedAt": "2025-04-01T05:31:56Z",
            "app": "windmill",
            "method": "access-token",
            "credentials": {
                "instanceUrl": "https://app.windmill.dev"
            }
        }
    }
    ```
  </Tab>
</Tabs>


# Zabbix Connection
Source: https://infisical.com/docs/integrations/app-connections/zabbix

Learn how to configure a Zabbix Connection for Infisical.

Infisical supports the use of [API Tokens](https://www.zabbix.com/documentation/current/en/manual/web_interface/frontend_sections/users/api_tokens) to connect with Zabbix.

## Create Zabbix API Token

<Steps>
  <Step title="Navigate to 'API Tokens'">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/zabbix/zabbix-dashboard.png" alt="Dashboard Page" />
  </Step>

  <Step title="Click 'Create API Token'">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/zabbix/zabbix-api-token-list.png" alt="Click Create Token" />
  </Step>

  <Step title="Provide Token Information">
    Ensure that you give this token access to the correct app, then click 'Create Token'.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/zabbix/zabbix-api-token-form.png" alt="Create Token Page" />
  </Step>

  <Step title="Save Token">
    After clicking 'Create Token', a modal containing your access token will appear. Save this token for later steps.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/zabbix/zabbix-api-token-generated.png" alt="Copy Token Modal" />
  </Step>
</Steps>

## Create Zabbix Connection in Infisical

<Tabs>
  <Tab title="Infisical UI">
    <Steps>
      <Step title="Navigate to App Connections">
        In your Infisical dashboard, navigate to the **App Connections** page in the desired project.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/general/add-connection.png" alt="App Connections Tab" />
      </Step>

      <Step title="Select Zabbix Connection">
        Click the **+ Add Connection** button and select the **Zabbix Connection** option from the available integrations.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/zabbix/zabbix-app-connection-option.png" alt="Select Zabbix Connection" />
      </Step>

      <Step title="Fill out the Zabbix Connection Modal">
        Complete the Zabbix Connection form by entering:

        * A descriptive name for the connection
        * An optional description for future reference
        * The Zabbix URL for your instance
        * The API Token from earlier steps

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/zabbix/zabbix-app-connection-form.png" alt="Zabbix Connection Modal" />
      </Step>

      <Step title="Connection Created">
        After clicking Create, your **Zabbix Connection** is established and ready to use with your Infisical project.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/app-connections/zabbix/zabbix-app-connection-generated.png" alt="Zabbix Connection Created" />
      </Step>
    </Steps>
  </Tab>

  <Tab title="API">
    To create a Zabbix Connection, make an API request to the [Create Zabbix Connection](/api-reference/endpoints/app-connections/zabbix/create) API endpoint.

    ### Sample request

    ```bash Request theme={"dark"}
    curl    --request POST \
            --url https://app.infisical.com/api/v1/app-connections/zabbix \
            --header 'Content-Type: application/json' \
            --data '{
                "name": "my-zabbix-connection",
                "method": "api-token",
                "projectId": "7ffbb072-2575-495a-b5b0-127f88caef78",
                "credentials": {
                    "apiToken": "[API TOKEN]",
                    "instanceUrl": "https://zabbix.example.com"
                }
            }'
    ```

    ### Sample response

    ```bash Response theme={"dark"}
    {
      "appConnection": {
          "id": "e5d18aca-86f7-4026-a95e-efb8aeb0d8e6",
          "name": "my-zabbix-connection",
          "projectId": "7ffbb072-2575-495a-b5b0-127f88caef78",
          "description": null,
          "version": 1,
          "orgId": "6f03caa1-a5de-43ce-b127-95a145d3464c",
          "createdAt": "2025-04-23T19:46:34.831Z",
          "updatedAt": "2025-04-23T19:46:34.831Z",
          "isPlatformManagedCredentials": false,
          "credentialsHash": "7c2d371dec195f82a6a0d5b41c970a229cfcaf88e894a5b6395e2dbd0280661f",
          "app": "zabbix",
          "method": "api-token",
          "credentials": {
            "instanceUrl": "https://zabbix.example.com"
          }
      }
    }
    ```
  </Tab>
</Tabs>


# Gradle
Source: https://infisical.com/docs/integrations/build-tools/gradle

How to use Infisical to inject environment variables with Gradle

# Using Infisical with Gradle

By integrating [Infisical CLI](../../cli/overview) with Gradle, you can configure your builds and scripts to different environments, CI/CD pipelines, and more without explicitly setting variables in the command line.

This documentation provides an overview of how to use Infisical with [Gradle](https://gradle.org/).

## Basic Usage

To run a Gradle task with Infisical, you can use the `run` command. The basic structure is:

```
infisical run -- [Your command here]
```

For example, to run the `generateFile` task in Gradle:

```groovy build.gradle theme={"dark"}
task generateFile {
    doLast {
        String content = System.getenv('ENV_NAME_FROM_INFISICAL') ?: 'Default Content'
        file('output.txt').text = content
        println "Generated output.txt with content: $content"
    }
}
```

```
infisical run -- gradle generateFile
```

With this command, Infisical will automatically inject the environment variables associated with the current Infisical project into the Gradle process.
Your Gradle script can then access these variables using `System.getenv('VARIABLE_NAME')`.

## More Examples

### 1. Building a Project with a Specific Profile

Assuming you have different build profiles (e.g., 'development', 'production'), you can use Infisical to switch between them:

```
infisical run -- gradle build
```

Inside your `build.gradle`, you might have:

```groovy build.gradle theme={"dark"}
if (System.getenv('PROFILE') == 'production') {
    // production-specific configurations
}
```

### 2. Running Tests with Different Database Configurations

If you want to run tests against different database configurations:

```
infisical run -- gradle test
```

Your test configuration in `build.gradle` can then adjust the database URL accordingly:

```groovy build.gradle theme={"dark"}
test {
    systemProperty 'db.url', System.getenv('DB_URL')
}
```

### 3. Generating Artifacts with Versioning

For automated CI/CD pipelines, you might want to inject a build number or version:

```
infisical run -- gradle assemble
```

And in `build.gradle`:

```groovy build.gradle theme={"dark"}
version = System.getenv('BUILD_NUMBER') ?: '1.0.0-SNAPSHOT'
```

## Advantages of Using Infisical with Gradle

1. **Flexibility**: Easily adapt your Gradle builds to different environments without modifying the build scripts or setting environment variables manually.
2. **Reproducibility**: Ensure consistent builds by leveraging the environment variables from the related Infisical project.
3. **Security**: Protect sensitive information by using Infisical's secrets management without exposing them in scripts or logs.


# Bitbucket
Source: https://infisical.com/docs/integrations/cicd/bitbucket

How to sync secrets from Infisical to Bitbucket

Infisical lets you sync secrets to Bitbucket at the repository-level and deployment environment-level.

Prerequisites:

* Set up and add envars to [Infisical Cloud](https://app.infisical.com)

<AccordionGroup>
  <Accordion title="Push secrets to Bitbucket from Infisical">
    <Steps>
      <Step title="Authorize Infisical for Bitbucket">
        Navigate to your project's integrations tab in Infisical.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations.png" alt="integrations" />

        Press on the Bitbucket tile and grant Infisical access to your Bitbucket account.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/bitbucket/integrations-bitbucket.png" alt="integrations bitbucket authorization" />
      </Step>

      <Step title="Configure integration">
        Select which workspace, repository, and optionally, deployment environment, you'd like to sync your secrets
        to.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/bitbucket/integrations-bitbucket-configuration.png" alt="integrations configure
        bitbucket" />

        Once created, your integration will begin syncing secrets to the configured repository or deployment
        environment.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/bitbucket/integrations-bitbucket.png" alt="integrations bitbucket" />
      </Step>
    </Steps>
  </Accordion>

  <Accordion title="Pull secrets in Bitbucket pipelines from Infisical">
    <Steps>
      <Step title="Configure Infisical Access">
        Configure a [Machine Identity](https://infisical.com/docs/documentation/platform/identities/universal-auth) for your project and give it permissions to read secrets from your desired Infisical projects and environments.
      </Step>

      <Step title="Initialize Bitbucket variables">
        Create Bitbucket variables (can be either workspace, repository, or deployment-level) to store Machine Identity Client ID and Client Secret.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/bitbucket/integrations-bitbucket-env.png" alt="integrations bitbucket" />
      </Step>

      <Step title="Integrate Infisical secrets into the pipeline">
        Edit your Bitbucket pipeline YAML file to include the use of the Infisical CLI to fetch and inject secrets into any script or command within the pipeline.

        #### Example

        ```yaml  theme={"dark"}
        image: atlassian/default-image:3

        pipelines:
          default:
            - step:
                name: Build application with secrets from Infisical
                script:
                  - apt update && apt install -y curl
                  - curl -1sLf 'https://dl.cloudsmith.io/public/infisical/infisical-cli/setup.deb.sh' | bash
                  - apt-get update && apt-get install -y infisical
                  - export INFISICAL_TOKEN=$(infisical login --method=universal-auth --client-id=$INFISICAL_CLIENT_ID --client-secret=$INFISICAL_CLIENT_SECRET --silent --plain)
                  - infisical run --projectId=1d0443c1-cd43-4b3a-91a3-9d5f81254a89 --env=dev -- npm run build
        ```

        <Tip>
          Set the values of `projectId` and `env` flags in the `infisical run` command to your intended source path. For more options, refer to the CLI command reference [here](https://infisical.com/docs/cli/commands/run).
        </Tip>
      </Step>
    </Steps>
  </Accordion>
</AccordionGroup>


# CircleCI
Source: https://infisical.com/docs/integrations/cicd/circleci

How to sync secrets from Infisical to CircleCI

Prerequisites:

* Set up and add envars to [Infisical Cloud](https://app.infisical.com)

<Steps>
  <Step title="Authorize Infisical for CircleCI">
    Obtain an API token in User Settings > Personal API Tokens

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/circleci/integrations-circleci-token.png" alt="integrations circleci token" />

    Navigate to your project's integrations tab in Infisical.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations.png" alt="integrations" />

    Press on the CircleCI tile and input your CircleCI API token to grant Infisical access to your CircleCI account.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/circleci/integrations-circleci-auth.png" alt="integrations circleci authorization" />
  </Step>

  <Step title="Start integration">
    Select which Infisical environment secrets you want to sync to which CircleCI project or context.

    <Tabs>
      <Tab title="Project">
                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/circleci/integrations-circleci-create-project.png" alt="integrations circle ci project" />
      </Tab>

      <Tab title="Context">
                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/circleci/integrations-circleci-create-context.png" alt="integrations circle ci project" />
      </Tab>
    </Tabs>

    Finally, press create integration to start syncing secrets to CircleCI.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/circleci/integrations-circleci.png" alt="integrations circleci" />
  </Step>
</Steps>


# Codefresh
Source: https://infisical.com/docs/integrations/cicd/codefresh

How to sync secrets from Infisical to Codefresh

Prerequisites:

* Set up and add envars to [Infisical Cloud](https://app.infisical.com)

<Steps>
  <Step title="Authorize Infisical for Codefresh">
    Obtain an API key in User Settings > API Keys

    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/codefresh/integrations-codefresh-dashboard.png" alt="integrations codefresh dashboard" />
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/codefresh/integrations-codefresh-token.png" alt="integrations codefresh token" />

    Navigate to your project's integrations tab in Infisical.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations.png" alt="integrations" />

    Press on the Codefresh tile and input your Codefresh API key to grant Infisical access to your Codefresh account.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/codefresh/integrations-codefresh-auth.png" alt="integrations codefresh authorization" />
  </Step>

  <Step title="Start integration">
    Select which Infisical environment secrets you want to sync to which Codefresh service and press create integration to start syncing secrets to Codefresh.

    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/codefresh/integrations-codefresh-create.png" alt="create integration codefresh" />
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/codefresh/integrations-codefresh.png" alt="integrations codefresh" />
  </Step>
</Steps>


# GitHub Actions
Source: https://infisical.com/docs/integrations/cicd/githubactions

How to sync secrets from Infisical to GitHub Actions

<Note>
  Alternatively, you can use Infisical's official GitHub Action
  [here](https://github.com/Infisical/secrets-action).
</Note>

Infisical lets you sync secrets to GitHub at the organization-level, repository-level, and repository environment-level.

## Connecting with GitHub App (Recommended)

<Tabs>
  <Tab title="Usage">
    <Steps>
      <Step title="Authorize GitHub Infisical App">
        Navigate to your project's integrations tab in Infisical and press on the GitHub tile.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/github/app/integration-overview.png" alt="integrations" />

        Select GitHub App as the authentication method and click **Connect to GitHub**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/github/app/github-app-method-selection.png" alt="integrations github app auth selection" />

        You will then be redirected to the GitHub app installation page.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/github/app/github-app-installation.png" alt="integrations github app installation" />

        Install and authorize the GitHub application. This will redirect you back to the Infisical integration page.
      </Step>

      <Step title="Configure Infisical GitHub integration">
        Select which Infisical environment secrets you want to sync to which GitHub organization, repository, or repository environment.

        <Tabs>
          <Tab title="Repository">
                        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/github/integrations-github-scope-repo.png" alt="integrations github" />
          </Tab>

          <Tab title="Organization">
                        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/github/integrations-github-scope-org.png" alt="integrations github" />

            When using the organization scope, your secrets will be saved in the top-level of your GitHub Organization.

            You can choose the visibility, which defines which repositories can access the secrets. The options are:

            * **All public repositories**: All public repositories in the organization can access the secrets.
            * **All private repositories**: All private repositories in the organization can access the secrets.
            * **Selected repositories**: Only the selected repositories can access the secrets. This gives a more fine-grained control over which repositories can access the secrets. You can select *both* private and public repositories with this option.
          </Tab>

          <Tab title="Repository Environment">
                        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/github/integrations-github-scope-env.png" alt="integrations github" />
          </Tab>
        </Tabs>

        Finally, press create integration to start syncing secrets to GitHub.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/github/integrations-github.png" alt="integrations github" />
      </Step>
    </Steps>
  </Tab>

  <Tab title="Self-Hosted Setup">
    Using the GitHub integration with app authentication on a self-hosted instance of Infisical requires configuring an application on GitHub
    and registering your instance with it.

    <Steps>
      <Step title="Create an application on GitHub">
        Navigate to the GitHub app settings [here](https://github.com/settings/apps). Click **New GitHub App**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/github/app/self-hosted-github-app-create.png" alt="integrations github app create" />

        Give the application a name, a homepage URL (your self-hosted domain i.e. `https://your-domain.com`), and a callback URL (i.e. `https://your-domain.com/integrations/github/oauth2/callback`).

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/github/app/self-hosted-github-app-basic-details.png" alt="integrations github app basic details" />

        Enable request user authorization during app installation.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/github/app/self-hosted-github-app-enable-oauth.png" alt="integrations github app enable auth" />

        Disable webhook by unchecking the Active checkbox.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/github/app/self-hosted-github-app-webhook.png" alt="integrations github app webhook" />

        Set the repository permissions as follows: Metadata: Read-only, Secrets: Read and write, Environments: Read and write, Actions: Read.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/github/app/self-hosted-github-app-repository.png" alt="integrations github app repository" />

        Similarly, set the organization permissions as follows: Secrets: Read and write.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/github/app/self-hosted-github-app-organization.png" alt="integrations github app organization" />

        Create the Github application.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/github/app/self-hosted-github-app-create-confirm.png" alt="integrations github app create confirm" />

        <Note>
          If you have a GitHub organization, you can create an application under it
          in your organization Settings > Developer settings > GitHub Apps > New GitHub App.
        </Note>
      </Step>

      <Step title="Add your application credentials to Infisical">
        Generate a new **Client Secret** for your GitHub application.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/github/app/self-hosted-github-app-secret.png" alt="integrations github app create secret" />

        Generate a new **Private Key** for your Github application.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/github/app/self-hosted-github-app-private-key.png" alt="integrations github app create private key" />

        Obtain the necessary Github application credentials. This would be the application slug, client ID, app ID, client secret, and private key.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/github/app/self-hosted-github-app-credentials.png" alt="integrations github app credentials" />

        Back in your Infisical instance, add the five new environment variables for the credentials of your GitHub application:

        * `CLIENT_ID_GITHUB_APP`: The **Client ID** of your GitHub application.
        * `CLIENT_SECRET_GITHUB_APP`: The **Client Secret** of your GitHub application.
        * `CLIENT_SLUG_GITHUB_APP`: The **Slug** of your GitHub application. This is the one found in the URL.
        * `CLIENT_APP_ID_GITHUB_APP`: The **App ID** of your GitHub application.
        * `CLIENT_PRIVATE_KEY_GITHUB_APP`: The **Private Key** of your GitHub application.

        Once added, restart your Infisical instance and use the GitHub integration via app authentication.
      </Step>
    </Steps>
  </Tab>
</Tabs>

## Connecting with GitHub OAuth

Prerequisites:

* Set up and add envars to [Infisical Cloud](https://app.infisical.com)
* Ensure that you have admin privileges to the repository you want to sync secrets to.

<Tabs>
  <Tab title="Usage">
    <Steps>
      <Step title="Authorize Infisical for GitHub">
        Navigate to your project's integrations tab in Infisical and press on the GitHub tile.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/github/integration-overview.png" alt="integrations" />

        Select OAuth as the authentication method and click **Connect to GitHub**.
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/github/github-oauth-method-selection.png" alt="integrations github oauth auth selection" />

        Grant Infisical access to your GitHub account (organization and repo privileges).
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/github/integrations-github-auth.png" alt="integrations github authorization" />
      </Step>

      <Step title="Configure Infisical GitHub integration">
        Select which Infisical environment secrets you want to sync to which GitHub organization, repository, or repository environment.

        <Tabs>
          <Tab title="Repository">
                        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/github/integrations-github-scope-repo.png" alt="integrations github" />
          </Tab>

          <Tab title="Organization">
                        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/github/integrations-github-scope-org.png" alt="integrations github" />

            When using the organization scope, your secrets will be saved in the top-level of your GitHub Organization.

            You can choose the visibility, which defines which repositories can access the secrets. The options are:

            * **All public repositories**: All public repositories in the organization can access the secrets.
            * **All private repositories**: All private repositories in the organization can access the secrets.
            * **Selected repositories**: Only the selected repositories can access the secrets. This gives a more fine-grained control over which repositories can access the secrets. You can select *both* private and public repositories with this option.
          </Tab>

          <Tab title="Repository Environment">
                        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/github/integrations-github-scope-env.png" alt="integrations github" />
          </Tab>
        </Tabs>

        Finally, press create integration to start syncing secrets to GitHub.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/github/integrations-github.png" alt="integrations github" />
      </Step>
    </Steps>
  </Tab>

  <Tab title="Self-Hosted Setup">
    Using the GitHub integration on a self-hosted instance of Infisical requires configuring an OAuth application in GitHub
    and registering your instance with it.

    <Steps>
      <Step title="Create an OAuth application in GitHub">
        Navigate to your user Settings > Developer settings > OAuth Apps to create a new GitHub OAuth application.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/github/integrations-github-config-settings.png" alt="integrations github config" />
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/github/integrations-github-config-dev-settings.png" alt="integrations github config" />
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/github/integrations-github-config-new-app.png" alt="integrations github config" />

        Create the OAuth application. As part of the form, set the **Homepage URL** to your self-hosted domain `https://your-domain.com`
        and the **Authorization callback URL** to `https://your-domain.com/integrations/github/oauth2/callback`.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/github/integrations-github-config-new-app-form.png" alt="integrations github config" />

        <Note>
          If you have a GitHub organization, you can create an OAuth application under it
          in your organization Settings > Developer settings > OAuth Apps > New Org OAuth App.
        </Note>
      </Step>

      <Step title="Add your OAuth application credentials to Infisical">
        Obtain the **Client ID** and generate a new **Client Secret** for your GitHub OAuth application.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/github/integrations-github-config-credentials.png" alt="integrations github config" />

        Back in your Infisical instance, add two new environment variables for the credentials of your GitHub OAuth application:

        * `CLIENT_ID_GITHUB`: The **Client ID** of your GitHub OAuth application.
        * `CLIENT_SECRET_GITHUB`: The **Client Secret** of your GitHub OAuth application.

        Once added, restart your Infisical instance and use the GitHub integration.
      </Step>
    </Steps>
  </Tab>
</Tabs>


# GitLab
Source: https://infisical.com/docs/integrations/cicd/gitlab

How to sync secrets from Infisical to GitLab

<Tabs>
  <Tab title="Usage">
    Prerequisites:

    * Set up and add envars to [Infisical Cloud](https://app.infisical.com)

    <AccordionGroup>
      <Accordion title="Standard">
        <Steps>
          <Step title="Authorize Infisical for GitLab">
            Navigate to your project's integrations tab in Infisical.

                        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations.png" alt="integrations" />

            Press on the GitLab tile and grant Infisical access to your GitLab account.

                        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/gitlab/integrations-gitlab-auth.png" alt="integrations gitlab authorization" />
          </Step>

          <Step title="Start integration">
            Select which Infisical environment secrets you want to sync to which GitLab repository and press create integration to start syncing secrets to GitLab.

                        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/gitlab/integrations-gitlab-create.png" alt="integrations gitlab" />

            Note that the GitLab integration supports a few options in the **Options** tab:

            * Secret Prefix: If inputted, the prefix is appended to the front of every secret name prior to being synced.
            * Secret Suffix: If inputted, the suffix to appended to the back of every name of every secret prior to being synced.

            Setting a secret prefix or suffix ensures that existing secrets in GitLab are not overwritten during the sync. As part of this process, Infisical abstains from mutating any secrets in GitLab without the specified prefix or suffix.

                        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/gitlab/integrations-gitlab-create-options.png" alt="integrations gitlab options" />

                        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/gitlab/integrations-gitlab.png" alt="integrations gitlab" />
          </Step>
        </Steps>
      </Accordion>

      <Accordion title="Pipeline">
        <Steps>
          <Step title="Authorize Infisical for GitLab">
            Generate an [Infisical Token](/documentation/platform/token) for the specific project and environment in Infisical.

            Next, create a new variable called `INFISICAL_TOKEN` with the value set to the token from the previous step in Settings > CI/CD > Variables of your GitLab repository.
          </Step>

          <Step title="Configure Infisical in your pipeline">
            Edit your `.gitlab-ci.yml` to include the Infisical CLI installation. This will allow you to use the CLI for fetching and injecting secrets into any script or command within your Gitlab CI/CD process.

            #### Example

            ```yaml  theme={"dark"}
            image: ubuntu

            stages:
              - build
              - test
              - deploy

            build-job:
              stage: build
              script:
                - apt update && apt install -y curl
                - curl -1sLf 'https://dl.cloudsmith.io/public/infisical/infisical-cli/setup.deb.sh' | bash
                - apt-get update && apt-get install -y infisical
                - infisical run -- npm run build
            ```
          </Step>
        </Steps>
      </Accordion>
    </AccordionGroup>
  </Tab>

  <Tab title="Self-Hosted Setup">
    Using the GitLab integration on a self-hosted instance of Infisical requires configuring an application in GitLab
    and registering your instance with it.
    <Tip>If you're self-hosting Gitlab with custom certificates, you will have to configure your Infisical instance to trust these certificates. To learn how, please follow [this guide](../../self-hosting/guides/custom-certificates).</Tip>

    <Steps>
      <Step title="Create an OAuth application in GitLab">
        Navigate to your user Settings > Applications to create a new GitLab application.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/gitlab/integrations-gitlab-config-edit-profile.png" alt="integrations gitlab config" />
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/gitlab/integrations-gitlab-config-new-app.png" alt="integrations gitlab config" />

        Create the application. As part of the form, set the **Redirect URI** to `https://your-domain.com/integrations/gitlab/oauth2/callback`.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/gitlab/integrations-gitlab-config-new-app-form.png" alt="integrations gitlab config" />

        <Note>
          If you have a GitLab group, you can create an OAuth application under it
          in your group Settings > Applications.
        </Note>
      </Step>

      <Step title="Add your OAuth application credentials to Infisical">
        Obtain the **Application ID** and **Secret** for your GitLab application.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/gitlab/integrations-gitlab-config-credentials.png" alt="integrations gitlab config" />

        Back in your Infisical instance, add two new environment variables for the credentials of your GitLab application:

        * `CLIENT_ID_GITLAB`: The **Client ID** of your GitLab application.
        * `CLIENT_SECRET_GITLAB`: The **Secret** of your GitLab application.

        Once added, restart your Infisical instance and use the GitLab integration.
      </Step>
    </Steps>
  </Tab>
</Tabs>


# Jenkins Plugin
Source: https://infisical.com/docs/integrations/cicd/jenkins

How to effectively and securely manage secrets in Jenkins using Infisical

**Objective**: Fetch secrets from Infisical to Jenkins pipelines

In this guide, we'll outline the steps to deliver secrets from Infisical to Jenkins via the Infisical CLI.
At a high level, the Infisical CLI will be executed within your build environment and use a machine identity to authenticate with Infisical.
This token must be added as a Jenkins Credential and then passed to the Infisical CLI as an environment variable, enabling it to access and retrieve secrets within your workflows.

Prerequisites:

* Set up and add secrets to [Infisical](https://app.infisical.com).
* Create a [machine identity](/documentation/platform/identities/machine-identities) (Recommended), or a service token in Infisical.
* You have a working Jenkins installation with the [credentials plugin](https://plugins.jenkins.io/credentials/) installed.
* You have the [Infisical CLI](/cli/overview) installed on your Jenkins executor nodes or container images.

<Tabs>
  <Tab title="Using Plugin with Machine Identities (Recommended)">
    ## Jenkins Infisical Plugin

    This plugin adds a build wrapper to set environment variables from [Infisical](https://infisical.com). Secrets are generally masked in the build log, so you can't accidentally print them.

    ## Installation

    To install the plugin, navigate to `Manage Jenkins -> Plugins -> Available plugins` and search for `Infisical`. Install the plugin and restart Jenkins.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/jenkins/plugin/install-plugin.png" alt="Install Plugin" />

    ## Infisical Authentication

    Authenticating with Infisical is done through the use of [Machine Identities](https://infisical.com/docs/documentation/platform/identities/machine-identities).
    Currently the Jenkins plugin only supports [Universal Auth](https://infisical.com/docs/documentation/platform/identities/universal-auth) for authentication. More methods will be added soon.

    ### How does Universal Auth work?

    To use Universal Auth, you'll need to create a new Credential *(Infisical Universal Auth Credential)*. The credential should contain your Universal Auth client ID, and your Universal Auth client secret.
    Please [read more here](https://infisical.com/docs/documentation/platform/identities/universal-auth) on how to setup a Machine Identity to use universal auth.

    ### Creating a Universal Auth credential

    Creating a universal auth credential inside Jenkins is very straight forward.

    Simply navigate to<br />
    `Dashboard -> Manage Jenkins -> Credentials -> System -> Global credentials (unrestricted)`.

    Press the `Add Credentials` button and select `Infisical Universal Auth Credential` in the `Kind` field.

    The `ID` and `Description` field doesn't matter much in this case, as they won't be read anywhere. The description field will be displayed as the credential name during the plugin configuration.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/jenkins/plugin/universal-auth-credential.png" alt="Infisical Universal Auth Credential" />

    ## Plugin Usage

    ### Configuration

    Configuration takes place on a job-level basis.

    Inside your job, you simply tick the `Infisical Plugin` checkbox under "Build Environment". After enabling the plugin, you'll see a new section appear where you'll have to configure the plugin.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/jenkins/plugin/plugin-checked.png" alt="Plugin enabled" />

    You'll be prompted with 4 options to fill:

    * Infisical URL
      * This defaults to [https://app.infisical.com](https://app.infisical.com). This field is only relevant if you're running a managed or self-hosted instance. If you are using Infisical Cloud, leave this as-is, otherwise enter the URL of your Infisical instance.
    * Infisical Credential
      * This is where you select your Infisical credential to use for authentication. In the step above [Creating a Universal Auth credential](#creating-a-universal-auth-credential), you can read on how to configure the credential. Simply select the credential you have created for this field.
    * Infisical Project Slug
      * This is the slug of the project you wish to fetch secrets from. You can find this in your project settings on Infisical by clicking "Copy project slug".
    * Environment Slug
      * This is the slug of the environment to fetch secrets from. In most cases it's either `dev`, `staging`, or `prod`. You can however create custom environments in Infisical. If you are using custom environments, you need to enter the slug of the custom environment you wish to fetch secrets from.

    That's it! Now you're ready to select which secrets you want to fetch into Jenkins.
    By clicking the `Add an Infisical secret` in the Jenkins UI like seen in the screenshot below.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/jenkins/plugin/add-infisical-secret.png" alt="Add Infisical secret" />

    You need to select which secrets that should be pulled into Jenkins.
    You start by specifying a [folder path from Infisical](https://infisical.com/docs/documentation/platform/folder#comparing-folders). The root path is simply `/`. You also need to select wether or not you want to [include imports](https://infisical.com/docs/documentation/platform/secret-reference#secret-imports). Now you can add secrets the secret keys that you want to pull from Infisical into Jenkins. If you want to add multiple secrets, press the "Add key/value pair".

    If you wish to pull secrets from multiple paths, you can press the "Add an Infisical secret" button at the bottom, and configure a new set of secrets to pull.

    ## Pipeline usage

    ### Generating pipeline block

    Using the Infisical Plugin in a Jenkins pipeline is very straight forward. To generate a block to use the Infisical Plugin in a Pipeline, simply to go `{JENKINS_URL}/jenkins/job/{JOB_ID}/pipeline-syntax/`.

    You can find a direct link on the Pipeline configuration page in the very bottom of the page, see image below.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/jenkins/plugin/pipeline-syntax-highlight.png" alt="Pipeline Syntax Highlight" />

    On the Snippet Generator page, simply configure the Infisical Plugin like it's documented in the [Configuration documentation](#configuration) step.

    Once you have filled out the configuration, press `Generate Pipeline Script`, and it will generate a block you can use in your pipeline.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/jenkins/plugin/pipeline-configuration.png" alt="Pipeline Configuration" />

    ### Using Infisical in a Pipeline

    Using the generated block in a pipeline is very straight forward. There's a few approaches on how to implement the block in a Pipeline script.
    Here's an example of using the generated block in a pipeline script. Make sure to replace the placeholder values with your own values.

    The script is formatted for clarity. All these fields will be pre-filled for you if you use the `Snippet Generator` like described in the [step above](#generating-pipeline-block).

    ```groovy  theme={"dark"}
    node {
        withInfisical(
            configuration: [
                infisicalCredentialId: 'YOUR_CREDENTIAL_ID',
                infisicalEnvironmentSlug: 'PROJECT_ENV_SLUG', 
                infisicalProjectSlug: 'PROJECT_SLUG', 
                infisicalUrl: 'https://app.infisical.com' // Change this to your Infisical instance URL if you aren't using Infisical Cloud.
            ], 
            infisicalSecrets: [
                infisicalSecret(
                    includeImports: true, 
                    path: '/', 
                    secretValues: [
                        [infisicalKey: 'DATABASE_URL'],
                        [infisicalKey: "API_URL"],
                        [infisicalKey: 'THIS_KEY_MIGHT_NOT_EXIST', isRequired: false],
                    ]
                )
            ]
        ) {
            // Code runs here
            sh "printenv"
        }     
    }
    ```
  </Tab>

  <Tab title="Using CLI with Service Tokens">
    ## Add Infisical Service Token to Jenkins

    After setting up your project in Infisical and installing the Infisical CLI to the environment where your Jenkins builds will run, you will need to add the Infisical Service Token to Jenkins.

    To generate a Infisical service token, follow the guide [here](/documentation/platform/token).
    Once you have generated the token, navigate to **Manage Jenkins > Manage Credentials** in your Jenkins instance.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/jenkins/jenkins_1.png" alt="Jenkins step 1" />

    Click on the credential store you want to store the Infisical Service Token in. In this case, we're using the default Jenkins global store.

    <Info>
      Each of your projects will have a different `INFISICAL_TOKEN`.
      As a result, it may make sense to spread these out into separate credential domains depending on your use case.
    </Info>

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/jenkins/jenkins_2.png" alt="Jenkins step 2" />

    Now, click Add Credentials.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/jenkins/jenkins_3.png" alt="Jenkins step 3" />

    Choose **Secret text** for the **Kind** option from the dropdown list and enter the Infisical Service Token in the **Secret** field.
    Although the **ID** can be any value, we'll set it to `infisical-service-token` for the sake of this guide.
    The description is optional and can be any text you prefer.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/jenkins/jenkins_4.png" alt="Jenkins step 4" />

    When you're done, you should see a credential similar to the one below:

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/jenkins/jenkins_5.png" alt="Jenkins step 5" />

    ## Use Infisical in a Freestyle Project

    To fetch secrets with Infisical in a Freestyle Project job, you'll need to expose the credential you created above as an environment variable to the Infisical CLI.
    To do so, first click **New Item** from the dashboard navigation sidebar:

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/jenkins/jenkins_6.png" alt="Jenkins step 6" />

    Enter the name of the job, choose the **Freestyle Project** option, and click **OK**.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/jenkins/jenkins_7.png" alt="Jenkins step 7" />

    Scroll down to the **Build Environment** section and enable the **Use secret text(s) or file(s)** option. Then click **Add** under the **Bindings** section and choose **Secret text** from the dropdown menu.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/jenkins/jenkins_8.png" alt="Jenkins step 8" />

    Enter `INFISICAL_TOKEN` in the **Variable** field then click the **Specific credentials** option from the Credentials section and select the credential you created earlier.
    In this case, we saved it as `Infisical service token` so we'll choose that from the dropdown menu.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/jenkins/jenkins_9.png" alt="Jenkins step 9" />

    Scroll down to the **Build** section and choose **Execute shell** from the **Add build step** menu.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/jenkins/jenkins_10.png" alt="Jenkins step 10" />

    In the command field, you can now use the Infisical CLI to fetch secrets.
    The example command below will print the secrets using the service token passed as a credential. When done, click  **Save**.

    ```
    infisical secrets --env=dev --path=/
    ```

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/jenkins/jenkins_11.png" alt="Jenkins step 11" />

    Finally, click **Build Now** from the navigation sidebar to run your new job.

    <Info>
      Running into issues? Join Infisical's [community Slack](https://infisical.com/slack) for quick support.
    </Info>

    ## Use Infisical in a Jenkins Pipeline

    To fetch secrets using Infisical in a Pipeline job, you'll need to expose the Jenkins credential you created above as an environment variable.
    To do so, click **New Item** from the dashboard navigation sidebar:

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/jenkins/jenkins_6.png" alt="Jenkins step 6" />

    Enter the name of the job, choose the **Pipeline** option, and click OK.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/jenkins/jenkins_12.png" alt="Jenkins step 12" />

    Scroll down to the **Pipeline** section, paste the following into the **Script** field, and click **Save**.

    ```
    pipeline {
        agent any

        environment {
            INFISICAL_TOKEN = credentials('infisical-service-token')
        }

        stages {
            stage('Run Infisical') {
                steps {
                    sh("infisical secrets --env=dev --path=/")

                    // doesn't work
                    // sh("docker run --rm test-container infisical secrets")

                    // works
                    // sh("docker run -e INFISICAL_TOKEN=${INFISICAL_TOKEN} --rm test-container infisical secrets --env=dev --path=/")

                    // doesn't work
                    // sh("docker-compose up -d")

                    // works
                    // sh("INFISICAL_TOKEN=${INFISICAL_TOKEN} docker-compose up -d")
                }
            }
        }
    }
    ```
  </Tab>
</Tabs>

The example provided above serves as an initial guide. It shows how Jenkins adds the `INFISICAL_TOKEN` environment variable, which is configured in the pipeline, into the shell for executing commands.
There may be instances where this doesn't work as expected in the context of running Docker commands.
However, the list of working examples should provide some insight into how this can be handled properly.


# Octopus Deploy
Source: https://infisical.com/docs/integrations/cicd/octopus-deploy

Learn how to sync secrets from Infisical to Octopus Deploy

Prerequisites:

* Set up and add secrets to [Infisical Cloud](https://app.infisical.com)

<Steps>
  <Step title="Create a Service Account for Infisical in Octopus Deploy">
    Navigate to **Configuration** > **Users** and click on the **Create Service Account** button.

        <img
          src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/octopus-deploy/integrations-octopus-deploy-user-settings.png"
          alt="integrations octopus deploy
    users"
        />

    Fill out the required fields and click on the **Save** button.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/octopus-deploy/integrations-octopus-deploy-create-service-account.png" alt="integrations octopus deploy service
    account" />
  </Step>

  <Step title="Generate an API Key for your Service Account">
    On the **Service Account** user page, expand the **API Keys** section and click on the **New API Key** button.

        <img
          src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/octopus-deploy/integrations-octopus-deploy-create-api-key.png"
          alt="integrations octopus deploy
    new api key"
        />

    Fill out the required fields and click on the **Generate New** button.

        <img
          src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/octopus-deploy/integrations-octopus-deploy-generate-api-key.png"
          alt="integrations octopus deploy
    generate api key"
        />

    <Note>If you configure your access token to expire,
    you will need to generate a new API key for Infisical prior to this date to keep your integration running.</Note>

    Copy the generated **API Key** and click on the **Close** button.

        <img
          src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/octopus-deploy/integrations-octopus-deploy-copy-api-key.png"
          alt="integrations octopus deploy
    copy api key"
        />
  </Step>

  <Step title="Create a Service Accounts Team and assign your Service Account">
    <Note>You can skip creating a new team if you already have an Octopus Deploy team configured with
    the **Project Contributor** role to assign your Service Account to.</Note>

    Navigate to **Configuration** > **Teams** and click on the **Add Team** button.

        <img
          src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/octopus-deploy/integrations-octopus-deploy-team-settings.png"
          alt="integrations octopus deploy
    teams"
        />

    Create a new team for **Service Accounts** and click on the **Save** button.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/octopus-deploy/integrations-octopus-deploy-create-team.png" alt="integrations octopus deploy add
    team" />

    On the **Members** tab, click on the **Add Member** button, add your **Infisical Service Account** and click on the **Add** button.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/octopus-deploy/integrations-octopus-deploy-add-to-team.png" alt="integrations octopus deploy add service account to team" />

    On the **User Roles** tab, click on the **Include User Role** button, and add the **Project Contributor** role. Optionally,
    click on the **Define Scope** button to further refine what projects your Service Account has access to. Click on the **Apply** button once complete.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/octopus-deploy/integrations-octopus-deploy-add-role.png" alt="integrations octopus deploy add user roles to team" />

    Save your team changes by clicking on the **Save** button.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/octopus-deploy/integrations-octopus-deploy-save-team.png" alt="integrations octopus deploy save team changes" />
  </Step>

  <Step title="Setup Integration">
    In Infisical, navigate to your **Project** > **Integrations** page and select the **Octopus Deploy** integration.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/octopus-deploy/integrations-octopus-deploy-integrations.png" alt="integration octopus deploy" />

    Enter your **Instance URL** and **API Key** from **Octopus Deploy** to authorize Infisical.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/octopus-deploy/integrations-octopus-deploy-authorize.png" alt="integration octopus deploy" />

    Select a **Space** and **Project** from **Octopus Deploy** to sync secrets to; configuring additional **Scope Values** as needed. Click on the **Create Integration** button once configured.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/octopus-deploy/integrations-octopus-deploy-create.png" alt="integration octopus deploy" />

    Your Infisical secrets will begin to sync to **Octopus Deploy**.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/octopus-deploy/integrations-octopus-deploy-sync.png" alt="integration octopus deploy" />
  </Step>
</Steps>


# Rundeck
Source: https://infisical.com/docs/integrations/cicd/rundeck

How to sync secrets from Infisical to Rundeck

Prerequisites:

* Set up and add envars to [Infisical Cloud](https://app.infisical.com)

<Steps>
  <Step title="Authorize Infisical for Rundeck">
    Obtain a User API Token in the Profile settings of Rundeck

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/rundeck/integrations-rundeck-token.png" alt="integrations rundeck token" />

    Navigate to your project's integrations tab in Infisical.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations.png" alt="integrations" />

    Press on the Rundeck tile and input your Rundeck instance Base URL and User API token to grant Infisical access to manage Rundeck keys

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/rundeck/integrations-rundeck-auth.png" alt="integrations rundeck authorization" />
  </Step>

  <Step title="Start integration">
    Select which Infisical environment secrets you want to sync to a Rundeck Key Storage Path and press create integration to start syncing secrets to Rundeck.

    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/rundeck/integrations-rundeck-create.png" alt="create integration rundeck" />
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/rundeck/integrations-rundeck.png" alt="integrations rundeck" />
  </Step>
</Steps>


# Travis CI
Source: https://infisical.com/docs/integrations/cicd/travisci

How to sync secrets from Infisical to Travis CI

Prerequisites:

* Set up and add envars to [Infisical Cloud](https://app.infisical.com)

<Steps>
  <Step title="Authorize Infisical for Travis CI">
    Obtain your API token in User Settings > API authentication > Token

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/travis-ci/integrations-travisci-token.png" alt="integrations travis ci token" />

    Navigate to your project's integrations tab in Infisical.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations.png" alt="integrations" />

    Press on the Travis CI tile and input your Travis CI API token to grant Infisical access to your Travis CI account.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/travis-ci/integrations-travisci-auth.png" alt="integrations travis ci authorization" />
  </Step>

  <Step title="Start integration">
    Select which Infisical environment secrets you want to sync to which Travis CI repository and press create integration to start syncing secrets to Travis CI.

    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/travis-ci/integrations-travisci-create.png" alt="create integration travis ci" />
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/travis-ci/integrations-travisci.png" alt="integrations travis ci" />
  </Step>
</Steps>


# AWS Amplify
Source: https://infisical.com/docs/integrations/cloud/aws-amplify

Learn how to sync secrets from Infisical to AWS Amplify.

Prerequisites:

* Infisical Cloud account
* Add the secrets you wish to sync to Amplify to [Infisical Cloud](https://app.infisical.com)

There are many approaches to sync secrets stored within Infisical to AWS Amplify. This guide describes two such approaches below.

## Access Infisical secrets at Amplify build time

This approach enables you to fetch secrets from Infisical during Amplify build time.

<Tabs>
  <Tab title="Machine Identity (Recommended)">
    <Steps>
      <Step title="Create a machine identity">
        Create a machine identtiy and connect it to your Infisical project. You can read more about how to use machine identities [here](/documentation/platform/identities/machine-identities). The machine identity will allow you to authenticate and fetch secrets from Infisical.
      </Step>

      <Step title="Set the machine identity client ID and client secret as Amplify environment variables">
                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/aws/integrations-amplify-env-console-identity.png" alt="aws amplify env console" />

        1. In the Amplify console, choose App Settings, and then select Environment variables.
        2. In the Environment variables section, select Manage variables.
        3. Under the first Variable enter `INFISICAL_MACHINE_IDENTITY_CLIENT_ID`, and for the value, enter the client ID of the machine identity you created in the previous step.
        4. Under the second Variable enter `INFISICAL_MACHINE_IDENTITY_CLIENT_SECRET`, and for the value, enter the client secret of the machine identity you created in the previous step.
        5. Click save.
      </Step>

      <Step title="Install Infisical CLI to the Amplify build step">
        In the prebuild phase, add the command in AWS Amplify to install the Infisical CLI.

        ```yaml  theme={"dark"}
        build:
          phases:
            preBuild:
              commands:
        - sudo curl -1sLf 'https://dl.cloudsmith.io/public/infisical/infisical-cli/setup.rpm.sh' | sudo -E bash
        - sudo yum -y install infisical
        ```
      </Step>

      <Step title="Modify the build command">
        You can now pull secrets from Infisical using the CLI and save them as a `.env` file. To do this, modify the build commands.

        ```yaml  theme={"dark"}
        build:
          phases:
            build:
              commands:
        - INFISICAL_TOKEN=$(infisical login --method=universal-auth --client-id=${INFISICAL_MACHINE_IDENTITY_CLIENT_ID} --client-secret=${INFISICAL_MACHINE_IDENTITY_CLIENT_SECRET} --silent --plain)
            - infisical export --format=dotenv > .env
            - <rest of the commands>
        ```
      </Step>
    </Steps>
  </Tab>

  <Tab title="Service Token (Deprecated)">
    <Steps>
      <Step title="Generate a service token">
        Go to your project settings in the Infisical dashboard to generate a [service token](/documentation/platform/token). This service token will allow you to authenticate and fetch secrets from Infisical. Once you have created a service token with the required permissions, youll need to provide the token to the CLI installed in your Docker container.
      </Step>

      <Step title="Set the service token as an Amplify environment variable">
                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/aws/integrations-amplify-env-console.png" alt="aws amplify env console" />

        1. In the Amplify console, choose App Settings, and then select Environment variables.
        2. In the Environment variables section, select Manage variables.
        3. Under Variable, enter the key **INFISICAL\_TOKEN**. For the value, enter the generated service token from the previous step.
        4. Click save.
      </Step>

      <Step title="Install Infisical CLI to the Amplify build step">
        In the prebuild phase, add the command in AWS Amplify to install the Infisical CLI.

        ```yaml  theme={"dark"}
        build:
          phases:
            preBuild:
              commands:
        - sudo curl -1sLf 'https://dl.cloudsmith.io/public/infisical/infisical-cli/setup.rpm.sh' | sudo -E bash
        - sudo yum -y install infisical
        ```
      </Step>

      <Step title="Modify the build command">
        You can now pull secrets from Infisical using the CLI and save them as a `.env` file. To do this, modify the build commands.

        ```yaml  theme={"dark"}
        build:
          phases:
            build:
              commands:
        - INFISICAL_TOKEN=${INFISICAL_TOKEN}
            - infisical export --format=dotenv > .env
            - <rest of the commands>
        ```
      </Step>
    </Steps>

    ## Sync Secrets Using AWS SSM Parameter Store

    Another approach to use secrets from Infisical in AWS Amplify is to utilize AWS Parameter Store.
    At high level, you begin by using Infisical's AWS SSM Parameter Store integration to sync secrets from Infisical to AWS SSM Parameter Store. You then instruct AWS Amplify to consume those secrets from AWS SSM Parameter Store as [environment secrets](https://docs.aws.amazon.com/amplify/latest/userguide/environment-variables.html#environment-secrets).

    <Steps>
      <Step title="Follow the AWS SSM Parameter Store Integration guide">
        Follow the [Infisical AWS SSM Parameter Store Integration Guide](./aws-parameter-store) to set up the integration. Pause once you reach the step where it asks you to select the path you would like to sync.
      </Step>

      <Step title="Find your Amplify App ID">
                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/aws/integrations-amplify-app-id.png" alt="amplify app id" />

        1. Open your AWS Amplify App console.
        2. Go to **Actions >> View App Settings**
        3. The App ID will be the last part of the App ARN field after the slash.
      </Step>

      <Step title="Set AWS SSM Parameter Store path">
        You need to set the path in the format `/amplify/[amplify_app_id]/[your-amplify-environment-name]` as the path option in AWS SSM Parameter Infisical Integration.
      </Step>
    </Steps>
  </Tab>
</Tabs>

<Info>
  Accessing an environment secret during a build is similar to accessing
  environment variables, except that environment secrets are stored in
  `process.env.secrets` as a JSON string.
</Info>


# AWS Parameter Store
Source: https://infisical.com/docs/integrations/cloud/aws-parameter-store

Learn how to sync secrets from Infisical to AWS Parameter Store.

<Note>
  The AWS Parameter Store Native Integration will be deprecated in 2026. Please migrate to our new [AWS Parameter Store Sync](../secret-syncs/aws-parameter-store).
</Note>


# AWS Secrets Manager
Source: https://infisical.com/docs/integrations/cloud/aws-secret-manager

Learn how to sync secrets from Infisical to AWS Secrets Manager.

<Note>
  The AWS Secrets Manager Native Integration will be deprecated in 2026. Please migrate to our new [AWS Secrets Manager Sync](../secret-syncs/aws-secrets-manager).
</Note>


# Azure App Configuration
Source: https://infisical.com/docs/integrations/cloud/azure-app-configuration

How to sync secrets from Infisical to Azure App Configuration

<Note>
  The Azure App Configuration Native Integration will be deprecated in 2026. Please migrate to our new [Azure App Configuration Sync](../secret-syncs/azure-app-configuration).
</Note>


# Azure DevOps
Source: https://infisical.com/docs/integrations/cloud/azure-devops

How to sync secrets from Infisical to Azure DevOps

### Usage

Prerequisites:

* Set up and add envars to [Infisical Cloud](https://app.infisical.com).
* Create a new [Azure DevOps](https://dev.azure.com) project if you don't have one already.

#### Create a new Azure DevOps personal access token (PAT)

You'll need to create a new personal access token (PAT) in order to authenticate Infisical with Azure DevOps.

<Steps>
  <Step title="Navigate to Azure DevOps">
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/azure-devops/overview-page.png" alt="integrations" />
  </Step>

  <Step title="Create a new token">
    Make sure the newly created token has Read/Write access to the Release scope.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/azure-devops/create-new-token.png" alt="integrations" />

    <Note>
      Please make sure that the token has access to the following scopes: Variable Groups *(read, create, & manage)*, Release *(read/write)*, Project and Team *(read)*, Service Connections *(read & query)*
    </Note>
  </Step>

  <Step title="Copy the new access token">
    Copy the newly created token as this will be used to authenticate Infisical with Azure DevOps.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/azure-devops/new-token-created.png" alt="integrations" />
  </Step>
</Steps>

#### Setup the Infisical Azure DevOps integration

Navigate to your project's integrations tab and select the 'Azure DevOps' integration.
<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations.png" alt="integrations" />

<Steps>
  <Step title="Authorize Infisical for Azure DevOps">
    Enter your credentials that you obtained from the previous step.

    1. Azure DevOps API token is the personal access token (PAT) you created in the previous step.
    2. Azure DevOps organization name is the name of your Azure DevOps organization.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/azure-devops/new-infiscial-integration-step-1.png" alt="integrations" />
  </Step>

  <Step title="Configure the integration">
    Select Infisical project and secret path you want to sync into Azure DevOps.
    Finally, press create integration to start syncing secrets to Azure DevOps.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/azure-devops/new-infiscial-integration-step-2.png" alt="integrations" />
  </Step>
</Steps>

Now you have successfully integrated Infisical with Azure DevOps. Your existing and future secret changes will automatically sync to Azure DevOps.
You can view your secrets by navigating to your Azure DevOps project and selecting the 'Library' tab under 'Pipelines' in the 'Library' section.


# Azure Key Vault
Source: https://infisical.com/docs/integrations/cloud/azure-key-vault

How to sync secrets from Infisical to Azure Key Vault

<Note>
  The Azure Key Vault Native Integration will be deprecated in 2026. Please migrate to our new [Azure Key Vault Sync](../secret-syncs/azure-key-vault).
</Note>


# Checkly
Source: https://infisical.com/docs/integrations/cloud/checkly

How to sync secrets from Infisical to Checkly

Prerequisites:

* Set up and add envars to [Infisical Cloud](https://app.infisical.com)

<Steps>
  <Step title="Authorize Infisical for Checkly">
    Obtain a Checkly API Key in User Settings > API Keys.

    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/checkly/integrations-checkly-dashboard.png" alt="integrations checkly dashboard" />
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/checkly/integrations-checkly-token.png" alt="integrations checkly token" />

    Navigate to your project's integrations tab in Infisical.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations.png" alt="integrations" />

    Press on the Checkly tile and input your Checkly API Key to grant Infisical access to your Checkly account.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/checkly/integrations-checkly-auth.png" alt="integrations checkly authorization" />
  </Step>

  <Step title="Start integration">
    Select which Infisical environment secrets you want to sync to Checkly and press create integration to start syncing secrets.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/checkly/integrations-checkly-create.png" alt="integrations checkly" />

    <Note>
      Infisical integrates with Checkly's environment variables at the **global** and **group** levels.

      To sync secrets to a specific group, you can select a group from the Checkly Group dropdown; otherwise, leaving it empty will sync secrets globally.
    </Note>

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/checkly/integrations-checkly.png" alt="integrations checkly" />

    <Info>
      In the new version of the Checkly integration, you are able to specify suffixes that depend on the secrets' environment and path.
      If you choose to do so, you should utilize such suffixes for ALL Checkly integrations otherwise the integration system
      might run into issues with deleting secrets from the wrong environments.
    </Info>
  </Step>
</Steps>


# Cloud 66
Source: https://infisical.com/docs/integrations/cloud/cloud-66

How to sync secrets from Infisical to Cloud 66

Prerequisites:

* Set up and add envars to [Infisical Cloud](https://app.infisical.com)

## Navigate to your project's integrations tab

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations.png" alt="integrations" />

## Enter your Cloud 66 Access Token

In Cloud 66 Dashboard, click on the top right icon > Account Settings > Access Token
<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/cloud-66/integrations-cloud-66-dashboard.png" alt="integrations cloud 66 dashboard" />
<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/cloud-66/integrations-cloud-66-access-token.png" alt="integrations cloud 66 access token" />

Create new Personal Access Token.
<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/cloud-66/integrations-cloud-66-pat.png" alt="integrations cloud 66 personal access token" />

Name it **infisical** and check **Public** and **Admin**. Then click "Create Token"
<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/cloud-66/integrations-cloud-66-pat-setup.png" alt="integrations cloud 66 personal access token setup" />

Copy and save your token.
<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/cloud-66/integrations-cloud-66-copy-pat.png" alt="integrations cloud 66 copy API token" />

### Go to Infisical Integration Page

Click on the Cloud 66 tile and enter your API token to grant Infisical access to your Cloud 66 account.
<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/cloud-66/integrations-cloud-66-infisical-dashboard.png" alt="integrations cloud 66 tile in infisical dashboard" />

Enter your Cloud 66 Personal Access Token here. Then click "Connect to Cloud 66".
<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/cloud-66/integrations-cloud-66-paste-pat.png" alt="integrations cloud 66 tile in infisical dashboard" />

## Start integration

Select which Infisical environment secrets you want to sync to which Cloud 66 stacks and press create integration to start syncing secrets to Cloud 66.
<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/cloud-66/integrations-cloud-66-create.png" alt="integrations laravel forge" />

<Warning>
  Any existing environment variables in Cloud 66 will be deleted when you start syncing. Make sure to add all the secrets into the Infisical dashboard first before doing any integrations.
</Warning>

Done!
<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/cloud-66/integrations-cloud-66-done.png" alt="integrations laravel forge" />


# Cloudflare Pages
Source: https://infisical.com/docs/integrations/cloud/cloudflare-pages

How to sync secrets from Infisical to Cloudflare Pages

Prerequisites:

* Set up and add envars to [Infisical Cloud](https://app.infisical.com)

<Steps>
  <Step title="Authorize Infisical for Cloudflare Pages">
    Obtain a Cloudflare [API token](https://dash.cloudflare.com/profile/api-tokens) and [Account ID](https://developers.cloudflare.com/fundamentals/get-started/basic-tasks/find-account-and-zone-ids/):

    Create a new [API token](https://dash.cloudflare.com/profile/api-tokens) in My Profile > API Tokens

    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/cloudflare/integrations-cloudflare-credentials-1.png" alt="integrations cloudflare credentials 1" />
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/cloudflare/integrations-cloudflare-credentials-2.png" alt="integrations cloudflare credentials 2" />
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/cloudflare/integrations-cloudflare-credentials-3.png" alt="integrations cloudflare credentials 3" />

    Copy your [Account ID](https://developers.cloudflare.com/fundamentals/get-started/basic-tasks/find-account-and-zone-ids/) from Account > Workers & Pages > Overview

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/cloudflare/integrations-cloudflare-credentials-4.png" alt="integrations cloudflare credentials 4" />

    Navigate to your project's integrations tab in Infisical.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations.png" alt="integrations" />

    Press on the Cloudflare Pages tile and input your Cloudflare API token and account ID to grant Infisical access to your Cloudflare Pages.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/cloudflare/integrations-cloudflare-auth.png" alt="integrations cloudflare authorization" />
  </Step>

  <Step title="Start integration">
    Select which Infisical environment secrets you want to sync to Cloudflare and press create integration to start syncing secrets.

    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/cloudflare/integrations-cloudflare-create.png" alt="integrations cloudflare" />
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/cloudflare/integrations-cloudflare.png" alt="integrations cloudflare" />
  </Step>
</Steps>


# Cloudflare Workers
Source: https://infisical.com/docs/integrations/cloud/cloudflare-workers

How to sync secrets from Infisical to Cloudflare Workers

Prerequisites:

* Set up and add envars to [Infisical Cloud](https://app.infisical.com)

<Steps>
  <Step title="Authorize Infisical for Cloudflare Workers">
    Obtain a Cloudflare [API token](https://dash.cloudflare.com/profile/api-tokens) and [Account ID](https://developers.cloudflare.com/fundamentals/get-started/basic-tasks/find-account-and-zone-ids/):

    Create a new [API token](https://dash.cloudflare.com/profile/api-tokens) in My Profile > API Tokens

    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/cloudflare/integrations-cloudflare-credentials-1.png" alt="integrations cloudflare credentials 1" />
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/cloudflare/integrations-cloudflare-credentials-2.png" alt="integrations cloudflare credentials 2" />
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/cloudflare/integrations-cloudflare-workers-permission.png" alt="integrations cloudflare credentials 3" />

    Copy your [Account ID](https://developers.cloudflare.com/fundamentals/get-started/basic-tasks/find-account-and-zone-ids/) from Account > Workers & Pages > Overview

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/cloudflare/integrations-cloudflare-credentials-4.png" alt="integrations cloudflare credentials 4" />

    Navigate to your project's integrations tab in Infisical.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations.png" alt="integrations" />

    Press on the Cloudflare Workers tile and input your Cloudflare API token and account ID to grant Infisical access to your Cloudflare Workers.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/cloudflare/integration-cloudflare-workers-connect.png" alt="integrations cloudflare authorization" />
  </Step>

  <Step title="Start integration">
    Select which Infisical environment secrets you want to sync to Cloudflare Workers and press create integration to start syncing secrets.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/cloudflare/integration-cloudflare-workers-create.png" alt="integrations cloudflare" />
  </Step>
</Steps>


# Databricks
Source: https://infisical.com/docs/integrations/cloud/databricks

Learn how to sync secrets from Infisical to Databricks.

<Note>
  The Databricks Native Integration will be deprecated in 2026. Please migrate to our new [Databricks Sync](../secret-syncs/databricks).
</Note>


# Digital Ocean App Platform
Source: https://infisical.com/docs/integrations/cloud/digital-ocean-app-platform

How to sync secrets from Infisical to Digital Ocean App Platform

Prerequisites:

* Set up and add envars to [Infisical Cloud](https://app.infisical.com)

## Get your Digital Ocean Personal Access Tokens

On Digital Ocean dashboard, navigate to **API > Tokens** and click on "Generate New Token"
<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/digital-ocean/integrations-do-dashboard.png" alt="integrations digital ocean dashboard" />

Name it **infisical**, choose **No expiry**, and make sure to check **Write (optional)**. Then click on "Generate Token" and copy your API token.
<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/digital-ocean/integrations-do-token-modal.png" alt="integrations digital ocean token modal" />

## Navigate to your project's integrations tab

Click on the **Digital Ocean App Platform** tile and enter your API token to grant Infisical access to your Digital Ocean account.
<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations.png" alt="integrations" />

Then enter your Digital Ocean Personal Access Token here. Then click "Connect to Digital Ocean App Platform".
<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/digital-ocean/integrations-do-enter-token.png" alt="integrations infisical dashboard digital ocean integration" />

## Start integration

Select which Infisical environment secrets you want to sync to which Digital Ocean App and click "Create Integration".
<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/digital-ocean/integrations-do-select-projects.png" alt="integrations digital ocean select projects" />

Done!
<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/digital-ocean/integrations-do-success.png" alt="integrations digital ocean integration success" />


# Fly.io
Source: https://infisical.com/docs/integrations/cloud/flyio

How to sync secrets from Infisical to Fly.io

Prerequisites:

* Set up and add envars to [Infisical Cloud](https://app.infisical.com)

<Steps>
  <Step title="Authorize Infisical for Fly.io">
    Obtain a Fly.io access token in Access Tokens

    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/flyio/integrations-flyio-dashboard.png" alt="integrations fly dashboard" />
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/flyio/integrations-flyio-token.png" alt="integrations fly token" />

    Navigate to your project's integrations tab in Infisical.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations.png" alt="integrations" />

    Press on the Fly.io tile and input your Fly.io access token to grant Infisical access to your Fly.io account.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/flyio/integrations-flyio-auth.png" alt="integrations fly authorization" />
  </Step>

  <Step title="Start integration">
    Select which Infisical environment secrets you want to sync to which Fly.io app and press create integration to start syncing secrets to Fly.io.

    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/flyio/integrations-flyio-create.png" alt="integrations fly" />
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/flyio/integrations-flyio.png" alt="integrations fly" />
  </Step>
</Steps>


# GCP Secret Manager
Source: https://infisical.com/docs/integrations/cloud/gcp-secret-manager

How to sync secrets from Infisical to GCP Secret Manager

<Note>
  The GCP Secret Manager Native Integration will be deprecated in 2026. Please migrate to our new [GCP Secret Manager Sync](../secret-syncs/gcp-secret-manager).
</Note>


# HashiCorp Vault
Source: https://infisical.com/docs/integrations/cloud/hashicorp-vault

How to sync secrets from Infisical to HashiCorp Vault

<Note>
  The Hashicorp Vault Native Integration will be deprecated in 2026. Please migrate to our new [Hashicorp Vault Sync](../secret-syncs/hashicorp-vault).
</Note>


# Hasura Cloud
Source: https://infisical.com/docs/integrations/cloud/hasura-cloud

How to sync secrets from Infisical to Hasura Cloud

Prerequisites:

* Set up and add envars to [Infisical Cloud](https://app.infisical.com)

<Steps>
  <Step title="Authorize Infisical for Hasura Cloud">
    Obtain a Hasura Cloud Access Token in My Account > Access Tokens

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/hasura-cloud/integrations-hasura-cloud-tokens.png" alt="integrations hasura cloud tokens" />

    Navigate to your project's integrations tab in Infisical.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations.png" alt="integrations" />

    Press on the Hasura Cloud tile and input your Hasura Cloud access token to grant Infisical access to your Hasura Cloud account.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/hasura-cloud/integrations-hasura-cloud-auth.png" alt="integrations hasura cloud authorization" />
  </Step>

  <Step title="Start integration">
    Select which Infisical environment secrets you want to sync to which Hasura Cloud project and press create integration to start syncing secrets to Hasura Cloud.

    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/hasura-cloud/integrations-hasura-cloud-create.png" alt="integrations hasura cloud" />
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/hasura-cloud/integrations-hasura-cloud.png" alt="integrations hasura cloud" />
  </Step>
</Steps>


# Heroku
Source: https://infisical.com/docs/integrations/cloud/heroku

How to sync secrets from Infisical to Heroku

<Tabs>
  <Tab title="Usage">
    Prerequisites:

    * Set up and add envars to [Infisical Cloud](https://app.infisical.com)

    <Steps>
      <Step title="Authorize Infisical for Heroku">
        Navigate to your project's integrations tab in Infisical.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations.png" alt="integrations" />

        Press on the Heroku tile and grant Infisical access to your Heroku account.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/heroku/integrations-heroku-auth.png" alt="integrations heroku authorization" />
      </Step>

      <Step title="Start integration">
        Select which Infisical environment secrets you want to sync to which Heroku app and press create integration to start syncing secrets to Heroku.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/heroku/integrations-heroku-create.png" alt="integrations heroku" />

        Here's some guidance on each field:

        * Project Environment: The environment in the current Infisical project from which you want to sync secrets from.
        * Secrets Path: The path in the current Infisical project from which you want to sync secrets from such as `/` (for secrets that do not reside in a folder) or `/foo/bar` (for secrets nested in a folder, in this case a folder called `bar` in another folder called `foo`).
        * Heroku App: The application in Heroku that you want to sync secrets to.
        * Initial Sync Behavior (default is **Import - Prefer values from Infisical**): The behavior of the first sync operation triggered after creating the integration.
          * **No Import - Overwrite all values in Heroku**: Sync secrets and overwrite any existing secrets in Heroku.
          * **Import - Prefer values from Infisical**: Import secrets from Heroku to Infisical; if a secret with the same name already exists in Infisical, do nothing. Afterwards, sync secrets to Heroku.
          * **Import - Prefer values from Heroku**: Import secrets from Heroku to Infisical; if a secret with the same name already exists in Infisical, replace its value with the one from Heroku. Afterwards, sync secrets to Heroku.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/heroku/integrations-heroku.png" alt="integrations heroku" />
      </Step>
    </Steps>
  </Tab>

  <Tab title="Self-Hosted Setup">
    Using the Heroku integration on a self-hosted instance of Infisical requires configuring an API client in Heroku
    and registering your instance with it.

    <Steps>
      <Step title="Create an API client in Heroku">
        Navigate to your user Account settings > Applications to create a new API client.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/heroku/integrations-heroku-config-settings.png" alt="integrations Heroku config" />
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/heroku/integrations-heroku-config-applications.png" alt="integrations Heroku config" />
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/heroku/integrations-heroku-config-new-app.png" alt="integrations Heroku config" />

        Create the API client. As part of the form, set the **OAuth callback URL** to `https://your-domain.com/integrations/heroku/oauth2/callback`.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/heroku/integrations-heroku-config-new-app-form.png" alt="integrations Heroku config" />
      </Step>

      <Step title="Add your Heroku API client credentials to Infisical">
        Obtain the **Client ID** and **Client Secret** for your Heroku API client.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/heroku/integrations-heroku-config-credentials.png" alt="integrations Heroku config" />

        Back in your Infisical instance, add two new environment variables for the credentials of your Heroku API client.

        * `CLIENT_ID_HEROKU`: The **Client ID** of your Heroku API client.
        * `CLIENT_SECRET_HEROKU`: The **Client Secret** of your Heroku API client.

        Once added, restart your Infisical instance and use the Heroku integration.
      </Step>
    </Steps>
  </Tab>
</Tabs>


# Laravel Forge
Source: https://infisical.com/docs/integrations/cloud/laravel-forge

How to sync secrets from Infisical to Laravel Forge

Prerequisites:

* Set up and add envars to [Infisical Cloud](https://app.infisical.com)

<Steps>
  <Step title="Authorize Infisical for Laravel Forge">
    Obtain a Laravel Forge access token in API Tokens

    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/laravel-forge/integrations-laravelforge-dashboard.png" alt="integrations laravel forge dashboard" />
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/laravel-forge/integrations-laravelforge-api.png" alt="integrations laravel forge api tokens" />

    Obtain your Laravel Forge Server ID in Servers > Server ID

    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/laravel-forge/integrations-laravelforge-servers.png" alt="integrations laravel forge server" />
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/laravel-forge/integrations-laravelforge-serverid.png" alt="integrations laravel forge server id" />

    Navigate to your project's integrations tab in Infisical.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations.png" alt="integrations" />

    Press on the Laravel Forge tile and input your Laravel Forge access token and server ID to grant Infisical access to your Laravel Forge account.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/laravel-forge/integrations-laravelforge-auth.png" alt="integrations laravel forge authorization" />
  </Step>

  <Step title="Start integration">
    Select which Infisical environment secrets you want to sync to which Laravel Forge site and press create integration to start syncing secrets to Laravel Forge.

    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/laravel-forge/integrations-laravelforge-create.png" alt="integrations laravel forge" />
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/laravel-forge/integrations-laravelforge.png" alt="integrations laravel forge" />
  </Step>
</Steps>


# Netlify
Source: https://infisical.com/docs/integrations/cloud/netlify

How to sync secrets from Infisical to Netlify

<Tabs>
  <Tab title="Usage">
    <Warning>
      Infisical integrates with Netlify's new environment variable experience. If
      your site uses Netlify's old environment variable experience, you'll have to
      upgrade it to the new one to use this integration.
    </Warning>

    Prerequisites:

    * Set up and add envars to [Infisical Cloud](https://app.infisical.com)

    <Steps>
      <Step title="Authorize Infisical for Netlify">
        Navigate to your project's integrations tab in Infisical.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations.png" alt="integrations" />

        Press on the Netlify tile and grant Infisical access to your Netlify account.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/netlify/integrations-netlify-auth.png" alt="integrations netlify authorization" />
      </Step>

      <Step title="Start integration">
        Select which Infisical environment secrets you want to sync to which Netlify app and context. Lastly, press create integration to start syncing secrets to Netlify.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/netlify/integrations-netlify-create.png" alt="integrations netlify" />
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/netlify/integrations-netlify.png" alt="integrations netlify" />
      </Step>
    </Steps>
  </Tab>

  <Tab title="Self-Hosted Setup">
    Using the Netlify integration on a self-hosted instance of Infisical requires configuring an OAuth application in Netlify
    and registering your instance with it.

    <Steps>
      <Step title="Create an OAuth application in Netlify">
        Navigate to your User settings > Applications > OAuth to create a new OAuth application.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/netlify/integrations-netlify-config-user-settings.png" alt="integrations Netlify config" />
        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/netlify/integrations-netlify-config-new-app.png" alt="integrations Netlify config" />

        Create the OAuth application. As part of the form, set the **Redirect URI** to `https://your-domain.com/integrations/netlify/oauth2/callback`.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/netlify/integrations-netlify-config-new-app-form.png" alt="integrations Netlify config" />
      </Step>

      <Step title="Add your Netlify OAuth application credentials to Infisical">
        Obtain the **Client ID** and **Secret** for your Netlify OAuth application.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/netlify/integrations-netlify-config-credentials.png" alt="integrations Netlify config" />

        Back in your Infisical instance, add two new environment variables for the credentials of your Netlify OAuth application.

        * `CLIENT_ID_NETLIFY`: The **Client ID** of your Netlify OAuth application.
        * `CLIENT_SECRET_NETLIFY`: The **Secret** of your Netlify OAuth application.

        Once added, restart your Infisical instance and use the Netlify integration.
      </Step>
    </Steps>
  </Tab>
</Tabs>


# Northflank
Source: https://infisical.com/docs/integrations/cloud/northflank

How to sync secrets from Infisical to Northflank

Prerequisites:

* Set up and add envars to [Infisical Cloud](https://app.infisical.com)
* Have a [Northflank](https://northflank.com) project with a secret group ready

<Steps>
  <Step title="Authorize Infisical for Northflank">
    Obtain a Northflank API token in Account settings > API > Tokens

    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/northflank/integrations-northflank-dashboard.png" alt="integrations northflank dashboard" />
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/northflank/integrations-northflank-token.png" alt="integrations northflank token" />

    Navigate to your project's integrations tab in Infisical.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations.png" alt="integrations" />

    Press on the Northflank tile and input your Northflank API token to grant Infisical access to your Northflank account.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/northflank/integrations-northflank-auth.png" alt="integrations northflank authorization" />
  </Step>

  <Step title="Start integration">
    Select which Infisical environment secrets you want to sync to which Northflank project and secret group. Finally, press create integration to start syncing secrets to Northflank.

    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/northflank/integrations-northflank-create.png" alt="integrations northflank" />
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/northflank/integrations-northflank.png" alt="integrations northflank" />
  </Step>
</Steps>


# Qovery
Source: https://infisical.com/docs/integrations/cloud/qovery

How to sync secrets from Infisical to Qovery

Prerequisites:

* Set up and add envars to [Infisical Cloud](https://app.infisical.com)

<Steps>
  <Step title="Authorize Infisical for Qovery">
    Obtain a Qovery API Token in Settings > API Token.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/qovery/integrations-qovery-token.png" alt="integrations qovery api token" />

    Navigate to your project's integrations tab in Infisical.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations.png" alt="integrations" />

    Press on the Qovery tile and input your Qovery API Token to grant Infisical access to your Qovery account.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/qovery/integrations-qovery-auth.png" alt="integrations qovery authorization" />
  </Step>

  <Step title="Start integration">
    Select which Infisical environment secrets you want to sync to Qovery and press create integration to start syncing secrets.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/qovery/integrations-qovery-create-1.png" alt="integrations qovery create" />

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/qovery/integrations-qovery-create-2.png" alt="integrations qovery create" />

    <Note>
      Infisical supports syncing secrets to various Qovery scopes including applications, jobs, or containers.
    </Note>

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/qovery/integrations-qovery.png" alt="integrations qovery settings" />
  </Step>
</Steps>


# Railway
Source: https://infisical.com/docs/integrations/cloud/railway

How to sync secrets from Infisical to Railway

Prerequisites:

* Set up and add envars to [Infisical Cloud](https://app.infisical.com)

<Steps>
  <Step title="Authorize Infisical for Railway">
    Obtain a Railway API Token in your Railway [Account Settings > Tokens](https://railway.app/account/tokens).

    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/railway/integrations-railway-dashboard.png" alt="integrations railway dashboard" />
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/railway/integrations-railway-token.png" alt="integrations railway token" />

    <Note>
      If this is your first time creating a Railway API token, then you'll be prompted to join
      Railway's Private Boarding Beta program on the Railway Account Settings > Tokens page.

      Note that Railway project tokens will not work for this integration since they don't work with
      Railway's Public API.
    </Note>

    Navigate to your project's integrations tab in Infisical.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations.png" alt="integrations" />

    Press on the Railway tile and input your Railway API Key to grant Infisical access to your Railway account.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/railway/integrations-railway-authorization.png" alt="integrations railway authorization" />
  </Step>

  <Step title="Start integration">
    Select which Infisical environment secrets you want to sync to which Railway project and environment (and optionally service). Lastly, press create integration to start syncing secrets to Railway.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/railway/integrations-railway-create.png" alt="integrations create railway" />

    <Note>
      Infisical integrates with both Railway's [shared variables](https://blog.railway.app/p/shared-variables-release) at the project environment level as well as service variables at the service level.

      To sync secrets to a specific service in a project, you can select a service from the Railway Service dropdown; otherwise, leaving it empty will sync secrets to the shared variables of that project.
    </Note>

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/railway/integrations-railway.png" alt="integrations railway" />
  </Step>
</Steps>


# Render
Source: https://infisical.com/docs/integrations/cloud/render

How to sync secrets from Infisical to Render

<Note>
  The Render Native Integration will be deprecated in 2026. Please migrate to
  our new [Render Sync](../secret-syncs/render).
</Note>


# Supabase
Source: https://infisical.com/docs/integrations/cloud/supabase

How to sync secrets from Infisical to Supabase

<Note>
  The Supabase integration is useful if your Supabase project uses sensitive-information such as [environment variables in edge functions](https://supabase.com/docs/guides/functions/secrets).

  Synced envars can be accessed in edge functions using Deno's built-in handler: `Deno.env.get(MY_SECRET_NAME)`.
</Note>

Prerequisites:

* Have an account and project set up at [Supabase](https://supabase.com/)
* Set up and add envars to [Infisical Cloud](https://app.infisical.com)

<Steps>
  <Step title="Authorize Infisical for Supabase">
    Obtain a Supabase Access Token in your Supabase [Account > Access Tokens](https://app.supabase.com/account/tokens).
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/supabase/integrations-supabase-dashboard.png" alt="integrations supabase dashboard" />
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/supabase/integrations-supabase-token.png" alt="integrations supabase token" />

    Navigate to your project's integrations tab in Infisical.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations.png" alt="integrations" />

    Press on the Supabase tile and input your Supabase Access Token to grant Infisical access to your Supabase account.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/supabase/integrations-supabase-authorization.png" alt="integrations supabase authorization" />
  </Step>

  <Step title="Start integration">
    Select which Infisical environment secrets you want to sync to which Supabase project. Lastly, press create integration to start syncing secrets to Supabase.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/supabase/integrations-supabase-create.png" alt="integrations supabase create" />

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/supabase/integrations-supabase.png" alt="integrations supabase" />
  </Step>
</Steps>


# TeamCity
Source: https://infisical.com/docs/integrations/cloud/teamcity

How to sync secrets from Infisical to TeamCity

<Note>
  The TeamCity Native Integration will be deprecated in 2026. Please migrate to our new [TeamCity Sync](../secret-syncs/teamcity).
</Note>


# Terraform Cloud
Source: https://infisical.com/docs/integrations/cloud/terraform-cloud

How to sync secrets from Infisical to Terraform Cloud

<Note>
  The Terraform Cloud Native Integration will be deprecated in 2026. Please migrate to our new [Terraform Cloud Sync](../secret-syncs/terraform-cloud).
</Note>


# Vercel
Source: https://infisical.com/docs/integrations/cloud/vercel

How to sync secrets from Infisical to Vercel

<Note>
  The Vercel Native Integration will be deprecated in 2026. Please migrate to our new [Vercel Sync](../secret-syncs/vercel).
</Note>


# Windmill
Source: https://infisical.com/docs/integrations/cloud/windmill

How to sync secrets from Infisical to Windmill

<Note>
  The Windmill Native Integration will be deprecated in 2026. Please migrate to our new [Windmill Sync](../secret-syncs/windmill).
</Note>


# Dynamic Secrets
Source: https://infisical.com/docs/integrations/dynamic-secrets

Browse and search through all available dynamic secrets for Infisical.

export const DynamicSecretsBrowser = () => {
  const [searchTerm, setSearchTerm] = useState('');
  const [selectedCategory, setSelectedCategory] = useState('All');
  const categories = ['All', 'Databases', 'Cloud Providers', 'Message Queues', 'Caches', 'Directory Services', 'CI/CD', 'Container Orchestration', 'Authentication'];
  const dynamicSecrets = [{
    "name": "AWS IAM",
    "slug": "aws-iam",
    "path": "/documentation/platform/dynamic-secrets/aws-iam",
    "description": "Learn how to generate dynamic AWS IAM credentials on-demand.",
    "category": "Cloud Providers"
  }, {
    "name": "AWS ElastiCache",
    "slug": "aws-elasticache",
    "path": "/documentation/platform/dynamic-secrets/aws-elasticache",
    "description": "Learn how to generate dynamic AWS ElastiCache credentials on-demand.",
    "category": "Caches"
  }, {
    "name": "Azure Entra ID",
    "slug": "azure-entra-id",
    "path": "/documentation/platform/dynamic-secrets/azure-entra-id",
    "description": "Learn how to generate dynamic Azure Entra ID credentials on-demand.",
    "category": "Cloud Providers"
  }, {
    "name": "Azure SQL Database",
    "slug": "azure-sql-database",
    "path": "/documentation/platform/dynamic-secrets/azure-sql-database",
    "description": "Learn how to generate dynamic Azure SQL Database credentials on-demand.",
    "category": "Databases"
  }, {
    "name": "GCP IAM",
    "slug": "gcp-iam",
    "path": "/documentation/platform/dynamic-secrets/gcp-iam",
    "description": "Learn how to generate dynamic GCP IAM credentials on-demand.",
    "category": "Cloud Providers"
  }, {
    "name": "Cassandra",
    "slug": "cassandra",
    "path": "/documentation/platform/dynamic-secrets/cassandra",
    "description": "Learn how to generate dynamic Cassandra database credentials on-demand.",
    "category": "Databases"
  }, {
    "name": "Couchbase",
    "slug": "couchbase",
    "path": "/documentation/platform/dynamic-secrets/couchbase",
    "description": "Learn how to generate dynamic Couchbase database credentials on-demand.",
    "category": "Databases"
  }, {
    "name": "MongoDB",
    "slug": "mongodb",
    "path": "/documentation/platform/dynamic-secrets/mongo-db",
    "description": "Learn how to generate dynamic MongoDB database credentials on-demand.",
    "category": "Databases"
  }, {
    "name": "MongoDB Atlas",
    "slug": "mongodb-atlas",
    "path": "/documentation/platform/dynamic-secrets/mongo-atlas",
    "description": "Learn how to generate dynamic MongoDB Atlas database credentials on-demand.",
    "category": "Databases"
  }, {
    "name": "MySQL",
    "slug": "mysql",
    "path": "/documentation/platform/dynamic-secrets/mysql",
    "description": "Learn how to generate dynamic MySQL database credentials on-demand.",
    "category": "Databases"
  }, {
    "name": "PostgreSQL",
    "slug": "postgresql",
    "path": "/documentation/platform/dynamic-secrets/postgresql",
    "description": "Learn how to generate dynamic PostgreSQL database credentials on-demand.",
    "category": "Databases"
  }, {
    "name": "Microsoft SQL Server",
    "slug": "mssql",
    "path": "/documentation/platform/dynamic-secrets/mssql",
    "description": "Learn how to generate dynamic Microsoft SQL Server credentials on-demand.",
    "category": "Databases"
  }, {
    "name": "Oracle Database",
    "slug": "oracle",
    "path": "/documentation/platform/dynamic-secrets/oracle",
    "description": "Learn how to generate dynamic Oracle Database credentials on-demand.",
    "category": "Databases"
  }, {
    "name": "SAP ASE",
    "slug": "sap-ase",
    "path": "/documentation/platform/dynamic-secrets/sap-ase",
    "description": "Learn how to generate dynamic SAP ASE database credentials on-demand.",
    "category": "Databases"
  }, {
    "name": "SAP HANA",
    "slug": "sap-hana",
    "path": "/documentation/platform/dynamic-secrets/sap-hana",
    "description": "Learn how to generate dynamic SAP HANA database credentials on-demand.",
    "category": "Databases"
  }, {
    "name": "Snowflake",
    "slug": "snowflake",
    "path": "/documentation/platform/dynamic-secrets/snowflake",
    "description": "Learn how to generate dynamic Snowflake database credentials on-demand.",
    "category": "Databases"
  }, {
    "name": "Vertica",
    "slug": "vertica",
    "path": "/documentation/platform/dynamic-secrets/vertica",
    "description": "Learn how to generate dynamic Vertica database credentials on-demand.",
    "category": "Databases"
  }, {
    "name": "Redis",
    "slug": "redis",
    "path": "/documentation/platform/dynamic-secrets/redis",
    "description": "Learn how to generate dynamic Redis credentials on-demand.",
    "category": "Caches"
  }, {
    "name": "ElasticSearch",
    "slug": "elasticsearch",
    "path": "/documentation/platform/dynamic-secrets/elastic-search",
    "description": "Learn how to generate dynamic ElasticSearch credentials on-demand.",
    "category": "Databases"
  }, {
    "name": "RabbitMQ",
    "slug": "rabbitmq",
    "path": "/documentation/platform/dynamic-secrets/rabbit-mq",
    "description": "Learn how to generate dynamic RabbitMQ credentials on-demand.",
    "category": "Message Queues"
  }, {
    "name": "LDAP",
    "slug": "ldap",
    "path": "/documentation/platform/dynamic-secrets/ldap",
    "description": "Learn how to generate dynamic LDAP credentials on-demand.",
    "category": "Directory Services"
  }, {
    "name": "GitHub",
    "slug": "github",
    "path": "/documentation/platform/dynamic-secrets/github",
    "description": "Learn how to generate dynamic GitHub credentials on-demand.",
    "category": "CI/CD"
  }, {
    "name": "Kubernetes",
    "slug": "kubernetes",
    "path": "/documentation/platform/dynamic-secrets/kubernetes",
    "description": "Learn how to generate dynamic Kubernetes credentials on-demand.",
    "category": "Container Orchestration"
  }, {
    "name": "TOTP",
    "slug": "totp",
    "path": "/documentation/platform/dynamic-secrets/totp",
    "description": "Learn how to generate dynamic TOTP codes on-demand.",
    "category": "Authentication"
  }].sort(function (a, b) {
    return a.name.toLowerCase().localeCompare(b.name.toLowerCase());
  });
  const filteredDynamicSecrets = useMemo(() => {
    let filtered = dynamicSecrets;
    if (selectedCategory !== 'All') {
      filtered = filtered.filter(secret => secret.category === selectedCategory);
    }
    if (searchTerm) {
      filtered = filtered.filter(secret => secret.name.toLowerCase().includes(searchTerm.toLowerCase()) || secret.description.toLowerCase().includes(searchTerm.toLowerCase()) || secret.category.toLowerCase().includes(searchTerm.toLowerCase()));
    }
    return filtered;
  }, [searchTerm, selectedCategory]);
  return <div className="max-w-none">
      {}
      <div className="mb-6">
        <div className="relative w-full">
          <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
            <svg className="h-4 w-4 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
            </svg>
          </div>
          <input type="text" placeholder="Search dynamic secrets..." className="block w-full pl-9 pr-3 py-2 text-sm border border-gray-300 rounded-lg placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-yellow-500 focus:border-yellow-500 bg-white shadow-sm" value={searchTerm} onChange={e => setSearchTerm(e.target.value)} />
        </div>
      </div>

      {}
      <div className="mb-6">
        <div className="flex flex-wrap gap-2">
          {categories.map(category => <button key={category} onClick={() => setSelectedCategory(category)} className={`px-3 py-1.5 text-sm font-medium rounded-lg transition-colors shadow-sm ${selectedCategory === category ? 'bg-yellow-100 text-yellow-700 border border-yellow-200' : 'bg-white text-gray-700 border border-gray-200 hover:bg-yellow-50 hover:border-yellow-200'}`}>
              {category}
            </button>)}
        </div>
      </div>

      {}
      <div className="mb-4">
        <p className="text-sm text-gray-600">
          {filteredDynamicSecrets.length} dynamic secret{filteredDynamicSecrets.length !== 1 ? 's' : ''} found
          {selectedCategory !== 'All' && ` in ${selectedCategory}`}
          {searchTerm && ` for "${searchTerm}"`}
        </p>
      </div>

      {}
      {filteredDynamicSecrets.length > 0 ? <div className="space-y-4">
          {filteredDynamicSecrets.map((secret, index) => <a key={secret.slug} href={secret.path} className="group block px-4 py-3 border border-gray-200 rounded-xl hover:border-yellow-200 hover:bg-yellow-50/50 hover:shadow-sm transition-all duration-200 bg-white shadow-sm">
              <div className="w-full">
                <div className="flex items-center justify-between mb-0.5">
                  <h3 className="text-base font-medium text-gray-900 leading-none m-0">
                    {secret.name}
                  </h3>
                  <span className="ml-3 inline-flex items-center px-3 py-1 rounded-full text-xs font-medium bg-yellow-100 text-yellow-700 flex-shrink-0">
                    {secret.category}
                  </span>
                </div>
                <p className="text-sm text-gray-600 leading-relaxed">
                  {secret.description}
                </p>
              </div>
            </a>)}
        </div> : <div className="text-center py-8">
          <div className="flex flex-col items-center space-y-2">
            <p className="text-gray-500">No dynamic secrets found matching your criteria</p>
            {searchTerm && <p className="text-gray-400 text-sm">Try adjusting your search terms or filters</p>}
          </div>
        </div>}
    </div>;
};

<DynamicSecretsBrowser />


# Backstage Infisical Plugin
Source: https://infisical.com/docs/integrations/external/backstage

A powerful plugin that integrates Infisical secrets management into your Backstage developer portal.

Integrate secrets management into your developer portal with the Backstage Infisical plugin suite. This plugin provides a seamless interface to manage your [Infisical](https://infisical.com) secrets directly within Backstage, including full support for environments and folder structure.

## Features

* **Secrets Management**: View, create, update, and delete secrets from Infisical
* **Folder Navigation**: Explore the full folder structure of your Infisical projects
* **Multi-Environment Support**: Easily switch between and manage different environments
* **Entity Linking**: Map Backstage entities to specific Infisical projects via annotations

***

## Installation

### Frontend Plugin

```bash  theme={"dark"}
# From your Backstage root directory
yarn --cwd packages/app add @infisical/backstage-plugin-infisical
```

### Backend Plugin

```bash  theme={"dark"}
# From your Backstage root directory
yarn --cwd packages/backend add @infisical/backstage-backend-plugin-infisical
```

## Configuration

### Backend

Update your `app-config.yaml`:

```yaml  theme={"dark"}
infisical:
  baseUrl: https://app.infisical.com

  authentication:
    # Option 1: API Token Authentication
    auth_token:
      token: ${INFISICAL_API_TOKEN}

    # Option 2: Client Credentials Authentication
    universalAuth:
      clientId: ${INFISICAL_CLIENT_ID}
      clientSecret: ${INFISICAL_CLIENT_SECRET}
```

<Tip>
  If you have not created a machine identity yet, you can do so in [Identities](/documentation/platform/identities/machine-identities)
</Tip>

Register the plugin in `packages/backend/src/index.ts`:

```ts  theme={"dark"}
import { createBackend } from '@backstage/backend-defaults';

const backend = createBackend();

backend.add(import('@infisical/backstage-backend-plugin-infisical'));

backend.start();
```

### Frontend

Update `packages/app/src/App.tsx` to include the plugin:

```tsx  theme={"dark"}
import { infisicalPlugin } from '@infisical/backstage-plugin-infisical';

const app = createApp({
  plugins: [
    infisicalPlugin,
    // ...other plugins
  ],
});
```

Modify `packages/app/src/components/catalog/EntityPage.tsx`:

```tsx  theme={"dark"}
import { EntityInfisicalContent } from '@infisical/backstage-plugin-infisical';

const serviceEntityPage = (
  <EntityLayout>
    {/* ...other tabs */}
    <EntityLayout.Route path="/infisical" title="Secrets">
      <EntityInfisicalContent />
    </EntityLayout.Route>
  </EntityLayout>
);
```

### Entity Annotation

Add the Infisical project ID to your entity yaml settings:

```yaml  theme={"dark"}
apiVersion: backstage.io/v1alpha1
kind: Component
metadata:
  name: example-service
  annotations:
    infisical/projectId: <your-infisical-project-id>
```

> Replace `<your-infisical-project-id>` with the actual project ID from Infisical.

## Usage

Once installed and configured, you can:

1. **View and manage secrets** in Infisical from within Backstage
2. **Create, update, and delete** secrets using the Infisical tab in entity pages
3. **Navigate environments and folders**
4. **Search and filter** secrets by key, value, or comments

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/integrations/external/backstage/backstage-plugin-infisical.png" alt="Backstage Plugin Table" />


# Framework Integrations
Source: https://infisical.com/docs/integrations/framework-integrations

Browse and search through all available framework integrations for Infisical.

export const FrameworkIntegrationsBrowser = () => {
  const [searchTerm, setSearchTerm] = useState('');
  const integrations = [{
    "name": "React",
    "slug": "react",
    "path": "/integrations/frameworks/react",
    "description": "Learn how to integrate Infisical with React applications for secure secret management.",
    "category": "Web Frameworks"
  }, {
    "name": "Next.js",
    "slug": "nextjs",
    "path": "/integrations/frameworks/nextjs",
    "description": "Learn how to integrate Infisical with Next.js applications.",
    "category": "Web Frameworks"
  }, {
    "name": "Vue",
    "slug": "vuejs",
    "path": "/integrations/frameworks/vue",
    "description": "Learn how to integrate Infisical with Vue.js applications.",
    "category": "Web Frameworks"
  }, {
    "name": "Nuxt",
    "slug": "nuxtjs",
    "path": "/integrations/frameworks/nuxt",
    "description": "Learn how to integrate Infisical with Nuxt.js applications.",
    "category": "Web Frameworks"
  }, {
    "name": "SvelteKit",
    "slug": "sveltekit",
    "path": "/integrations/frameworks/sveltekit",
    "description": "Learn how to integrate Infisical with SvelteKit applications.",
    "category": "Web Frameworks"
  }, {
    "name": "Express, Fastify, Koa",
    "slug": "express",
    "path": "/integrations/frameworks/express",
    "description": "Learn how to integrate Infisical with Express.js backend applications.",
    "category": "Web Frameworks"
  }, {
    "name": "NestJS",
    "slug": "nestjs",
    "path": "/integrations/frameworks/nestjs",
    "description": "Learn how to integrate Infisical with NestJS applications.",
    "category": "Web Frameworks"
  }, {
    "name": "Django",
    "slug": "django",
    "path": "/integrations/frameworks/django",
    "description": "Learn how to integrate Infisical with Django applications.",
    "category": "Web Frameworks"
  }, {
    "name": "Flask",
    "slug": "flask",
    "path": "/integrations/frameworks/flask",
    "description": "Learn how to integrate Infisical with Flask applications.",
    "category": "Web Frameworks"
  }, {
    "name": "Ruby on Rails",
    "slug": "rails",
    "path": "/integrations/frameworks/rails",
    "description": "Learn how to integrate Infisical with Ruby on Rails applications.",
    "category": "Web Frameworks"
  }, {
    "name": "Spring Boot",
    "slug": "spring-boot-maven",
    "path": "/integrations/frameworks/spring-boot-maven",
    "description": "Learn how to integrate Infisical with Spring Boot applications.",
    "category": "Web Frameworks"
  }, {
    "name": "Laravel",
    "slug": "laravel",
    "path": "/integrations/frameworks/laravel",
    "description": "Learn how to integrate Infisical with Laravel applications.",
    "category": "Web Frameworks"
  }, {
    "name": ".NET",
    "slug": "dotnet",
    "path": "/integrations/frameworks/dotnet",
    "description": "Learn how to integrate Infisical with .NET applications.",
    "category": "Web Frameworks"
  }, {
    "name": "Fiber",
    "slug": "fiber",
    "path": "/integrations/frameworks/fiber",
    "description": "Learn how to integrate Infisical with Fiber (Go) framework.",
    "category": "Web Frameworks"
  }, {
    "name": "Gatsby",
    "slug": "gatsby",
    "path": "/integrations/frameworks/gatsby",
    "description": "Learn how to integrate Infisical with Gatsby applications.",
    "category": "Web Frameworks"
  }, {
    "name": "Remix",
    "slug": "remix",
    "path": "/integrations/frameworks/remix",
    "description": "Learn how to integrate Infisical with Remix applications.",
    "category": "Web Frameworks"
  }, {
    "name": "Vite",
    "slug": "vite",
    "path": "/integrations/frameworks/vite",
    "description": "Learn how to integrate Infisical with Vite applications.",
    "category": "Web Frameworks"
  }, {
    "name": "AB Initio",
    "slug": "ab-initio",
    "path": "/integrations/frameworks/ab-initio",
    "description": "Learn how to integrate Infisical with AB Initio applications.",
    "category": "Web Frameworks"
  }].sort(function (a, b) {
    return a.name.toLowerCase().localeCompare(b.name.toLowerCase());
  });
  const filteredIntegrations = useMemo(() => {
    if (searchTerm) {
      return integrations.filter(integration => integration.name.toLowerCase().includes(searchTerm.toLowerCase()) || integration.description.toLowerCase().includes(searchTerm.toLowerCase()));
    }
    return integrations;
  }, [searchTerm]);
  return <div className="max-w-none">
      {}
      <div className="mb-6">
        <div className="relative w-full">
          <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
            <svg className="h-4 w-4 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
            </svg>
          </div>
          <input type="text" placeholder="Search framework integrations..." className="block w-full pl-9 pr-3 py-2 text-sm border border-gray-300 rounded-lg placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-yellow-500 focus:border-yellow-500 bg-white shadow-sm" value={searchTerm} onChange={e => setSearchTerm(e.target.value)} />
        </div>
      </div>

      {}
      <div className="mb-4">
        <p className="text-sm text-gray-600">
          {filteredIntegrations.length} framework integration{filteredIntegrations.length !== 1 ? 's' : ''} found
          {searchTerm && ` for "${searchTerm}"`}
        </p>
      </div>

      {}
      {filteredIntegrations.length > 0 ? <div className="space-y-4">
          {filteredIntegrations.map((integration, index) => <a key={integration.slug} href={integration.path} className="group block px-4 py-3 border border-gray-200 rounded-xl hover:border-yellow-200 hover:bg-yellow-50/50 hover:shadow-sm transition-all duration-200 bg-white shadow-sm">
              <div className="w-full">
                <div className="mb-0.5">
                  <h3 className="text-base font-medium text-gray-900 leading-none m-0">
                    {integration.name}
                  </h3>
                </div>
                <p className="text-sm text-gray-600 leading-relaxed">
                  {integration.description}
                </p>
              </div>
            </a>)}
        </div> : <div className="text-center py-8">
          <div className="flex flex-col items-center space-y-2">
            <p className="text-gray-500">No framework integrations found matching your criteria</p>
            {searchTerm && <p className="text-gray-400 text-sm">Try adjusting your search terms or filters</p>}
          </div>
        </div>}
    </div>;
};

<FrameworkIntegrationsBrowser />


# AB Initio
Source: https://infisical.com/docs/integrations/frameworks/ab-initio

How to use Infisical secrets in AB Initio.

## Prerequisites

* Set up and add envars to [Infisical](https://app.infisical.com).
* Install the [Infisical CLI](https://infisical.com/docs/cli/overview) to your server.

## Setup

<Steps>
  <Step title="Authorize Infisical for AB Initio">
    Create a [machine identity](https://infisical.com/docs/documentation/platform/identities/machine-identities#machine-identities) in Infisical and give it the appropriate read permissions for the desired project and secret paths.
  </Step>

  <Step title="Add Infisical CLI to your workflow">
    Update your AB Initio workflows to use Infisical CLI to inject Infisical secrets as environment variables.

    ```bash  theme={"dark"}
    # Login using the machine identity. Modify this accordingly based on the authentication method used.
    export INFISICAL_TOKEN=$(infisical login --method=universal-auth --client-id=$INFISICAL_CLIENT_ID --client-secret=$INFISICAL_CLIENT_SECRET --silent --plain)

    # Fetch secrets from Infisical
    infisical export --projectId="<>" --env="prod" > infisical.env

    # Inject secrets as environment variables
    source infisical.env
    ```
  </Step>
</Steps>


# Django
Source: https://infisical.com/docs/integrations/frameworks/django

How to use Infisical to inject environment variables and secrets into a Django app.

Prerequisites:

* Set up and add envars to [Infisical Cloud](https://app.infisical.com)
* [Install the CLI](/cli/overview)

## Initialize Infisical for your [Django](https://www.djangoproject.com) project

```bash  theme={"dark"}
# navigate to the root of your of your project 
cd /path/to/project

# then initialize Infisical
infisical init
```

## Start your application as usual but with Infisical

```bash  theme={"dark"}
infisical run -- <your application start command>

# Example
infisical run -- python manage.py runserver
```


# .NET
Source: https://infisical.com/docs/integrations/frameworks/dotnet

How to use Infisical to inject environment variables and secrets into a .NET app.

Prerequisites:

* Set up and add envars to [Infisical Cloud](https://app.infisical.com)
* [Install the CLI](/cli/overview)

## Initialize Infisical for your [.NET](https://dotnet.microsoft.com) app

```bash  theme={"dark"}
# navigate to the root of your of your project 
cd /path/to/project

# then initialize infisical
infisical init
```

## Start your application as usual but with Infisical

```bash  theme={"dark"}
infisical run -- <your application start command>

# Example
infisical run -- dotnet run
```


# Express, Fastify, Koa
Source: https://infisical.com/docs/integrations/frameworks/express

How to use Infisical to inject environment variables and secrets into an Express app.

Prerequisites:

* Set up and add envars to [Infisical Cloud](https://app.infisical.com)
* [Install the CLI](/cli/overview)

The steps apply to the following non-exhaustive list of frameworks:

* [Express](https://expressjs.com)
* [Fastify](https://www.fastify.io)
* [Koa](https://koajs.com)

## Initialize Infisical for your app

```bash  theme={"dark"}
# navigate to the root of your of your project 
cd /path/to/project

# then initialize Infisical
infisical init
```

## Start your application as usual but with Infisical

```bash  theme={"dark"}
infisical run -- <your application start command>

# Example
infisical run -- npm run dev
```


# Fiber
Source: https://infisical.com/docs/integrations/frameworks/fiber

How to use Infisical to inject environment variables and secrets into a Fiber app.

Prerequisites:

* Set up and add envars to [Infisical Cloud](https://app.infisical.com)
* [Install the CLI](/cli/overview)

## Initialize Infisical for your [Fiber](https://gofiber.io/) app

```bash  theme={"dark"}
# navigate to the root of your of your project 
cd /path/to/project

# then initialize Infisical
infisical init
```

## Start your application as usual but with Infisical

```bash  theme={"dark"}
infisical run -- <your application start command>

# Example 
infisical run -- go run server.go
```


# Flask
Source: https://infisical.com/docs/integrations/frameworks/flask

How to use Infisical to inject environment variables and secrets into a Flask app.

Prerequisites:

* Set up and add envars to [Infisical Cloud](https://app.infisical.com)
* [Install the CLI](/cli/overview)

## Initialize Infisical for your [Flask](https://flask.palletsprojects.com/en/2.2.x) app

```bash  theme={"dark"}
# navigate to the root of your of your project 
cd /path/to/project

# then initialize Infisical
infisical init
```

## Start your application as usual but with Infisical

```bash  theme={"dark"}
infisical run -- <your application start command>

# Example 
infisical run -- flask run
```


# Gatsby
Source: https://infisical.com/docs/integrations/frameworks/gatsby

How to use Infisical to inject environment variables and secrets into a Gatsby app.

Prerequisites:

* Set up and add envars to [Infisical Cloud](https://app.infisical.com)
* [Install the CLI](/cli/overview)

## Initialize Infisical for your [Gatsby](https://www.gatsbyjs.com) app

```bash  theme={"dark"}
# navigate to the root of your of your project 
cd /path/to/project

# then initialize Infisical
infisical init
```

## Start your application as usual but with Infisical

```bash  theme={"dark"}
infisical run -- <your application start command>

# Example
infisical run -- npm run develop
```

<Note>
  Note that for environment variables to be exposed to the client, you'll have
  to prefix them with `GATSBY_`. Read more about that
  [here](https://www.gatsbyjs.com/docs/how-to/local-development/environment-variables/#accessing-environment-variables-in-the-browser).
</Note>


# Laravel
Source: https://infisical.com/docs/integrations/frameworks/laravel

How to use Infisical to inject environment variables and secrets into a Laravel app.

Prerequisites:

* Set up and add envars to [Infisical Cloud](https://app.infisical.com)
* [Install the CLI](/cli/overview)

## Initialize Infisical for your [Laravel](https://laravel.com/) app

```bash  theme={"dark"}
# navigate to the root of your of your project 
cd /path/to/project

# then initialize Infisical
infisical init
```

## Start your application as usual but with Infisical

```bash  theme={"dark"}
infisical run -- <your application start command>

# Example 
infisical run -- php artisan serve
```


# NestJS
Source: https://infisical.com/docs/integrations/frameworks/nestjs

How to use Infisical to inject environment variables and secrets into a NestJS app.

Prerequisites:

* Set up and add envars to [Infisical Cloud](https://app.infisical.com)
* [Install the CLI](/cli/overview)

## Initialize Infisical for your [NestJS](https://nestjs.com) app

```bash  theme={"dark"}
# navigate to the root of your of your project 
cd /path/to/project

# then initialize infisical
infisical init
```

## Start your application as usual but with Infisical

```bash  theme={"dark"}
infisical run -- <your application start command>

# Example
infisical run -- npm run start:dev
```


# Next.js
Source: https://infisical.com/docs/integrations/frameworks/nextjs

How to use Infisical to inject environment variables and secrets into a Next.js app.

Prerequisites:

* Set up and add envars to [Infisical Cloud](https://app.infisical.com)
* [Install the CLI](/cli/overview)

## Initialize Infisical for your [Next.js](https://nextjs.org) app

```bash  theme={"dark"}
# navigate to the root of your of your project 
cd /path/to/project

# then initialize infisical
infisical init
```

## Start your application as usual but with Infisical

```bash  theme={"dark"}
infisical run -- <your application start command>

# Example
infisical run -- npm run dev
```

<Note>
  Note that for environment variables to be exposed to the client, you'll have
  to prefix them with `NEXT_PUBLIC_`. Read more about that
  [here](https://nextjs.org/docs/basic-features/environment-variables).
</Note>


# Nuxt
Source: https://infisical.com/docs/integrations/frameworks/nuxt

How to use Infisical to inject environment variables and secrets into a Nuxt app.

Prerequisites:

* Set up and add envars to [Infisical Cloud](https://app.infisical.com)
* [Install the CLI](/cli/overview)

## Initialize Infisical for your [Nuxt](https://nuxtjs.org) app

```bash  theme={"dark"}
# navigate to the root of your of your project 
cd /path/to/project

# then initialize infisical
infisical init
```

## Start your application as usual but with Infisical

```bash  theme={"dark"}
infisical run -- <your application start command>

# Example
infisical run -- npm run dev
```


# Packer
Source: https://infisical.com/docs/integrations/frameworks/packer

Learn how to fetch secrets from Infisical with Packer using a data source

This guide demonstrates how to use the Infisical Packer plugin to fetch secret data using a data source. The Packer plugin supports both [Infisical Cloud](https://app.infisical.com) and [self-hosted instances of Infisical](https://infisical.com/docs/self-hosting/overview).

## Prerequisites

Before you begin, make sure you have:

* [Packer](https://developer.hashicorp.com/packer/install) installed
* An Infisical account with access to a project
* Basic understanding of Packer

## Project Setup

### Configure Provider

First, specify the Infisical provider in your Packer configuration:

```hcl  theme={"dark"}
packer {
  required_plugins {
    infisical = {
      source  = "github.com/infisical/infisical"
      version = ">=0.0.1"
    }
  }
}
```

### Authentication

Using a Machine Identity, you can authenticate with [Universal Auth](https://infisical.com/docs/documentation/platform/identities/universal-auth).

```hcl  theme={"dark"}
data "infisical-secrets" "dev-secrets" {
  folder_path = "/"
  env_slug    = "dev" # The environment to list secrets from (e.g. dev, staging, prod)
  project_id  = "00000000-0000-0000-0000-000000000000"
  host        = "https://app.infisical.com" # Optional for cloud, required for self-hosted

  universal_auth {
    client_id = "00000000-0000-0000-0000-000000000000"
    client_secret = "..." # Optional if using INFISICAL_UNIVERSAL_AUTH_CLIENT_SECRET env variable
  }
}
```

Learn more about [machine identities](/documentation/platform/identities/machine-identities).

## Using Secrets in Packer

You're able to fetch secrets from Infisical using the `infisical-secrets` Data Source:

```hcl  theme={"dark"}
# Fetch all secrets from a folder
data "infisical-secrets" "dev-secrets" {
  folder_path = "/"
  env_slug    = "dev"
  project_id  = "00000000-0000-0000-0000-000000000000"

  universal_auth {
    ...
  }
}

locals {
  secrets = data.infisical-secrets.dev-secrets.secrets
}

source "null" "basic-example" {
  communicator = "none"
}

build {
  sources = [
    "source.null.basic-example"
  ]

  provisioner "shell-local" {
    inline = [
      "echo secret_key: ${local.secrets["SECRET_KEY"].secret_value}",
    ]
  }
}
```

The `local.secrets` object maps secret keys to [secret objects](https://github.com/Infisical/packer-plugin-infisical/blob/main/docs/datasources/secrets.md#secret-object).

See also:

* [Packer Plugin Repository Example](https://github.com/Infisical/packer-plugin-infisical/blob/main/example/build.pkr.hcl)
* [Packer Plugin Repository Docs](https://github.com/Infisical/packer-plugin-infisical/tree/main/docs)
* [Machine Identity setup guide](/documentation/platform/identities/machine-identities)


# Pulumi
Source: https://infisical.com/docs/integrations/frameworks/pulumi

Using Infisical with Pulumi via the Terraform Bridge

Infisical can be integrated with Pulumi by leveraging Pulumis [Terraform Bridge](https://www.pulumi.com/blog/any-terraform-provider/),
which allows Terraform providers to be used seamlessly within Pulumi projects. This enables infrastructure and platform teams to manage Infisical secrets and resources
using Pulumis familiar programming languages (including TypeScript, Python, Go, and C#), without any change to existing workflows.

The Terraform Bridge wraps the [Infisical Terraform provider](https://registry.terraform.io/providers/Infisical/infisical/latest/docs) and exposes its resources (such as `infisical_secret`, `infisical_project`, and `infisical_service_token`)
in a Pulumi-compatible interface. This makes it easy to integrate secret management directly into Pulumi-based IaC pipelines, ensuring secrets stay in sync with
the rest of your cloud infrastructure. Authentication is handled through the same methods as Terraform: using environment variables such as `INFISICAL_TOKEN` and `INFISICAL_SITE_URL`.

By bridging the Infisical provider, teams using Pulumi can adopt secure, centralized secrets management without compromising on their toolchain or language preferences.


# Ruby on Rails
Source: https://infisical.com/docs/integrations/frameworks/rails

How to use Infisical to inject environment variables and secrets into a Ruby on Rails app.

Prerequisites:

* Set up and add envars to [Infisical Cloud](https://app.infisical.com)
* [Install the CLI](/cli/overview)

## Initialize Infisical for your [Rails](https://rubyonrails.org) app

```bash  theme={"dark"}
# navigate to the root of your of your project 
cd /path/to/project

# then initialize Infisical
infisical init
```

## Start your application as usual but with Infisical

```bash  theme={"dark"}
infisical run -- <your application start command>

# Example 
infisical run -- bin/rails server
```


# React
Source: https://infisical.com/docs/integrations/frameworks/react

How to use Infisical to inject environment variables and secrets into a React app.

Prerequisites:

* Set up and add envars to [Infisical Cloud](https://app.infisical.com)
* [Install the CLI](/cli/overview)

## Initialize Infisical for your [Create React App](https://create-react-app.dev)

```bash  theme={"dark"}
# navigate to the root of your of your project 
cd /path/to/project

# then initialize infisical
infisical init
```

## Start your application as usual but with Infisical

```bash  theme={"dark"}
infisical run -- <your application start command>

# Example
infisical run -- npm run dev
```

<Info>
  React environment variables must be prefixed with `REACT_APP_` to show up within the application
</Info>


# Remix
Source: https://infisical.com/docs/integrations/frameworks/remix

How to use Infisical to inject environment variables and secrets into a Remix app.

Prerequisites:

* Set up and add envars to [Infisical Cloud](https://app.infisical.com)
* [Install the CLI](/cli/overview)

## Initialize Infisical for your [Remix](https://remix.run) app

```bash  theme={"dark"}
# navigate to the root of your of your project 
cd /path/to/project

# then initialize Infisical
infisical init
```

## Start your application as usual but with Infisical

```bash  theme={"dark"}
infisical run -- <your application start command>

# Example
infisical run -- npm run dev
```


# Spring Boot with Maven
Source: https://infisical.com/docs/integrations/frameworks/spring-boot-maven

How to use Infisical to inject environment variables into Java Spring Boot

Prerequisites:

* Set up and add your environment variables to [Infisical Cloud](https://app.infisical.com)
* [Install the CLI](/cli/overview)

## Initialize Infisical

In order for Infisical to know which secrets to fetch, you'll need to first initialize Infisical at the root of your project.

```bash  theme={"dark"}
# navigate to the root of your of your project 
cd /path/to/project

# then initialize Infisical
infisical init
```

## Start your application with Maven wrapper

To pass in Infisical secrets into your application, we will utilize the Infisical CLI to inject the secrets into the Maven wrapper executable, which is used to launch your application.
The Maven wrapper executable should already be present in the root directory of your project.

```bash  theme={"dark"}
infisical run -- ./mvnw spring-boot:run --quiet
```

#### Accessing injected secrets

```java example.java theme={"dark"}
  ...
  import org.springframework.core.env.Environment;

  @SpringBootApplication
  public class DemoApplication {
    @Autowired
    private Environment env;

    @Bean
    public void someMethod() {
        System.out.println(env.getProperty("SOME_SECRET_NAME"));
      };
  }
```

## Debugging with secrets

During the process of debugging your code, it may be necessary to have certain environment variables available. To inject these variables for the purpose of debugging, please follow the instructions provided below.
Note that these instructions are currently only available for IntelliJ.

**Step 1:** On the main tool bar, choose Edit Configuration

<img height="200" src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/spring-maven-debug-1.png" />

**Step 2:** Click the plus icon

<img height="200" src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/spring-maven-debug-2.png" />

**Step 3:** Select Shell Script

<img height="200" src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/spring-maven-debug-3.png" />

**Step 4:** Choose Script Text and then paste in the command below.

<img height="200" src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/spring-maven-debug-4.png" />

```
infisical run -- ./mvnw spring-boot:run -Dspring-boot.run.jvmArguments="-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=*:5005"
```

**Step 5:** When you need to run a block of code in debug mode, select the Infisical script

<img height="200" src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/spring-maven-debug-5.png" />


# SvelteKit
Source: https://infisical.com/docs/integrations/frameworks/sveltekit

How to use Infisical to inject environment variables and secrets into a SvelteKit app.

Prerequisites:

* Set up and add envars to [Infisical Cloud](https://app.infisical.com)
* [Install the CLI](/cli/overview)

## Initialize Infisical for your [SvelteKit](https://kit.svelte.dev) app

```bash  theme={"dark"}
# navigate to the root of your of your project 
cd /path/to/project

# then initialize infisical
infisical init
```

## Start your application as usual but with Infisical

```bash  theme={"dark"}
infisical run -- <your application start command>

# Example
infisical run -- npm run dev
```

<Note>
  Note that for environment variables to be exposed to the client, you'll have
  to prefix them with `PUBLIC_`. Read more about that
  [here](https://kit.svelte.dev/docs/modules#\$env-static-public).
</Note>


# Terraform
Source: https://infisical.com/docs/integrations/frameworks/terraform

Learn how to fetch secrets from Infisical with Terraform using both traditional data sources and ephemeral resources



# Vite
Source: https://infisical.com/docs/integrations/frameworks/vite

How to use Infisical to inject environment variables and secrets into a Vite app.

Prerequisites:

* Set up and add envars to [Infisical Cloud](https://app.infisical.com)
* [Install the CLI](/cli/overview)

## Initialize Infisical for your [Vite](https://vitejs.dev) app

```bash  theme={"dark"}
# navigate to the root of your of your project 
cd /path/to/project

# then initialize Infisical
infisical init
```

## Start your application as usual but with Infisical

```bash  theme={"dark"}
infisical run -- <your application start command>

# Example
infisical run -- npm run dev
```

<Note>
  Note that for environment variables to be exposed to the client, you'll have
  to prefix them with `VITE_` and export them from the `vite.config.js` file.
  Read more about that [here](https://vitejs.dev/guide/env-and-mode.html) and
  [here](https://main.vitejs.dev/config).
</Note>


# Vue
Source: https://infisical.com/docs/integrations/frameworks/vue

How to use Infisical to inject environment variables and secrets into a Vue.js app.

Prerequisites:

* Set up and add envars to [Infisical Cloud](https://app.infisical.com)
* [Install the CLI](/cli/overview)

## Initialize Infisical for your [Vue](https://vuejs.org) app

```bash  theme={"dark"}
# navigate to the root of your of your project 
cd /path/to/project

# then initialize infisical
infisical init
```

## Start your application as usual but with Infisical

```bash  theme={"dark"}
infisical run -- <your application start command>

# Example
infisical run -- npm run dev
```

<Note>
  Note that for environment variables to be exposed to the client, you'll have
  to prefix them with `VUE_APP` Read more about that
  [here](https://cli.vuejs.org/guide/mode-and-env.html).
</Note>


# Machine Authentication
Source: https://infisical.com/docs/integrations/machine-authentication

Browse and search through all available machine authentication methods for Infisical.

export const MachineAuthenticationBrowser = () => {
  const [searchTerm, setSearchTerm] = useState('');
  const [selectedCategory, setSelectedCategory] = useState('All');
  const categories = ['All', 'Token-based', 'Cloud Provider', 'Kubernetes', 'Certificate-based', 'Directory-based'];
  const authMethods = [{
    "name": "Universal Auth",
    "slug": "universal-auth",
    "path": "/documentation/platform/identities/universal-auth",
    "description": "Learn how to authenticate machines using Universal Auth tokens with client ID and secret.",
    "category": "Token-based"
  }, {
    "name": "Token Auth",
    "slug": "token-auth",
    "path": "/documentation/platform/identities/token-auth",
    "description": "Learn how to authenticate machines using long-lived access tokens.",
    "category": "Token-based"
  }, {
    "name": "JWT Auth",
    "slug": "jwt-auth",
    "path": "/documentation/platform/identities/jwt-auth",
    "description": "Learn how to authenticate machines using JSON Web Tokens (JWT).",
    "category": "Token-based"
  }, {
    "name": "AWS Auth",
    "slug": "aws-iam-auth",
    "path": "/documentation/platform/identities/aws-auth",
    "description": "Learn how to authenticate AWS services and resources using IAM roles.",
    "category": "Cloud Provider"
  }, {
    "name": "Azure Auth",
    "slug": "azure-auth",
    "path": "/documentation/platform/identities/azure-auth",
    "description": "Learn how to authenticate Azure services using managed identities.",
    "category": "Cloud Provider"
  }, {
    "name": "GCP Auth",
    "slug": "gcp-auth",
    "path": "/documentation/platform/identities/gcp-auth",
    "description": "Learn how to authenticate GCP services using service accounts.",
    "category": "Cloud Provider"
  }, {
    "name": "Alibaba Cloud Auth",
    "slug": "alicloud-auth",
    "path": "/documentation/platform/identities/alicloud-auth",
    "description": "Learn how to authenticate Alibaba Cloud services using RAM roles.",
    "category": "Cloud Provider"
  }, {
    "name": "OCI Auth",
    "slug": "oci-auth",
    "path": "/documentation/platform/identities/oci-auth",
    "description": "Learn how to authenticate Oracle Cloud Infrastructure services.",
    "category": "Cloud Provider"
  }, {
    "name": "Kubernetes Auth",
    "slug": "kubernetes-auth",
    "path": "/documentation/platform/identities/kubernetes-auth",
    "description": "Learn how to authenticate Kubernetes workloads using service account tokens.",
    "category": "Kubernetes"
  }, {
    "name": "OIDC Auth",
    "slug": "oidc-auth-general",
    "path": "/documentation/platform/identities/oidc-auth/general",
    "description": "Learn how to authenticate machines using OpenID Connect (OIDC) providers.",
    "category": "Token-based"
  }, {
    "name": "OIDC Auth for GitHub Actions",
    "slug": "oidc-auth-github",
    "path": "/documentation/platform/identities/oidc-auth/github",
    "description": "Learn how to authenticate GitHub Actions using OIDC.",
    "category": "Token-based"
  }, {
    "name": "OIDC Auth for GitLab CI/CD",
    "slug": "oidc-auth-gitlab",
    "path": "/documentation/platform/identities/oidc-auth/gitlab",
    "description": "Learn how to authenticate GitLab CI/CD using OIDC.",
    "category": "Token-based"
  }, {
    "name": "OIDC Auth for Azure",
    "slug": "oidc-auth-azure",
    "path": "/documentation/platform/identities/oidc-auth/azure",
    "description": "Learn how to authenticate Azure services using OIDC.",
    "category": "Token-based"
  }, {
    "name": "OIDC Auth for CircleCI",
    "slug": "oidc-auth-circleci",
    "path": "/documentation/platform/identities/oidc-auth/circleci",
    "description": "Learn how to authenticate CircleCI workflows using OIDC.",
    "category": "Token-based"
  }, {
    "name": "OIDC Auth for Terraform Cloud",
    "slug": "oidc-auth-terraform",
    "path": "/documentation/platform/identities/oidc-auth/terraform-cloud",
    "description": "Learn how to authenticate Terraform Cloud using OIDC.",
    "category": "Token-based"
  }, {
    "name": "OIDC Auth for SPIRE",
    "slug": "oidc-auth-spire",
    "path": "/documentation/platform/identities/oidc-auth/spire",
    "description": "Learn how to authenticate workloads using SPIFFE/SPIRE OIDC.",
    "category": "Token-based"
  }, {
    "name": "TLS Certificate Auth",
    "slug": "tls-cert-auth",
    "path": "/documentation/platform/identities/tls-cert-auth",
    "description": "Learn how to authenticate machines using TLS client certificates.",
    "category": "Certificate-based"
  }, {
    "name": "LDAP Auth",
    "slug": "ldap-auth-general",
    "path": "/documentation/platform/identities/ldap-auth/general",
    "description": "Learn how to authenticate machines using LDAP credentials.",
    "category": "Directory-based"
  }, {
    "name": "LDAP Auth for JumpCloud",
    "slug": "ldap-auth-jumpcloud",
    "path": "/documentation/platform/identities/ldap-auth/jumpcloud",
    "description": "Learn how to authenticate machines using JumpCloud LDAP.",
    "category": "Directory-based"
  }].sort(function (a, b) {
    return a.name.toLowerCase().localeCompare(b.name.toLowerCase());
  });
  const filteredAuthMethods = useMemo(() => {
    let filtered = authMethods;
    if (selectedCategory !== 'All') {
      filtered = filtered.filter(method => method.category === selectedCategory);
    }
    if (searchTerm) {
      filtered = filtered.filter(method => method.name.toLowerCase().includes(searchTerm.toLowerCase()) || method.description.toLowerCase().includes(searchTerm.toLowerCase()) || method.category.toLowerCase().includes(searchTerm.toLowerCase()));
    }
    return filtered;
  }, [searchTerm, selectedCategory]);
  return <div className="max-w-none">
      {}
      <div className="mb-6">
        <div className="relative w-full">
          <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
            <svg className="h-4 w-4 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
            </svg>
          </div>
          <input type="text" placeholder="Search machine authentication methods..." className="block w-full pl-9 pr-3 py-2 text-sm border border-gray-300 rounded-lg placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-yellow-500 focus:border-yellow-500 bg-white shadow-sm" value={searchTerm} onChange={e => setSearchTerm(e.target.value)} />
        </div>
      </div>

      {}
      <div className="mb-6">
        <div className="flex flex-wrap gap-2">
          {categories.map(category => <button key={category} onClick={() => setSelectedCategory(category)} className={`px-3 py-1.5 text-sm font-medium rounded-lg transition-colors shadow-sm ${selectedCategory === category ? 'bg-yellow-100 text-yellow-700 border border-yellow-200' : 'bg-white text-gray-700 border border-gray-200 hover:bg-yellow-50 hover:border-yellow-200'}`}>
              {category}
            </button>)}
        </div>
      </div>

      {}
      <div className="mb-4">
        <p className="text-sm text-gray-600">
          {filteredAuthMethods.length} authentication method{filteredAuthMethods.length !== 1 ? 's' : ''} found
          {selectedCategory !== 'All' && ` in ${selectedCategory}`}
          {searchTerm && ` for "${searchTerm}"`}
        </p>
      </div>

      {}
      {filteredAuthMethods.length > 0 ? <div className="space-y-4">
          {filteredAuthMethods.map((method, index) => <a key={method.slug} href={method.path} className="group block px-4 py-3 border border-gray-200 rounded-xl hover:border-yellow-200 hover:bg-yellow-50/50 hover:shadow-sm transition-all duration-200 bg-white shadow-sm">
              <div className="w-full">
                <div className="flex items-center justify-between mb-0.5">
                  <h3 className="text-base font-medium text-gray-900 leading-none m-0">
                    {method.name}
                  </h3>
                  <span className="ml-3 inline-flex items-center px-3 py-1 rounded-full text-xs font-medium bg-yellow-100 text-yellow-700 flex-shrink-0">
                    {method.category}
                  </span>
                </div>
                <p className="text-sm text-gray-600 leading-relaxed">
                  {method.description}
                </p>
              </div>
            </a>)}
        </div> : <div className="text-center py-8">
          <div className="flex flex-col items-center space-y-2">
            <p className="text-gray-500">No authentication methods found matching your criteria</p>
            {searchTerm && <p className="text-gray-400 text-sm">Try adjusting your search terms or filters</p>}
          </div>
        </div>}
    </div>;
};

<MachineAuthenticationBrowser />


# Ansible
Source: https://infisical.com/docs/integrations/platforms/ansible

Learn how to use Infisical for secret management in Ansible.

You can find the Infisical Ansible collection on [Ansible Galaxy](https://galaxy.ansible.com/ui/repo/published/infisical/vault/).

This Ansible Infisical collection includes a variety of Ansible content to help automate the management of Infisical services. This collection is maintained by the Infisical team.

## Ansible version compatibility

Tested with the Ansible Core >= 2.12.0 versions, and the current development version of Ansible. Ansible Core versions prior to 2.12.0 have not been tested.

## Python version compatibility

This collection depends on the Infisical SDK for Python.

Requires Python 3.7 or greater.

## Installing this collection

You can install the Infisical collection with the Ansible Galaxy CLI:

```bash  theme={"dark"}
$ ansible-galaxy collection install infisical.vault
```

The python module dependencies are not installed by ansible-galaxy. They can be manually installed using pip:

```bash  theme={"dark"}
$ pip install infisicalsdk
```

## Using this collection

You can either call modules by their Fully Qualified Collection Name (FQCN), such as `infisical.vault.read_secrets`, or you can call modules by their short name if you list the `infisical.vault` collection in the playbook's collections keyword:

### Authentication

The Infisical Ansible Collection supports [Universal Auth](/documentation/platform/identities/universal-auth) and [OIDC](/documentation/platform/identities/oidc-auth/general) for authenticating against Infisical.

<AccordionGroup>
  <Accordion title="Universal Auth">
    Using Universal Auth for authentication is the most straight-forward way to get started with using the Ansible collection.

    To use Universal Auth, you need to provide the Client ID and Client Secret of your Infisical Machine Identity.

    ```yaml  theme={"dark"}
    lookup('infisical.vault.read_secrets', auth_method="universal-auth", universal_auth_client_id='<client-id>', universal_auth_client_secret='<client-secret>' ...rest)
    ```

    You can also provide the `auth_method`, `universal_auth_client_id`, and `universal_auth_client_secret` parameters through environment variables:

    | Parameter Name                 | Environment Variable Name                |
    | ------------------------------ | ---------------------------------------- |
    | `auth_method`                  | `INFISICAL_AUTH_METHOD`                  |
    | `universal_auth_client_id`     | `INFISICAL_UNIVERSAL_AUTH_CLIENT_ID`     |
    | `universal_auth_client_secret` | `INFISICAL_UNIVERSAL_AUTH_CLIENT_SECRET` |
  </Accordion>

  <Accordion title="OIDC Auth">
    To use OIDC Auth, you'll need to provide the ID of your machine identity, and the OIDC JWT to be used for authentication.

    <Note>
      Please note that in order to use OIDC Auth, you must have `1.0.10` or newer of the `infisicalsdk` package installed.
    </Note>

    ```yaml  theme={"dark"}
    lookup('infisical.vault.read_secrets', auth_method="oidc-auth", identity_id='<identity-id>', jwt='<oidc-jwt>' ...rest)
    ```

    You can also provide the `auth_method`, `identity_id`, and `jwt` parameters through environment variables:

    | Parameter Name | Environment Variable Name |
    | -------------- | ------------------------- |
    | auth\_method   | `INFISICAL_AUTH_METHOD`   |
    | identity\_id   | `INFISICAL_IDENTITY_ID`   |
    | jwt            | `INFISICAL_JWT`           |
  </Accordion>
</AccordionGroup>

### Examples

```yaml  theme={"dark"}
---
vars:
  read_all_secrets_within_scope: "{{ lookup('infisical.vault.read_secrets', universal_auth_client_id='<>', universal_auth_client_secret='<>', project_id='<>', path='/', env_slug='dev', url='https://spotify.infisical.com') }}"
  # [{ "key": "HOST", "value": "google.com" }, { "key": "SMTP", "value": "gmail.smtp.edu" }]


  read_all_secrets_as_dict: "{{ lookup('infisical.vault.read_secrets', as_dict=True, universal_auth_client_id='<>', universal_auth_client_secret='<>', project_id='<>', path='/', env_slug='dev', url='https://spotify.infisical.com') }}"
  # { "SECRET_KEY_1": "secret-value-1", "SECRET_KEY_2": "secret-value-2" } -> Can be accessed as secrets.SECRET_KEY_1


  read_secret_by_name_within_scope: "{{ lookup('infisical.vault.read_secrets', universal_auth_client_id='<>', universal_auth_client_secret='<>', project_id='<>', path='/', env_slug='dev', secret_name='HOST', url='https://spotify.infisical.com') }}"
  # { "key": "HOST", "value": "google.com" }
```

## Troubleshoot

<Accordion title="I'm getting a error related to objc[72832]: +[__NSCFConstantString initialize]">
  If you get this Python error when you running the lookup plugin:-

  ```
  objc[72832]: +[__NSCFConstantString initialize] may have been in progress in another thread when fork() was called. We cannot safely call it or ignore it in the fork() child process. Crashing instead. Set a breakpoint on objc_initializeAfterForkError to debug.
  Fatal Python error: Aborted
  ```

  You will need to add this to your shell environment or ansible wrapper script:-

  ```
  export OBJC_DISABLE_INITIALIZE_FORK_SAFETY=YES
  ```
</Accordion>


# Apache Airflow
Source: https://infisical.com/docs/integrations/platforms/apache-airflow

Learn how to use Infisical as your custom secrets backend in Apache Airflow.



# Docker Entrypoint
Source: https://infisical.com/docs/integrations/platforms/docker

Learn how to use Infisical to inject environment variables into a Docker container.

This approach allows you to inject secrets from Infisical directly into your application.
This is achieved by installing the Infisical CLI into your docker image and modifying your start command to execute with Infisical.

## Install the Infisical CLI to your Dockerfile

To install the CLI, follow the instructions for your chosen distribution [here](/cli/overview).

####

<Tip>
  We recommend you to set the version of the CLI to a specific version. This will help keep your CLI version consistent across reinstalls. [View versions](https://cloudsmith.io/~infisical/repos/infisical-cli/packages/)
</Tip>

## Modify the start command in your Dockerfile

Starting your service with the Infisical CLI pulls your secrets from Infisical and injects them into your service.

<Tabs>
  <Tab title="Machine Identity (Recommended)">
    ```dockerfile  theme={"dark"}
    CMD ["infisical", "run", "--projectId", "<your-project-id>", "--", "[your service start command]"]

    # example with single single command

    CMD ["infisical", "run", "--projectId", "<your-project-id>", "--", "npm", "run", "start"]

    # example with multiple commands

    CMD ["infisical", "run", "--projectId", "<your-project-id>", "--command", "npm run start && ..."]

    ```

    <Steps>
      <Step title="Generate a machine identity">
        Generate a machine identity for your project by following the steps in the [Machine Identity](/documentation/platform/identities/machine-identities) guide. The machine identity will allow you to authenticate and fetch secrets from Infisical.
      </Step>

      <Step title="Obtain an access token for the machine identity">
        Obtain an access token for the machine identity by running the following command:

        ```bash  theme={"dark"}
        export INFISICAL_TOKEN=$(infisical login --method=universal-auth --client-id=<your-client-id> --client-secret=<your-client-secret> --plain --silent)
        ```

        <Info>
          Please note that the access token has a limited lifespan. The `infisical token renew` command can be used to renew the token if needed.
        </Info>
      </Step>

      <Step title="Feed the access token to the docker container">
        The last step is to give the Infisical CLI installed in your Docker container access to the access token. This will allow the CLI to fetch and inject the secrets into your application.

        To feed the access token to the container, use the INFISICAL\_TOKEN environment variable as shown below.

        ```bash  theme={"dark"}
        docker run --env INFISICAL_TOKEN=$INFISICAL_TOKEN [DOCKER-IMAGE]...
        ```
      </Step>
    </Steps>

    ### Using a Starting Script

    The drawback of the previous method is that you would have to generate the `INFISICAL_TOKEN` manually. To automate this process, you can use a shell script as your starting command.

    <Steps>
      <Step title="Generate a Machine Identity">
        Create a machine identity for your project by following the steps in the [Machine Identity](/documentation/platform/identities/machine-identities) guide. This identity will enable authentication and secret retrieval from Infisical.
      </Step>

      <Step title="Create the Shell Script">
        Create a shell script to obtain an access token for the machine identity:

        ```bash script.sh theme={"dark"}
        #!/bin/sh
        export INFISICAL_TOKEN=$(infisical login --method=universal-auth --client-id=$INFISICAL_MACHINE_CLIENT_ID --client-secret=$INFISICAL_MACHINE_CLIENT_SECRET --plain --silent)
        exec infisical run --token $INFISICAL_TOKEN --projectId $PROJECT_ID --env $INFISICAL_SECRET_ENV --domain $INFISICAL_API_URL -- <starting script>
        ```

        > **Note:** The access token has a limited lifespan. Use the [infisical token renew](/cli/commands/token) CLI command to renew it when necessary.

        <Warning>
          Caution: Implementing this directly in your Dockerfile presents two key issues:

          1. Lack of persistence: Variables set in one build step are not automatically carried over to subsequent steps, complicating the process.
          2. Security risk: It exposes sensitive credentials inside your container, potentially allowing anyone with container access to retrieve them.
        </Warning>
      </Step>

      <Step title="Update Your Dockerfile">
        Grant the Infisical CLI access to the access token, inside your Docker container. This allows the CLI to fetch and inject secrets into your application.

        Add the following line to your Dockerfile:

        ```dockerfile  theme={"dark"}
        CMD ["./script.sh"]
        ```
      </Step>
    </Steps>
  </Tab>

  <Tab title="Service Token (Deprecated)">
    ```dockerfile  theme={"dark"}
    CMD ["infisical", "run", "--", "[your service start command]"]

    # example with single single command
    CMD ["infisical", "run", "--", "npm", "run", "start"]

    # example with multiple commands
    CMD ["infisical", "run", "--command", "npm run start && ..."]
    ```

    <Steps>
      <Step title="Generate a service token">
        Head to your project settings in the Infisical dashboard to generate an [service token](/documentation/platform/token).
        This service token will allow you to authenticate and fetch secrets from Infisical.
        Once you have created a service token with the required permissions, youll need to feed the token to the CLI installed in your docker container.
      </Step>

      <Step title="Feed service token to docker container">
        The last step is to give the Infisical CLI installed in your Docker container access to the service token. This will allow the CLI to fetch and inject the secrets into your application.

        To feed the service token to the container, use the INFISICAL\_TOKEN environment variable as shown below.

        ```bash  theme={"dark"}
        docker run --env INFISICAL_TOKEN=[token] [DOCKER-IMAGE]...
        ```
      </Step>
    </Steps>
  </Tab>
</Tabs>


# Docker Compose
Source: https://infisical.com/docs/integrations/platforms/docker-compose

Find out how to use Infisical to inject environment variables into services defined in your Docker Compose file.

Prerequisites:

* Set up and add envars to [Infisical Cloud](https://app.infisical.com)

## Configure the Infisical CLI for each service

Follow this [guide](./docker) to configure the Infisical CLI for each service that you wish to inject environment variables into; you'll have to update the Dockerfile of each service.

<Tabs>
  <Tab title="Machine Identity (Recommended)">
    ### Generate and configure machine identity

    Generate a machine identity for each service you want to inject secrets into. You can do this by following the steps in the [Machine Identity](/documentation/platform/identities/machine-identities) guide.

    ### Set the machine identity client ID and client secret as environment variables

    For each service you want to inject secrets into, generate the required `INFISICAL_TOKEN_SERVICE_A` and `INFISICAL_TOKEN_SERVICE_B`.

    ```yaml  theme={"dark"}
    # Example Docker Compose file
    services:
      web:
        build: .
        image: example-service-1
        environment:
          - INFISICAL_TOKEN=${INFISICAL_TOKEN_SERVICE_A}

      api:
        build: .
        image: example-service-2
        environment:
          - INFISICAL_TOKEN=${INFISICAL_TOKEN_SERVICE_B}

    ```

    ### Export shell variables

    Next, set the shell variables you defined in your compose file. This can be done manually or via your CI/CD environment. Once done, it will be used to populate the corresponding `INFISICAL_TOKEN_SERVICE_A` and `INFISICAL_TOKEN_SERVICE_B` in your Docker Compose file.

    ```bash  theme={"dark"}
    #Example

    # Token refers to the token we generated in step 2 for this service
    export INFISICAL_TOKEN_SERVICE_A=$(infisical login --method=universal-auth --client-id=<your-client-id> --client-secret=<your-client-secret> --silent --plain)
    export INFISICAL_TOKEN_SERVICE_B=$(infisical login --method=universal-auth --client-id=<your-client-id> --client-secret=<your-client-secret> --silent --plain)

    # Then run your compose file in the same terminal.
    docker-compose ...
    ```
  </Tab>

  <Tab title="Service Token">
    ## Generate service token

    Generate a unique [Service Token](/documentation/platform/token) for each service.

    ## Feed service token to your Docker Compose file

    For each service you want to inject secrets into, set an environment variable called `INFISICAL_TOKEN` equal to a unique identifier variable.

    In the example below, we set `INFISICAL_TOKEN_FOR_WEB` and `INFISICAL_TOKEN_FOR_API` as the `INFISICAL_TOKEN` for the services.

    ```yaml  theme={"dark"}
    # Example Docker Compose file
    services:
      web:
        build: .
        image: example-service-1
        environment:
          - INFISICAL_TOKEN=${INFISICAL_TOKEN_FOR_WEB}

      api:
        build: .
        image: example-service-2
        environment:
          - INFISICAL_TOKEN=${INFISICAL_TOKEN_FOR_API}
    ```

    ## Export shell variables

    Next, set the shell variables you defined in your compose file. This can be done manually or via your CI/CD environment. Once done, it will be used to populate the corresponding `INFISICAL_TOKEN`
    in your Docker Compose file.

    ```bash  theme={"dark"}
    #Example

    # Token refers to the token we generated in step 2 for this service
    export INFISICAL_TOKEN_FOR_WEB=<token>

    # Token refers to the token we generated in step 2 for this service
    export INFISICAL_TOKEN_FOR_API=<token>

    # Then run your compose file in the same terminal.
    docker-compose ...
    ```
  </Tab>
</Tabs>


# Docker
Source: https://infisical.com/docs/integrations/platforms/docker-intro

Learn how to feed secrets from Infisical into your Docker application.

There are many methods to inject Infisical secrets into Docker-based applications.
Regardless of the method you choose, they all inject secrets from Infisical as environment variables into your Docker container.

<Card title="Docker Entrypoint" color="#ea5a0c" href="./docker">
  Install and run your app start command with Infisical CLI
</Card>

<CardGroup cols={2}>
  <Card title="Docker run" color="#0285c7" href="./docker-pass-envs">
    Feed secrets with the `--env-file` flag when using the
    `docker run` command
  </Card>

  <Card title="Docker compose" color="#16a34a" href="./docker-compose">
    Inject secrets into multiple services using Docker Compose
  </Card>
</CardGroup>

<Info>
  The main difference between the "Docker Entrypoint" and "Docker run" approach is where the Infisical CLI is installed.
  In most production settings, it's typically less convenient to have the Infisical CLI installed and executed externally, so we suggest using the "Docker Entrypoint" method for production purposes.
  However, if this limitation doesn't apply to you, select the method that best fits your needs.
</Info>


# Docker Run
Source: https://infisical.com/docs/integrations/platforms/docker-pass-envs

Learn how to pass secrets to your docker container at run time.

This method allows you to feed secrets from Infisical into your container using the `--env-file` flag of `docker run` command.
Rather than giving the flag a file path to your env file, you'll use the Infisical CLI to create a virtual file path.

For this method to function as expected, you must have a bash shell (for processing substitution) and the [Infisical CLI](../../cli/overview) installed in the environment where you will be running the `docker run` command.

## 1. Authentication

If you are already logged in via the CLI you can skip this step. Otherwise, head to your organization settings in Infisical Cloud to create a [Machine Identity](../../documentation/platform/identities/machine-identities). The machine identity will allow you to authenticate and fetch secrets from Infisical.
Once you have created a machine identity with the required permissions, you'll need to feed the token to the CLI.

<Info>
  Please note that we highly recommend using `infisical login` for local development.
</Info>

#### Pass as flag

You may use the --token flag to set the token

```bash  theme={"dark"}
infisical export --token=<>
```

#### Pass via shell environment variable

The CLI is configured to look for an environment variable named `INFISICAL_TOKEN`. If set, it'll attempt to use it for authentication.

```bash  theme={"dark"}
export INFISICAL_TOKEN=<>
```

You can use the `infisical login --method=universal-auth` command to directly obtain a universal auth access token and set it as an environment variable.

```bash  theme={"dark"}
  export INFISICAL_TOKEN=$(infisical login --method=universal-auth --client-id=<your-client-id> --client-secret=<your-client-secret> --silent --plain)
```

<Warning>
  In production scenarios, please to avoid using the `infisical login` command and instead use a [machine identity](../../documentation/platform/identities/machine-identities).
</Warning>

## 2. Run your docker command with Infisical

Next, use the --env-file flag of the `docker run` command with Infisical CLI to point to your secrets.
Under the hood, this command will fetch secrets from Infisical and serve them as a file to the `--env-file` flag.

```bash  theme={"dark"}
# In this example, executing a docker run command will initiate an empty Alpine container and display the environment variables passed to it by Infisical.
docker run --rm --env-file <(infisical export --format=dotenv) alpine printenv
```

To view all options of the `export` command, click [here](../../cli/commands/export)

<Warning>
  When using the --env-file option, Docker does not have the capability to support secrets that span multiple lines.
</Warning>


# Docker Swarm
Source: https://infisical.com/docs/integrations/platforms/docker-swarm-with-agent

Learn how to manage secrets in Docker Swarm services.

In this guide, we'll demonstrate how to use Infisical for managing secrets within Docker Swarm.
Specifically, we'll set up a sidecar container using the [Infisical Agent](/integrations/platforms/infisical-agent), which authenticates with Infisical to retrieve secrets and access tokens.
These secrets are then stored in a shared volume accessible by other services in your Docker Swarm.

## Prerequisites

* Infisical account
* Docker version 20.10.24 or newer
* Basic knowledge of Docker Swarm
* [Git](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git) installed on your system
* Familiarity with the [Infisical Agent](/integrations/platforms/infisical-agent)

## Objective

Our goal is to deploy an Nginx instance in your Docker Swarm cluster, configured to display Infisical secrets on its landing page. This will provide hands-on experience in fetching and utilizing secrets from Infisical within Docker Swarm. The principles demonstrated here are also applicable to Docker Compose deployments.

<Steps>
  <Step title="Cloning the Guide Assets Repository">
    Start by cloning the [Infisical guide assets repository](https://github.com/Infisical/infisical-guides.git) from Github. This repository includes necessary assets for this and other Infisical guides. Focus on the `docker-swarm-with-agent` sub-directory, which we'll use as our working directory.
  </Step>

  <Step title="Setting Up Authentication with Infisical">
    To allow the agent to fetch your Infisical secrets, choose an authentication method for the agent. For this guide, we will use [Universal Auth](/documentation/platform/identities/universal-auth) for authentication. Follow the instructions [here](/documentation/platform/identities/universal-auth) to generate a client ID and client secret.
  </Step>

  <Step title="Entering Universal Auth Credentials">
    Copy the client ID and client secret obtained in the previous step into the `client-id` and `client-secret` text files, respectively.
  </Step>

  <Step title="Configuring the Infisical Agent">
    The Infisical Agent will authenticate using Universal Auth and retrieve secrets for rendering as specified in the template(s).
    Adjust the `polling-interval` to control the frequency of secret updates.

    In the example template, the secrets are rendered as an HTML page, which will be set as Nginx's home page to demonstrate successful secret retrieval and utilization.

    <Tip>
      Remember to add your project id, environment slug and path of corresponding Infisical project to the secret template.
    </Tip>

    <Tabs>
      <Tab title="Agent Configuration">
        ```yaml infisical-agent-config theme={"dark"}
        infisical:
        address: "https://app.infisical.com"
        auth:
          type: "universal-auth"
          config:
            client-id: "/run/secrets/infisical-universal-auth-client-id"
            client-secret: "/run/secrets/infisical-universal-auth-client-secret"
            remove_client_secret_on_read: false
        sinks:
          - type: "file"
            config:
              path: "/infisical-secrets/access-token"
        templates:
          - source-path: /run/secrets/nginx-home-page-template
            destination-path: /infisical-secrets/index.html
            config:
              polling-interval: 60s
        ```

        <Info>
          Some paths contain `/run/secrets/` because the contents of those files reside in a [Docker secret](https://docs.docker.com/engine/swarm/secrets/#how-docker-manages-secrets).
        </Info>
      </Tab>

      <Tab title="Secret Template for Agent">
        ```html nginx-home-page-template theme={"dark"}
        <!DOCTYPE html>
        <html lang="en">
        <body>
            <h1>This file is rendered by Infisical agent template engine</h1>
            <p>Here are the secrets that have been fetched from Infisical and stored in your volume mount</p>
            <ol>
              {{- with secret "7df67a5f-d26a-4988-a375-7153c08149da" "dev" "/" }}
              {{- range . }}
              <li>{{ .Key }}={{ .Value }}</li>
              {{- end }}
              {{- end }}
            </ol>
        </body>
        </html>
        ```
      </Tab>
    </Tabs>
  </Step>

  <Step title="Creating the Docker Compose File">
    Define the `infisical-agent` and `nginx` services in your Docker Compose file. `infisical-agent` will handle secret retrieval and storage. These secrets are stored in a volume, accessible by other services like Nginx.

    ```yaml docker-compose.yaml theme={"dark"}
    version: "3.1"

    services:
      infisical-agent:
        container_name: infisical-agnet
        image: infisical/cli:0.18.0
        command: agent --config=/run/secrets/infisical-agent-config
        volumes:
          - infisical-agent:/infisical-secrets
        secrets:
          - infisical-universal-auth-client-id
          - infisical-universal-auth-client-secret
          - infisical-agent-config
          - nginx-home-page-template
        networks:
          - infisical_network

      nginx:
        image: nginx:latest
        ports:
          - "80:80"
        volumes:
          - infisical-agent:/usr/share/nginx/html
        networks:
          - infisical_network

    volumes:
      infisical-agent: 

    secrets:
      infisical-universal-auth-client-id:
        file: ./client-id
      infisical-universal-auth-client-secret:
        file: ./client-secret
      infisical-agent-config:
        file: ./infisical-agent-config
      nginx-home-page-template:
        file: ./nginx-home-page-template
        

    networks:
      infisical_network:
    ```
  </Step>

  <Step title="Initializing Docker Swarm">
    ```
    docker swarm init
    ```
  </Step>

  <Step title="Deploying the Docker Stack">
    ```
    docker stack deploy -c docker-compose.yaml agent-demo
    ```
  </Step>

  <Step title="Verifying Secret Consumption">
    To confirm that secrets are properly rendered and accessible, navigate to `http://localhost`. You should see the Infisical secrets displayed on the Nginx landing page.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/docker-swarm-secrets-complete.png" alt="Nginx displaying Infisical secrets" />
  </Step>

  <Step title="Clean up">
    ```
    docker stack rm agent-demo
    ```
  </Step>
</Steps>

## Considerations

* Secret Updates: Applications that access secrets directly from the volume mount will receive updates in real-time, in accordance with the `polling-interval` set in agent config.
* In-Memory Secrets: If your application loads secrets into memory, the new secrets will be available to the application on the next deployment.


# Amazon ECS
Source: https://infisical.com/docs/integrations/platforms/ecs-with-agent

Learn how to deliver secrets to Amazon Elastic Container Service.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/guides/agent-with-ecs/ecs-diagram.png" alt="ecs diagram" />

This guide will go over the steps needed to access secrets stored in Infisical from Amazon Elastic Container Service (ECS).

At a high level, the steps involve setting up an ECS task with an [Infisical Agent](/integrations/platforms/infisical-agent) as a sidecar container. This sidecar container uses [AWS Auth](/documentation/platform/identities/aws-auth) to authenticate with Infisical to fetch secrets/access tokens.
Once the secrets/access tokens are retrieved, they are then stored in a shared [Amazon Elastic File System](https://aws.amazon.com/efs/) (EFS) volume. This volume is then made accessible to your application and all of its replicas.

This guide primarily focuses on integrating Infisical Cloud with Amazon ECS on AWS Fargate and Amazon EFS.
However, the principles and steps can be adapted for use with any instance of Infisical (on premise or cloud) and different ECS launch configurations.

## Prerequisites

This guide requires the following prerequisites:

* Infisical account
* Git installed
* Terraform v1.0 or later installed
* Access to AWS credentials
* Understanding of [Infisical Agent](/integrations/platforms/infisical-agent)

## What we will deploy

For this demonstration, we'll deploy the [File Browser](https://github.com/filebrowser/filebrowser) application on our ECS cluster.
Although this guide focuses on File Browser, the principles outlined here can be applied to any application of your choice.

File Browser plays a key role in this context because it enables us to view all files attached to a specific volume.
This feature is important for our demonstration, as it allows us to verify whether the Infisical agent is depositing the expected files into the designated file volume and if those files are accessible to the application.

<Warning>
  Volumes that contain sensitive secrets should not be publicly accessible. The
  use of File Browser here is solely for demonstration and verification
  purposes.
</Warning>

## Configure Authentication with Infisical

In order for the Infisical agent to fetch credentials from Infisical, we'll first need to authenticate with Infisical. Follow the documentation to configure a machine identity with AWS Auth [here](/documentation/platform/identities/aws-auth).
Take note of the Machine Identity ID as you will be needing this in the preceding steps.

## Clone guide assets repository

To help you quickly deploy the example application, please clone the guide assets from this [Github repository](https://github.com/Infisical/infisical-guides.git).
This repository contains assets for all Infisical guides. The content for this guide can be found within a sub directory called `aws-ecs-with-agent`.
The guide will assume that `aws-ecs-with-agent` is your working directory going forward.

## Deploy example application

Before we can deploy our full application and its related infrastructure with Terraform, we'll need to first configure our Infisical agent.

### Agent configuration overview

The agent config file defines what authentication method will be used when connecting with Infisical along with where the fetched secrets/access tokens should be saved to.

Since the Infisical agent will be deployed as a sidecar, the agent configuration file will need to be encoded in base64.
This encoding step is necessary as it allows the agent configuration file to be added into our Terraform configuration without needing to upload it first.

#### Full agent configuration file

Inside the `aws-ecs-with-agent` directory, you will find a sample `agent-config.yaml` file. This agent config file will connect with Infisical Cloud using AWS Auth and deposit access tokens at path `/infisical-agent/access-token` and render secrets to file `/infisical-agent/secrets`.

```yaml agent-config.yaml theme={"dark"}
infisical:
  address: https://app.infisical.com
  exit-after-auth: true
auth:
  type: aws-iam
sinks:
  - type: file
    config:
      path: /infisical-agent/access-token
templates:
  - template-content: |
      {{- with secret "202f04d7-e4cb-43d4-a292-e893712d61fc" "dev" "/" }}
      {{- range . }}
      {{ .Key }}={{ .Value }}
      {{- end }}
      {{- end }}
    destination-path: /infisical-agent/secrets
```

#### Secret template

The Infisical agent accepts one or more optional templates. If provided, the agent will fetch secrets using the set authentication method and format the fetched secrets according to the given template.
Typically, these templates are passed in to the agent configuration file via file reference using the `source-path` property but for simplicity we define them inline.

In the agent configuration above, the template defined will transform the secrets from Infisical project with the ID `202f04d7-e4cb-43d4-a292-e893712d61fc`, in the `dev` environment, and secrets located in the path `/`, into a `KEY=VALUE` format.

<Tip>
  Remember to update the project id, environment slug and secret path to one
  that exists within your Infisical project
</Tip>

## Configure app on terraform

Navigate to the `ecs.tf` file in your preferred code editor. In the container\_definitions section, assign the values to the `machine_identity_id` and `agent_config` properties.
The `agent_config` property expects the base64-encoded agent configuration file. In order to get this, we use the `base64encode` and `file` functions of HCL.

```hcl ecs.tf theme={"dark"}
...snip...
resource "aws_ecs_task_definition" "app" {
  family                   = "cb-app-task"
  execution_role_arn       = aws_iam_role.ecs_task_execution_role.arn
  task_role_arn            = aws_iam_role.ecs_task_role.arn
  network_mode             = "awsvpc"
  requires_compatibilities = ["FARGATE"]
  cpu                      = 4096
  memory                   = 8192
  container_definitions = templatefile("./templates/ecs/cb_app.json.tpl", {
    app_image           = var.app_image
    sidecar_image       = var.sidecar_image
    app_port            = var.app_port
    fargate_cpu         = var.fargate_cpu
    fargate_memory      = var.fargate_memory
    aws_region          = var.aws_region
    machine_identity_id = "5655f4f5-332b-45f9-af06-8f493edff36f"
    agent_config = base64encode(file("../agent-config.yaml"))
  })
  volume {
    name = "infisical-efs"
    efs_volume_configuration {
      file_system_id = aws_efs_file_system.infisical_efs.id
      root_directory = "/"
    }
  }
}
...snip...
```

After these values have been set, they will be passed to the Infisical agent during startup through environment variables, as configured in the `infisical-sidecar` container below.

```terraform templates/ecs/cb_app.json.tpl theme={"dark"}
[
...snip...
  {
    "name": "infisical-sidecar",
    "image": "${sidecar_image}",
    "cpu": 1024,
    "memory": 1024,
    "networkMode": "bridge",
    "command": ["agent"],
    "essential": false,
    "logConfiguration": {
        "logDriver": "awslogs",
        "options": {
          "awslogs-group": "/ecs/agent",
          "awslogs-region": "${aws_region}",
          "awslogs-stream-prefix": "ecs"
        }
    },
    "healthCheck": {
        "command": ["CMD-SHELL", "agent", "--help"],
        "interval": 30,
        "timeout": 5,
        "retries": 3,
        "startPeriod": 0
    },
    "environment": [
      {
        "name": "INFISICAL_MACHINE_IDENTITY_ID",
        "value": "${machine_identity_id}"
      },
      {
        "name": "INFISICAL_AGENT_CONFIG_BASE64",
        "value": "${agent_config}"
      }
    ],
    "mountPoints": [
      {
          "containerPath": "/infisical-agent",
          "sourceVolume": "infisical-efs"
      }
    ]
  }
]
```

In the above container definition, you'll notice that that the Infisical agent has a `mountPoints` defined.
This mount point is referencing to the already configured EFS volume as shown below.
`containerPath` is set to `/infisical-agent` because that is that the folder we have instructed the agent to deposit the credentials to.

```hcl terraform/efs.tf theme={"dark"}
resource "aws_efs_file_system" "infisical_efs" {
  tags = {
    Name = "INFISICAL-ECS-EFS"
  }
}

resource "aws_efs_mount_target" "mount" {
  count           = length(aws_subnet.private.*.id)
  file_system_id  = aws_efs_file_system.infisical_efs.id
  subnet_id       = aws_subnet.private[count.index].id
  security_groups = [aws_security_group.efs_sg.id]
}
```

## Configure AWS credentials

Because we'll be deploying the example file browser application to AWS via Terraform, you will need to obtain a set of `AWS Access Key` and `Secret Key`.
Once you have generated these credentials, export them to your terminal.

1. Export the AWS Access Key ID:

   ```bash  theme={"dark"}
   export AWS_ACCESS_KEY_ID=<your AWS access key ID>
   ```

2. Export the AWS Secret Access Key:

   ```bash  theme={"dark"}
   export AWS_SECRET_ACCESS_KEY=<your AWS secret access key>
   ```

## Deploy terraform configuration

With the agent's sidecar configuration complete, we can now deploy our changes to AWS via Terraform.

1. Change your directory to `terraform`

```sh  theme={"dark"}
cd terraform
```

2. Initialize Terraform

```
$ terraform init
```

3. Preview resources that will be created

```
$ terraform plan
```

4. Trigger resource creation

```bash  theme={"dark"}
$ terraform apply

Do you want to perform these actions?
  Terraform will perform the actions described above.
  Only 'yes' will be accepted to approve.

  Enter a value: yes
```

```bash  theme={"dark"}

Apply complete! Resources: 1 added, 1 changed, 1 destroyed.

Outputs:

alb_hostname = "cb-load-balancer-1675475779.us-east-1.elb.amazonaws.com:8080"
```

Once the resources have been successfully deployed, Terraform will output the host address where the file browser application will be accessible.
It may take a few minutes for the application to become fully ready.

## Verify secrets/tokens in EFS volume

To verify that the agent is depositing access tokens and rendering secrets to the paths specified in the agent config, navigate to the web address from the previous step.
Once you visit the address, you'll be prompted to login. Enter the credentials shown below.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/guides/agent-with-ecs/file_browser_main.png" alt="file browser main login page" />

Since our EFS volume is mounted to the path of the file browser application, we should see the access token and rendered secret file we defined via the agent config file.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/guides/agent-with-ecs/filebrowser_afterlogin.png" alt="file browswer dashbaord" />

As expected, two files are present: `access-token` and `secrets`.
The `access-token` file should hold a valid `Bearer` token, which can be used to make HTTP requests to Infisical.
The `secrets` file should contain secrets, formatted according to the specifications in our secret template file (presented in key=value format).

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/guides/agent-with-ecs/access-token-deposit.png" alt="file browser access token deposit" />

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/guides/agent-with-ecs/secrets-deposit.png" alt="file browser secrets render" />


# Infisical Agent
Source: https://infisical.com/docs/integrations/platforms/infisical-agent

This page describes how to manage secrets using Infisical Agent.

Infisical Agent is a client daemon that simplifies the adoption of Infisical by providing a more scalable and user-friendly approach for applications to interact with Infisical.
It eliminates the need to modify application logic by enabling clients to decide how they want their secrets rendered through the use of templates.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/agent/infisical-agent-diagram.png" alt="agent diagram" />

### Key features:

* Token renewal: Automatically authenticates with Infisical and deposits renewed access tokens at specified path for applications to consume
* Templating: Renders secrets via user provided templates to desired formats for applications to consume

### Token renewal

The Infisical agent can help manage the life cycle of access tokens. The token renewal process is split into two main components: a `Method`, which is the authentication process suitable for your current setup, and `Sinks`, which are the places where the agent deposits the new access token whenever it receives updates.

When the Infisical Agent is started, it will attempt to obtain a valid access token using the authentication method you have configured. If the agent is unable to fetch a valid token, the agent will keep trying, increasing the time between each attempt.

Once a access token is successfully fetched, the agent will make sure the access token stays valid, continuing to renew it before it expires.

Every time the agent successfully retrieves a new access token, it writes the new token to the Sinks you've configured.

<Info>
  Access tokens can be utilized with Infisical SDKs or directly in API requests
  to retrieve secrets from Infisical
</Info>

### Templating

The Infisical agent can help deliver formatted secrets to your application in a variety of environments. To achieve this, the agent will retrieve secrets from Infisical, format them using a specified template, and then save these formatted secrets to a designated file path.

Templating process is done through the use of Go language's [text/template feature](https://pkg.go.dev/text/template).You can refer to the available secret template functions [here](#available-secret-template-functions). Multiple template definitions can be set in the agent configuration file to generate a variety of formatted secret files.

When the agent is started and templates are defined in the agent configuration file, the agent will attempt to acquire a valid access token using the set authentication method outlined in the agent's configuration.
If this initial attempt is unsuccessful, the agent will momentarily pauses before continuing to make more attempts.

Once the agent successfully obtains a valid access token, the agent proceeds to fetch the secrets from Infisical using it.
It then formats these secrets using the user provided templates and writes the formatted data to configured file paths.

## Agent configuration file

To set up the authentication method for token renewal and to define secret templates, the Infisical agent requires a YAML configuration file containing properties defined below.
While specifying an authentication method is mandatory to start the agent, configuring sinks and secret templates are optional.

| Field                                      | Description                                                                                                                                                                                         |
| ------------------------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `infisical.address`                        | The URL of the Infisical service. Default: `"https://app.infisical.com"`.                                                                                                                           |
| `infisical.exit-after-auth`                | Whether to exit the agent after authentication and first secret render. Default: `"false"`.                                                                                                         |
| `infisical.revoke-credentials-on-shutdown` | Whether to revoke all managed dynamic secret leases and identity access tokens on shutdown. Default: `"false"`.                                                                                     |
| `auth.type`                                | The type of authentication method used. Available options: `universal-auth`, `kubernetes`, `azure`, `gcp-id-token`, `gcp-iam`, `aws-iam`                                                            |
| `auth.config.identity-id`                  | The file path where the machine identity id is stored<br /><br />This field is required when using any of the following auth types: `kubernetes`, `azure`, `gcp-id-token`, `gcp-iam`, or `aws-iam`. |
| `auth.config.service-account-token`        | Path to the Kubernetes service account token to use (optional)<br /><br />Default: `/var/run/secrets/kubernetes.io/serviceaccount/token`                                                            |
| `auth.config.service-account-key`          | Path to your GCP service account key file. This field is required when using `gcp-iam` auth type.<br /><br />Please note that the file should be in JSON format.                                    |
| `auth.config.client-id`                    | The file path where the universal-auth client id is stored.                                                                                                                                         |
| `auth.config.client-secret`                | The file path where the universal-auth client secret is stored.                                                                                                                                     |
| `auth.config.remove_client_secret_on_read` | This will instruct the agent to remove the client secret from disk.                                                                                                                                 |
| `sinks[].type`                             | The type of sink in a list of sinks. Each item specifies a sink type. Currently, only `"file"` type is available.                                                                                   |
| `sinks[].config.path`                      | The file path where the access token should be stored for each sink in the list.                                                                                                                    |
| `templates[].source-path`                  | The path to the template file that should be used to render secrets.                                                                                                                                |
| `templates[].template-content`             | The inline secret template to be used for rendering the secrets.                                                                                                                                    |
| `templates[].destination-path`             | The path where the rendered secrets from the source template will be saved to.                                                                                                                      |
| `templates[].config.polling-interval`      | How frequently to check for secret changes. Default: `5 minutes` (optional)                                                                                                                         |
| `templates[].config.execute.command`       | The command to execute when secret change is detected (optional)                                                                                                                                    |
| `templates[].config.execute.timeout`       | How long in seconds to wait for command to execute before timing out (optional)                                                                                                                     |

## Authentication

The Infisical agent supports multiple authentication methods. Below are the available authentication methods, with their respective configurations.

<AccordionGroup>
  <Accordion title="Universal Auth">
    The Universal Auth method is a simple and secure way to authenticate with Infisical. It requires a client ID and a client secret to authenticate with Infisical.

    <ParamField query="config" type="UniversalAuthConfig">
      <Expandable title="properties">
        <ParamField query="client-id" type="string" required>
          Path to the file containing the universal auth client ID.
        </ParamField>

        <ParamField query="client-secret" type="string" required>
          Path to the file containing the universal auth client secret.
        </ParamField>

        <ParamField query="remove_client_secret_on_read" type="boolean" optional>
          Instructs the agent to remove the client secret from disk after reading
          it.
        </ParamField>
      </Expandable>
    </ParamField>

    <Steps>
      <Step title="Create a universal auth machine identity">
        To create a universal auth machine identity, follow the step by step guide outlined [here](/documentation/platform/identities/universal-auth).
      </Step>

      <Step title="Configure the agent">
        Update the agent configuration file with the specified auth method, client ID, and client secret. In the snippet below you can see a sample configuration of the `auth` field when using the Universal Auth method.

        ```yaml example-auth-config.yaml theme={"dark"}
        auth:
          type: "universal-auth"
          config:
            client-id: "./client-id" # Path to the file containing the client ID
            client-secret: "./client" # Path to the file containing the client secret
            remove_client_secret_on_read: false # Optional field, instructs the agent to remove the client secret from disk after reading it
        ```
      </Step>
    </Steps>
  </Accordion>

  <Accordion title="Native Kubernetes">
    The Native Kubernetes method is used to authenticate with Infisical when running in a Kubernetes environment. It requires a service account token to authenticate with Infisical.

    {" "}

    <ParamField query="config" type="KubernetesAuthConfig">
      <Expandable title="properties">
        <ParamField query="identity-id" type="string" required>
          Path to the file containing the machine identity ID.
        </ParamField>

        <ParamField query="service-account-token" type="string" optional>
          Path to the Kubernetes service account token to use. Default:
          `/var/run/secrets/kubernetes.io/serviceaccount/token`.
        </ParamField>
      </Expandable>
    </ParamField>

    <Steps>
      <Step title="Create a Kubernetes machine identity">
        To create a Kubernetes machine identity, follow the step by step guide outlined [here](/documentation/platform/identities/kubernetes-auth).
      </Step>

      <Step title="Configure the agent">
        Update the agent configuration file with the specified auth method, identity ID, and service account token. In the snippet below you can see a sample configuration of the `auth` field when using the Kubernetes method.

        ```yaml example-auth-config.yaml theme={"dark"}
        auth:
          type: "kubernetes"
          config:
            identity-id: "./identity-id" # Path to the file containing the machine identity ID
            service-account-token: "/var/run/secrets/kubernetes.io/serviceaccount/token" # Optional field, custom path to the Kubernetes service account token to use
        ```
      </Step>
    </Steps>
  </Accordion>

  <Accordion title="Native Azure">
    The Native Azure method is used to authenticate with Infisical when running in an Azure environment.

    <ParamField query="config" type="AzureAuthConfig">
      <Expandable title="properties">
        <ParamField query="identity-id" type="string" required>
          Path to the file containing the machine identity ID.
        </ParamField>
      </Expandable>
    </ParamField>

    <Steps>
      <Step title="Create an Azure machine identity">
        To create an Azure machine identity, follow the step by step guide outlined [here](/documentation/platform/identities/azure-auth).
      </Step>

      <Step title="Configure the agent">
        Update the agent configuration file with the specified auth method and identity ID. In the snippet below you can see a sample configuration of the `auth` field when using the Azure method.

        ```yaml example-auth-config.yaml theme={"dark"}
        auth:
          type: "azure"
          config:
            identity-id: "./identity-id" # Path to the file containing the machine identity ID
        ```
      </Step>
    </Steps>
  </Accordion>

  <Accordion title="Native GCP ID Token">
    The Native GCP ID Token method is used to authenticate with Infisical when running in a GCP environment.

    <ParamField query="config" type="GCPIDTokenAuthConfig">
      <Expandable title="properties">
        <ParamField query="identity-id" type="string" required>
          Path to the file containing the machine identity ID.
        </ParamField>
      </Expandable>
    </ParamField>

    <Steps>
      <Step title="Create a GCP machine identity">
        To create a GCP machine identity, follow the step by step guide outlined [here](/documentation/platform/identities/gcp-auth).
      </Step>

      <Step title="Configure the agent">
        Update the agent configuration file with the specified auth method and identity ID. In the snippet below you can see a sample configuration of the `auth` field when using the GCP ID Token method.

        ```yaml example-auth-config.yaml theme={"dark"}
        auth:
          type: "gcp-id-token"
          config:
            identity-id: "./identity-id" # Path to the file containing the machine identity ID
        ```
      </Step>
    </Steps>
  </Accordion>

  <Accordion title="GCP IAM">
    The GCP IAM method is used to authenticate with Infisical with a GCP service account key.

    <ParamField query="config" type="GCPIAMAuthConfig">
      <Expandable title="properties">
        <ParamField query="identity-id" type="string" required>
          Path to the file containing the machine identity ID.
        </ParamField>

        <ParamField query="service-account-key" type="string" required>
          Path to your GCP service account key file.
        </ParamField>
      </Expandable>
    </ParamField>

    <Steps>
      <Step title="Create a GCP machine identity">
        To create a GCP machine identity, follow the step by step guide outlined [here](/documentation/platform/identities/gcp-auth).
      </Step>

      <Step title="Configure the agent">
        Update the agent configuration file with the specified auth method, identity ID, and service account key. In the snippet below you can see a sample configuration of the `auth` field when using the GCP IAM method.

        ```yaml example-auth-config.yaml theme={"dark"}
        auth:
          type: "gcp-iam"
          config:
            identity-id: "./identity-id" # Path to the file containing the machine identity ID
            service-account-key: "./service-account-key.json" # Path to your GCP service account key file
        ```
      </Step>
    </Steps>
  </Accordion>

  <Accordion title="Native AWS IAM">
    The AWS IAM method is used to authenticate with Infisical with an AWS IAM role while running in an AWS environment like EC2, Lambda, etc.

    <ParamField query="config" type="AWSIAMAuthConfig">
      <Expandable title="properties">
        <ParamField query="identity-id" type="string" required>
          Path to the file containing the machine identity ID.
        </ParamField>
      </Expandable>
    </ParamField>

    <Steps>
      <Step title="Create an AWS machine identity">
        To create an AWS machine identity, follow the step by step guide outlined [here](/documentation/platform/identities/aws-auth).
      </Step>

      <Step title="Configure the agent">
        Update the agent configuration file with the specified auth method and identity ID. In the snippet below you can see a sample configuration of the `auth` field when using the AWS IAM method.

        ```yaml example-auth-config.yaml theme={"dark"}
        auth:
          type: "aws-iam"
          config:
            identity-id: "./identity-id" # Path to the file containing the machine identity ID
        ```
      </Step>
    </Steps>
  </Accordion>
</AccordionGroup>

## Quick start Infisical Agent

To install the Infisical agent, you must first install the [Infisical CLI](/cli/overview) in the desired environment where you'd like the agent to run. This is because the Infisical agent is a sub-command of the Infisical CLI.

Once you have the CLI installed, you will need to provision programmatic access for the agent via [Universal Auth](/documentation/platform/identities/universal-auth). To obtain a **Client ID** and a **Client Secret**, follow the step by step guide outlined [here](/documentation/platform/identities/universal-auth).

Next, create agent config file as shown below. The example agent configuration file defines the token authentication method, one sink location, and a secret template.

```yaml example-agent-config-file.yaml theme={"dark"}
infisical:
  address: "https://app.infisical.com"
auth:
  type: "universal-auth"
  config:
    client-id: "./client-id"
    client-secret: "./client-secret"
    remove_client_secret_on_read: false
sinks:
  - type: "file"
    config:
      path: "/some/path/to/store/access-token/file-name"
templates:
  - source-path: my-dot-ev-secret-template
    destination-path: /some/path/.env
    config:
      polling-interval: 60s
      execute:
        timeout: 30
        command: ./reload-app.sh
```

The secret template below will be used to render the secrets with the key and the value separated by `=` sign. You'll notice that a custom function named `secret` is used to fetch the secrets.
This function takes the following arguments: `secret "<project-id>" "<environment-slug>" "<secret-path>"`.

```text my-dot-ev-secret-template theme={"dark"}
{{- with secret "6553ccb2b7da580d7f6e7260" "dev" "/" }}
{{- range . }}
{{ .Key }}={{ .Value }}
{{- end }}
{{- end }}
```

After defining the agent configuration file, run the command below pointing to the path where the agent configuration file is located.

```bash  theme={"dark"}
infisical agent --config example-agent-config-file.yaml
```

### Available secret template functions

<Accordion title="listSecrets">
  ```bash  theme={"dark"}
    listSecrets "<project-id>" "environment-slug" "<secret-path>" "<optional-modifier>"
  ```

  ```bash example-template-usage-1 theme={"dark"}
  {{- with listSecrets "6553ccb2b7da580d7f6e7260" "dev" "/" `{"recursive": false, "expandSecretReferences": true}` }}
  {{- range . }}
  {{ .Key }}={{ .Value }}
  {{- end }}
  {{- end }}
  ```

  ```bash example-template-usage-2 theme={"dark"}
  {{- with secret "da8056c8-01e2-4d24-b39f-cb4e004b8d44" "staging" "/" `{"recursive": true, "expandSecretReferences": true}` }}
  {{- range . }}
  {{- if eq .SecretPath "/"}}
  {{ .Key }}={{ .Value }}
  {{- else}}
  {{ .SecretPath }}/{{ .Key }}={{ .Value }}
  {{- end}}
  {{- end }}
  {{- end }}
  ```

  **Function name**: listSecrets

  **Description**: This function can be used to render the full list of secrets within a given project, environment and secret path.

  An optional JSON argument is also available. It includes the properties `recursive`, which defaults to false, and `expandSecretReferences`, which defaults to true and expands the returned secrets.

  **Returns**: A single secret object with the following keys `Key, WorkspaceId, Value, SecretPath, Type, ID, and Comment`
</Accordion>

<Accordion title="getSecretByName">
  ```bash  theme={"dark"}
  getSecretByName "<project-id>" "<environment-slug>" "<secret-path>" "<secret-name>"
  ```

  ```bash example-template-usage theme={"dark"}
  {{ with getSecretByName "d821f21d-aa90-453b-8448-8c78c1160a0e" "dev" "/" "POSTHOG_HOST"}}
  {{ if .Value }}
  password = "{{ .Value }}"
  {{ end }}
  {{ end }}
  ```

  **Function name**: getSecretByName

  **Description**: This function can be used to render a single secret by it's name.

  **Returns**: A list of secret objects with the following keys `Key, WorkspaceId, Value, Type, ID, and Comment`
</Accordion>

<Accordion title="dynamic_secret">
  ```bash  theme={"dark"}
  dynamic_secret "<project-slug>" "<environment-slug>" "<secret-path>" "<dynamic-secret-name>" "<lease-ttl>"
  ```

  ```bash example-redis-dynamic-secret theme={"dark"}
    {{ with dynamic_secret "aaa-o7en-s5qm" "dev" "/" "redis" "1m" }}
    {{ .DB_USERNAME }}={{ .DB_PASSWORD }}
    {{- end }}

    **Function Name**: dynamic_secret

    **Description**: This function can be used to render a dynamic secret lease credentials. The credentials are automatically renewed before they expire, ensuring that the rendered credentials are always up-to-date.

    **Returns**: An object with keys corresponding to the dynamic secret lease credentials.
  ```
</Accordion>


# Kubernetes CSI
Source: https://infisical.com/docs/integrations/platforms/kubernetes-csi

How to use the Infisical Kubernetes CSI provider to inject secrets directly into Kubernetes pods.

## Overview

The Infisical CSI provider allows you to use Infisical with the [Secrets Store CSI driver](https://secrets-store-csi-driver.sigs.k8s.io) to inject secrets directly into your Kubernetes pods through a volume mount.
In contrast to the [Infisical Kubernetes Operator](https://infisical.com/docs/integrations/platforms/kubernetes), the Infisical CSI provider will allow you to sync Infisical secrets directly to pods as files, removing the need for Kubernetes secret resources.

```mermaid  theme={"dark"}
flowchart LR
    subgraph Secrets Management
        SS(Infisical) --> CSP(Infisical CSI Provider)
        CSP --> CSD(Secrets Store CSI Driver)
    end

    subgraph Pod
        CSD --> V(Volume)
        V <--> P(Application)
    end

```

## Features

The following features are supported by the Infisical CSI Provider:

* Integration with Secrets Store CSI Driver for direct pod mounting
* Authentication using Kubernetes service accounts via machine identities
* Auto-syncing secrets when enabled via CSI Driver
* Configurable secret paths and file mounting locations
* Installation via Helm

## Prerequisites

The Infisical CSI provider is only supported for Kubernetes clusters with version >= 1.20.

## Limitations

Currently, the Infisical CSI provider only supports static secrets.

## Deploy to Kubernetes cluster

### Install Secrets Store CSI Driver

In order to use the Infisical CSI provider, you will first have to install the [Secrets Store CSI driver](https://secrets-store-csi-driver.sigs.k8s.io/getting-started/installation) to your cluster.

#### Standard Installation

For most Kubernetes clusters, use the following installation:

```bash  theme={"dark"}
helm repo add secrets-store-csi-driver https://kubernetes-sigs.github.io/secrets-store-csi-driver/charts
```

```bash  theme={"dark"}
helm install csi secrets-store-csi-driver/secrets-store-csi-driver \
--namespace=kube-system \
--set "tokenRequests[0].audience=infisical" \
--set enableSecretRotation=true \
--set rotationPollInterval=2m \
--set "syncSecret.enabled=true" \
```

The flags configure the following:

* `tokenRequests[0].audience=infisical`: Sets the audience value for service account token authentication (recommended for environments that support custom audiences)
* `enableSecretRotation=true`: Enables automatic secret updates from Infisical
* `rotationPollInterval=2m`: Checks for secret updates every 2 minutes
* `syncSecret.enabled=true`: Enables syncing secrets to Kubernetes secrets

<Info>
  If you do not wish to use the auto-syncing feature of the secrets store CSI
  driver, you can omit the `enableSecretRotation` and the `rotationPollInterval`
  flags. Do note that by default, secrets from Infisical are only fetched and
  mounted during pod creation. If there are any changes made to the secrets in
  Infisical, they will not propagate to the pods unless auto-syncing is enabled
  for the CSI driver.
</Info>

#### Installation for Environments Without Custom Audience Support

Some Kubernetes environments (such as AWS EKS) don't support custom audiences and will reject tokens with non-default audiences. For these environments, use this installation instead:

```bash  theme={"dark"}
helm install csi secrets-store-csi-driver/secrets-store-csi-driver \
--namespace=kube-system \
--set enableSecretRotation=true \
--set rotationPollInterval=2m \
--set "syncSecret.enabled=true" \
```

<Warning>
  **Environments without custom audience support**: Do not set a custom audience
  when installing the CSI driver in environments that reject custom audiences.
  Instead, use the installation above and set `useDefaultAudience: "true"` in
  your SecretProviderClass configuration.
</Warning>

### Install Infisical CSI Provider

You would then have to install the Infisical CSI provider to your cluster.

**Install the latest Infisical Helm repository**

```bash  theme={"dark"}
helm repo add infisical-helm-charts 'https://dl.cloudsmith.io/public/infisical/helm-charts/helm/charts/'

helm repo update
```

**Install the Helm Chart**

```bash  theme={"dark"}
helm install infisical-csi-provider infisical-helm-charts/infisical-csi-provider
```

For a list of all supported arguments for the helm installation, you can run the following:

```bash  theme={"dark"}
helm show values infisical-helm-charts/infisical-csi-provider
```

### Authentication

In order for the Infisical CSI provider to pull secrets from your Infisical project, you will have to configure
a machine identity with [Kubernetes authentication](https://infisical.com/docs/documentation/platform/identities/kubernetes-auth) configured with your cluster.
You can refer to the documentation for setting it up [here](https://infisical.com/docs/documentation/platform/identities/kubernetes-auth#guide).

<Warning>
  **Important**: The "Allowed Audience" field in your machine identity's
  Kubernetes authentication settings must match your CSI driver installation. If
  you used the standard installation with `tokenRequests[0].audience=infisical`,
  set the "Allowed Audience" field to `infisical`. If you used the installation
  for environments without custom audience support, leave the "Allowed Audience"
  field empty.
</Warning>

### Creating Secret Provider Class

With the Secrets Store CSI driver and the Infisical CSI provider installed, create a Kubernetes [SecretProviderClass](https://secrets-store-csi-driver.sigs.k8s.io/concepts.html#secretproviderclass) resource to establish
the connection between the CSI driver and the Infisical CSI provider for secret retrieval. You can create as many Secret Provider Classes as needed for your cluster.

#### Standard Configuration

```yaml  theme={"dark"}
apiVersion: secrets-store.csi.x-k8s.io/v1
kind: SecretProviderClass
metadata:
  name: my-infisical-app-csi-provider
spec:
  provider: infisical
  parameters:
    infisicalUrl: "https://app.infisical.com"
    authMethod: "kubernetes"
    identityId: "ad2f8c67-cbe2-417a-b5eb-1339776ec0b3"
    projectId: "09eda1f8-85a3-47a9-8a6f-e27f133b2a36"
    envSlug: "prod"
    secrets: |
      - secretPath: "/"
        fileName: "dbPassword"
        secretKey: "DB_PASSWORD"
      - secretPath: "/app"
        fileName: "appSecret"
        secretKey: "APP_SECRET"
```

#### Configuration for Environments Without Custom Audience Support

For environments that don't support custom audiences (such as AWS EKS), use this configuration instead:

```yaml  theme={"dark"}
apiVersion: secrets-store.csi.x-k8s.io/v1
kind: SecretProviderClass
metadata:
  name: my-infisical-app-csi-provider
spec:
  provider: infisical
  parameters:
    infisicalUrl: "https://app.infisical.com"
    authMethod: "kubernetes"
    useDefaultAudience: "true"
    identityId: "ad2f8c67-cbe2-417a-b5eb-1339776ec0b3"
    projectId: "09eda1f8-85a3-47a9-8a6f-e27f133b2a36"
    envSlug: "prod"
    secrets: |
      - secretPath: "/"
        fileName: "dbPassword"
        secretKey: "DB_PASSWORD"
      - secretPath: "/app"
        fileName: "appSecret"
        secretKey: "APP_SECRET"
```

<Note>
  **Key difference**: The only change from the standard configuration is the
  addition of `useDefaultAudience: "true"`. This parameter tells the CSI
  provider to use the default Kubernetes audience instead of a custom
  "infisical" audience, which is required for environments that reject custom
  audiences.
</Note>

<Note>
  The SecretProviderClass should be provisioned in the same namespace as the pod
  you intend to mount secrets to.
</Note>

#### Supported Parameters

<Accordion title="infisicalUrl">
  The base URL of your Infisical instance. If you're using Infisical Cloud US,
  this should be set to `https://app.infisical.com`. If you're using Infisical
  Cloud EU, then this should be set to `https://eu.infisical.com`.
</Accordion>

<Accordion title="caCertificate">
  The CA certificate of the Infisical instance in order to establish SSL/TLS
  when the instance uses a private or self-signed certificate. Unless necessary,
  this should be omitted.
</Accordion>

<Accordion title="authMethod">
  The auth method to use for authenticating the Infisical CSI provider with
  Infisical. For now, the only supported method is `kubernetes`.
</Accordion>

<Accordion title="identityId">
  The ID of the machine identity to use for authenticating the Infisical CSI
  provider with your Infisical organization. This should be the machine identity
  configured with Kubernetes authentication.
</Accordion>

<Accordion title="projectId">
  The project ID of the Infisical project to pull secrets from.
</Accordion>

<Accordion title="envSlug">
  The slug of the project environment to pull secrets from.
</Accordion>

<Accordion title="secrets">
  An array that defines which secrets to retrieve and how to mount them. Each
  entry requires three properties: `secretPath` and `secretKey` work together to
  identify the source secret to fetch, while `fileName` specifies the path where
  the secret's value will be mounted within the pod's filesystem.
</Accordion>

<Accordion title="audience">
  The custom audience value configured for the CSI driver. This defaults to
  `infisical`.
</Accordion>

<Accordion title="useDefaultAudience">
  When set to `"true"`, the Infisical CSI provider will use the default
  Kubernetes audience instead of a custom audience. This is required for
  environments that don't support custom audiences (such as AWS EKS), which
  reject tokens with non-default audiences. When using this option, do not set a
  custom audience in the CSI driver installation. This defaults to `false`.

  <Note>
    When enabled, the CSI provider will dynamically create service account
    tokens on-demand using the default Kubernetes audience, rather than using
    pre-existing tokens from the CSI driver.
  </Note>
</Accordion>

### Using Secret Provider Class

A pod can use the Secret Provider Class by mounting it as a CSI volume:

```yaml  theme={"dark"}
apiVersion: v1
kind: Pod
metadata:
  name: nginx-secrets-store
  labels:
    app: nginx
spec:
  containers:
    - name: nginx
      image: nginx
      volumeMounts:
        - name: secrets-store-inline
          mountPath: "/mnt/secrets-store"
          readOnly: true
  volumes:
    - name: secrets-store-inline
      csi:
        driver: secrets-store.csi.k8s.io
        readOnly: true
        volumeAttributes:
          secretProviderClass: "my-infisical-app-csi-provider"
```

When the pod is created, the secrets are mounted as individual files in the /mnt/secrets-store directory.

### Verifying Secret Mounts

To verify your secrets are mounted correctly:

```bash  theme={"dark"}
# Check pod status
kubectl get pod nginx-secrets-store

# View mounted secrets
kubectl exec -it nginx-secrets-store -- ls -l /mnt/secrets-store
```

### Troubleshooting

To troubleshoot issues with the Infisical CSI provider, refer to the logs of the Infisical CSI provider running on the same node as your pod.

```bash  theme={"dark"}
kubectl logs infisical-csi-provider-7x44t
```

You can also refer to the logs of the secrets store CSI driver. Modify the command below with the appropriate pod and namespace of your secrets store CSI driver installation.

```bash  theme={"dark"}
kubectl logs csi-secrets-store-csi-driver-7h4jp -n=kube-system
```

**Common issues include:**

* Mismatch in the audience value of the CSI driver with the machine identity's Kubernetes auth configuration
* SecretProviderClass in the wrong namespace
* Invalid machine identity configuration
* Incorrect secret paths or keys

**Issues in environments without custom audience support:**

* **Token authentication failed with custom audience**: If you're seeing authentication errors in environments that don't support custom audiences (such as AWS EKS), ensure you're using the installation without custom audience and have set `useDefaultAudience: "true"` in your SecretProviderClass
* **Audience not allowed errors**: Make sure the "Allowed Audience" field is left empty in your machine identity's Kubernetes authentication configuration when using environments that don't support custom audiences

## Best Practices

For additional guidance on setting this up for your production cluster, you can refer to the Secrets Store CSI driver documentation [here](https://secrets-store-csi-driver.sigs.k8s.io/topics/best-practices).

## Frequently Asked Questions

<AccordionGroup>
  <Accordion title="Is it possible to sync Infisical secrets as environment variables?">
    Yes, but it requires an indirect approach:

    1. First enable syncing to Kubernetes secrets by setting `syncSecret.enabled=true` in the CSI driver installation
    2. Configure the Secret Provider Class to sync specific secrets to Kubernetes secrets
    3. Use the resulting Kubernetes secrets in your pod's environment variables

    This means secrets are first synced to Kubernetes secrets before they can be used as environment variables. You can find detailed examples in the [Secrets Store CSI driver documentation](https://secrets-store-csi-driver.sigs.k8s.io/topics/set-as-env-var).
  </Accordion>
</AccordionGroup>

<AccordionGroup>
  <Accordion title="Do I have to list out every Infisical single secret that I want to sync?">
    Yes, you will need to explicitly list each secret you want to sync in the
    Secret Provider Class configuration. This is a common requirement across all
    CSI providers as the Secrets Store CSI Driver architecture requires specific
    mapping of secrets to their mounted file locations.
  </Accordion>
</AccordionGroup>


# Kubernetes Agent Injector
Source: https://infisical.com/docs/integrations/platforms/kubernetes-injector

How to use the Infisical Kubernetes Agent Injector to inject secrets directly into Kubernetes pods.

## Overview

The Infisical Kubernetes Agent Injector allows you to inject secrets directly into your Kubernetes pods. The Injector will create a [Infisical Agent](/integrations/platforms/infisical-agent) container within your pod that syncs secrets from Infisical into a shared volume mount within your pod.

The Infisical Agent Injector will patch and modify your pod's deployment to contain an [Infisical Agent](/integrations/platforms/infisical-agent) container which renders your Infisical secrets into a shared volume mount within your pod.

The Infisical Agent Injector is built on [Kubernetes Mutating Admission Webhooks](https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers), and will watch for `CREATE` and `UPDATE` events on pods in your cluster.
The injector is namespace-agnostic, and will watch for pods in any namespace, but will only patch pods that have the `org.infisical.com/inject` annotation set to `true`.

```mermaid  theme={"dark"}
flowchart LR
    subgraph Secrets Management
        SS(Infisical) --> INJ(Infisical Injector)
    end

    subgraph Pod
        INJ --> INIT(Agent Init Container)
        INIT --> V(Volume)
        V <--> P(Application)
    end
    
```

## Install the Infisical Agent Injector

To install the Infisical Agent Injector, you will need to install our helm charts using [Helm](https://helm.sh/).

```bash  theme={"dark"}
helm repo add infisical-helm-charts 'https://dl.cloudsmith.io/public/infisical/helm-charts/helm/charts/'
helm repo update
helm install --generate-name infisical-helm-charts/infisical-agent-injector
```

After installing the helm chart you can verify that the injector is running and working as intended by checking the logs of the injector pod.

```bash  theme={"dark"}
$ kubectl logs deployment/infisical-agent-injector 
2025/05/19 14:20:05 Starting infisical-agent-injector...
2025/05/19 14:20:05 Generating self-signed certificate...
2025/05/19 14:20:06 Creating directory: /tmp/tls
2025/05/19 14:20:06 Writing cert to: /tmp/tls/tls.crt
2025/05/19 14:20:06 Writing key to: /tmp/tls/tls.key
2025/05/19 14:20:06 Starting HTTPS server on port 8585...
2025/05/19 14:20:06 Attempting to update webhook config (attempt 1)...
2025/05/19 14:20:06 Successfully updated webhook configuration with CA bundle
```

## Windows support

By default the agent injector is built for Linux-based pods, but supports injecting into Windows-based pods.

**To inject into Windows-based pods, no extra configuration is needed.** The agent injector will automatically detect and handle injections into Windows-based pods.

However, if you are trying to run the agent injector itself on a Windows-based pod, you'll need to configure your helm values.yaml file to point to a Windows-based image.

The Agent Injector will only run on and inject into Windows-based pods that are running on the supported Windows versions:

* **Windows Server 2022**
* **Windows Server 2019**

We're looking to add support for other Windows versions in the future. If you're using a different Windows version, please let us know by opening [an issue](https://github.com/Infisical/infisical-agent-injector/issues/new), and we'll look into adding support for your desired version as soon as possible.

You will need to set the `nodeSelector.kubernetes.io/os` label to `windows` and set the image tag to a Windows-based image. Below are two examples for Windows Server 2019 and Windows Server 2022.

<AccordionGroup>
  <Accordion title="Run Agent Injector on Windows Server 2019">
    Create your `values.yaml` file and add the following:

    ```yaml values.yaml theme={"dark"}
    image:
      repository: infisical/infisical-agent-injector
      tag: "v0.1.4-windows-server-2019"

    nodeSelector:
      kubernetes.io/os: windows
    ```

    Install the agent injector using the values.yaml file you created above.

    ```bash  theme={"dark"}
    helm install --generate-name infisical-helm-charts/infisical-agent-injector -f values.yaml
    ```
  </Accordion>

  <Accordion title="Run Agent Injector on Windows Server 2022">
    Create your `values.yaml` file and add the following:

    ```yaml values.yaml theme={"dark"}
    image:
      repository: infisical/infisical-agent-injector
      tag: "v0.1.4-windows-server-2022"

    nodeSelector:
      kubernetes.io/os: windows
    ```

    Install the agent injector using the values.yaml file you created above.

    ```bash  theme={"dark"}
    helm install --generate-name infisical-helm-charts/infisical-agent-injector -f values.yaml
    ```
  </Accordion>
</AccordionGroup>

<Tip>
  Note that Windows support is only supported in version `v0.1.4` and above. If you are using an older version, you will need to upgrade to `v0.1.4` or above to use Windows support.
</Tip>

## Supported annotations

The Infisical Agent Injector supports the following annotations:

<Accordion title="org.infisical.com/inject">
  The inject annotation is used to enable the injector on a pod. Set the value to `true` and the pod will be patched with an Infisical Agent container on update or create.
</Accordion>

<Accordion title="org.infisical.com/inject-mode">
  The inject mode annotation is used to specify the mode to use to inject the secrets into the pod.

  * `init`: The init method will create an init container for the pod that will render the secrets into a shared volume mount within the pod. The agent init container will run before any other containers in the pod runs, including other init containers.
  * `sidecar`: The sidecar method will create a sidecar container for the pod that will render the secrets into a shared volume mount within the pod. The agent sidecar container will run alongside the main container in the pod. This means that the secrets rendered will always be in sync with your Infisical secrets.
  * `sidecar-init`: The sidecar-init method will create the init container and the sidecar container from the other two methods. The init container will run before any other container and fetch the secrets from the start and the sidecar container will keep the secrets in sync throughout the lifecycle of the deployment.
</Accordion>

<Accordion title="org.infisical.com/agent-config-map">
  The agent config map annotation is used to specify the name of the config map that contains the configuration for the injector. The config map must be in the same namespace as the pod.
</Accordion>

## ConfigMap Configuration

### Supported Fields

When you are configuring a pod to use the injector, you must create a config map in the same namespace as the pod you want to inject secrets into.
The entire config needs to be of string format and needs to be assigned to the `config.yaml` key in the config map. You can find a full example of the config at the end of this section.

<Accordion title="infisical.address">
  The address of your Infisical instance. This field is optional and will default to `https://app.infisical.com` if not provided.
</Accordion>

<Accordion title="infisical.revoke-credentials-on-shutdown">
  Whether to revoke all managed dynamic secret leases and identity access tokens on shutdown. Default: `"false"`.

  If this is set to `true`, all managed dynamic secret leases and identity access tokens will be revoked when a `SIGTERM` signal is sent to the agents container *(such as when a pod is terminated or when the pod is restarted)*.
  **Note:** In disaster events such as cluster power outages, a `SIGTERM` signal won't be sent to the agents container, and the credentials will not be revoked.

  <Note>
    Note that this is currently unsupported on Windows-based pods, and will only work when injecting into Linux-based pods.
  </Note>
</Accordion>

<Accordion title="infisical.auth.type">
  The authentication type to use to connect to Infisical. Currently only the `kubernetes` authentication type is supported.
  You can refer to our [Kubernetes Auth](/documentation/platform/identities/kubernetes-auth) documentation for more information on how to create a machine identity for Kubernetes Auth.
  Please note that the pod's default service account will be used to authenticate with Infisical.
</Accordion>

<Accordion title="infisical.auth.config.identity-id">
  The ID of the machine identity to use to connect to Infisical. This field is required if the `infisical.auth.type` is set to `kubernetes`.
</Accordion>

<Accordion title="templates[]">
  The templates hold an array of templates that will be rendered and injected into the pod.
</Accordion>

<Accordion title="templates[].destination-path">
  The path to inject the secrets into within the pod.
  If not specified, this will default to `/shared/infisical-secrets`. If you have multiple templates and don't provide a destination path, the destination paths will default to `/shared/infisical-secrets-1`, `/shared/infisical-secrets-2`, etc.
</Accordion>

<Accordion title="templates[].template-content">
  The content of the template to render.
  This will be rendered as a [Go Template](https://pkg.go.dev/text/template) and will have access to the following variables.
  It follows the templating format and supports the same functions as the [Infisical Agent](/integrations/platforms/infisical-agent#quick-start-infisical-agent)
</Accordion>

### Authentication

The Infisical Agent Injector supports Machine Identity [Kubernetes Auth](/documentation/platform/identities/kubernetes-auth) and [LDAP Auth](/documentation/platform/identities/ldap-auth) authentication.

<AccordionGroup>
  <Accordion title="Kubernetes Auth">
    To configure Kubernetes Auth, you need to set the `auth.type` field to `kubernetes` and set the `auth.config.identity-id` to the ID of the machine identity you wish to use for authentication.

    ```yaml  theme={"dark"}
    auth:
      type: "kubernetes"
      config:
        identity-id: "<your-infisical-machine-identity-id>"
    ```

    ### Example ConfigMap

    ```yaml config-map.yaml theme={"dark"}
    apiVersion: v1
    kind: ConfigMap
    metadata:
      name: demo-config-map
    data:
      config.yaml: |
        infisical:
          address: "https://app.infisical.com"
          auth:
            type: "kubernetes"
            config:
              identity-id: "<your-infisical-machine-identity-id>"
        templates:
          - destination-path: "/path/to/save/secrets/file.txt"
            template-content: |
              {{- with secret "<your-project-id>" "dev" "/" }}
              {{- range . }}
              {{ .Key }}={{ .Value }}
              {{- end }}
              {{- end }}
    ```

    ```bash  theme={"dark"}
    kubectl apply -f config-map.yaml
    ```
  </Accordion>

  <Accordion title="LDAP Auth">
    To configure LDAP Auth, you need to set the `auth.type` field to `ldap-auth` and set the `auth.config.identity-id` to the ID of the machine identity you wish to use for authentication. Configure the `auth.config.username` and `auth.config.password` to the username and password of the LDAP user to authenticate with.

    ```yaml  theme={"dark"}
    auth:
      type: "ldap-auth"
      config:
        identity-id: "<your-infisical-machine-identity-id>"
        username: "<your-ldap-username>"
        password: "<your-ldap-password>"
    ```

    ### Example ConfigMap

    ```yaml config-map.yaml theme={"dark"}
    apiVersion: v1
    kind: ConfigMap
    metadata:
      name: demo-config-map
    data:
      config.yaml: |
        infisical:
          address: "https://app.infisical.com"
          auth:
            type: "ldap-auth"
            config:
              identity-id: "<your-infisical-machine-identity-id>"
              username: "<your-ldap-username>"
              password: "<your-ldap-password>"
        templates:
          - destination-path: "/path/to/save/secrets/file.txt"
            template-content: |
              {{- with secret "<your-project-id>" "dev" "/" }}
              {{- range . }}
              {{ .Key }}={{ .Value }}
              {{- end }}
              {{- end }}
    ```

    ```bash  theme={"dark"}
    kubectl apply -f config-map.yaml
    ```
  </Accordion>
</AccordionGroup>

To use the config map in your pod, you will need to add the `org.infisical.com/agent-config-map` annotation to your pod's deployment. The value of the annotation is the name of the config map you created above.

```yaml  theme={"dark"}
apiVersion: v1
kind: Pod
metadata:
  name: demo
  labels:
    app: demo
  annotations:
    org.infisical.com/inject: "true" # Set to true for the injector to patch the pod on create/update events
    org.infisical.com/inject-mode: "init" # The mode to use to inject the secrets into the pod. init|sidecar
    org.infisical.com/agent-config-map: "name-of-config-map" # The name of the config map that you created above, which contains all the settings for injecting the secrets into the pod
spec:
  # ...
```

## Quick Start

In this section we'll walk through a full example of how to inject secrets into a pod using the Infisical Agent Injector.
In this example we'll create a basic nginx deployment and print a Infisical secret called `API_KEY` to the container logs.

### Create secrets in Infisical

First you'll need to create the secret in Infisical.

* `API_KEY`: The API key to use for the nginx deployment.

Once you've created the secret, save your project ID, environment slug, and secret path, as these will be used in the next step.

### Configuration

To use the injector you must create a config map in the same namespace as the pod you want to inject secrets into. In this example we'll create a config map in the `test-namespace` namespace.

The agent injector will authenticate with Infisical using a [Kubernetes Auth](/documentation/platform/identities/kubernetes-auth) machine identity. Please follow the [instructions](/documentation/platform/identities/kubernetes-auth) to create a machine identity configured for Kubernetes Auth.
The agent injector will use the service account token of the pod to authenticate with Infisical.

The `template-content` will be rendered as a [Go Template](https://pkg.go.dev/text/template) and will have access to the following variables. It follows the templating format and supports the same functions as the [Infisical Agent](/integrations/platforms/infisical-agent#quick-start-infisical-agent)
The `destination-path` refers to the path within the pod that the secrets will be injected into. In this case we're injecting the secrets into a file called `/infisical/secrets`.

Replace the `<your-project-id>`, `<your-environment-slug>`, with your project ID and the environment slug of where you created your secrets in Infisical. Replace `<your-infisical-machine-identity-id>` with the ID of your machine identity configured for Kubernetes Auth.

```yaml config-map.yaml theme={"dark"}
apiVersion: v1
kind: ConfigMap
metadata:
  name: nginx-infisical-config-map
  namespace: test-namespace
data:
  config.yaml: |
    infisical:
      address: "https://app.infisical.com"
      auth:
        type: "kubernetes"
        config:
          identity-id: "<your-infisical-machine-identity-id>"
    templates:
      - destination-path: "/infisical/secrets"
        template-content: |
          {{- with secret "<your-project-id>" "<your-environment-slug>" "/" }}
          {{- range . }}
          {{ .Key }}={{ .Value }}
          {{- end }}
          {{- end }}
```

Now apply the config map:

```bash  theme={"dark"}
kubectl apply -f config-map.yaml
```

### Injecting secrets into your pod

To inject secrets into your pod, you will need to add the `org.infisical.com/inject: "true"` annotation to your pod's deployment.

The `org.infisical.com/agent-config-map` annotation will point to the config map we created in the previous step. It's important that the config map is in the same namespace as the pod.

We are creating a nginx deployment with a PVC to store the database data.

```yaml nginx.yaml theme={"dark"}
---
apiVersion: v1
kind: Pod
metadata:
  name: nginx-pod
  namespace: test-namespace
  labels:
    app: nginx
  annotations:
    org.infisical.com/inject: "true"
    org.infisical.com/inject-mode: "init"
    org.infisical.com/agent-config-map: "nginx-infisical-config-map"
spec:
  containers:
    - name: simple-app-demo
      image: nginx:alpine
      command: ["/bin/sh", "-c"]
      args:
        - |
          export $(cat /infisical/secrets | xargs)
          echo "API_KEY is set to: $API_KEY"
          nginx -g "daemon off;"
```

### Applying the deployment

To apply the deployment, you can use the following command:

```bash  theme={"dark"}
kubectl apply -f nginx.yaml
```

It may take a few minutes for the pod to be ready and for the Infisical secrets to be injected. You can check the status of the pod by running:

```bash  theme={"dark"}
kubectl get pods -n test-namespace
```

### Verifying the secrets are injected

To verify the secrets are injected, you can check the pod's logs:

```bash  theme={"dark"}
$ kubectl exec -it pod/nginx-pod -n test-namespace -- cat /infisical/secrets

Defaulted container "simple-app-demo" out of: simple-app-demo, infisical-agent-init (init)

API_KEY=sk_api_... # The secret you created in Infisical
```

Additionally you can now check that the `API_KEY` secret is being logged to the nginx container logs:

```bash  theme={"dark"}
$ kubectl logs pod/nginx-pod -n test-namespace                              
Defaulted container "simple-app-demo" out of: simple-app-demo, infisical-agent-init (init)
API_KEY is set to: sk_api_... # The secret you created in Infisical
```

## Troubleshooting

<Accordion title="The pod is stuck in `Init` state">
  If the pod is stuck in `Init` state, it means the Agent init container is failing to start or is stuck in a restart loop.
  This could be due to a number of reasons, such as the machine identity not having the correct permissions, or trying to fetch secrets from a non-existent project/environment.

  You can check the logs of the infisical init container by running:

  ```bash  theme={"dark"}
  # For deployments
  kubectl logs deployment/your-deployment-name -c infisical-agent-init -n "<namespace>"

  # For pods
  kubectl logs pod/your-pod-name -c infisical-agent-init -n "<namespace>"
  ```

  You can also check the logs of the pod by running:

  ```bash  theme={"dark"}
  kubectl logs deployment/postgres-deployment -n test-namespace
  ```

  When checking the logs of the agent init container, you may see something like the following:

  ```bash  theme={"dark"}
  Starting infisical agent...
  11:10AM INF starting Infisical agent...
  11:10AM INF Infisical instance address set to https://daniel1.tunn.dev
  11:10AM INF template engine started for template 1...
  11:10AM INF attempting to authenticate...
  11:10AM INF new access token saved to file at path '/home/infisical/config/identity-access-token'
  11:10AM ERR unable to process template because template: literalTemplate:1:9: executing "literalTemplate" at <secret "3c0d3ff6-165c-4dc9-b52c-ff3ffaedfce311111" "dev" "/">: error calling secret: CallGetRawSecretsV3: Unsuccessful response [GET https://daniel1.tunn.dev/api/v3/secrets/raw?environment=dev&expandSecretReferences=true&include_imports=true&secretPath=%2F&workspaceId=3c0d3ff6-165c-4dc9-b52c-ff3ffaedfce311111] [status-code=404] [response={"reqId":"req-ljqNq567jchFrK","statusCode":404,"message":"Project with ID '3c0d3ff6-165c-4dc9-b52c-ff3ffaedfce311111' not found during bot lookup. Are you sure you are using the correct project ID?","error":"NotFound"}]
  + echo 'Agent failed with exit code 1'
  + exit 1
  Agent failed with exit code 1
  ```

  In the above error, the project ID was invalid in the config map.
</Accordion>


# Using the InfisicalDynamicSecret CRD
Source: https://infisical.com/docs/integrations/platforms/kubernetes/infisical-dynamic-secret-crd

Learn how to generate dynamic secret leases in Infisical and sync them to your Kubernetes cluster.

## Overview

The **InfisicalDynamicSecret** CRD allows you to easily create and manage dynamic secret leases in Infisical and automatically sync them to your Kubernetes cluster as native **Kubernetes Secret** resources.
This means any Pod, Deployment, or other Kubernetes resource can make use of dynamic secrets from Infisical just like any other K8s secret.

This CRD offers the following features:

* **Generate a dynamic secret lease** in Infisical and track its lifecycle.
* **Write** the dynamic secret from Infisical to your cluster as native Kubernetes secret.
* **Automatically rotate** the dynamic secret value before it expires to make sure your cluster always has valid credentials.
* **Optionally trigger redeployments** of any workloads that consume the secret if you enable auto-reload.

### Prerequisites

* A project within Infisical.
* A [machine identity](/documentation/platform/identities/machine-identities) ready for use in Infisical that has permissions to create dynamic secret leases in the project.
* You have already configured a dynamic secret in Infisical.
* The operator is installed on to your Kubernetes cluster.

## Configure Dynamic Secret CRD

The example below shows a sample **InfisicalDynamicSecret** CRD that creates a dynamic secret lease in Infisical, and syncs the lease to your Kubernetes cluster.

```yaml dynamic-secret-crd.yaml theme={"dark"}
apiVersion: secrets.infisical.com/v1alpha1
kind: InfisicalDynamicSecret
metadata:
  name: infisicaldynamicsecret
spec:
  hostAPI: https://app.infisical.com/api # Optional, defaults to https://app.infisical.com/api

  dynamicSecret:
    secretName: <dynamic-secret-name>
    projectId: <project-id>
    secretsPath: <path/to/dynamic-secret> # Root directory is /
    environmentSlug: <env-slug>

  # Lease revocation policy defines what should happen to leases created by the operator if the CRD is deleted.
  # If set to "Revoke", leases will be revoked when the InfisicalDynamicSecret CRD is deleted.
  leaseRevocationPolicy: Revoke

  # Lease TTL defines how long the lease should last for the dynamic secret.
  # This value must be less than 1 day, and if a max TTL is defined on the dynamic secret, it must be below the max TTL.
  leaseTTL: 1m

  # A reference to the secret that the dynamic secret lease should be stored in.
  # If the secret doesn't exist, it will automatically be created.
  managedSecretReference:
    secretName: <secret-name>
    secretNamespace: default # Must be the same namespace as the InfisicalDynamicSecret CRD.
    creationPolicy: Orphan

  # Only have one authentication method defined or you are likely to run into authentication issues.
  # Remove all except one authentication method.
  authentication:
    awsIamAuth:
      identityId: <machine-identity-id>
    azureAuth:
      identityId: <machine-identity-id>
    gcpIamAuth:
      identityId: <machine-identity-id>
      serviceAccountKeyFilePath: </path-to-service-account-key-file.json>
    gcpIdTokenAuth:
      identityId: <machine-identity-id>
    ldapAuth:
      identityId: <machine-identity-id>
      credentialsRef:
        secretName: <secret-name> # ldap-auth-credentials
        secretNamespace: <secret-namespace> # default
    kubernetesAuth:
      identityId: <machine-identity-id>
      serviceAccountRef:
        name: <secret-name>
        namespace: <secret-namespace>
    universalAuth:
      credentialsRef:
        secretName: <secret-name> # universal-auth-credentials
        secretNamespace: <secret-namespace> # default
```

Apply the InfisicalDynamicSecret CRD to your cluster.

```bash  theme={"dark"}
kubectl apply -f dynamic-secret-crd.yaml
```

After applying the InfisicalDynamicSecret CRD, you should notice that the dynamic secret lease has been created in Infisical and synced to your Kubernetes cluster. You can verify that the lease has been created by doing:

```bash  theme={"dark"}
kubectl get secret <managed-secret-name> -o yaml
```

After getting the secret, you should should see that the secret has data that contains the lease credentials.

```yaml  theme={"dark"}
apiVersion: v1
data:
  DB_PASSWORD: VHhETjZ4c2xsTXpOSWdPYW5LLlRyNEc2alVKYml6WiQjQS0tNTdodyREM3ZLZWtYSi4hTkdyS0F+TVFsLU9CSA==
  DB_USERNAME: cHg4Z0dJTUVBcHdtTW1aYnV3ZWRsekJRRll6cW4wFEE=
kind: Secret
# .....
```

### InfisicalDynamicSecret CRD properties

<Accordion title="hostAPI">
  If you are fetching secrets from a self-hosted instance of Infisical set the value of `hostAPI` to
  `https://your-self-hosted-instace.com/api`

  When `hostAPI` is not defined the operator fetches secrets from Infisical Cloud.

  <Accordion title="Advanced use case">
    If you have installed your Infisical instance within the same cluster as the Infisical operator, you can optionally access the Infisical backend's service directly without having to route through the public internet.
    To achieve this, use the following address for the hostAPI field:

    ```bash  theme={"dark"}
    http://<backend-svc-name>.<namespace>.svc.cluster.local:4000/api
    ```

    Make sure to replace `<backend-svc-name>` and `<namespace>` with the appropriate values for your backend service and namespace.
  </Accordion>
</Accordion>

<Accordion title="leaseTTL">
  The `leaseTTL` is a string-formatted duration that defines the time the lease should last for the dynamic secret.

  The format of the field is `[duration][unit]` where `duration` is a number and `unit` is a string representing the unit of time.

  The following units are supported:

  * `s` for seconds (must be at least 5 seconds)
  * `m` for minutes
  * `h` for hours
  * `d` for days

    <Note>
      The lease duration at most be 1 day (24 hours). And the TTL must be less than the max TTL defined on the dynamic secret.
    </Note>
</Accordion>

<Accordion title="managedSecretReference">
  The `managedSecretReference` field is used to define the Kubernetes secret where the dynamic secret lease should be stored. The required fields are `secretName` and `secretNamespace`.

  ```yaml  theme={"dark"}
  spec:
    managedSecretReference:
      secretName: <secret-name>
      secretNamespace: default
  ```

  {" "}

  <Accordion title="managedSecretReference.secretName">
    The name of the Kubernetes secret where the dynamic secret lease should be
    stored.
  </Accordion>

  {" "}

  <Accordion title="managedSecretReference.secretNamespace">
    The namespace of the Kubernetes secret where the dynamic secret lease should
    be stored.
  </Accordion>

  <Accordion title="managedSecretReference.creationPolicy">
    Creation policies allow you to control whether or not owner references should be added to the managed Kubernetes secret that is generated by the Infisical operator.
    This is useful for tools such as ArgoCD, where every resource requires an owner reference; otherwise, it will be pruned automatically.

    #### Available options

    * `Orphan` (default)
    * `Owner`

    <Tip>
      When creation policy is set to `Owner`, the `InfisicalSecret` CRD must be in
      the same namespace as where the managed kubernetes secret.
    </Tip>

    This field is optional.
  </Accordion>

  <Accordion title="managedSecretReference.secretType">
    Override the default Opaque type for managed secrets with this field. Useful for creating kubernetes.io/dockerconfigjson secrets.

    This field is optional.
  </Accordion>
</Accordion>

<Accordion title="leaseRevocationPolicy">
  The field is optional and will default to `None` if not defined.

  The lease revocation policy defines what the operator should do with the leases created by the operator, when the InfisicalDynamicSecret CRD is deleted.

  Valid values are `None` and `Revoke`.

  Behavior of each policy:

  * `None`: The operator will not override existing secrets in Infisical. If a secret with the same key already exists, the operator will skip pushing that secret, and the secret will not be managed by the operator.
  * `Revoke`: The operator will revoke the leases created by the operator when the InfisicalDynamicSecret CRD is deleted.

  ```yaml  theme={"dark"}
  spec:
    leaseRevocationPolicy: Revoke
  ```
</Accordion>

<Accordion title="dynamicSecret">
  The `dynamicSecret` field is used to specify which dynamic secret to create leases for. The required fields are `secretName`, `projectId`, `secretsPath`, and `environmentSlug`.

  ```yaml  theme={"dark"}
  spec:
    dynamicSecret:
      secretName: <dynamic-secret-name>
      # Use either projectId OR projectSlug, not both
      projectId: <project-id> # Either projectId or projectSlug is required
      # projectSlug: <project-slug>
      environmentSlug: <env-slug>
      secretsPath: <secrets-path>
  ```

  {" "}

  <Accordion title="dynamicSecret.secretName">
    The name of the dynamic secret.
  </Accordion>

  {" "}

  <Accordion title="dynamicSecret.projectId">
    The project ID of where the dynamic secret is stored in Infisical.

    <Note>
      Please note that you can only use either `projectId` or `projectSlug` in the `dynamicSecret` field.
    </Note>
  </Accordion>

  <Accordion title="dynamicSecret.projectSlug">
    The project slug of where the dynamic secret is stored in Infisical.

    <Note>
      Please note that you can only use either `projectId` or `projectSlug` in the `dynamicSecret` field.
    </Note>
  </Accordion>

  {" "}

  <Accordion title="dynamicSecret.environmentSlug">
    The environment slug of where the dynamic secret is stored in Infisical.
  </Accordion>

  {" "}

  <Accordion title="dynamicSecret.secretsPath">
    The path of where the dynamic secret is stored in Infisical. The root path is
    `/`.
  </Accordion>
</Accordion>

<Accordion title="authentication">
  The `authentication` field dictates which authentication method to use when pushing secrets to Infisical.
  The available authentication methods are `universalAuth`, `kubernetesAuth`, `awsIamAuth`, `azureAuth`, `gcpIdTokenAuth`, and `gcpIamAuth`.

  <Accordion title="universalAuth">
    The universal authentication method is one of the easiest ways to get started with Infisical. Universal Auth works anywhere and is not tied to any specific cloud provider.
    [Read more about Universal Auth](/documentation/platform/identities/universal-auth).

    Valid fields:

    * `identityId`: The identity ID of the machine identity you created.
    * `credentialsRef`: The name and namespace of the Kubernetes secret that stores the service token.
    * `credentialsRef.secretName`: The name of the Kubernetes secret.
    * `credentialsRef.secretNamespace`: The namespace of the Kubernetes secret.

    Example:

    ```yaml  theme={"dark"}
      # infisical-push-secret.yaml
      spec:
        universalAuth:
          credentialsRef:
            secretName: <secret-name>
            secretNamespace: <secret-namespace>
    ```

    ```yaml  theme={"dark"}
      # machine-identity-credentials.yaml
      apiVersion: v1
      kind: Secret
      metadata:
        name: universal-auth-credentials
      type: Opaque
      stringData:
        clientId: <machine-identity-client-id>
        clientSecret: <machine-identity-client-secret>
    ```
  </Accordion>

  <Accordion title="kubernetesAuth">
    The Kubernetes machine identity authentication method is used to authenticate with Infisical. The identity ID is stored in a field in the InfisicalSecret resource. This authentication method can only be used within a Kubernetes environment.
    [Read more about Kubernetes Auth](/documentation/platform/identities/kubernetes-auth).
    Valid fields:

    * `identityId`: The identity ID of the machine identity you created.
    * `serviceAccountRef`: The name and namespace of the service account that will be used to authenticate with Infisical.
    * `serviceAccountRef.name`: The name of the service account.
    * `serviceAccountRef.namespace`: The namespace of the service account.
    * `autoCreateServiceAccountToken`: If set to `true`, the operator will automatically create a short-lived service account token on-demand for the service account. Defaults to `false`.
    * `serviceAccountTokenAudiences`: Optionally specify audience for the service account token. This field is only relevant if you have set `autoCreateServiceAccountToken` to `true`. No audience is specified by default.

    Example:

    ```yaml  theme={"dark"}
      spec:
        kubernetesAuth:
          identityId: <machine-identity-id>
          autoCreateServiceAccountToken: true # Automatically creates short-lived service account tokens for the service account.
          serviceAccountTokenAudiences:
            - <audience> # Optionally specify audience for the service account token. No audience is specified by default.
          serviceAccountRef:
            name: <secret-name>
            namespace: <secret-namespace>
    ```
  </Accordion>

  <Accordion title="ldapAuth">
    The LDAP machine identity authentication method is used to authenticate with a configured LDAP directory. [Read more about LDAP Auth](/documentation/platform/identities/ldap-auth).

    Valid fields:

    * `identityId`: The identity ID of the machine identity you created.
    * `credentialsRef`: The name and namespace of the Kubernetes secret that stores the LDAP credentials.
    * `credentialsRef.secretName`: The name of the Kubernetes secret.
    * `credentialsRef.secretNamespace`: The namespace of the Kubernetes secret.

    Example:

    ```yaml  theme={"dark"}
      # infisical-push-secret.yaml
      spec:
        ldapAuth:
          identityId: <machine-identity-id>
          credentialsRef:
            secretName: <secret-name>
            secretNamespace: <secret-namespace>
    ```

    ```yaml  theme={"dark"}
      # machine-identity-credentials.yaml
      apiVersion: v1
      kind: Secret
      metadata:
        name: ldap-auth-credentials
      type: Opaque
      stringData:
        username: <ldap-username>
        password: <ldap-password>
    ```
  </Accordion>

  <Accordion title="awsIamAuth">
    The AWS IAM machine identity authentication method is used to authenticate with Infisical.
    [Read more about AWS IAM Auth](/documentation/platform/identities/aws-auth).

    Valid fields:

    * `identityId`: The identity ID of the machine identity you created.

    Example:

    ```yaml  theme={"dark"}
      spec:
        authentication:
          awsIamAuth:
            identityId: <machine-identity-id>
    ```
  </Accordion>

  <Accordion title="azureAuth">
    The AWS IAM machine identity authentication method is used to authenticate with Infisical. Azure Auth can only be used from within an Azure environment.
    [Read more about Azure Auth](/documentation/platform/identities/azure-auth).

    Valid fields:

    * `identityId`: The identity ID of the machine identity you created.

    Example:

    ```yaml  theme={"dark"}
      spec:
        authentication:
          azureAuth:
            identityId: <machine-identity-id>
    ```
  </Accordion>

  <Accordion title="gcpIamAuth">
    The GCP IAM machine identity authentication method is used to authenticate with Infisical. The identity ID is stored in a field in the InfisicalSecret resource. This authentication method can only be used both within and outside GCP environments.
    [Read more about Azure Auth](/documentation/platform/identities/gcp-auth).

    Valid fields:

    * `identityId`: The identity ID of the machine identity you created.
    * `serviceAccountKeyFilePath`: The path to the GCP service account key file.

    Example:

    ```yaml  theme={"dark"}
      spec:
        gcpIamAuth:
          identityId: <machine-identity-id>
          serviceAccountKeyFilePath: </path-to-service-account-key-file.json>
    ```
  </Accordion>

  <Accordion title="gcpIdTokenAuth">
    The GCP ID Token machine identity authentication method is used to authenticate with Infisical. The identity ID is stored in a field in the InfisicalSecret resource. This authentication method can only be used within GCP environments.
    [Read more about Azure Auth](/documentation/platform/identities/gcp-auth).

    Valid fields:

    * `identityId`: The identity ID of the machine identity you created.

    Example:

    ```yaml  theme={"dark"}
      spec:
        gcpIdTokenAuth:
          identityId: <machine-identity-id>
    ```
  </Accordion>
</Accordion>

<Accordion title="tls">
  This block defines the TLS settings to use for connecting to the Infisical
  instance.

  Fields:

  <Accordion title="caRef">
    This block defines the reference to the CA certificate to use for connecting to the Infisical instance with SSL/TLS.

    Valid fields:

    * `secretName`: The name of the Kubernetes secret containing the CA certificate to use for connecting to the Infisical instance with SSL/TLS.
    * `secretNamespace`: The namespace of the Kubernetes secret containing the CA certificate to use for connecting to the Infisical instance with SSL/TLS.
    * `key`: The name of the key in the Kubernetes secret which contains the value of the CA certificate to use for connecting to the Infisical instance with SSL/TLS.

    Example:

    ```yaml  theme={"dark"}
      tls:
        caRef:
          secretName: custom-ca-certificate
          secretNamespace: default
          key: ca.crt
    ```
  </Accordion>
</Accordion>

### Applying the InfisicalDynamicSecret CRD to your cluster

Once you have configured the `InfisicalDynamicSecret` CRD with the required fields, you can apply it to your cluster. After applying, you should notice that a lease has been created in Infisical and synced to your Kubernetes cluster.

```bash  theme={"dark"}
kubectl apply -f dynamic-secret-crd.yaml
```

## Auto redeployment

Deployments referring to Kubernetes secrets containing Infisical dynamic secrets don't automatically reload when the dynamic secret lease expires. This means your deployment may use expired dynamic secrets unless manually redeployed.
To address this, we've added functionality to automatically redeploy your deployment when the associated Kubernetes secret containing your Infisical dynamic secret updates.

#### Enabling auto redeploy

To enable auto redeployment you simply have to add the following annotation to the deployment, statefulset, or daemonset that consumes a managed secret.

```yaml  theme={"dark"}
secrets.infisical.com/auto-reload: "true"
```

<Accordion title="Deployment example with auto redeploy enabled">
  ```yaml  theme={"dark"}
  apiVersion: apps/v1
  kind: Deployment
  metadata:
    name: nginx-deployment
    labels:
      app: nginx
    annotations:
      secrets.infisical.com/auto-reload: "true" # <- redeployment annotation
  spec:
    replicas: 1
    selector:
      matchLabels:
        app: nginx
    template:
      metadata:
        labels:
          app: nginx
      spec:
        containers:
        - name: nginx
          image: nginx:1.14.2
          envFrom:
          - secretRef:
              name: managed-secret # The name of your managed secret, the same that you're using in your InfisicalDynamicSecret CRD (spec.managedSecretReference.secretName)
          ports:
          - containerPort: 80
  ```
</Accordion>

<Info>
  #### How it works

  When the lease changes, the operator will check to see which deployments are using the operator-managed Kubernetes secret that received the update.
  Then, for each deployment that has this annotation present, a rolling update will be triggered. A redeployment won't happen if the lease is renewed, only if it's recreated.
</Info>


# Using the InfisicalPushSecret CRD
Source: https://infisical.com/docs/integrations/platforms/kubernetes/infisical-push-secret-crd

Learn how to use the InfisicalPushSecret CRD to push and manage secrets in Infisical.

## Overview

The **InfisicalPushSecret** CRD allows you to create secrets in your Kubernetes cluster and push them to Infisical.

This CRD offers the following features:

* **Push Secrets** from a Kubernetes secret into Infisical.
* **Manage secret lifecycle** of pushed secrets in Infisical. When the Kubernetes secret is updated, the operator will automatically update the secrets in Infisical. Optionally, when the Kubernetes secret is deleted, the operator will delete the secrets in Infisical automatically.

### Prerequisites

* A project within Infisical.
* A [machine identity](/documentation/platform/identities/machine-identities) ready for use in Infisical that has permissions to create secrets in your project.
* The operator is installed on to your Kubernetes cluster.

## Example usage

Below is a sample InfisicalPushSecret CRD that pushes secrets defined in a Kubernetes secret to Infisical.

After filling out the fields in the InfisicalPushSecret CRD, you can apply it directly to your cluster.

Before applying the InfisicalPushSecret CRD, you need to create a Kubernetes secret containing the secrets you want to push to Infisical. An example can be seen below the InfisicalPushSecret CRD.

```yaml infisical-push-secret.yaml theme={"dark"}
  apiVersion: secrets.infisical.com/v1alpha1
  kind: InfisicalPushSecret
  metadata:
    name: infisical-push-secret-demo
  spec:
    resyncInterval: 1m # Remove this field to disable automatic reconciliation of the InfisicalPushSecret CRD.
    hostAPI: https://app.infisical.com/api

    # Optional, defaults to no replacement.
    updatePolicy: Replace # If set to replace, existing secrets inside Infisical will be replaced by the value of the PushSecret on sync.

    # Optional, defaults to no deletion.
    deletionPolicy: Delete # If set to delete, the secret(s) inside Infisical managed by the operator, will be deleted if the InfisicalPushSecret CRD is deleted.

    destination:
      projectId: <project-id> # Either projectId or projectSlug is required
      projectSlug: <project-slug>
      environmentSlug: <env-slug>
      secretsPath: <secret-path>

    push:
      secret:
        secretName: push-secret-demo # Secret CRD
        secretNamespace: default

    # Only have one authentication method defined or you are likely to run into authentication issues.
    # Remove all except one authentication method.
    authentication:
      awsIamAuth:
        identityId: <machine-identity-id>
      azureAuth:
        identityId: <machine-identity-id>
      gcpIamAuth:
        identityId: <machine-identity-id>
        serviceAccountKeyFilePath: </path-to-service-account-key-file.json>
      gcpIdTokenAuth:
        identityId: <machine-identity-id>
      kubernetesAuth:
        identityId: <machine-identity-id>
        serviceAccountRef:
          name: <secret-name>
          namespace: <secret-namespace>
      ldapAuth:
        identityId: <machine-identity-id>
        credentialsRef:
          secretName: <secret-name> # ldap-auth-credentials
          secretNamespace: <secret-namespace> # default
      universalAuth:
        credentialsRef:
          secretName: <secret-name> # universal-auth-credentials
          secretNamespace: <secret-namespace> # default
```

```yaml source-secret.yaml theme={"dark"}
  apiVersion: v1
  kind: Secret
  metadata:
    name: push-secret-demo
    namespace: default
  stringData: # can also be "data", but needs to be base64 encoded
    API_KEY: some-api-key
    DATABASE_URL: postgres://127.0.0.1:5432
    ENCRYPTION_KEY: fabcc12-a22-facbaa4-11aa568aab
```

```bash  theme={"dark"}
  kubectl apply -f source-secret.yaml
```

After applying the soruce-secret.yaml file, you are ready to apply the InfisicalPushSecret CRD.

```bash  theme={"dark"}
  kubectl apply -f infisical-push-secret.yaml
```

After applying the InfisicalPushSecret CRD, you should notice that the secrets you have defined in your source-secret.yaml file have been pushed to your specified destination in Infisical.

## InfisicalPushSecret CRD properties

<Accordion title="hostAPI">
  If you are fetching secrets from a self-hosted instance of Infisical set the value of `hostAPI` to
  `https://your-self-hosted-instace.com/api`

  When `hostAPI` is not defined the operator fetches secrets from Infisical Cloud.

  <Accordion title="Advanced use case">
    If you have installed your Infisical instance within the same cluster as the Infisical operator, you can optionally access the Infisical backend's service directly without having to route through the public internet.
    To achieve this, use the following address for the hostAPI field:

    ```bash  theme={"dark"}
    http://<backend-svc-name>.<namespace>.svc.cluster.local:4000/api
    ```

    Make sure to replace `<backend-svc-name>` and `<namespace>` with the appropriate values for your backend service and namespace.
  </Accordion>
</Accordion>

<Accordion title="resyncInterval">
  The `resyncInterval` is a string-formatted duration that defines the time between each resync. The field is optional, and will default to no automatic resync if not defined.

  If you don't want to automatically reconcile the InfisicalPushSecret CRD on an interval, you can remove the `resyncInterval` field entirely from your InfisicalPushSecret CRD.

  The format of the field is `[duration][unit]` where `duration` is a number and `unit` is a string representing the unit of time.

  The following units are supported:

  * `s` for seconds (must be at least 5 seconds)
  * `m` for minutes
  * `h` for hours
  * `d` for days
  * `w` for weeks

  The default value is `1m` (1 minute).

  Valid intervals examples:

  ```yaml  theme={"dark"}
  resyncInterval: 5s # 10 seconds
  resyncInterval: 10s # 10 seconds
  resyncInterval: 5m # 5 minutes
  resyncInterval: 1h # 1 hour
  resyncInterval: 1d # 1 day
  ```
</Accordion>

<Accordion title="updatePolicy">
  The field is optional and will default to `None` if not defined.

  The update policy defines how the operator should handle conflicting secrets when pushing secrets to Infisical.

  Valid values are `None` and `Replace`.

  Behavior of each policy:

  * `None`: The operator will not override existing secrets in Infisical. If a secret with the same key already exists, the operator will skip pushing that secret, and the secret will not be managed by the operator.
  * `Replace`: The operator will replace existing secrets in Infisical with the new secrets. If a secret with the same key already exists, the operator will update the secret with the new value.

  ```yaml  theme={"dark"}
  spec:
    updatePolicy: Replace
  ```
</Accordion>

<Accordion title="deletionPolicy">
  This field is optional and will default to `None` if not defined.

  The deletion policy defines what the operator should do in case the InfisicalPushSecret CRD is deleted.

  Valid values are `None` and `Delete`.

  Behavior of each policy:

  * `None`: The operator will not delete the secrets in Infisical when the InfisicalPushSecret CRD is deleted.
  * `Delete`: The operator will delete the secrets in Infisical that are managed by the operator when the InfisicalPushSecret CRD is deleted.

  ```yaml  theme={"dark"}
  spec:
    deletionPolicy: Delete
  ```
</Accordion>

<Accordion title="destination">
  The `destination` field is used to specify where you want to create the secrets in Infisical. The required fields are `projectId`, `environmentSlug`, and `secretsPath`.

  ```yaml  theme={"dark"}
  spec:
    destination:
      projectId: <project-id>
      environmentSlug: <env-slug>
      secretsPath: <secrets-path>
  ```

  <Accordion title="destination.projectId">
    The project ID where you want to create the secrets in Infisical.

    <Note>
      Please note that you can only use either `projectId` or `projectSlug` in the `destination` field.
    </Note>
  </Accordion>

  <Accordion title="destination.projectSlug">
    The project slug where you want to create the secrets in Infisical.

    <Note>
      Please note that you can only use either `projectId` or `projectSlug` in the `destination` field.
    </Note>
  </Accordion>

  <Accordion title="destination.environmentSlug">
    The environment slug where you want to create the secrets in Infisical.
  </Accordion>

  <Accordion title="destination.secretsPath">
    The path where you want to create the secrets in Infisical. The root path is `/`.
  </Accordion>
</Accordion>

<Accordion title="push">
  The `push` field is used to define what you want to push to Infisical. Currently the operator only supports pushing Kubernetes secrets to Infisical. An example of the `push` field is shown below.

  <Accordion title="secret">
    The `secret` field is used to define the Kubernetes secret you want to push to Infisical. The required fields are `secretName` and `secretNamespace`.

    Example usage of the `push.secret` field:

    ```yaml infisical-push-secret.yaml theme={"dark"}
      push:
        secret:
          secretName: push-secret-demo
          secretNamespace: default
    ```

    ```yaml push-secret-demo.yaml theme={"dark"}
      apiVersion: v1
      kind: Secret
      metadata:
        name: push-secret-demo
        namespace: default
      # Pass in the secrets you wish to push to Infisical
      stringData:
        API_KEY: some-api-key
        DATABASE_URL: postgres://127.0.0.1:5432
        ENCRYPTION_KEY: fabcc12-a22-facbaa4-11aa568aab
    ```
  </Accordion>

  <Accordion title="generators[]">
    The `generators[]` field is used to define the generators you want to use for your InfisicalPushSecret CRD.
    You can follow the guide for [using generators to push secrets](#using-generators-to-push-secrets) for more information.

    Example:

    ```yaml  theme={"dark"}
      push:
        generators:
          - destinationSecretName: password-generator-test
            generatorRef:
              kind: Password
              name: password-generator
    ```
  </Accordion>
</Accordion>

<Accordion title="authentication">
  The `authentication` field dictates which authentication method to use when pushing secrets to Infisical.
  The available authentication methods are `universalAuth`, `kubernetesAuth`, `awsIamAuth`, `azureAuth`, `gcpIdTokenAuth`, and `gcpIamAuth`.

  <Accordion title="universalAuth">
    The universal authentication method is one of the easiest ways to get started with Infisical. Universal Auth works anywhere and is not tied to any specific cloud provider.
    [Read more about Universal Auth](/documentation/platform/identities/universal-auth).

    Valid fields:

    * `identityId`: The identity ID of the machine identity you created.
    * `credentialsRef`: The name and namespace of the Kubernetes secret that stores the service token.
    * `credentialsRef.secretName`: The name of the Kubernetes secret.
    * `credentialsRef.secretNamespace`: The namespace of the Kubernetes secret.

    Example:

    ```yaml  theme={"dark"}
      # infisical-push-secret.yaml
      spec:
        universalAuth:
          credentialsRef:
            secretName: <secret-name>
            secretNamespace: <secret-namespace>
    ```

    ```yaml  theme={"dark"}
      # machine-identity-credentials.yaml
      apiVersion: v1
      kind: Secret
      metadata:
        name: universal-auth-credentials
      type: Opaque
      stringData:
        clientId: <machine-identity-client-id>
        clientSecret: <machine-identity-client-secret>
    ```
  </Accordion>

  <Accordion title="kubernetesAuth">
    The Kubernetes machine identity authentication method is used to authenticate with Infisical. The identity ID is stored in a field in the InfisicalPushSecret resource. This authentication method can only be used within a Kubernetes environment.
    [Read more about Kubernetes Auth](/documentation/platform/identities/kubernetes-auth).
    Valid fields:

    * `identityId`: The identity ID of the machine identity you created.
    * `serviceAccountRef`: The name and namespace of the service account that will be used to authenticate with Infisical.
    * `serviceAccountRef.name`: The name of the service account.
    * `serviceAccountRef.namespace`: The namespace of the service account.
    * `autoCreateServiceAccountToken`: If set to `true`, the operator will automatically create a short-lived service account token on-demand for the service account. Defaults to `false`.
    * `serviceAccountTokenAudiences`: Optionally specify audience for the service account token. This field is only relevant if you have set `autoCreateServiceAccountToken` to `true`. No audience is specified by default.

    Example:

    ```yaml  theme={"dark"}
      spec:
        kubernetesAuth:
          identityId: <machine-identity-id>
          autoCreateServiceAccountToken: true # Automatically creates short-lived service account tokens for the service account.
          serviceAccountTokenAudiences:
            - <audience> # Optionally specify audience for the service account token. No audience is specified by default.
          serviceAccountRef:
            name: <secret-name>
            namespace: <secret-namespace>
    ```
  </Accordion>

  <Accordion title="ldapAuth">
    The LDAP machine identity authentication method is used to authenticate with a configured LDAP directory. [Read more about LDAP Auth](/documentation/platform/identities/ldap-auth).

    Valid fields:

    * `identityId`: The identity ID of the machine identity you created.
    * `credentialsRef`: The name and namespace of the Kubernetes secret that stores the LDAP credentials.
    * `credentialsRef.secretName`: The name of the Kubernetes secret.
    * `credentialsRef.secretNamespace`: The namespace of the Kubernetes secret.

    Example:

    ```yaml  theme={"dark"}
      # infisical-push-secret.yaml
      spec:
        ldapAuth:
          identityId: <machine-identity-id>
          credentialsRef:
            secretName: <secret-name>
            secretNamespace: <secret-namespace>
    ```

    ```yaml  theme={"dark"}
      # machine-identity-credentials.yaml
      apiVersion: v1
      kind: Secret
      metadata:
        name: ldap-auth-credentials
      type: Opaque
      stringData:
        username: <ldap-username>
        password: <ldap-password>
    ```
  </Accordion>

  <Accordion title="awsIamAuth">
    The AWS IAM machine identity authentication method is used to authenticate with Infisical.
    [Read more about AWS IAM Auth](/documentation/platform/identities/aws-auth).

    Valid fields:

    * `identityId`: The identity ID of the machine identity you created.

    Example:

    ```yaml  theme={"dark"}
      spec:
        authentication:
          awsIamAuth:
            identityId: <machine-identity-id>
    ```
  </Accordion>

  <Accordion title="azureAuth">
    The AWS IAM machine identity authentication method is used to authenticate with Infisical. Azure Auth can only be used from within an Azure environment.
    [Read more about Azure Auth](/documentation/platform/identities/azure-auth).

    Valid fields:

    * `identityId`: The identity ID of the machine identity you created.

    Example:

    ```yaml  theme={"dark"}
      spec:
        authentication:
          azureAuth:
            identityId: <machine-identity-id>
    ```
  </Accordion>

  <Accordion title="gcpIamAuth">
    The GCP IAM machine identity authentication method is used to authenticate with Infisical. The identity ID is stored in a field in the InfisicalPushSecret resource. This authentication method can only be used both within and outside GCP environments.
    [Read more about Azure Auth](/documentation/platform/identities/gcp-auth).

    Valid fields:

    * `identityId`: The identity ID of the machine identity you created.
    * `serviceAccountKeyFilePath`: The path to the GCP service account key file.

    Example:

    ```yaml  theme={"dark"}
      spec:
        gcpIamAuth:
          identityId: <machine-identity-id>
          serviceAccountKeyFilePath: </path-to-service-account-key-file.json>
    ```
  </Accordion>

  <Accordion title="gcpIdTokenAuth">
    The GCP ID Token machine identity authentication method is used to authenticate with Infisical. The identity ID is stored in a field in the InfisicalPushSecret resource. This authentication method can only be used within GCP environments.
    [Read more about Azure Auth](/documentation/platform/identities/gcp-auth).

    Valid fields:

    * `identityId`: The identity ID of the machine identity you created.

    Example:

    ```yaml  theme={"dark"}
      spec:
        gcpIdTokenAuth:
          identityId: <machine-identity-id>
    ```
  </Accordion>
</Accordion>

<Accordion title="tls">
  This block defines the TLS settings to use for connecting to the Infisical
  instance.

  Fields:

  <Accordion title="caRef">
    This block defines the reference to the CA certificate to use for connecting to the Infisical instance with SSL/TLS.

    Valid fields:

    * `secretName`: The name of the Kubernetes secret containing the CA certificate to use for connecting to the Infisical instance with SSL/TLS.
    * `secretNamespace`: The namespace of the Kubernetes secret containing the CA certificate to use for connecting to the Infisical instance with SSL/TLS.
    * `key`: The name of the key in the Kubernetes secret which contains the value of the CA certificate to use for connecting to the Infisical instance with SSL/TLS.

    Example:

    ```yaml  theme={"dark"}
      tls:
        caRef:
          secretName: custom-ca-certificate
          secretNamespace: default
          key: ca.crt
    ```
  </Accordion>
</Accordion>

## Using templating to push secrets

Pushing secrets to Infisical from the operator may not always be enough.
Templating is a useful utility of the Infisical secrets operator that allows you to use Go Templating to template the secrets you want to push to Infisical.
Using Go templates, you can format, combine, and create new key-value pairs of secrets that you want to push to Infisical.

<Accordion title="push.secret.template" />

<Accordion title="push.secret.template.includeAllSecrets">
  This property controls what secrets are included in your push to Infisica.
  When set to `true`, all secrets included in the `push.secret.secretName` Kubernetes secret will be pushed to Infisical.
  **Use this option when you would like to push all secrets to Infisical from the secrets operator, but want to template a subset of them.**

  When set to `false`, only secrets defined in the `push.secret.template.data` field of the template will be pushed to Infisical.
  Use this option when you would like to push **only** a subset of secrets from the Kubernetes secret to Infisical.
</Accordion>

<Accordion title="push.secret.template.data">
  Define secret keys and their corresponding templates.
  Each data value uses a Golang template with access to all secrets defined in the `push.secret.secretName` Kubernetes secret.

  Secrets are structured as follows:

  ```go  theme={"dark"}
  type TemplateSecret struct {
      Value      string `json:"value"`
      SecretPath string `json:"secretPath"`
  }
  ```

  #### Example template configuration:

  ```yaml  theme={"dark"}
  # This example assumes that the `push-secret-demo` Kubernetes secret contains the following secrets:
  # SITE_URL = "https://example.com"
  # REGION = "us-east-1"
  # OTHER_SECRET = "other-secret"

  push:
    secret:
      secretName: push-secret-demo
      secretNamespace: default
      template:
        includeAllSecrets: true # Includes all secrets from the `push-secret-demo` Kubernetes secret
        data:
          SITE_URL: "{{ .SITE_URL.Value }}"
          API_URL: "https://api.{{.SITE_URL.Value}}.{{.REGION.Value}}.com" # Will create a new secret in Infisical with the key `API_URL` with the value of the `SITE_URL` and `REGION` secrets
  ```

  To help transform your config map data further, the operator provides a set of built-in functions that you can use in your templates.

  ### Available templating functions

  Please refer to the [templating functions documentation](/integrations/platforms/kubernetes/overview#available-helper-functions) for more information.
</Accordion>

## Using generators to push secrets

Generators allow secrets to be dynamically generated during each reconciliation cycle and then pushed to Infisical. They are useful for use cases where a new secret value is needed on every sync, such as ephemeral credentials or one-time-use tokens.

A generator is defined as a custom resource (`ClusterGenerator`) within the cluster, which specifies the logic for generating secret values. Generators are stateless, each invocation triggers the creation of a new set of values, with no tracking or persistence of previously generated data.

Because of this behavior, you may want to disable automatic syncing for the `InfisicalPushSecret` resource to avoid continuous regeneration of secrets. This can be done by omitting the `resyncInterval` field from the InfisicalPushSecret CRD.

### Example usage

```yaml  theme={"dark"}
  push:
    secret:
      secretName: push-secret-source-secret
      secretNamespace: dev
    generators:
      - destinationSecretName: password-generator # Name of the secret that will be created in Infisical
        generatorRef:
          kind: Password # Kind of the resource, must match the generator kind.
          name: custom-generator # Name of the generator resource
```

To use a generator, you must specify at least one generator in the `push.generators[]` field.

<Accordion title="push.generators[]">
  This field holds an array of the generators you want to use for your InfisicalPushSecret CRD.
</Accordion>

<Accordion title="push.generators[].destinationSecretName">
  The name of the secret that will be created in Infisical.
</Accordion>

<Accordion title="push.generators[].generatorRef">
  The reference to the generator resource.

  Valid fields:

  * `kind`: The kind of the generator resource, must match the generator kind.
  * `name`: The name of the generator resource.
</Accordion>

<Accordion title="push.generators[].generatorRef.kind">
  The kind of the generator resource, must match the generator kind.

  Valid values:

  * `Password`
  * `UUID`
</Accordion>

<Accordion title="push.generators[].generatorRef.name">
  The name of the generator resource.
</Accordion>

### Supported Generators

Below are the currently supported generators for the InfisicalPushSecret CRD. Each generator is a `ClusterGenerator` custom resource that can be used to customize the generated secret.

<Accordion title="Password Generator">
  ### Password Generator

  The Password generator is a custom resource that is installed on the cluster that defines the logic for generating a password.

  * `kind`: The kind of the generator resource, must match the generator kind. For the Password generator, the kind is `Password`.
  * `generator.passwordSpec`: The spec of the password generator.

  <Accordion title="generator.kind">
    The `generator.kind` field must match the kind of the generator resource. For the Password generator, the kind should always be set to  `Password`.
  </Accordion>

  <Accordion title="generator.passwordSpec">
    * `length`: The length of the password.
    * `digits`: The number of digits in the password.
    * `symbols`: The number of symbols in the password.
    * `symbolCharacters`: The characters to use for the symbols in the password.
    * `noUpper`: Whether to include uppercase letters in the password.
    * `allowRepeat`: Whether to allow repeating characters in the password.
  </Accordion>

  ```yaml password-cluster-generator.yaml theme={"dark"}
  apiVersion: secrets.infisical.com/v1alpha1
  kind: ClusterGenerator
  metadata:
    name: password-generator
  spec:
    kind: Password
    generator:
      passwordSpec:
        length: 10
        digits: 5
        symbols: 5
        symbolCharacters: "-_$@"
        noUpper: false
        allowRepeat: true
  ```

  Example InfisicalPushSecret CRD using the Password generator:

  ```yaml infisical-push-secret-crd.yaml theme={"dark"}
    push:
      generators:
        - destinationSecretName: password-generator-test
          generatorRef:
            kind: Password
            name: password-generator
  ```
</Accordion>

<Accordion title="UUID Generator">
  ### UUID Generator

  The UUID generator is a custom resource that is installed on the cluster that defines the logic for generating a UUID.

  * `kind`: The kind of the generator resource, must match the generator kind. For the UUID generator, the kind is `UUID`.
  * `generator.uuidSpec`: The spec of the UUID generator. For UUID's, this can be left empty.

  <Accordion title="generator.kind">
    The `generator.kind` field must match the kind of the generator resource. For the UUID generator, the kind should always be set to  `UUID`.
  </Accordion>

  <Accordion title="generator.uuidSpec">
    The spec of the UUID generator. For UUID's, this can be left empty.
  </Accordion>

  ```yaml uuid-cluster-generator.yaml theme={"dark"}
    apiVersion: secrets.infisical.com/v1alpha1
    kind: ClusterGenerator
    metadata:
      name: uuid-generator
    spec:
      kind: UUID
      generator:
        uuidSpec:
  ```

  Example InfisicalPushSecret CRD using the UUID generator:

  ```yaml infisical-push-secret-crd.yaml theme={"dark"}
    push:
      generators:
        - destinationSecretName: uuid-generator-test
          generatorRef:
            kind: UUID
            name: uuid-generator
  ```
</Accordion>

## Applying the InfisicalPushSecret CRD to your cluster

Once you have configured the `InfisicalPushSecret` CRD with the required fields, you can apply it to your cluster.
After applying, you should notice that the secrets have been pushed to Infisical.

```bash  theme={"dark"}
  kubectl apply -f source-push-secret.yaml # The secret that you're referencing in the InfisicalPushSecret CRD push.secret field
  kubectl apply -f example-infisical-push-secret-crd.yaml # The InfisicalPushSecret CRD itself
```


# Using the InfisicalSecret CRD
Source: https://infisical.com/docs/integrations/platforms/kubernetes/infisical-secret-crd

Learn how to use the InfisicalSecret CRD to fetch secrets from Infisical and store them as native Kubernetes secret resource

Once you have installed the operator to your cluster, you'll need to create a `InfisicalSecret` custom resource definition (CRD).
In this CRD, you'll define the authentication method to use, the secrets to fetch, and the target location to store the secrets within your cluster.

```yaml example-infisical-secret-crd.yaml theme={"dark"}
apiVersion: secrets.infisical.com/v1alpha1
kind: InfisicalSecret
metadata:
  name: infisicalsecret-sample
  labels:
    label-to-be-passed-to-managed-secret: sample-value
  annotations:
    example.com/annotation-to-be-passed-to-managed-secret: "sample-value"
spec:
  hostAPI: https://app.infisical.com/api
  resyncInterval: 10
  authentication:
    kubernetesAuth:
      identityId: <machine-identity-id>
      serviceAccountRef:
        name: <service-account-name>
        namespace: <service-account-namespace>

  managedKubeSecretReferences:
    - secretName: managed-secret
      secretNamespace: default
      creationPolicy: "Orphan"
      template:
        includeAllSecrets: true
        data:
          NEW_KEY_NAME: "{{ .KEY.SecretPath }} {{ .KEY.Value }}"
          KEY_WITH_BINARY_VALUE: "{{ .KEY.SecretPath }} {{ .KEY.Value }}"
```

## CRD properties

### Generic

The following properties help define what instance of Infisical the operator will interact with, the interval it will sync secrets and any CA certificates that may be required to connect.

<Accordion title="hostAPI">
  If you are fetching secrets from a self-hosted instance of Infisical set the value of `hostAPI` to
  ` https://your-self-hosted-instace.com/api`

  When `hostAPI` is not defined the operator fetches secrets from Infisical Cloud.

  <Accordion title="Advanced use case">
    If you have installed your Infisical instance within the same cluster as the Infisical operator, you can optionally access the Infisical backend's service directly without having to route through the public internet.
    To achieve this, use the following address for the hostAPI field:

    ```bash  theme={"dark"}
    http://<backend-svc-name>.<namespace>.svc.cluster.local:4000/api
    ```

    Make sure to replace `<backend-svc-name>` and `<namespace>` with the appropriate values for your backend service and namespace.
  </Accordion>
</Accordion>

<Accordion title="resyncInterval">
  This property defines the time in seconds between each secret re-sync from
  Infisical. Shorter time between re-syncs will require higher rate limits only
  available on paid plans. Default re-sync interval is every 1 minute.
</Accordion>

<Accordion title="instantUpdates">
  This property enables instant updates from Infisical. When set to true,
  changes made to secrets in Infisical will be immediately pushed to the
  operator, triggering a configuration update. This reduces the need for
  periodic re-syncs.

  <Info>
    Note that `Instant Updates` is a paid feature.

    If you're using Infisical Cloud, then it is available under the **Pro**,
    and **Enterprise Tier** with varying retention periods. If you're self-hosting Infisical,
    then you should contact [sales@infisical.com](mailto:sales@infisical.com) to purchase an enterprise license to use it.
  </Info>
</Accordion>

<Accordion title="tls">
  This block defines the TLS settings to use for connecting to the Infisical
  instance.
</Accordion>

<Accordion title="tls.caRef">
  This block defines the reference to the CA certificate to use for connecting
  to the Infisical instance with SSL/TLS.
</Accordion>

<Accordion title="tls.caRef.secretName">
  The name of the Kubernetes secret containing the CA certificate to use for
  connecting to the Infisical instance with SSL/TLS.
</Accordion>

<Accordion title="tls.caRef.secretNamespace">
  The namespace of the Kubernetes secret containing the CA certificate to use
  for connecting to the Infisical instance with SSL/TLS.
</Accordion>

<Accordion title="tls.caRef.key">
  The name of the key in the Kubernetes secret which contains the value of the
  CA certificate to use for connecting to the Infisical instance with SSL/TLS.
</Accordion>

### Authentication Methods

To retrieve the requested secrets, the operator must first authenticate with Infisical.
The list of available authentication methods are shown below.

<Accordion title="authentication" />

<Accordion title="authentication.universalAuth">
  The universal machine identity authentication method is used to authenticate with Infisical. The client ID and client secret needs to be stored in a Kubernetes secret. This block defines the reference to the name and namespace of secret that stores these credentials.

  <Steps>
    <Step title="Create a machine identity">
      You need to create a machine identity, and give it access to the project(s) you want to interact with. You can [read more about machine identities here](/documentation/platform/identities/universal-auth).
    </Step>

    <Step title="Create Kubernetes secret containing machine identity credentials">
      Once you have created your machine identity and added it to your project(s), you will need to create a Kubernetes secret containing the identity credentials.
      To quickly create a Kubernetes secret containing the identity credentials, you can run the command below.

      Make sure you replace `<your-identity-client-id>` with the identity client ID and `<your-identity-client-secret>` with the identity client secret.

      ```bash  theme={"dark"}
        kubectl create secret generic universal-auth-credentials --from-literal=clientId="<your-identity-client-id>" --from-literal=clientSecret="<your-identity-client-secret>"
      ```
    </Step>

    <Step title="Add reference for the Kubernetes secret containing the identity credentials">
      Once the secret is created, add the `secretName` and `secretNamespace` of the secret that was just created under `authentication.universalAuth.credentialsRef` field in the InfisicalSecret resource.
    </Step>
  </Steps>

  <Info>
    Make sure to also populate the `secretsScope` field with the project slug
    *`projectSlug`*, environment slug *`envSlug`*, and secrets path
    *`secretsPath`* that you want to fetch secrets from. Please see the example
    below.
  </Info>

  ## Example

  ```yaml  theme={"dark"}
  apiVersion: secrets.infisical.com/v1alpha1
  kind: InfisicalSecret
  metadata:
    name: infisicalsecret-sample-crd
  spec:
    authentication:
        universalAuth:
            secretsScope:
                # either projectSlug or projectId is required
                projectSlug: <project-slug> # <-- project slug
                projectId: <project-id> # <-- project id

                secretName: <secret-name> # OPTIONAL: If you want to fetch a single Infisical secret, you can specify the secret name here. If not specified, all secrets in the specified scope will be fetched.
                envSlug: <env-slug> # "dev", "staging", "prod", etc..
                secretsPath: "<secrets-path>" # Root is "/"
            credentialsRef:
                secretName: universal-auth-credentials # <-- name of the Kubernetes secret that stores our machine identity credentials
                secretNamespace: default # <-- namespace of the Kubernetes secret that stores our machine identity credentials
    ...
  ```
</Accordion>

<Accordion title="authentication.kubernetesAuth">
  The Kubernetes machine identity authentication method is used to authenticate with Infisical. The identity ID is stored in a field in the InfisicalSecret resource. This authentication method can only be used within a Kubernetes environment.

  <Tabs>
    <Tab title="Short-lived service account tokens (Recommended)">
      Short-lived service account tokens are automatically created by the operator and are valid only for a short period of time. This is the recommended approach for using Kubernetes auth in the Infisical Secrets Operator.

      <Steps>
        <Step title="Obtaining the token reviewer JWT for Infisical">
          **1.1.** Start by creating a reviewer service account in your Kubernetes cluster that will be used by Infisical to authenticate with the Kubernetes API Server.

          ```yaml infisical-reviewer-service-account.yaml theme={"dark"}
          apiVersion: v1
          kind: ServiceAccount
          metadata:
            name: infisical-token-reviewer
            namespace: default

          ```

          ```bash  theme={"dark"}
          kubectl apply -f infisical-reviewer-service-account.yaml
          ```

          **1.2.** Bind the reviewer service account to the `system:auth-delegator` cluster role. As described [here](https://kubernetes.io/docs/reference/access-authn-authz/rbac/#other-component-roles), this role allows delegated authentication and authorization checks, specifically for Infisical to access the [TokenReview API](https://kubernetes.io/docs/reference/kubernetes-api/authentication-resources/token-review-v1/). You can apply the following configuration file:

          ```yaml infisical-reviewer-cluster-role-binding.yaml theme={"dark"}
          apiVersion: rbac.authorization.k8s.io/v1
          kind: ClusterRoleBinding
          metadata:
            name: infisical-token-reviewer-role-binding
            namespace: default
          roleRef:
            apiGroup: rbac.authorization.k8s.io
            kind: ClusterRole
            name: system:auth-delegator
          subjects:
            - kind: ServiceAccount
              name: infisical-token-reviewer
              namespace: default
          ```

          ```bash  theme={"dark"}
          kubectl apply -f infisical-reviewer-cluster-role-binding.yaml
          ```

          **1.3.** Next, create a long-lived service account JWT token (i.e. the token reviewer JWT token) for the service account using this configuration file for a new `Secret` resource:

          ```yaml service-account-reviewer-token.yaml theme={"dark"}
            apiVersion: v1
            kind: Secret
            type: kubernetes.io/service-account-token
            metadata:
              name: infisical-token-reviewer-token
              annotations:
                kubernetes.io/service-account.name: "infisical-token-reviewer"
          ```

          ```bash  theme={"dark"}
          kubectl apply -f service-account-reviewer-token.yaml
          ```

          **1.4.** Link the secret in step 1.3 to the service account in step 1.1:

          ```bash  theme={"dark"}
          kubectl patch serviceaccount infisical-token-reviewer -p '{"secrets": [{"name": "infisical-token-reviewer-token"}]}' -n default
          ```

          **1.5.** Finally, retrieve the token reviewer JWT token from the secret.

          ```bash  theme={"dark"}
          kubectl get secret infisical-token-reviewer-token -n default -o=jsonpath='{.data.token}' | base64 --decode
          ```

          Keep this JWT token handy as you will need it for the **Token Reviewer JWT** field when configuring the Kubernetes Auth authentication method for the identity in step 2.
        </Step>

        <Step title="Creating an identity">
          To create an identity, head to your Organization Settings > Access Control > Identities and press **Create identity**.

                    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-org.png" alt="identities organization" />

          When creating an identity, you specify an organization level [role](/documentation/platform/access-controls/role-based-access-controls) for it to assume; you can configure roles in Organization Settings > Access Control > Organization Roles.

                    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-org-create.png" alt="identities organization create" />

          Now input a few details for your new identity. Here's some guidance for each field:

          * Name (required): A friendly name for the identity.
          * Role (required): A role from the **Organization Roles** tab for the identity to assume. The organization role assigned will determine what organization level resources this identity can have access to.

          Once you've created an identity, you'll be prompted to configure the authentication method for it. Here, select **Kubernetes Auth**.

          <Info>
            To learn more about each field of the Kubernetes native authentication method, see step 2 of [guide](/documentation/platform/identities/kubernetes-auth#guide).
          </Info>

                    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-org-create-kubernetes-auth-method.png" alt="identities organization create auth method" />
        </Step>

        <Step title="Adding an identity to a project">
          To allow the operator to use the given identity to access secrets, you will need to add the identity to project(s) that you would like  to grant it access to.

          To do this, head over to the project you want to add the identity to and go to Project Settings > Access Control > Machine Identities and press **Add identity**.

          Next, select the identity you want to add to the project and the project level role you want to allow it to assume. The project role assigned will determine what project level resources this identity can have access to.

                    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-project.png" alt="identities project" />

                    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-project-create.png" alt="identities project create" />
        </Step>

        <Step title="Create a new Kubernetes service account to authenticate with Infisical">
          You have already created the reviewer service account in step **1.1**. Now, create a new Kubernetes service account that will be used to authenticate with Infisical.
          This service account will create short-lived tokens that will be used to authenticate with Infisical. The operator itself will handle the creation of these tokens automatically.

          ```yaml infisical-service-account.yaml theme={"dark"}
          kind: ServiceAccount
          apiVersion: v1
          metadata:
            name: infisical-service-account
          ```

          ```bash  theme={"dark"}
          kubectl apply -f infisical-service-account.yaml -n default
          ```
        </Step>

        <Step title="Add your identity ID & service account to your InfisicalSecret resource">
          Once you have created your machine identity and added it to your project(s), you will need to add the identity ID to your InfisicalSecret resource.
          In the `authentication.kubernetesAuth.identityId` field, add the identity ID of the machine identity you created.
          See the example below for more details.
        </Step>

        <Step title="Add your Kubernetes service account token to the InfisicalSecret resource">
          Add the service account details from the previous steps under `authentication.kubernetesAuth.serviceAccountRef`.
          Here you will need to enter the name and namespace of the service account.
          The example below shows a complete InfisicalSecret resource with all required fields defined.
          Make sure you set `authentication.kubernetesAuth.autoCreateServiceAccountToken` to `true` to automatically create short-lived service account tokens for the service account.
        </Step>
      </Steps>

      <Info>
        Make sure to also populate the `secretsScope` field with the project slug
        *`projectSlug`*, environment slug *`envSlug`*, and secrets path
        *`secretsPath`* that you want to fetch secrets from. Please see the example
        below.
      </Info>

      ## Example

      ```yaml example-kubernetes-auth.yaml theme={"dark"}
      apiVersion: secrets.infisical.com/v1alpha1
      kind: InfisicalSecret
      metadata:
        name: infisicalsecret-sample-crd
      spec:
        authentication:
            kubernetesAuth:
                identityId: <machine-identity-id>
                autoCreateServiceAccountToken: true # Automatically creates short-lived service account tokens for the service account.
                serviceAccountTokenAudiences:
                  - <audience> # Optionally specify audience for the service account token. No audience is specified by default.
                serviceAccountRef:
                  name: infisical-service-account # The service account we just created in the previous step.
                  namespace: <service-account-namespace>

                # secretsScope is identical to the secrets scope in the universalAuth field in this sample.
                secretsScope:
                    projectSlug: your-project-slug
                    envSlug: prod
                    secretsPath: "/path"
                    secretName: <secret-name> # OPTIONAL: If you want to fetch a single Infisical secret, you can specify the secret name here. If not specified, all secrets in the specified scope will be fetched.
                    recursive: true
        ...
      ```
    </Tab>

    <Tab title="Manual long-lived service account tokens">
      Manual long-lived service account tokens are manually created by the user and are valid indefinitely unless deleted or rotated. In most cases, you should be using the automatic short-lived service account tokens as they are more secure and easier to use.

      <Steps>
        <Step title="Obtaining the token reviewer JWT for Infisical">
          **1.1.** Start by creating a reviewer service account in your Kubernetes cluster that will be used by Infisical to authenticate with the Kubernetes API Server.

          ```yaml infisical-reviewer-service-account.yaml theme={"dark"}
          apiVersion: v1
          kind: ServiceAccount
          metadata:
            name: infisical-token-reviewer
            namespace: default

          ```

          ```bash  theme={"dark"}
          kubectl apply -f infisical-reviewer-service-account.yaml
          ```

          **1.2.** Bind the reviewer service account to the `system:auth-delegator` cluster role. As described [here](https://kubernetes.io/docs/reference/access-authn-authz/rbac/#other-component-roles), this role allows delegated authentication and authorization checks, specifically for Infisical to access the [TokenReview API](https://kubernetes.io/docs/reference/kubernetes-api/authentication-resources/token-review-v1/). You can apply the following configuration file:

          ```yaml infisical-reviewer-cluster-role-binding.yaml theme={"dark"}
          apiVersion: rbac.authorization.k8s.io/v1
          kind: ClusterRoleBinding
          metadata:
            name: infisical-token-reviewer-role-binding
            namespace: default
          roleRef:
            apiGroup: rbac.authorization.k8s.io
            kind: ClusterRole
            name: system:auth-delegator
          subjects:
            - kind: ServiceAccount
              name: infisical-token-reviewer
              namespace: default
          ```

          ```bash  theme={"dark"}
          kubectl apply -f infisical-reviewer-cluster-role-binding.yaml
          ```

          **1.3.** Next, create a long-lived service account JWT token (i.e. the token reviewer JWT token) for the service account using this configuration file for a new `Secret` resource:

          ```yaml service-account-reviewer-token.yaml theme={"dark"}
            apiVersion: v1
            kind: Secret
            type: kubernetes.io/service-account-token
            metadata:
              name: infisical-token-reviewer-token
              annotations:
                kubernetes.io/service-account.name: "infisical-token-reviewer"
          ```

          ```bash  theme={"dark"}
          kubectl apply -f service-account-reviewer-token.yaml
          ```

          **1.4.** Link the secret in step 1.3 to the service account in step 1.1:

          ```bash  theme={"dark"}
          kubectl patch serviceaccount infisical-token-reviewer -p '{"secrets": [{"name": "infisical-token-reviewer-token"}]}' -n default
          ```

          **1.5.** Finally, retrieve the token reviewer JWT token from the secret.

          ```bash  theme={"dark"}
          kubectl get secret infisical-token-reviewer-token -n default -o=jsonpath='{.data.token}' | base64 --decode
          ```

          Keep this JWT token handy as you will need it for the **Token Reviewer JWT** field when configuring the Kubernetes Auth authentication method for the identity in step 2.
        </Step>

        <Step title="Creating an identity">
          To create an identity, head to your Organization Settings > Access Control > Identities and press **Create identity**.

                    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-org.png" alt="identities organization" />

          When creating an identity, you specify an organization level [role](/documentation/platform/access-controls/role-based-access-controls) for it to assume; you can configure roles in Organization Settings > Access Control > Organization Roles.

                    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-org-create.png" alt="identities organization create" />

          Now input a few details for your new identity. Here's some guidance for each field:

          * Name (required): A friendly name for the identity.
          * Role (required): A role from the **Organization Roles** tab for the identity to assume. The organization role assigned will determine what organization level resources this identity can have access to.

          Once you've created an identity, you'll be prompted to configure the authentication method for it. Here, select **Kubernetes Auth**.

          <Info>
            To learn more about each field of the Kubernetes native authentication method, see step 2 of [guide](/documentation/platform/identities/kubernetes-auth#guide).
          </Info>

                    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-org-create-kubernetes-auth-method.png" alt="identities organization create auth method" />
        </Step>

        <Step title="Adding an identity to a project">
          To allow the operator to use the given identity to access secrets, you will need to add the identity to project(s) that you would like  to grant it access to.

          To do this, head over to the project you want to add the identity to and go to Project Settings > Access Control > Machine Identities and press **Add identity**.

          Next, select the identity you want to add to the project and the project level role you want to allow it to assume. The project role assigned will determine what project level resources this identity can have access to.

                    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-project.png" alt="identities project" />

                    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/platform/identities/identities-project-create.png" alt="identities project create" />
        </Step>

        <Step title="Create a new Kubernetes service account to authenticate with Infisical">
          You have already created the reviewer service account in step **1.1**. Now, create a new Kubernetes service account that will be used to authenticate with Infisical.

          ```yaml infisical-service-account.yaml theme={"dark"}
          kind: ServiceAccount
          apiVersion: v1
          metadata:
            name: infisical-service-account
          ```

          ```bash  theme={"dark"}
          kubectl apply -f infisical-service-account.yaml -n default
          ```
        </Step>

        <Step title="Create a service account token for the Kubernetes service account">
          Create a service account token for the newly created Kubernetes service account from the previous step.

          ```yaml infisical-service-account-token.yaml theme={"dark"}
          apiVersion: v1
          kind: Secret
          type: kubernetes.io/service-account-token
          metadata:
            name: infisical-service-account-token
            annotations:
              kubernetes.io/service-account.name: "infisical-service-account"
          ```

          ```bash  theme={"dark"}
          kubectl apply -f infisical-service-account-token.yaml -n default
          ```

          Patch the service account with the newly created service account token.

          ```bash  theme={"dark"}
          kubectl patch serviceaccount infisical-service-account -p '{"secrets": [{"name": "infisical-service-account-token"}]}' -n default
          ```
        </Step>

        <Step title="Add your identity ID & service account to your InfisicalSecret resource">
          Once you have created your machine identity and added it to your project(s), you will need to add the identity ID to your InfisicalSecret resource.
          In the `authentication.kubernetesAuth.identityId` field, add the identity ID of the machine identity you created.
          See the example below for more details.
        </Step>

        <Step title="Add your Kubernetes service account token to the InfisicalSecret resource">
          Add the service account details from the previous steps under `authentication.kubernetesAuth.serviceAccountRef`.
          Here you will need to enter the name and namespace of the service account.
          The example below shows a complete InfisicalSecret resource with all required fields defined.
        </Step>
      </Steps>

      <Info>
        Make sure to also populate the `secretsScope` field with the project slug
        *`projectSlug`*, or project ID *`projectId`*, environment slug *`envSlug`*, and secrets path
        *`secretsPath`* that you want to fetch secrets from. Please see the example
        below.

        Please note that you can only use either `projectSlug` or `projectId` in the `secretsScope` field.
      </Info>

      ## Example

      ```yaml example-kubernetes-auth.yaml theme={"dark"}
      apiVersion: secrets.infisical.com/v1alpha1
      kind: InfisicalSecret
      metadata:
        name: infisicalsecret-sample-crd
      spec:
        authentication:
            kubernetesAuth:
                identityId: <machine-identity-id>
                serviceAccountRef:
                  name: infisical-service-account # The service account we just created in the previous step. (*not* the reviewer service account)
                  namespace: <service-account-namespace>

                # secretsScope is identical to the secrets scope in the universalAuth field in this sample.
                secretsScope:
                    projectSlug: your-project-slug
                    envSlug: prod
                    secretsPath: "/path"
                    secretName: <secret-name> # OPTIONAL: If you want to fetch a single Infisical secret, you can specify the secret name here. If not specified, all secrets in the specified scope will be fetched.
                    recursive: true
        ...
      ```
    </Tab>
  </Tabs>
</Accordion>

<Accordion title="authentication.awsIamAuth">
  The AWS IAM machine identity authentication method is used to authenticate with Infisical. The identity ID is stored in a field in the InfisicalSecret resource. This authentication method can only be used within an AWS environment like an EC2 or a Lambda function.

  <Steps>
    <Step title="Create a machine identity">
      You need to create a machine identity, and give it access to the project(s) you want to interact with. You can [read more about AWS machine identities here](/documentation/platform/identities/aws-auth).
    </Step>

    <Step title="Add your identity ID to your InfisicalSecret resource">
      Once you have created your machine identity and added it to your project(s), you will need to add the identity ID to your InfisicalSecret resource. In the `authentication.awsIamAuth.identityId` field, add the identity ID of the machine identity you created. See the example below for more details.
    </Step>
  </Steps>

  <Info>
    Make sure to also populate the `secretsScope` field with the project slug
    *`projectSlug`*, or project ID *`projectId`*, environment slug *`envSlug`*, and secrets path
    *`secretsPath`* that you want to fetch secrets from. Please see the example
    below.

    Please note that you can only use either `projectSlug` or `projectId` in the `secretsScope` field.
  </Info>

  ## Example

  ```yaml example-aws-iam-auth.yaml theme={"dark"}
  apiVersion: secrets.infisical.com/v1alpha1
  kind: InfisicalSecret
  metadata:
    name: infisicalsecret-sample-crd
  spec:
    authentication:
        awsIamAuth:
            identityId: <your-machine-identity-id>

            # secretsScope is identical to the secrets scope in the universalAuth field in this sample.
            secretsScope:
                projectSlug: your-project-slug
                envSlug: prod
                secretsPath: "/path"
                secretName: <secret-name> # OPTIONAL: If you want to fetch a single Infisical secret, you can specify the secret name here. If not specified, all secrets in the specified scope will be fetched.
                recursive: true
    ...
  ```
</Accordion>

<Accordion title="authentication.azureAuth">
  The Azure machine identity authentication method is used to authenticate with Infisical. The identity ID is stored in a field in the InfisicalSecret resource. This authentication method can only be used within an Azure environment.

  <Steps>
    <Step title="Create a machine identity">
      You need to create a machine identity, and give it access to the project(s) you want to interact with. You can [read more about Azure machine identities here](/documentation/platform/identities/azure-auth).
    </Step>

    <Step title="Add your identity ID to your InfisicalSecret resource">
      Once you have created your machine identity and added it to your project(s), you will need to add the identity ID to your InfisicalSecret resource. In the `authentication.azureAuth.identityId` field, add the identity ID of the machine identity you created. See the example below for more details.
    </Step>
  </Steps>

  <Info>
    Make sure to also populate the `secretsScope` field with the project slug
    *`projectSlug`*, or project ID *`projectId`*, environment slug *`envSlug`*, and secrets path
    *`secretsPath`* that you want to fetch secrets from. Please see the example
    below.

    Please note that you can only use either `projectSlug` or `projectId` in the `secretsScope` field.
  </Info>

  ## Example

  ```yaml example-azure-auth.yaml theme={"dark"}
  apiVersion: secrets.infisical.com/v1alpha1
  kind: InfisicalSecret
  metadata:
    name: infisicalsecret-sample-crd
  spec:
    authentication:
        azureAuth:
            identityId: <your-machine-identity-id>

            # secretsScope is identical to the secrets scope in the universalAuth field in this sample.
            secretsScope:
                projectSlug: your-project-slug
                envSlug: prod
                secretsPath: "/path"
                secretName: <secret-name> # OPTIONAL: If you want to fetch a single Infisical secret, you can specify the secret name here. If not specified, all secrets in the specified scope will be fetched.
                recursive: true
    ...
  ```
</Accordion>

<Accordion title="authentication.gcpIdTokenAuth">
  The GCP ID Token machine identity authentication method is used to authenticate with Infisical. The identity ID is stored in a field in the InfisicalSecret resource. This authentication method can only be used within GCP environments.

  <Steps>
    <Step title="Create a machine identity">
      You need to create a machine identity, and give it access to the project(s) you want to interact with. You can [read more about GCP machine identities here](/documentation/platform/identities/gcp-auth).
    </Step>

    <Step title="Add your identity ID to your InfisicalSecret resource">
      Once you have created your machine identity and added it to your project(s), you will need to add the identity ID to your InfisicalSecret resource. In the `authentication.gcpIdTokenAuth.identityId` field, add the identity ID of the machine identity you created. See the example below for more details.
    </Step>
  </Steps>

  <Info>
    Make sure to also populate the `secretsScope` field with the project slug
    *`projectSlug`*, or project ID *`projectId`*, environment slug *`envSlug`*, and secrets path
    *`secretsPath`* that you want to fetch secrets from. Please see the example
    below.

    Please note that you can only use either `projectSlug` or `projectId` in the `secretsScope` field.
  </Info>

  ## Example

  ```yaml example-gcp-id-token-auth.yaml theme={"dark"}
  apiVersion: secrets.infisical.com/v1alpha1
  kind: InfisicalSecret
  metadata:
    name: infisicalsecret-sample-crd
  spec:
    authentication:
        gcpIdTokenAuth:
            identityId: <your-machine-identity-id>

            # secretsScope is identical to the secrets scope in the universalAuth field in this sample.
            secretsScope:
                projectSlug: your-project-slug
                envSlug: prod
                secretsPath: "/path"
                secretName: <secret-name> # OPTIONAL: If you want to fetch a single Infisical secret, you can specify the secret name here. If not specified, all secrets in the specified scope will be fetched.
                recursive: true
    ...
  ```
</Accordion>

<Accordion title="authentication.gcpIamAuth">
  The GCP IAM machine identity authentication method is used to authenticate with Infisical. The identity ID is stored in a field in the InfisicalSecret resource. This authentication method can only be used both within and outside GCP environments.

  <Steps>
    <Step title="Create a machine identity">
      You need to create a machine identity, and give it access to the project(s) you want to interact with. You can [read more about GCP machine identities here](/documentation/platform/identities/gcp-auth).
    </Step>

    <Step title="Add your identity ID and service account token path to your InfisicalSecret resource">
      Once you have created your machine identity and added it to your project(s), you will need to add the identity ID to your InfisicalSecret resource. In the `authentication.gcpIamAuth.identityId` field, add the identity ID of the machine identity you created.
      You'll also need to add the service account key file path to your InfisicalSecret resource. In the `authentication.gcpIamAuth.serviceAccountKeyFilePath` field, add the path to your service account key file path. Please see the example below for more details.
    </Step>
  </Steps>

  <Info>
    Make sure to also populate the `secretsScope` field with the project slug
    *`projectSlug`*, or project ID *`projectId`*, environment slug *`envSlug`*, and secrets path
    *`secretsPath`* that you want to fetch secrets from. Please see the example
    below.

    Please note that you can only use either `projectSlug` or `projectId` in the `secretsScope` field.
  </Info>

  ## Example

  ```yaml example-gcp-id-token-auth.yaml theme={"dark"}
  apiVersion: secrets.infisical.com/v1alpha1
  kind: InfisicalSecret
  metadata:
    name: infisicalsecret-sample-crd
  spec:
    authentication:
        gcpIamAuth:
            identityId: <your-machine-identity-id>
            serviceAccountKeyFilePath: "/path/to-service-account-key-file-path.json"

            # secretsScope is identical to the secrets scope in the universalAuth field in this sample.
            secretsScope:
                projectSlug: your-project-slug
                envSlug: prod
                secretsPath: "/path"
                secretName: <secret-name> # OPTIONAL: If you want to fetch a single Infisical secret, you can specify the secret name here. If not specified, all secrets in the specified scope will be fetched.
                recursive: true
    ...
  ```
</Accordion>

<Accordion title="authentication.ldapAuth">
  The LDAP machine identity authentication method is used to authenticate with Infisical using the configured LDAP directory. The username and password needs to be stored in a Kubernetes secret. This block defines the reference to the name and namespace of secret that stores these credentials.

  <Steps>
    <Step title="Create a machine identity">
      You need to create a machine identity, and give it access to the project(s) you want to interact with. You can [read more about machine identities here](/documentation/platform/identities/universal-auth).
    </Step>

    <Step title="Create Kubernetes secret containing machine identity credentials">
      Once you have created your machine identity and added it to your project(s), you will need to create a Kubernetes secret containing the identity credentials.
      To quickly create a Kubernetes secret containing the identity credentials, you can run the command below.

      Make sure you replace `<your-identity-ldap-username>` with the identity LDAP username and `<your-identity-ldap-password>` with the identity LDAP password.

      ```bash  theme={"dark"}
        kubectl create secret generic ldap-auth-credentials --from-literal=username="<your-identity-ldap-username>" --from-literal=password="<your-identity-ldap-password>"
      ```
    </Step>

    <Step title="Add reference for the Kubernetes secret containing the identity credentials">
      Once the secret is created, add the `secretName` and `secretNamespace` of the secret that was just created under `authentication.ldapAuth.credentialsRef` field in the InfisicalSecret resource.
    </Step>
  </Steps>

  <Info>
    Make sure to also populate the `secretsScope` field with the project slug
    *`projectSlug`*, or project ID *`projectId`*, environment slug *`envSlug`*, and secrets path
    *`secretsPath`* that you want to fetch secrets from. Please see the example
    below.

    Please note that you can only use either `projectSlug` or `projectId` in the `secretsScope` field.
  </Info>

  ## Example

  ```yaml  theme={"dark"}
  apiVersion: secrets.infisical.com/v1alpha1
  kind: InfisicalSecret
  metadata:
    name: infisicalsecret-sample-crd
  spec:
    authentication:
      ldapAuth:
        secretsScope:
          projectSlug: <project-slug> # <-- project slug
          envSlug: <env-slug> # "dev", "staging", "prod", etc..
          secretsPath: "<secrets-path>" # Root is "/"
          secretName: <secret-name> # OPTIONAL: If you want to fetch a single Infisical secret, you can specify the secret name here. If not specified, all secrets in the specified scope will be fetched.
        identityId: <machine-identity-id>
        credentialsRef:
          secretName: ldap-auth-credentials # <-- name of the Kubernetes secret that stores our machine identity credentials
          secretNamespace: default # <-- namespace of the Kubernetes secret that stores our machine identity credentials
  ```
</Accordion>

<Accordion title="authentication.serviceToken">
  The service token required to authenticate with Infisical needs to be stored in a Kubernetes secret. This block defines the reference to the name and namespace of secret that stores this service token.
  Follow the instructions below to create and store the service token in a Kubernetes secrets and reference it in your CRD.

  #### 1. Generate service token

  You can generate a [service token](/documentation/platform/token) for an Infisical project by heading over to the Infisical dashboard then to Project Settings.

  #### 2. Create Kubernetes secret containing service token

  Once you have generated the service token, you will need to create a Kubernetes secret containing the service token you generated.
  To quickly create a Kubernetes secret containing the generated service token, you can run the command below. Make sure you replace `<your-service-token-here>` with your service token.

  ```bash  theme={"dark"}
  kubectl create secret generic service-token --from-literal=infisicalToken="<your-service-token-here>"
  ```

  #### 3. Add reference for the Kubernetes secret containing service token

  Once the secret is created, add the name and namespace of the secret that was just created under `authentication.serviceToken.serviceTokenSecretReference` field in the InfisicalSecret resource.

  {" "}

  <Info>
    Make sure to also populate the `secretsScope` field with the, environment slug
    *`envSlug`*, and secrets path *`secretsPath`* that you want to fetch secrets
    from. Please see the example below.
  </Info>

  ## Example

  ```yaml  theme={"dark"}
  apiVersion: secrets.infisical.com/v1alpha1
  kind: InfisicalSecret
  metadata:
    name: infisicalsecret-sample-crd
  spec:
    authentication:
      serviceToken:
        serviceTokenSecretReference:
          secretName: service-token # <-- name of the Kubernetes secret that stores our service token
          secretNamespace: option # <-- namespace of the Kubernetes secret that stores our service token
        secretsScope:
          envSlug: <env-slug> # "dev", "staging", "prod", etc..
          secretsPath: <secrets-path> # Root is "/"
    ...
  ```
</Accordion>

### Operator Managed Secrets

The managed secret properties specify where to store the secrets retrieved from your Infisical project.
This includes defining the name and namespace of the Kubernetes secret that will hold these secrets.
The Infisical operator will automatically create the Kubernetes secret in the specified name/namespace and ensure it stays up-to-date.

<Note>
  The `managedSecretReference` field is deprecated and will be removed in a future release.
  Replace it with `managedKubeSecretReferences`, which now accepts an array of references to support multiple managed secrets in a single InfisicalSecret CRD.

  Example:

  ```yaml  theme={"dark"}
  managedKubeSecretReferences:
    - secretName: managed-secret
      secretNamespace: default
      creationPolicy: "Orphan"
  ```
</Note>

<Accordion title="managedKubeSecretReferences" />

<Accordion title="managedKubeSecretReferences[].secretName">
  The name of the managed Kubernetes secret to be created
</Accordion>

<Accordion title="managedKubeSecretReferences[].secretNamespace">
  The namespace of the managed Kubernetes secret to be created.
</Accordion>

<Accordion title="managedKubeSecretReferences[].secretType">
  Override the default Opaque type for managed secrets with this field. Useful for creating kubernetes.io/dockerconfigjson secrets.
</Accordion>

<Accordion title="managedKubeSecretReferences[].creationPolicy">
  Creation policies allow you to control whether or not owner references should be added to the managed Kubernetes secret that is generated by the Infisical operator.
  This is useful for tools such as ArgoCD, where every resource requires an owner reference; otherwise, it will be pruned automatically.

  #### Available options

  * `Orphan` (default)
  * `Owner`

  <Tip>
    When creation policy is set to `Owner`, the `InfisicalSecret` CRD must be in
    the same namespace as where the managed kubernetes secret.
  </Tip>
</Accordion>

#### Managed Secret Templating

Fetching secrets from Infisical as is via the operator may not be enough. This is where templating functionality may be helpful.
Using Go templates, you can format, combine, and create new key-value pairs from secrets fetched from Infisical before storing them as Kubernetes Secrets.

<Accordion title="managedKubeSecretReferences[].template" />

<Accordion title="managedKubeSecretReferences[].template.includeAllSecrets">
  This property controls what secrets are included in your managed secret when using templates.
  When set to `true`, all secrets fetched from your Infisical project will be added into your managed Kubernetes secret resource.
  **Use this option when you would like to sync all secrets from Infisical to Kubernetes but want to template a subset of them.**

  When set to `false`, only secrets defined in the `managedKubeSecretReferences[].template.data` field of the template will be included in the managed secret.
  Use this option when you would like to sync **only** a subset of secrets from Infisical to Kubernetes.
</Accordion>

<Accordion title="managedKubeSecretReferences[].template.data">
  Define secret keys and their corresponding templates.
  Each data value uses a Golang template with access to all secrets retrieved from the specified scope.

  Secrets are structured as follows:

  ```golang  theme={"dark"}
  type TemplateSecret struct {
      Value      string `json:"value"`
      SecretPath string `json:"secretPath"`
  }
  ```

  #### Example template configuration:

  ```yaml  theme={"dark"}
  managedKubeSecretReferences:
    - secretName: managed-secret
      secretNamespace: default
      template:
        includeAllSecrets: true
        data:
          # Create new secret key that doesn't exist in your Infisical project using values of other secrets
          NEW_KEY: "{{ .DB_PASSWORD.Value }}"
          # Override an existing secret key in Infisical project with a new value using values of other secrets
          API_URL: "https://api.{{.COMPANY_NAME.Value}}.{{.REGION.Value}}.com"
  ```

  For this example, let's assume the following secrets exist in your Infisical project:

  ```
  DB_PASSWORD = "secret123"
  COMPANY_NAME = "acme"
  REGION = "us-east-1"
  API_URL = "old-url"  # This will be overridden
  ```

  The resulting managed Kubernetes secret will then contain:

  ```
  # Original secrets (from includeAllSecrets: true)
  DB_PASSWORD = "secret123"
  COMPANY_NAME = "acme"
  REGION = "us-east-1"

  # New and overridden templated secrets
  NEW_KEY = "secret123"                       # New secret created from template
  API_URL = "https://api.acme.us-east-1.com" # Existing secret overridden by template
  ```

  To help transform your secrets further, the operator provides a set of built-in functions that you can use in your templates.

  ### Available templating functions

  Please refer to the [templating functions documentation](/integrations/platforms/kubernetes/overview#available-helper-functions) for more information.
</Accordion>

### Operator Managed ConfigMaps

The managed config map properties specify where to store the secrets retrieved from your Infisical project. Config maps can be used to store **non-sensitive** data, such as application configuration variables.
The properties includes defining the name and namespace of the Kubernetes config map that will hold the data retrieved from your Infisical project.
The Infisical operator will automatically create the Kubernetes config map in the specified name/namespace and ensure it stays up-to-date. If a config map already exists in the specified namespace, the operator will update the existing config map with the new data.

<Warning>
  The usage of config maps is only intended for storing non-sensitive data. If
  you are looking to store sensitive data, please use the [managed
  secret](#operator-managed-secrets) property instead.
</Warning>

<Accordion title="managedKubeConfigMapReferences" />

<Accordion title="managedKubeConfigMapReferences[].configMapName">
  The name of the managed Kubernetes config map that your Infisical data will be stored in.
</Accordion>

<Accordion title="managedKubeConfigMapReferences[].configMapNamespace">
  The namespace of the managed Kubernetes config map that your Infisical data will be stored in.
</Accordion>

<Accordion title="managedKubeConfigMapReferences[].creationPolicy">
  Creation policies allow you to control whether or not owner references should be added to the managed Kubernetes config map that is generated by the Infisical operator.
  This is useful for tools such as ArgoCD, where every resource requires an owner reference; otherwise, it will be pruned automatically.

  #### Available options

  * `Orphan` (default)
  * `Owner`

  <Tip>
    When creation policy is set to `Owner`, the `InfisicalSecret` CRD must be in
    the same namespace as where the managed kubernetes config map.
  </Tip>
</Accordion>

#### Managed ConfigMap Templating

Fetching secrets from Infisical as is via the operator may not be enough. This is where templating functionality may be helpful.
Using Go templates, you can format, combine, and create new key-value pairs from secrets fetched from Infisical before storing them as Kubernetes Config Maps.

<Accordion title="managedKubeConfigMapReferences[].template" />

<Accordion title="managedKubeConfigMapReferences[].template.includeAllSecrets">
  This property controls what secrets are included in your managed config map when using templates.
  When set to `true`, all secrets fetched from your Infisical project will be added into your managed Kubernetes config map resource.
  **Use this option when you would like to sync all secrets from Infisical to Kubernetes but want to template a subset of them.**

  When set to `false`, only secrets defined in the `managedKubeConfigMapReferences[].template.data` field of the template will be included in the managed config map.
  Use this option when you would like to sync **only** a subset of secrets from Infisical to Kubernetes.
</Accordion>

<Accordion title="managedKubeConfigMapReferences[].template.data">
  Define secret keys and their corresponding templates.
  Each data value uses a Golang template with access to all secrets retrieved from the specified scope.

  Secrets are structured as follows:

  ```golang  theme={"dark"}
  type TemplateSecret struct {
      Value      string `json:"value"`
      SecretPath string `json:"secretPath"`
  }
  ```

  #### Example template configuration:

  ```yaml  theme={"dark"}
  managedKubeConfigMapReferences:
    - configMapName: managed-configmap
      configMapNamespace: default
      template:
        includeAllSecrets: true
        data:
          # Create new key that doesn't exist in your Infisical project using values of other secrets
          SITE_URL: "{{ .SITE_URL.Value }}"
          # Override an existing key in Infisical project with a new value using values of other secrets
          API_URL: "https://api.{{.SITE_URL.Value}}.{{.REGION.Value}}.com"
  ```

  For this example, let's assume the following secrets exist in your Infisical project:

  ```
  SITE_URL = "https://example.com"
  REGION = "us-east-1"
  API_URL = "old-url"  # This will be overridden
  ```

  The resulting managed Kubernetes config map will then contain:

  ```
  # Original config map data (from includeAllSecrets: true)
  SITE_URL = "https://example.com"
  REGION = "us-east-1"

  # New and overridden config map data
  SITE_URL = "https://example.com"
  API_URL = "https://api.example.com.us-east-1.com" # Existing secret overridden by template
  ```

  To help transform your config map data further, the operator provides a set of built-in functions that you can use in your templates.

  ### Available templating functions

  Please refer to the [templating functions documentation](/integrations/platforms/kubernetes/overview#available-helper-functions) for more information.
</Accordion>

## Applying CRD

Once you have configured the InfisicalSecret CRD with the required fields, you can apply it to your cluster.
After applying, you should notice that the managed secret has been created in the desired namespace your specified.

```
kubectl apply -f example-infisical-secret-crd.yaml
```

To verify that the operator has successfully created the managed secret, you can check the secrets in the namespace that was specified.

<Tabs>
  <Tab title="Managed Secret">
    ```bash  theme={"dark"}
    # Verify managed secret is created
    kubectl get secrets -n <namespace of managed secret>
    ```

    <Info>
      The Infisical secrets will be synced and stored into the managed secret every
      1 minute unless configured otherwise.
    </Info>
  </Tab>

  <Tab title="Managed ConfigMap">
    ```bash  theme={"dark"}
    # Verify managed config map is created
    kubectl get configmaps -n <namespace of managed config map>
    ```

    <Info>
      The Infisical config map data will be synced and stored into the managed config map every
      1 minute unless configured otherwise.
    </Info>
  </Tab>
</Tabs>

## Using Managed Secret In Your Deployment

To make use of the managed secret created by the operator into your deployment can be achieved through several methods.
Here, we will highlight three of the most common ways to utilize it. Learn more about Kubernetes secrets [here](https://kubernetes.io/docs/concepts/configuration/secret/)

<Accordion title="envFrom">
  This will take all the secrets from your managed secret and expose them to your container

  ````yaml  theme={"dark"}
    envFrom:
      - secretRef:
          name: managed-secret # managed secret name
    ```

    Example usage in a deployment
    ```yaml
    apiVersion: apps/v1
  kind: Deployment
  metadata:
    name: nginx-deployment
    labels:
      app: nginx
  spec:
    replicas: 1
    selector:
      matchLabels:
        app: nginx
    template:
      metadata:
        labels:
          app: nginx
      spec:
        containers:
        - name: nginx
          image: nginx:1.14.2
          envFrom:
          - secretRef:
              name: managed-secret # <- name of managed secret
          ports:
          - containerPort: 80
  ````
</Accordion>

<Accordion title="env">
  This will allow you to select individual secrets by key name from your managed secret and expose them to your container

  ```yaml  theme={"dark"}
  env:
    - name: SECRET_NAME # The environment variable's name which is made available in the container
      valueFrom:
        secretKeyRef:
          name: managed-secret # managed secret name
          key: SOME_SECRET_KEY # The name of the key which exists in the managed secret
  ```

  Example usage in a deployment

  ```yaml  theme={"dark"}
  apiVersion: apps/v1
  kind: Deployment
  metadata:
    name: nginx-deployment
    labels:
      app: nginx
  spec:
    replicas: 1
    selector:
      matchLabels:
        app: nginx
    template:
      metadata:
        labels:
          app: nginx
      spec:
        containers:
          - name: nginx
            image: nginx:1.14.2
            env:
              - name: STRIPE_API_SECRET
                valueFrom:
                  secretKeyRef:
                    name: managed-secret # <- name of managed secret
                    key: STRIPE_API_SECRET
            ports:
              - containerPort: 80
  ```
</Accordion>

<Accordion title="volumes">
  This will allow you to create a volume on your container which comprises of files holding the secrets in your managed kubernetes secret

  ```yaml  theme={"dark"}
  volumes:
    - name: secrets-volume-name # The name of the volume under which secrets will be stored
      secret:
        secretName: managed-secret # managed secret name
  ```

  You can then mount this volume to the container's filesystem so that your deployment can access the files containing the managed secrets

  ```yaml  theme={"dark"}
  volumeMounts:
    - name: secrets-volume-name
      mountPath: /etc/secrets
      readOnly: true
  ```

  Example usage in a deployment

  ```yaml  theme={"dark"}
  apiVersion: apps/v1
  kind: Deployment
  metadata:
    name: nginx-deployment
    labels:
      app: nginx
  spec:
    replicas: 1
    selector:
      matchLabels:
        app: nginx
    template:
      metadata:
        labels:
          app: nginx
      spec:
        containers:
          - name: nginx
            image: nginx:1.14.2
            volumeMounts:
              - name: secrets-volume-name
                mountPath: /etc/secrets
                readOnly: true
            ports:
              - containerPort: 80
        volumes:
          - name: secrets-volume-name
            secret:
              secretName: managed-secret # <- managed secrets
  ```
</Accordion>

The definition file of the Kubernetes secret for the CA certificate can be structured like the following:

```yaml  theme={"dark"}
apiVersion: v1
kind: Secret
metadata:
  name: custom-ca-certificate
type: Opaque
stringData:
  ca.crt: |
    -----BEGIN CERTIFICATE-----
    MIIEZzCCA0+gAwIBAgIUDk9+HZcMHppiNy0TvoBg8/aMEqIwDQYJKoZIhvcNAQEL
    ...
    BQAwDTELMAkGA1UEChMCUEgwHhcNMjQxMDI1MTU0MjAzWhcNMjUxMDI1MjE0MjAz
    -----END CERTIFICATE-----
```

### Automatic Redeployment

Deployments using managed secrets don't reload automatically on updates, so they may use outdated secrets unless manually redeployed.
To address this, we added functionality to automatically redeploy your deployment when its managed secret updates.

#### Enabling Automatic Redeployment

To enable auto redeployment you simply have to add the following annotation to the Deployment, StatefulSet, or DaemonSet that consumes a managed secret.

```yaml  theme={"dark"}
secrets.infisical.com/auto-reload: "true"
```

<Accordion title="Deployment example">
  ```yaml  theme={"dark"}
  apiVersion: apps/v1
  kind: Deployment
  metadata:
    name: nginx-deployment
    labels:
      app: nginx
    annotations:
      secrets.infisical.com/auto-reload: "true" # <- redeployment annotation
  spec:
    replicas: 1
    selector:
      matchLabels:
        app: nginx
    template:
      metadata:
        labels:
          app: nginx
      spec:
        containers:
        - name: nginx
          image: nginx:1.14.2
          envFrom:
          - secretRef:
              name: managed-secret
          ports:
          - containerPort: 80
  ```
</Accordion>

<Accordion title="DaemonSet example">
  ```yaml  theme={"dark"}
  apiVersion: apps/v1
  kind: DaemonSet
  metadata:
    name: log-agent
    labels:
      app: log-agent
    annotations:
      secrets.infisical.com/auto-reload: "true" # <- redeployment annotation
  spec:
    selector:
      matchLabels:
        app: log-agent
    template:
      metadata:
        labels:
          app: log-agent
      spec:
        containers:
          - name: log-agent
            image: mycompany/log-agent:latest
            envFrom:
              - secretRef:
                  name: managed-secret # <- name of the managed secret
            volumeMounts:
              - name: config-volume
                mountPath: /etc/config
                readOnly: true
        volumes:
          - name: config-volume
            secret:
              secretName: managed-secret
  ```
</Accordion>

<Accordion title="StatefulSet example">
  ```yaml  theme={"dark"}
  apiVersion: apps/v1
  kind: StatefulSet
  metadata:
    name: db-worker
    labels:
      app: db-worker
    annotations:
      secrets.infisical.com/auto-reload: "true" # <- redeployment annotation
  spec:
    selector:
      matchLabels:
        app: db-worker
    serviceName: "db-worker"
    replicas: 2
    template:
      metadata:
        labels:
          app: db-worker
      spec:
        containers:
          - name: db-worker
            image: mycompany/db-worker:stable
            env:
              - name: DATABASE_PASSWORD
                valueFrom:
                  secretKeyRef:
                    name: managed-secret
                    key: DB_PASSWORD
            ports:
              - containerPort: 5432
  ```
</Accordion>

<Info>
  #### How it works When a managed secret is updated, the operator checks for

  any Deployments, DaemonSets, or StatefulSets that consume the updated secret
  and have the annotation `secrets.infisical.com/auto-reload: "true"`. For each
  matching workload, the operator triggers a rolling restart to ensure it picks
  up the latest secret values.
</Info>

## Using Managed ConfigMap In Your Deployment

To make use of the managed ConfigMap created by the operator into your deployment can be achieved through several methods.
Here, we will highlight three of the most common ways to utilize it. Learn more about Kubernetes ConfigMaps [here](https://kubernetes.io/docs/concepts/configuration/configmap/)

<Tip>
  Automatic redeployment of deployments using managed ConfigMaps is not yet
  supported.
</Tip>

<Accordion title="envFrom">
  This will take all the secrets from your managed ConfigMap and expose them to your container

  ````yaml  theme={"dark"}
    envFrom:
      - configMapRef:
          name: managed-configmap # managed configmap name
    ```

    Example usage in a deployment
    ```yaml
    apiVersion: apps/v1
  kind: Deployment
  metadata:
    name: nginx-deployment
    labels:
      app: nginx
  spec:
    replicas: 1
    selector:
      matchLabels:
        app: nginx
    template:
      metadata:
        labels:
          app: nginx
      spec:
        containers:
        - name: nginx
          image: nginx:1.14.2
          envFrom:
          - configMapRef:
              name: managed-configmap # <- name of managed configmap
          ports:
          - containerPort: 80
  ````
</Accordion>

<Accordion title="env">
  This will allow you to select individual secrets by key name from your managed ConfigMap and expose them to your container

  ```yaml  theme={"dark"}
  env:
    - name: CONFIG_NAME # The environment variable's name which is made available in the container
      valueFrom:
        configMapKeyRef:
          name: managed-configmap # managed configmap name
          key: SOME_CONFIG_KEY # The name of the key which exists in the managed configmap
  ```

  Example usage in a deployment

  ```yaml  theme={"dark"}
  apiVersion: apps/v1
  kind: Deployment
  metadata:
    name: nginx-deployment
    labels:
      app: nginx
  spec:
    replicas: 1
    selector:
      matchLabels:
        app: nginx
    template:
      metadata:
        labels:
          app: nginx
      spec:
        containers:
          - name: nginx
            image: nginx:1.14.2
            env:
              - name: STRIPE_API_SECRET
                valueFrom:
                  configMapKeyRef:
                    name: managed-configmap # <- name of managed configmap
                    key: STRIPE_API_SECRET
            ports:
              - containerPort: 80
  ```
</Accordion>

<Accordion title="volumes">
  This will allow you to create a volume on your container which comprises of files holding the secrets in your managed kubernetes secret

  ```yaml  theme={"dark"}
  volumes:
    - name: configmaps-volume-name # The name of the volume under which configmaps will be stored
      configMap:
        name: managed-configmap # managed configmap name
  ```

  You can then mount this volume to the container's filesystem so that your deployment can access the files containing the managed secrets

  ```yaml  theme={"dark"}
  volumeMounts:
    - name: configmaps-volume-name
      mountPath: /etc/config
      readOnly: true
  ```

  Example usage in a deployment

  ```yaml  theme={"dark"}
  apiVersion: apps/v1
  kind: Deployment
  metadata:
    name: nginx-deployment
    labels:
      app: nginx
  spec:
    replicas: 1
    selector:
      matchLabels:
        app: nginx
    template:
      metadata:
        labels:
          app: nginx
      spec:
        containers:
          - name: nginx
            image: nginx:1.14.2
            volumeMounts:
              - name: configmaps-volume-name
                mountPath: /etc/config
                readOnly: true
            ports:
              - containerPort: 80
        volumes:
          - name: configmaps-volume-name
            configMap:
              name: managed-configmap # <- managed configmap
  ```
</Accordion>

The definition file of the Kubernetes secret for the CA certificate can be structured like the following:

```yaml  theme={"dark"}
apiVersion: v1
kind: Secret
metadata:
  name: custom-ca-certificate
type: Opaque
stringData:
  ca.crt: |
    -----BEGIN CERTIFICATE-----
    MIIEZzCCA0+gAwIBAgIUDk9+HZcMHppiNy0TvoBg8/aMEqIwDQYJKoZIhvcNAQEL
    ...
    BQAwDTELMAkGA1UEChMCUEgwHhcNMjQxMDI1MTU0MjAzWhcNMjUxMDI1MjE0MjAz
    -----END CERTIFICATE-----
```

## Propagating Labels & Annotations

The operator will transfer all labels & annotations present on the `InfisicalSecret` CRD to the managed Kubernetes secret to be created.
Thus, if a specific label is required on the resulting secret, it can be applied as demonstrated in the following example:

<Accordion title="Example propagation">
  ```yaml  theme={"dark"}
  apiVersion: secrets.infisical.com/v1alpha1
  kind: InfisicalSecret
  metadata:
    name: infisicalsecret-sample
    labels:
      label-to-be-passed-to-managed-secret: sample-value
    annotations:
      example.com/annotation-to-be-passed-to-managed-secret: "sample-value"
  spec:
    ..
    authentication:
      ...
    managedKubeSecretReferences:
      ...
  ```

  This would result in the following managed secret to be created:

  ```yaml  theme={"dark"}
  apiVersion: v1
  data: ...
  kind: Secret
  metadata:
    annotations:
      example.com/annotation-to-be-passed-to-managed-secret: sample-value
      secrets.infisical.com/version: W/"3f1-ZyOSsrCLGSkAhhCkY2USPu2ivRw"
    labels:
      label-to-be-passed-to-managed-secret: sample-value
    name: managed-token
    namespace: default
  type: Opaque
  ```
</Accordion>


# Kubernetes Operator
Source: https://infisical.com/docs/integrations/platforms/kubernetes/overview

How to use Infisical to inject, push, and manage secrets within Kubernetes clusters

The Infisical Operator is a collection of Kubernetes controllers that streamline how secrets are managed between Infisical and your Kubernetes cluster.
It provides multiple Custom Resource Definitions (CRDs) which enable you to:

* **Sync** secrets from Infisical into Kubernetes (`InfisicalSecret`).
* **Push** new secrets from Kubernetes to Infisical (`InfisicalPushSecret`).
* **Manage** dynamic secrets and automatically create time-bound leases (`InfisicalDynamicSecret`).

When these CRDs are configured, the Infisical Operator will continuously monitors for changes and performs necessary updates to keep your Kubernetes secrets up to date.
It can also automatically reload dependent Deployments resources whenever relevant secrets are updated.

<Note>
  If you are already using the External Secrets operator, you can view the
  integration documentation for it
  [here](https://external-secrets.io/latest/provider/infisical/).
</Note>

## Install

The operator can be installed via [Helm](https://helm.sh). Helm is a package manager for Kubernetes that allows you to define, install, and upgrade Kubernetes applications.

**Install the latest Helm repository**

```bash  theme={"dark"}
helm repo add infisical-helm-charts 'https://dl.cloudsmith.io/public/infisical/helm-charts/helm/charts/' 
```

```bash  theme={"dark"}
helm repo update
```

The operator can be installed either cluster-wide or restricted to a specific namespace.
If you require stronger isolation and stricter access controls, a namespace-scoped installation may make more sense.

<Tabs>
  <Tab title="Cluster Wide Installation">
    ```bash  theme={"dark"}
    helm install --generate-name infisical-helm-charts/secrets-operator
    ```

    <Accordion title="Using your own service account">
      By default a service account is created for the operator based on the operator release name.
      You can bring your own service account by setting `controllerManager.serviceAccount.create` to `false` and setting `controllerManager.serviceAccount.name` to the name of the service account you want to use in your values.yaml file.

      Example values.yaml file:

      ```yaml values.yaml theme={"dark"}
      controllerManager:
        serviceAccount:
          create: false
          name: my-service-account
      # other values...
      ```

      <Note>
        Please note that if you set `controllerManager.serviceAccount.create` to `false`, the service account needs to already exist in the namespace you are installing the operator in.
      </Note>

      <Tip>
        Custom service accounts are supported in chart version `0.10.11` and above. Please upgrade your helm chart to `0.10.11` or above before attempting to use custom service accounts.
      </Tip>
    </Accordion>
  </Tab>

  <Tab title="Namespace Scoped Installation">
    The operator can be configured to watch and manage secrets in a specific namespace instead of having cluster-wide access. This is useful for:

    * **Enhanced Security**: Limit the operator's permissions to only specific namespaces instead of cluster-wide access
    * **Multi-tenant Clusters**: Run separate operator instances for different teams or applications
    * **Resource Isolation**: Ensure operators in different namespaces don't interfere with each other
    * **Development & Testing**: Run development and production operators side by side in isolated namespaces

    **Note**: For multiple namespace-scoped installations, only the first installation should install CRDs. Subsequent installations should set `installCRDs: false` to avoid conflicts.

    ```bash  theme={"dark"}
    # First namespace installation (with CRDs)
    helm install operator-namespace1 infisical-helm-charts/secrets-operator \
      --namespace first-namespace \
      --set scopedNamespace=first-namespace \
      --set scopedRBAC=true

    # Subsequent namespace installations
    helm install operator-namespace2 infisical-helm-charts/secrets-operator \
      --namespace another-namespace \
      --set scopedNamespace=another-namespace \
      --set scopedRBAC=true \
      --set installCRDs=false
    ```

    <Accordion title="Using your own service account">
      By default a service account is created for the operator based on the operator release name.
      You can bring your own service account by setting `controllerManager.serviceAccount.create` to `false` and setting `controllerManager.serviceAccount.name` to the name of the service account you want to use in your values.yaml file.

      Example values.yaml file:

      ```yaml values.yaml theme={"dark"}
      controllerManager:
        serviceAccount:
          create: false
          name: my-service-account
      # other values...
      ```

      <Note>
        Please note that if you set `controllerManager.serviceAccount.create` to `false`, the service account needs to already exist in the namespace you are installing the operator in.
      </Note>

      <Tip>
        Custom service accounts are supported in chart version `0.10.11` and above. Please upgrade your helm chart to `0.10.11` or above before attempting to use custom service accounts.
      </Tip>
    </Accordion>

    When scoped to a namespace, the operator will:

    * Only watch InfisicalSecrets in the specified namespace
    * Only create/update Kubernetes secrets in that namespace
    * Only access deployments in that namespace

    The default configuration gives cluster-wide access:

    ```yaml  theme={"dark"}
    installCRDs: true # Install CRDs (set to false for additional namespace installations)
    scopedNamespace: "" # Empty for cluster-wide access
    scopedRBAC: false # Cluster-wide permissions
    ```

    If you want to install operators in multiple namespaces simultaneously:

    * Make sure to set `installCRDs: false` for all but one of the installations to avoid conflicts, as CRDs are cluster-wide resources.
    * Use unique release names for each installation (e.g., operator-namespace1, operator-namespace2).
  </Tab>
</Tabs>

## Custom Resource Definitions

Currently the operator supports the following CRD's. We are constantly expanding the functionality of the operator, and this list will be updated as new CRD's are added.

1. [InfisicalSecret](/integrations/platforms/kubernetes/infisical-secret-crd): Sync secrets from Infisical to a Kubernetes secret.
2. [InfisicalPushSecret](/integrations/platforms/kubernetes/infisical-push-secret-crd): Push secrets from a Kubernetes secret to Infisical.
3. [InfisicalDynamicSecret](/integrations/platforms/kubernetes/infisical-dynamic-secret-crd): Sync dynamic secrets and create leases automatically in Kubernetes.

## General Configuration

### Private/self-signed certificate

To connect to Infisical instances behind a private/self-signed certificate, you can configure the TLS settings in the CRD
to point to a CA certificate stored in a Kubernetes secret resource.

```yaml  theme={"dark"}
---
spec:
  hostAPI: https://app.infisical.com/api
  tls:
    caRef:
      secretName: custom-ca-certificate
      secretNamespace: default
      key: ca.crt
---
```

## Advanced Templating

With the Infisical Secrets Operator, you can use templating to dynamically generate secrets in Kubernetes. The templating is built on top of [Go templates](https://pkg.go.dev/text/template), which is a powerful and flexible template engine built into Go.

Please be aware that trying to reference non-existing keys will result in an error. Additionally, each template field is processed individually, which means one template field cannot reference another template field.

<Note>
  Please note that templating is currently only supported for the `InfisicalPushSecret` and `InfisicalSecret` CRDs.
</Note>

### Available helper functions

The Infisical Secrets Operator exposes a wide range of helper functions to make it easier to work with secrets in Kubernetes.

| Function              | Description                                                                                                                                                                                         | Signature                                                          |
| --------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------ |
| `decodeBase64ToBytes` | Given a base64 encoded string, this function will decode the base64-encoded string.                                                                                                                 | `decodeBase64ToBytes(encodedString string) string`                 |
| `encodeBase64`        | Given a string, this function will encode the string to a base64 encoded string.                                                                                                                    | `encodeBase64(plainString string) string`                          |
| `pkcs12key`           | Extracts all private keys from a PKCS#12 archive and encodes them in PKCS#8 PEM format.                                                                                                             | `pkcs12key(input string) string`                                   |
| `pkcs12keyPass`       | Same as pkcs12key. Uses the provided password to decrypt the PKCS#12 archive.                                                                                                                       | `pkcs12keyPass(pass string, input string) string`                  |
| `pkcs12cert`          | Extracts all certificates from a PKCS#12 archive and orders them if possible. If disjunct or multiple leaf certs are provided they are returned as-is. Sort order: `leaf / intermediate(s) / root`. | `pkcs12cert(input string) string`                                  |
| `pkcs12certPass`      | Same as `pkcs12cert`. Uses the provided password to decrypt the PKCS#12 archive.                                                                                                                    | `pkcs12certPass(pass string, input string) string`                 |
| `pemToPkcs12`         | Takes a PEM encoded certificate and key and creates a base64 encoded PKCS#12 archive.                                                                                                               | `pemToPkcs12(cert string, key string) string`                      |
| `pemToPkcs12Pass`     | Same as `pemToPkcs12`. Uses the provided password to encrypt the PKCS#12 archive.                                                                                                                   | `pemToPkcs12Pass(cert string, key string, pass string) string`     |
| `fullPemToPkcs12`     | Takes a PEM encoded certificates chain and key and creates a base64 encoded PKCS#12 archive.                                                                                                        | `fullPemToPkcs12(cert string, key string) string`                  |
| `fullPemToPkcs12Pass` | Same as `fullPemToPkcs12`. Uses the provided password to encrypt the PKCS#12 archive.                                                                                                               | `fullPemToPkcs12Pass(cert string, key string, pass string) string` |
| `filterPEM`           | Filters PEM blocks with a specific type from a list of PEM blocks..                                                                                                                                 | `filterPEM(pemType string, input string) string`                   |
| `filterCertChain`     | Filters PEM block(s) with a specific certificate type (`leaf`, `intermediate` or `root`) from a certificate chain of PEM blocks (PEM blocks with type `CERTIFICATE`).                               | `filterCertChain(certType string, input string) string`            |
| `jwkPublicKeyPem`     | Takes an json-serialized JWK and returns an PEM block of type `PUBLIC KEY` that contains the public key. [See here](https://golang.org/pkg/crypto/x509/#MarshalPKIXPublicKey) for details.          | `jwkPublicKeyPem(jwkjson string) string`                           |
| `jwkPrivateKeyPem`    | Takes an json-serialized JWK and returns an PEM block of type `PRIVATE KEY` that contains the private key. [See here](https://pkg.go.dev/crypto/x509#MarshalPKCS8PrivateKey) for details.           | `jwkPrivateKeyPem(jwkjson string) string`                          |
| `toYaml`              | Takes an interface, marshals it to yaml. It returns a string, even on marshal error (empty string).                                                                                                 | `toYaml(v any) string`                                             |
| `fromYaml`            | Function converts a YAML document into a `map[string]any`.                                                                                                                                          | `fromYaml(str string) map[string]any`                              |

### Sprig functions

The Infisical Secrets Operator integrates with the [Sprig library](https://github.com/Masterminds/sprig) to provide additional helper functions.

<Note>
  We've removed `expandEnv` and `env` from the supported functions for security reasons.
</Note>

## Global configuration

To configure global settings that will apply to all CRD instances (`InfisicalSecret`, `InfisicalPushSecret`, and `InfisicalDynamicSecret`), you can define these configurations in a Kubernetes ConfigMap.
For example, you can configure all CRD instances to fetch secrets from a single backend API without specifying the `hostAPI` parameter for each instance.

### Available global properties

| Property                  | Description                                                                             | Default value                                                  |
| ------------------------- | --------------------------------------------------------------------------------------- | -------------------------------------------------------------- |
| hostAPI                   | If `hostAPI` in a CRD instance is left empty, this value will be used                   | [https://app.infisical.com/api](https://app.infisical.com/api) |
| tls.caRef.secretName      | If `tls.caRef.secretName` in a CRD instance is left empty, this value will be used      | -                                                              |
| tls.caRef.secretNamespace | If `tls.caRef.secretNamespace` in a CRD instance is left empty, this value will be used | -                                                              |
| tls.caRef.key             | If `tls.caRef.key` in a CRD instance is left empty, this value will be used             | -                                                              |

### Applying global configurations

All global configurations must reside in a Kubernetes ConfigMap named `infisical-config` in the namespace `infisical-operator-system`.
To apply global configuration to the operator, copy the following yaml into `infisical-config.yaml` file.

```yaml infisical-config.yaml theme={"dark"}
apiVersion: v1
kind: Namespace
metadata:
  name: infisical-operator-system
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: infisical-config
  namespace: infisical-operator-system
data:
  hostAPI: https://example.com/api # <-- global hostAPI
  tls.caRef.secretName: custom-ca-certificate # <-- global TLS CA secret name
  tls.caRef.secretNamespace: default # <-- global TLS CA secret namespace
  tls.caRef.key: ca.crt # <-- global TLS CA secret key
```

Then apply this change via kubectl by running the following

```bash  theme={"dark"}
kubectl apply -f infisical-config.yaml
```

## Troubleshoot operator

If the operator is unable to fetch secrets from the API, it will not affect the managed Kubernetes secret.
It will continue attempting to reconnect to the API indefinitely.
The InfisicalSecret resource uses the `status.conditions` field to report its current state and any errors encountered.

```yaml  theme={"dark"}
$ kubectl get infisicalSecrets
NAME                     AGE
infisicalsecret-sample   12s

$ kubectl describe infisicalSecret infisicalsecret-sample
...
Spec:
...
Status:
  Conditions:
    Last Transition Time:  2022-12-18T04:29:09Z
    Message:               Infisical controller has located the Infisical token in provided Kubernetes secret
    Reason:                OK
    Status:                True
    Type:                  secrets.infisical.com/LoadedInfisicalToken
    Last Transition Time:  2022-12-18T04:29:10Z
    Message:               Failed to update secret because: 400 Bad Request
    Reason:                Error
    Status:                False
    Type:                  secrets.infisical.com/ReadyToSyncSecrets
Events:                    <none>
```

## Uninstall Operator

The managed secret created by the operator will not be deleted when the operator is uninstalled.

<Tabs>
  <Tab title="Helm">
    Uninstall Infisical Helm repository

    ```bash  theme={"dark"}
    helm uninstall <release name>
    ```
  </Tab>
</Tabs>


# PM2
Source: https://infisical.com/docs/integrations/platforms/pm2

How to use Infisical to inject environment variables and secrets with PM2 into a Node.js app

Prerequisites:

* Set up and add envars to [Infisical Cloud](https://app.infisical.com)
* [Install the CLI](/cli/overview)

## Initialize Infisical for your Node.js app

```bash  theme={"dark"}
# navigate to the root of your of your project
cd /path/to/project

# then initialize infisical
infisical init
```

## Create a bash or js script

<CodeGroup>
  ```bash infisical-run.sh theme={"dark"}
  infisical run -- npm start
  ```

  ```js infisical-run.js theme={"dark"}
  const spawn = require("child_process").spawn;

  const infisical = spawn("infisical", ["run", "--", "npm", "start"]);

  infisical.stdout.on("data", (data) => console.log(`${data}`));
  infisical.stderr.on("data", (data) => console.error(`${data}`));
  ```
</CodeGroup>

## Start your application as usual but with the script

<CodeGroup>
  ```bash infisical-run.sh theme={"dark"}
  pm2 start infisical-run.sh
  ```

  ```bash infisical-run.js theme={"dark"}
  pm2 start infisical-run.js
  ```
</CodeGroup>


# null
Source: https://infisical.com/docs/integrations/secret-rotations

Browse and search through all available secret rotations for Infisical.

export const RotationsBrowser = () => {
  const [searchTerm, setSearchTerm] = useState('');
  const [selectedCategory, setSelectedCategory] = useState('All');
  const categories = ['All', 'Databases', 'Identity & Auth', 'Cloud Providers'];
  const rotations = [{
    "name": "AWS IAM User",
    "slug": "aws-iam-user",
    "path": "/documentation/platform/secret-rotation/aws-iam-user-secret",
    "description": "Learn how to automatically rotate AWS IAM user access keys.",
    "category": "Cloud Providers"
  }, {
    "name": "Azure Client Secret",
    "slug": "azure-client-secret",
    "path": "/documentation/platform/secret-rotation/azure-client-secret",
    "description": "Learn how to automatically rotate Azure client secrets.",
    "category": "Cloud Providers"
  }, {
    "name": "Auth0 Client Secret",
    "slug": "auth0-client-secret",
    "path": "/documentation/platform/secret-rotation/auth0-client-secret",
    "description": "Learn how to automatically rotate Auth0 client secrets.",
    "category": "Identity & Auth"
  }, {
    "name": "Okta Client Secret",
    "slug": "okta-client-secret",
    "path": "/documentation/platform/secret-rotation/okta-client-secret",
    "description": "Learn how to automatically rotate Okta client secrets.",
    "category": "Identity & Auth"
  }, {
    "name": "LDAP Password",
    "slug": "ldap-password",
    "path": "/documentation/platform/secret-rotation/ldap-password",
    "description": "Learn how to automatically rotate LDAP user passwords.",
    "category": "Identity & Auth"
  }, {
    "name": "MySQL",
    "slug": "mysql-credentials",
    "path": "/documentation/platform/secret-rotation/mysql-credentials",
    "description": "Learn how to automatically rotate MySQL database credentials.",
    "category": "Databases"
  }, {
    "name": "PostgreSQL",
    "slug": "postgres-credentials",
    "path": "/documentation/platform/secret-rotation/postgres-credentials",
    "description": "Learn how to automatically rotate PostgreSQL database credentials.",
    "category": "Databases"
  }, {
    "name": "Redis",
    "slug": "redis-credentials",
    "path": "/documentation/platform/secret-rotation/redis-credentials",
    "description": "Learn how to automatically rotate Redis database credentials.",
    "category": "Databases"
  }, {
    "name": "Microsoft SQL Server",
    "slug": "mssql-credentials",
    "path": "/documentation/platform/secret-rotation/mssql-credentials",
    "description": "Learn how to automatically rotate Microsoft SQL Server credentials.",
    "category": "Databases"
  }, {
    "name": "Oracle Database",
    "slug": "oracledb-credentials",
    "path": "/documentation/platform/secret-rotation/oracledb-credentials",
    "description": "Learn how to automatically rotate Oracle Database credentials.",
    "category": "Databases"
  }].sort(function (a, b) {
    return a.name.toLowerCase().localeCompare(b.name.toLowerCase());
  });
  const filteredRotations = useMemo(() => {
    let filtered = rotations;
    if (selectedCategory !== 'All') {
      filtered = filtered.filter(rotation => rotation.category === selectedCategory);
    }
    if (searchTerm) {
      filtered = filtered.filter(rotation => rotation.name.toLowerCase().includes(searchTerm.toLowerCase()) || rotation.description.toLowerCase().includes(searchTerm.toLowerCase()) || rotation.category.toLowerCase().includes(searchTerm.toLowerCase()));
    }
    return filtered;
  }, [searchTerm, selectedCategory]);
  return <div className="max-w-none">
      {}
      <div className="mb-6">
        <div className="relative w-full">
          <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
            <svg className="h-4 w-4 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
            </svg>
          </div>
          <input type="text" placeholder="Search secret rotations..." className="block w-full pl-9 pr-3 py-2 text-sm border border-gray-300 rounded-lg placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-yellow-500 focus:border-yellow-500 bg-white shadow-sm" value={searchTerm} onChange={e => setSearchTerm(e.target.value)} />
        </div>
      </div>

      {}
      <div className="mb-6">
        <div className="flex flex-wrap gap-2">
          {categories.map(category => <button key={category} onClick={() => setSelectedCategory(category)} className={`px-3 py-1.5 text-sm font-medium rounded-lg transition-colors shadow-sm ${selectedCategory === category ? 'bg-yellow-100 text-yellow-700 border border-yellow-200' : 'bg-white text-gray-700 border border-gray-200 hover:bg-yellow-50 hover:border-yellow-200'}`}>
              {category}
            </button>)}
        </div>
      </div>

      {}
      <div className="mb-4">
        <p className="text-sm text-gray-600">
          {filteredRotations.length} secret rotation{filteredRotations.length !== 1 ? 's' : ''} found
          {selectedCategory !== 'All' && ` in ${selectedCategory}`}
          {searchTerm && ` for "${searchTerm}"`}
        </p>
      </div>

      {}
      {filteredRotations.length > 0 ? <div className="space-y-4">
          {filteredRotations.map((rotation, index) => <a key={rotation.slug} href={rotation.path} className="group block px-4 py-3 border border-gray-200 rounded-xl hover:border-yellow-200 hover:bg-yellow-50/50 hover:shadow-sm transition-all duration-200 bg-white shadow-sm">
              <div className="w-full">
                <div className="flex items-center justify-between mb-0.5">
                  <h3 className="text-base font-medium text-gray-900 leading-none m-0">
                    {rotation.name}
                  </h3>
                  <span className="ml-3 inline-flex items-center px-3 py-1 rounded-full text-xs font-medium bg-yellow-100 text-yellow-700 flex-shrink-0">
                    {rotation.category}
                  </span>
                </div>
                <p className="text-sm text-gray-600 leading-relaxed">
                  {rotation.description}
                </p>
              </div>
            </a>)}
        </div> : <div className="text-center py-8">
          <div className="flex flex-col items-center space-y-2">
            <p className="text-gray-500">No secret rotations found matching your criteria</p>
            {searchTerm && <p className="text-gray-400 text-sm">Try adjusting your search terms or filters</p>}
          </div>
        </div>}
    </div>;
};

<RotationsBrowser />


# null
Source: https://infisical.com/docs/integrations/secret-syncs

Browse and search through all available secret syncs for Infisical.

export const SecretSyncsBrowser = () => {
  const [searchTerm, setSearchTerm] = useState('');
  const [selectedCategory, setSelectedCategory] = useState('All');
  const categories = ['All', 'Cloud Providers', 'Databases', 'CI/CD', 'Monitoring', 'Data Analytics', 'Hosting', 'DevOps Tools', 'Security'];
  const syncs = [{
    "name": "AWS Parameter Store",
    "slug": "aws-parameter-store",
    "path": "/integrations/secret-syncs/aws-parameter-store",
    "description": "Learn how to sync secrets from Infisical to AWS Parameter Store.",
    "category": "Cloud Providers"
  }, {
    "name": "AWS Secrets Manager",
    "slug": "aws-secrets-manager",
    "path": "/integrations/secret-syncs/aws-secrets-manager",
    "description": "Learn how to sync secrets from Infisical to AWS Secrets Manager.",
    "category": "Cloud Providers"
  }, {
    "name": "Azure Key Vault",
    "slug": "azure-key-vault",
    "path": "/integrations/secret-syncs/azure-key-vault",
    "description": "Learn how to sync secrets from Infisical to Azure Key Vault.",
    "category": "Cloud Providers"
  }, {
    "name": "Azure App Configuration",
    "slug": "azure-app-configuration",
    "path": "/integrations/secret-syncs/azure-app-configuration",
    "description": "Learn how to sync secrets from Infisical to Azure App Configuration.",
    "category": "Cloud Providers"
  }, {
    "name": "Azure DevOps",
    "slug": "azure-devops",
    "path": "/integrations/secret-syncs/azure-devops",
    "description": "Learn how to sync secrets from Infisical to Azure DevOps.",
    "category": "CI/CD"
  }, {
    "name": "GCP Secret Manager",
    "slug": "gcp-secret-manager",
    "path": "/integrations/secret-syncs/gcp-secret-manager",
    "description": "Learn how to sync secrets from Infisical to GCP Secret Manager.",
    "category": "Cloud Providers"
  }, {
    "name": "HashiCorp Vault",
    "slug": "hashicorp-vault",
    "path": "/integrations/secret-syncs/hashicorp-vault",
    "description": "Learn how to sync secrets from Infisical to HashiCorp Vault.",
    "category": "Security"
  }, {
    "name": "1Password",
    "slug": "1password",
    "path": "/integrations/secret-syncs/1password",
    "description": "Learn how to sync secrets from Infisical to 1Password.",
    "category": "Security"
  }, {
    "name": "Vercel",
    "slug": "vercel",
    "path": "/integrations/secret-syncs/vercel",
    "description": "Learn how to sync secrets from Infisical to Vercel.",
    "category": "Hosting"
  }, {
    "name": "Netlify",
    "slug": "netlify",
    "path": "/integrations/secret-syncs/netlify",
    "description": "Learn how to sync secrets from Infisical to Netlify.",
    "category": "Hosting"
  }, {
    "name": "Railway",
    "slug": "railway",
    "path": "/integrations/secret-syncs/railway",
    "description": "Learn how to sync secrets from Infisical to Railway.",
    "category": "Hosting"
  }, {
    "name": "Fly.io",
    "slug": "flyio",
    "path": "/integrations/secret-syncs/flyio",
    "description": "Learn how to sync secrets from Infisical to Fly.io.",
    "category": "Hosting"
  }, {
    "name": "Render",
    "slug": "render",
    "path": "/integrations/secret-syncs/render",
    "description": "Learn how to sync secrets from Infisical to Render.",
    "category": "Hosting"
  }, {
    "name": "Heroku",
    "slug": "heroku",
    "path": "/integrations/secret-syncs/heroku",
    "description": "Learn how to sync secrets from Infisical to Heroku.",
    "category": "Hosting"
  }, {
    "name": "DigitalOcean App Platform",
    "slug": "digital-ocean-app-platform",
    "path": "/integrations/secret-syncs/digital-ocean-app-platform",
    "description": "Learn how to sync secrets from Infisical to DigitalOcean App Platform.",
    "category": "Hosting"
  }, {
    "name": "Supabase",
    "slug": "supabase",
    "path": "/integrations/secret-syncs/supabase",
    "description": "Learn how to sync secrets from Infisical to Supabase.",
    "category": "Databases"
  }, {
    "name": "Checkly",
    "slug": "checkly",
    "path": "/integrations/secret-syncs/checkly",
    "description": "Learn how to sync secrets from Infisical to Checkly.",
    "category": "Monitoring"
  }, {
    "name": "GitHub",
    "slug": "github",
    "path": "/integrations/secret-syncs/github",
    "description": "Learn how to sync secrets from Infisical to GitHub.",
    "category": "CI/CD"
  }, {
    "name": "GitLab",
    "slug": "gitlab",
    "path": "/integrations/secret-syncs/gitlab",
    "description": "Learn how to sync secrets from Infisical to GitLab.",
    "category": "CI/CD"
  }, {
    "name": "TeamCity",
    "slug": "teamcity",
    "path": "/integrations/secret-syncs/teamcity",
    "description": "Learn how to sync secrets from Infisical to TeamCity.",
    "category": "CI/CD"
  }, {
    "name": "Bitbucket",
    "slug": "bitbucket",
    "path": "/integrations/secret-syncs/bitbucket",
    "description": "Learn how to sync secrets from Infisical to Bitbucket.",
    "category": "CI/CD"
  }, {
    "name": "Terraform Cloud",
    "slug": "terraform-cloud",
    "path": "/integrations/secret-syncs/terraform-cloud",
    "description": "Learn how to sync secrets from Infisical to Terraform Cloud.",
    "category": "DevOps Tools"
  }, {
    "name": "Cloudflare Pages",
    "slug": "cloudflare-pages",
    "path": "/integrations/secret-syncs/cloudflare-pages",
    "description": "Learn how to sync secrets from Infisical to Cloudflare Pages.",
    "category": "Hosting"
  }, {
    "name": "Cloudflare Workers",
    "slug": "cloudflare-workers",
    "path": "/integrations/secret-syncs/cloudflare-workers",
    "description": "Learn how to sync secrets from Infisical to Cloudflare Workers.",
    "category": "Cloud Providers"
  }, {
    "name": "Databricks",
    "slug": "databricks",
    "path": "/integrations/secret-syncs/databricks",
    "description": "Learn how to sync secrets from Infisical to Databricks.",
    "category": "Data Analytics"
  }, {
    "name": "Windmill",
    "slug": "windmill",
    "path": "/integrations/secret-syncs/windmill",
    "description": "Learn how to sync secrets from Infisical to Windmill.",
    "category": "DevOps Tools"
  }, {
    "name": "Camunda",
    "slug": "camunda",
    "path": "/integrations/secret-syncs/camunda",
    "description": "Learn how to sync secrets from Infisical to Camunda.",
    "category": "DevOps Tools"
  }, {
    "name": "Humanitec",
    "slug": "humanitec",
    "path": "/integrations/secret-syncs/humanitec",
    "description": "Learn how to sync secrets from Infisical to Humanitec.",
    "category": "DevOps Tools"
  }, {
    "name": "OCI Vault",
    "slug": "oci-vault",
    "path": "/integrations/secret-syncs/oci-vault",
    "description": "Learn how to sync secrets from Infisical to OCI Vault.",
    "category": "Cloud Providers"
  }, {
    "name": "Zabbix",
    "slug": "zabbix",
    "path": "/integrations/secret-syncs/zabbix",
    "description": "Learn how to sync secrets from Infisical to Zabbix.",
    "category": "Monitoring"
  }, {
    "name": "Laravel Forge",
    "slug": "laravel-forge",
    "path": "/integrations/secret-syncs/laravel-forge",
    "description": "Learn how to sync secrets from Infisical to Laravel Forge.",
    "category": "Hosting"
  }, {
    "name": "Chef",
    "slug": "chef",
    "path": "/integrations/secret-syncs/chef",
    "description": "Learn how to sync secrets from Infisical to Chef.",
    "category": "DevOps Tools"
  }, {
    "name": "Northflank",
    "slug": "northflank",
    "path": "/integrations/secret-syncs/northflank",
    "description": "Learn how to sync secrets from Infisical to Northflank projects.",
    "category": "Hosting"
  }].sort(function (a, b) {
    return a.name.toLowerCase().localeCompare(b.name.toLowerCase());
  });
  const filteredSyncs = useMemo(() => {
    let filtered = syncs;
    if (selectedCategory !== 'All') {
      filtered = filtered.filter(sync => sync.category === selectedCategory);
    }
    if (searchTerm) {
      filtered = filtered.filter(sync => sync.name.toLowerCase().includes(searchTerm.toLowerCase()) || sync.description.toLowerCase().includes(searchTerm.toLowerCase()) || sync.category.toLowerCase().includes(searchTerm.toLowerCase()));
    }
    return filtered;
  }, [searchTerm, selectedCategory]);
  return <div className="max-w-none">
      {}
      <div className="mb-6">
        <div className="relative w-full">
          <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
            <svg className="h-4 w-4 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
            </svg>
          </div>
          <input type="text" placeholder="Search secret syncs..." className="block w-full pl-9 pr-3 py-2 text-sm border border-gray-300 rounded-lg placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-yellow-500 focus:border-yellow-500 bg-white shadow-sm" value={searchTerm} onChange={e => setSearchTerm(e.target.value)} />
        </div>
      </div>

      {}
      <div className="mb-6">
        <div className="flex flex-wrap gap-2">
          {categories.map(category => <button key={category} onClick={() => setSelectedCategory(category)} className={`px-3 py-1.5 text-sm font-medium rounded-lg transition-colors shadow-sm ${selectedCategory === category ? 'bg-yellow-100 text-yellow-700 border border-yellow-200' : 'bg-white text-gray-700 border border-gray-200 hover:bg-yellow-50 hover:border-yellow-200'}`}>
              {category}
            </button>)}
        </div>
      </div>

      {}
      <div className="mb-4">
        <p className="text-sm text-gray-600">
          {filteredSyncs.length} secret sync{filteredSyncs.length !== 1 ? 's' : ''} found
          {selectedCategory !== 'All' && ` in ${selectedCategory}`}
          {searchTerm && ` for "${searchTerm}"`}
        </p>
      </div>

      {}
      {filteredSyncs.length > 0 ? <div className="space-y-4">
          {filteredSyncs.map((sync, index) => <a key={sync.slug} href={sync.path} className="group block px-4 py-3 border border-gray-200 rounded-xl hover:border-yellow-200 hover:bg-yellow-50/50 hover:shadow-sm transition-all duration-200 bg-white shadow-sm">
              <div className="w-full">
                <div className="flex items-center justify-between mb-0.5">
                  <h3 className="text-base font-medium text-gray-900 leading-none m-0">
                    {sync.name}
                  </h3>
                  <span className="ml-3 inline-flex items-center px-3 py-1 rounded-full text-xs font-medium bg-yellow-100 text-yellow-700 flex-shrink-0">
                    {sync.category}
                  </span>
                </div>
                <p className="text-sm text-gray-600 leading-relaxed">
                  {sync.description}
                </p>
              </div>
            </a>)}
        </div> : <div className="text-center py-8">
          <div className="flex flex-col items-center space-y-2">
            <p className="text-gray-500">No secret syncs found matching your criteria</p>
            {searchTerm && <p className="text-gray-400 text-sm">Try adjusting your search terms or filters</p>}
          </div>
        </div>}
    </div>;
};

<SecretSyncsBrowser />


# 1Password Sync
Source: https://infisical.com/docs/integrations/secret-syncs/1password

Learn how to configure a 1Password Sync for Infisical.

**Prerequisites:**

* Create an [1Password Connection](/integrations/app-connections/1password)

<Tabs>
  <Tab title="Infisical UI">
    <Steps>
      <Step title="Add Sync">
        Navigate to **Project** > **Integrations** and select the **Secret Syncs** tab. Click on the **Add Sync** button.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/general/secret-sync-tab.png" alt="Secret Syncs Tab" />
      </Step>

      <Step title="Select '1Password'">
                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/1password/select-option.png" alt="Select 1Password" />
      </Step>

      <Step title="Configure source">
        Configure the **Source** from where secrets should be retrieved, then click **Next**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/1password/configure-source.png" alt="Configure Source" />

        * **Environment**: The project environment to retrieve secrets from.
        * **Secret Path**: The folder path to retrieve secrets from.

        <Tip>
          If you need to sync secrets from multiple folder locations, check out [secret imports](/documentation/platform/secret-reference#secret-imports).
        </Tip>
      </Step>

      <Step title="Configure destination">
        Configure the **Destination** to where secrets should be deployed, then click **Next**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/1password/configure-destination.png" alt="Configure Destination" />

        * **1Password Connection**: The 1Password Connection to authenticate with.
        * **Vault**: The 1Password vault to sync secrets to.
        * **Value Label**: The label of the 1Password item field that will hold your secret value.
      </Step>

      <Step title="Configure sync options">
        Configure the **Sync Options** to specify how secrets should be synced, then click **Next**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/1password/configure-sync-options.png" alt="Configure Sync Options" />

        * **Initial Sync Behavior**: Determines how Infisical should resolve the initial sync.
          * **Overwrite Destination Secrets**: Removes any secrets at the destination endpoint not present in Infisical.
          * **Import Secrets (Prioritize Infisical)**: Imports secrets from the destination endpoint before syncing, prioritizing values from Infisical over 1Password when keys conflict.
          * **Import Secrets (Prioritize 1Password)**: Imports secrets from the destination endpoint before syncing, prioritizing values from 1Password over Infisical when keys conflict.
        * **Key Schema**: Template that determines how secret names are transformed when syncing, using `{{secretKey}}` as a placeholder for the original secret name and `{{environment}}` for the environment.

        <Note>
          We highly recommend using a Key Schema to ensure that Infisical only manages the specific keys you intend, keeping everything else untouched.
        </Note>

        * **Auto-Sync Enabled**: If enabled, secrets will automatically be synced from the source location when changes occur. Disable to enforce manual syncing only.
        * **Disable Secret Deletion**: If enabled, Infisical will not remove secrets from the sync destination. Enable this option if you intend to manage some secrets manually outside of Infisical.
      </Step>

      <Step title="Configure details">
        Configure the **Details** of your 1Password Sync, then click **Next**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/1password/configure-details.png" alt="Configure Details" />

        * **Name**: The name of your sync. Must be slug-friendly.
        * **Description**: An optional description for your sync.
      </Step>

      <Step title="Review configuration">
        Review your 1Password Sync configuration, then click **Create Sync**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/1password/review-configuration.png" alt="Review Configuration" />
      </Step>

      <Step title="Sync created">
        If enabled, your 1Password Sync will begin syncing your secrets to the destination endpoint.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/1password/sync-created.png" alt="Sync Created" />
      </Step>
    </Steps>
  </Tab>

  <Tab title="API">
    To create an **1Password Sync**, make an API request to the [Create 1Password Sync](/api-reference/endpoints/secret-syncs/1password/create) API endpoint.

    ### Sample request

    ```bash Request theme={"dark"}
    curl    --request POST \
            --url https://app.infisical.com/api/v1/secret-syncs/1password \
            --header 'Content-Type: application/json' \
            --data '{
                "name": "my-1password-sync",
                "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                "description": "an example sync",
                "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                "environment": "dev",
                "secretPath": "/my-secrets",
                "isEnabled": true,
                "syncOptions": {
                    "initialSyncBehavior": "overwrite-destination"
                },
                "destinationConfig": {
                    "vaultId": "...",
                    "valueLabel": "value"
                }
            }'
    ```

    ### Sample response

    ```bash Response theme={"dark"}
    {
        "secretSync": {
            "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "name": "my-1password-sync",
            "description": "an example sync",
            "isEnabled": true,
            "version": 1,
            "folderId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "createdAt": "2023-11-07T05:31:56Z",
            "updatedAt": "2023-11-07T05:31:56Z",
            "syncStatus": "succeeded",
            "lastSyncJobId": "123",
            "lastSyncMessage": null,
            "lastSyncedAt": "2023-11-07T05:31:56Z",
            "importStatus": null,
            "lastImportJobId": null,
            "lastImportMessage": null,
            "lastImportedAt": null,
            "removeStatus": null,
            "lastRemoveJobId": null,
            "lastRemoveMessage": null,
            "lastRemovedAt": null,
            "syncOptions": {
                "initialSyncBehavior": "overwrite-destination"
            },
            "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "connection": {
                "app": "1password",
                "name": "my-1password-connection",
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a"
            },
            "environment": {
                "slug": "dev",
                "name": "Development",
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a"
            },
            "folder": {
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                "path": "/my-secrets"
            },
            "destination": "1password",
            "destinationConfig": {
              "vaultId": "...",
              "valueLabel": "value"
            }
        }
    }
    ```
  </Tab>
</Tabs>

## FAQ

<AccordionGroup>
  <Accordion title="How are different 1Password item types treated?">
    Infisical can only perform CRUD operations on the following item types:

    * API Credentials
  </Accordion>

  <Accordion title="What is a 'Value Label'?">
    It's the label of the 1Password item field which will hold your secret value. For example, if you were to sync Infisical secret 'foo: bar', the 1Password item equivalent would have an item title of 'foo', and a field on that item 'value: bar'. The field label 'value' is what gets changed by this option.
  </Accordion>
</AccordionGroup>


# AWS Parameter Store Sync
Source: https://infisical.com/docs/integrations/secret-syncs/aws-parameter-store

Learn how to configure an AWS Parameter Store Sync for Infisical.

**Prerequisites:**

* Set up and add secrets to [Infisical Cloud](https://app.infisical.com)
* Create an [AWS Connection](/integrations/app-connections/aws) with the required **Secret Sync** permissions
* Ensure your network security policies allow incoming requests from Infisical to this secret sync provider, if network restrictions apply.

<Note>
  For workflows involving large amounts of secrets or frequent syncs, we recommend increasing your [AWS Parameter Store throughput quota](https://docs.aws.amazon.com/systems-manager/latest/userguide/parameter-store-throughput.html) to avoid rate limiting.
</Note>

<Tabs>
  <Tab title="Infisical UI">
    1. Navigate to **Project** > **Integrations** and select the **Secret Syncs** tab. Click on the **Add Sync** button.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/general/secret-sync-tab.png" alt="Secret Syncs Tab" />

    2. Select the **AWS Parameter Store** option.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/aws-parameter-store/select-aws-parameter-store-option.png" alt="Select AWS Parameter Store" />

    3. Configure the **Source** from where secrets should be retrieved, then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/aws-parameter-store/aws-parameter-store-source.png" alt="Configure Source" />

       * **Environment**: The project environment to retrieve secrets from.
       * **Secret Path**: The folder path to retrieve secrets from.

    <Tip>
      If you need to sync secrets from multiple folder locations, check out [secret imports](/documentation/platform/secret-reference#secret-imports).
    </Tip>

    4. Configure the **Destination** to where secrets should be deployed, then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/aws-parameter-store/aws-parameter-store-destination.png" alt="Configure Destination" />

       * **AWS Connection**: The AWS Connection to authenticate with.
       * **Region**: The AWS region to deploy secrets to.
       * **Path**: The AWS Parameter Store path to deploy secrets to.

    5. Configure the **Sync Options** to specify how secrets should be synced, then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/aws-parameter-store/aws-parameter-store-options.png" alt="Configure Options" />

       * **Initial Sync Behavior**: Determines how Infisical should resolve the initial sync.
         * **Overwrite Destination Secrets**: Removes any secrets at the destination endpoint not present in Infisical.
         * **Import Secrets (Prioritize Infisical)**: Imports secrets from the destination endpoint before syncing, prioritizing values from Infisical over Parameter Store when keys conflict.
         * **Import Secrets (Prioritize AWS Parameter Store)**: Imports secrets from the destination endpoint before syncing, prioritizing values from Parameter Store over Infisical when keys conflict.
       * **Key Schema**: Template that determines how secret names are transformed when syncing, using `{{secretKey}}` as a placeholder for the original secret name and `{{environment}}` for the environment.

       <Note>
         We highly recommend using a Key Schema to ensure that Infisical only manages the specific keys you intend, keeping everything else untouched.
       </Note>

       * **KMS Key**: The AWS KMS key ID or alias to encrypt parameters with.
       * **Tags**: Optional resource tags to add to parameters synced by Infisical.
       * **Sync Secret Metadata as Resource Tags**: If enabled, metadata attached to secrets will be added as resource tags to parameters synced by Infisical.

       <Note>
         Manually configured tags from the **Tags** field will take precedence over secret metadata when tag keys conflict.
       </Note>

       * **Auto-Sync Enabled**: If enabled, secrets will automatically be synced from the source location when changes occur. Disable to enforce manual syncing only.
       * **Disable Secret Deletion**: If enabled, Infisical will not remove secrets from the sync destination. Enable this option if you intend to manage some secrets manually outside of Infisical.

    6. Configure the **Details** of your Parameter Store Sync, then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/aws-parameter-store/aws-parameter-store-details.png" alt="Configure Details" />

       * **Name**: The name of your sync. Must be slug-friendly.
       * **Description**: An optional description for your sync.

    7. Review your Parameter Store Sync configuration, then click **Create Sync**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/aws-parameter-store/aws-parameter-store-review.png" alt="Confirm Configuration" />

    8. If enabled, your Parameter Store Sync will begin syncing your secrets to the destination endpoint.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/aws-parameter-store/aws-parameter-store-created.png" alt="Sync Secrets" />
  </Tab>

  <Tab title="API">
    To create an **AWS Parameter Store Sync**, make an API request to the [Create AWS
    Parameter Store Sync](/api-reference/endpoints/secret-syncs/aws-parameter-store/create) API endpoint.

    ### Sample request

    ```bash Request theme={"dark"}
    curl    --request POST \
    --url https://app.infisical.com/api/v1/secret-syncs/aws-parameter-store \
    --header 'Content-Type: application/json' \
    --data '{
        "name": "my-parameter-store-sync",
        "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
        "description": "an example sync",
        "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
        "environment": "dev",
        "secretPath": "/my-secrets",
        "isEnabled": true,
        "syncOptions": {
            "initialSyncBehavior": "overwrite-destination"
        },
        "destinationConfig": {
            "region": "us-east-1",
            "path": "/my-aws/path/"
        }
    }'
    ```

    ### Sample response

    ```bash Response theme={"dark"}
    {
        "secretSync": {
            "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "name": "my-parameter-store-sync",
            "description": "an example sync",
            "isEnabled": true,
            "version": 1,
            "folderId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "createdAt": "2023-11-07T05:31:56Z",
            "updatedAt": "2023-11-07T05:31:56Z",
            "syncStatus": "succeeded",
            "lastSyncJobId": "123",
            "lastSyncMessage": null,
            "lastSyncedAt": "2023-11-07T05:31:56Z",
            "importStatus": null,
            "lastImportJobId": null,
            "lastImportMessage": null,
            "lastImportedAt": null,
            "removeStatus": null,
            "lastRemoveJobId": null,
            "lastRemoveMessage": null,
            "lastRemovedAt": null,
            "syncOptions": {
                "initialSyncBehavior": "overwrite-destination"
            },
            "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "connection": {
                "app": "aws",
                "name": "my-aws-connection",
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a"
            },
            "environment": {
                "slug": "dev",
                "name": "Development",
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a"
            },
            "folder": {
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                "path": "/my-secrets"
            },
            "destination": "aws-parameter-store",
            "destinationConfig": {
                "region": "us-east-1",
                "path": "/my-aws/path/"
            }
        }
    }
    ```
  </Tab>
</Tabs>

## FAQ

<AccordionGroup>
  <Accordion title="What's the relationship between 'path' and 'key schema'?">
    The path is required and will be prepended to the key schema. For example, if you have a path of `/demo/path/` and a key schema of `INFISICAL_{{secretKey}}`, then the result will be `/demo/path/INFISICAL_{{secretKey}}`.
  </Accordion>
</AccordionGroup>


# AWS Secrets Manager Sync
Source: https://infisical.com/docs/integrations/secret-syncs/aws-secrets-manager

Learn how to configure an AWS Secrets Manager Sync for Infisical.

**Prerequisites:**

* Set up and add secrets to [Infisical Cloud](https://app.infisical.com)
* Create an [AWS Connection](/integrations/app-connections/aws) with the required **Secret Sync** permissions
* Ensure your network security policies allow incoming requests from Infisical to this secret sync provider, if network restrictions apply.

<Tabs>
  <Tab title="Infisical UI">
    1. Navigate to **Project** > **Integrations** and select the **Secret Syncs** tab. Click on the **Add Sync** button.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/general/secret-sync-tab.png" alt="Secret Syncs Tab" />

    2. Select the **AWS Secrets Manager** option.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/aws-secrets-manager/select-aws-secrets-manager-option.png" alt="Select AWS Secrets Manager" />

    3. Configure the **Source** from where secrets should be retrieved, then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/aws-secrets-manager/aws-secrets-manager-source.png" alt="Configure Source" />

       * **Environment**: The project environment to retrieve secrets from.
       * **Secret Path**: The folder path to retrieve secrets from.

    <Tip>
      If you need to sync secrets from multiple folder locations, check out [secret imports](/documentation/platform/secret-reference#secret-imports).
    </Tip>

    4. Configure the **Destination** to where secrets should be deployed, then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/aws-secrets-manager/aws-secrets-manager-destination.png" alt="Configure Destination" />

       * **AWS Connection**: The AWS Connection to authenticate with.
       * **Region**: The AWS region to deploy secrets to.
       * **Mapping Behavior**: Specify how Infisical should map secrets to AWS Secrets Manager:
         * **One-To-One**: Each Infisical secret will be mapped to a separate AWS Secrets Manager secret.
         * **Many-To-One**: All Infisical secrets will be mapped to a single AWS Secrets Manager secret.
       * **Secret Name**: Specifies the name of the AWS Secret to map secrets to if **Many-To-One** mapping behavior is selected.

    5. Configure the **Sync Options** to specify how secrets should be synced, then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/aws-secrets-manager/aws-secrets-manager-options.png" alt="Configure Options" />

       * **Initial Sync Behavior**: Determines how Infisical should resolve the initial sync.
         * **Overwrite Destination Secrets**: Removes any secrets at the destination endpoint not present in Infisical.
         * **Import Secrets (Prioritize Infisical)**: Imports secrets from the destination endpoint before syncing, prioritizing values from Infisical over Secrets Manager when keys conflict.
         * **Import Secrets (Prioritize AWS Secrets Manager)**: Imports secrets from the destination endpoint before syncing, prioritizing values from Secrets Manager over Infisical when keys conflict.
       * **Key Schema**: Template that determines how secret names are transformed when syncing, using `{{secretKey}}` as a placeholder for the original secret name and `{{environment}}` for the environment.

       <Note>
         We highly recommend using a Key Schema to ensure that Infisical only manages the specific keys you intend, keeping everything else untouched.
       </Note>

       * **KMS Key**: The AWS KMS key ID or alias to encrypt secrets with.
       * **Tags**: Optional tags to add to secrets synced by Infisical.
       * **Sync Secret Metadata as Tags**: If enabled, metadata attached to secrets will be added as tags to secrets synced by Infisical.

       <Note>
         Manually configured tags from the **Tags** field will take precedence over secret metadata when tag keys conflict.
       </Note>

       * **Auto-Sync Enabled**: If enabled, secrets will automatically be synced from the source location when changes occur. Disable to enforce manual syncing only.
       * **Disable Secret Deletion**: If enabled, Infisical will not remove secrets from the sync destination. Enable this option if you intend to manage some secrets manually outside of Infisical.

    6. Configure the **Details** of your Secrets Manager Sync, then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/aws-secrets-manager/aws-secrets-manager-details.png" alt="Configure Details" />

       * **Name**: The name of your sync. Must be slug-friendly.
       * **Description**: An optional description for your sync.

    7. Review your Secrets Manager Sync configuration, then click **Create Sync**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/aws-secrets-manager/aws-secrets-manager-review.png" alt="Confirm Configuration" />

    8. If enabled, your Secrets Manager Sync will begin syncing your secrets to the destination endpoint.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/aws-secrets-manager/aws-secrets-manager-created.png" alt="Sync Secrets" />
  </Tab>

  <Tab title="API">
    To create an **AWS Secrets Manager Sync**, make an API request to the [Create AWS
    Secrets Manager Sync](/api-reference/endpoints/secret-syncs/aws-secrets-manager/create) API endpoint.

    ### Sample request

    ```bash Request theme={"dark"}
    curl    --request POST \
    --url https://app.infisical.com/api/v1/secret-syncs/aws-secrets-manager \
    --header 'Content-Type: application/json' \
    --data '{
        "name": "my-secrets-manager-sync",
        "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
        "description": "an example sync",
        "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
        "environment": "dev",
        "secretPath": "/my-secrets",
        "isEnabled": true,
        "syncOptions": {
            "initialSyncBehavior": "overwrite-destination"
        },
        "destinationConfig": {
            "region": "us-east-1",
            "mappingBehavior": "one-to-one"
        }
    }'
    ```

    ### Sample response

    ```bash Response theme={"dark"}
    {
        "secretSync": {
            "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "name": "my-secrets-manager-sync",
            "description": "an example sync",
            "isEnabled": true,
            "version": 1,
            "folderId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "createdAt": "2023-11-07T05:31:56Z",
            "updatedAt": "2023-11-07T05:31:56Z",
            "syncStatus": "succeeded",
            "lastSyncJobId": "123",
            "lastSyncMessage": null,
            "lastSyncedAt": "2023-11-07T05:31:56Z",
            "importStatus": null,
            "lastImportJobId": null,
            "lastImportMessage": null,
            "lastImportedAt": null,
            "removeStatus": null,
            "lastRemoveJobId": null,
            "lastRemoveMessage": null,
            "lastRemovedAt": null,
            "syncOptions": {
                "initialSyncBehavior": "overwrite-destination"
            },
            "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "connection": {
                "app": "aws",
                "name": "my-aws-connection",
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a"
            },
            "environment": {
                "slug": "dev",
                "name": "Development",
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a"
            },
            "folder": {
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                "path": "/my-secrets"
            },
            "destination": "aws-secrets-manager",
            "destinationConfig": {
                "region": "us-east-1",
                "mappingBehavior": "one-to-one"
            }
        }
    }
    ```
  </Tab>
</Tabs>


# Azure App Configuration Sync
Source: https://infisical.com/docs/integrations/secret-syncs/azure-app-configuration

Learn how to configure an Azure App Configuration Sync for Infisical.

**Prerequisites:**

* Set up and add secrets to [Infisical Cloud](https://app.infisical.com)
* Create an [Azure App Configuration Connection](/integrations/app-connections/azure-app-configuration)
* Ensure your network security policies allow incoming requests from Infisical to this secret sync provider, if network restrictions apply.

<Note>
  The Azure App Configuration Secret Sync requires the following permissions to be set on the user / service principal
  for Infisical to sync secrets to Azure App Configuration: `Read Key-Value`, `Write Key-Value`, `Delete Key-Value`.

  Any role with these permissions would work such as the **App Configuration Data Owner** role. Alternatively, you can use the **App Configuration Data Contributor** role for read/write access.
</Note>

<Tabs>
  <Tab title="Infisical UI">
    1. Navigate to **Project** > **Integrations** and select the **Secret Syncs** tab. Click on the **Add Sync** button.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/general/secret-sync-tab.png" alt="Secret Syncs Tab" />

    2. Select the **Azure App Configuration** option.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/azure-app-configuration/select-app-config.png" alt="Select Azure App Configuration" />

    3. Configure the **Source** from where secrets should be retrieved, then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/azure-app-configuration/app-config-source.png" alt="Configure Source" />

       * **Environment**: The project environment to retrieve secrets from.
       * **Secret Path**: The folder path to retrieve secrets from.

    <Tip>
      If you need to sync secrets from multiple folder locations, check out [secret imports](/documentation/platform/secret-reference#secret-imports).
    </Tip>

    4. Configure the **Destination** to where secrets should be deployed, then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/azure-app-configuration/app-config-destination.png" alt="Configure Destination" />

       * **Azure Connection**: The Azure Connection to authenticate with.
       * **Configuration URL**: The URL of your Azure App Configuration.
       * **Label**: An optional label to attach to all secrets created by Infisical inside your Azure App Configuration.

    5. Configure the **Sync Options** to specify how secrets should be synced, then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/azure-app-configuration/app-config-options.png" alt="Configure Options" />

       * **Initial Sync Behavior**: Determines how Infisical should resolve the initial sync.
         * **Overwrite Destination Secrets**: Removes any secrets at the destination endpoint not present in Infisical.
         * **Import Secrets (Prioritize Infisical)**: Imports secrets from the destination endpoint before syncing, prioritizing values from Infisical over Secrets Manager when keys conflict.
         * **Import Secrets (Prioritize Azure App Configuration)**: Imports secrets from the destination endpoint before syncing, prioritizing values from Secrets Manager over Infisical when keys conflict.
       * **Key Schema**: Template that determines how secret names are transformed when syncing, using `{{secretKey}}` as a placeholder for the original secret name and `{{environment}}` for the environment.

       <Note>
         We highly recommend using a Key Schema to ensure that Infisical only manages the specific keys you intend, keeping everything else untouched.
       </Note>

       * **Auto-Sync Enabled**: If enabled, secrets will automatically be synced from the source location when changes occur. Disable to enforce manual syncing only.
       * **Disable Secret Deletion**: If enabled, Infisical will not remove secrets from the sync destination. Enable this option if you intend to manage some secrets manually outside of Infisical.

    6. Configure the **Details** of your Azure App Configuration Sync, then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/azure-app-configuration/app-config-details.png" alt="Configure Details" />

       * **Name**: The name of your sync. Must be slug-friendly.
       * **Description**: An optional description for your sync.

    7. Review your Azure App Configuration Sync configuration, then click **Create Sync**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/azure-app-configuration/app-config-review.png" alt="Confirm Configuration" />

    8. If enabled, your Azure App Configuration Sync will begin syncing your secrets to the destination endpoint.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/azure-app-configuration/app-config-synced.png" alt="Sync Secrets" />
  </Tab>

  <Tab title="API">
    To create an **Azure App Configuration Sync**, make an API request to the [Create Azure App Configuration Sync](/api-reference/endpoints/secret-syncs/azure-app-configuration/create) API endpoint.

    ### Sample request

    ```bash Request theme={"dark"}
    curl    --request POST \
    --url https://app.infisical.com/api/v1/secret-syncs/azure-app-configuration \
    --header 'Content-Type: application/json' \
    --data '{
        "name": "my-azure-app-configuration-sync",
        "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
        "description": "an example sync",
        "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
        "environment": "dev",
        "secretPath": "/my-secrets",
        "isEnabled": true,
        "syncOptions": {
            "initialSyncBehavior": "overwrite-destination"
        },
        "destinationConfig": {
          "configurationUrl": "https://my-azure-app-configuration.azconfig.io",
          "label": "my-label"
        }
    }'
    ```

    ### Sample response

    ```json Response theme={"dark"}
    {
        "secretSync": {
            "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "name": "my-azure-app-configuration-sync",
            "description": "an example sync",
            "isEnabled": true,
            "version": 1,
            "folderId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "createdAt": "2023-11-07T05:31:56Z",
            "updatedAt": "2023-11-07T05:31:56Z",
            "syncStatus": "succeeded",
            "lastSyncJobId": "123",
            "lastSyncMessage": null,
            "lastSyncedAt": "2023-11-07T05:31:56Z",
            "importStatus": null,
            "lastImportJobId": null,
            "lastImportMessage": null,
            "lastImportedAt": null,
            "removeStatus": null,
            "lastRemoveJobId": null,
            "lastRemoveMessage": null,
            "lastRemovedAt": null,
            "syncOptions": {
                "initialSyncBehavior": "overwrite-destination"
            },
            "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "connection": {
                "app": "azure",
                "name": "my-azure-connection",
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a"
            },
            "environment": {
                "slug": "dev",
                "name": "Development",
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a"
            },
            "folder": {
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                "path": "/my-secrets"
            },
            "destination": "azure-app-configuration",
            "destinationConfig": {
                "configurationUrl": "https://my-azure-app-configuration.azconfig.io",
                "label": "my-label"
            }
        }
    }
    ```
  </Tab>
</Tabs>


# Azure DevOps Sync
Source: https://infisical.com/docs/integrations/secret-syncs/azure-devops

Learn how to configure a Azure DevOps Sync for Infisical.

**Prerequisites:**

* Set up and add secrets to [Infisical Cloud](https://app.infisical.com)
* Create an [Azure DevOps Connection](/integrations/app-connections/azure-devops)
* Ensure your network security policies allow incoming requests from Infisical to this secret sync provider, if network restrictions apply.

<Tabs>
  <Tab title="Infisical UI">
    1. Navigate to **Project** > **Integrations** and select the **Secret Syncs** tab. Click on the **Add Sync** button.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/general/secret-sync-tab.png" alt="Secret Syncs Tab" />

    2. Select the **Azure DevOps** option.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/azure-devops/select-azure-devops-option.png" alt="Select Azure DevOps" />

    3. Configure the **Source** from where secrets should be retrieved, then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/azure-devops/devops-source.png" alt="Configure Source" />

       * **Environment**: The project environment to retrieve secrets from.
       * **Secret Path**: The folder path to retrieve secrets from.

    <Tip>
      If you need to sync secrets from multiple folder locations, check out [secret imports](/documentation/platform/secret-reference#secret-imports).
    </Tip>

    4. Configure the **Destination** to where secrets should be deployed, then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/azure-devops/devops-destination.png" alt="Configure Destination" />

       * **Azure DevOps Connection**: The Azure DevOps Connection to authenticate with.
       * **Project**: The Azure DevOps project to deploy secrets to.

       <p class="height:1px" />

    5. Configure the **Sync Options** to specify how secrets should be synced, then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/azure-devops/devops-options.png" alt="Configure Options" />

       * **Initial Sync Behavior**: Determines how Infisical should resolve the initial sync.
         * **Overwrite Destination Secrets**: Removes any secrets at the destination endpoint not present in Infisical.
         <Note>
           Azure Devops does not support importing secrets.
         </Note>
       * **Key Schema**: Template that determines how secret names are transformed when syncing, using `{{secretKey}}` as a placeholder for the original secret name.
       * **Auto-Sync Enabled**: If enabled, secrets will automatically be synced from the source location when changes occur. Disable to enforce manual syncing only.
       * **Disable Secret Deletion**: If enabled, Infisical will not remove secrets from the sync destination. Enable this option if you intend to manage some secrets manually outside of Infisical.

    6. Configure the **Details** of your Azure DevOps Sync, then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/azure-devops/devops-details.png" alt="Configure Details" />

       * **Name**: The name of your sync. Must be slug-friendly.
       * **Description**: An optional description for your sync.

    7. Review your Azure DevOps Sync configuration, then click **Create Sync**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/azure-devops/devops-review.png" alt="Confirm Configuration" />

    8. If enabled, your Azure DevOps Sync will begin syncing your secrets to the destination endpoint.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/azure-devops/devops-synced.png" alt="Sync Secrets" />
  </Tab>

  <Tab title="API">
    To create a **Azure DevOps Sync**, make an API request to the [Create Azure DevOps Sync](/api-reference/endpoints/secret-syncs/azure-devops/create) API endpoint.

    ### Sample request

    ```bash Request theme={"dark"}
    curl --request POST \
    --url https://app.infisical.com/api/v1/secret-syncs/azure-devops \
    --header 'Content-Type: application/json' \
    --data '{
        "name": "my-devops-sync",
        "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
        "description": "an example sync",
        "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
        "environment": "dev",
        "secretPath": "/my-secrets",
        "isEnabled": true,
        "syncOptions": {
           "initialSyncBehavior": "overwrite-destination",
           "disableSecretDeletion": true
        },
        "destinationConfig": {
            "devopsProjectId": "12345678-90ab-cdef-1234-567890abcdef",
            "devopsProjectName": "example-project"
        }
    }'
    ```

    ### Sample response

    ```json Response theme={"dark"}
    {
        "secretSync": {
            "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "name": "my-devops-sync",
            "description": "an example sync",
            "isEnabled": true,
            "version": 1,
            "folderId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "createdAt": "2023-11-07T05:31:56Z",
            "updatedAt": "2023-11-07T05:31:56Z",
            "syncStatus": "succeeded",
            "lastSyncJobId": "123",
            "lastSyncMessage": null,
            "lastSyncedAt": "2023-11-07T05:31:56Z",
            "importStatus": null,
            "lastImportJobId": null,
            "lastImportMessage": null,
            "lastImportedAt": null,
            "removeStatus": null,
            "lastRemoveJobId": null,
            "lastRemoveMessage": null,
            "lastRemovedAt": null,
            "syncOptions": {
                "initialSyncBehavior": "overwrite-destination",
                "keySchema": "PIPELINE_${secretKey}",
                "disableSecretDeletion": true
            },
            "connection": {
                "app": "azure-devops",
                "name": "Production DevOps Organization",
                "id": "8b92f5cc-3g77-5e80-6666-6ff57069385d"
            },
            "environment": {
                "slug": "production",
                "name": "Production Environment",
                "id": "4f16j9gg-7k11-9i23-2222-2jj91403729h"
            },
            "folder": {
                "id": "5a71e8dd-2f66-4d70-7777-7cc46958274c",
                "path": "/devops/pipeline-secrets"
            },
            "destination": "azure-devops",
            "destinationConfig": {
                "devopsProjectId": "12345678-90ab-cdef-1234-567890abcdef",
                "devopsProjectName": "example-project"
            }
        }
    }
    ```
  </Tab>
</Tabs>


# Azure Key Vault Sync
Source: https://infisical.com/docs/integrations/secret-syncs/azure-key-vault

Learn how to configure a Azure Key Vault Sync for Infisical.

**Prerequisites:**

* Set up and add secrets to [Infisical Cloud](https://app.infisical.com)
* Create an [Azure Key Vault Connection](/integrations/app-connections/azure-key-vault)
* Ensure your network security policies allow incoming requests from Infisical to this secret sync provider, if network restrictions apply.

<Note>
  The Azure Key Vault Secret Sync requires the following secrets permissions to be set on the user / service principal
  for Infisical to sync secrets to Azure Key Vault: `secrets/list`, `secrets/get`, `secrets/set`, `secrets/recover`.

  Any role with these permissions would work such as the **Key Vault Secrets Officer** role.
</Note>

<Note>
  Secrets in Infisical that contain an underscore (`_`) will be converted to a hyphen (`-`) when synced to Azure Key Vault.
</Note>

<Tabs>
  <Tab title="Infisical UI">
    1. Navigate to **Project** > **Integrations** and select the **Secret Syncs** tab. Click on the **Add Sync** button.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/general/secret-sync-tab.png" alt="Secret Syncs Tab" />

    2. Select the **Azure Key Vault** option.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/azure-key-vault/select-key-vault-option.png" alt="Select Key Vault" />

    3. Configure the **Source** from where secrets should be retrieved, then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/azure-key-vault/vault-source.png" alt="Configure Source" />

       * **Environment**: The project environment to retrieve secrets from.
       * **Secret Path**: The folder path to retrieve secrets from.

    <Tip>
      If you need to sync secrets from multiple folder locations, check out [secret imports](/documentation/platform/secret-reference#secret-imports).
    </Tip>

    4. Configure the **Destination** to where secrets should be deployed, then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/azure-key-vault/vault-destination.png" alt="Configure Destination" />

       * **Azure Connection**: The Azure Connection to authenticate with.
       * **Vault Base URL**: The URL of your Azure Key Vault.

       <p class="height:1px" />

    5. Configure the **Sync Options** to specify how secrets should be synced, then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/azure-key-vault/vault-options.png" alt="Configure Options" />

       * **Initial Sync Behavior**: Determines how Infisical should resolve the initial sync.
         * **Overwrite Destination Secrets**: Removes any secrets at the destination endpoint not present in Infisical.
         * **Import Secrets (Prioritize Infisical)**: Imports secrets from the destination endpoint before syncing, prioritizing values from Infisical over Secrets Manager when keys conflict.
         * **Import Secrets (Prioritize Azure Key Vault)**: Imports secrets from the destination endpoint before syncing, prioritizing values from Secrets Manager over Infisical when keys conflict.
       * **Key Schema**: Template that determines how secret names are transformed when syncing, using `{{secretKey}}` as a placeholder for the original secret name and `{{environment}}` for the environment.

       <Note>
         We highly recommend using a Key Schema to ensure that Infisical only manages the specific keys you intend, keeping everything else untouched.
       </Note>

       * **Auto-Sync Enabled**: If enabled, secrets will automatically be synced from the source location when changes occur. Disable to enforce manual syncing only.
       * **Disable Secret Deletion**: If enabled, Infisical will not remove secrets from the sync destination. Enable this option if you intend to manage some secrets manually outside of Infisical.

    6. Configure the **Details** of your Azure Key Vault Sync, then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/azure-key-vault/vault-details.png" alt="Configure Details" />

       * **Name**: The name of your sync. Must be slug-friendly.
       * **Description**: An optional description for your sync.

    7. Review your Azure Key Vault Sync configuration, then click **Create Sync**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/azure-key-vault/vault-review.png" alt="Confirm Configuration" />

    8. If enabled, your Azure Key Vault Sync will begin syncing your secrets to the destination endpoint.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/azure-key-vault/vault-synced.png" alt="Sync Secrets" />
  </Tab>

  <Tab title="API">
    To create a **Azure Key Vault Sync**, make an API request to the [Create Key Vault Sync](/api-reference/endpoints/secret-syncs/azure-key-vault/create) API endpoint.

    ### Sample request

    ```bash Request theme={"dark"}
    curl --request POST \
    --url https://app.infisical.com/api/v1/secret-syncs/azure-key-vault \
    --header 'Content-Type: application/json' \
    --data '{
        "name": "my-key-vault-sync",
        "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
        "description": "an example sync",
        "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
        "environment": "dev",
        "secretPath": "/my-secrets",
        "isEnabled": true,
        "syncOptions": {
            "initialSyncBehavior": "overwrite-destination"
        },
        "destinationConfig": {
            "vaultBaseUrl": "https://my-key-vault.vault.azure.net"
        }
    }'
    ```

    ### Sample response

    ```json Response theme={"dark"}
    {
        "secretSync": {
            "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "name": "my-key-vault-sync",
            "description": "an example sync",
            "isEnabled": true,
            "version": 1,
            "folderId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "createdAt": "2023-11-07T05:31:56Z",
            "updatedAt": "2023-11-07T05:31:56Z",
            "syncStatus": "succeeded",
            "lastSyncJobId": "123",
            "lastSyncMessage": null,
            "lastSyncedAt": "2023-11-07T05:31:56Z",
            "importStatus": null,
            "lastImportJobId": null,
            "lastImportMessage": null,
            "lastImportedAt": null,
            "removeStatus": null,
            "lastRemoveJobId": null,
            "lastRemoveMessage": null,
            "lastRemovedAt": null,
            "syncOptions": {
                "initialSyncBehavior": "overwrite-destination"
            },
            "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "connection": {
                "app": "azure",
                "name": "my-azure-key-vault-connection",
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a"
            },
            "environment": {
                "slug": "dev",
                "name": "Development",
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a"
            },
            "folder": {
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                "path": "/my-secrets"
            },
            "destination": "azure-key-vault",
            "destinationConfig": {
              "vaultBaseUrl": "https://my-key-vault.vault.azure.net"
            }
        }
    }
    ```
  </Tab>
</Tabs>


# Bitbucket Sync
Source: https://infisical.com/docs/integrations/secret-syncs/bitbucket

Learn how to configure a Bitbucket Sync for Infisical.

**Prerequisites:**

* Create a [Bitbucket Connection](/integrations/app-connections/bitbucket)

<Tabs>
  <Tab title="Infisical UI">
    <Steps>
      <Step title="Add Sync">
        Navigate to **Project** > **Integrations** and select the **Secret Syncs** tab. Click on the **Add Sync** button.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/general/secret-sync-tab.png" alt="Secret Syncs Tab" />
      </Step>

      <Step title="Select 'Bitbucket'">
                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/bitbucket/select-option.png" alt="Select Bitbucket" />
      </Step>

      <Step title="Configure source">
        Configure the **Source** from where secrets should be retrieved, then click **Next**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/bitbucket/configure-source.png" alt="Configure Source" />

        * **Environment**: The project environment to retrieve secrets from.
        * **Secret Path**: The folder path to retrieve secrets from.

        <Tip>
          If you need to sync secrets from multiple folder locations, check out [secret imports](/documentation/platform/secret-reference#secret-imports).
        </Tip>
      </Step>

      <Step title="Configure destination">
        Configure the **Destination** to where secrets should be deployed, then click **Next**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/bitbucket/configure-destination.png" alt="Configure Destination" />

        * **Bitbucket Connection**: The Bitbucket Connection to authenticate with.
        * **Workspace**: The Bitbucket workspace to sync secrets to.
        * **Repository**: The Bitbucket repository to sync secrets to.
        * **Deployment Environment (Optional)**: The Bitbucket deployment environment to sync secrets to.
      </Step>

      <Step title="Configure sync options">
        Configure the **Sync Options** to specify how secrets should be synced, then click **Next**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/bitbucket/configure-sync-options.png" alt="Configure Sync Options" />

        * **Initial Sync Behavior**: Determines how Infisical should resolve the initial sync.
          * **Overwrite Destination Secrets**: Removes any secrets at the destination endpoint not present in Infisical.
          <Note>
            Bitbucket does not support importing secrets.
          </Note>
        * **Key Schema**: Template that determines how secret names are transformed when syncing, using `{{secretKey}}` as a placeholder for the original secret name and `{{environment}}` for the environment.

        <Note>
          We highly recommend using a Key Schema to ensure that Infisical only manages the specific keys you intend, keeping everything else untouched.
        </Note>

        * **Auto-Sync Enabled**: If enabled, secrets will automatically be synced from the source location when changes occur. Disable to enforce manual syncing only.
        * **Disable Secret Deletion**: If enabled, Infisical will not remove secrets from the sync destination. Enable this option if you intend to manage some secrets manually outside of Infisical.
      </Step>

      <Step title="Configure details">
        Configure the **Details** of your Bitbucket Sync, then click **Next**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/bitbucket/configure-details.png" alt="Configure Details" />

        * **Name**: The name of your sync. Must be slug-friendly.
        * **Description**: An optional description for your sync.
      </Step>

      <Step title="Review configuration">
        Review your Bitbucket Sync configuration, then click **Create Sync**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/bitbucket/review-configuration.png" alt="Review Configuration" />
      </Step>

      <Step title="Sync created">
        If enabled, your Bitbucket Sync will begin syncing your secrets to the destination endpoint.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/bitbucket/sync-created.png" alt="Sync Created" />
      </Step>
    </Steps>
  </Tab>

  <Tab title="API">
    To create a **Bitbucket Sync**, make an API request to the [Create Bitbucket Sync](/api-reference/endpoints/secret-syncs/bitbucket/create) API endpoint.

    ### Sample request

    ```bash Request theme={"dark"}
    curl    --request POST \
            --url https://app.infisical.com/api/v1/secret-syncs/bitbucket \
            --header 'Content-Type: application/json' \
            --data '{
                "name": "my-bitbucket-sync",
                "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                "description": "an example sync",
                "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                "environment": "dev",
                "secretPath": "/my-secrets",
                "isEnabled": true,
                "syncOptions": {
                    "initialSyncBehavior": "overwrite-destination"
                },
                "destinationConfig": {
                    "workspaceSlug": "my-bitbucket-workspace",
                    "repositorySlug": "my-bitbucket-repository"
                }
            }'
    ```

    ### Sample response

    ```bash Response theme={"dark"}
    {
        "secretSync": {
            "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "name": "my-bitbucket-sync",
            "description": "an example sync",
            "isEnabled": true,
            "version": 1,
            "folderId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "createdAt": "2023-11-07T05:31:56Z",
            "updatedAt": "2023-11-07T05:31:56Z",
            "syncStatus": "succeeded",
            "lastSyncJobId": "123",
            "lastSyncMessage": null,
            "lastSyncedAt": "2023-11-07T05:31:56Z",
            "importStatus": null,
            "lastImportJobId": null,
            "lastImportMessage": null,
            "lastImportedAt": null,
            "removeStatus": null,
            "lastRemoveJobId": null,
            "lastRemoveMessage": null,
            "lastRemovedAt": null,
            "syncOptions": {
                "initialSyncBehavior": "overwrite-destination"
            },
            "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "connection": {
                "app": "bitbucket",
                "name": "my-bitbucket-connection",
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a"
            },
            "environment": {
                "slug": "dev",
                "name": "Development",
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a"
            },
            "folder": {
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                "path": "/my-secrets"
            },
            "destination": "bitbucket",
            "destinationConfig": {
              "workspaceSlug": "my-bitbucket-workspace",
              "repositorySlug": "my-bitbucket-repository"
            }
        }
    }
    ```
  </Tab>
</Tabs>


# Camunda Sync
Source: https://infisical.com/docs/integrations/secret-syncs/camunda

Learn how to configure a Camunda Sync for Infisical.

**Prerequisites:**

* Set up and add secrets to [Infisical Cloud](https://app.infisical.com)
* Create a [Camunda Connection](/integrations/app-connections/camunda)

<Tabs>
  <Tab title="Infisical UI">
    1. Navigate to **Project** > **Integrations** and select the **Secret Syncs** tab. Click on the **Add Sync** button.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/general/secret-sync-tab.png" alt="Secret Syncs Tab" />

    2. Select the **Camunda** option.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/camunda/select-camunda-option.png" alt="Select Camunda" />

    3. Configure the **Source** from where secrets should be retrieved, then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/camunda/camunda-source.png" alt="Configure Source" />

       * **Environment**: The project environment to retrieve secrets from.
       * **Secret Path**: The folder path to retrieve secrets from.

    <Tip>
      If you need to sync secrets from multiple folder locations, check out [secret imports](/documentation/platform/secret-reference#secret-imports).
    </Tip>

    4. Configure the **Destination** to where secrets should be deployed, then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/camunda/camunda-destination.png" alt="Configure Destination" />

       * **Camunda Connection**: The Camunda Connection to authenticate with.
       * **Cluster**: The Camunda cluster to sync connector secrets to.

    5. Configure the **Sync Options** to specify how secrets should be synced, then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/camunda/camunda-options.png" alt="Configure Options" />

       * **Initial Sync Behavior**: Determines how Infisical should resolve the initial sync.
         * **Overwrite Destination Secrets**: Removes any secrets at the destination endpoint not present in Infisical.
         * **Import Secrets (Prioritize Infisical)**: Imports secrets from the destination endpoint before syncing, prioritizing values from Infisical over Camunda when keys conflict.
         * **Import Secrets (Prioritize Camunda)**: Imports secrets from the destination endpoint before syncing, prioritizing values from Camunda over Infisical when keys conflict.
       * **Key Schema**: Template that determines how secret names are transformed when syncing, using `{{secretKey}}` as a placeholder for the original secret name and `{{environment}}` for the environment.

       <Note>
         We highly recommend using a Key Schema to ensure that Infisical only manages the specific keys you intend, keeping everything else untouched.
       </Note>

       * **Auto-Sync Enabled**: If enabled, secrets will automatically be synced from the source location when changes occur. Disable to enforce manual syncing only.
       * **Disable Secret Deletion**: If enabled, Infisical will not remove secrets from the sync destination. Enable this option if you intend to manage some secrets manually outside of Infisical.

    6. Configure the **Details** of your Camunda Sync, then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/camunda/camunda-details.png" alt="Configure Details" />

       * **Name**: The name of your sync. Must be slug-friendly.
       * **Description**: An optional description for your sync.

    7. Review your Camunda Sync configuration, then click **Create Sync**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/camunda/camunda-review.png" alt="Confirm Configuration" />

    8. If enabled, your Camunda Sync will begin syncing your secrets to the destination endpoint.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/camunda/camunda-created.png" alt="Sync Secrets" />
  </Tab>

  <Tab title="API">
    To create an **Camunda Sync**, make an API request to the [Create Camunda Sync](/api-reference/endpoints/secret-syncs/camunda/create) API endpoint.

    ### Sample request

    ```bash Request theme={"dark"}
    curl    --request POST \
    --url https://app.infisical.com/api/v1/secret-syncs/camunda \
    --header 'Content-Type: application/json' \
    --data '{
        "name": "my-camunda-sync",
        "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
        "description": "an example sync",
        "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
        "environment": "dev",
        "secretPath": "/my-secrets",
        "isEnabled": true,
        "syncOptions": {
            "initialSyncBehavior": "overwrite-destination"
        },
        "destinationConfig": {
            "scope": "cluster",
            "clusterUUID": "cc4c8dae-dce9-4f4c-9882-132b2bd65fa5"
        }
    }'
    ```

    ### Sample response

    ```bash Response theme={"dark"}
    {
        "secretSync": {
            "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "name": "my-camunda-sync",
            "description": "an example sync",
            "isEnabled": true,
            "version": 1,
            "folderId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "createdAt": "2023-11-07T05:31:56Z",
            "updatedAt": "2023-11-07T05:31:56Z",
            "syncStatus": "succeeded",
            "lastSyncJobId": "123",
            "lastSyncMessage": null,
            "lastSyncedAt": "2023-11-07T05:31:56Z",
            "importStatus": null,
            "lastImportJobId": null,
            "lastImportMessage": null,
            "lastImportedAt": null,
            "removeStatus": null,
            "lastRemoveJobId": null,
            "lastRemoveMessage": null,
            "lastRemovedAt": null,
            "syncOptions": {
                "initialSyncBehavior": "overwrite-destination"
            },
            "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "connection": {
                "app": "camunda",
                "name": "my-camunda-connection",
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a"
            },
            "environment": {
                "slug": "dev",
                "name": "Development",
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a"
            },
            "folder": {
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                "path": "/my-secrets"
            },
            "destination": "camunda",
            "destinationConfig": {
                "scope": "cluster",
                "clusterUUID": "cc4c8dae-dce9-4f4c-9882-132b2bd65fa5"
            }
        }
    }
    ```
  </Tab>
</Tabs>


# Checkly Sync
Source: https://infisical.com/docs/integrations/secret-syncs/checkly

Learn how to configure a Checkly Sync for Infisical.

**Prerequisites:**

* Create a [Checkly Connection](/integrations/app-connections/checkly)

<Tabs>
  <Tab title="Infisical UI">
    <Steps>
      <Step title="Add Sync">
        Navigate to **Project** > **Integrations** and select the **Secret Syncs** tab. Click on the **Add Sync** button.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/general/secret-sync-tab.png" alt="Secret Syncs Tab" />
      </Step>

      <Step title="Select 'Checkly'">
                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/checkly/select-option.png" alt="Select Checkly" />
      </Step>

      <Step title="Configure source">
        Configure the **Source** from where secrets should be retrieved, then click **Next**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/checkly/checkly-sync-source.png" alt="Configure Source" />

        * **Environment**: The project environment to retrieve secrets from.
        * **Secret Path**: The folder path to retrieve secrets from.

        <Tip>
          If you need to sync secrets from multiple folder locations, check out [secret imports](/documentation/platform/secret-reference#secret-imports).
        </Tip>
      </Step>

      <Step title="Configure destination">
        Configure the **Destination** to where secrets should be deployed, then click **Next**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/checkly/checkly-sync-destination.png" alt="Configure Destination" />

        * **Checkly Connection**: The Checkly Connection to authenticate with.
        * **Account**: The Checkly account to sync secrets to.
        * **Group**: The Checkly check group to sync secrets to (Optional).
      </Step>

      <Step title="Configure Sync Options">
        Configure the **Sync Options** to specify how secrets should be synced, then click **Next**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/checkly/checkly-sync-options.png" alt="Configure Options" />

        * **Initial Sync Behavior**: Determines how Infisical should resolve the initial sync.
          * **Overwrite Destination Secrets**: Removes any secrets at the destination endpoint not present in Infisical.
          <Note>
            Checkly does not support importing secrets.
          </Note>
        * **Key Schema**: Template that determines how secret names are transformed when syncing, using `{{secretKey}}` as a placeholder for the original secret name and `{{environment}}` for the environment.

        <Note>
          We highly recommend using a Key Schema to ensure that Infisical only manages the specific keys you intend, keeping everything else untouched.
        </Note>

        * **Auto-Sync Enabled**: If enabled, secrets will automatically be synced from the source location when changes occur. Disable to enforce manual syncing only.
        * **Disable Secret Deletion**: If enabled, Infisical will not remove secrets from the sync destination. Enable this option if you intend to manage some secrets manually outside of Infisical.
      </Step>

      <Step title="Configure details">
        Configure the **Details** of your Checkly Sync, then click **Next**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/checkly/checkly-sync-details.png" alt="Configure Details" />

        * **Name**: The name of your sync. Must be slug-friendly.
        * **Description**: An optional description for your sync.
      </Step>

      <Step title="Review configuration">
        Review your Checkly Sync configuration, then click **Create Sync**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/checkly/checkly-sync-review.png" alt="Review Configuration" />
      </Step>

      <Step title="Sync created">
        If enabled, your Checkly Sync will begin syncing your secrets to the destination endpoint.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/checkly/checkly-sync-created.png" alt="Sync Created" />
      </Step>
    </Steps>
  </Tab>

  <Tab title="API">
    To create a **Checkly Sync**, make an API request to the [Create Checkly Sync](/api-reference/endpoints/secret-syncs/checkly/create) API endpoint.

    ### Sample request

    ```bash Request theme={"dark"}
    curl    --request POST \
            --url https://app.infisical.com/api/v1/secret-syncs/checkly \
            --header 'Content-Type: application/json' \
            --data '{
                "name": "my-checkly-sync",
                "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                "description": "an example sync",
                "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                "environment": "dev",
                "secretPath": "/my-secrets",
                "isEnabled": true,
                "syncOptions": {
                    "initialSyncBehavior": "overwrite-destination",
                    "autoSyncEnabled": true,
                    "disableSecretDeletion": false
                },
                "destinationConfig": {
                    "accountId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                    "accountName": "Example Company"
                }
            }'
    ```

    ### Sample response

    ```bash Response theme={"dark"}
    {
        "secretSync": {
            "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "name": "my-checkly-sync",
            "description": "an example sync",
            "isEnabled": true,
            "version": 1,
            "folderId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "createdAt": "2023-11-07T05:31:56Z",
            "updatedAt": "2023-11-07T05:31:56Z",
            "syncStatus": "succeeded",
            "lastSyncJobId": "123",
            "lastSyncMessage": null,
            "lastSyncedAt": "2023-11-07T05:31:56Z",
            "importStatus": null,
            "lastImportJobId": null,
            "lastImportMessage": null,
            "lastImportedAt": null,
            "removeStatus": null,
            "lastRemoveJobId": null,
            "lastRemoveMessage": null,
            "lastRemovedAt": null,
            "syncOptions": {
                "initialSyncBehavior": "overwrite-destination",
                "autoSyncEnabled": true,
                "disableSecretDeletion": false
            },
            "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "connection": {
                "app": "checkly",
                "name": "my-checkly-connection",
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a"
            },
            "environment": {
                "slug": "dev",
                "name": "Development",
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a"
            },
            "folder": {
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                "path": "/my-secrets"
            },
            "destination": "checkly",
            "destinationConfig": {
                "accountId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                "accountName": "Example Company",
            }
        }
    }
    ```
  </Tab>
</Tabs>


# Chef Sync
Source: https://infisical.com/docs/integrations/secret-syncs/chef

Learn how to configure a Chef Sync for Infisical.

<Info>
  Chef Sync is a paid feature.

  If you're using Infisical Cloud, then it is available under the **Enterprise Tier**. If you're self-hosting Infisical,
  then you should contact [team@infisical.com](mailto:team@infisical.com) to purchase an enterprise license to use it.
</Info>

**Prerequisites:**

* Create a [Chef Connection](/integrations/app-connections/chef)

<Tabs>
  <Tab title="Infisical UI">
    <Steps>
      <Step title="Add Sync">
        Navigate to **Project** > **Integrations** and select the **Secret Syncs** tab. Click on the **Add Sync** button.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/general/secret-sync-tab.png" alt="Secret Syncs Tab" />
      </Step>

      <Step title="Select 'Chef'">
                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/chef/select-option.png" alt="Select Chef" />
      </Step>

      <Step title="Configure source">
        Configure the **Source** from where secrets should be retrieved, then click **Next**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/chef/sync-source.png" alt="Configure Source" />

        * **Environment**: The project environment to retrieve secrets from.
        * **Secret Path**: The folder path to retrieve secrets from.

        <Tip>
          If you need to sync secrets from multiple folder locations, check out [secret imports](/documentation/platform/secret-reference#secret-imports).
        </Tip>
      </Step>

      <Step title="Configure destination">
        Configure the **Destination** to where secrets should be deployed, then click **Next**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/chef/sync-destination.png" alt="Configure Destination" />

        * **Chef Connection**: The Chef Connection to authenticate with.
        * **Data Bag**: The Data Bag to sync secrets to.
        * **Data Bag Item**: The Data Bag Item to sync secrets to.
      </Step>

      <Step title="Configure Sync Options">
        Configure the **Sync Options** to specify how secrets should be synced, then click **Next**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/chef/sync-options.png" alt="Configure Options" />

        * **Initial Sync Behavior**: Determines how Infisical should resolve the initial sync.
          * **Overwrite Destination Secrets**: Removes any secrets at the destination endpoint not present in Infisical.
          * **Import Secrets (Prioritize Infisical)**: Imports secrets from the destination endpoint before syncing, prioritizing values from Infisical over Chef when keys conflict.
          * **Import Secrets (Prioritize Chef)**: Imports secrets from the destination endpoint before syncing, prioritizing values from Chef over Infisical when keys conflict.
        * **Key Schema**: Template that determines how secret names are transformed when syncing, using `{{secretKey}}` as a placeholder for the original secret name and `{{environment}}` for the environment.

        <Note>
          We highly recommend using a Key Schema to ensure that Infisical only manages the specific keys you intend, keeping everything else untouched.
        </Note>

        * **Auto-Sync Enabled**: If enabled, secrets will automatically be synced from the source location when changes occur. Disable to enforce manual syncing only.
        * **Disable Secret Deletion**: If enabled, Infisical will not remove secrets from the sync destination. Enable this option if you intend to manage some secrets manually outside of Infisical.
      </Step>

      <Step title="Configure details">
        Configure the **Details** of your Chef Sync, then click **Next**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/chef/sync-details.png" alt="Configure Details" />

        * **Name**: The name of your sync. Must be slug-friendly.
        * **Description**: An optional description for your sync.
      </Step>

      <Step title="Review configuration">
        Review your Chef Sync configuration, then click **Create Sync**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/chef/sync-review.png" alt="Review Configuration" />
      </Step>

      <Step title="Sync created">
        If enabled, your Chef Sync will begin syncing your secrets to the destination endpoint.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/chef/sync-created.png" alt="Sync Created" />
      </Step>
    </Steps>
  </Tab>

  <Tab title="API">
    To create a **Chef Sync**, make an API request to the [Create Chef Sync](/api-reference/endpoints/secret-syncs/chef/create) API endpoint.

    ### Sample request

    ```bash Request theme={"dark"}
    curl    --request POST \
            --url https://app.infisical.com/api/v1/secret-syncs/chef \
            --header 'Content-Type: application/json' \
            --data '{
                "name": "my-chef-sync",
                "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                "description": "sync to chef site",
                "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                "environment": "dev",
                "secretPath": "/",
                "isEnabled": true,
                "isAutoSyncEnabled": true,
                "syncOptions": {
                    "initialSyncBehavior": "overwrite-destination",
                    "disableSecretDeletion": false
                },
                "destinationConfig": {
                    "dataBagName": "my-data-bag",
                    "dataBagItemName": "my-data-bag-item"
                }
            }'
    ```

    ### Sample response

    ```bash Response theme={"dark"}
    {
        "secretSync": {
            "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "name": "my-chef-sync",
            "description": "sync to chef site",
            "folderId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "createdAt": "2025-07-19T12:00:00Z",
            "updatedAt": "2025-07-19T12:00:00Z",
            "syncStatus": "succeeded",
            "lastSyncJobId": "job-1234",
            "lastSyncMessage": null,
            "lastSyncedAt": "2025-07-19T12:00:00Z",
            "syncOptions": {
                "initialSyncBehavior": "overwrite-destination",
                "disableSecretDeletion": false
            },
            "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "connection": {
                "app": "chef",
                "name": "my-chef-connection",
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a"
            },
            "environment": {
                "slug": "dev",
                "name": "Development",
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a"
            },
            "folder": {
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                "path": "/"
            },
            "destination": "chef",
            "destinationConfig": {
                "dataBagName": "my-data-bag",
                "dataBagItemName": "my-data-bag-item"
            }
        }
    }
    ```
  </Tab>
</Tabs>


# Cloudflare Pages Sync
Source: https://infisical.com/docs/integrations/secret-syncs/cloudflare-pages

Learn how to configure a Cloudflare Pages Sync for Infisical.

**Prerequisites:**

* Set up and add secrets to [Infisical Cloud](https://app.infisical.com)
* Create a [Cloudflare Connection](/integrations/app-connections/cloudflare)

<Tabs>
  <Tab title="Infisical UI">
    1. Navigate to **Project** > **Integrations** and select the **Secret Syncs** tab. Click on the **Add Sync** button.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/general/secret-sync-tab.png" alt="Secret Syncs Tab" />

    2. Select the **Cloudflare Pages** option.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/cloudflare-pages/select-cloudflare-pages-option.png" alt="Select Cloudflare Pages" />

    3. Configure the **Source** from where secrets should be retrieved, then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/cloudflare-pages/cloudflare-pages-sync-source.png" alt="Configure Source" />

    * **Environment**: The project environment to retrieve secrets from.
    * **Secret Path**: The folder path to retrieve secrets from.

    <Tip>
      If you need to sync secrets from multiple folder locations, check out [secret imports](/documentation/platform/secret-reference#secret-imports).
    </Tip>

    4. Configure the **Destination** to where secrets should be deployed, then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/cloudflare-pages/cloudflare-pages-sync-destination.png" alt="Configure Destination" />

    * **Cloudflare Connection**: The Cloudflare Connection to authenticate with.
    * **Cloudflare Pages Project**: Choose the Cloudflare Pages project you want to sync secrets to.
    * **Environment**: Select the deployment environment (preview or production).

    5. Configure the **Sync Options** to specify how secrets should be synced, then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/cloudflare-pages/cloudflare-pages-sync-options.png" alt="Configure Options" />

    * **Initial Sync Behavior**: Determines how Infisical should resolve the initial sync.
      * **Overwrite Destination Secrets**: Removes any secrets at the destination endpoint not present in Infisical.
    * **Key Schema**: Template that determines how secret names are transformed when syncing, using `{{secretKey}}` as a placeholder for the original secret name and `{{environment}}` for the environment.
    * **Auto-Sync Enabled**: If enabled, secrets will automatically be synced from the source location when changes occur. Disable to enforce manual syncing only.
    * **Disable Secret Deletion**: If enabled, Infisical will not remove secrets from the sync destination. Enable this option if you intend to manage some secrets manually outside of Infisical.

    6. Configure the **Details** of your Cloudflare Pages Sync, then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/cloudflare-pages/cloudflare-pages-sync-details.png" alt="Configure Details" />

    * **Name**: The name of your sync. Must be slug-friendly.
    * **Description**: An optional description for your sync.

    7. Review your Cloudflare Pages Sync configuration, then click **Create Sync**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/cloudflare-pages/cloudflare-pages-sync-review.png" alt="Confirm Configuration" />

    8. If enabled, your Cloudflare Pages Sync will begin syncing your secrets to the destination endpoint.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/cloudflare-pages/cloudflare-pages-sync-created.png" alt="Sync Secrets" />
  </Tab>

  <Tab title="API">
    To create a **Cloudflare Pages Sync**, make an API request to the [Create Cloudflare Pages Sync](/api-reference/endpoints/secret-syncs/cloudflare-pages/create) API endpoint.

    ### Sample request

    ```bash Request theme={"dark"}
    curl --request POST \
      --url https://app.infisical.com/api/v1/secret-syncs/cloudflare-pages \
      --header 'Content-Type: application/json' \
      --data '{
        "name": "my-cloudflare-pages-sync",
        "projectId": "your-project-id",
        "description": "an example sync",
        "connectionId": "your-cloudflare-connection-id",
        "environment": "production",
        "secretPath": "/my-secrets",
        "isEnabled": true,
        "syncOptions": {
          "initialSyncBehavior": "overwrite-destination"
        },
        "destinationConfig": {
          "projectId": "your-cloudflare-pages-project-id",
          "projectName": "my-pages-project",
          "environment": "production"
        }
      }'
    ```

    ### Sample response

    ```bash Response theme={"dark"}
    {
      "secretSync": {
        "id": "your-sync-id",
        "name": "my-cloudflare-pages-sync",
        "description": "an example sync",
        "isEnabled": true,
        "version": 1,
        "folderId": "your-folder-id",
        "connectionId": "your-cloudflare-connection-id",
        "createdAt": "2024-05-01T12:00:00Z",
        "updatedAt": "2024-05-01T12:00:00Z",
        "syncStatus": "succeeded",
        "lastSyncJobId": "123",
        "lastSyncMessage": null,
        "lastSyncedAt": "2024-05-01T12:00:00Z",
        "syncOptions": {
          "initialSyncBehavior": "overwrite-destination"
        },
        "projectId": "your-project-id",
        "connection": {
          "app": "cloudflare",
          "name": "my-cloudflare-connection",
          "id": "your-cloudflare-connection-id"
        },
        "environment": {
          "slug": "production",
          "name": "Production",
          "id": "your-env-id"
        },
        "folder": {
          "id": "your-folder-id",
          "path": "/my-secrets"
        },
        "destination": "cloudflare-pages",
        "destinationConfig": {
          "projectId": "your-cloudflare-pages-project-id",
          "projectName": "my-pages-project",
          "environment": "production"
        }
      }
    }
    ```
  </Tab>
</Tabs>


# Cloudflare Workers Sync
Source: https://infisical.com/docs/integrations/secret-syncs/cloudflare-workers

Learn how to configure a Cloudflare Workers Sync for Infisical.

**Prerequisites:**

* Set up and add secrets to [Infisical Cloud](https://app.infisical.com)
* Create a [Cloudflare Connection](/integrations/app-connections/cloudflare)

<Tabs>
  <Tab title="Infisical UI">
    1. Navigate to **Project** > **Integrations** and select the **Secret Syncs** tab. Click on the **Add Sync** button.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/general/secret-sync-tab.png" alt="Secret Syncs Tab" />

    2. Select the **Cloudflare Workers** option.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/cloudflare-workers/select-cloudflare-workers-option.png" alt="Select Cloudflare Workers" />

    3. Configure the **Source** from where secrets should be retrieved, then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/cloudflare-workers/cloudflare-workers-sync-source.png" alt="Configure Source" />

    * **Environment**: The project environment to retrieve secrets from.
    * **Secret Path**: The folder path to retrieve secrets from.

    <Tip>
      If you need to sync secrets from multiple folder locations, check out [secret imports](/documentation/platform/secret-reference#secret-imports).
    </Tip>

    4. Configure the **Destination** to where secrets should be deployed, then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/cloudflare-workers/cloudflare-workers-sync-destination.png" alt="Configure Destination" />

    * **Cloudflare Connection**: The Cloudflare Connection to authenticate with.
    * **Cloudflare Workers Script**: Choose the Cloudflare Workers script you want to sync secrets to.

    5. Configure the **Sync Options** to specify how secrets should be synced, then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/cloudflare-workers/cloudflare-workers-sync-options.png" alt="Configure Options" />

    * **Initial Sync Behavior**: Determines how Infisical should resolve the initial sync.
      * **Overwrite Destination Secrets**: Removes any secrets at the destination endpoint not present in Infisical.
    * **Key Schema**: Template that determines how secret names are transformed when syncing, using `{{secretKey}}` as a placeholder for the original secret name and `{{environment}}` for the environment.
    * **Auto-Sync Enabled**: If enabled, secrets will automatically be synced from the source location when changes occur. Disable to enforce manual syncing only.
    * **Disable Secret Deletion**: If enabled, Infisical will not remove secrets from the sync destination. Enable this option if you intend to manage some secrets manually outside of Infisical.

    6. Configure the **Details** of your Cloudflare Workers Sync, then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/cloudflare-workers/cloudflare-workers-sync-details.png" alt="Configure Details" />

    * **Name**: The name of your sync. Must be slug-friendly.
    * **Description**: An optional description for your sync.

    7. Review your Cloudflare Workers Sync configuration, then click **Create Sync**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/cloudflare-workers/cloudflare-workers-sync-review.png" alt="Confirm Configuration" />

    8. If enabled, your Cloudflare Workers Sync will begin syncing your secrets to the destination endpoint.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/cloudflare-workers/cloudflare-workers-sync-created.png" alt="Sync Secrets" />
  </Tab>

  <Tab title="API">
    To create a **Cloudflare Workers Sync**, make an API request to the [Create Cloudflare Workers Sync](/api-reference/endpoints/secret-syncs/cloudflare-workers/create) API endpoint.

    ### Sample request

    ```bash Request theme={"dark"}
    curl --request POST \
      --url https://app.infisical.com/api/v1/secret-syncs/cloudflare-workers \
      --header 'Content-Type: application/json' \
      --data '{
        "name": "my-cloudflare-workers-sync",
        "projectId": "your-project-id",
        "description": "an example sync",
        "connectionId": "your-cloudflare-connection-id",
        "environment": "production",
        "secretPath": "/my-secrets",
        "isEnabled": true,
        "syncOptions": {
          "initialSyncBehavior": "overwrite-destination"
        },
        "destinationConfig": {
          "scriptId": "my-workers-script"
        }
      }'
    ```

    ### Sample response

    ```bash Response theme={"dark"}
    {
      "secretSync": {
        "id": "your-sync-id",
        "name": "my-cloudflare-workers-sync",
        "description": "an example sync",
        "isEnabled": true,
        "version": 1,
        "folderId": "your-folder-id",
        "connectionId": "your-cloudflare-connection-id",
        "createdAt": "2024-05-01T12:00:00Z",
        "updatedAt": "2024-05-01T12:00:00Z",
        "syncStatus": "succeeded",
        "lastSyncJobId": "123",
        "lastSyncMessage": null,
        "lastSyncedAt": "2024-05-01T12:00:00Z",
        "syncOptions": {
          "initialSyncBehavior": "overwrite-destination"
        },
        "projectId": "your-project-id",
        "connection": {
          "app": "cloudflare",
          "name": "my-cloudflare-connection",
          "id": "your-cloudflare-connection-id"
        },
        "environment": {
          "slug": "production",
          "name": "Production",
          "id": "your-env-id"
        },
        "folder": {
          "id": "your-folder-id",
          "path": "/my-secrets"
        },
        "destination": "cloudflare-workers",
        "destinationConfig": {
          "scriptId": "my-workers-script"
        }
      }
    }
    ```
  </Tab>
</Tabs>


# Databricks Sync
Source: https://infisical.com/docs/integrations/secret-syncs/databricks

Learn how to configure a Databricks Sync for Infisical.

**Prerequisites:**

* Set up and add secrets to [Infisical Cloud](https://app.infisical.com)
* Create a [Databricks Connection](/integrations/app-connections/databricks)

<Tabs>
  <Tab title="Infisical UI">
    1. Navigate to **Project** > **Integrations** and select the **Secret Syncs** tab. Click on the **Add Sync** button.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/general/secret-sync-tab.png" alt="Secret Syncs Tab" />

    2. Select the **Databricks** option.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/databricks/select-databricks-option.png" alt="Select Databricks" />

    3. Configure the **Source** from where secrets should be retrieved, then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/databricks/databricks-source.png" alt="Configure Source" />

       * **Environment**: The project environment to retrieve secrets from.
       * **Secret Path**: The folder path to retrieve secrets from.

    <Tip>
      If you need to sync secrets from multiple folder locations, check out [secret imports](/documentation/platform/secret-reference#secret-imports).
    </Tip>

    4. Configure the **Destination** to where secrets should be deployed, then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/databricks/databricks-destination.png" alt="Configure Destination" />

       * **Databricks Connection**: The Databricks Connection to authenticate with.
       * **Scope**: The Databricks secret scope to sync secrets to.

       <Note>
         You must create a secret scope in your Databricks workspace prior to configuration. Ensure your service principal has [Write permissions](https://docs.databricks.com/en/security/auth/access-control/index.html#secret-acls) for the specified secret scope.

         Infisical recommends creating a designated Databricks secret scope for your sync to prevent removal of secrets not managed by Infisical.
       </Note>

    5. Configure the **Sync Options** to specify how secrets should be synced, then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/databricks/databricks-options.png" alt="Configure Options" />

       * **Initial Sync Behavior**: Determines how Infisical should resolve the initial sync.
         * **Overwrite Destination Secrets**: Removes any secrets at the destination endpoint not present in Infisical.
         <Note>
           Databricks does not support importing secrets.
         </Note>
       * **Key Schema**: Template that determines how secret names are transformed when syncing, using `{{secretKey}}` as a placeholder for the original secret name and `{{environment}}` for the environment.

       <Note>
         We highly recommend using a Key Schema to ensure that Infisical only manages the specific keys you intend, keeping everything else untouched.
       </Note>

       * **Auto-Sync Enabled**: If enabled, secrets will automatically be synced from the source location when changes occur. Disable to enforce manual syncing only.
       * **Disable Secret Deletion**: If enabled, Infisical will not remove secrets from the sync destination. Enable this option if you intend to manage some secrets manually outside of Infisical.

    6. Configure the **Details** of your Databricks Sync, then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/databricks/databricks-details.png" alt="Configure Details" />

       * **Name**: The name of your sync. Must be slug-friendly.
       * **Description**: An optional description for your sync.

    7. Review your Databricks Sync configuration, then click **Create Sync**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/databricks/databricks-review.png" alt="Confirm Configuration" />

    8. If enabled, your Databricks Sync will begin syncing your secrets to the destination endpoint.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/databricks/databricks-created.png" alt="Sync Secrets" />
  </Tab>

  <Tab title="API">
    To create an **Databricks Sync**, make an API request to the [Create Databricks Sync](/api-reference/endpoints/secret-syncs/databricks/create) API endpoint.

    ### Sample request

    ```bash Request theme={"dark"}
    curl    --request POST \
    --url https://app.infisical.com/api/v1/secret-syncs/databricks \
    --header 'Content-Type: application/json' \
    --data '{
        "name": "my-databricks-sync",
        "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
        "description": "an example sync",
        "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
        "environment": "dev",
        "secretPath": "/my-secrets",
        "isEnabled": true,
        "syncOptions": {
            "initialSyncBehavior": "overwrite-destination"
        },
        "destinationConfig": {
            "scope": "my-scope"
        }
    }'
    ```

    ### Sample response

    ```bash Response theme={"dark"}
    {
        "secretSync": {
            "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "name": "my-databricks-sync",
            "description": "an example sync",
            "isEnabled": true,
            "version": 1,
            "folderId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "createdAt": "2023-11-07T05:31:56Z",
            "updatedAt": "2023-11-07T05:31:56Z",
            "syncStatus": "succeeded",
            "lastSyncJobId": "123",
            "lastSyncMessage": null,
            "lastSyncedAt": "2023-11-07T05:31:56Z",
            "importStatus": null,
            "lastImportJobId": null,
            "lastImportMessage": null,
            "lastImportedAt": null,
            "removeStatus": null,
            "lastRemoveJobId": null,
            "lastRemoveMessage": null,
            "lastRemovedAt": null,
            "syncOptions": {
                "initialSyncBehavior": "overwrite-destination"
            },
            "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "connection": {
                "app": "databricks",
                "name": "my-databricks-connection",
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a"
            },
            "environment": {
                "slug": "dev",
                "name": "Development",
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a"
            },
            "folder": {
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                "path": "/my-secrets"
            },
            "destination": "databricks",
            "destinationConfig": {
                "scope": "my-scope"
            }
        }
    }
    ```
  </Tab>
</Tabs>


# DigitalOcean App Platform Sync
Source: https://infisical.com/docs/integrations/secret-syncs/digital-ocean-app-platform

Learn how to configure a DigitalOcean App Platform Sync for Infisical.

**Prerequisites:**

* Create a [DigitalOcean Connection](/integrations/app-connections/digital-ocean)

<Tabs>
  <Tab title="Infisical UI">
    <Steps>
      <Step title="Add Sync">
        Navigate to **Project** > **Integrations** and select the **Secret Syncs** tab. Click on the **Add Sync** button.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/general/secret-sync-tab.png" alt="Secret Syncs Tab" />
      </Step>

      <Step title="Select 'DigitalOcean App Platform'">
                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/digital-ocean-app-platform/select-option.png" alt="Select DigitalOcean" />
      </Step>

      <Step title="Configure source">
        Configure the **Source** from where secrets should be retrieved, then click **Next**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/digital-ocean-app-platform/sync-source.png" alt="Configure Source" />

        * **Environment**: The project environment to retrieve secrets from.
        * **Secret Path**: The folder path to retrieve secrets from.

        <Tip>
          If you need to sync secrets from multiple folder locations, check out [secret imports](/documentation/platform/secret-reference#secret-imports).
        </Tip>
      </Step>

      <Step title="Configure destination">
        Configure the **Destination** to where secrets should be deployed, then click **Next**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/digital-ocean-app-platform/sync-destination.png" alt="Configure Destination" />

        * **DigitalOcean Connection**: The DigitalOcean Connection to authenticate with.
        * **App**: The App Platform app to sync secrets to.
      </Step>

      <Step title="Configure Sync Options">
        Configure the **Sync Options** to specify how secrets should be synced, then click **Next**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/digital-ocean-app-platform/sync-options.png" alt="Configure Options" />

        * **Initial Sync Behavior**: Determines how Infisical should resolve the initial sync.
          * **Overwrite Destination Secrets**: Removes any secrets at the destination endpoint not present in Infisical.

        <Note>
          Digital Ocean App Platform does not support importing secrets.
        </Note>

        * **Key Schema**: Template that determines how secret names are transformed when syncing, using `{{secretKey}}` as a placeholder for the original secret name and `{{environment}}` for the environment.

        <Note>
          We highly recommend using a Key Schema to ensure that Infisical only manages the specific keys you intend, keeping everything else untouched.
        </Note>

        * **Auto-Sync Enabled**: If enabled, secrets will automatically be synced from the source location when changes occur. Disable to enforce manual syncing only.
        * **Disable Secret Deletion**: If enabled, Infisical will not remove secrets from the sync destination. Enable this option if you intend to manage some secrets manually outside of Infisical.
      </Step>

      <Step title="Configure details">
        Configure the **Details** of your DigitalOcean Sync, then click **Next**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/digital-ocean-app-platform/sync-details.png" alt="Configure Details" />

        * **Name**: The name of your sync. Must be slug-friendly.
        * **Description**: An optional description for your sync.
      </Step>

      <Step title="Review configuration">
        Review your DigitalOcean Sync configuration, then click **Create Sync**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/digital-ocean-app-platform/sync-review.png" alt="Review Configuration" />
      </Step>

      <Step title="Sync created">
        If enabled, your DigitalOcean Sync will begin syncing your secrets to the destination endpoint.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/digital-ocean-app-platform/sync-created.png" alt="Sync Created" />
      </Step>
    </Steps>
  </Tab>

  <Tab title="API">
    To create a **DigitalOcean App Platform Sync**, make an API request to the [Create DigitalOcean Sync](/api-reference/endpoints/secret-syncs/digital-ocean-app-platform/create) API endpoint.

    ### Sample request

    ```bash Request theme={"dark"}
    curl    --request POST \
            --url https://app.infisical.com/api/v1/secret-syncs/digital-ocean-app-platform \
            --header 'Content-Type: application/json' \
            --data '{
                "name": "my-digitalocean-sync",
                "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                "description": "sync to do app",
                "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                "environment": "dev",
                "secretPath": "/app-secrets",
                "isEnabled": true,
                "syncOptions": {
                    "initialSyncBehavior": "overwrite-destination",
                    "autoSyncEnabled": true,
                    "disableSecretDeletion": false
                },
                "destinationConfig": {
                    "appId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                    "appName": "do-todo-app"
                }
            }'
    ```

    ### Sample response

    ```bash Response theme={"dark"}
    {
        "secretSync": {
            "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "name": "my-digitalocean-sync",
            "description": "sync to do app",
            "isEnabled": true,
            "version": 1,
            "folderId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "createdAt": "2025-07-19T12:00:00Z",
            "updatedAt": "2025-07-19T12:00:00Z",
            "syncStatus": "succeeded",
            "lastSyncJobId": "job-5678",
            "lastSyncMessage": null,
            "lastSyncedAt": "2025-07-19T12:00:00Z",
            "syncOptions": {
                "initialSyncBehavior": "overwrite-destination",
                "autoSyncEnabled": true,
                "disableSecretDeletion": false
            },
            "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "connection": {
                "app": "digital-ocean",
                "name": "my-digitalocean-connection",
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a"
            },
            "environment": {
                "slug": "dev",
                "name": "Development",
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a"
            },
            "folder": {
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                "path": "/app-secrets"
            },
            "destination": "digital-ocean",
            "destinationConfig": {
                "appId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                "appName": "do-todo-app"
            }
        }
    }
    ```
  </Tab>
</Tabs>


# Fly.io Sync
Source: https://infisical.com/docs/integrations/secret-syncs/flyio

Learn how to configure a Fly.io Sync for Infisical.

**Prerequisites:**

* Create a [Fly.io Connection](/integrations/app-connections/flyio)

<Tabs>
  <Tab title="Infisical UI">
    <Steps>
      <Step title="Add Sync">
        Navigate to **Project** > **Integrations** and select the **Secret Syncs** tab. Click on the **Add Sync** button.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/general/secret-sync-tab.png" alt="Secret Syncs Tab" />
      </Step>

      <Step title="Select 'Fly.io'">
                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/flyio/select-option.png" alt="Select Fly.io" />
      </Step>

      <Step title="Configure source">
        Configure the **Source** from where secrets should be retrieved, then click **Next**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/flyio/configure-source.png" alt="Configure Source" />

        * **Environment**: The project environment to retrieve secrets from.
        * **Secret Path**: The folder path to retrieve secrets from.

        <Tip>
          If you need to sync secrets from multiple folder locations, check out [secret imports](/documentation/platform/secret-reference#secret-imports).
        </Tip>
      </Step>

      <Step title="Configure destination">
        Configure the **Destination** to where secrets should be deployed, then click **Next**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/flyio/configure-destination.png" alt="Configure Destination" />

        * **Fly.io Connection**: The Fly.io Connection to authenticate with.
        * **App**: The Fly.io app to sync secrets to.
      </Step>

      <Step title="Configure sync options">
        Configure the **Sync Options** to specify how secrets should be synced, then click **Next**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/flyio/configure-sync-options.png" alt="Configure Sync Options" />

        * **Initial Sync Behavior**: Determines how Infisical should resolve the initial sync.
          * **Overwrite Destination Secrets**: Removes any secrets at the destination endpoint not present in Infisical.
          <Note>
            Fly.io does not support importing secrets.
          </Note>
        * **Key Schema**: Template that determines how secret names are transformed when syncing, using `{{secretKey}}` as a placeholder for the original secret name and `{{environment}}` for the environment.

        <Note>
          We highly recommend using a Key Schema to ensure that Infisical only manages the specific keys you intend, keeping everything else untouched.
        </Note>

        * **Auto-Sync Enabled**: If enabled, secrets will automatically be synced from the source location when changes occur. Disable to enforce manual syncing only.
        * **Disable Secret Deletion**: If enabled, Infisical will not remove secrets from the sync destination. Enable this option if you intend to manage some secrets manually outside of Infisical.
      </Step>

      <Step title="Configure details">
        Configure the **Details** of your Fly.io Sync, then click **Next**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/flyio/configure-details.png" alt="Configure Details" />

        * **Name**: The name of your sync. Must be slug-friendly.
        * **Description**: An optional description for your sync.
      </Step>

      <Step title="Review configuration">
        Review your Fly.io Sync configuration, then click **Create Sync**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/flyio/review-configuration.png" alt="Review Configuration" />
      </Step>

      <Step title="Sync created">
        If enabled, your Fly.io Sync will begin syncing your secrets to the destination endpoint.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/flyio/sync-created.png" alt="Sync Created" />
      </Step>
    </Steps>
  </Tab>

  <Tab title="API">
    To create a **Fly.io Sync**, make an API request to the [Create Fly.io Sync](/api-reference/endpoints/secret-syncs/flyio/create) API endpoint.

    ### Sample request

    ```bash Request theme={"dark"}
    curl    --request POST \
            --url https://app.infisical.com/api/v1/secret-syncs/flyio \
            --header 'Content-Type: application/json' \
            --data '{
                "name": "my-flyio-sync",
                "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                "description": "an example sync",
                "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                "environment": "dev",
                "secretPath": "/my-secrets",
                "isEnabled": true,
                "syncOptions": {
                    "initialSyncBehavior": "overwrite-destination"
                },
                "destinationConfig": {
                    "appId": "..."
                }
            }'
    ```

    ### Sample response

    ```bash Response theme={"dark"}
    {
        "secretSync": {
            "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "name": "my-flyio-sync",
            "description": "an example sync",
            "isEnabled": true,
            "version": 1,
            "folderId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "createdAt": "2023-11-07T05:31:56Z",
            "updatedAt": "2023-11-07T05:31:56Z",
            "syncStatus": "succeeded",
            "lastSyncJobId": "123",
            "lastSyncMessage": null,
            "lastSyncedAt": "2023-11-07T05:31:56Z",
            "importStatus": null,
            "lastImportJobId": null,
            "lastImportMessage": null,
            "lastImportedAt": null,
            "removeStatus": null,
            "lastRemoveJobId": null,
            "lastRemoveMessage": null,
            "lastRemovedAt": null,
            "syncOptions": {
                "initialSyncBehavior": "overwrite-destination"
            },
            "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "connection": {
                "app": "flyio",
                "name": "my-flyio-connection",
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a"
            },
            "environment": {
                "slug": "dev",
                "name": "Development",
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a"
            },
            "folder": {
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                "path": "/my-secrets"
            },
            "destination": "flyio",
            "destinationConfig": {
              "appId": "..."
            }
        }
    }
    ```
  </Tab>
</Tabs>


# GCP Secret Manager Sync
Source: https://infisical.com/docs/integrations/secret-syncs/gcp-secret-manager

Learn how to configure a GCP Secret Manager Sync for Infisical.

**Prerequisites:**

* Set up and add secrets to [Infisical Cloud](https://app.infisical.com)
* Create a [GCP Connection](/integrations/app-connections/gcp) with the required **Secret Sync** permissions
* Enable **Cloud Resource Manager API**, **Secret Manager API**, and **Service Usage API** on your GCP project
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/gcp-secret-manager/enable-resource-manager-api.png" alt="Secret Syncs Tab" />
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/gcp-secret-manager/enable-secret-manager-api.png" alt="Secret Syncs Tab" />
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/gcp-secret-manager/enable-service-usage-api.png" alt="Secret Syncs Tab" />
* Ensure your network security policies allow incoming requests from Infisical to this secret sync provider, if network restrictions apply.

<Tabs>
  <Tab title="Infisical UI">
    1. Navigate to **Project** > **Integrations** and select the **Secret Syncs** tab. Click on the **Add Sync** button.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/general/secret-sync-tab.png" alt="Secret Syncs Tab" />

    2. Select the **GCP Secret Manager** option.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/gcp-secret-manager/select-gcp-secret-manager-option.png" alt="Select GCP Secret Manager" />

    3. Configure the **Source** from where secrets should be retrieved, then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/gcp-secret-manager/gcp-secret-manager-source.png" alt="Configure Source" />

       * **Environment**: The project environment to retrieve secrets from.
       * **Secret Path**: The folder path to retrieve secrets from.

    <Tip>
      If you need to sync secrets from multiple folder locations, check out [secret imports](/documentation/platform/secret-reference#secret-imports).
    </Tip>

    4. Configure the **Destination** to where secrets should be deployed, then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/gcp-secret-manager/gcp-secret-manager-destination.png" alt="Configure Destination" />

       * **GCP Connection**: The GCP Connection to authenticate with.
       * **Project**: The GCP project to sync with.
       * **Scope**: The GCP project scope that secrets should be synced to:
         * **Global**: Secrets will be synced globally; available to all project regions.
         * **Region**: Secrets will be synced to the specified region.

    5. Configure the **Sync Options** to specify how secrets should be synced, then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/gcp-secret-manager/gcp-secret-manager-options.png" alt="Configure Options" />

       * **Initial Sync Behavior**: Determines how Infisical should resolve the initial sync.
         * **Overwrite Destination Secrets**: Removes any secrets at the destination endpoint not present in Infisical.
         * **Import Secrets (Prioritize Infisical)**: Imports secrets from the destination endpoint before syncing, prioritizing values from Infisical over GCP Secret Manager when keys conflict.
         * **Import Secrets (Prioritize GCP Secret Manager)**: Imports secrets from the destination endpoint before syncing, prioritizing values from GCP Secret Manager over Infisical when keys conflict.
       * **Key Schema**: Template that determines how secret names are transformed when syncing, using `{{secretKey}}` as a placeholder for the original secret name and `{{environment}}` for the environment.

       <Note>
         We highly recommend using a Key Schema to ensure that Infisical only manages the specific keys you intend, keeping everything else untouched.
       </Note>

       * **Auto-Sync Enabled**: If enabled, secrets will automatically be synced from the source location when changes occur. Disable to enforce manual syncing only.
       * **Disable Secret Deletion**: If enabled, Infisical will not remove secrets from the sync destination. Enable this option if you intend to manage some secrets manually outside of Infisical.

    6. Configure the **Details** of your GCP Secret Manager Sync, then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/gcp-secret-manager/gcp-secret-manager-details.png" alt="Configure Details" />

       * **Name**: The name of your sync. Must be slug-friendly.
       * **Description**: An optional description for your sync.

    7. Review your Secret Manager Sync configuration, then click **Create Sync**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/gcp-secret-manager/gcp-secret-manager-review.png" alt="Confirm Configuration" />

    8. If enabled, your GCP Secret Manager Sync will begin syncing your secrets to the destination endpoint.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/gcp-secret-manager/gcp-secret-manager-created.png" alt="Sync Secrets" />
  </Tab>

  <Tab title="API">
    To create a **GCP Secret Manager Sync**, make an API request to the [Create GCP
    Secret Manager Sync](/api-reference/endpoints/secret-syncs/gcp-secret-manager/create) API endpoint.

    ### Sample request

    ```bash Request theme={"dark"}
    curl    --request POST \
    --url https://app.infisical.com/api/v1/secret-syncs/gcp-secret-manager \
    --header 'Content-Type: application/json' \
    --data '{
        "destinationConfig": {
            "scope": "global",
            "projectId": "infisical-test-playground"
        },
        "name": "my-gcp-sync",
        "description": "this is an example secret sync",
        "secretPath": "/",
        "syncOptions": {
            "initialSyncBehavior": "overwrite-destination"
        },
        "isAutoSyncEnabled": true,
        "connectionId": "eec83609-5eb4-4d8d-9f6e-ded016984f0d",
        "environment": "dev",
        "projectId": "09eda1f8-85a3-47a9-8a6f-e27f133b2a36"
    }'
    ```

    ### Sample response

    ```bash Response theme={"dark"}
    {
        "secretSync": {
            "id": "aee02c4a-4a5f-488c-82dd-0b3164772871",
            "name": "my-gcp-sync",
            "description": "this is an example secret sync",
            "isAutoSyncEnabled": true,
            "version": 1,
            "projectId": "09eda1f8-85a3-47a9-8a6f-e27f133b2a36",
            "folderId": "1447389e-16fb-49ba-96fd-361b5a2522af",
            "connectionId": "eec83609-5eb4-4d8d-9f6e-ded016984f0d",
            "createdAt": "2025-01-27T12:28:59.408Z",
            "updatedAt": "2025-01-27T12:28:59.408Z",
            "syncStatus": "pending",
            "lastSyncJobId": null,
            "lastSyncMessage": null,
            "lastSyncedAt": null,
            "importStatus": null,
            "lastImportJobId": null,
            "lastImportMessage": null,
            "lastImportedAt": null,
            "removeStatus": null,
            "lastRemoveJobId": null,
            "lastRemoveMessage": null,
            "lastRemovedAt": null,
            "syncOptions": {
                "initialSyncBehavior": "overwrite-destination"
            },
            "connection": {
                "app": "gcp",
                "name": "my-gcp-connection",
                "id": "eec83609-5eb4-4d8d-9f6e-ded016984f0d"
            },
            "environment": {
                "slug": "dev",
                "name": "Development",
                "id": "124e0392-4070-4b1c-900e-ced30cd55bf3"
            },
            "folder": {
                "id": "1447389e-16fb-49ba-96fd-361b5a2522af",
                "path": "/"
            },
            "destination": "gcp-secret-manager",
            "destinationConfig": {
                "projectId": "infisical-test-playground"
            }
        }
    }
    ```
  </Tab>
</Tabs>


# GitHub Sync
Source: https://infisical.com/docs/integrations/secret-syncs/github

Learn how to configure a GitHub Sync for Infisical.

**Prerequisites:**

* Set up and add secrets to [Infisical Cloud](https://app.infisical.com)
* Create a [GitHub Connection](/integrations/app-connections/github)
* Ensure your network security policies allow incoming requests from Infisical to this secret sync provider, if network restrictions apply.

<Tabs>
  <Tab title="Infisical UI">
    1. Navigate to **Project** > **Integrations** and select the **Secret Syncs** tab. Click on the **Add Sync** button.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/general/secret-sync-tab.png" alt="Secret Syncs Tab" />

    2. Select the **GitHub** option.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/github/select-github-option.png" alt="Select GitHub" />

    3. Configure the **Source** from where secrets should be retrieved, then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/github/github-source.png" alt="Configure Source" />

       * **Environment**: The project environment to retrieve secrets from.
       * **Secret Path**: The folder path to retrieve secrets from.

    <Tip>
      If you need to sync secrets from multiple folder locations, check out [secret imports](/documentation/platform/secret-reference#secret-imports).
    </Tip>

    4. Configure the **Destination** to where secrets should be deployed, then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/github/github-destination.png" alt="Configure Destination" />

       * **GitHub Connection**: The GitHub Connection to authenticate with.
       * **Scope**: The GitHub secret scope to sync secrets to.
         * **Organization**: Sync secrets to a specific organization.
         * **Repository**: Sync secrets to a specific repository.
         * **Repository Environment**: Sync secrets to a specific repository's environment.

       <p class="height:1px" />

       The remaining fields are determined by the selected **Scope**:

       <AccordionGroup>
         <Accordion title="Organization">
           * **Organization**: The organization to deploy secrets to.
           * **Visibility**: Determines which organization repositories can access deployed secrets.
             * **All Repositories**: All repositories of the organization. (Public repositories if not a Pro/Team account)
             * **Private Repositories**: All private repositories of the organization. (Requires Pro/Team account)
             * **Selected Repositories**: Only the selected Repositories.
           * **Selected Repositories**: The selected repositories if **Visibility** is set to **Selected Repositories**.
         </Accordion>

         <Accordion title="Repository">
           * **Repository**: The repository to deploy secrets to.
         </Accordion>

         <Accordion title="Repository Environment">
           * **Repository**: The repository to deploy secrets to.
           * **Environment**: The repository's environment to deploy secrets to.
         </Accordion>
       </AccordionGroup>

    5. Configure the **Sync Options** to specify how secrets should be synced, then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/github/github-options.png" alt="Configure Options" />

       * **Initial Sync Behavior**: Determines how Infisical should resolve the initial sync.
         * **Overwrite Destination Secrets**: Removes any secrets at the destination endpoint not present in Infisical.
         <Note>
           GitHub does not support importing secrets.
         </Note>
       * **Key Schema**: Template that determines how secret names are transformed when syncing, using `{{secretKey}}` as a placeholder for the original secret name and `{{environment}}` for the environment.

       <Note>
         We highly recommend using a Key Schema to ensure that Infisical only manages the specific keys you intend, keeping everything else untouched.
       </Note>

       * **Auto-Sync Enabled**: If enabled, secrets will automatically be synced from the source location when changes occur. Disable to enforce manual syncing only.
       * **Disable Secret Deletion**: If enabled, Infisical will not remove secrets from the sync destination. Enable this option if you intend to manage some secrets manually outside of Infisical.

    6. Configure the **Details** of your GitHub Sync, then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/github/github-details.png" alt="Configure Details" />

       * **Name**: The name of your sync. Must be slug-friendly.
       * **Description**: An optional description for your sync.

    7. Review your GitHub Sync configuration, then click **Create Sync**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/github/github-review.png" alt="Confirm Configuration" />

    8. If enabled, your GitHub Sync will begin syncing your secrets to the destination endpoint.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/github/github-created.png" alt="Sync Secrets" />
  </Tab>

  <Tab title="API">
    To create an **GitHub Sync**, make an API request to the [Create GitHub Sync](/api-reference/endpoints/secret-syncs/github/create) API endpoint.

    ### Sample request

    ```bash Request theme={"dark"}
    curl    --request POST \
    --url https://app.infisical.com/api/v1/secret-syncs/github \
    --header 'Content-Type: application/json' \
    --data '{
        "name": "my-github-sync",
        "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
        "description": "an example sync",
        "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
        "environment": "dev",
        "secretPath": "/my-secrets",
        "isEnabled": true,
        "syncOptions": {
            "initialSyncBehavior": "overwrite-destination"
        },
        "destinationConfig": {
            "scope": "repository",
            "owner": "my-github",
            "repo": "my-repository"
        }
    }'
    ```

    ### Sample response

    ```bash Response theme={"dark"}
    {
        "secretSync": {
            "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "name": "my-github-sync",
            "description": "an example sync",
            "isEnabled": true,
            "version": 1,
            "folderId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "createdAt": "2023-11-07T05:31:56Z",
            "updatedAt": "2023-11-07T05:31:56Z",
            "syncStatus": "succeeded",
            "lastSyncJobId": "123",
            "lastSyncMessage": null,
            "lastSyncedAt": "2023-11-07T05:31:56Z",
            "importStatus": null,
            "lastImportJobId": null,
            "lastImportMessage": null,
            "lastImportedAt": null,
            "removeStatus": null,
            "lastRemoveJobId": null,
            "lastRemoveMessage": null,
            "lastRemovedAt": null,
            "syncOptions": {
                "initialSyncBehavior": "overwrite-destination"
            },
            "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "connection": {
                "app": "github",
                "name": "my-github-connection",
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a"
            },
            "environment": {
                "slug": "dev",
                "name": "Development",
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a"
            },
            "folder": {
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                "path": "/my-secrets"
            },
            "destination": "github",
            "destinationConfig": {
                "scope": "repository",
                "owner": "my-github",
                "repo": "my-repository"
            }
        }
    }
    ```
  </Tab>
</Tabs>


# GitLab Sync
Source: https://infisical.com/docs/integrations/secret-syncs/gitlab

Learn how to configure a GitLab Sync for Infisical.

**Prerequisites:**

* Set up and add secrets to [Infisical Cloud](https://app.infisical.com)
* Create a [GitLab Connection](/integrations/app-connections/gitlab)
* Ensure your network security policies allow incoming requests from Infisical to this secret sync provider, if network restrictions apply.

<Tabs>
  <Tab title="Infisical UI">
    1. Navigate to **Project** > **Integrations** and select the **Secret Syncs** tab. Click on the **Add Sync** button.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/general/secret-sync-tab.png" alt="Secret Syncs Tab" />

    2. Select the **GitLab** option.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/gitlab/gitlab-secret-sync-option.png" alt="Select GitLab" />

    3. Configure the **Source** from where secrets should be retrieved, then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/gitlab/gitlab-secret-sync-source.png" alt="Configure Source" />

       * **Environment**: The project environment to retrieve secrets from.
       * **Secret Path**: The folder path to retrieve secrets from.

    <Tip>
      If you need to sync secrets from multiple folder locations, check out [secret imports](/documentation/platform/secret-reference#secret-imports).
    </Tip>

    4. Configure the **Destination** to where secrets should be deployed, then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/gitlab/gitlab-secret-sync-destination.png" alt="Configure Destination" />

       * **GitLab Connection**: The GitLab Connection to authenticate with.
       * **Scope**: The GitLab scope to sync secrets to.
         * **Project**: Sync secrets to a GitLab project.
         * **Group**: Sync secrets to a GitLab group.

       <p class="height:1px" />

       The remaining fields are determined by the selected **Scope**:

       <AccordionGroup>
         <Accordion title="Project">
           * **GitLab Project**: The project to deploy secrets to.
           * **GitLab Environment Scope**: The environment scope to deploy secrets to (optional, defaults to "\*" for all environments).
           * **Mark secrets as Protected**: If enabled, synced secrets will be marked as protected in GitLab.
           * **Mark secrets as Masked**: If enabled, synced secrets will be masked in GitLab CI/CD logs.
           * **Mark secrets as Hidden**: If enabled, synced secrets will be hidden from the GitLab UI.
         </Accordion>

         <Accordion title="Group">
           * **GitLab Group**: The group to deploy secrets to.
           * **GitLab Environment Scope**: The environment scope to deploy secrets to (optional, defaults to "\*" for all environments).
           * **Mark secrets as Protected**: If enabled, synced secrets will be marked as protected in GitLab.
           * **Mark secrets as Masked**: If enabled, synced secrets will be masked in GitLab CI/CD logs.
           * **Mark secrets as Hidden**: If enabled, synced secrets will be hidden from the GitLab UI.
         </Accordion>
       </AccordionGroup>

       <Note>
         Be aware that GitLab only allows to mark secrets as hidden for new secrets. If you try to mark an existing secret as hidden, it produces an error.
       </Note>

       <Warning>
         If you enable **Mark secrets as Hidden**, Infisical will not be able to unhide/unmask secrets from the sync destination if you disable the option later. This is because GitLab does not allow to unhide/unmask existing secrets.
       </Warning>

    5. Configure the **Sync Options** to specify how secrets should be synced, then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/gitlab/gitlab-secret-sync-options.png" alt="Configure Options" />

       * **Initial Sync Behavior**: Determines how Infisical should resolve the initial sync.
         * **Overwrite Destination Secrets**: Removes any secrets at the destination endpoint not present in Infisical.
         <Note>
           GitLab does not support importing secrets.
         </Note>
       * **Key Schema**: Template that determines how secret names are transformed when syncing, using `{{secretKey}}` as a placeholder for the original secret name and `{{environment}}` for the environment.

       <Note>
         We highly recommend using a Key Schema to ensure that Infisical only manages the specific keys you intend, keeping everything else untouched.
       </Note>

       * **Auto-Sync Enabled**: If enabled, secrets will automatically be synced from the source location when changes occur. Disable to enforce manual syncing only.
       * **Disable Secret Deletion**: If enabled, Infisical will not remove secrets from the sync destination. Enable this option if you intend to manage some secrets manually outside of Infisical.

    6. Configure the **Details** of your GitLab Sync, then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/gitlab/gitlab-secret-sync-details.png" alt="Configure Details" />

       * **Name**: The name of your sync. Must be slug-friendly.
       * **Description**: An optional description for your sync.

    7. Review your GitLab Sync configuration, then click **Create Sync**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/gitlab/gitlab-secret-sync-review.png" alt="Confirm Configuration" />

    8. If enabled, your GitLab Sync will begin syncing your secrets to the destination endpoint.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/gitlab/gitlab-secret-sync-created.png" alt="Sync Secrets" />
  </Tab>

  <Tab title="API">
    To create a **GitLab Sync**, make an API request to the [Create GitLab Sync](/api-reference/endpoints/secret-syncs/gitlab/create) API endpoint.

    ### Sample request

    ```bash Request theme={"dark"}
    curl    --request POST \
    --url https://app.infisical.com/api/v1/secret-syncs/gitlab \
    --header 'Content-Type: application/json' \
    --data '{
        "name": "my-gitlab-sync",
        "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
        "description": "an example sync",
        "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
        "environment": "dev",
        "secretPath": "/my-secrets",
        "isEnabled": true,
        "syncOptions": {
            "initialSyncBehavior": "overwrite-destination"
        },
        "destinationConfig": {
            "scope": "project",
            "projectId": "70998370",
            "projectName": "test",
            "targetEnvironment": "*",
            "shouldProtectSecrets": true,
            "shouldMaskSecrets": true,
            "shouldHideSecrets": false
        }
    }'
    ```

    ### Sample response

    ```bash Response theme={"dark"}
    {
        "secretSync": {
            "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "name": "my-gitlab-sync",
            "description": "an example sync",
            "isEnabled": true,
            "version": 1,
            "folderId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "createdAt": "2023-11-07T05:31:56Z",
            "updatedAt": "2023-11-07T05:31:56Z",
            "syncStatus": "succeeded",
            "lastSyncJobId": "123",
            "lastSyncMessage": null,
            "lastSyncedAt": "2023-11-07T05:31:56Z",
            "importStatus": null,
            "lastImportJobId": null,
            "lastImportMessage": null,
            "lastImportedAt": null,
            "removeStatus": null,
            "lastRemoveJobId": null,
            "lastRemoveMessage": null,
            "lastRemovedAt": null,
            "syncOptions": {
                "initialSyncBehavior": "overwrite-destination"
            },
            "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "connection": {
                "app": "gitlab",
                "name": "my-gitlab-connection",
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a"
            },
            "environment": {
                "slug": "dev",
                "name": "Development",
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a"
            },
            "folder": {
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                "path": "/my-secrets"
            },
            "destination": "gitlab",
            "destinationConfig": {
                "scope": "project",
                "projectId": "70998370",
                "projectName": "test",
                "targetEnvironment": "*",
                "shouldProtectSecrets": true,
                "shouldMaskSecrets": true,
                "shouldHideSecrets": false
            }
        }
    }
    ```
  </Tab>
</Tabs>


# Hashicorp Vault Sync
Source: https://infisical.com/docs/integrations/secret-syncs/hashicorp-vault

Learn how to configure a Hashicorp Vault Sync for Infisical.

**Prerequisites:**

* Set up and add secrets to [Infisical Cloud](https://app.infisical.com)
* Create a [Hashicorp Vault Connection](/integrations/app-connections/hashicorp-vault)

<Tabs>
  <Tab title="Infisical UI">
    <Steps>
      <Step title="Add Sync">
        Navigate to **Project** > **Integrations** and select the **Secret Syncs** tab. Click on the **Add Sync** button.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/general/secret-sync-tab.png" alt="Secret Syncs Tab" />
      </Step>

      <Step title="Select Hashicorp Vault">
                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/hashicorp-vault/select-option.png" alt="Select Hashicorp Vault" />
      </Step>

      <Step title="Configure Source">
        Configure the **Source** from where secrets should be retrieved, then click **Next**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/hashicorp-vault/sync-source.png" alt="Configure Source" />

        * **Environment**: The project environment to retrieve secrets from.
        * **Secret Path**: The folder path to retrieve secrets from.

        <Tip>
          If you need to sync secrets from multiple folder locations, check out [secret imports](/documentation/platform/secret-reference#secret-imports).
        </Tip>
      </Step>

      <Step title="Configure Destination">
        Configure the **Destination** to where secrets should be deployed.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/hashicorp-vault/sync-destination.png" alt="Configure Destination" />

        * **Hashicorp Vault Connection**: The Vault Connection to authenticate with.
        * **Secrets Engine Mount**: The secrets engine to sync secrets with (e.g., 'secret', 'kv').
        * **Path**: The specific path within the secrets engine where secrets will be stored.

        After configuring these parameters, click the **Next** button to continue to the Sync Options step.

        <Note>
          If the **path** you provide does not exist in Vault, it will be created.
        </Note>
      </Step>

      <Step title="Configure Sync Options">
        Configure the **Sync Options** to specify how secrets should be synced, then click **Next**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/hashicorp-vault/sync-options.png" alt="Configure Options" />

        * **Initial Sync Behavior**: Determines how Infisical should resolve the initial sync.
          * **Overwrite Destination Secrets**: Removes any secrets at the destination endpoint not present in Infisical.
          * **Import Secrets (Prioritize Infisical)**: Imports secrets from the destination endpoint before syncing, prioritizing values from Infisical over Hashicorp Vault when keys conflict.
          * **Import Secrets (Prioritize Hashicorp Vault)**: Imports secrets from the destination endpoint before syncing, prioritizing values from Hashicorp Vault over Infisical when keys conflict.
        * **Key Schema**: Template that determines how secret names are transformed when syncing, using `{{secretKey}}` as a placeholder for the original secret name and `{{environment}}` for the environment.

        <Note>
          We highly recommend using a Key Schema to ensure that Infisical only manages the specific keys you intend, keeping everything else untouched.
        </Note>

        * **Auto-Sync Enabled**: If enabled, secrets will automatically be synced from the source location when changes occur. Disable to enforce manual syncing only.
        * **Disable Secret Deletion**: If enabled, Infisical will not remove secrets from the sync destination. Enable this option if you intend to manage some secrets manually outside of Infisical.
      </Step>

      <Step title="Configure Details">
        Configure the **Details** of your Hashicorp Vault Sync, then click **Next**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/hashicorp-vault/sync-details.png" alt="Configure Details" />

        * **Name**: The name of your sync. Must be slug-friendly.
        * **Description**: An optional description for your sync.
      </Step>

      <Step title="Review Configuration">
        Review your Hashicorp Vault Sync configuration, then click **Create Sync**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/hashicorp-vault/sync-review.png" alt="Confirm Configuration" />
      </Step>

      <Step title="Sync Created">
        If enabled, your Hashicorp Vault Sync will begin syncing your secrets to the destination endpoint.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/hashicorp-vault/sync-created.png" alt="Sync Created" />
      </Step>
    </Steps>
  </Tab>

  <Tab title="API">
    To create an **Hashicorp Vault Sync**, make an API request to the [Create Hashicorp Vault Sync](/api-reference/endpoints/secret-syncs/hashicorp-vault/create) API endpoint.

    ### Sample request

    ```bash Request theme={"dark"}
    curl    --request POST \
            --url https://app.infisical.com/api/v1/secret-syncs/hashicorp-vault \
            --header 'Content-Type: application/json' \
            --data '{
                "name": "my-vault-sync",
                "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                "description": "an example sync",
                "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                "environment": "dev",
                "secretPath": "/",
                "isEnabled": true,
                "syncOptions": {
                    "initialSyncBehavior": "overwrite-destination"
                },
                "destinationConfig": {
                    "mount": "secret",
                    "path": "dev/nested"
                }
            }'
    ```

    ### Sample response

    ```bash Response theme={"dark"}
    {
        "secretSync": {
            "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "name": "my-vault-sync",
            "description": "an example sync",
            "isEnabled": true,
            "version": 1,
            "folderId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "createdAt": "2023-11-07T05:31:56Z",
            "updatedAt": "2023-11-07T05:31:56Z",
            "syncStatus": "succeeded",
            "lastSyncJobId": "123",
            "lastSyncMessage": null,
            "lastSyncedAt": "2023-11-07T05:31:56Z",
            "importStatus": null,
            "lastImportJobId": null,
            "lastImportMessage": null,
            "lastImportedAt": null,
            "removeStatus": null,
            "lastRemoveJobId": null,
            "lastRemoveMessage": null,
            "lastRemovedAt": null,
            "syncOptions": {
                "initialSyncBehavior": "overwrite-destination"
            },
            "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "connection": {
                "app": "hashicorp-vault",
                "name": "my-vault-connection",
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a"
            },
            "environment": {
                "slug": "dev",
                "name": "Development",
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a"
            },
            "folder": {
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                "path": "/"
            },
            "destination": "hashicorp-vault",
            "destinationConfig": {
                "mount": "secret",
                "path": "dev/nested"
            }
        }
    }
    ```
  </Tab>
</Tabs>


# Heroku Sync
Source: https://infisical.com/docs/integrations/secret-syncs/heroku

Learn how to configure a Heroku Sync for Infisical.

**Prerequisites:**

* Set up and add secrets to [Infisical Cloud](https://app.infisical.com)
* Create a [Heroku Connection](/integrations/app-connections/heroku)

<Tabs>
  <Tab title="Infisical UI">
    1. Navigate to **Project** > **Integrations** and select the **Secret Syncs** tab. Click on the **Add Sync** button.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/general/secret-sync-tab.png" alt="Secret Syncs Tab" />

    2. Select the **Heroku** option.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/heroku/select-heroku-option.png" alt="Select Heroku" />

    3. Configure the **Source** from where secrets should be retrieved, then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/heroku/heroku-source.png" alt="Configure Source" />

       * **Environment**: The project environment to retrieve secrets from.
       * **Secret Path**: The folder path to retrieve secrets from.

    <Tip>
      If you need to sync secrets from multiple folder locations, check out [secret imports](/documentation/platform/secret-reference#secret-imports).
    </Tip>

    4. Configure the **Destination** to where secrets should be deployed, then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/heroku/heroku-destination.png" alt="Configure Destination" />

       * **Heroku Connection**: The Heroku Connection to authenticate with.
       * **Heroku App**: The Heroku application to sync secrets to.

    5. Configure the **Sync Options** to specify how secrets should be synced, then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/heroku/heroku-options.png" alt="Configure Options" />

       * **Initial Sync Behavior**: Determines how Infisical should resolve the initial sync.
         * **Import - Prefer values from Infisical**: Import secrets from Heroku to Infisical; if a secret with the same name already exists in Infisical, do nothing. Afterwards, sync secrets to Heroku.
         * **Import - Prefer values from Heroku**: Import secrets from Heroku to Infisical; if a secret with the same name already exists in Infisical, replace its value with the one from Heroku. Afterwards, sync secrets to Heroku.
         * **Overwrite Destination Secrets**: Removes any secrets at the destination endpoint not present in Infisical.
       * **Key Schema**: Template that determines how secret names are transformed when syncing, using `{{secretKey}}` as a placeholder for the original secret name and `{{environment}}` for the environment.

       <Note>
         We highly recommend using a Key Schema to ensure that Infisical only manages the specific keys you intend, keeping everything else untouched.
       </Note>

       * **Auto-Sync Enabled**: If enabled, secrets will automatically be synced from the source location when changes occur. Disable to enforce manual syncing only.
       * **Disable Secret Deletion**: If enabled, Infisical will not remove secrets from the sync destination. Enable this option if you intend to manage some secrets manually outside of Infisical.

    6. Configure the **Details** of your Heroku Sync, then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/heroku/heroku-details.png" alt="Configure Details" />

       * **Name**: The name of your sync. Must be slug-friendly.
       * **Description**: An optional description for your sync.

    7. Review your Heroku Sync configuration, then click **Create Sync**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/heroku/heroku-review.png" alt="Confirm Configuration" />

    8. If enabled, your Heroku Sync will begin syncing your secrets to the destination endpoint.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/heroku/heroku-created.png" alt="Sync Secrets" />
  </Tab>

  <Tab title="API">
    To create a **Heroku Sync**, make an API request to the [Create Heroku Sync](/api-reference/endpoints/secret-syncs/heroku/create) API endpoint.

    ### Sample request

    ```bash Request theme={"dark"}
    curl    --request POST \
    --url https://app.infisical.com/api/v1/secret-syncs/heroku \
    --header 'Content-Type: application/json' \
    --data '{
        "name": "my-heroku-sync",
        "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
        "description": "an example sync",
        "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
        "environment": "dev",
        "secretPath": "/my-secrets",
        "isEnabled": true,
        "syncOptions": {
            "initialSyncBehavior": "overwrite-destination",
            "disableSecretDeletion": true
        },
        "destinationConfig": {
            "app": "8dd25736052a4b50",
            "appName": "my-app"
        }
    }'
    ```

    ### Sample response

    ```bash Response theme={"dark"}
    {
        "secretSync": {
            "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "name": "my-heroku-sync",
            "description": "an example sync",
            "isEnabled": true,
            "version": 1,
            "folderId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "createdAt": "2023-11-07T05:31:56Z",
            "updatedAt": "2023-11-07T05:31:56Z",
            "syncStatus": "succeeded",
            "lastSyncJobId": "123",
            "lastSyncMessage": null,
            "lastSyncedAt": "2023-11-07T05:31:56Z",
            "importStatus": null,
            "lastImportJobId": null,
            "lastImportMessage": null,
            "lastImportedAt": null,
            "removeStatus": null,
            "lastRemoveJobId": null,
            "lastRemoveMessage": null,
            "lastRemovedAt": null,
            "syncOptions": {
                "initialSyncBehavior": "overwrite-destination",
                "disableSecretDeletion": true
            },
            "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "connection": {
                "app": "heroku",
                "name": "my-heroku-connection",
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a"
            },
            "environment": {
                "slug": "dev",
                "name": "Development",
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a"
            },
            "folder": {
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                "path": "/my-secrets"
            },
            "destination": "heroku",
            "destinationConfig": {
                "app": "8dd25736052a4b50",
                "appName": "my-app"
            }
        }
    }
    ```
  </Tab>
</Tabs>


# Humanitec Sync
Source: https://infisical.com/docs/integrations/secret-syncs/humanitec

Learn how to configure a Humanitec Sync for Infisical.

**Prerequisites:**

* Set up and add secrets to [Infisical Cloud](https://app.infisical.com)
* Create a [Humanitec Connection](/integrations/app-connections/humanitec)

<Tabs>
  <Tab title="Infisical UI">
    1. Navigate to **Project** > **Integrations** and select the **Secret Syncs** tab. Click on the **Add Sync** button.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/general/secret-sync-tab.png" alt="Secret Syncs Tab" />

    2. Select the **Humanitec** option.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/humanitec/select-humanitec-option.png" alt="Select Humanitec" />

    3. Configure the **Source** from where secrets should be retrieved, then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/humanitec/humanitec-source.png" alt="Configure Source" />

       * **Environment**: The project environment to retrieve secrets from.
       * **Secret Path**: The folder path to retrieve secrets from.

    <Tip>
      If you need to sync secrets from multiple folder locations, check out [secret imports](/documentation/platform/secret-reference#secret-imports).
    </Tip>

    4. Configure the **Destination** to where secrets should be deployed, then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/humanitec/humanitec-destination.png" alt="Configure Destination" />

       * **Humanitec Connection**: The Humanitec Connection to authenticate with.
       * **Scope**: The Humanitec secret scope to sync secrets to.
         * **Application**: Sync secrets to a specific application.
         * **Environment**: Sync secrets to a specific environment of an application.

       <p class="height:1px" />

       The remaining fields are determined by the selected **Scope**:

       <AccordionGroup>
         <Accordion title="Application">
           * **Organization**: The organization to deploy secrets to.
           * **App**: The application to deploy secrets to.
         </Accordion>

         <Accordion title="Environment">
           * **Organization**: The organization to deploy secrets to.
           * **App**: The application to deploy secrets to.
           * **Environment**: The environment to deploy secrets to.
         </Accordion>
       </AccordionGroup>

    5. Configure the **Sync Options** to specify how secrets should be synced, then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/humanitec/humanitec-options.png" alt="Configure Options" />

       * **Initial Sync Behavior**: Determines how Infisical should resolve the initial sync.
         * **Overwrite Destination Secrets**: Removes any secrets at the destination endpoint not present in Infisical.
         <Note>
           Humanitec does not support importing secrets.
         </Note>
       * **Key Schema**: Template that determines how secret names are transformed when syncing, using `{{secretKey}}` as a placeholder for the original secret name and `{{environment}}` for the environment.

       <Note>
         We highly recommend using a Key Schema to ensure that Infisical only manages the specific keys you intend, keeping everything else untouched.
       </Note>

       * **Auto-Sync Enabled**: If enabled, secrets will automatically be synced from the source location when changes occur. Disable to enforce manual syncing only.
       * **Disable Secret Deletion**: If enabled, Infisical will not remove secrets from the sync destination. Enable this option if you intend to manage some secrets manually outside of Infisical.

    6. Configure the **Details** of your Humanitec Sync, then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/humanitec/humanitec-details.png" alt="Configure Details" />

       * **Name**: The name of your sync. Must be slug-friendly.
       * **Description**: An optional description for your sync.

    7. Review your Humanitec Sync configuration, then click **Create Sync**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/humanitec/humanitec-review.png" alt="Confirm Configuration" />

    8. If enabled, your Humanitec Sync will begin syncing your secrets to the destination endpoint.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/humanitec/humanitec-created.png" alt="Sync Secrets" />
  </Tab>

  <Tab title="API">
    To create an **Humanitec Sync**, make an API request to the [Create Humanitec Sync](/api-reference/endpoints/secret-syncs/humanitec/create) API endpoint.

    ### Sample request

    ```bash Request theme={"dark"}
    curl    --request POST \
    --url https://app.infisical.com/api/v1/secret-syncs/humanitec \
    --header 'Content-Type: application/json' \
    --data '{
        "name": "my-humanitec-sync",
        "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
        "description": "an example sync",
        "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
        "environment": "dev",
        "secretPath": "/my-secrets",
        "isEnabled": true,
        "syncOptions": {
            "initialSyncBehavior": "overwrite-destination"
        },
        "destinationConfig": {
            "scope": "application",
            "app": "my-app",
            "environment": "development"
        }
    }'
    ```

    ### Sample response

    ```bash Response theme={"dark"}
    {
        "secretSync": {
            "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "name": "my-humanitec-sync",
            "description": "an example sync",
            "isEnabled": true,
            "version": 1,
            "folderId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "createdAt": "2023-11-07T05:31:56Z",
            "updatedAt": "2023-11-07T05:31:56Z",
            "syncStatus": "succeeded",
            "lastSyncJobId": "123",
            "lastSyncMessage": null,
            "lastSyncedAt": "2023-11-07T05:31:56Z",
            "importStatus": null,
            "lastImportJobId": null,
            "lastImportMessage": null,
            "lastImportedAt": null,
            "removeStatus": null,
            "lastRemoveJobId": null,
            "lastRemoveMessage": null,
            "lastRemovedAt": null,
            "syncOptions": {
                "initialSyncBehavior": "overwrite-destination"
            },
            "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "connection": {
                "app": "humanitec",
                "name": "my-humanitec-connection",
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a"
            },
            "environment": {
                "slug": "dev",
                "name": "Development",
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a"
            },
            "folder": {
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                "path": "/my-secrets"
            },
            "destination": "humanitec",
            "destinationConfig": {
                "scope": "application",
                "org": "my-organization",
                "app": "my-app",
                "env": "development"
            }
        }
    }
    ```
  </Tab>
</Tabs>


# Laravel Forge Sync
Source: https://infisical.com/docs/integrations/secret-syncs/laravel-forge

Learn how to configure a Laravel Forge Sync for Infisical.

**Prerequisites:**

* Create a [Laravel Forge Connection](/integrations/app-connections/laravel-forge)

<Tabs>
  <Tab title="Infisical UI">
    <Steps>
      <Step title="Add Sync">
        Navigate to **Project** > **Integrations** and select the **Secret Syncs** tab. Click on the **Add Sync** button.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/general/secret-sync-tab.png" alt="Secret Syncs Tab" />
      </Step>

      <Step title="Select 'Laravel Forge'">
                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/laravel-forge/select-option.png" alt="Select Laravel Forge" />
      </Step>

      <Step title="Configure source">
        Configure the **Source** from where secrets should be retrieved, then click **Next**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/laravel-forge/sync-source.png" alt="Configure Source" />

        * **Environment**: The project environment to retrieve secrets from.
        * **Secret Path**: The folder path to retrieve secrets from.

        <Tip>
          If you need to sync secrets from multiple folder locations, check out [secret imports](/documentation/platform/secret-reference#secret-imports).
        </Tip>
      </Step>

      <Step title="Configure destination">
        Configure the **Destination** to where secrets should be deployed, then click **Next**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/laravel-forge/sync-destination.png" alt="Configure Destination" />

        * **Laravel Forge Connection**: The Laravel Forge Connection to authenticate with.
        * **Organization**: The Organization in which the server and site reside.
        * **Server**: The Server on which the site resides.
        * **Site**: The Site for which secrets should be synced.
      </Step>

      <Step title="Configure Sync Options">
        Configure the **Sync Options** to specify how secrets should be synced, then click **Next**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/laravel-forge/sync-options.png" alt="Configure Options" />

        * **Initial Sync Behavior**: Determines how Infisical should resolve the initial sync.
          * **Overwrite Destination Secrets**: Removes any secrets at the destination endpoint not present in Infisical.
          * **Import Secrets (Prioritize Infisical)**: Imports secrets from the destination endpoint before syncing, prioritizing values from Infisical over Laravel Forge when keys conflict.
          * **Import Secrets (Prioritize Laravel Forge)**: Imports secrets from the destination endpoint before syncing, prioritizing values from Laravel Forge over Infisical when keys conflict.
        * **Key Schema**: Template that determines how secret names are transformed when syncing, using `{{secretKey}}` as a placeholder for the original secret name and `{{environment}}` for the environment.

        <Note>
          We highly recommend using a Key Schema to ensure that Infisical only manages the specific keys you intend, keeping everything else untouched.
        </Note>

        * **Auto-Sync Enabled**: If enabled, secrets will automatically be synced from the source location when changes occur. Disable to enforce manual syncing only.
        * **Disable Secret Deletion**: If enabled, Infisical will not remove secrets from the sync destination. Enable this option if you intend to manage some secrets manually outside of Infisical.
      </Step>

      <Step title="Configure details">
        Configure the **Details** of your Laravel Forge Sync, then click **Next**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/laravel-forge/sync-details.png" alt="Configure Details" />

        * **Name**: The name of your sync. Must be slug-friendly.
        * **Description**: An optional description for your sync.
      </Step>

      <Step title="Review configuration">
        Review your Laravel Forge Sync configuration, then click **Create Sync**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/laravel-forge/sync-review.png" alt="Review Configuration" />
      </Step>

      <Step title="Sync created">
        If enabled, your Laravel Forge Sync will begin syncing your secrets to the destination endpoint.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/laravel-forge/sync-created.png" alt="Sync Created" />
      </Step>
    </Steps>
  </Tab>

  <Tab title="API">
    To create a **Laravel Forge Sync**, make an API request to the [Create Laravel Forge Sync](/api-reference/endpoints/secret-syncs/laravel-forge/create) API endpoint.

    ### Sample request

    ```bash Request theme={"dark"}
    curl    --request POST \
            --url https://app.infisical.com/api/v1/secret-syncs/laravel-forge \
            --header 'Content-Type: application/json' \
            --data '{
                "name": "my-laravel-forge-sync",
                "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                "description": "sync to laravel forge site",
                "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                "environment": "dev",
                "secretPath": "/",
                "isEnabled": true,
                "isAutoSyncEnabled": true,
                "syncOptions": {
                    "initialSyncBehavior": "overwrite-destination",
                    "disableSecretDeletion": false
                },
                "destinationConfig": {
                    "orgSlug": "org-abc123",
                    "serverId": "123",
                    "siteId": "site-abc123"
                }
            }'
    ```

    ### Sample response

    ```bash Response theme={"dark"}
    {
        "secretSync": {
            "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "name": "my-laravel-forge-sync",
            "description": "sync to laravel forge site",
            "folderId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "createdAt": "2025-07-19T12:00:00Z",
            "updatedAt": "2025-07-19T12:00:00Z",
            "syncStatus": "succeeded",
            "lastSyncJobId": "job-1234",
            "lastSyncMessage": null,
            "lastSyncedAt": "2025-07-19T12:00:00Z",
            "syncOptions": {
                "initialSyncBehavior": "overwrite-destination",
                "disableSecretDeletion": false
            },
            "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "connection": {
                "app": "laravel-forge",
                "name": "my-laravel-forge-connection",
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a"
            },
            "environment": {
                "slug": "dev",
                "name": "Development",
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a"
            },
            "folder": {
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                "path": "/"
            },
            "destination": "laravel-forge",
            "destinationConfig": {
                "orgSlug": "org-abc123",
                "serverId": "123",
                "siteId": "site-abc123"
            }
        }
    }
    ```
  </Tab>
</Tabs>


# Netlify Sync
Source: https://infisical.com/docs/integrations/secret-syncs/netlify

Learn how to configure a Netlify Sync for Infisical.

**Prerequisites:**

* Create a [Netlify Connection](/integrations/app-connections/netlify)

<Tabs>
  <Tab title="Infisical UI">
    <Steps>
      <Step title="Add Sync">
        Navigate to **Project** > **Integrations** and select the **Secret Syncs** tab. Click on the **Add Sync** button.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/general/secret-sync-tab.png" alt="Secret Syncs Tab" />
      </Step>

      <Step title="Select 'Netlify'">
                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/netlify/select-option.png" alt="Select Netlify" />
      </Step>

      <Step title="Configure source">
        Configure the **Source** from where secrets should be retrieved, then click **Next**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/netlify/sync-source.png" alt="Configure Source" />

        * **Environment**: The project environment to retrieve secrets from.
        * **Secret Path**: The folder path to retrieve secrets from.

        <Tip>
          If you need to sync secrets from multiple folder locations, check out [secret imports](/documentation/platform/secret-reference#secret-imports).
        </Tip>
      </Step>

      <Step title="Configure destination">
        Configure the **Destination** to where secrets should be deployed, then click **Next**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/netlify/sync-destination.png" alt="Configure Destination" />

        * **Netlify Connection**: The Netlify Connection to authenticate with.
        * **Account**: The Netlify Account to be used.
        * **Site**: The Netlify site where secrets should be synced.
        * **Context**: The Netlify deployment context where secrets should be created in.
      </Step>

      <Step title="Configure Sync Options">
        Configure the **Sync Options** to specify how secrets should be synced, then click **Next**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/netlify/sync-options.png" alt="Configure Options" />

        * **Initial Sync Behavior**: Determines how Infisical should resolve the initial sync.
          * **Overwrite Destination Secrets**: Removes any secrets at the destination endpoint not present in Infisical.
          * **Import Secrets (Prioritize Infisical)**: Imports secrets from the destination endpoint before syncing, prioritizing values from Infisical over Netlify when keys conflict.
          * **Import Secrets (Prioritize Netlify)**: Imports secrets from the destination endpoint before syncing, prioritizing values from Netlify over Infisical when keys conflict.

        <Note>
          Netlify only supports importing non-secret values.
        </Note>

        * **Key Schema**: Template that determines how secret names are transformed when syncing, using `{{secretKey}}` as a placeholder for the original secret name and `{{environment}}` for the environment.

        <Note>
          We highly recommend using a Key Schema to ensure that Infisical only manages the specific keys you intend, keeping everything else untouched.
        </Note>

        * **Auto-Sync Enabled**: If enabled, secrets will automatically be synced from the source location when changes occur. Disable to enforce manual syncing only.
        * **Disable Secret Deletion**: If enabled, Infisical will not remove secrets from the sync destination. Enable this option if you intend to manage some secrets manually outside of Infisical.
      </Step>

      <Step title="Configure details">
        Configure the **Details** of your Netlify Sync, then click **Next**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/netlify/sync-details.png" alt="Configure Details" />

        * **Name**: The name of your sync. Must be slug-friendly.
        * **Description**: An optional description for your sync.
      </Step>

      <Step title="Review configuration">
        Review your Netlify Sync configuration, then click **Create Sync**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/netlify/sync-review.png" alt="Review Configuration" />
      </Step>

      <Step title="Sync created">
        If enabled, your Netlify Sync will begin syncing your secrets to the destination endpoint.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/netlify/sync-created.png" alt="Sync Created" />
      </Step>
    </Steps>
  </Tab>

  <Tab title="API">
    To create a **Netlify Sync**, make an API request to the [Create Netlify Sync](/api-reference/endpoints/secret-syncs/netlify/create) API endpoint.

    ### Sample request

    ```bash Request theme={"dark"}
    curl    --request POST \
            --url https://app.infisical.com/api/v1/secret-syncs/netlify \
            --header 'Content-Type: application/json' \
            --data '{
                "name": "my-netlify-sync",
                "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                "description": "sync to netlify site",
                "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                "environment": "production",
                "secretPath": "/site-secrets",
                "isEnabled": true,
                "syncOptions": {
                    "initialSyncBehavior": "overwrite-destination",
                    "autoSyncEnabled": true,
                    "disableSecretDeletion": false
                },
                "destinationConfig": {
                    "siteId": "site-abc123",
                    "accountId": "account-abc123",
                    "context": "dev"
                }
            }'
    ```

    ### Sample response

    ```bash Response theme={"dark"}
    {
        "secretSync": {
            "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "name": "my-netlify-sync",
            "description": "sync to netlify site",
            "isEnabled": true,
            "version": 1,
            "folderId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "createdAt": "2025-07-19T12:00:00Z",
            "updatedAt": "2025-07-19T12:00:00Z",
            "syncStatus": "succeeded",
            "lastSyncJobId": "job-1234",
            "lastSyncMessage": null,
            "lastSyncedAt": "2025-07-19T12:00:00Z",
            "syncOptions": {
                "initialSyncBehavior": "overwrite-destination",
                "autoSyncEnabled": true,
                "disableSecretDeletion": false
            },
            "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "connection": {
                "app": "netlify",
                "name": "my-netlify-connection",
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a"
            },
            "environment": {
                "slug": "production",
                "name": "Production",
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a"
            },
            "folder": {
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                "path": "/site-secrets"
            },
            "destination": "netlify",
            "destinationConfig": {
                "siteId": "site-abc123",
                "accountId": "account-abc123",
                "context": "dev"
            }
        }
    }
    ```
  </Tab>
</Tabs>


# Northflank Sync
Source: https://infisical.com/docs/integrations/secret-syncs/northflank

Learn how to configure a Northflank Sync for Infisical.

**Prerequisites:**

* Create a [Northflank Connection](/integrations/app-connections/northflank)

<Tabs>
  <Tab title="Infisical UI">
    <Steps>
      <Step title="Add Sync">
        Navigate to **Project** > **Integrations** and select the **Secret Syncs** tab. Click on the **Add Sync** button.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/general/secret-sync-tab.png" alt="Secret Syncs Tab" />
      </Step>

      <Step title="Select 'Northflank'">
                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/northflank/select-option.png" alt="Select Northflank" />
      </Step>

      <Step title="Configure source">
        Configure the **Source** from where secrets should be retrieved, then click **Next**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/northflank/configure-source.png" alt="Configure Source" />

        * **Environment**: The project environment to retrieve secrets from.
        * **Secret Path**: The folder path to retrieve secrets from.

        <Tip>
          If you need to sync secrets from multiple folder locations, check out [secret imports](/documentation/platform/secret-reference#secret-imports).
        </Tip>
      </Step>

      <Step title="Configure destination">
        Configure the **Destination** to where secrets should be deployed, then click **Next**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/northflank/configure-destination.png" alt="Configure Destination" />

        * **Northflank Connection**: The Northflank Connection to authenticate with.
        * **Project**: The Northflank project to sync secrets to.
        * **Secret Group**: The Northflank secret group to sync secrets to.
      </Step>

      <Step title="Configure sync options">
        Configure the **Sync Options** to specify how secrets should be synced, then click **Next**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/northflank/configure-sync-options.png" alt="Configure Sync Options" />

        * **Initial Sync Behavior**: Determines how Infisical should resolve the initial sync.
          * **Overwrite Destination Secrets**: Removes any secrets at the destination endpoint not present in Infisical.
          * **Import Destination Secrets - Prioritize Infisical Values**: Imports any secrets present in the Northflank destination prior to syncing, prioritizing values from Infisical over Northflank when keys conflict.
          * **Import Destination Secrets - Prioritize Northflank Values**: Imports any secrets present in the Northflank destination prior to syncing, prioritizing values from Northflank over Infisical when keys conflict.
        * **Key Schema**: Template that determines how secret names are transformed when syncing, using `{{secretKey}}` as a placeholder for the original secret name and `{{environment}}` for the environment.

        <Note>
          We highly recommend using a Key Schema to ensure that Infisical only manages the specific keys you intend, keeping everything else untouched.
        </Note>

        * **Auto-Sync Enabled**: If enabled, secrets will automatically be synced from the source location when changes occur. Disable to enforce manual syncing only.
        * **Disable Secret Deletion**: If enabled, Infisical will not remove secrets from the sync destination. Enable this option if you intend to manage some secrets manually outside of Infisical.
      </Step>

      <Step title="Configure details">
        Configure the **Details** of your Northflank Sync, then click **Next**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/northflank/configure-details.png" alt="Configure Details" />

        * **Name**: The name of your sync. Must be slug-friendly.
        * **Description**: An optional description for your sync.
      </Step>

      <Step title="Review configuration">
        Review your Northflank Sync configuration, then click **Create Sync**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/northflank/review-configuration.png" alt="Review Configuration" />
      </Step>

      <Step title="Sync created">
        If enabled, your Northflank Sync will begin syncing your secrets to the destination endpoint.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/northflank/sync-created.png" alt="Sync Created" />
      </Step>
    </Steps>
  </Tab>

  <Tab title="API">
    To create a **Northflank Sync**, make an API request to the [Create Northflank Sync](/api-reference/endpoints/secret-syncs/northflank/create) API endpoint.

    ### Sample request

    ```bash Request theme={"dark"}
    curl    --request POST \
            --url https://app.infisical.com/api/v1/secret-syncs/northflank \
            --header 'Content-Type: application/json' \
            --data '{
                "name": "my-northflank-sync",
                "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                "description": "an example sync",
                "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                "environment": "dev",
                "secretPath": "/my-secrets",
                "isAutoSyncEnabled": true,
                "syncOptions": {
                    "initialSyncBehavior": "overwrite-destination",
                    "keySchema": "INFISICAL_{{secretKey}}"
                },
                "destinationConfig": {
                    "projectId": "my-project-id",
                    "secretGroupId": "my-secret-group-id"
                }
            }'
    ```

    ### Sample response

    ```json Response theme={"dark"}
    {
        "secretSync": {
            "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "name": "my-northflank-sync",
            "description": "an example sync",
            "isAutoSyncEnabled": true,
            "version": 1,
            "folderId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "createdAt": "2023-11-07T05:31:56Z",
            "updatedAt": "2023-11-07T05:31:56Z",
            "syncStatus": "succeeded",
            "lastSyncJobId": "123",
            "lastSyncMessage": null,
            "lastSyncedAt": "2023-11-07T05:31:56Z",
            "importStatus": null,
            "lastImportJobId": null,
            "lastImportMessage": null,
            "lastImportedAt": null,
            "removeStatus": null,
            "lastRemoveJobId": null,
            "lastRemoveMessage": null,
            "lastRemovedAt": null,
            "syncOptions": {
                "initialSyncBehavior": "overwrite-destination",
                "keySchema": "INFISICAL_{{secretKey}}",
                "disableSecretDeletion": false
            },
            "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "connection": {
                "app": "northflank",
                "name": "my-northflank-connection",
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a"
            },
            "environment": {
                "slug": "dev",
                "name": "Development",
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a"
            },
            "folder": {
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                "path": "/my-secrets"
            },
            "destination": "northflank",
            "destinationConfig": {
                "projectId": "my-project-id",
                "secretGroupId": "my-secret-group-id"
            }
        }
    }
    ```
  </Tab>
</Tabs>


# OCI Vault Sync
Source: https://infisical.com/docs/integrations/secret-syncs/oci-vault

Learn how to configure an Oracle Cloud Infrastructure Vault Sync for Infisical.

<Info>
  OCI Vault Sync is a paid feature.

  If you're using Infisical Cloud, then it is available under the **Enterprise Tier**. If you're self-hosting Infisical,
  then you should contact [team@infisical.com](mailto:team@infisical.com) to purchase an enterprise license to use it.
</Info>

**Prerequisites:**

* Create an [OCI Connection](/integrations/app-connections/oci) with the required **Secret Sync** permissions
* [Create](https://docs.oracle.com/en-us/iaas/Content/Identity/compartments/To_create_a_compartment.htm) or use an existing OCI Compartment (which the OCI Connection is authorized to access)
* [Create](https://docs.oracle.com/en-us/iaas/Content/KeyManagement/Tasks/managingvaults_topic-To_create_a_new_vault.htm#createnewvault) or use an existing OCI Vault
* Ensure your network security policies allow incoming requests from Infisical to this secret sync provider, if network restrictions apply.

<Tabs>
  <Tab title="Infisical UI">
    <Steps>
      <Step title="Add Sync">
        Navigate to **Project** > **Integrations** and select the **Secret Syncs** tab. Click on the **Add Sync** button.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/general/secret-sync-tab.png" alt="Secret Syncs Tab" />
      </Step>

      <Step title="Select 'OCI Vault'">
                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/oci-vault/select-option.png" alt="Select OCI Vault" />
      </Step>

      <Step title="Configure source">
        Configure the **Source** from where secrets should be retrieved, then click **Next**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/oci-vault/configure-source.png" alt="Configure Source" />

        * **Environment**: The project environment to retrieve secrets from.
        * **Secret Path**: The folder path to retrieve secrets from.

        <Tip>
          If you need to sync secrets from multiple folder locations, check out [secret imports](/documentation/platform/secret-reference#secret-imports).
        </Tip>
      </Step>

      <Step title="Configure destination">
        Configure the **Destination** to where secrets should be deployed, then click **Next**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/oci-vault/configure-destination.png" alt="Configure Destination" />

        * **OCI Connection**: The OCI Connection to authenticate with.
        * **Compartment**: The compartment where the vault is located.
        * **Vault**: The vault to sync secrets to.
        * **Encryption Key**: The encryption key to use when creating secrets in the vault.
      </Step>

      <Step title="Configure sync options">
        Configure the **Sync Options** to specify how secrets should be synced, then click **Next**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/oci-vault/configure-sync-options.png" alt="Configure Sync Options" />

        * **Initial Sync Behavior**: Determines how Infisical should resolve the initial sync.
          * **Overwrite Destination Secrets**: Removes any secrets at the destination endpoint not present in Infisical.
          * **Import Secrets (Prioritize Infisical)**: Imports secrets from the destination endpoint before syncing, prioritizing values from Infisical over OCI Vault when keys conflict.
          * **Import Secrets (Prioritize OCI Vault)**: Imports secrets from the destination endpoint before syncing, prioritizing values from OCI Vault over Infisical when keys conflict.
        * **Key Schema**: Template that determines how secret names are transformed when syncing, using `{{secretKey}}` as a placeholder for the original secret name and `{{environment}}` for the environment.

        <Note>
          We highly recommend using a Key Schema to ensure that Infisical only manages the specific keys you intend, keeping everything else untouched.
        </Note>

        * **Auto-Sync Enabled**: If enabled, secrets will automatically be synced from the source location when changes occur. Disable to enforce manual syncing only.
        * **Disable Secret Deletion**: If enabled, Infisical will not remove secrets from the sync destination. Enable this option if you intend to manage some secrets manually outside of Infisical.
      </Step>

      <Step title="Configure details">
        Configure the **Details** of your OCI Vault Sync, then click **Next**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/oci-vault/configure-details.png" alt="Configure Details" />

        * **Name**: The name of your sync. Must be slug-friendly.
        * **Description**: An optional description for your sync.
      </Step>

      <Step title="Review configuration">
        Review your OCI Vault Sync configuration, then click **Create Sync**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/oci-vault/review-configuration.png" alt="Review Configuration" />
      </Step>

      <Step title="Sync created">
        If enabled, your OCI Vault Sync will begin syncing your secrets to the destination endpoint.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/oci-vault/sync-created.png" alt="Sync Created" />
      </Step>
    </Steps>
  </Tab>

  <Tab title="API">
    To create an **OCI Vault Sync**, make an API request to the [Create OCI Vault Sync](/api-reference/endpoints/secret-syncs/oci-vault/create) API endpoint.

    ### Sample request

    ```bash Request theme={"dark"}
    curl    --request POST \
            --url https://app.infisical.com/api/v1/secret-syncs/oci-vault \
            --header 'Content-Type: application/json' \
            --data '{
                "name": "my-oci-vault-sync",
                "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                "description": "an example sync",
                "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                "environment": "dev",
                "secretPath": "/my-secrets",
                "isEnabled": true,
                "syncOptions": {
                    "initialSyncBehavior": "overwrite-destination"
                },
                "destinationConfig": {
                    "compartmentOcid": "...",
                    "vaultOcid": "...",
                    "keyOcid": "..."
                }
            }'
    ```

    ### Sample response

    ```bash Response theme={"dark"}
    {
        "secretSync": {
            "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "name": "my-oci-vault-sync",
            "description": "an example sync",
            "isEnabled": true,
            "version": 1,
            "folderId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "createdAt": "2023-11-07T05:31:56Z",
            "updatedAt": "2023-11-07T05:31:56Z",
            "syncStatus": "succeeded",
            "lastSyncJobId": "123",
            "lastSyncMessage": null,
            "lastSyncedAt": "2023-11-07T05:31:56Z",
            "importStatus": null,
            "lastImportJobId": null,
            "lastImportMessage": null,
            "lastImportedAt": null,
            "removeStatus": null,
            "lastRemoveJobId": null,
            "lastRemoveMessage": null,
            "lastRemovedAt": null,
            "syncOptions": {
                "initialSyncBehavior": "overwrite-destination"
            },
            "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "connection": {
                "app": "oci",
                "name": "my-oci-connection",
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a"
            },
            "environment": {
                "slug": "dev",
                "name": "Development",
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a"
            },
            "folder": {
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                "path": "/my-secrets"
            },
            "destination": "oci-vault",
            "destinationConfig": {
              "compartmentOcid": "...",
              "vaultOcid": "...",
              "keyOcid": "..."
            }
        }
    }
    ```
  </Tab>
</Tabs>

## FAQ

<AccordionGroup>
  <Accordion title="How are non-active lifecycle states treated?">
    When Infisical attempts to sync secrets, the sync will fail and attempt to re-sync if **any secret** has one of the following lifecycle states:

    * SchedulingDeletion
    * CancellingDeletion
    * Deleting
    * Creating
    * Updating

    We do this to prevent any desync issues.
  </Accordion>

  <Accordion title="What happens if I create / update a variable that's scheduled for deletion in OCI Vault?">
    In the case that a variable is created or updated while it's scheduled for deletion in OCI Vault, we cancel the deletion and update the variable. This action may take up to a minute since Infisical must wait for OCI to completely cancel the deletion and then update the variable.
  </Accordion>
</AccordionGroup>


# null
Source: https://infisical.com/docs/integrations/secret-syncs/overview

Learn how to sync secrets to third-party services with Infisical.

Secret Syncs enable you to sync secrets from Infisical to third-party services using [App Connections](/integrations/app-connections/overview).

<Note>
  Secret Syncs will gradually replace Native Integrations as they become available. Native Integrations will be deprecated in the future, so opt for configuring a Secret Sync when available.
</Note>

## Concept

Secret Syncs are a project-level resource used to sync secrets, via an [App Connection](/integrations/app-connections/overview), from a particular project environment and folder path (source)
to a third-party service (destination). Changes to the source will automatically be propagated to the destination, ensuring
your secrets are always up-to-date.

<br />

<div align="center">
  ```mermaid  theme={"dark"}
  %%{init: {'flowchart': {'curve': 'linear'} } }%%
  graph LR
  A[App Connection]
  B[Secret Sync]
  C[Secret 1]
  D[Secret 2]
  E[Secret 3]
  F[Third-Party Service]
  G[Secret 1]
  H[Secret 2]
  I[Secret 3]
  J[Project Source]

  B --> A
  C --> J
  D --> J
  E --> J
  A --> F
  F --> G
  F --> H
  F --> I
  J --> B

  classDef default fill:#ffffff,stroke:#666,stroke-width:2px,rx:10px,color:black
  classDef connection fill:#FFF2B2,stroke:#E6C34A,stroke-width:2px,color:black,rx:15px
  classDef secret fill:#E6F4FF,stroke:#0096D6,stroke-width:2px,color:black,rx:15px
  classDef sync fill:#F4FFE6,stroke:#96D600,stroke-width:2px,color:black,rx:15px
  classDef service fill:#E6E6FF,stroke:#6B4E96,stroke-width:2px,color:black,rx:15px
  classDef project fill:#FFE6E6,stroke:#D63F3F,stroke-width:2px,color:black,rx:15px

  class A connection
  class B sync
  class C,D,E,G,H,I secret
  class F project
  class J service
  ```
</div>

## Workflow

Configuring a Secret Sync requires three components: a <strong>source</strong> location to retrieve secrets from,
a <strong>destination</strong> endpoint to deploy secrets to, and <strong>configuration options</strong> to determine how your secrets
should be synced. Follow these steps to start syncing:

<Note>
  For step-by-step guides on syncing to a particular third-party service, refer to the Secret Syncs section in the Navigation Bar.
</Note>

1. <strong>Create App Connection:</strong> If you have not already done so, create an [App Connection](/integrations/app-connections/overview)
   via the UI or API for the third-party service you intend to sync secrets to.

2. <strong>Create Secret Sync:</strong> Configure a Secret Sync in the desired project by specifying the following parameters via the UI or API:
   * <strong>Source:</strong> The project environment and folder path you wish to retrieve secrets from.
   * <strong>Destination:</strong> The App Connection to utilize and the destination endpoint to deploy secrets to. These can vary between services.
   * <strong>Options:</strong> Customize how secrets should be synced, such as whether or not secrets should be imported from the destination on the initial sync.

<Note>
  Secret Syncs are the source of truth for connected third-party services. Any secret,
  including associated data, not present or imported in Infisical before syncing will be
  overwritten, and changes made directly in the connected service outside of infisical may also
  be overwritten by future syncs.
</Note>

<Info>
  Some third-party services do not support importing secrets.
</Info>

3. <strong>Utilize Sync:</strong> Any changes to the source location will now automatically be propagated to the destination endpoint.

<Note>
  Infisical is continuously expanding it's Secret Sync third-party service support. If the service you need isn't available,
  you can still use our Native Integrations in the interim, or contact us at [team@infisical.com](mailto:team@infisical.com) to make a request .
</Note>

## Key Schemas

Key Schemas transform your secret keys by applying a prefix, suffix, or format pattern during sync to external destinations. This makes it clear which secrets are managed by Infisical and prevents accidental changes to unrelated secrets.

Any destination secrets which do not match the schema will not get deleted or updated by Infisical.

Key Schemas use handlebars syntax to define dynamic values. Here's a full list of available variables:

* `{{secretKey}}` - The key of the secret
* `{{environment}}` - The environment which the secret is in (e.g. dev, staging, prod)

**Example:**

* Infisical key: `SECRET_1`
* Schema: `INFISICAL_{{secretKey}}`
* Synced key: `INFISICAL_SECRET_1`

<div align="center">
  ```mermaid  theme={"dark"}
  graph LR
    A[Infisical: **SECRET_1**] -->|Apply Schema| B[Destination: **INFISICAL_SECRET_1**]
    style B fill:#F4FFE6,stroke:#96D600,stroke-width:2px,color:black,rx:15px
    style A fill:#E6F4FF,stroke:#0096D6,stroke-width:2px,color:black,rx:15px
  ```
</div>

<Note>
  When importing secrets from the destination into Infisical, the schema is stripped from imported secret keys.
</Note>


# Railway Sync
Source: https://infisical.com/docs/integrations/secret-syncs/railway

Learn how to configure a Railway Sync for Infisical.

**Prerequisites:**

* Create a [Railway Connection](/integrations/app-connections/railway)

<Tabs>
  <Tab title="Infisical UI">
    <Steps>
      <Step title="Add Sync">
        Navigate to **Project** > **Integrations** and select the **Secret Syncs** tab. Click on the **Add Sync** button.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/general/secret-sync-tab.png" alt="Secret Syncs Tab" />
      </Step>

      <Step title="Select 'Railway'">
                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/railway/select-option.png" alt="Select Railway" />
      </Step>

      <Step title="Configure source">
        Configure the **Source** from where secrets should be retrieved, then click **Next**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/railway/railway-sync-source.png" alt="Configure Source" />

        * **Environment**: The project environment to retrieve secrets from.
        * **Secret Path**: The folder path to retrieve secrets from.

        <Tip>
          If you need to sync secrets from multiple folder locations, check out [secret imports](/documentation/platform/secret-reference#secret-imports).
        </Tip>
      </Step>

      <Step title="Configure destination">
        Configure the **Destination** to where secrets should be deployed, then click **Next**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/railway/railway-sync-destination.png" alt="Configure Destination" />

        * **Railway Connection**: The Railway Connection to authenticate with.
        * **Project**: The Railway project to sync secrets to.
        * **Environment**: The Railway environment to sync secrets to.
        * **Service**: The Service to sync secrets to.
          * **If not provided**: Secrets will be synced as [shared variables](https://docs.railway.com/guides/variables#shared-variables) on Railway.
      </Step>

      <Step title="Configure Sync Options">
        Configure the **Sync Options** to specify how secrets should be synced, then click **Next**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/railway/railway-sync-options.png" alt="Configure Options" />

        * **Initial Sync Behavior**: Determines how Infisical should resolve the initial sync.
          * **Overwrite Destination Secrets**: Removes any secrets at the destination endpoint not present in Infisical.
          * **Import Secrets (Prioritize Infisical)**: Imports secrets from the destination endpoint before syncing, prioritizing values from Infisical over Railway when keys conflict.
          * **Import Secrets (Prioritize Railway)**: Imports secrets from the destination endpoint before syncing, prioritizing values from Railway over Infisical when keys conflict.
        * **Key Schema**: Template that determines how secret names are transformed when syncing, using `{{secretKey}}` as a placeholder for the original secret name and `{{environment}}` for the environment.

        <Note>
          We highly recommend using a Key Schema to ensure that Infisical only manages the specific keys you intend, keeping everything else untouched.
        </Note>

        * **Auto-Sync Enabled**: If enabled, secrets will automatically be synced from the source location when changes occur. Disable to enforce manual syncing only.
        * **Disable Secret Deletion**: If enabled, Infisical will not remove secrets from the sync destination. Enable this option if you intend to manage some secrets manually outside of Infisical.
      </Step>

      <Step title="Configure details">
        Configure the **Details** of your Railway Sync, then click **Next**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/railway/railway-sync-details.png" alt="Configure Details" />

        * **Name**: The name of your sync. Must be slug-friendly.
        * **Description**: An optional description for your sync.
      </Step>

      <Step title="Review configuration">
        Review your Railway Sync configuration, then click **Create Sync**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/railway/railway-sync-review.png" alt="Review Configuration" />
      </Step>

      <Step title="Sync created">
        If enabled, your Railway Sync will begin syncing your secrets to the destination endpoint.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/railway/railway-sync-created.png" alt="Sync Created" />
      </Step>
    </Steps>
  </Tab>

  <Tab title="API">
    To create a **Railway Sync**, make an API request to the [Create Railway Sync](/api-reference/endpoints/secret-syncs/railway/create) API endpoint.

    ### Sample request

    ```bash Request theme={"dark"}
    curl    --request POST \
            --url https://app.infisical.com/api/v1/secret-syncs/railway \
            --header 'Content-Type: application/json' \
            --data '{
                "name": "my-railway-sync",
                "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                "description": "an example sync",
                "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                "environment": "dev",
                "secretPath": "/my-secrets",
                "isEnabled": true,
                "syncOptions": {
                    "initialSyncBehavior": "overwrite-destination",
                    "autoSyncEnabled": true,
                    "disableSecretDeletion": false
                },
                "destinationConfig": {
                    "projectId": "dev-project-id",
                    "projectName": "Development Project",
                    "environmentId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                    "environmentName": "Development",
                    "serviceId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                    "serviceName": "my-railway-service",
                }
            }'
    ```

    ### Sample response

    ```bash Response theme={"dark"}
    {
        "secretSync": {
            "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "name": "my-railway-sync",
            "description": "an example sync",
            "isEnabled": true,
            "version": 1,
            "folderId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "createdAt": "2023-11-07T05:31:56Z",
            "updatedAt": "2023-11-07T05:31:56Z",
            "syncStatus": "succeeded",
            "lastSyncJobId": "123",
            "lastSyncMessage": null,
            "lastSyncedAt": "2023-11-07T05:31:56Z",
            "importStatus": null,
            "lastImportJobId": null,
            "lastImportMessage": null,
            "lastImportedAt": null,
            "removeStatus": null,
            "lastRemoveJobId": null,
            "lastRemoveMessage": null,
            "lastRemovedAt": null,
            "syncOptions": {
                "initialSyncBehavior": "overwrite-destination",
                "autoSyncEnabled": true,
                "disableSecretDeletion": false
            },
            "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "connection": {
                "app": "railway",
                "name": "my-railway-connection",
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a"
            },
            "environment": {
                "slug": "dev",
                "name": "Development",
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a"
            },
            "folder": {
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                "path": "/my-secrets"
            },
            "destination": "railway",
            "destinationConfig": {
                "projectId": "dev-project-id",
                "projectName": "Development Project",
                "environmentId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                "environmentName": "Development",
                "serviceId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                "serviceName": "my-railway-service",
            }
        }
    }
    ```
  </Tab>
</Tabs>


# Render Sync
Source: https://infisical.com/docs/integrations/secret-syncs/render

Learn how to configure a Render Sync for Infisical.

**Prerequisites:**

* Set up and add secrets to [Infisical Cloud](https://app.infisical.com)
* Create a [Render Connection](/integrations/app-connections/render)

<Tabs>
  <Tab title="Infisical UI">
    1. Navigate to **Project** > **Integrations** and select the **Secret Syncs** tab. Click on the **Add Sync** button.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/general/secret-sync-tab.png" alt="Secret Syncs Tab" />

    2. Select the **Render** option.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/render/select-render-option.png" alt="Select Render" />

    3. Configure the **Source** from where secrets should be retrieved, then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/render/render-sync-source.png" alt="Configure Source" />

    * **Environment**: The project environment to retrieve secrets from.
    * **Secret Path**: The folder path to retrieve secrets from.

    <Tip>
      If you need to sync secrets from multiple folder locations, check out [secret imports](/documentation/platform/secret-reference#secret-imports).
    </Tip>

    4. Configure the **Destination** to where secrets should be deployed, then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/render/render-sync-destination.png" alt="Configure Destination" />

    * **Render Connection**: The Render Connection to authenticate with.
    * **Scope**: Select **Service** or **Environment Group**.
      * **Service**: Choose the Render service you want to sync secrets to.
      * **Environment Group**: Choose the Render environment group you want to sync secrets to.

    5. Configure the **Sync Options** to specify how secrets should be synced, then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/render/render-sync-options.png" alt="Configure Options" />

    * **Initial Sync Behavior**: Determines how Infisical should resolve the initial sync.
      * **Overwrite Destination Secrets**: Removes any secrets at the destination endpoint not present in Infisical.
      * **Import Secrets (Prioritize Infisical)**: Imports secrets from the Render service before syncing, prioritizing values from Infisical over Render when keys conflict.
      * **Import Secrets (Prioritize Render)**: Imports secrets from the Render service before syncing, prioritizing values from Render over Infisical when keys conflict.
    * **Key Schema**: Template that determines how secret names are transformed when syncing, using `{{secretKey}}` as a placeholder for the original secret name and `{{environment}}` for the environment.
    * **Auto-Sync Enabled**: If enabled, secrets will automatically be synced from the source location when changes occur. Disable to enforce manual syncing only.
    * **Disable Secret Deletion**: If enabled, Infisical will not remove secrets from the sync destination. Enable this option if you intend to manage some secrets manually outside of Infisical.

    6. Configure the **Details** of your Render Sync, then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/render/render-sync-details.png" alt="Configure Details" />

    * **Name**: The name of your sync. Must be slug-friendly.
    * **Description**: An optional description for your sync.

    7. Review your Render Sync configuration, then click **Create Sync**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/render/render-sync-review.png" alt="Confirm Configuration" />

    8. If enabled, your Render Sync will begin syncing your secrets to the destination endpoint.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/render/render-sync-created.png" alt="Sync Secrets" />
  </Tab>

  <Tab title="API">
    To create a **Render Sync**, make an API request to the [Create Render Sync](/api-reference/endpoints/secret-syncs/render/create) API endpoint.

    ### Sample request

    ```bash Request theme={"dark"}
    curl --request POST \
      --url https://app.infisical.com/api/v1/secret-syncs/render \
      --header 'Content-Type: application/json' \
      --data '{
        "name": "my-render-sync",
        "projectId": "your-project-id",
        "description": "an example sync",
        "connectionId": "your-render-connection-id",
        "environment": "production",
        "secretPath": "/my-secrets",
        "isEnabled": true,
        "syncOptions": {
          "initialSyncBehavior": "overwrite-destination"
        },
        "destinationConfig": {
          "scope": "service",
          "serviceId": "your-render-service-id",
          "type": "env"
        }
      }'
    ```

    ### Sample response

    ```bash Response theme={"dark"}
    {
      "secretSync": {
        "id": "your-sync-id",
        "name": "my-render-sync",
        "description": "an example sync",
        "isEnabled": true,
        "version": 1,
        "folderId": "your-folder-id",
        "connectionId": "your-render-connection-id",
        "createdAt": "2024-05-01T12:00:00Z",
        "updatedAt": "2024-05-01T12:00:00Z",
        "syncStatus": "succeeded",
        "lastSyncJobId": "123",
        "lastSyncMessage": null,
        "lastSyncedAt": "2024-05-01T12:00:00Z",
        "syncOptions": {
          "initialSyncBehavior": "overwrite-destination"
        },
        "projectId": "your-project-id",
        "connection": {
          "app": "render",
          "name": "my-render-connection",
          "id": "your-render-connection-id"
        },
        "environment": {
          "slug": "production",
          "name": "Production",
          "id": "your-env-id"
        },
        "folder": {
          "id": "your-folder-id",
          "path": "/my-secrets"
        },
        "destination": "render",
        "destinationConfig": {
          "scope": "service",
          "serviceId": "your-render-service-id",
          "type": "env"
        }
      }
    }
    ```
  </Tab>
</Tabs>


# Supabase Sync
Source: https://infisical.com/docs/integrations/secret-syncs/supabase

Learn how to configure a Supabase Sync for Infisical.

**Prerequisites:**

* Create a [Supabase Connection](/integrations/app-connections/supabase)

<Tabs>
  <Tab title="Infisical UI">
    <Steps>
      <Step title="Add Sync">
        Navigate to **Project** > **Integrations** and select the **Secret Syncs** tab. Click on the **Add Sync** button.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/general/secret-sync-tab.png" alt="Secret Syncs Tab" />
      </Step>

      <Step title="Select 'Supabase'">
                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/supabase/select-option.png" alt="Select Supabase" />
      </Step>

      <Step title="Configure source">
        Configure the **Source** from where secrets should be retrieved, then click **Next**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/supabase/sync-source.png" alt="Configure Source" />

        * **Environment**: The project environment to retrieve secrets from.
        * **Secret Path**: The folder path to retrieve secrets from.

        <Tip>
          If you need to sync secrets from multiple folder locations, check out [secret imports](/documentation/platform/secret-reference#secret-imports).
        </Tip>
      </Step>

      <Step title="Configure destination">
        Configure the **Destination** to where secrets should be deployed, then click **Next**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/supabase/sync-destination.png" alt="Configure Destination" />

        * **Supabase Connection**: The Supabase Connection to authenticate with.
        * **Project**: The Supabase project to sync secrets to.
      </Step>

      <Step title="Configure Sync Options">
        Configure the **Sync Options** to specify how secrets should be synced, then click **Next**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/supabase/sync-options.png" alt="Configure Options" />

        * **Initial Sync Behavior**: Determines how Infisical should resolve the initial sync.
          * **Overwrite Destination Secrets**: Removes any secrets at the destination endpoint not present in Infisical.
          <Note>
            Supabase does not support importing secrets.
          </Note>
        * **Key Schema**: Template that determines how secret names are transformed when syncing, using `{{secretKey}}` as a placeholder for the original secret name and `{{environment}}` for the environment.

        <Note>
          We highly recommend using a Key Schema to ensure that Infisical only manages the specific keys you intend, keeping everything else untouched.
        </Note>

        * **Auto-Sync Enabled**: If enabled, secrets will automatically be synced from the source location when changes occur. Disable to enforce manual syncing only.
        * **Disable Secret Deletion**: If enabled, Infisical will not remove secrets from the sync destination. Enable this option if you intend to manage some secrets manually outside of Infisical.
      </Step>

      <Step title="Configure details">
        Configure the **Details** of your Supabase Sync, then click **Next**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/supabase/sync-details.png" alt="Configure Details" />

        * **Name**: The name of your sync. Must be slug-friendly.
        * **Description**: An optional description for your sync.
      </Step>

      <Step title="Review configuration">
        Review your Supabase Sync configuration, then click **Create Sync**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/supabase/sync-review.png" alt="Review Configuration" />
      </Step>

      <Step title="Sync created">
        If enabled, your Supabase Sync will begin syncing your secrets to the destination endpoint.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/supabase/sync-created.png" alt="Sync Created" />
      </Step>
    </Steps>
  </Tab>

  <Tab title="API">
    To create a **Supabase Sync**, make an API request to the [Create Supabase Sync](/api-reference/endpoints/secret-syncs/supabase/create) API endpoint.

    ### Sample request

    ```bash Request theme={"dark"}
    curl    --request POST \
            --url https://app.infisical.com/api/v1/secret-syncs/supabase \
            --header 'Content-Type: application/json' \
            --data '{
                "name": "my-supabase-sync",
                "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                "description": "an example sync",
                "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                "environment": "dev",
                "secretPath": "/my-secrets",
                "isEnabled": true,
                "syncOptions": {
                    "initialSyncBehavior": "overwrite-destination",
                    "autoSyncEnabled": true,
                    "disableSecretDeletion": false
                },
                "destinationConfig": {
                    "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                    "projectName": "Example Project"
                }
            }'
    ```

    ### Sample response

    ```bash Response theme={"dark"}
    {
        "secretSync": {
            "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "name": "my-supabase-sync",
            "description": "an example sync",
            "isEnabled": true,
            "version": 1,
            "folderId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "createdAt": "2023-11-07T05:31:56Z",
            "updatedAt": "2023-11-07T05:31:56Z",
            "syncStatus": "succeeded",
            "lastSyncJobId": "123",
            "lastSyncMessage": null,
            "lastSyncedAt": "2023-11-07T05:31:56Z",
            "importStatus": null,
            "lastImportJobId": null,
            "lastImportMessage": null,
            "lastImportedAt": null,
            "removeStatus": null,
            "lastRemoveJobId": null,
            "lastRemoveMessage": null,
            "lastRemovedAt": null,
            "syncOptions": {
                "initialSyncBehavior": "overwrite-destination",
                "autoSyncEnabled": true,
                "disableSecretDeletion": false
            },
            "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "connection": {
                "app": "supabase",
                "name": "my-supabase-connection",
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a"
            },
            "environment": {
                "slug": "dev",
                "name": "Development",
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a"
            },
            "folder": {
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                "path": "/my-secrets"
            },
            "destination": "supabase",
            "destinationConfig": {
                "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                "projectName": "Example Project"
            }
        }
    }
    ```
  </Tab>
</Tabs>


# TeamCity Sync
Source: https://infisical.com/docs/integrations/secret-syncs/teamcity

Learn how to configure a TeamCity Sync for Infisical.

**Prerequisites:**

* Set up and add secrets to [Infisical Cloud](https://app.infisical.com)
* Create a [TeamCity Connection](/integrations/app-connections/teamcity) with the required **Secret Sync** permissions

<Tabs>
  <Tab title="Infisical UI">
    1. Navigate to **Project** > **Integrations** and select the **Secret Syncs** tab. Click on the **Add Sync** button.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/general/secret-sync-tab.png" alt="Secret Syncs Tab" />

    2. Select the **TeamCity** option.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/teamcity/select-teamcity-option.png" alt="Select TeamCity" />

    3. Configure the **Source** from where secrets should be retrieved, then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/teamcity/teamcity-sync-source.png" alt="Configure Source" />

       * **Environment**: The project environment to retrieve secrets from.
       * **Secret Path**: The folder path to retrieve secrets from.

    <Tip>
      If you need to sync secrets from multiple folder locations, check out [secret imports](/documentation/platform/secret-reference#secret-imports).
    </Tip>

    4. Configure the **Destination** to where secrets should be deployed, then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/teamcity/teamcity-sync-destination.png" alt="Configure Destination" />

       * **TeamCity Connection**: The TeamCity Connection to authenticate with.
       * **Project**: The TeamCity project to sync secrets to.
       * **Build Configuration**: The build configuration to sync secrets to.

       <Note>
         Not including a Build Configuration will sync secrets to the project.
       </Note>

    5. Configure the **Sync Options** to specify how secrets should be synced, then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/teamcity/teamcity-sync-options.png" alt="Configure Options" />

       * **Initial Sync Behavior**: Determines how Infisical should resolve the initial sync.

         * **Overwrite Destination Secrets**: Removes any secrets at the destination endpoint not present in Infisical.
         * **Import Secrets (Prioritize Infisical)**: Imports secrets from the destination endpoint before syncing, prioritizing values from Infisical over TeamCity when keys conflict.
         * **Import Secrets (Prioritize TeamCity)**: Imports secrets from the destination endpoint before syncing, prioritizing values from TeamCity over Infisical when keys conflict.

         <Note>
           Infisical only syncs secrets from within the target scope; inherited secrets will not be imported.
         </Note>
       * **Key Schema**: Template that determines how secret names are transformed when syncing, using `{{secretKey}}` as a placeholder for the original secret name and `{{environment}}` for the environment.

       <Note>
         We highly recommend using a Key Schema to ensure that Infisical only manages the specific keys you intend, keeping everything else untouched.
       </Note>

       * **Auto-Sync Enabled**: If enabled, secrets will automatically be synced from the source location when changes occur. Disable to enforce manual syncing only.
       * **Disable Secret Deletion**: If enabled, Infisical will not remove secrets from the sync destination. Enable this option if you intend to manage some secrets manually outside of Infisical.

    6. Configure the **Details** of your TeamCity Sync, then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/teamcity/teamcity-sync-details.png" alt="Configure Details" />

       * **Name**: The name of your sync. Must be slug-friendly.
       * **Description**: An optional description for your sync.

    7. Review your TeamCity Sync configuration, then click **Create Sync**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/teamcity/teamcity-sync-review.png" alt="Confirm Configuration" />

    8. If enabled, your TeamCity Sync will begin syncing your secrets to the destination endpoint.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/teamcity/teamcity-sync-created.png" alt="Sync Secrets" />
  </Tab>

  <Tab title="API">
    To create a **TeamCity Sync**, make an API request to the [Create TeamCity Sync](/api-reference/endpoints/secret-syncs/teamcity/create) API endpoint.

    ### Sample request

    ```bash Request theme={"dark"}
    curl    --request POST \
    --url https://app.infisical.com/api/v1/secret-syncs/teamcity \
    --header 'Content-Type: application/json' \
    --data '{
        "name": "my-teamcity-sync",
        "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
        "description": "an example sync",
        "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
        "environment": "dev",
        "secretPath": "/my-secrets",
        "isEnabled": true,
        "syncOptions": {
            "initialSyncBehavior": "overwrite-destination"
        },
        "destinationConfig": {
            "project": "TestProject",
            "buildConfig": "TestBuildConfig"
        }
    }'
    ```

    <Note>
      The **Project** and **Build Config** parameters must use project and build configuration IDs, not their names.
    </Note>

    ### Sample response

    ```bash Response theme={"dark"}
    {
        "secretSync": {
            "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "name": "my-teamcity-sync",
            "description": "an example sync",
            "isEnabled": true,
            "version": 1,
            "folderId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "createdAt": "2023-11-07T05:31:56Z",
            "updatedAt": "2023-11-07T05:31:56Z",
            "syncStatus": "succeeded",
            "lastSyncJobId": "123",
            "lastSyncMessage": null,
            "lastSyncedAt": "2023-11-07T05:31:56Z",
            "importStatus": null,
            "lastImportJobId": null,
            "lastImportMessage": null,
            "lastImportedAt": null,
            "removeStatus": null,
            "lastRemoveJobId": null,
            "lastRemoveMessage": null,
            "lastRemovedAt": null,
            "syncOptions": {
                "initialSyncBehavior": "overwrite-destination"
            },
            "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "connection": {
                "app": "teamcity",
                "name": "my-teamcity-connection",
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a"
            },
            "environment": {
                "slug": "dev",
                "name": "Development",
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a"
            },
            "folder": {
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                "path": "/my-secrets"
            },
            "destination": "teamcity",
            "destinationConfig": {
                "project": "TestProject",
                "buildConfig": "TestBuildConfig"
            }
        }
    }
    ```
  </Tab>
</Tabs>


# Terraform Cloud Sync
Source: https://infisical.com/docs/integrations/secret-syncs/terraform-cloud

Learn how to configure a Terraform Cloud Sync for Infisical.

**Prerequisites:**

* Set up and add secrets to [Infisical Cloud](https://app.infisical.com)
* Create a [Terraform Cloud Connection](/integrations/app-connections/terraform-cloud)

<Tabs>
  <Tab title="Infisical UI">
    1. Navigate to **Project** > **Integrations** and select the **Secret Syncs** tab. Click on the **Add Sync** button.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/general/secret-sync-tab.png" alt="Secret Syncs Tab" />

    2. Select the **Terraform Cloud** option.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/terraform-cloud/terraform-cloud-option.png" alt="Select Terraform Cloud" />

    3. Configure the **Source** from where secrets should be retrieved, then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/terraform-cloud/terraform-cloud-source.png" alt="Configure Source" />

       * **Environment**: The project environment to retrieve secrets from.
       * **Secret Path**: The folder path to retrieve secrets from.

    <Tip>
      If you need to sync secrets from multiple folder locations, check out [secret imports](/documentation/platform/secret-reference#secret-imports).
    </Tip>

    4. Configure the **Destination** to where secrets should be deployed, then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/terraform-cloud/terraform-cloud-destination.png" alt="Configure Destination" />

       * **Terraform Cloud Connection**: The Terraform Cloud Connection to authenticate with.
       * **Organization**: The Terraform Cloud organization to deploy secrets to.
       * **Category**: The Terraform Cloud variable category to use on secrets syncs. Choose from:
         * **Environment**: Sync secrets as environment variables.
         * **Terraform**: Sync secrets as Terraform variables.
       * **Scope**: The Terraform Cloud secret scope to sync secrets to.
         * **Variable Set**: Sync secrets to a specific variable set.
         * **Workspace**: Sync secrets to a specific workspace.

       <p class="height:1px" />

       The remaining fields are determined by the selected **Scope**:

       <AccordionGroup>
         <Accordion title="Variable Set">
           * **Variable Set**: The variable set to deploy secrets to.
         </Accordion>

         <Accordion title="Workspace">
           * **Workspace**: The workspace to deploy secrets to.
         </Accordion>
       </AccordionGroup>

    5. Configure the **Sync Options** to specify how secrets should be synced, then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/terraform-cloud/terraform-cloud-options.png" alt="Configure Options" />

       * **Initial Sync Behavior**: Determines how Infisical should resolve the initial sync.
         * **Overwrite Destination Secrets**: Removes any secrets at the destination endpoint not present in Infisical.
         <Note>
           Terraform Cloud does not support importing secrets.
         </Note>
       * **Key Schema**: Template that determines how secret names are transformed when syncing, using `{{secretKey}}` as a placeholder for the original secret name and `{{environment}}` for the environment.

       <Note>
         We highly recommend using a Key Schema to ensure that Infisical only manages the specific keys you intend, keeping everything else untouched.
       </Note>

       * **Auto-Sync Enabled**: If enabled, secrets will automatically be synced from the source location when changes occur. Disable to enforce manual syncing only.
       * **Disable Secret Deletion**: If enabled, Infisical will not remove secrets from the sync destination. Enable this option if you intend to manage some secrets manually outside of Infisical.

    6. Configure the **Details** of your Terraform Cloud Sync, then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/terraform-cloud/terraform-cloud-details.png" alt="Configure Details" />

       * **Name**: The name of your sync. Must be slug-friendly.
       * **Description**: An optional description for your sync.

    7. Review your Terraform Cloud Sync configuration, then click **Create Sync**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/terraform-cloud/terraform-cloud-review.png" alt="Confirm Configuration" />

    8. If enabled, your Terraform Cloud Sync will begin syncing your secrets to the destination endpoint.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/terraform-cloud/terraform-cloud-created.png" alt="Sync Secrets" />
  </Tab>

  <Tab title="API">
    To create an **Terraform Cloud Sync**, make an API request to the [Create Terraform Cloud Sync](/api-reference/endpoints/secret-syncs/terraform-cloud/create) API endpoint.

    ### Sample request

    ```bash Request theme={"dark"}
    curl    --request POST \
    --url https://app.infisical.com/api/v1/secret-syncs/terraform-cloud \
    --header 'Content-Type: application/json' \
    --data '{
        "name": "my-terraform-cloud-sync",
        "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
        "description": "an example sync",
        "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
        "environment": "dev",
        "secretPath": "/my-secrets",
        "isEnabled": true,
        "syncOptions": {
            "initialSyncBehavior": "overwrite-destination"
        },
        "destinationConfig": {
            "scope": "variable-set",
            "variableSetId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "variableSetName": "my-variable-set",
            "org": "my-organization-id",
            "category": "env"
        }
    }'
    ```

    ### Sample response

    ```bash Response theme={"dark"}
    {
        "secretSync": {
            "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "name": "my-terraform-cloud-sync",
            "description": "an example sync",
            "isEnabled": true,
            "version": 1,
            "folderId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "createdAt": "2023-11-07T05:31:56Z",
            "updatedAt": "2023-11-07T05:31:56Z",
            "syncStatus": "succeeded",
            "lastSyncJobId": "123",
            "lastSyncMessage": null,
            "lastSyncedAt": "2023-11-07T05:31:56Z",
            "importStatus": null,
            "lastImportJobId": null,
            "lastImportMessage": null,
            "lastImportedAt": null,
            "removeStatus": null,
            "lastRemoveJobId": null,
            "lastRemoveMessage": null,
            "lastRemovedAt": null,
            "syncOptions": {
                "initialSyncBehavior": "overwrite-destination"
            },
            "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "connection": {
                "app": "terraform-cloud",
                "name": "my-terraform-cloud-connection",
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a"
            },
            "environment": {
                "slug": "dev",
                "name": "Development",
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a"
            },
            "folder": {
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                "path": "/my-secrets"
            },
            "destination": "terraform-cloud",
            "destinationConfig": {
                "scope": "workspace",
                "workspaceId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                "workspaceName": "my-workspace",
                "org": "my-organization-id",
                "category": "terraform"
            }
        }
    }
    ```
  </Tab>
</Tabs>


# Vercel Sync
Source: https://infisical.com/docs/integrations/secret-syncs/vercel

Learn how to configure a Vercel Sync for Infisical.

**Prerequisites:**

* Set up and add secrets to [Infisical Cloud](https://app.infisical.com)
* Create a [Vercel Connection](/integrations/app-connections/vercel)

<Tabs>
  <Tab title="Infisical UI">
    1. Navigate to **Project** > **Integrations** and select the **Secret Syncs** tab. Click on the **Add Sync** button.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/general/secret-sync-tab.png" alt="Secret Syncs Tab" />

    2. Select the **Vercel** option.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/vercel/select-vercel-option.png" alt="Select Vercel" />

    3. Configure the **Source** from where secrets should be retrieved, then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/vercel/vercel-source.png" alt="Configure Source" />

       * **Environment**: The project environment to retrieve secrets from.
       * **Secret Path**: The folder path to retrieve secrets from.

    <Tip>
      If you need to sync secrets from multiple folder locations, check out [secret imports](/documentation/platform/secret-reference#secret-imports).
    </Tip>

    4. Configure the **Destination** to where secrets should be deployed, then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/vercel/vercel-destination.png" alt="Configure Destination" />

       * **Vercel Connection**: The Vercel Connection to authenticate with.
       * **Vercel App**: The application to deploy secrets to.
       * **Vercel App Environment**: The environment to deploy secrets to.
       * **Vercel Preview Branch (Optional)**: Specify a branch for preview deployments if needed.

    After configuring these parameters, click the **Next** button to continue to the Sync Options step.

    5. Configure the **Sync Options** to specify how secrets should be synced, then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/vercel/vercel-options.png" alt="Configure Options" />

       * **Initial Sync Behavior**: Determines how Infisical should resolve the initial sync.
         * **Overwrite Destination Secrets**: Removes any secrets at the destination endpoint not present in Infisical.
         * **Import Secrets (Prioritize Infisical)**: Imports secrets from the destination endpoint before syncing, prioritizing values from Infisical over Vercel when keys conflict.
         * **Import Secrets (Prioritize Vercel)**: Imports secrets from the destination endpoint before syncing, prioritizing values from Vercel over Infisical when keys conflict.
       * **Key Schema**: Template that determines how secret names are transformed when syncing, using `{{secretKey}}` as a placeholder for the original secret name and `{{environment}}` for the environment.

       <Note>
         We highly recommend using a Key Schema to ensure that Infisical only manages the specific keys you intend, keeping everything else untouched.
       </Note>

       * **Auto-Sync Enabled**: If enabled, secrets will automatically be synced from the source location when changes occur. Disable to enforce manual syncing only.
       * **Disable Secret Deletion**: If enabled, Infisical will not remove secrets from the sync destination. Enable this option if you intend to manage some secrets manually outside of Infisical.

    6. Configure the **Details** of your Vercel Sync, then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/vercel/vercel-details.png" alt="Configure Details" />

       * **Name**: The name of your sync. Must be slug-friendly.
       * **Description**: An optional description for your sync.

    7. Review your Vercel Sync configuration, then click **Create Sync**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/vercel/vercel-review.png" alt="Confirm Configuration" />

    8. If enabled, your Vercel Sync will begin syncing your secrets to the destination endpoint.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/vercel/vercel-created.png" alt="Sync Secrets" />
  </Tab>

  <Tab title="API">
    To create an **Vercel Sync**, make an API request to the [Create Vercel Sync](/api-reference/endpoints/secret-syncs/vercel/create) API endpoint.

    ### Sample request

    ```bash Request theme={"dark"}
    curl    --request POST \
    --url https://app.infisical.com/api/v1/secret-syncs/vercel \
    --header 'Content-Type: application/json' \
    --data '{
        "name": "my-vercel-sync",
        "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
        "description": "an example sync",
        "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
        "environment": "dev",
        "secretPath": "/my-secrets",
        "isEnabled": true,
        "syncOptions": {
            "initialSyncBehavior": "overwrite-destination"
        },
        "destinationConfig": {
            "app": "prj_bz7zgHvQETPvJWc5tmIr0tGRH9kE",
            "env": "preview",
            "branch": "test",
            "appName": "nextjs-boilerplate",
            "teamId": "team_0d444b5088888dd257"
        }
    }'
    ```

    ### Sample response

    ```bash Response theme={"dark"}
    {
        "secretSync": {
            "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "name": "my-vercel-sync",
            "description": "an example sync",
            "isEnabled": true,
            "version": 1,
            "folderId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "createdAt": "2023-11-07T05:31:56Z",
            "updatedAt": "2023-11-07T05:31:56Z",
            "syncStatus": "succeeded",
            "lastSyncJobId": "123",
            "lastSyncMessage": null,
            "lastSyncedAt": "2023-11-07T05:31:56Z",
            "importStatus": null,
            "lastImportJobId": null,
            "lastImportMessage": null,
            "lastImportedAt": null,
            "removeStatus": null,
            "lastRemoveJobId": null,
            "lastRemoveMessage": null,
            "lastRemovedAt": null,
            "syncOptions": {
                "initialSyncBehavior": "overwrite-destination"
            },
            "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "connection": {
                "app": "vercel",
                "name": "my-vercel-connection",
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a"
            },
            "environment": {
                "slug": "dev",
                "name": "Development",
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a"
            },
            "folder": {
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                "path": "/my-secrets"
            },
            "destination": "vercel",
            "destinationConfig": {
                "app": "prj_bz7zgHvQETPvJWc5tmIr0tGRH9kE",
                "env": "preview",
                "branch": "test",
                "appName": "nextjs-boilerplate",
                "teamId": "team_0d444b5088888dd257"
            }
        }
    }
    ```
  </Tab>
</Tabs>


# Windmill Sync
Source: https://infisical.com/docs/integrations/secret-syncs/windmill

Learn how to configure a Windmill Sync for Infisical.

**Prerequisites:**

* Set up and add secrets to [Infisical Cloud](https://app.infisical.com)
* Create a [Windmill Connection](/integrations/app-connections/windmill) with the required **Secret Sync** permissions

<Tabs>
  <Tab title="Infisical UI">
    1. Navigate to **Project** > **Integrations** and select the **Secret Syncs** tab. Click on the **Add Sync** button.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/general/secret-sync-tab.png" alt="Secret Syncs Tab" />

    2. Select the **Windmill** option.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/windmill/select-windmill-option.png" alt="Select Windmill" />

    3. Configure the **Source** from where secrets should be retrieved, then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/windmill/windmill-sync-source.png" alt="Configure Source" />

       * **Environment**: The project environment to retrieve secrets from.
       * **Secret Path**: The folder path to retrieve secrets from.

    <Tip>
      If you need to sync secrets from multiple folder locations, check out [secret imports](/documentation/platform/secret-reference#secret-imports).
    </Tip>

    4. Configure the **Destination** to where secrets should be deployed, then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/windmill/windmill-sync-destination.png" alt="Configure Destination" />

       * **Windmill Connection**: The Windmill Connection to authenticate with.
       * **Workspace**: The Windmill workspace to sync secrets to.
       * **Path**: The workspace path to sync secrets to.

       <Note>
         Workspace path must conform to Windmill's [owner path convention](https://www.windmill.dev/docs/core_concepts/roles_and_permissions#path).
       </Note>

    5. Configure the **Sync Options** to specify how secrets should be synced, then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/windmill/windmill-sync-options.png" alt="Configure Options" />

       * **Initial Sync Behavior**: Determines how Infisical should resolve the initial sync.
         * **Overwrite Destination Secrets**: Removes any secrets at the destination endpoint not present in Infisical.
         * **Import Secrets (Prioritize Infisical)**: Imports secrets from the destination endpoint before syncing, prioritizing values from Infisical over Windmill when keys conflict.
         * **Import Secrets (Prioritize Windmill)**: Imports secrets from the destination endpoint before syncing, prioritizing values from Windmill over Infisical when keys conflict.
       * **Key Schema**: Template that determines how secret names are transformed when syncing, using `{{secretKey}}` as a placeholder for the original secret name and `{{environment}}` for the environment.

       <Note>
         We highly recommend using a Key Schema to ensure that Infisical only manages the specific keys you intend, keeping everything else untouched.
       </Note>

       * **Auto-Sync Enabled**: If enabled, secrets will automatically be synced from the source location when changes occur. Disable to enforce manual syncing only.
       * **Disable Secret Deletion**: If enabled, Infisical will not remove secrets from the sync destination. Enable this option if you intend to manage some secrets manually outside of Infisical.

    6. Configure the **Details** of your Windmill Sync, then click **Next**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/windmill/windmill-sync-details.png" alt="Configure Details" />

       * **Name**: The name of your sync. Must be slug-friendly.
       * **Description**: An optional description for your sync.

    7. Review your Windmill Sync configuration, then click **Create Sync**.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/windmill/windmill-sync-review.png" alt="Confirm Configuration" />

    8. If enabled, your Windmill Sync will begin syncing your secrets to the destination endpoint.
       <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/windmill/windmill-sync-created.png" alt="Sync Secrets" />
  </Tab>

  <Tab title="API">
    To create an **Windmill Sync**, make an API request to the [Create Windmill Sync](/api-reference/endpoints/secret-syncs/windmill/create) API endpoint.

    ### Sample request

    ```bash Request theme={"dark"}
    curl    --request POST \
    --url https://app.infisical.com/api/v1/secret-syncs/windmill \
    --header 'Content-Type: application/json' \
    --data '{
        "name": "my-windmill-sync",
        "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
        "description": "an example sync",
        "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
        "environment": "dev",
        "secretPath": "/my-secrets",
        "isEnabled": true,
        "syncOptions": {
            "initialSyncBehavior": "overwrite-destination"
        },
        "destinationConfig": {
            "workspace": "my-workspace",
            "path": "f/folder/path/"
        }
    }'
    ```

    <Note>
      Workspace path must conform to Windmill's [owner path convention](https://www.windmill.dev/docs/core_concepts/roles_and_permissions#path).
    </Note>

    ### Sample response

    ```bash Response theme={"dark"}
    {
        "secretSync": {
            "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "name": "my-windmill-sync",
            "description": "an example sync",
            "isEnabled": true,
            "version": 1,
            "folderId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "createdAt": "2023-11-07T05:31:56Z",
            "updatedAt": "2023-11-07T05:31:56Z",
            "syncStatus": "succeeded",
            "lastSyncJobId": "123",
            "lastSyncMessage": null,
            "lastSyncedAt": "2023-11-07T05:31:56Z",
            "importStatus": null,
            "lastImportJobId": null,
            "lastImportMessage": null,
            "lastImportedAt": null,
            "removeStatus": null,
            "lastRemoveJobId": null,
            "lastRemoveMessage": null,
            "lastRemovedAt": null,
            "syncOptions": {
                "initialSyncBehavior": "overwrite-destination"
            },
            "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "connection": {
                "app": "windmill",
                "name": "my-windmill-connection",
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a"
            },
            "environment": {
                "slug": "dev",
                "name": "Development",
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a"
            },
            "folder": {
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                "path": "/my-secrets"
            },
            "destination": "windmill",
            "destinationConfig": {
                "workspace": "my-workspace",
                "path": "f/folder/path/"
            }
        }
    }
    ```
  </Tab>
</Tabs>


# Zabbix Sync
Source: https://infisical.com/docs/integrations/secret-syncs/zabbix

Learn how to configure a Zabbix Sync for Infisical.

**Prerequisites:**

* Create a [Zabbix Connection](/integrations/app-connections/zabbix)

<Tabs>
  <Tab title="Infisical UI">
    <Steps>
      <Step title="Add Sync">
        Navigate to **Project** > **Integrations** and select the **Secret Syncs** tab. Click on the **Add Sync** button.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/general/secret-sync-tab.png" alt="Secret Syncs Tab" />
      </Step>

      <Step title="Select 'Zabbix'">
                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/zabbix/select-option.png" alt="Select Zabbix" />
      </Step>

      <Step title="Configure source">
        Configure the **Source** from where secrets should be retrieved, then click **Next**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/zabbix/configure-source.png" alt="Configure Source" />

        * **Environment**: The project environment to retrieve secrets from.
        * **Secret Path**: The folder path to retrieve secrets from.

        <Tip>
          If you need to sync secrets from multiple folder locations, check out [secret imports](/documentation/platform/secret-reference#secret-imports).
        </Tip>
      </Step>

      <Step title="Configure destination">
        Configure the **Destination** to where secrets should be deployed, then click **Next**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/zabbix/configure-destination.png" alt="Configure Destination" />

        * **Zabbix Connection**: The Zabbix Connection to authenticate with.
        * **Scope**: The Zabbix scope to sync secrets to.
          * **Global**: Secrets will be synced globally.
          * **Host**: Secrets will be synced to the specified host.
        * **Macro Type**: The type of macro to use when syncing secrets to Zabbix. Currently only **Text** and **Secret** macros are supported.
          The remaining fields are determined by the selected **Scope**:

        <AccordionGroup>
          <Accordion title="Host">
            - **Host**: The host to sync secrets to.
          </Accordion>
        </AccordionGroup>
      </Step>

      <Step title="Configure Sync Options">
        Configure the **Sync Options** to specify how secrets should be synced, then click **Next**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/zabbix/configure-sync-options.png" alt="Configure Options" />

        * **Initial Sync Behavior**: Determines how Infisical should resolve the initial sync.
          * **Overwrite Destination Secrets**: Removes any secrets at the destination endpoint not present in Infisical.
          * **Import Secrets (Prioritize Infisical)**: Imports secrets from the destination endpoint before syncing, prioritizing values from Infisical over Zabbix when keys conflict.
          * **Import Secrets (Prioritize Zabbix)**: Imports secrets from the destination endpoint before syncing, prioritizing values from Zabbix over Infisical when keys conflict.
        * **Key Schema**: Template that determines how secret names are transformed when syncing, using `{{secretKey}}` as a placeholder for the original secret name and `{{environment}}` for the environment.

        <Note>
          We highly recommend using a Key Schema to ensure that Infisical only manages the specific keys you intend, keeping everything else untouched.
        </Note>

        * **Auto-Sync Enabled**: If enabled, secrets will automatically be synced from the source location when changes occur. Disable to enforce manual syncing only.
        * **Disable Secret Deletion**: If enabled, Infisical will not remove secrets from the sync destination. Enable this option if you intend to manage some secrets manually outside of Infisical.
      </Step>

      <Step title="Configure details">
        Configure the **Details** of your Zabbix Sync, then click **Next**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/zabbix/configure-details.png" alt="Configure Details" />

        * **Name**: The name of your sync. Must be slug-friendly.
        * **Description**: An optional description for your sync.
      </Step>

      <Step title="Review configuration">
        Review your Zabbix Sync configuration, then click **Create Sync**.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/zabbix/review-configuration.png" alt="Review Configuration" />
      </Step>

      <Step title="Sync created">
        If enabled, your Zabbix Sync will begin syncing your secrets to the destination endpoint.

                <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/secret-syncs/zabbix/sync-created.png" alt="Sync Created" />
      </Step>
    </Steps>
  </Tab>

  <Tab title="API">
    To create a **Zabbix Sync**, make an API request to the [Create Zabbix Sync](/api-reference/endpoints/secret-syncs/zabbix/create) API endpoint.

    ### Sample request

    ```bash Request theme={"dark"}
    curl    --request POST \
            --url https://app.infisical.com/api/v1/secret-syncs/zabbix \
            --header 'Content-Type: application/json' \
            --data '{
                "name": "my-zabbix-sync",
                "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                "description": "an example sync",
                "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                "environment": "dev",
                "secretPath": "/my-secrets",
                "isEnabled": true,
                "syncOptions": {
                    "initialSyncBehavior": "overwrite-destination",
                    "autoSyncEnabled": true,
                    "disableSecretDeletion": false
                },
                "destinationConfig": {
                    "scope": "host",
                    "hostId": "my-zabbix-host",
                    "hostName": "my-zabbix-host",
                    "macroType": 0
                }
            }'
    ```

    ### Sample response

    ```bash Response theme={"dark"}
    {
        "secretSync": {
            "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "name": "my-zabbix-sync",
            "description": "an example sync",
            "isEnabled": true,
            "version": 1,
            "folderId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "connectionId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "createdAt": "2023-11-07T05:31:56Z",
            "updatedAt": "2023-11-07T05:31:56Z",
            "syncStatus": "succeeded",
            "lastSyncJobId": "123",
            "lastSyncMessage": null,
            "lastSyncedAt": "2023-11-07T05:31:56Z",
            "importStatus": null,
            "lastImportJobId": null,
            "lastImportMessage": null,
            "lastImportedAt": null,
            "removeStatus": null,
            "lastRemoveJobId": null,
            "lastRemoveMessage": null,
            "lastRemovedAt": null,
            "syncOptions": {
                "initialSyncBehavior": "overwrite-destination",
                "autoSyncEnabled": true,
                "disableSecretDeletion": false
            },
            "projectId": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
            "connection": {
                "app": "zabbix",
                "name": "my-zabbix-connection",
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a"
            },
            "environment": {
                "slug": "dev",
                "name": "Development",
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a"
            },
            "folder": {
                "id": "3c90c3cc-0d44-4b50-8888-8dd25736052a",
                "path": "/my-secrets"
            },
            "destination": "zabbix",
            "destinationConfig": {
              "scope": "host",
              "hostId": "my-zabbix-host",
              "hostName": "my-zabbix-host",
              "macroType": 0
            }
        }
    }
    ```
  </Tab>
</Tabs>


# User Authentication
Source: https://infisical.com/docs/integrations/user-authentication

Browse and search through all available user authentication methods for Infisical.

export const UserAuthenticationBrowser = () => {
  const [searchTerm, setSearchTerm] = useState('');
  const [selectedCategory, setSelectedCategory] = useState('All');
  const categories = ['All', 'SSO', 'LDAP', 'SCIM', 'General'];
  const authMethods = [{
    "name": "Auth0 OIDC",
    "slug": "auth0-oidc-sso",
    "path": "/documentation/platform/sso/auth0-oidc",
    "description": "Learn how to configure Auth0 OIDC SSO for user authentication in Infisical.",
    "category": "SSO"
  }, {
    "name": "Auth0 SAML",
    "slug": "auth0-saml-sso",
    "path": "/documentation/platform/sso/auth0-saml",
    "description": "Learn how to configure Auth0 SAML SSO for user authentication in Infisical.",
    "category": "SSO"
  }, {
    "name": "Entra ID / Azure AD SAML",
    "slug": "azure-ad-sso",
    "path": "/documentation/platform/sso/azure",
    "description": "Learn how to configure Azure Active Directory (Entra ID) SSO for user authentication in Infisical.",
    "category": "SSO"
  }, {
    "name": "Google",
    "slug": "google-sso",
    "path": "/documentation/platform/sso/google",
    "description": "Learn how to configure Google SSO for user authentication in Infisical.",
    "category": "SSO"
  }, {
    "name": "Google SAML",
    "slug": "google-saml-sso",
    "path": "/documentation/platform/sso/google-saml",
    "description": "Learn how to configure Google SAML SSO for user authentication in Infisical.",
    "category": "SSO"
  }, {
    "name": "GitHub",
    "slug": "github-sso",
    "path": "/documentation/platform/sso/github",
    "description": "Learn how to configure GitHub SSO for user authentication in Infisical.",
    "category": "SSO"
  }, {
    "name": "GitLab",
    "slug": "gitlab-sso",
    "path": "/documentation/platform/sso/gitlab",
    "description": "Learn how to configure GitLab SSO for user authentication in Infisical.",
    "category": "SSO"
  }, {
    "name": "JumpCloud",
    "slug": "jumpcloud-sso",
    "path": "/documentation/platform/sso/jumpcloud",
    "description": "Learn how to configure JumpCloud SSO for user authentication in Infisical.",
    "category": "SSO"
  }, {
    "name": "Keycloak OIDC",
    "slug": "keycloak-oidc-sso",
    "path": "/documentation/platform/sso/keycloak-oidc/overview",
    "description": "Learn how to configure Keycloak OIDC SSO for user authentication in Infisical.",
    "category": "SSO"
  }, {
    "name": "Keycloak SAML",
    "slug": "keycloak-saml-sso",
    "path": "/documentation/platform/sso/keycloak-saml",
    "description": "Learn how to configure Keycloak SAML SSO for user authentication in Infisical.",
    "category": "SSO"
  }, {
    "name": "Okta",
    "slug": "okta-oidc-sso",
    "path": "/documentation/platform/sso/okta",
    "description": "Learn how to configure Okta OIDC SSO for user authentication in Infisical.",
    "category": "SSO"
  }, {
    "name": "Okta SAML",
    "slug": "okta-saml-sso",
    "path": "/documentation/platform/sso/okta-saml",
    "description": "Learn how to configure Okta SAML SSO for user authentication in Infisical.",
    "category": "SSO"
  }, {
    "name": "OneLogin SAML",
    "slug": "onelogin-saml-sso",
    "path": "/documentation/platform/sso/onelogin-saml",
    "description": "Learn how to configure OneLogin SAML SSO for user authentication in Infisical.",
    "category": "SSO"
  }, {
    "name": "General OIDC",
    "slug": "general-oidc-sso",
    "path": "/documentation/platform/sso/general-oidc",
    "description": "Learn how to configure generic OIDC providers for SSO in Infisical.",
    "category": "SSO"
  }, {
    "name": "General SAML 2.0",
    "slug": "general-saml-sso",
    "path": "/documentation/platform/sso/general-saml",
    "description": "Learn how to configure generic SAML 2.0 providers for SSO in Infisical.",
    "category": "SSO"
  }, {
    "name": "LDAP",
    "slug": "ldap",
    "path": "/documentation/platform/ldap/overview",
    "description": "Learn how to configure LDAP authentication for user login in Infisical.",
    "category": "LDAP"
  }, {
    "name": "SCIM",
    "slug": "scim",
    "path": "/documentation/platform/scim/overview",
    "description": "Learn how to configure SCIM provisioning for automated user management in Infisical.",
    "category": "SCIM"
  }, {
    "name": "Email/Password",
    "slug": "email-password",
    "path": "/documentation/getting-started/introduction",
    "description": "Learn how to use standard email and password authentication in Infisical.",
    "category": "General"
  }].sort(function (a, b) {
    return a.name.toLowerCase().localeCompare(b.name.toLowerCase());
  });
  const filteredAuthMethods = useMemo(() => {
    let filtered = authMethods;
    if (selectedCategory !== 'All') {
      filtered = filtered.filter(method => method.category === selectedCategory);
    }
    if (searchTerm) {
      filtered = filtered.filter(method => method.name.toLowerCase().includes(searchTerm.toLowerCase()) || method.description.toLowerCase().includes(searchTerm.toLowerCase()) || method.category.toLowerCase().includes(searchTerm.toLowerCase()));
    }
    return filtered;
  }, [searchTerm, selectedCategory]);
  return <div className="max-w-none">
      {}
      <div className="mb-6">
        <div className="relative w-full">
          <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
            <svg className="h-4 w-4 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
            </svg>
          </div>
          <input type="text" placeholder="Search user authentication methods..." className="block w-full pl-9 pr-3 py-2 text-sm border border-gray-300 rounded-lg placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-yellow-500 focus:border-yellow-500 bg-white shadow-sm" value={searchTerm} onChange={e => setSearchTerm(e.target.value)} />
        </div>
      </div>

      {}
      <div className="mb-6">
        <div className="flex flex-wrap gap-2">
          {categories.map(category => <button key={category} onClick={() => setSelectedCategory(category)} className={`px-3 py-1.5 text-sm font-medium rounded-lg transition-colors shadow-sm ${selectedCategory === category ? 'bg-yellow-100 text-yellow-700 border border-yellow-200' : 'bg-white text-gray-700 border border-gray-200 hover:bg-yellow-50 hover:border-yellow-200'}`}>
              {category}
            </button>)}
        </div>
      </div>

      {}
      <div className="mb-4">
        <p className="text-sm text-gray-600">
          {filteredAuthMethods.length} user authentication method{filteredAuthMethods.length !== 1 ? 's' : ''} found
          {selectedCategory !== 'All' && ` in ${selectedCategory}`}
          {searchTerm && ` for "${searchTerm}"`}
        </p>
      </div>

      {}
      {filteredAuthMethods.length > 0 ? <div className="space-y-4">
          {filteredAuthMethods.map((method, index) => <a key={method.slug} href={method.path} className="group block px-4 py-3 border border-gray-200 rounded-xl hover:border-yellow-200 hover:bg-yellow-50/50 hover:shadow-sm transition-all duration-200 bg-white shadow-sm">
              <div className="w-full">
                <div className="flex items-center justify-between mb-0.5">
                  <h3 className="text-base font-medium text-gray-900 leading-none m-0">
                    {method.name}
                  </h3>
                  <span className="ml-3 inline-flex items-center px-3 py-1 rounded-full text-xs font-medium bg-yellow-100 text-yellow-700 flex-shrink-0">
                    {method.category}
                  </span>
                </div>
                <p className="text-sm text-gray-600 leading-relaxed">
                  {method.description}
                </p>
              </div>
            </a>)}
        </div> : <div className="text-center py-8">
          <div className="flex flex-col items-center space-y-2">
            <p className="text-gray-500">No user authentication methods found matching your criteria</p>
            {searchTerm && <p className="text-gray-400 text-sm">Try adjusting your search terms or filters</p>}
          </div>
        </div>}
    </div>;
};

<UserAuthenticationBrowser />


# Infisical Cloud
Source: https://infisical.com/docs/internals/architecture/cloud

Architecture overview of Infisical's US and EU cloud deployments

This document provides an overview of Infisical's cloud architecture for our US and EU deployments, detailing the core components and how they interact to provide security and infrastructure services.

## Overview

Infisical Cloud operates on AWS infrastructure using containerized services deployed via Amazon ECS (Elastic Container Service). Our US and EU deployments use identical architectural patterns to ensure consistency and reliability across regions.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/self-hosting/reference-architectures/Infisical-AWS-ECS-architecture.jpeg" alt="Infisical Cloud Architecture" />

## Components

A typical Infisical Cloud deployment consists of the following components:

### Application Services

* **Infisical Core**: Main application server running the Infisical backend API
* **License API**: Dedicated API service for license management with separate RDS instance (shared between US/EU)
* **Application Load Balancer**: Routes incoming traffic to application containers with SSL termination and host-based routing

### Data Layer

* **Amazon RDS (PostgreSQL)**:
  * **Main RDS Instance**: Primary database for secrets, users, and metadata (Multi-AZ, encryption enabled)
  * **License API RDS Instance**: Dedicated database for license management services
* **Amazon ElastiCache (Redis)**:
  * **Main Redis Cluster**: Multi-AZ replication group for core application caching and queuing
  * **License API Redis**: Dedicated cache for license services
  * Redis 7 engine with CloudWatch logging and snapshot backups

### Infrastructure

* **ECS Fargate**: Serverless container platform running application services
* **AWS Global Accelerator**: Global traffic routing and performance optimization
* **Cloudflare**: DNS management and routing
* **AWS SSM Parameter Store**: Stores application configuration and secrets
* **CloudWatch**: Centralized logging and monitoring

## System Layout

### Service Architecture

The Infisical application runs as multiple containerized services on ECS:

* **Main Server**: Auto-scaling containerized application services
* **License API**: Dedicated service with separate infrastructure (shared globally)
* **Monitoring**: AWS OTel Collector and Datadog Agent sidecars

Container images are pulled from Docker Hub and managed via GitHub Actions for deployments.

### Network Configuration

Services are deployed in private subnets with the following connectivity:

* External traffic  Application Load Balancer  ECS Services
* Main server exposes port 8080
* License API exposes port 4000 (portal.infisical.com, license.infisical.com)
* Service-to-service communication via AWS Service Connect

### Data Flow

1. **DNS resolution** via Cloudflare routes traffic to AWS Global Accelerator
2. **Global Accelerator** optimizes routing to the nearest AWS region
3. **Client requests** are routed through the Application Load Balancer to ECS containers
4. **Application logic** processes requests in the Infisical Core service
5. **Data persistence** occurs via encrypted connections to RDS
6. **Caching** utilizes ElastiCache for performance optimization
7. **Configuration** is retrieved from AWS SSM Parameter Store

## Regional Deployments

Each region operates in a separate AWS account, providing strong isolation boundaries for security, compliance, and operational independence.

### US Cloud (us.infisical.com or app.infisical.com)

* **AWS Account**: Dedicated US AWS account
* **Infrastructure**: ECS-based containerized deployment
* **Monitoring**: Integrated with Datadog for observability and security monitoring

### EU Cloud (eu.infisical.com)

* **AWS Account**: Dedicated EU AWS account
* **Infrastructure**: ECS-based containerized deployment
* **Monitoring**: Integrated with Datadog for observability and security monitoring

## Configuration Management

Application configuration and secrets are managed through AWS SSM Parameter Store, with deployment automation handled via GitHub Actions.

## Monitoring and Observability

### Logging

* **CloudWatch**: 365-day retention for application logs
* **Health Checks**: HTTP endpoint monitoring for service health

### Metrics

* **AWS OTel Collector**: Prometheus metrics collection
* **Datadog Agent**: Application performance monitoring and infrastructure metrics

## Container Management

* **Images**: `infisical/staging_infisical` and `infisical/license-api` from Docker Hub
* **Deployment**: Automated via GitHub Actions updating SSM parameter for image tags
* **Registry Access**: Docker Hub credentials stored in AWS Secrets Manager
* **Platform**: ECS Fargate serverless container platform

## Security Overview

### Data Protection

* **Encryption**: All secrets encrypted at rest and in transit
* **Network Isolation**: Services deployed in private subnets with controlled access
* **Authentication**: API tokens and service accounts for secure access
* **Audit Logging**: Comprehensive audit trails for all secret operations

### Network Architecture

* **VPC Design**: Dedicated VPC with public and private subnets across multiple Availability Zones
* **NAT Gateway**: Controlled outbound connectivity from private subnets
* **Load Balancing**: Application Load Balancer with SSL termination and health checks
* **Security Groups**: Restrictive firewall rules and controlled network access
* **High Availability**: Multi-AZ deployment with automatic failover
* **Network Monitoring**: VPC Flow Logs with 365-day retention for traffic analysis


# Components
Source: https://infisical.com/docs/internals/architecture/components

Understand Infisical's core architectural components and how they work together.

## Overview

Infisical is architected around several key components that work in concert to provide a secure and streamlined secret management experience. These components span the client, API, and storage layers, ensuring that secrets are protected at every stage of their lifecycle.

## 1. API (Backend)

Infisical exposes a well-documented [REST API](https://infisical.com/docs/api-reference/overview/introduction) that enables programmatic interaction with the platform, enabling a wide range of use cases.

## 2. Storage Backend

Infisical relies on a robust storage backend to durably store secrets, users, and other platform data. Infisical's storage backend is [PostgreSQL](https://www.postgresql.org/).

## 3. Caching Layer

Infisical uses [Redis](https://redis.com) to enable more complex workflows including a queuing system to manage long-running asynchronous tasks, cron jobs, as well as reliable cache for frequently used resources.

## 4. Clients

Clients are interfaces through which users and applications interact with the Infisical API:

* **Web UI**: A browser-based portal providing a user-friendly interface for managing secrets, configurations, and performing administrative tasks.

* [**CLI**](https://infisical.com/docs/cli): A terminal-based tool for interacting with the Infisical API, enabling automation, scripting, and integration into CI/CD pipelines.

* **SDKs (Software Development Kits)**: Platform-specific libraries with method abstractions for working with secrets. Supported languages include [Node.js](https://infisical.com/docs/sdks/languages/node), [Python](https://infisical.com/docs/sdks/languages/python), [Java](https://infisical.com/docs/sdks/languages/java), [Golang](https://infisical.com/docs/sdks/languages/go), [Ruby](https://infisical.com/docs/sdks/languages/ruby) and [.NET](https://infisical.com/docs/sdks/languages/csharp).

* [**Kubernetes Operator**](https://infisical.com/docs/integrations/platforms/kubernetes): A Kubernetes-native component that facilitates the secure retrieval and management of secrets within a Kubernetes cluster. The operator supports multiple custom resource definitions (CRDs) for syncing secrets.

* [**Infisical Agent**](https://infisical.com/docs/integrations/platforms/infisical-agent): Daemon that automatically fetches and manages access tokens and secrets to be used in various client resources.


# Overview
Source: https://infisical.com/docs/internals/overview

Read how Infisical works under the hood.

This section covers the internals of Infisical including its technical underpinnings, architecture, and security properties.

<Note>
  Knowledge of this section is recommended but not required to use Infisical.
  However, if you're operating Infisical, we recommend understanding the
  internals.
</Note>

## Learn More

<CardGroup cols={2}>
  <Card href="./architecture/components" title="Components" icon="boxes-stacked" color="#000000">
    Learn about the fundamental parts of Infisical.
  </Card>

  <Card href="./security" title="Security" icon="shield" color="#000000">
    Read about most common security-related topics and questions.
  </Card>

  <Card href="./service-tokens" title="Service tokens" icon="ticket" color="#000000">
    Learn best practices for utilizing Infisical service tokens. Please note
    that service tokens are now deprecated and will be removed entirely in the
    future.
  </Card>
</CardGroup>


# Migration Guide
Source: https://infisical.com/docs/internals/permissions/migration

Guide for migrating permissions in Infisical

# Migrating from Permission V1 to Permission V2

This guide provides instructions for upgrading from the legacy V1 permissions system to the more powerful V2 permissions system in Infisical.

## Why Upgrade to V2?

The V2 permissions system offers several advantages over V1:

* **More granular control**: Separate permissions for different secret-related resources
* **Explicit deny rules**: Support for permission inversion
* **Conditional permissions**: Apply permissions based on specific criteria
* **Array-based actions**: Cleaner syntax for multiple actions

## Migration Steps

When upgrading to V2 permissions (i.e., when moving from using the `permissions` to `permissions_v2` field in your Terraform configurations, or upgrading to the V2 permission API), you'll need to update your permission structure as follows:

### 1. Expand Secret Permissions

Any permissions for `secrets` should be expanded to include equivalent permissions for:

* `secret-imports`
* `secret-folders` (except for read permissions)
* `dynamic-secrets`

### 2. Map Dynamic Secret Actions

For dynamic secrets, the actions need to be mapped differently:

| V1 Action | V2 Action                                             |
| --------- | ----------------------------------------------------- |
| `read`    | `read-root-credential`                                |
| `create`  | `create-root-credential`                              |
| `edit`    | `edit-root-credential` (also adds `lease` permission) |
| `delete`  | `delete-root-credential`                              |

### 3. Update Configuration Format

V2 permissions use a different syntax, with actions stored in arrays and an optional `inverted` flag:

```typescript  theme={"dark"}
// V1 format (single action)
{
  subject: "secrets",
  action: "read"
}

// V2 format (array of actions)
{
  subject: "secrets",
  action: ["read"],
  inverted: false  // Optional, defaults to false
}
```

## Example Migration

Here's a complete example showing how to migrate a role from V1 to V2:

```hcl  theme={"dark"}
# Old V1 configuration
resource "infisical_project_role" "example" {
  name = "example"
  permissions = [
    {
      subject = "secrets"
      action = "read"
    },
    {
      subject = "secrets"
      action = "edit"
    }
  ]
}

# New V2 configuration
resource "infisical_project_role" "example" {
  name = "example"
  permissions_v2 = [
    # Original secrets permission
    {
      subject = "secrets"
      action = ["read", "edit"]
      inverted = false
    },
    # Add equivalent secret-imports permission
    {
      subject = "secret-imports"
      action = ["read", "edit"]
      inverted = false
    },
    # Add secret-folders permission (without read)
    {
      subject = "secret-folders"
      action = ["edit"]
      inverted = false
    },
    # Add dynamic-secrets permission with mapped actions
    {
      subject = "dynamic-secrets"
      action = ["read-root-credential", "edit-root-credential", "lease"]
      inverted = false
    }
  ]
}
```

## Important Considerations

* When moving to V2 permissions, make sure to include all the necessary expanded permissions based on your original `secrets` permissions.
* V2 permissions give you the ability to use conditions and inversion, which are not available in V1.
* During migration, review your existing roles and consider if more granular permissions would better fit your security requirements.
* Test your migrated permissions thoroughly in a non-production environment before deploying to production.


# Organization Permissions
Source: https://infisical.com/docs/internals/permissions/organization-permissions

Comprehensive guide to Infisical's organization-level permissions

## Overview

Infisical's organization permissions system follows a role-based access control (RBAC) model built on a subject-action-object framework. At the organization level, these permissions determine what actions users/machines can perform on various resources across the entire organization.

Each permission consists of:

* **Subject**: The resource the permission applies to (e.g., project, members, billing)
* **Action**: The operation that can be performed (e.g., read, create, edit, delete)

Some organization-level resourcesspecifically `app-connections`support conditional permissions and permission inversion for more granular access control.

## Available Organization Permissions

Below is a comprehensive list of all available organization-level subjects and their supported actions, organized by functional area.

### Project Management

#### Subject: `project` (formerly workspace)

| Action   | Description        |
| -------- | ------------------ |
| `create` | Create new project |

### Role Management

#### Subject: `role`

| Action   | Description                                            |
| -------- | ------------------------------------------------------ |
| `read`   | View organization roles and their assigned permissions |
| `create` | Create new organization roles                          |
| `edit`   | Modify existing organization roles                     |
| `delete` | Remove organization roles                              |

### User Management

#### Subject: `member`

| Action   | Description                          |
| -------- | ------------------------------------ |
| `read`   | View organization members            |
| `create` | Add new members to the organization  |
| `edit`   | Modify member details                |
| `delete` | Remove members from the organization |

#### Subject: `groups`

| Action             | Description                                      |
| ------------------ | ------------------------------------------------ |
| `read`             | View organization groups                         |
| `create`           | Create new groups in the organization            |
| `edit`             | Modify existing groups                           |
| `delete`           | Remove groups from the organization              |
| `grant-privileges` | Change permission levels for organization groups |
| `add-members`      | Add members to groups                            |
| `remove-members`   | Remove members from groups                       |

#### Subject: `identity`

| Action             | Description                                         |
| ------------------ | --------------------------------------------------- |
| `read`             | View organization identities                        |
| `create`           | Add new identities to organization                  |
| `edit`             | Modify organization identities                      |
| `delete`           | Remove identities from organization                 |
| `grant-privileges` | Change permission levels of organization identities |
| `revoke-auth`      | Revoke authentication for identities                |
| `create-token`     | Create new authentication tokens                    |
| `delete-token`     | Delete authentication tokens                        |
| `get-token`        | Retrieve authentication tokens                      |

### Security & Compliance

#### Subject: `secret-scanning`

| Action   | Description                               |
| -------- | ----------------------------------------- |
| `read`   | View secret scanning results and settings |
| `create` | Configure secret scanning                 |
| `edit`   | Modify secret scanning settings           |
| `delete` | Remove secret scanning configuration      |

#### Subject: `settings`

| Action   | Description                               |
| -------- | ----------------------------------------- |
| `read`   | View organization settings                |
| `create` | Setup and configure organization settings |
| `edit`   | Modify organization settings              |
| `delete` | Remove organization settings              |

#### Subject: `incident-contact`

| Action   | Description                      |
| -------- | -------------------------------- |
| `read`   | View incident contacts           |
| `create` | Set up new incident contacts     |
| `edit`   | Modify incident contact settings |
| `delete` | Remove incident contacts         |

#### Subject: `audit-logs`

| Action | Description                  |
| ------ | ---------------------------- |
| `read` | View organization audit logs |

### Identity Provider Integration

#### Subject: `sso`

| Action   | Description                        |
| -------- | ---------------------------------- |
| `read`   | View Single Sign-On configurations |
| `create` | Set up new SSO integrations        |
| `edit`   | Modify existing SSO settings       |
| `delete` | Remove SSO configurations          |

#### Subject: `scim`

| Action   | Description                   |
| -------- | ----------------------------- |
| `read`   | View SCIM configurations      |
| `create` | Set up new SCIM provisioning  |
| `edit`   | Modify existing SCIM settings |
| `delete` | Remove SCIM configurations    |

#### Subject: `ldap`

| Action   | Description                   |
| -------- | ----------------------------- |
| `read`   | View LDAP configurations      |
| `create` | Set up new LDAP integrations  |
| `edit`   | Modify existing LDAP settings |
| `delete` | Remove LDAP configurations    |

### Billing & Subscriptions

#### Subject: `billing`

| Action           | Description                                      |
| ---------------- | ------------------------------------------------ |
| `read`           | View billing information and subscription status |
| `manage-billing` | Manage billing details and subscription plans    |

### Templates & Automation

#### Subject: `project-templates`

| Action   | Description                       |
| -------- | --------------------------------- |
| `read`   | View project templates            |
| `create` | Create new project templates      |
| `edit`   | Modify existing project templates |
| `delete` | Remove project templates          |

### Integrations

#### Subject: `app-connections`

Supports conditions and permission inversion

| Action    | Description                        |
| --------- | ---------------------------------- |
| `read`    | View app connection configurations |
| `create`  | Create new app connections         |
| `edit`    | Modify existing app connections    |
| `delete`  | Remove app connections             |
| `connect` | Use app connections                |

### Key Management

#### Subject: `kms`

| Action   | Description                          |
| -------- | ------------------------------------ |
| `read`   | View organization KMS configurations |
| `create` | Set up new KMS configurations        |
| `edit`   | Modify KMS settings                  |
| `delete` | Remove KMS configurations            |

#### Subject: `kmip`

| Action  | Description                        |
| ------- | ---------------------------------- |
| `setup` | Configure KMIP server settings     |
| `proxy` | Act as a proxy for KMIP operations |

### Admin Tools

#### Subject: `organization-admin-console`

| Action                | Description                                 |
| --------------------- | ------------------------------------------- |
| `access-all-projects` | Access all projects within the organization |

### Secure Share

#### Subject: `secret-share`

| Action            | Description                  |
| ----------------- | ---------------------------- |
| `manage-settings` | Manage secret share settings |

### Gateway Management

#### Subject: `gateway`

| Action            | Description                       |
| ----------------- | --------------------------------- |
| `list-gateways`   | View all organization gateways    |
| `create-gateways` | Add new gateways to organization  |
| `edit-gateways`   | Modify existing gateway settings  |
| `delete-gateways` | Remove gateways from organization |
| `attach-gateways` | Attach gateways to resources      |

#### Subject: `relay`

| Action          | Description                     |
| --------------- | ------------------------------- |
| `list-relays`   | View all organization relays    |
| `create-relays` | Add new relays to organization  |
| `edit-relays`   | Modify existing relay settings  |
| `delete-relays` | Remove relays from organization |

#### Subject: `machine-identity-auth-template`

| Action             | Description                                    |
| ------------------ | ---------------------------------------------- |
| `list-templates`   | View identity auth templates                   |
| `create-templates` | Create new identity auth templates             |
| `edit-templates`   | Modify existing identity auth templates        |
| `delete-templates` | Remove identity auth templates                 |
| `unlink-templates` | Unlink identity auth templates from identities |
| `attach-templates` | Attach identity auth templates to identities   |


# Overview
Source: https://infisical.com/docs/internals/permissions/overview

Infisical's permissions system provides granular access control.

## Overview

The Infisical permissions system is based on a role-based access control (RBAC) model. The system allows you to define roles and assign them to users and machines. Each role has a set of permissions that define what actions a user can perform.

Permissions are built on a subject-action-object model. The subject is the resource the permission is being applied to, the action is what the permission allows.
An example of a subject/action combination would be `secrets/read`. This permission allows the subject to read secrets.

## Permission Scope Levels

Infisical's permission system operates at two distinct levels, providing comprehensive and flexible access control across your entire security infrastructure:

### Project Permissions

Project permissions control access to resources within a specific project, including secrets management, PKI, KMS, and SSH certificate functionality.

For a comprehensive list of all project-level subjects, actions, and detailed descriptions, please refer to the [Project Permissions](/internals/permissions/project-permissions) documentation.

### Organization Permissions

Organization permissions control access to organization-wide resources and settings such as workspaces, billing, identity providers, and more.

For a comprehensive list of all organization-level subjects, actions, and detailed descriptions, please refer to the [Organization Permissions](/internals/permissions/organization-permissions) documentation.

## Inversion

Permission inversion allows you to explicitly deny actions instead of allowing them. This is supported for the following subjects:

* secrets
* secret-folders
* secret-imports
* dynamic-secrets

When a permission is inverted, it changes from an "allow" rule to a "deny" rule. For example:

```typescript  theme={"dark"}
// Regular permission - allows reading secrets
{
  subject: "secrets",
  action: ["read"]
}

// Inverted permission - denies reading secrets
{
  subject: "secrets",
  action: ["read"],
  inverted: true
}
```

**Important:** The order of permissions matters when using inversion. For inverted (deny) permissions to be effective, there
typically needs to be a corresponding allow permission somewhere in the chain. Permissions are evaluated in sequence,
so the relative positioning of allow and deny rules determines the final access outcome.

## Conditions

Conditions allow you to create more granular permissions by specifying criteria that must be met for the permission to apply. This is supported for the following subjects:

* secrets
* secret-folders
* secret-imports
* dynamic-secrets

### Properties

Conditions can be applied to the following properties:

* `environment`: Control access based on environment slugs
* `secretPath`: Control access based on secret paths
* `secretName`: Control access based on secret names
* `secretTags`: Control access based on tags (only supports \$in operator)

### Operators

The following operators are available for conditions:

| Operator | Description                        | Example                                               |
| -------- | ---------------------------------- | ----------------------------------------------------- |
| `$eq`    | Equal                              | `{ environment: { $eq: "production" } }`              |
| `$ne`    | Not equal                          | `{ environment: { $ne: "development" } }`             |
| `$in`    | Matches any value in array         | `{ environment: { $in: ["staging", "production"] } }` |
| `$glob`  | Pattern matching using glob syntax | `{ secretPath: { $glob: "/app/\*" } }`                |

These details are especially useful if you're using the API to [create new project roles](/api-reference/endpoints/project-roles/create).
The rules outlined on this page, also apply when using our Terraform Provider to manage your Infisical project roles, or any other of our clients that manage project roles.


# Project Permissions
Source: https://infisical.com/docs/internals/permissions/project-permissions

Comprehensive guide to Infisical's project-level permissions

## Overview

Infisical's project permissions system follows a role-based access control (RBAC) model built on a subject-action-object framework. At the project level, these permissions determine what actions users/machines can perform on various resources within a specific project.

Each permission consists of:

* **Subject**: The resource the permission applies to (e.g., secrets, members, settings)
* **Action**: The operation that can be performed (e.g., read, create, edit, delete)

Some project-level resourcesspecifically `secrets`, `secret-folders`, `secret-imports`, `dynamic-secrets`, and `secret-syncs`, support conditional permissions and permission inversion for more granular access control. Conditions allow you to specify criteria (like environment, secret path, or tags) that must be met for the permission to apply.

## Available Project Permissions

Below is a comprehensive list of all available project-level subjects and their supported actions.

### Core Platform & Access Control

#### Subject: `role`

| Action   | Description                                       |
| -------- | ------------------------------------------------- |
| `read`   | View project roles and their assigned permissions |
| `create` | Create new project roles                          |
| `edit`   | Modify existing project roles                     |
| `delete` | Remove project roles                              |

#### Subject: `member`

| Action             | Description                                 |
| ------------------ | ------------------------------------------- |
| `read`             | View project members                        |
| `create`           | Add new members to the project              |
| `edit`             | Modify member details                       |
| `delete`           | Remove members from the project             |
| `grant-privileges` | Change permission levels of project members |

#### Subject: `groups`

| Action             | Description                                |
| ------------------ | ------------------------------------------ |
| `read`             | View project groups                        |
| `create`           | Create new groups within the project       |
| `edit`             | Modify existing groups                     |
| `delete`           | Remove groups from the project             |
| `grant-privileges` | Change permission levels of project groups |

#### Subject: `identity`

| Action             | Description                                    |
| ------------------ | ---------------------------------------------- |
| `read`             | View project identities                        |
| `create`           | Add new identities to project                  |
| `edit`             | Modify project identities                      |
| `delete`           | Remove identities from project                 |
| `grant-privileges` | Change permission levels of project identities |

#### Subject: `settings`

| Action   | Description                            |
| -------- | -------------------------------------- |
| `read`   | View project settings                  |
| `create` | Add new project configuration settings |
| `edit`   | Modify project settings                |
| `delete` | Remove project settings                |

#### Subject: `environments`

| Action   | Description                          |
| -------- | ------------------------------------ |
| `read`   | View project environments            |
| `create` | Add new environments to the project  |
| `edit`   | Modify existing environments         |
| `delete` | Remove environments from the project |

#### Subject: `tags`

| Action   | Description                              |
| -------- | ---------------------------------------- |
| `read`   | View project tags                        |
| `create` | Create new tags for organizing resources |
| `edit`   | Modify existing tags                     |
| `delete` | Remove tags from the project             |

#### Subject: `project`

| Action   | Description               |
| -------- | ------------------------- |
| `edit`   | Modify workspace settings |
| `delete` | Delete the workspace      |

#### Subject: `ip-allowlist`

| Action   | Description                                  |
| -------- | -------------------------------------------- |
| `read`   | View IP allowlists                           |
| `create` | Add new IP addresses or ranges to allowlists |
| `edit`   | Modify existing IP allowlist entries         |
| `delete` | Remove IP addresses from allowlists          |

#### Subject: `audit-logs`

| Action | Description                                             |
| ------ | ------------------------------------------------------- |
| `read` | View audit logs of actions performed within the project |

#### Subject: `integrations`

| Action   | Description                      |
| -------- | -------------------------------- |
| `read`   | View configured integrations     |
| `create` | Add new third-party integrations |
| `edit`   | Modify integration settings      |
| `delete` | Remove integrations              |

#### Subject: `webhooks`

| Action   | Description                          |
| -------- | ------------------------------------ |
| `read`   | View webhook configurations          |
| `create` | Add new webhooks                     |
| `edit`   | Modify webhook endpoints or triggers |
| `delete` | Remove webhooks                      |

#### Subject: `service-tokens`

| Action   | Description                              |
| -------- | ---------------------------------------- |
| `read`   | View service tokens                      |
| `create` | Create new service tokens for API access |
| `edit`   | Modify token properties                  |
| `delete` | Revoke or remove service tokens          |

#### Subject: `app-connections`

Supports conditions and permission inversion

| Action                    | Description                        |
| ------------------------- | ---------------------------------- |
| `read-app-connections`    | View app connection configurations |
| `create-app-connections`  | Create new app connections         |
| `edit-app-connections`    | Modify existing app connections    |
| `delete-app-connections`  | Remove app connections             |
| `connect-app-connections` | Use app connections                |

### Secrets Management

#### Subject: `secrets`

Supports conditions and permission inversion

| Action           | Description                                                     | Notes                                                                                                                                                                                                |
| ---------------- | --------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `read`           | View secrets and their values                                   | This action is the equivalent of granting both `describeSecret` and `readValue`. The `read` action is considered **legacy**. You should use the `describeSecret` and/or `readValue` actions instead. |
| `describeSecret` | View secret details such as key, path, metadata, tags, and more | If you are using the API, you can pass `viewSecretValue: false` to the API call to retrieve secrets without their values.                                                                            |
| `readValue`      | View the value of a secret.                                     | In order to read secret values, the `describeSecret` action must also be granted.                                                                                                                    |
| `create`         | Add new secrets to the project                                  |                                                                                                                                                                                                      |
| `edit`           | Modify existing secret values                                   |                                                                                                                                                                                                      |
| `delete`         | Remove secrets from the project                                 |                                                                                                                                                                                                      |

#### Subject: `secret-folders`

Supports conditions and permission inversion

| Action   | Description              |
| -------- | ------------------------ |
| `read`   | View secret folders      |
| `create` | Create new folders       |
| `edit`   | Modify folder properties |
| `delete` | Remove secret folders    |

#### Subject: `secret-imports`

Supports conditions and permission inversion

| Action   | Description           |
| -------- | --------------------- |
| `read`   | View secret imports   |
| `create` | Create secret imports |
| `edit`   | Modify secret imports |
| `delete` | Remove secret imports |

#### Subject: `secret-events`

| Action                          | Description                                                   |
| ------------------------------- | ------------------------------------------------------------- |
| `subscribe-on-created`          | Subscribe to events when secrets are created                  |
| `subscribe-on-updated`          | Subscribe to events when secrets are updated                  |
| `subscribe-on-deleted`          | Subscribe to events when secrets are deleted                  |
| `subscribe-on-import-mutations` | Subscribe to events when secrets are modified through imports |

#### Subject: `secret-rollback`

| Action   | Description                        |
| -------- | ---------------------------------- |
| `read`   | View secret versions and snapshots |
| `create` | Roll back secrets to snapshots     |

#### Subject: `commits`

| Action             | Description                                                     |
| ------------------ | --------------------------------------------------------------- |
| `read`             | View commits and changes across folders                         |
| `perform-rollback` | Roll back commits changes and restore folders to previous state |

#### Subject: `secret-approval`

| Action                | Description                                                                         |
| --------------------- | ----------------------------------------------------------------------------------- |
| `read`                | View approval policies and requests                                                 |
| `create`              | Create new approval policies                                                        |
| `edit`                | Modify approval policies                                                            |
| `delete`              | Remove approval policies                                                            |
| `allow-change-bypass` | Allow request creators to merge changes without approval in break-glass situations  |
| `allow-access-bypass` | Allow request creators to access secrets without approval in break-glass situations |

#### Subject: `secret-rotation`

Supports conditions and permission inversion

| Action                       | Description                                    |
| ---------------------------- | ---------------------------------------------- |
| `read`                       | View secret rotation configurations            |
| `read-generated-credentials` | View the generated credentials of a rotation   |
| `create`                     | Set up secret rotation configurations          |
| `edit`                       | Modify secret rotation configurations          |
| `rotate-secrets`             | Rotate the generated credentials of a rotation |
| `delete`                     | Remove secret rotation configurations          |

#### Subject: `secret-syncs`

Supports conditions and permission inversion.

| Action           | Description                                        |
| ---------------- | -------------------------------------------------- |
| `read`           | View secret synchronization configurations         |
| `create`         | Create new sync configurations                     |
| `edit`           | Modify existing sync settings                      |
| `delete`         | Remove sync configurations                         |
| `sync-secrets`   | Execute synchronization of secrets between systems |
| `import-secrets` | Import secrets from sync sources                   |
| `remove-secrets` | Remove secrets from sync destinations              |

#### Subject: `dynamic-secrets`

Supports conditions and permission inversion

| Action                   | Description                        |
| ------------------------ | ---------------------------------- |
| `read-root-credential`   | View dynamic secret configurations |
| `create-root-credential` | Create dynamic secrets             |
| `edit-root-credential`   | Edit dynamic secrets               |
| `delete-root-credential` | Remove dynamic secrets             |
| `lease`                  | Create dynamic secret leases       |

### Key Management Service (KMS)

#### Subject: `kms`

| Action | Description                 |
| ------ | --------------------------- |
| `edit` | Modify project KMS settings |

#### Subject: `cmek`

| Action    | Description                           |
| --------- | ------------------------------------- |
| `read`    | View Customer-Managed Encryption Keys |
| `create`  | Add new encryption keys               |
| `edit`    | Modify key properties                 |
| `delete`  | Remove encryption keys                |
| `encrypt` | Use keys for encryption operations    |
| `decrypt` | Use keys for decryption operations    |

### Public Key Infrastructure (PKI)

#### Subject: `certificate-authorities`

| Action   | Description                        |
| -------- | ---------------------------------- |
| `read`   | View certificate authorities       |
| `create` | Create new certificate authorities |
| `edit`   | Modify CA configurations           |
| `delete` | Remove certificate authorities     |

#### Subject: `certificates`

| Action             | Description                   |
| ------------------ | ----------------------------- |
| `read`             | View certificates             |
| `read-private-key` | Read certificate private key  |
| `create`           | Issue new certificates        |
| `delete`           | Revoke or remove certificates |

#### Subject: `certificate-profiles`

| Action       | Description                     |
| ------------ | ------------------------------- |
| `read`       | View certificate profiles       |
| `create`     | Create new certificate profiles |
| `edit`       | Modify profile configurations   |
| `delete`     | Remove certificate profiles     |
| `issue-cert` | Issue new certificates          |

#### Subject: `certificate-templates`

| Action   | Description                      |
| -------- | -------------------------------- |
| `read`   | View certificate templates       |
| `create` | Create new certificate templates |
| `edit`   | Modify template configurations   |
| `delete` | Remove certificate templates     |

#### Subject: `pki-alerts`

| Action   | Description                                                  |
| -------- | ------------------------------------------------------------ |
| `read`   | View PKI alert configurations                                |
| `create` | Create new alerts for certificate expiry or other PKI events |
| `edit`   | Modify alert settings                                        |
| `delete` | Remove PKI alerts                                            |

#### Subject: `pki-collections`

| Action   | Description                                         |
| -------- | --------------------------------------------------- |
| `read`   | View PKI resource collections                       |
| `create` | Create new collections for organizing PKI resources |
| `edit`   | Modify collection properties                        |
| `delete` | Remove PKI collections                              |

### SSH Certificate Management

#### Subject: `ssh-certificate-authorities`

| Action   | Description                            |
| -------- | -------------------------------------- |
| `read`   | View SSH certificate authorities       |
| `create` | Create new SSH certificate authorities |
| `edit`   | Modify SSH CA configurations           |
| `delete` | Remove SSH certificate authorities     |

#### Subject: `ssh-certificates`

| Action   | Description                       |
| -------- | --------------------------------- |
| `read`   | View SSH certificates             |
| `create` | Issue new SSH certificates        |
| `edit`   | Modify SSH certificate properties |
| `delete` | Revoke or remove SSH certificates |

#### Subject: `ssh-certificate-templates`

| Action   | Description                          |
| -------- | ------------------------------------ |
| `read`   | View SSH certificate templates       |
| `create` | Create new SSH certificate templates |
| `edit`   | Modify SSH template configurations   |
| `delete` | Remove SSH certificate templates     |

### Secret Scanning

#### Subject: `secret-scanning-data-sources`

| Action                       | Description                      |
| ---------------------------- | -------------------------------- |
| `read-data-sources`          | View Data Sources                |
| `create-data-sources`        | Create new Data Sources          |
| `edit-data-sources`          | Modify Data Sources              |
| `delete-data-sources`        | Remove Data Sources              |
| `read-data-source-resources` | View Data Source Resources       |
| `read-data-source-scans`     | View Data Source Scans           |
| `trigger-data-source-scans`  | Trigger Data Source Secret Scans |

#### Subject: `secret-scanning-findings`

| Action            | Description                     |
| ----------------- | ------------------------------- |
| `read-findings`   | View Secret Scanning Findings   |
| `update-findings` | Update Secret Scanning Findings |

#### Subject: `secret-scanning-configs`

| Action           | Description                                  |
| ---------------- | -------------------------------------------- |
| `read-configs`   | View Secret Scanning Project Configuration   |
| `update-configs` | Update Secret Scanning Project Configuration |


# Security
Source: https://infisical.com/docs/internals/security

Infisical's security model includes many considerations and initiatives.

As a security infrastructure platform dealing with highly-sensitive data, Infisical follows a robust security model with the goal of ensuring the security and integrity of all its managed data and associated components.

As part of the security model, data at rest and in transit must be secure from eavesdropping or tampering, clients must be authenticated and authorized to access data, and all operations in the platform are audited and can be traced back to their source.

This page documents security measures used by [Infisical](https://github.com/Infisical/infisical), the software, and [Infisical Cloud](https://infisical.com/), a separate managed service offering for the software.

## Threat model

Infisicals (the software) threat model spans communication, storage, response mechanisms, and more.

* Eavesdropping on communications: Infisical secures client communication with the server and from the server to the storage backend.
* Tampering with data (at rest or in transit): Infisical implements data integrity checks to detect tampering. If inconsistencies are found, Infisical aborts transactions and raises alerts.
* Unauthorized access (lacking authentication/authorization): Infisical mandates rigorous authentication and authorization checks for all inbound requests; it also offers multi-factor authentication and role/attribute-based access controls.
* Actions without accountability: Infisical logs events, including policy updates, queries/mutations applied to secrets, certificates, and more. Every event is timestamped and information about actor, source (i.e. IP address, user-agent, etc.), and relevant metadata is included.
* Breach of data storage confidentiality: Infisical encrypts all stored secrets using proven cryptographic techniques for symmetric encryption.
* Unrecognized suspicious activities: Infisical monitors for any anomalous activities such as authentication attempts from previously unseen sources.
* Unidentified system vulnerabilities: Infisical undergoes penetration tests and vulnerability assessments twice a year; we act on findings to bolster the systems defense mechanisms.

Infisical (the software) does not consider the following as part of its threat model:

* Uncontrolled access to the storage mechanism: An attacker with unfettered access to the storage system can manipulate data in unpredictable ways, including erasing or tampering with stored secrets. Furthermore, the attacker could potentially implement state rollbacks to favor their objectives.
* Disclosure of secret presence: If an adversary gains read access to the storage backend, they might discern the existence of certain secrets, even if the actual contents remain encrypted and concealed.
* Runtime memory intrusion: An attacker with capabilities to probe the memory state of a live instance of Infisical can potentially compromise data confidentiality.
* Vulnerabilities in affiliated systems: Some functionality may rely on third-party services and dependencies. Security lapses in these dependencies can indirectly jeopardize the confidentiality or integrity of the secrets.
* Breaches via compromised clients: If a system or application accessing Infisical is compromised, and its credentials to the platform are exposed, an attacker might gain access at the privilege level of that compromised entity.
* Configuration tampering by administrators: Any configuration data, whether supplied through admin interfaces or configuration files, needs scrutiny. If an attacker can manipulate these configurations, it poses risks to data confidentiality and integrity.
* Physical access to deployment infrastructure: An attacker with physical access to the servers or infrastructure where Infisical is deployed can potentially compromise the system in ways that are challenging to guard against, such as direct hardware tampering or booting from malicious media.
* Social engineering attacks on personnel: Attacks that target personnel, tricking them into divulging sensitive information or performing compromising actions, fall outside the platforms direct defensive purview.

Note that while these points fall outside the Infisicals threat model, they remain considerations in the broader platform architecture.

## External threat overview

Infisicals architecture consists of various systems which together we refer to as the Infisical platform:

* Server: The Infisical API that serves requests.
* Clients: The Web UI and other applications that send requests to the server.
* Storage backend: PostgreSQL used by the server to persist data.
* Redis: Used by Infisical for caching, queueing and cron job scheduling.

The server requires clients to be authenticated and authorized for every inbound request. If using [Infisical Cloud](https://infisical.com/), all traffic is routed through [Cloudflare](https://www.cloudflare.com/) which enforces TLS and requires a minimum of TLS 1.2.

The server mandates that each request includes a valid token (issued for a user or machine identity) used to identify the client before performing any actions on the platform. Clients without a valid token can only access login endpoints with the exception of a few intentionally unauthenticated endpoints. For tokens issued for machine identities, Infisical provides significant configuration, including support for native authentication methods (e.g. [AWS](https://infisical.com/docs/documentation/platform/identities/aws-auth), [Azure](https://infisical.com/docs/documentation/platform/identities/azure-auth), [Kubernetes](https://infisical.com/docs/documentation/platform/identities/kubernetes-auth), etc.); custom TTLs to restrict token lifespan; IP restrictions to enforce network-based access controls; and usage caps to limit the maximum number of times that a token can be used.

When accessing Infisical via web browser, JWT tokens are stored in browser memory and appended to outbound requests requiring authentication; refresh tokens are stored in HttpOnly cookies and included in requests as part of token renewal. Note also that Infisical utilizes the latest HTTP security headers and employs a strict Content-Security-Policy to mitigate XSS.

To mitigate abuse and enhance system stability, the server enforces configurable rate limiting on read, write, and secrets operations. This prevents excessive API requests from impacting system performance while ensuring fair usage across clients.

Once traffic enters the server, any sensitive data (e.g. secrets, certificates entering the server), where applicable, is encrypted using a 256-bit [Advanced Encryption Standard (AES)](https://en.wikipedia.org/wiki/Advanced_Encryption_Standard) cipher in the [Galois Counter Mode (GCM)](https://en.wikipedia.org/wiki/Galois/Counter_Mode) with 96-bit nonces prior to being persisted in the storage backend. Encryption is an integral part of Infisicals platform-wide cryptographic architecture, which also supports seal-wrapping with external KMS and HSMs. Before responding to a client request, the server securely retrieves and decrypts requested data from the storage backend. Each decryption operation includes integrity verification to ensure data has not been altered or tampered with.

## Internal threat overview

Within Infisical, an internal threat and critical security concern is an attacker gaining access to sensitive data that they are not permitted to, especially if they are able to authenticate with some degree of access to the system.

Before a client can perform any actions on the platform, it must authenticate with the server using a supported authentication method such as username-password, SAML, SSO, LDAP, AWS/GCP/Azure, OIDC, or Kubernetes authentication. A successful authentication results in the issuance of a client (JWT) token containing a reference to the user or machine identity bound to it.

When a client uses the token to make authenticated requests against the server, Infisical validates the token and maps the bound-identity to access control policies that exist at the organization and project level, both types of namespaces within the platform. The access control policies are configured by operators of Infisical ahead of time and may involve role-based, attribute-based, and one-off additional privilege resource constraints. Given the robustness of the access control system, we recommend reading the full documentation for it.

For example, an operator of Infisical may define the following constraints to restrict client access to particular resources:

* Read and write access to a secret resource via an additional privilege attached to the bound-identity.
* Read-only access to a secret resource via one or multiple roles attached to the bound-identity.
* Read-only access to a secret resource via a group membership for which the associated bound-identity is part of; the group itself is assigned one or multiple roles with access to the secret resource.

## Cryptography

All symmetric encryption operations, with the exception of those proxied through external KMS and HSM systems, in Infisical use a software-backed, 256-bit Advanced Encryption Standard (AES) cipher in the Galois Counter Mode (GCM) with 96-bit nonces  AES-256-GCM.

Infisical employs a multilayer approach to its encryption architecture with components that can be optionally linked to external KMS or HSM systems. At a high-level, a master key, backed by an operator-provided key, is used to encrypt (internal) KMS keys that are used to then encrypt data keys; the data keys are used to protect sensitive data stored in Infisical. The keys in the architecture are stored encrypted in the storage backend, retrieved, decrypted, and only then used as part of server operations when needed. Since server configuration is needed to decrypt any keys as part of the encryption architecture, accessing any sensitive data in Infisical requires access to both server configuration and data in the storage backend. Note that the platforms encryption architecture has components that can be linked to external KMS and HSM systems; opting for these make the use of the software more FIPS aligned.

To be specific:

* The architecture starts with a 256-bit master key that can be secured by a root key which can either be a 128-bit key, passed into the server by an operator of Infisical as an environment variable, or an external key from an HSM module such as [Thales Luna HSM](https://cpl.thalesgroup.com/encryption/data-protection-on-demand/services/luna-cloud-hsm) or [AWS Cloud HSM](https://aws.amazon.com/cloudhsm/) linked via specified configuration parameters.
* The master key secures 256-bit keys in Infisical henceforth referred to as KMS keys.
* Each organization in Infisical has its own KMS key and a separate data key; the KMS key is used to secure the data key which encrypts organization-level data.
* Each project in Infisical has a designated KMS key and a separate data key; the KMS key is used to secure the data key which encrypts project-level data. Note that a project KMS key can be substituted for an external key from a KMS such as [AWS KMS](https://infisical.com/docs/documentation/platform/kms-configuration/aws-kms), [AWS Cloud HSM](https://infisical.com/docs/documentation/platform/kms-configuration/aws-hsm), and [GCP KMS](https://infisical.com/docs/documentation/platform/kms-configuration/gcp-kms). We recommend reading the fuller [documentation](https://infisical.com/docs/documentation/platform/kms-configuration/overview) or integrating with an external KMS

## Infrastructure & High availability (Infisical Cloud)

Infisical Cloud uses a number of strategies to keep services running smoothly and ensure data stays available, even during failures; we document these strategies below:

* Multi-AZ AWS RDS: Infisical Cloud runs AWS Relational Database Service (RDS) with Multi-AZ deployments to improve availability and durability. This setup keeps a standby replica in a different Availability Zone (AZ) and automatically fails over if the primary instance goes down. Continuous backups and replication help protect data and minimize interruptions.
* Multi-AZ ElastiCache (Redis): For caching, Infisical Cloud runs Amazon ElastiCache (Redis) in a Multi-AZ setup. This means data is replicated across different AZs, so if one goes down, the system can automatically fail over to a healthy node. This helps keep response times low and ensures caching stays reliable.
* Multi-AZ ECS for Container Orchestration: Infisical Cloud runs on Amazon Elastic Container Service (ECS) across multiple availability zones, making sure containers stay available even if an AZ fails. If one zone has an issue, traffic automatically shifts to healthy instances in other zones, keeping downtime to a minimum.

Infisical Cloud utilizes several strategies to ensure high availability, leveraging AWS services to maintain continuous operation and data integrity.

## Cross-Region Replication for Disaster Recovery (Infisical Cloud)

To handle regional failures, Infisical Cloud keeps backups both within AWS and across cloud providers in GCP updated and ready to take over when needed.

* ElastiCache (Redis): Data is replicated across regions using AWS Global Datastore, keeping cached data consistent and available even if a primary region goes down.
* RDS (PostgreSQL): Cross-region read replicas ensure database data is available in multiple AWS locations, with additional replication to GCP for multi-cloud disaster recovery, allowing for failover in case of a regional outage or cloud provider issues.

## Penetration testing

Infisical hires external third parties to perform regular security assessment and penetration testing of the platform.

Most recently, Infisical commissioned cybersecurity firm [Cure53](https://cure53.de/) to perform a full-coverage, gray box penetration test against the platform's entire attack surface to identify vulnerabilities according to industry standards (OWASP, ASVS, WSTG, TOP-10, etc.).

Please email [security@infisical.com](mailto:security@infisical.com) to request any reports including a letter of attestation for the conducted penetration test.

## Employee data access

Whether or not Infisical or your employees can access data in the Infisical instance and/or storage backend depends on many factors how you use Infisical:

* Infisical Self-Hosted: Self-hosting Infisical is common amongst organizations that prefer to keep data on their own infrastructure usually to adhere to strict regulatory and compliance requirements. In this option, organizations retain full control over their data and therefore govern the data access policy of their Infisical instance and storage backend.
* Infisical Cloud: Using Infisical's managed service, [Infisical Cloud](https://app.infisical.com) means delegating data oversight and management to Infisical. Under our policy controls, employees are only granted access to parts of infrastructure according to principle of least privilege; this is especially relevant to customer data can only be accessed currently by executive management of Infisical. Moreover, any changes to sensitive customer data is prohibited without explicit customer approval.

It should be noted that, even on Infisical Cloud, it is physically impossible for employees of Infisical to view the values of secrets if users have not explicitly granted Infisical access to their project (i.e. opted out of zero-knowledge).

Please email [security@infisical.com](mailto:security@infisical.com) if you have any specific inquiries about employee data and security policies.


# Service tokens
Source: https://infisical.com/docs/internals/service-tokens

Understanding service tokens and their best practices.


Many clients use service tokens to authenticate and read/write secrets from/to Infisical; they can be created in your project settings.

## Anatomy

A service token in Infisical consists of the token itself, a `string`, and a corresponding document in the storage backend containing its
properties and metadata.

### Database model

The storage backend model for a token contains the following information:

* ID: The token identifier.
* Expiration: The date at which point the token is invalid.
* Project: The project that the token is part of.
* Scopes: The project environments and paths that the token has access to.
* Encrypted project key: An encrypted copy of the project key.

### Token

A service token itself consist of two parts used for authentication and decryption, separated by the delimiter `.`.

Consider the token `st.abc.def.ghi`. Here, `st.abc.def` can be used to authenticate with the API, by including it in the `Authorization` header under `Bearer st.abc.def`, and retrieve (encrypted) secrets as well as a project key back. Meanwhile, `ghi`, a hex-string, can be used to decrypt the project key used to decrypt the secrets.

Note that when using service tokens via select client methods like SDK or CLI, cryptographic operations are abstracted for you that is the token is parsed and encryption/decryption operations are handled. If using service tokens with the REST API and end-to-end encryption enabled, then you will have to handle the encryption/decryption operations yourself.


## Recommendations

### Issuance

When creating a new service token, its important to consider the principle of least privilege(PoLP) when setting its scope and expiration date. For example, if the client using the token only requires access to a staging environment, then you should scope the token to that environment only; you can further scope tokens to path(s) within environment(s) if you happen to use path-based secret storage. Likewise, if the client does not intend to access secrets indefinitely, then you may consider setting a finite lifetime for the token such as 6 months or 1 year from now. Finally, you should consider carefully whether or not your client requires the ability to read and/or write secrets from/to Infisical.

### Network access

We recommend configuring the IP whitelist settings of each project to allow either single IP addresses or CIDR-notated range of addresses to read/write secrets to Infisical. With this feature, you can specify the IP range of your client servers to restrict access to your project in Infisical.

### Storage

Since service tokens grant access to your secrets, we recommend storing them securely across your development cycle whether it be in a .env file in local development or as an environment variable of your deployment platform.

### Rotation

We recommend periodically rotating the service token, even in the absence of compromise. Since service tokens are capable of decrypting project keys used to decrypt secrets, all of which use AES-256-GCM encryption, they should be rotated before approximately 2^32 encryptions have been performed; this follows the guidance set forth by [NIST publication 800-38D](https://csrc.nist.gov/pubs/sp/800/38/d/final).

Note that Infisical keeps track of the number of times that service tokens are used and will alert you when you have reached 90% of the recommended capacity.


# Infisical C++ SDK
Source: https://infisical.com/docs/sdks/languages/cpp



If you're working with C++, the official Infisical C++ SDK package is the easiest way to fetch and work with secrets for your application.

## Compatible with C++ 17 and later

The Infisical C++ SDK is compatible with C++ 17 capable compilers. This implies GCC 8 or newer, and clang 3.8 or newer. Earlier versions of C++ are unsupported.

## Dependencies

* `cURL`: Used internally for crafting HTTP requests.

## CMake Installation

```bash  theme={"dark"}
cmake_minimum_required(VERSION 3.14)
project(InfisicalTest)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_PREFIX_PATH ${CMAKE_BINARY_DIR})

find_package(OpenSSL REQUIRED)


include(FetchContent)


FetchContent_Declare(
  infisical
  GIT_REPOSITORY https://github.com/Infisical/infisical-cpp-sdk.git
  GIT_TAG 1.0.0 # Replace with the desired version
)

FetchContent_MakeAvailable(infisical)
FetchContent_GetProperties(infisical)


# Example usage. This will differ based on your project structure.
add_executable(my_app src/main.cpp)
target_link_libraries(my_app PRIVATE infisical OpenSSL::SSL OpenSSL::Crypto)
target_include_directories(my_app PRIVATE ${infisical_SOURCE_DIR}/include)
```

## Manual Installation

If you're unable to use the recommended CMake installation approach, you can choose to manually build the library and use it in your project.

```bash  theme={"dark"}
mkdir build
cd build
cmake ..
make
```

## Quick-Start Example

Below you'll find an example that uses the Infisical SDK to fetch a secret with the key `API_KEY` using [Machine Identity Universal Auth](https://infisical.com/docs/documentation/platform/identities/universal-auth)

More examples can be found in the [/examples](https://github.com/Infisical/infisical-cpp-sdk/tree/main/examples) folder.

```cpp  theme={"dark"}
#include <iostream>
#include <libinfisical/InfisicalClient.h>

int main() {

  try {
    Infisical::InfisicalClient client(
        Infisical::ConfigBuilder()
            .withHostUrl("https://app.infisical.com") // Optionally change this to your custom Infisical instance URL.
            .withAuthentication(
                Infisical::AuthenticationBuilder()
                    .withUniversalAuth("<machine-identity-universal-auth-client-id>", "<machine-identity-universal-auth-client-secret>")
                    .build())
            .build());

    const auto getSecretOptions = Infisical::Input::GetSecretOptionsBuilder()
                                      .withEnvironment("<env-slug>") // dev, staging, prod, etc
                                      .withProjectId("<your-project-id>")
                                      .withSecretKey("API_KEY")
                                      .build();

    const auto apiKeySecret = client.secrets().getSecret(getSecretOptions);

    printf("Secret retrieved, [key=%s] [value=%s]\n", apiKeySecret.getSecretKey().c_str(), apiKeySecret.getSecretValue().c_str());
  } catch (const Infisical::InfisicalError &e) {
    std::cerr << "Error: " << e.what() << std::endl;
    return 1;
  }

  return 0;
}
```

## JSON Serialization

The SDK uses [nlohmann/json](https://github.com/nlohmann/json) internally to serialize/deserialize JSON data. This SDK makes no assumptions about which JSON library you use in your project, and you aren't constrained to `nlohmann/json` in any way. Data returned by the SDK is returned as a class, which exposes Getter methods for getting fields such as the secret value or secret key.

## Documentation

The Infisical C++ SDK follows a builder pattern for all types of input. Below is a detailed documentation of our currently support methods.

Everything related to the Infisical SDK lives inside the `Infisical` namespace.

### InfisicalClient Class

`InfisicalClient(Config &config)`

```cpp  theme={"dark"}
  Infisical::InfisicalClient client(
      Infisical::ConfigBuilder()
          .withHostUrl("https://app.infisical.com")
          .withAuthentication(
              Infisical::AuthenticationBuilder()
                  .withUniversalAuth(clientId, clientSecret)
                  .build())
          .build());
```

Config is created through the `ConfigBuilder` class. See below for more details

### Config Class

`Config` defines the configuration of the Infisical Client itself, such as authentication.

```cpp  theme={"dark"}
Infisical::Config config = Infisical::ConfigBuilder()
                          .withHostUrl("https://app.infisical.com")
                          .withAuthentication(
                            Infisical::AuthenticationBuilder()
                              .withUniversalAuth(clientId, clientSecret)
                              .build())
                          .build();

Infisical::InfisicalClient client(config);
```

* `withHostUrl(string)` *(optional)*: Specify a custom Infisical host URL, pointing to your Infisical instance. Defaults to `https://app.infisical.com`
* `withAuthentication(Infisical::Authentication)`: Configure the authentication that will be used by the SDK. See [Authentication Class](#authentication-class) for more details.
* `build()`: Returns the `Config` object with the options you configured.

### Authentication Class

```cpp  theme={"dark"}
Infisical::Authentication auth = Infisical::AuthenticationBuilder()
                                  .withUniversalAuth(clientId, clientSecret)
                                  .build();

Infisical::Config config = Infisical::ConfigBuilder()
                            .withAuthentication(std::move(auth)) // Or use inline declaration
                            .build();
```

* `withUniversalAuth(string, string)`: Specify the Universal Auth Client ID and Client Secret that will be used for authentication.
* `build()`: Returns the `Authentication` object with the options you specified.

### TSecret Class

The `TSecret` class is the class that's returned by all secret methods (get/list/delete/update/create). It can come in the form of a `std::vector` or a single instance.

**Available getter methods:**

* `getId(): std::string`: Returns the ID of the secret.
* `getWorkspace(): std::string`: Returns the project ID of the secret.
* `getEnvironment(): std::string`: Returns the environment slug of the secret.
* `getVersion(): unsigned int`: Gets the version of the secret. By default this will always be the latest version unless specified otherwise with `withVersion()`
* `getType(): std::string`: Returns the type of the secret. Can only be `shared` or `personal`. Shared secrets are available to everyone with access to the secret. Personal secrets are personal overwrites of the secret, mainly intended for local development purposes.
* `getSecretKey(): std::string`: Returns the secret key.
* `getSecretValue(): std::string` Returns the secret value.
* `getRotationId(): std::string`: If the secret is a rotation secret, this will return the rotation ID of the secret. If it's a regular secret, this will return an empty string.
* `getSecretPath(): std::string`: Returns the secret path of the secret.
* `getSkipMultilineEncoding(): bool`: Returns whether or not skip multiline encoding is enabled for the secret or not.
  `getIsRotatedSecret(): bool`: Returns wether or not the secret is a rotated secret. If `true`, then `getRotationId()` returns the ID of the rotation.

### Secrets

#### Create Secret

```cpp  theme={"dark"}
const auto createSecretOptions = Infisical::Input::CreateSecretOptionsBuilder()
                                  .withEnvironment("<env-slug>")
                                  .withProjectId("<project-id>")
                                  .withSecretKey("SECRET_KEY_TO_CREATE")
                                  .withSecretValue("VALUE_TO_CREATE")
                                  .withSecretComment("Secret comment to attach") // Optional
                                  .withSecretPath("/path/where/to/create/secret") // Optional, defaults to /
                                  .withTagIds({"tag-id-1", "tag-id-2"}) // Optional
                                  .build();

const auto secret = client.secrets().createSecret(createSecretOptions);
```

**Parameters**:

* `withEnvironment(string)`: Specify the slug of the environment to create the secret in.
* `withProjectId(string)`: Specify the ID of the project to create the secret in.
* `withSecretPath(string)`: Specify the secret path to create the secret in. Defaults to `/`
* `withSecretKey(string)`: The secret key to be created.
* `withSecretValue(string)`: The value of the secret to create.
* `withSecretComment(string)` *(optional)*: Optionally add a comment to the secret.
* `withTagIds(std::vector<std::string>>)` *(optional)*: A list of ID's of tags to attach to the secret.
* `build()`: Returns the `CreateSecretOptions` class that can be passed into the `createSecret()` method.

**Returns**:

* Returns the created secret as a `TSecret` class. Read more in the [TSecret Class](#tsecret-class) documentation.

#### Update Secret

```cpp  theme={"dark"}
  const auto updateSecretOptions = Infisical::Input::UpdateSecretOptionsBuilder()
                                    .withEnvironment("<env-slug>")
                                    .withProjectId("<project-id>")
                                    .withSecretKey("<secret-key>") 
                                    .withNewSecretKey("<new-secret-key>") // Optional
                                    .withSecretValue("<new-secret-value>") // Optional
                                    .withSecretComment("Updated comment") // Optional
                                    .withSecretReminderNote("Updated reminder note") // Optional
                                    .withSecretReminderRepeatDays(1) // Optional
                                    .withType("shared") // Optional
                                    .withTagIds({"tag-id-3", "tag-id-4"}) // Optional
                                    .build();

const auto updatedSecret = client.secrets().updateSecret(updateSecretOptions);
```

**Parameters**:

* `withEnvironment(string)`: Specify the slug of the environment where the secret lives in.
* `withProjectId(string)`: Specify the ID of the project where the secret to update lives in.
* `withSecretPath(string)`: Specify the secret path of the secret to update. Defaults to `/`.
* `withType("shared" | "personal")`: *(optional)*: The type of secret to update. Defaults to `shared`.
* `withSecretKey(string)`: The key of the secret you wish to update.
* `withNewSecretKey(string)` *(optional)*: The new key of the secret you wish to update.
* `withSecretValue(string)` *(optional)*: The new value of the secret.
* `withSecretReminderNote(string)` *(optional)*: Update the secret reminder note attached to the secret.
* `withSecretReminderRepeatDays(unsigned int)` *(optional)*: Update the secret reminder repeat days attached to the secret.
* `withTagIds(std::vector<std::string>>)` *(optional)*: A list of ID's of tags to attach to the secret.
* `build()`: Returns the `UpdateSecretOptions` class that can be passed into the `updateSecret()` method.

**Returns**:

* Returns the updated secret as a `TSecret` class. Read more in the [TSecret Class](#tsecret-class) documentation.

#### Get Secret

```cpp  theme={"dark"}
const auto getSecretOptions = Infisical::Input::GetSecretOptionsBuilder()
                                .withEnvironment("<env-slug>")
                                .withProjectId("<project-id>")
                                .withSecretKey("<secret-key>") 
                                .withType("shared")
                                .withVersion(2)
                                .withExpandSecretReferences(true)    
                                .build();

const auto secret = client.secrets().getSecret(getSecretOptions);
```

**Parameters**:

* `withEnvironment(string)`: Specify the slug of the environment where the secret lives in.
* `withProjectId(string)`: Specify the ID of the project where the secret lives in.
* `withSecretPath(string)`: Specify the secret path of the secret to get. Defaults to `/`
* `withType("shared" | "personal")`: *(optional)*: The type of secret to get. Defaults to `shared`.
* `withSecretKey(string)`: The key of the secret to get.
* `withExpandSecretReferences(bool)` *(optional)*: Whether or not to expand secret references automatically. Defaults to `true`.
* `withVersion(unsigned int)` *(optional)*: Optionally fetch a specific version of the secret. If not defined, the latest version of the secret is returned.
* `build()`: Returns the `GetSecretOptions` class that can be passed into the `getSecret()` method.

**Returns**:

* Returns the secret as a `TSecret` class. Read more in the [TSecret Class](#tsecret-class) documentation.

#### Delete Secret

```cpp  theme={"dark"}
const auto deleteSecretOptions = Infisical::Input::DeleteSecretOptionsBuilder()
                                  .withEnvironment("<env-slug>")
                                  .withProjectId("<project-id>")
                                  .withSecretKey("<secret-key>")
                                  .withType("shared")
                                  .withSecretPath("<secret-path>")
                                  .build();

const auto deletedSecret = client.secrets().deleteSecret(deleteSecretOptions);
```

**Parameters**:

* `withEnvironment(string)`: Specify the slug of the environment where the secret to delete lives in.
* `withProjectId(string)`: Specify the ID of the project where the secret to delete lives in.
* `withSecretPath(string)`: Specify the secret path of the secret to delete. Defaults to `/`
* `withType("shared" | "personal")`: *(optional)*: The type of secret to delete. Defaults to `shared`.
* `withSecretKey(string)`: The key of the secret to delete.
* `build()` Returns the `DeleteSecretOptions` class that can be passed into the `deleteSecret()` method.

**Returns**:

* Returns the deleted secret as a `TSecret` class. Read more in the [TSecret Class](#tsecret-class) documentation.

#### List Secrets

```cpp  theme={"dark"}
const auto listSecretsOptions = Infisical::Input::ListSecretOptionsBuilder()
                                  .withProjectId(projectId)
                                  .withEnvironment(environment)
                                  .withSecretPath("/")
                                  .withRecursive(false)
                                  .withAddSecretsToEnvironmentVariables(false)
                                  .build();

const auto secrets = client.secrets().listSecrets(listSecretsOptions);

```

**Parameters**:

* `withEnvironment(string)`: Specify the slug of the environment to list secrets from.
* `withProjectId(string)`: Specify the ID of the project to fetch secrets from.
* `withSecretPath(string)`: Specify the secret path to fetch secrets from. Defaults to `/`
* `withExpandSecretReferences(bool)` *(optional)*: Whether or not to expand secret references automatically. Defaults to `true`.
* `withRecursive(bool)` *(optional)*: Wether or not to recursively fetch secrets from sub-folders. If set to true, all secrets from the secret path specified with `withSecretPath()` and downwards will be fetched.
* `withAddSecretsToEnvironmentVariables(bool)` *(optional)*: If set to true, the fetched secrets will be automatically set as environment variables, making them accessible with `std::getenv` or equivalent by secret key.
* `build()`: Returns the `ListSecretsOptions` class that can be passed into the `listSecrets()` method.

**Returns**:

* Returns the listed secrets as `std::vector<TSecret>`. Read more in the [TSecret Class](#tsecret-class) documentation.


# Infisical .NET SDK
Source: https://infisical.com/docs/sdks/languages/dotnet



If you're working with .NET, the official Infisical .NET SDK package is the easiest way to fetch and work with secrets for your application.

## Installation

```bash  theme={"dark"}
dotnet add package Infisical.Sdk
```

## Getting Started (.NET)

```csharp  theme={"dark"}
namespace Example;

using Infisical.Sdk;
using Infisical.Sdk.Model;

public class Program {
  public static void Main(string[] args) {

    var settings = new InfisicalSdkSettingsBuilder()
        .WithHostUri("http://localhost:8080") // Optional. Will default to https://app.infisical.com
        .Build();

    var infisicalClient = new InfisicalClient(settings);

    var _ = infisicalClient.Auth().UniversalAuth().LoginAsync("<machine-identity-universal-auth-client-id>", "<machine-identity-universal-auth-client-secret>").Result;

    var options = new ListSecretsOptions
    {
      SetSecretsAsEnvironmentVariables = true,
      EnvironmentSlug = "<your-env-slug>",
      SecretPath = "/",
      ProjectId = "<your-project-id>",
    };

    var secrets = infisicalClient.Secrets().ListAsync(options).Result;

    if (secrets == null)
    {
      throw new Exception("Failed to fetch secrets, returned null response");
    }

    foreach (var secret in secrets)
    {
      Console.WriteLine($"{secret.SecretKey}: {secret.SecretValue}");
    }
  }
}
```

## Getting Started (Visual Basic)

```vb  theme={"dark"}
Imports Infisical.Sdk
Imports Infisical.Sdk.Model

Module Program
    Sub Main(args As String())
        Dim settings = New InfisicalSdkSettingsBuilder() _
            .WithHostUri("https://app.infisical.com") _
            .Build()
        
        Dim infisicalClient As New InfisicalClient(settings)

        Dim authResult = infisicalClient.Auth().UniversalAuth() _
          .LoginAsync("<machine-identity-universal-auth-client-id>", "machine-identity-universal-auth-client-secret").Result

        Dim options As New ListSecretsOptions With {
          .SetSecretsAsEnvironmentVariables = True,
          .EnvironmentSlug = "<your-env-slug>",
          .SecretPath = "/",
          .ProjectId = "<your-project-id>"
        }

        Dim secrets = infisicalClient.Secrets().ListAsync(options).Result

        For Each secret In secrets
            Console.WriteLine(secret.SecretKey)
            if Environment.GetEnvironmentVariable(secret.SecretKey) IsNot Nothing Then
                Console.WriteLine("{0} found on environment variables", secret.SecretKey)
            End If
        Next
        
    End Sub
End Module
```

## Core Methods

The SDK methods are organized into the following high-level categories:

1. `Auth()`: Handles authentication methods.
2. `Secrets()`: Manages CRUD operations for secrets.
3. `Pki()`: Programmatically interact with the Infisical PKI.
   * `Subscribers()`: Manage PKI Subscribers.

### `Auth()`

The `Auth()` component provides methods for authentication:

### Universal Auth

#### Authenticating

```cs  theme={"dark"}
var _ = await sdk.Auth().UniversalAuth().LoginAsync(
  "CLIENT_ID",
  "CLIENT_SECRET"
);
```

**Parameters:**

* `clientId` (string): The client ID of your Machine Identity.
* `clientSecret` (string): The client secret of your Machine Identity.

### `Secrets()`

The `Secrets()` sub-class handles operations related to the Infisical secrets management product.

#### List Secrets

```cs  theme={"dark"}
Task<Secret[]> ListAsync(ListSecretsOptions options);

throws InfisicalException
```

```csharp  theme={"dark"}
var options = new ListSecretsOptions
  {
    SetSecretsAsEnvironmentVariables = true,
    EnvironmentSlug = "dev",
    SecretPath = "/test",
    Recursive = true,
    ExpandSecretReferences = true,
    ProjectId = projectId,
    ViewSecretValue = true,
  };

Secret[] secrets = await sdk.Secrets().ListAsync(options);
```

**ListSecretsOptions:**

* `ProjectId` (string): The ID of your project.
* `EnvironmentSlug` (string): The environment in which to list secrets (e.g., "dev").
* `SecretPath` (string): The path to the secrets.
* `ExpandSecretReferences` (boolean): Whether to expand secret references.
* `Recursive` (boolean): Whether to list secrets recursively.
* `SetSecretsAsEnvironmentVariables` (boolean): Set the retrieved secrets as environment variables.

**Returns:**

* `Task<Secret[]>`: The response containing the list of secrets.

#### Create Secret

```cs  theme={"dark"}
public Task<Secret> CreateAsync(CreateSecretOptions options);

throws InfisicalException
```

```cs  theme={"dark"}

var options = new CreateSecretOptions
{
  SecretName = "SECRET_NAME",
  SecretValue = "SECRET_VALUE",
  EnvironmentSlug = "<environment-slug>",
  SecretPath = "/",
  ProjectId = "<your-project-id>",
  Metadata = new SecretMetadata[] {
    new SecretMetadata {
      Key = "metadata-key",
      Value = "metadata-value"
    }
  }
};

Task<Secret> newSecret = await sdk.Secrets().CreateAsync(options);
```

**Parameters:**

* `SecretName` (string): The name of the secret to create
* `SecretValue` (string): The value of the secret.
* `ProjectId` (string): The ID of your project.
* `EnvironmentSlug` (string): The environment in which to create the secret.
* `SecretPath` (string, optional): The path to the secret.
* `Metadata` (object, optional): Attach metadata to the secret.
* `SecretComment` (string, optional): Attach a secret comment to the secret.
* `SecretReminderNote` (string, optional): Attach a secret reminder note to the secret.
* `SecretReminderRepeatDays` (int, optional): Set the reminder repeat days on the secret.
* `SkipMultilineEncoding` (bool, optional): Whether or not to skip multiline encoding for the secret's value. Defaults to `false`.

**Returns:**

* `Task<Secret>`: The created secret.

#### Update Secret

```cs  theme={"dark"}
public Task<Secret> UpdateAsync(UpdateSecretOptions options); 

throws InfisicalException
```

```cs  theme={"dark"}

var updateSecretOptions = new UpdateSecretOptions
{
  SecretName = "EXISTING_SECRET_NAME",
  EnvironmentSlug = "<environment-slug>",
  SecretPath = "/",
  NewSecretName = "NEW_SECRET_NAME",
  NewSecretValue = "new-secret-value",
  ProjectId = "<project-id>",
};


Task<Secret> updatedSecret = await sdk.Secrets().UpdateAsync(updateSecretOptions);
```

**Parameters:**

* `SecretName` (string): The name of the secret to update.\`
* `ProjectId` (string): The ID of your project.
* `EnvironmentSlug` (string): The environment in which to update the secret.
* `SecretPath` (string): The path to the secret.
* `NewSecretValue` (string, optional): The new value of the secret.
* `NewSecretName` (string, optional): A new name for the secret.
* `NewMetadata` (object, optional): New metadata to attach to the secret.

**Returns:**

* `Task<Secret>`: The updated secret.

#### Get Secret by Name

```cs  theme={"dark"}
public Task<Secret> GetAsync(GetSecretOptions options);

throws InfisicalException
```

```cs  theme={"dark"}

var getSecretOptions = new GetSecretOptions
{
  SecretName = "SECRET_NAME",
  EnvironmentSlug = "<environment-slug>",
  SecretPath = "/",
  ProjectId = "<project-id>",
};

Secret secret = await sdk.Secrets().GetAsync(getSecretOptions);
```

**Parameters:**

* `SecretName` (string): The name of the secret to get\`
* `ProjectId` (string): The ID of your project.
* `EnvironmentSlug` (string): The environment in which to retrieve the secret.
* `SecretPath` (string): The path to the secret.
* `ExpandSecretReferences` (boolean, optional): Whether to expand secret references.
* `Type` (SecretType, optional): The type of secret to fetch. Defaults to `Shared`.

**Returns:**

* `Task<Secret>`: The fetched secret.

#### Delete Secret by Name

```cs  theme={"dark"}
public Secret DeleteAsync(DeleteSecretOptions options);

throws InfisicalException
```

```cs  theme={"dark"}

var options = new DeleteSecretOptions
{
  SecretName = "SECRET_TO_DELETE",
  EnvironmentSlug = "<environment-slug>",
  SecretPath = "/",
  ProjectId = "<project-id>",
};


Secret deletedSecret = await sdk.Secrets().DeleteAsync(options);
```

**Parameters:**

* `SecretName` (string): The name of the secret to delete.
* `ProjectId` (string): The ID of your project.
* `EnvironmentSlug` (string): The environment in which to delete the secret.
* `SecretPath` (string, optional): The path to the secret.

**Returns:**

* `Task<Secret>`: The deleted secret.

### `Pki().Subscribers()`

The `Pki().Subscribers()` sub-class is used to programmatically interact with the Infisical PKI product line. Currently only issuing new certificates and retrieving the latest certificate bundle from a subscriber is supported. More widespread support for the PKI product is coming to the .NET SDK in the near future.

#### Issue a new certificate

```cs  theme={"dark"}
public async Task<SubscriberIssuedCertificate> IssueCertificateAsync(IssueCertificateOptions options);

throws InfisicalException
```

```cs  theme={"dark"}

var options = new IssueCertificateOptions
{
  SubscriberName = "<subscriber-name>",
  ProjectId = "<your-project-id>",
};

SubscriberIssuedCertificate newCertificate = await sdk.Pki().Subscribers().IssueCertificateAsync(options);
```

**Parameters:**

* `SubscriberName` (string): The name of the subscriber to create a certificate for.
* `ProjectId` (string): The ID of PKI project.

**Returns:**

* `Task<SubscriberIssuedCertificate>`: The newly issued certificate along with it's credentials for the specified subscriber.

#### Retrieve latest certificate bundle

```cs  theme={"dark"}
public async Task<CertificateBundle> RetrieveLatestCertificateBundleAsync(RetrieveLatestCertificateBundleOptions options)

throws InfisicalException
```

```cs  theme={"dark"}
var options = new RetrieveLatestCertificateBundleOptions
{
  SubscriberName = "<subscriber-name>",
  ProjectId = "<your-project-id>",
};

CertificateBundle latestCertificate = await sdk.Pki().Subscribers().RetrieveLatestCertificateBundleAsync(options);
```

**Parameters:**

* `SubscriberName` (string): The name of the subscriber to retrieve the latest certificate bundle for
* `ProjectId` (string): The ID of PKI project.

**Returns:**

* `Task<CertificateBundle>`: The latest certificate bundle for the specified subscriber.


# Infisical Go SDK
Source: https://infisical.com/docs/sdks/languages/go



If you're working with Go, the official Infisical Go SDK package is the easiest way to fetch and work with secrets for your application.

* [Package](https://pkg.go.dev/github.com/infisical/go-sdk)
* [Github Repository](https://github.com/infisical/go-sdk)

# Basic Usage

```go  theme={"dark"}
package main

import (
  "fmt"
  "os"
  "context"
  infisical "github.com/infisical/go-sdk"
)

func main() {

	client := infisical.NewInfisicalClient(context.Background(), infisical.Config{
		SiteUrl: "https://app.infisical.com", // Optional, default is https://app.infisical.com
    AutoTokenRefresh: true, // Wether or not to let the SDK handle the access token lifecycle. Defaults to true if not specified.
	})

	_, err := client.Auth().UniversalAuthLogin("YOUR_CLIENT_ID", "YOUR_CLIENT_SECRET")

	if err != nil {
		fmt.Printf("Authentication failed: %v", err)
		os.Exit(1)
	}

	apiKeySecret, err := client.Secrets().Retrieve(infisical.RetrieveSecretOptions{
		SecretKey:   "API_KEY",
		Environment: "dev",
		ProjectID:   "YOUR_PROJECT_ID",
		SecretPath:  "/",
	})

	if err != nil {
		fmt.Printf("Error: %v", err)
		os.Exit(1)
	}

	fmt.Printf("API Key Secret: %v", apiKeySecret)

}
```

This example demonstrates how to use the Infisical Go SDK in a simple Go application. The application retrieves a secret named `API_KEY` from the `dev` environment of the `YOUR_PROJECT_ID` project.

<Warning>
  We do not recommend hardcoding your [Machine Identity
  Tokens](/documentation/platform/identities/machine-identities). Setting it as an environment variable
  would be best.
</Warning>

# Installation

```console  theme={"dark"}
$ go get github.com/infisical/go-sdk
```

# Configuration

Import the SDK and create a client instance.

```go  theme={"dark"}
client := infisical.NewInfisicalClient(context.Background(), infisical.Config{
		SiteUrl: "https://app.infisical.com", // Optional, default is https://api.infisical.com
	})
```

### Configuration Options

<ParamField query="options" type="object">
  <Expandable title="properties">
    <ParamField query="SiteUrl" type="string" optional default="https://app.infisical.com">
      The URL of the Infisical API..
    </ParamField>

    <ParamField query="UserAgent" type="string">
      Optionally set the user agent that will be used for HTTP requests. *(Not recommended)*
    </ParamField>

    <ParamField query="AutoTokenRefresh" type="boolean" default={true} optional>
      Whether or not to let the SDK handle the access token lifecycle. Defaults to true if not specified.
    </ParamField>

    <ParamField query="SilentMode" type="boolean" default={false} optional>
      Whether or not to suppress logs such as warnings from the token refreshing process. Defaults to false if not specified.
    </ParamField>

    <ParamField query="CacheExpiryInSeconds" type="number" default={0} optional>
      Defines how long certain responses should be cached in memory, in seconds. When set to a positive value, responses from specific methods (like secret fetching) will be cached for this duration. Set to 0 to disable caching.
    </ParamField>

    <ParamField query="CustomHeaders" type="map[string]string" optional>
      Allows you to pass custom headers to the HTTP requests made by the SDK. Expected format is a map of `Header1: Value1, Header2: Value 2`.
    </ParamField>
  </Expandable>
</ParamField>

# Automatic token refreshing

The Infisical Go SDK supports automatic token refreshing. After using one of the auth methods such as Universal Auth, the SDK will automatically renew and re-authenticate when needed.
This behavior is enabled by default, but you can opt-out by setting `AutoTokenRefresh` to `false` in the client settings.

```go  theme={"dark"}
  client := infisical.NewInfisicalClient(context.Background(), infisical.Config{
    AutoTokenRefresh: false, // <- Disable automatic token refreshing
  })
```

When using automatic token refreshing it's important to understand how your application uses the Infiiscal client. If you are instantiating new instances of the client often, it's important to cancel the context when the client is no longer needed to avoid the token refreshing process from running indefinitely.

```go  theme={"dark"}
  ctx, cancel := context.WithCancel(context.Background())
  defer cancel() // Cancel the context when the client is no longer needed

  client := infisical.NewInfisicalClient(ctx, infisical.Config{
    AutoTokenRefresh: true,
  })

  // Use the client
```

This is only necessary if you are creating multiple instances of the client, and those instances are deleted or otherwise removed throughout the application lifecycle.
If you are only creating one instance of the client, and it will be used throughout the lifetime of your application, you don't need to worry about this.

# Authentication

The SDK supports a variety of authentication methods. The most common authentication method is Universal Auth, which uses a client ID and client secret to authenticate.

#### Universal Auth

**Using environment variables**

Call `.Auth().UniversalAuthLogin()` with empty arguments to use the following environment variables:

* `INFISICAL_UNIVERSAL_AUTH_CLIENT_ID` - Your machine identity client ID.
* `INFISICAL_UNIVERSAL_AUTH_CLIENT_SECRET` - Your machine identity client secret.

**Using the SDK directly**

```go  theme={"dark"}
_, err := client.Auth().UniversalAuthLogin("CLIENT_ID", "CLIENT_SECRET")

if err != nil {
  fmt.Println(err)
  os.Exit(1)
}
```

#### GCP ID Token Auth

<Info>
  Please note that this authentication method will only work if you're running
  your application on Google Cloud Platform. Please [read
  more](/documentation/platform/identities/gcp-auth) about this authentication
  method.
</Info>

**Using environment variables**

Call `.Auth().GcpIdTokenAuthLogin()` with empty arguments to use the following environment variables:

* `INFISICAL_GCP_AUTH_IDENTITY_ID` - Your Infisical Machine Identity ID.

**Using the SDK directly**

```go  theme={"dark"}
_, err := client.Auth().GcpIdTokenAuthLogin("YOUR_MACHINE_IDENTITY_ID")

if err != nil {
  fmt.Println(err)
  os.Exit(1)
}
```

#### GCP IAM Auth

**Using environment variables**

Call `.Auth().GcpIamAuthLogin()` with empty arguments to use the following environment variables:

* `INFISICAL_GCP_IAM_AUTH_IDENTITY_ID` - Your Infisical Machine Identity ID.
* `INFISICAL_GCP_IAM_SERVICE_ACCOUNT_KEY_FILE_PATH` - The path to your GCP service account key file.

**Using the SDK directly**

```go  theme={"dark"}
_, err = client.Auth().GcpIamAuthLogin("MACHINE_IDENTITY_ID", "SERVICE_ACCOUNT_KEY_FILE_PATH")

if err != nil {
  fmt.Println(err)
  os.Exit(1)
}
```

#### AWS IAM Auth

<Info>
  Please note that this authentication method will only work if you're running
  your application on AWS. Please [read
  more](/documentation/platform/identities/aws-auth) about this authentication
  method.
</Info>

**Using environment variables**

Call `.Auth().AwsIamAuthLogin()` with empty arguments to use the following environment variables:

* `INFISICAL_AWS_IAM_AUTH_IDENTITY_ID` - Your Infisical Machine Identity ID.

**Using the SDK directly**

```go  theme={"dark"}
_, err = client.Auth().AwsIamAuthLogin("MACHINE_IDENTITY_ID")

if err != nil {
  fmt.Println(err)
  os.Exit(1)
}
```

#### Azure Auth

<Info>
  Please note that this authentication method will only work if you're running
  your application on Azure. Please [read
  more](/documentation/platform/identities/azure-auth) about this authentication
  method.
</Info>

**Using environment variables**

Call `.Auth().AzureAuthLogin()` with empty arguments to use the following environment variables:

* `INFISICAL_AZURE_AUTH_IDENTITY_ID` - Your Infisical Machine Identity ID.

**Using the SDK directly**

```go  theme={"dark"}
_, err = client.Auth().AzureAuthLogin("MACHINE_IDENTITY_ID")

if err != nil {
  fmt.Println(err)
  os.Exit(1)
}
```

#### Kubernetes Auth

<Info>
  Please note that this authentication method will only work if you're running
  your application on Kubernetes. Please [read
  more](/documentation/platform/identities/kubernetes-auth) about this
  authentication method.
</Info>

**Using environment variables**

Call `.Auth().KubernetesAuthLogin()` with empty arguments to use the following environment variables:

* `INFISICAL_KUBERNETES_IDENTITY_ID` - Your Infisical Machine Identity ID.
* `INFISICAL_KUBERNETES_SERVICE_ACCOUNT_TOKEN_PATH_ENV_NAME` - The environment variable name that contains the path to the service account token. This is optional and will default to `/var/run/secrets/kubernetes.io/serviceaccount/token`.

**Using the SDK directly**

```go  theme={"dark"}
// Service account token path will default to /var/run/secrets/kubernetes.io/serviceaccount/token if empty value is passed
_, err = client.Auth().KubernetesAuthLogin("MACHINE_IDENTITY_ID", "SERVICE_ACCOUNT_TOKEN_PATH")

if err != nil {
  fmt.Println(err)
  os.Exit(1)
}
```

## Secrets

### List Secrets

`client.Secrets().List(options)`

Retrieve all secrets within the Infisical project and environment that client is connected to.

```go  theme={"dark"}
secrets, err := client.Secrets().List(infisical.ListSecretsOptions{
  ProjectID:          "PROJECT_ID",
  Environment:        "dev",
  SecretPath:         "/foo/bar",
  AttachToProcessEnv: false,
})
```

#### Parameters

<ParamField query="Parameters" type="object">
  <Expandable title="properties">
    <ParamField query="Environment" type="string" required>
      The slug name (dev, prod, etc) of the environment from where secrets should be fetched from.
    </ParamField>

    <ParamField query="ProjectID" type="string">
      The project ID where the secret lives in.
    </ParamField>

    <ParamField query="SecretPath" type="string" optional>
      The path from where secrets should be fetched from.
    </ParamField>

    <ParamField query="AttachToProcessEnv" type="boolean" default="false" optional>
      Whether or not to set the fetched secrets to the process environment. If true, you can access the secrets like so `System.getenv("SECRET_NAME")`.
    </ParamField>

    <ParamField query="IncludeImports" type="boolean" default="false" optional>
      Whether or not to include imported secrets from the current path. Read about [secret import](/documentation/platform/secret-reference)
    </ParamField>

    <ParamField query="Recursive" type="boolean" default="false" optional>
      Whether or not to fetch secrets recursively from the specified path. Please note that there's a 20-depth limit for recursive fetching.
    </ParamField>

    <ParamField query="ExpandSecretReferences" type="boolean" default="true" optional>
      Whether or not to expand secret references in the fetched secrets. Read about [secret reference](/documentation/platform/secret-reference)
    </ParamField>
  </Expandable>
</ParamField>

###

### Retrieve Secret

`client.Secrets().Retrieve(options)`

Retrieve a secret from Infisical. By default `Secrets().Retrieve()` fetches and returns a shared secret.

```go  theme={"dark"}
secret, err := client.Secrets().Retrieve(infisical.RetrieveSecretOptions{
  SecretKey:   "API_KEY",
  ProjectID:   "PROJECT_ID",
  Environment: "dev",
})
```

#### Parameters

<ParamField query="Parameters" type="object" optional>
  <Expandable title="properties">
    <ParamField query="SecretKey" type="string" required>
      The key of the secret to retrieve.
    </ParamField>

    <ParamField query="ProjectID" type="string" required>
      The project ID where the secret lives in.
    </ParamField>

    <ParamField query="Environment" type="string" required>
      The slug name (dev, prod, etc) of the environment from where secrets
      should be fetched from.
    </ParamField>

    <ParamField query="SecretPath" type="string" optional>
      The path from where secret should be fetched from.
    </ParamField>

    <ParamField query="Type" type="string" optional>
      The type of the secret. Valid options are "shared" or "personal". If not
      specified, the default value is "shared".
    </ParamField>

    <ParamField query="Version" type="number" optional>
      The version of the secret to retrieve.
    </ParamField>
  </Expandable>
</ParamField>

###

### Create Secret

`client.Secrets().Create(options)`

Create a new secret in Infisical.

```go  theme={"dark"}
secret, err := client.Secrets().Create(infisical.CreateSecretOptions{
  ProjectID:   "PROJECT_ID",
  Environment: "dev",

  SecretKey:     "NEW_SECRET_KEY",
  SecretValue:   "NEW_SECRET_VALUE",
  SecretComment: "This is a new secret",
})
```

#### Parameters

<ParamField query="Parameters" type="object" optional>
  <Expandable title="properties">
    <ParamField query="SecretKey" type="string" required>
      The key of the secret to create.
    </ParamField>

    <ParamField query="SecretValue" type="string" required>
      The value of the secret.
    </ParamField>

    <ParamField query="SecretComment" type="string" optional>
      A comment for the secret.
    </ParamField>

    <ParamField query="ProjectID" type="string" required>
      The project ID where the secret lives in.
    </ParamField>

    <ParamField query="Environment" type="string" required>
      The slug name (dev, prod, etc) of the environment from where secrets
      should be fetched from.
    </ParamField>

    <ParamField query="SecretPath" type="string" optional>
      The path from where secret should be created.
    </ParamField>

    <ParamField query="Type" type="string" optional>
      The type of the secret. Valid options are "shared" or "personal". If not
      specified, the default value is "shared".
    </ParamField>
  </Expandable>
</ParamField>

###

### Update Secret

`client.Secrets().Update(options)`

Update an existing secret in Infisical.

```go  theme={"dark"}
secret, err := client.Secrets().Update(infisical.UpdateSecretOptions{
  ProjectID:                "PROJECT_ID",
  Environment:              "dev",
  SecretKey:                "NEW_SECRET_KEY",
  NewSecretValue:           "NEW_SECRET_VALUE",
  NewSkipMultilineEncoding: false,
})
```

#### Parameters

<ParamField query="Parameters" type="object" optional>
  <Expandable title="properties">
    <ParamField query="SecretKey" type="string" required>
      The key of the secret to update.
    </ParamField>

    <ParamField query="NewSecretValue" type="string" required>
      The new value of the secret.
    </ParamField>

    <ParamField query="NewSkipMultilineEncoding" type="boolean" default="false" optional>
      Whether or not to skip multiline encoding for the new secret value.
    </ParamField>

    <ParamField query="ProjectID" type="string" required>
      The project ID where the secret lives in.
    </ParamField>

    <ParamField query="Environment" type="string" required>
      The slug name (dev, prod, etc) of the environment from where secrets
      should be fetched from.
    </ParamField>

    <ParamField query="SecretPath" type="string" optional>
      The path from where secret should be updated.
    </ParamField>

    <ParamField query="Type" type="string" optional>
      The type of the secret. Valid options are "shared" or "personal". If not
      specified, the default value is "shared".
    </ParamField>
  </Expandable>
</ParamField>

###

### Delete Secret

`client.Secrets().Delete(options)`

Delete a secret in Infisical.

```go  theme={"dark"}
secret, err := client.Secrets().Delete(infisical.DeleteSecretOptions{
  ProjectID:   "PROJECT_ID",
  Environment: "dev",
  SecretKey:   "SECRET_KEY",
})
```

#### Parameters

<ParamField query="Parameters" type="object" optional>
  <Expandable title="properties">
    <ParamField query="SecretKey" type="string">
      The key of the secret to update.
    </ParamField>

    <ParamField query="ProjectID" type="string" required>
      The project ID where the secret lives in.
    </ParamField>

    <ParamField query="Environment" type="string" required>
      The slug name (dev, prod, etc) of the environment from where secrets
      should be fetched from.
    </ParamField>

    <ParamField query="SecretPath" type="string" optional>
      The path from where secret should be deleted.
    </ParamField>

    <ParamField query="Type" type="string" optional>
      The type of the secret. Valid options are "shared" or "personal". If not
      specified, the default value is "shared".
    </ParamField>
  </Expandable>
</ParamField>

### Batch Create Secrets

`client.Secrets().Batch().Create(options)`

Create multiple secrets in Infisical.

```go  theme={"dark"}
	createdSecrets, err := client.Secrets().Batch().Create(infisical.BatchCreateSecretsOptions{
		Environment: "<environment-slug>",
		SecretPath:  "<secret-path>",
		ProjectID:   "<project-id>",
		Secrets: []infisical.BatchCreateSecret{
			{
				SecretKey:   "SECRET-1",
				SecretValue: "test-value-1",
			},
			{
				SecretKey:   "SECRET-2",
				SecretValue: "test-value-2",
			},
		},
	})
```

#### Parameters

<ParamField query="Parameters" type="object" optional>
  <Expandable title="properties">
    <ParamField query="Environment" type="string" required>
      The slug name (dev, prod, etc) of the environment from where secrets should be fetched from.
    </ParamField>

    <ParamField query="ProjectID" type="string" required>
      The project ID where the secret lives in.
    </ParamField>

    <ParamField query="SecretPath" type="string" optional>
      The path from where secret should be created.
    </ParamField>

    <ParamField query="Secrets" type="array" required>
      <Expandable>
        <ParamField query="SecretKey" type="string" required>
          The key of the secret to create.
        </ParamField>

        <ParamField query="SecretValue" type="string" required>
          The value of the secret.
        </ParamField>

        <ParamField query="SecretComment" type="string" optional>
          The comment to add to the secret.
        </ParamField>

        <ParamField query="SkipMultiLineEncoding" type="boolean" optional>
          Whether or not to skip multiline encoding for the secret value.
        </ParamField>

        <ParamField query="TagIDs" type="string[]" optional>
          The tag IDs to associate with the secret.
        </ParamField>

        <ParamField query="SecretMetadata" type="object" optional>
          <Expandable>
            <ParamField query="Key" type="string" required>
              The key of the metadata.
            </ParamField>

            <ParamField query="Value" type="string" required>
              The value of the metadata.
            </ParamField>
          </Expandable>
        </ParamField>
      </Expandable>
    </ParamField>
  </Expandable>
</ParamField>

## Folders

###

### List Folders

`client.Folders().List(options)`

Retrieve all within the Infisical project and environment that client is connected to.

```go  theme={"dark"}
folders, err := client.Folders().List(infisical.ListFoldersOptions{
  ProjectID:   "PROJECT_ID",
  Environment: "dev",
  Path:        "/",
})
```

#### Parameters

<ParamField query="Parameters" type="object">
  <Expandable title="properties">
    <ParamField query="Environment" type="string" required>
      The slug name (dev, prod, etc) of the environment from where folders should be fetched from.
    </ParamField>

    <ParamField query="ProjectID" type="string">
      The project ID where the folder lives in.
    </ParamField>

    <ParamField query="Path" type="string" optional>
      The path from where folders should be fetched from.
    </ParamField>
  </Expandable>
</ParamField>

###

### Create Folder

`client.Folders().Create(options)`

Create a new folder in Infisical.

```go  theme={"dark"}
folder, err := client.Folders().Create(infisical.CreateFolderOptions{
  ProjectID:   "PROJECT_ID",
  Name:        "new=folder-name",
  Environment: "dev",
  Path:        "/",
})
```

#### Parameters

<ParamField query="Parameters" type="object" optional>
  <Expandable title="properties">
    <ParamField query="ProjectID" type="string" required>
      The ID of the project where the folder will be created.
    </ParamField>

    <ParamField query="Environment" type="string" required>
      The slug name (dev, prod, etc) of the environment where the folder will be
      created.
    </ParamField>

    <ParamField query="Path" type="string" optional>
      The path to create the folder in. The root path is `/`.
    </ParamField>

    <ParamField query="Name" type="string" optional>
      The name of the folder to create.
    </ParamField>
  </Expandable>
</ParamField>

###

### Update Folder

`client.Folders().Update(options)`

Update an existing folder in Infisical.

```go  theme={"dark"}
folder, err := client.Folders().Update(infisical.UpdateFolderOptions{
  ProjectID:   "PROJECT_ID",
  Environment: "dev",
  Path:        "/",
  FolderID:    "FOLDER_ID_TO_UPDATE",
  NewName:     "new-folder-name",
})
```

#### Parameters

<ParamField query="Parameters" type="object" optional>
  <Expandable title="properties">
    <ParamField query="ProjectID" type="string" required>
      The ID of the project where the folder will be updated.
    </ParamField>

    <ParamField query="Environment" type="string" required>
      The slug name (dev, prod, etc) of the environment from where the folder
      lives in.
    </ParamField>

    <ParamField query="Path" type="string" optional>
      The path from where the folder should be updated.
    </ParamField>

    <ParamField query="FolderID" type="string" required>
      The ID of the folder to update.
    </ParamField>

    <ParamField query="NewName" type="string" required>
      The new name of the folder.
    </ParamField>
  </Expandable>
</ParamField>

###

### Delete Folder

`client.Folders().Delete(options)`

Delete a folder in Infisical.

```go  theme={"dark"}
deletedFolder, err := client.Folders().Delete(infisical.DeleteFolderOptions{
  // Either folder ID or folder name is required.
  FolderName:  "name-of-folder-to-delete",
  FolderID:    "folder-id-to-delete",
  ProjectID:   "PROJECT_ID",
  Environment: "dev",
  Path:        "/",
})
```

#### Parameters

<ParamField query="Parameters" type="object" optional>
  <Expandable title="properties">
    <ParamField query="FolderName" type="string" optional>
      The name of the folder to delete. Note that either `FolderName` or `FolderID` is required.
    </ParamField>

    <ParamField query="FolderID" type="string" optional>
      The ID of the folder to delete. Note that either `FolderName` or `FolderID` is required.
    </ParamField>

    <ParamField query="ProjectID" type="string" required>
      The ID of the project where the folder lives in.
    </ParamField>

    <ParamField query="Environment" type="string" required>
      The slug name (dev, prod, etc) of the environment from where the folder lives in.
    </ParamField>

    <ParamField query="Path" type="string" optional>
      The path from where the folder should be deleted.
    </ParamField>
  </Expandable>
</ParamField>

## KMS

### Create Key

`client.Kms().Keys().Create(options)`

Create a new key in Infisical.

```go  theme={"dark"}
	newKey, err := client.Kms().Keys().Create(infisical.KmsCreateKeyOptions{
		KeyUsage:            "<sign-verify>|<encrypt-decrypt>",
		Description:         "<key-description>",
		Name:                "<key-name>",
		EncryptionAlgorithm: "<rsa-4096>|<ecc-nist-p256>|<aes-256-gcm>|<aes-128-gcm>",
		ProjectId:           "<project-id>",
	})
```

#### Parameters

<ParamField query="Parameters" type="object" optional>
  <Expandable title="properties">
    <ParamField query="KeyUsage" type="string" required>
      The usage of the key. Valid options are `sign-verify` or `encrypt-decrypt`.
      The usage dictates what the key can be used for.
    </ParamField>

    <ParamField query="Description" type="string" optional>
      The description of the key.
    </ParamField>

    <ParamField query="Name" type="string" required>
      The name of the key.
    </ParamField>

    <ParamField query="EncryptionAlgorithm" type="string" required>
      The encryption algorithm of the key.

      Valid options for Signing/Verifying keys are:

      * `rsa-4096`
      * `ecc-nist-p256`

      Valid options for Encryption/Decryption keys are:

      * `aes-256-gcm`
      * `aes-128-gcm`
    </ParamField>

    <ParamField query="ProjectId" type="string" required>
      The ID of the project where the key will be created.
    </ParamField>
  </Expandable>
</ParamField>

#### Return (object)

<ParamField query="Return" type="object">
  <Expandable title="properties">
    <ParamField query="KeyId" type="string" required>
      The ID of the key that was created.
    </ParamField>

    <ParamField query="Name" type="string" required>
      The name of the key that was created.
    </ParamField>

    <ParamField query="Description" type="string" required>
      The description of the key that was created.
    </ParamField>

    <ParamField query="IsDisabled" type="boolean" required>
      Whether or not the key is disabled.
    </ParamField>

    <ParamField query="OrgId" type="string" required>
      The ID of the organization that the key belongs to.
    </ParamField>

    <ParamField query="ProjectId" type="string" required>
      The ID of the project that the key belongs to.
    </ParamField>

    <ParamField query="KeyUsage" type="string" required>
      The intended usage of the key that was created.
    </ParamField>

    <ParamField query="EncryptionAlgorithm" type="string" required>
      The encryption algorithm of the key that was created.
    </ParamField>

    <ParamField query="Version" type="string" required>
      The version of the key that was created.
    </ParamField>
  </Expandable>
</ParamField>

### Delete Key

`client.Kms().Keys().Delete(options)`

Delete a key in Infisical.

```go  theme={"dark"}
deletedKey, err = client.Kms().Keys().Delete(infisical.KmsDeleteKeyOptions{
		KeyId: "<key-id>",
	})
```

#### Parameters

<ParamField query="Parameters" type="object" optional>
  <Expandable title="properties">
    <ParamField query="KeyId" type="string" required>
      The ID of the key to delete.
    </ParamField>
  </Expandable>
</ParamField>

#### Return (object)

<ParamField query="Return" type="object">
  <Expandable title="properties">
    <ParamField query="KeyId" type="string" required>
      The ID of the key that was deleted
    </ParamField>

    <ParamField query="Name" type="string" required>
      The name of the key that was deleted.
    </ParamField>

    <ParamField query="Description" type="string" required>
      The description of the key that was deleted.
    </ParamField>

    <ParamField query="IsDisabled" type="boolean" required>
      Whether or not the key is disabled.
    </ParamField>

    <ParamField query="OrgId" type="string" required>
      The ID of the organization that the key belonged to.
    </ParamField>

    <ParamField query="ProjectId" type="string" required>
      The ID of the project that the key belonged to.
    </ParamField>

    <ParamField query="KeyUsage" type="string" required>
      The intended usage of the key that was deleted.
    </ParamField>

    <ParamField query="EncryptionAlgorithm" type="string" required>
      The encryption algorithm of the key that was deleted.
    </ParamField>

    <ParamField query="Version" type="string" required>
      The version of the key that was deleted.
    </ParamField>
  </Expandable>
</ParamField>

### Signing Data

`client.Kms().Signing().Sign(options)`
Sign data in Infisical.

```go  theme={"dark"}
res, err := client.Kms().Signing().SignData(infisical.KmsSignDataOptions{
  KeyId:            "<key-id>",
  Data:             "<data-to-sign>", // Must be a base64 encoded string.
  SigningAlgorithm: "<signing-algorithm>", // The signing algorithm that will be used to sign the data.
})
```

#### Parameters

<ParamField query="Parameters" type="object" optional>
  <Expandable title="properties">
    <ParamField query="KeyId" type="string" required>
      The ID of the key to sign the data with.
    </ParamField>

    <ParamField query="Data" type="string" required>
      The data to sign. Must be a base64 encoded string.
    </ParamField>

    <ParamField query="IsDigest" type="boolean" optional>
      Whether the data is already digested or not.
    </ParamField>

    <ParamField query="SigningAlgorithm" type="string" required>
      The signing algorithm to use. You must use a signing algorithm that matches the key usage.

      <Note>
        If you are unsure about which signing algorithms are available for your key, you can use the `client.Kms().Signing().ListSigningAlgorithms()` method. It will return an array of signing algorithms that are available for your key.
      </Note>

      Valid options for `RSA 4096` keys are:

      * `RSASSA_PSS_SHA_512`
      * `RSASSA_PSS_SHA_384`
      * `RSASSA_PSS_SHA_256`
      * `RSASSA_PKCS1_V1_5_SHA_512`
      * `RSASSA_PKCS1_V1_5_SHA_384`
      * `RSASSA_PKCS1_V1_5_SHA_256`

      Valid options for `ECC NIST P256` keys are:

      * `ECDSA_SHA_512`
      * `ECDSA_SHA_384`
      * `ECDSA_SHA_256`
    </ParamField>
  </Expandable>
</ParamField>

#### Return (\[]byte)

<ParamField query="Return" type="[]byte">
  The signature of the data that was signed.
</ParamField>

### Verifying Data

`client.Kms().Signing().Verify(options)`
Verify data in Infisical.

```go  theme={"dark"}
res, err := client.Kms().Signing().Verify(infisical.KmsVerifyDataOptions{
  KeyId:            "<key-id>",
  Data:             "<data-to-verify>", // Must be a base64 encoded string.
  SigningAlgorithm: "<signing-algorithm>", // The signing algorithm that was used to sign the data.
})
```

#### Parameters

<ParamField query="Parameters" type="object" optional>
  <Expandable title="properties">
    <ParamField query="KeyId" type="string" required>
      The ID of the key to verify the data with.
    </ParamField>

    <ParamField query="Data" type="string" required>
      The data to verify. Must be a base64 encoded string.
    </ParamField>

    <ParamField query="IsDigest" type="boolean" optional>
      Whether the data is already digested or not.
    </ParamField>

    <ParamField query="SigningAlgorithm" type="string" required>
      The signing algorithm that was used to sign the data.
    </ParamField>
  </Expandable>
</ParamField>

#### Return (object)

<ParamField query="Return" type="object">
  <Expandable title="properties">
    <ParamField query="SignatureValid" type="boolean" required>
      Whether or not the data is valid.
    </ParamField>

    <ParamField query="KeyId" type="string" required>
      The ID of the key that was used to verify the data.
    </ParamField>

    <ParamField query="SigningAlgorithm" type="string" required>
      The signing algorithm that was used to verify the data.
    </ParamField>
  </Expandable>
</ParamField>

### List Signing Algorithms

`client.Kms().Signing().ListSigningAlgorithms(options)`
List signing algorithms in Infisical.

```go  theme={"dark"}
res, err := client.Kms().Signing().ListSigningAlgorithms(infisical.KmsListSigningAlgorithmsOptions{
  KeyId: "<key-id>",
})
```

#### Parameters

<ParamField query="Parameters" type="object" optional>
  <Expandable title="properties">
    <ParamField query="KeyId" type="string" required>
      The ID of the key to list signing algorithms for.
    </ParamField>
  </Expandable>
</ParamField>

#### Return (\[]string)

<ParamField query="Return" type="[]string">
  The signing algorithms that are available for the key.
</ParamField>

### Get Public Key

<Note>
  This method is only available for keys with key usage `sign-verify`. If you attempt to use this method on a key that is intended for encryption/decryption, it will return an error.
</Note>

`client.Kms().Signing().GetPublicKey(options)`
Get the public key in Infisical.

```go  theme={"dark"}
publicKey, err := client.Kms().Signing().GetPublicKey(infisical.KmsGetPublicKeyOptions{
  KeyId: "<key-id>",
})
```

#### Parameters

<ParamField query="Parameters" type="object" optional>
  <Expandable title="properties">
    <ParamField query="KeyId" type="string" required>
      The ID of the key to get the public key for.
    </ParamField>
  </Expandable>
</ParamField>

#### Return (string)

<ParamField query="Return" type="string">
  The public key for the key.
</ParamField>

### Encrypt Data

`client.Kms().Encryption().Encrypt(options)`
Encrypt data with a key in Infisical KMS.

```go  theme={"dark"}
res, err := client.Kms().EncryptData(infisical.KmsEncryptDataOptions{
  KeyId: "<key-id>",
  Plaintext: "<data-to-encrypt>",
})
```

#### Parameters

<ParamField query="Parameters" type="object" optional>
  <Expandable title="properties">
    <ParamField query="KeyId" type="string" required>
      The ID of the key to encrypt the data with.
    </ParamField>
  </Expandable>
</ParamField>

#### Return (string)

<ParamField query="Return" type="string">
  The encrypted data.
</ParamField>

### Decrypt Data

`client.Kms().DecryptData(options)`
Decrypt data with a key in Infisical KMS.

```go  theme={"dark"}
res, err := client.Kms().DecryptData(infisical.KmsDecryptDataOptions{
  KeyId: "<key-id>",
  Ciphertext: "<encrypted-data>",
})
```

#### Parameters

<ParamField query="Parameters" type="object" optional>
  <Expandable title="properties">
    <ParamField query="KeyId" type="string" required>
      The ID of the key to decrypt the data with.
    </ParamField>

    <ParamField query="Ciphertext" type="string" required>
      The encrypted data to decrypt.
    </ParamField>
  </Expandable>
</ParamField>

#### Return (string)

<ParamField query="Return" type="string">
  The decrypted data.
</ParamField>


# Infisical Java SDK
Source: https://infisical.com/docs/sdks/languages/java



If you're working with Java, the official Infisical Java SDK package is the easiest way to fetch and work with secrets for your application.

## Installation

Replace `{version}` with the version of the SDK you wish to use. This documentation covers version >=3.0.0.

### Maven

```xml  theme={"dark"}
<dependency>
    <groupId>com.infisical</groupId>
    <artifactId>sdk</artifactId>
    <version>{version}</version>
</dependency>
```

### Gradle

```gradle  theme={"dark"}
  implementation group: 'com.infisical', name: 'sdk', version: '{version}'
```

### Others

For other build tools, please check our [package snippets](https://central.sonatype.com/artifact/com.infisical/sdk), and select the build tool you're using for your project.

## Getting Started

```java  theme={"dark"}
package com.example.example;

import com.infisical.sdk.InfisicalSdk;
import com.infisical.sdk.SdkConfig;

public class Example {

  public static void main(String[] args) {
    var sdk = new InfisicalSdk(
      new SdkConfig.Builder()
        // Optional, will default to https://app.infisical.com
        .withSiteUrl("https://your-infisical-instance.com")
        .build()
    );

    sdk.Auth().UniversalAuthLogin(
      "CLIENT_ID",
      "CLIENT_SECRET"
    );

    var secret = sdk.Secrets().GetSecret(
      "<secret-name>",
      "<project-id>",
      "<env-slug>",
      "<secret-path>",
      null, // Expand Secret References (boolean, optional)
      null, // Include Imports (boolean, optional)
      null  // Secret Type (shared/personal, defaults to shared, optional)
      );


    System.out.println(secret);
  }
}
```

## Core Methods

The SDK methods are organized into the following high-level categories:

1. `Auth()`: Handles authentication methods.
2. `Secrets()`: Manages CRUD operations for secrets.

### `Auth`

The `Auth` component provides methods for authentication:

### Universal Auth

#### Authenticating

```java  theme={"dark"}
public void UniversalAuthLogin(
  String clientId,
  String clientSecret
)
throws InfisicalException
```

```java  theme={"dark"}
sdk.Auth().UniversalAuthLogin(
  "CLIENT_ID",
  "CLIENT_SECRET"
);
```

**Parameters:**

* `clientId` (string): The client ID of your Machine Identity.
* `clientSecret` (string): The client secret of your Machine Identity.

### AWS Auth

```java  theme={"dark"}
public void AwsAuthLogin(
  String identityId
)
throws InfisicalException
```

```java  theme={"dark"}
sdk.Auth().AwsAuthLogin("<machine-identity-id>");
```

**Parameters:**

* `identityId` (String): The ID of the machine identity to authenticate with.

### LDAP Auth

```java  theme={"dark"}
public void LdapAuthLogin(
  LdapAuthLoginInput input
)
throws InfisicalException
```

```java  theme={"dark"}
var input = LdapAuthLoginInput
  .builder()
  .identityId("<machine-identity-id>")
  .username("<ldap-username>")
  .password("<ldap-password>")
  .build();

sdk.Auth().LdapAuthLogin(input);
```

**Parameters:**

* `input` (LdapAuthLoginInput): The input for authenticating with LDAP.
  * `identityId` (String): The ID of the machine identity to authenticate with.
  * `username` (String): The LDAP username.
  * `password` (String): The LDAP password.

### Access Token Auth

#### Authenticating

```java  theme={"dark"}
public void SetAccessToken(
  String accessToken
)
throws InfisicalException
```

```java  theme={"dark"}
sdk.Auth().SetAccessToken("ACCESS_TOKEN");
```

**Parameters:**

* `accessToken` (string): The access token you want to use for authentication.

### `Secrets`

This sub-class handles operations related to secrets:

#### List Secrets

```java  theme={"dark"}
public List<Secret> ListSecrets(
    String projectId,
    String environmentSlug,
    String secretPath,
    Boolean expandSecretReferences,
    Boolean recursive,
    Boolean includeImports,
    Boolean setSecretsOnSystemProperties
)

throws InfisicalException
```

```java  theme={"dark"}
List<Secret> secrets = sdk.Secrets().ListSecrets(
  "<project-id>",
  "<env-slug>", // dev, prod, staging, etc.
  "/secret/path", // `/` is the root folder
  false, // Should expand secret references
  false, // Should get secrets recursively from sub folders
  false, // Should include imports
  false // Should set the fetched secrets as key/value pairs on the system properties. Makes the secrets accessible as System.getProperty("<secret-key>")
);
```

**Parameters:**

* `projectId` (string): The ID of your project.
* `environmentSlug` (string): The environment in which to list secrets (e.g., "dev").
* `secretPath` (string): The path to the secrets.
* `expandSecretReferences` (boolean): Whether to expand secret references.
* `recursive` (boolean): Whether to list secrets recursively.
* `includeImports` (boolean): Whether to include imported secrets.
* `setSecretsOnSystemProperties` (boolean): Set the retrieved secrets as key/value pairs on the system properties, making them accessible through `System.getProperty("<secret-key>")`

**Returns:**

* `List<Secret>`: The response containing the list of secrets.

#### Create Secret

```java  theme={"dark"}
public Secret CreateSecret(
    String secretName,
    String secretValue,
    String projectId,
    String environmentSlug,
    String secretPath
)
throws InfisicalException
```

```java  theme={"dark"}
Secret newSecret = sdk.Secrets().CreateSecret(
  "NEW_SECRET_NAME",
  "secret-value",
  "<project-id>",
  "<env-slug>", // dev, prod, staging, etc.
  "/secret/path", // `/` is the root folder
);
```

**Parameters:**

* `secretName` (string): The name of the secret to create
* `secretValue` (string): The value of the secret.
* `projectId` (string): The ID of your project.
* `environmentSlug` (string): The environment in which to create the secret.
* `secretPath` (string, optional): The path to the secret.

**Returns:**

* `Secret`: The created secret.

#### Update Secret

```java  theme={"dark"}
public Secret UpdateSecret(
    String secretName,
    String projectId,
    String environmentSlug,
    String secretPath,
    String newSecretValue,
    String newSecretName
  )
    
throws InfisicalException
```

```java  theme={"dark"}
Secret updatedSecret = sdk.Secrets().UpdateSecret(
  "SECRET_NAME",
  "<project-id>",
  "<env-slug>", // dev, prod, staging, etc.
  "/secret/path", // `/` is the root folder
  "NEW_SECRET_VALUE", // nullable
  "NEW_SECRET_NAME" // nullable
);
```

**Parameters:**

* `secretName` (string): The name of the secret to update.
* `projectId` (string): The ID of your project.
* `environmentSlug` (string): The environment in which to update the secret.
* `secretPath` (string): The path to the secret.
* `newSecretValue` (string, nullable): The new value of the secret.
* `newSecretName` (string, nullable): A new name for the secret.

**Returns:**

* `Secret`: The updated secret.

#### Get Secret by Name

```java  theme={"dark"}
public Secret GetSecret(
    String secretName,
    String projectId,
    String environmentSlug,
    String secretPath,
    Boolean expandSecretReferences,
    Boolean includeImports,
    String secretType
  )
throws InfisicalException
```

```java  theme={"dark"}
Secret secret = sdk.Secrets().GetSecret(
  "SECRET_NAME",
  "<project-id>",
  "<env-slug>", // dev, prod, staging, etc.
  "/secret/path", // `/` is the root folder
  false, // Should expand secret references
  false, // Should get secrets recursively from sub folders
  false, // Should include imports
  "shared" // Optional Secret Type (defaults to "shared")
);
```

**Parameters:**

* `secretName` (string): The name of the secret to get\`
* `projectId` (string): The ID of your project.
* `environmentSlug` (string): The environment in which to retrieve the secret.
* `secretPath` (string): The path to the secret.
* `expandSecretReferences` (boolean, optional): Whether to expand secret references.
* `includeImports` (boolean, optional): Whether to include imported secrets.
* `secretType` (personal | shared, optional): The type of secret to fetch.

**Returns:**

* `Secret`: The fetched secret.

#### Delete Secret by Name

```java  theme={"dark"}
public Secret DeleteSecret(
    String secretName,
    String projectId,
    String environmentSlug,
    String secretPath
  )
throws InfisicalException
```

```java  theme={"dark"}
Secret deletedSecret = sdk.Secrets().DeleteSecret(
  "SECRET_NAME", 
  "<project-id>",
  "<env-slug>", // dev, prod, staging, etc.
  "/secret/path", // `/` is the root folder
);
```

**Parameters:**

* `secretName` (string): The name of the secret to delete.
* `projectId` (string): The ID of your project.
* `environmentSlug` (string): The environment in which to delete the secret.
* `secretPath` (string, optional): The path to the secret.

**Returns:**

* `Secret`: The deleted secret.

### `Folders`

#### Get Folder By Name

```java  theme={"dark"}
public Folder Get(
  String folderId
);
throws InfisicalException
```

```java  theme={"dark"}
Folder folder = sdk.Folders().Get("<folder-id>");
```

**Parameters:**

* `folderId` (String): The ID of the folder to retrieve.

**Returns:**

* `Folder`: The retrieved folder.

#### List Folders

```java  theme={"dark"}
public List<Folder> List(
  ListFoldersInput input
)
throws InfisicalException
```

```java  theme={"dark"}
ListFoldersInput input = ListFoldersInput
  .builder()
  .projectId("<your-project-id>")
  .environmentSlug("<env-slug>")
  .folderPath("/")
  .recursive(false)
  .build();

List<Folder> folders = sdk.Folders().List(input);
```

**Parameters:**

* `input` (ListFoldersInput): The input for listing folders.
  * `projectId` (String): The ID of the project to list folders from.
  * `environmentSlug` (String): The slug of the environment to list folders from.
  * `folderPath` (String): The path to list folders from. Defaults to `/`.
  * `recursive` (Boolean): Whether or not to list sub-folders recursively from the specified folder path and downwards. Defaults to `false`.

**Returns:**

* `List<Folder>`: The retrieved folders.

#### Create Folder

```java  theme={"dark"}
public Folder Create(
  CreateFolderInput input
)
throws InfisicalException
```

```java  theme={"dark"}
var input = CreateFolderInput
  .builder()
  .projectId("<your-project-id>")
  .environmentSlug("<env-slug>")
  .folderName("<folder-name>")
  .folderPath("/")
  .description("Optional folder description")
  .build();

Folder createdFolder = sdk.Folders().Create(input);
```

**Parameters:**

* `input` (CreateFolderInput): The input for creating a folder.
  * `projectId` (String): The ID of the project to create the folder in.
  * `environmentSlug` (String): The slug of the environment to create the folder in.
  * `folderPath` (String): The path to create the folder in. Defaults to `/`.
  * `folderName` (String): The name of the folder to create.
  * `description` (String): The description of the folder to create. This is optional.

**Returns:**

* `Folder`: The created folder.

#### Update Folder

```java  theme={"dark"}
public Folder Update(
  UpdateFolderInput input
)
throws InfisicalException
```

```java  theme={"dark"}
var input = UpdateFolderInput
  .builder()
  .projectId("<your-project-id>")
  .environmentSlug("<env-slug>")
  .folderId("<id-of-folder-to-update>")
  .newFolderName("<the-new-folder-name>")
  .folderPath("/")
  .build();

Folder updatedFolder = sdk.Folders().Update(input);
```

**Parameters:**

* `input` (UpdateFolderInput): The input for updating a folder.
  * `projectId` (String): The ID of the project where the folder exists.
  * `environmentSlug` (String): The slug of the environment where the folder exists.
  * `folderPath` (String): The path of the folder to update.
  * `folderId` (String): The ID of the folder to update.
  * `newFolderName` (String): The new folder name.

**Returns:**

* `Folder`: The updated folder.

#### Delete Folder

```java  theme={"dark"}
public Folder Delete(
  DeleteFolderInput input
)
throws InfisicalException
```

```java  theme={"dark"}
var input = DeleteFolderInput
  .builder()
  .folderId("<the-folder-id>")
  .environmentSlug("<env-slug>")
  .projectId("<your-project-id>")
  .build();

Folder deletedFolder = sdk.Folders().Delete(input);
```

**Parameters:**

* `input` (DeleteFolderInput): The input for deleting a folder.
  * `projectId` (String): The ID of the project where the folder exists.
  * `environmentSlug` (String): The slug of the environment where the folder exists.
  * `folderId` (String): The ID of the folder to delete.

**Returns:**

* `Folder`: The deleted folder.


# Infisical Node.js SDK
Source: https://infisical.com/docs/sdks/languages/node



If you're working with Node.js, the official Infisical Node.js SDK package is the easiest way to fetch and work with secrets for your application.

## Deprecation Notice

Please be aware that all versions prior to `4.0.0` are officially fully unsupported.
Please upgrade to version 4.0.0 or newer in order to receive the latest updates.

## Installation

```bash  theme={"dark"}
npm install @infisical/sdk
```

## Getting Started

```typescript  theme={"dark"}
import { InfisicalSDK } from '@infisical/sdk'

const client = new InfisicalSDK({
  siteUrl: "your-infisical-instance.com" // Optional, defaults to https://app.infisical.com
});

// Authenticate with Infisical
await client.auth().universalAuth.login({
  clientId: "<machine-identity-client-id>",
  clientSecret: "<machine-identity-client-secret>"
});

const allSecrets = await client.secrets().listSecrets({
  environment: "dev", // stg, dev, prod, or custom environment slugs
  projectId: "<your-project-id>"
});

console.log("Fetched secrets", allSecrets)
```

## Core Methods

The SDK methods are organized into the following high-level categories:

1. `auth`: Handles authentication methods.
2. `secrets`: Manages CRUD operations for secrets.
3. `dynamicSecrets`: Manages dynamic secrets and leases.
4. `projects`: Creates and manages projects.
5. `environments`: Creates and manages environments.
6. `folders`: Creates and manages folders.
7. `kms`: Manages KMS keys and encryption/signing operations.

### `auth`

The `Auth` component provides methods for authentication:

#### Universal Auth

#### Authenticating

```typescript  theme={"dark"}
await client.auth().universalAuth.login({
  clientId: "<machine-identity-client-id>",
  clientSecret: "<machine-identity-client-secret>"
});
```

**Parameters:**

* `options` (object):
  * `clientId` (string): The client ID of your Machine Identity.
  * `clientSecret` (string): The client secret of your Machine Identity.

#### Renewing

You can renew the authentication token that is currently set by using the `renew()` method.

```typescript  theme={"dark"}
await client.auth().universalAuth.renew();
```

#### Manually set access token

By default, when you run a successful `.login()` method call, the access token returned will be auto set for the client instance. However, if you wish to set the access token manually, you may use this method.

```typescript  theme={"dark"}
client.auth().accessToken("<your-access-token>")
```

**Parameters:**

* `accessToken` (string): The access token to be used for authentication. *This should not include "Bearer".*

#### AWS IAM

<Note>
  AWS IAM auth only works when the SDK is being used from within an AWS service, such as Lambda, EC2, etc.
</Note>

#### Authenticating

```typescript  theme={"dark"}
await client.auth().awsIamAuth.login({
  identityId: "<your-identity-id>"
})
```

**Parameters:**

* `options` (object):
  * `identityId` (string): The ID of your identity

#### Renewing

You can renew the authentication token that is currently set by using the `renew()` method.

```typescript  theme={"dark"}
await client.auth().awsIamAuth.renew();
```

### `secrets`

This sub-class handles operations related to secrets:

#### List Secrets

```typescript  theme={"dark"}
const allSecrets = await client.secrets().listSecrets({
  environment: "dev",
  projectId: "<your-project-id>",
  expandSecretReferences: true,
  viewSecretValue: true,
  includeImports: false,
  recursive: false,
  secretPath: "/foo/bar",
});
```

**Parameters:**

* `projectId` (string): The ID of your project.
* `environment` (string): The environment in which to list secrets (e.g., "dev").
* `secretPath` (str): The path to the secrets.
* `expandSecretReferences` (bool, optional): Whether to expand secret references.
* `viewSecretValue` (bool, optional): Whether or not to reveal the secret value of the secrets. If set to `false`, the `secretValue` is masked with `<hidden-by-infisical>`. Defaults to `true`.
* `recursive` (bool, optional): Whether to list secrets recursively.
* `includeImports` (bool, optional): Whether to include imported secrets.
* `tagFilters` (string\[], optional): Tags to filter secrets.

**Returns:**

* `ListSecretsResponse`: The response containing the list of secrets.

#### List secrets with imports

The `listSecretsWithImports` method makes it easier to get all your secrets at once. The imported secrets will automatically be added to the secrets returned. The secrets in the selected environment will take precedence over the imported secrets. This means if you have secrets with conflicting names, the secret from the environment the import was imported into, will take precedence.

```typescript  theme={"dark"}
const allSecrets = await client.secrets().listSecretsWithImports({
  environment: "dev",
  projectId: "<your-project-id>",
  expandSecretReferences: true,
  viewSecretValue: true,
  recursive: false,
  secretPath: "/foo/bar"
});
```

**Parameters:**

* `projectId` (string): The ID of your project.
* `environment` (string): The environment in which to list secrets (e.g., "dev").
* `secretPath` (str): The path to the secrets.
* `expandSecretReferences` (bool, optional): Whether to expand secret references.
* `viewSecretValue` (bool, optional): Whether or not to reveal the secret value of the secrets. If set to `false`, the `secretValue` is masked with `<hidden-by-infisical>`. Defaults to `true`.
* `recursive` (bool, optional): Whether to list secrets recursively.
* `tagFilters` (string\[], optional): Tags to filter secrets.

**Returns:**

* `Secret[]`: Returns the list of secrets objects, with imports.

#### Create Secret

```typescript  theme={"dark"}
	const newSecret = await client.secrets().createSecret("SECRET_NAME", {
		environment: "dev",
		projectId: "<your-project-id>",
		secretValue: "SECRET_VALUE",
		secretComment: "This is a new secret",          // Optional
		secretPath: "/foo/bar",                         // Optional
		secretReminderNote: "This is a reminder note",  // Optional
		secretReminderRepeatDays: 7,                    // Optional
		skipMultilineEncoding: false,                   // Optional
		tagIds: ["tagId1", "tagId2"],                   // Optional
		type: "personal"                                // Optional
	});
```

**Parameters:**

* `secretName` (string): The name of the secret to create
* `options` (object):
  * `projectId` (string): The ID of your project.
  * `environment` (str): The environment in which to create the secret.
  * `secretValue` (str): The value of the secret.
  * `secretPath` (string, optional): The path to the secret.
  * `secretComment` (str, optional): A comment associated with the secret.
  * `skipMultilineEncoding` (bool, optional): Whether to skip encoding for multiline secrets.
  * `secretReminderNote` (string, optional): A note for the secret reminder.
  * `secretReminderRepeatDays` (number, optional): Number of days after which to repeat secret reminders.
  * `tagIds` (string\[], optional): Array of tags to assign to the new secret.
  * `type` (personal | shared, optional): Which type of secret to create.

**Returns:**

* `CreateSecretResponse`: The response after creating the secret.

#### Update Secret

```typescript  theme={"dark"}
const updatedSecret = await client.secrets().updateSecret("SECRET_TO_UPDATE", {
  environment: "dev",                                     
  projectId: "<your-project-id>",                                  
  secretValue: "UPDATED_SECRET_VALUE",                    
  newSecretName: "NEW_SECRET_NAME2",                      // Optional
  secretComment: "This is an updated secret",             // Optional
  secretPath: "/foo/bar",                                 // Optional
  secretReminderNote: "This is an updated reminder note", // Optional
  secretReminderRepeatDays: 14,                           // Optional
  skipMultilineEncoding: false,                           // Optional
  tagIds: ["tagId1", "tagId2"],                           // Optional
  type: "personal",                                       // Optional
  metadata: {                                             // Optional
    extra: "metadata"
  }
});
```

**Parameters:**

* `secretName` (string): The name of the secret to update.\`
* `options` (object):
  * `environment` (str): The environment in which to update the secret.
  * `projectId` (str): The ID of your project.
  * `secretValue` (str, optional): The new value of the secret.
  * `newSecretName` (str, optional): A new name for the secret.
  * `secretComment` (str, optional): An updated comment associated with the secret.
  * `secretPath` (str): The path to the secret.
  * `secretReminderNote` (str, optional): An updated note for the secret reminder.
  * `secretReminderRepeatDays` (number, optional): Updated number of days after which to repeat secret reminders.
  * `skipMultilineEncoding` (bool, optional): Whether to skip encoding for multiline secrets.
  * `tagIds` (string\[], optional): Array of tags to assign to the secret.
  * `type` (personal | shared, optional): Which type of secret to create.
  * `metadata` (object, optional): Assign additional details to the secret, accessible through the API.

**Returns:**

* `UpdateSecretResponse`: The response after updating the secret.

#### Get Secret by Name

```typescript  theme={"dark"}
	const singleSecret = await client.secrets().getSecret({
    environment: "dev",
		projectId: "<your-project-id>",
		secretName: "DATABASE_URL",
		expandSecretReferences: true, // Optional
    viewSecretValue: true,        // Optional
		includeImports: true,         // Optional
		secretPath: "/foo/bar",       // Optional
		type: "shared",               // Optional
		version: 1                    // Optional
	});
```

**Parameters:**

* `environment` (str): The environment in which to retrieve the secret.
* `projectId` (str): The ID of your project.
* `secretName` (str): The name of the secret.
* `secretPath` (str, optional): The path to the secret.
* `expandSecretReferences` (bool, optional): Whether to expand secret references.
* `viewSecretValue` (bool, optional): Whether or not to reveal the secret value of the secret. If set to `false`, the `secretValue` is masked with `<hidden-by-infisical>`. Defaults to `true`.
* `includeImports` (bool): Whether to include imported secrets.
* `version` (str, optional): The version of the secret to retrieve. Fetches the latest by default.
* `type` (personal | shared, optional): The type of secret to fetch.

**Returns:**

* `Secret`: Returns the secret object.

#### Delete Secret by Name

```typescript  theme={"dark"}
const deletedSecret = await client.secrets().deleteSecret("SECRET_TO_DELETE", {
  environment: "dev",
  projectId: "<your-project-id>",
  secretPath: "/foo/bar", // Optional
  type: "personal"        // Optional
});
```

**Parameters:**

* `secretName` (string): The name of the secret to delete.
* `options` (object):
  * `projectId` (str): The ID of your project.
  * `environment` (str): The environment in which to delete the secret.
  * `secret_path` (str, optional): The path to the secret.
  * `type` (personal | shared, optional): The type of secret to delete.

**Returns:**

* `DeleteSecretResponse`: The response after deleting the secret.

### `dynamicSecrets`

#### Create a new dynamic secret

Creating a new dynamic secret can be done by using the `.dynamicSecrets().create({})` function. More details below.

The input for creating new dynamic secret varies greatly between secret types.
For a more in-depth description of each input type for each dynamic secret type, please refer to [our API documentation](https://infisical.com/docs/api-reference/endpoints/dynamic-secrets/create)

##### Example for creating a new Redis dynamic secret

```typescript  theme={"dark"}
import { InfisicalSDK, DynamicSecretProviders } from "@infisical/sdk";
	const client = new InfisicalSDK();

	await client.auth().universalAuth.login({
		// For localhost
		clientId: "CLIENT_ID",
		clientSecret: "CLIENT_SECRET"
	});
const dynamicSecret = await client.dynamicSecrets().create({
  provider: {
    type: DynamicSecretProviders.Redis,
    inputs: {
      host: "<redis-host>",
      port: 6479,
      username: "<redis-username>",
      password: "<redis-password>", // Only required if your Redis instance uses authentication (recommended)
      creationStatement: "ACL SETUSER {{username}} on >{{password}} ~* &* +@all",
      revocationStatement: "ACL DELUSER {{username}}"
    }
  },
  defaultTTL: "1h",
  maxTTL: "24h",
  name: "dynamic-secret-name",
  projectSlug: "project-slug",
  environmentSlug: "dev"
});
console.log(dynamicSecret);
```

**Returns:**

* `DynamicSecret`: The created dynamic secret.

#### Delete a dynamic secret

Note: Deleting a dynamic secret will also delete it's associated leases.

```typescript  theme={"dark"}
const deletedDynamicSecret = await client.dynamicSecrets().delete("dynamic-secret-name", {
  environmentSlug: "dev",
  projectSlug: "project-slug"
});
```

**Parameters:**

* `secretName` (string): The ID of the dynamic secret to delete
* `options` (object):
  * `projectSlug` (str): The ID of your project.
  * `environment` (str): The environment in which to delete the secret.

**Returns:**

* `DynamicSecret`: The deleted dynamic secret.

### `dynamicSecrets.leases`

In this section you'll learn how to work with dynamic secret leases

#### Create a new lease

```typescript  theme={"dark"}
const lease = await client.dynamicSecrets().leases.create({
  dynamicSecretName: "dynamic-secret-name",
  environmentSlug: "dev",
  projectSlug: "your-project-slug",
  path: "/foo/bar",
  ttl: "5m" // Optional
});

console.log(lease);
```

**Your dynamic secret credentials will be contained user `lease.data` in this example.**

**Parameters:**

* `dynamicSecretName` (string): The name of the dynamic secret you wish to create a lease for.
* `projectSlug` (string): The slug of the project where the secret is located.
* `environmentSlug` (string): The environment where the dynamic secret is located.
* `path` (string, optional): The path of where the dynamic secret is located.
* `ttl` (string, optional): A [vercel/ms](https://github.com/vercel/ms) encoded string representation of how long the lease credentials should be valid for. This will default to the dynamic secret's default TTL if not specified.

**Returns:**

* `CreateLeaseResponse`: The dynamic secret lease result.

#### Delete a lease

```typescript  theme={"dark"}
const deletedLease = await client.dynamicSecrets().leases.delete(newLease.lease.id, {
  environmentSlug: "dev",
  projectSlug: "test-zb-3a",
  path: "/foo/bar",
  isForced: false // Whether or not to forcefully delete the lease. This can't guarantee that the lease will be deleted from the external provider.
});
```

**Parameters:**

* `leaseId` (string): The ID of the lease you want to delete.
* options:
  * `projectSlug` (string): The slug of the project where the secret is located.
  * `environmentSlug` (string): The environment where the dynamic secret is located.
  * `path` (string, optional): The path of where the dynamic secret is located.
  * `isForced` (bool, optional): Whether or not to forcefully delete the lease. This can't guarantee that the lease will be deleted from the external provider, and is potentially unsafe for sensitive dynamic secrets.

**Returns:**

* `DeleteLeaseResponse`: The deleted lease result.

#### Renew a lease

Please note that renewals must happen **before** the lease has fully expired. After renewing the lease, you won't be given new credentials. Instead the existing credentials will continue to live for the specified TTL

```typescript  theme={"dark"}
const renewedLease = await client.dynamicSecrets().leases.renew(newLease.lease.id, {
		environmentSlug: "dev",
		projectSlug: "project-slug",
		path: "/foo/bar", // Optional
		ttl: "10m" // Optional
	});
```

**Parameters:**

* `leaseId` (string): The ID of the lease you want to delete.
* `options` (object):
  * `projectSlug` (string): The slug of the project where the secret is located.
  * `environmentSlug` (string): The environment where the dynamic secret is located.
  * `path` (string, optional): The path of where the dynamic secret is located.
  * `ttl` (string, optional): A [vercel/ms](https://github.com/vercel/ms) encoded string representation of how long the lease credentials should be valid for. This will default to the dynamic secret's default TTL if not specified.

**Returns:**

* `RenewLeaseResponse`: The renewed lease response *(doesn't contain new credentials)*.

### `projects`

#### Create a new project

```typescript  theme={"dark"}
const project = await client.projects().create({
  projectName: "<name-of-project>",
  type: "secret-manager", // cert-manager, secret-manager, kms, ssh
  projectDescription: "<project-description>", // Optional
  slug: "<slug-of-project-to-create>", // Optional
  template: "<project-template-name>", // Optional
  kmsKeyId: "<kms-key-id>" // Optional
});
```

**Parameters:**

* `projectName` (string): The name of the project to create.
* `type` (string): The type of project to create. Valid options are `secret-manager`, `cert-manager`, `kms`, `ssh`
* `projectDescription` (string): An optional description of the project to create.
* `slug` (string): An optional slug for the project to create. If not provided, one will be generated automatically.
* `template` (string): Optionally provide a project template name to use for creating this project.
* `kmsKeyId` (string): The ID of the KMS key to use for the project. Will use the Infisical KMS by default.

**Returns:**

* `Project`: The project that was created.

#### Invite members to a project

When inviting members to projects, you must either specify the `emails` or `usernames`. If neither are specified, the SDK will throw an error.

```typescript  theme={"dark"}
const memberships = await client.projects().inviteMembers({
  projectId: project.id,
  emails: ["test1@example.com", "test2@example.com"], // Optional
  usernames: ["example-user3", "example-user4"] // Optional 
  roleSlugs: ["member"] // Optional
});
```

**Parameters:**

* `projectId`: (string): The ID of the project to invite members to
* `emails`: (string\[]): An array of emails of the users to invite to the project.
* `usernames`: (string\[]) An array of usernames of the users to invite to the project.
* `roleSlugs`: (string\[]): An array of role slugs to assign to the members. If not specified, this will default to `member`.

**Returns:**

* `Membership[]`: An array of the created project memberships.

### `environments`

#### Create a new environment

```typescript  theme={"dark"}
const environment = await client.environments().create({
  name: "<environment-name>",
  projectId: "<your-project-id>",
  slug: "<environment-slug>",
  position: 1 // Optional
});
```

**Parameters:**

* `name` (string): The name of the environment to be created.
* `projectId` (string): The ID of the project to create the environment within.
* `slug`: (string): The slug of the environment to be created.
* `position` (number): An optional position of the environment to be created. The position is used in the Infisical UI to display environments in order. Environments with the lowest position come first.

**Returns:**

* `Environment`: The environment that was created.

#### Create a new folder

```typescript  theme={"dark"}
const folder = await client.folders().create({
  name: "<folder-name>",
  path: "<folder-path>",
  projectId: "<your-project-id>",
  environment: "<environment-slug>",
  description: "<folder-description>" // Optional
});
```

**Parameters:**

* `name` (string): The name of the folder to create.
* `path` (string): The path where of where to create the folder. Defaults to `/`, which is the root folder.
* `projectId` (string): The ID of the project to create the folder within.
* `environment` (string): The slug of the environment to create the folder within.
* `description` (string): An optional folder description.

**Returns:**

* `Folder`: The folder that was created.

#### List folders

```typescript  theme={"dark"}
const folders = await client.folders().listFolders({
  environment: "dev",
  projectId: "<your-project-id>",
  path: "/foo/bar", // Optional
  recursive: false // Optional
});
```

**Parameters:**

* `environment` (string): The slug of the environment to list folders within.
* `projectId` (string): The ID of the project to list folders within.
* `path` (string): The path to list folders within. Defaults to `/`, which is the root folder.
* `recursive` (boolean): An optional flag to list folders recursively. Defaults to `false`.

**Returns:**

* `Folder[]`: An array of folders.

### `kms`

The KMS (Key Management Service) module allows you to create and manage cryptographic keys for encryption and digital signing operations.

#### Create a new KMS key

Creating a new KMS key can be done by using the `.kms().keys().create({})` function. Keys can be created for either encryption/decryption or signing/verification operations.

##### Example for creating an encryption key

```typescript  theme={"dark"}
import { InfisicalSDK, KeyUsage, EncryptionAlgorithm } from "@infisical/sdk";
const client = new InfisicalSDK();

await client.auth().universalAuth.login({
	clientId: "CLIENT_ID",
	clientSecret: "CLIENT_SECRET"
});

const encryptionKey = await client.kms().keys().create({
	projectId: "your-project-id",
	name: "my-encryption-key",
	description: "Key for encrypting sensitive data",
	keyUsage: KeyUsage.ENCRYPTION,
	encryptionAlgorithm: EncryptionAlgorithm.AES_256_GCM
});

console.log(encryptionKey);
```

##### Example for creating a signing key

```typescript  theme={"dark"}
const signingKey = await client.kms().keys().create({
	projectId: "your-project-id",
	name: "my-signing-key",
	description: "Key for signing documents",
	keyUsage: KeyUsage.SIGNING,
	encryptionAlgorithm: EncryptionAlgorithm.RSA_4096
});

console.log(signingKey);
```

**Parameters:**

* `projectId` (string): The ID of your project.
* `name` (string): The name of the KMS key.
* `description` (string, optional): A description of the key's purpose.
* `keyUsage` (KeyUsage): Either `KeyUsage.ENCRYPTION` for encrypt/decrypt operations or `KeyUsage.SIGNING` for sign/verify operations.
* `encryptionAlgorithm` (EncryptionAlgorithm): The algorithm to use. Options include:
  * For encryption: `AES_256_GCM`, `AES_128_GCM`, `RSA_4096`, `ECC_NIST_P256`
  * For signing: `RSA_4096`, `ECC_NIST_P256`

**Returns:**

* `KmsKey`: The created KMS key object.

#### Get a KMS key by name

```typescript  theme={"dark"}
const key = await client.kms().keys().getByName({
	projectId: "your-project-id",
	name: "my-encryption-key"
});

console.log(key);
```

**Parameters:**

* `projectId` (string): The ID of your project.
* `name` (string): The name of the KMS key to retrieve.

**Returns:**

* `KmsKey`: The KMS key object.

#### Delete a KMS key

```typescript  theme={"dark"}
const deletedKey = await client.kms().keys().delete({
	keyId: "<kms-key-id>"
});

console.log(deletedKey);
```

**Parameters:**

* `keyId` (string): The ID of the KMS key to delete.

**Returns:**

* `KmsKey`: The deleted KMS key object.

### `kms.encryption`

The encryption module provides operations for encrypting and decrypting data using KMS keys created with `KeyUsage.ENCRYPTION`.

#### Encrypt data

```typescript  theme={"dark"}
const encrypted = await client.kms().encryption().encrypt({
	keyId: "<kms-key-id>",
	plaintext: "<base64-encoded-data>"
});

console.log(encrypted); // Returns the ciphertext string
```

**Parameters:**

* `keyId` (string): The ID of the encryption key.
* `plaintext` (string): The data to encrypt. This must be base64 encoded.

**Returns:**

* `string`: The encrypted ciphertext.

#### Decrypt data

```typescript  theme={"dark"}
const decrypted = await client.kms().encryption().decrypt({
	keyId: "<kms-key-id>",
	ciphertext: "<encrypted-data>"
});

console.log(decrypted); // Returns the original plaintext
```

**Parameters:**

* `keyId` (string): The ID of the encryption key used to encrypt the data.
* `ciphertext` (string): The encrypted data to decrypt.

**Returns:**

* `string`: The decrypted plaintext.

### `kms.signing`

The signing module provides operations for digitally signing data and verifying signatures using KMS keys created with `KeyUsage.SIGNING`.

#### Sign data

```typescript  theme={"dark"}
import { SigningAlgorithm } from "@infisical/sdk";

const signature = await client.kms().signing().sign({
	keyId: "<kms-key-id>",
	data: "<base64-encoded-data>",
	signingAlgorithm: SigningAlgorithm.RSASSA_PSS_SHA_256,
	isDigest: false // Optional: set to true if data is already a hash digest
});

console.log(signature);
```

**Parameters:**

* `keyId` (string): The ID of the signing key.
* `data` (string): The data to sign.
* `signingAlgorithm` (SigningAlgorithm): The signing algorithm to use. Available algorithms:
  * **RSA PSS** (non-deterministic): `RSASSA_PSS_SHA_256`, `RSASSA_PSS_SHA_384`, `RSASSA_PSS_SHA_512`
  * **RSA PKCS#1 v1.5** (deterministic): `RSASSA_PKCS1_V1_5_SHA_256`, `RSASSA_PKCS1_V1_5_SHA_384`, `RSASSA_PKCS1_V1_5_SHA_512`
  * **ECDSA** (non-deterministic): `ECDSA_SHA_256`, `ECDSA_SHA_384`, `ECDSA_SHA_512`
* `isDigest` (boolean, optional): Whether the data is already a hash digest. Defaults to `false`.

**Returns:**

* `KmsSignDataResponse`: Object containing the signature, keyId, and signingAlgorithm.

#### Verify a signature

```typescript  theme={"dark"}
const verification = await client.kms().signing().verify({
	keyId: "<kms-key-id>",
	data: "<base64-encoded-original-data>", // Must be base64 encoded
	signature: "<data-signature>",
	signingAlgorithm: SigningAlgorithm.RSASSA_PSS_SHA_256,
	isDigest: false // Optional: set to true if data is already a hash digest
});

console.log(verification.signatureValid); // true or false
```

**Parameters:**

* `keyId` (string): The ID of the signing key used to create the signature.
* `data` (string): The original data that was signed (must be base64 encoded).
* `signature` (string): The signature to verify.
* `signingAlgorithm` (SigningAlgorithm): The same signing algorithm used to create the signature.
* `isDigest` (boolean, optional): Whether the data is already a hash digest. Defaults to `false`.

**Returns:**

* `KmsVerifyDataResponse`: Object containing `signatureValid` (boolean), `keyId`, and `signingAlgorithm`.

#### Get supported signing algorithms for a key

```typescript  theme={"dark"}
const algorithms = await client.kms().signing().listSigningAlgorithms({
	keyId: "<kms-key-id>"
});

console.log(algorithms); // Array of supported SigningAlgorithm values
```

**Parameters:**

* `keyId` (string): The ID of the KMS signing key.

**Returns:**

* `SigningAlgorithm[]`: Array of supported signing algorithms for the key.

#### Get public key

Retrieve the public key for signature verification operations.

```typescript  theme={"dark"}
const publicKey = await client.kms().signing().getPublicKey({
	keyId: "<kms-key-id>"
});

console.log(publicKey); // Returns the public key string
```

**Parameters:**

* `keyId` (string): The ID of the KMS signing key.

**Returns:**

* `string`: The public key in PEM format.


# Infisical PHP SDK
Source: https://infisical.com/docs/sdks/languages/php



If you're working with PHP, the official Infisical PHP SDK package is the easiest way to fetch and work with secrets for your application.

## Installation

```bash  theme={"dark"}
composer require infisical/php-sdk
```

## Getting Started

```php  theme={"dark"}
<?php

use Infisical\SDK\InfisicalSDK;

$sdk = new InfisicalSDK('https://app.infisical.com');

// Authenticate with Infisical
$response = $sdk->auth()->universalAuth()->login(
    "your-machine-identity-client-id",
    "your-machine-identity-client-secret"
);

// List secrets
$params = new \Infisical\SDK\Models\ListSecretsParameters(
    environment: "dev",
    secretPath: "/",
    projectId: "your-project-id"
);

$secrets = $sdk->secrets()->list($params);
echo "Fetched secrets: " . count($secrets) . "\n";
```

## Core Methods

The SDK methods are organized into the following high-level categories:

1. `auth`: Handles authentication methods.
2. `secrets`: Manages CRUD operations for secrets.

### `Auth`

The `auth` component provides methods for authentication:

#### Universal Auth

**Authenticating**

```php  theme={"dark"}
$response = $sdk->auth()->universal_auth()->login(
    "your-machine-identity-client-id",
    "your-machine-identity-client-secret"
);
```

**Parameters:**

* `clientId` (string): The client ID of your Machine Identity.
* `clientSecret` (string): The client secret of your Machine Identity.

<Warning>
  We do not recommend hardcoding your [Machine Identity Tokens](/documentation/platform/identities/overview). Setting them as environment variables would be best.
</Warning>

### `Secrets`

This sub-class handles operations related to secrets:

#### List Secrets

```php  theme={"dark"}
use Infisical\SDK\Models\ListSecretsParameters;

$params = new ListSecretsParameters(
    environment: "dev",
    secretPath: "/",
    projectId: "your-project-id",
    tagSlugs: ["tag1", "tag2"], // Optional
    recursive: true, // Optional
    expandSecretReferences: true, // Optional
    attachToProcessEnv: false, // Optional
    skipUniqueValidation: false // Optional
);

$secrets = $sdk->secrets()->list($params);
```

**Parameters:**

* `environment` (string): The environment in which to list secrets (e.g., "dev").
* `projectId` (string): The ID of your project.
* `secretPath` (string, optional): The path to the secrets.
* `tagSlugs` (array, optional): Tags to filter secrets.
* `recursive` (bool, optional): Whether to list secrets recursively.
* `expandSecretReferences` (bool, optional): Whether to expand secret references.
* `attachToProcessEnv` (bool, optional): Whether to attach secrets to process environment variables.
* `skipUniqueValidation` (bool, optional): Whether to skip unique validation.

**Returns:**

* `Secret[]`: An array of secret objects.

#### Create Secret

```php  theme={"dark"}
use Infisical\SDK\Models\CreateSecretParameters;

$params = new CreateSecretParameters(
    secretKey: "SECRET_NAME",
    secretValue: "SECRET_VALUE",
    environment: "dev",
    secretPath: "/",
    projectId: "your-project-id"
);

$createdSecret = $sdk->secrets()->create($params);
```

**Parameters:**

* `secretKey` (string): The name of the secret to create.
* `secretValue` (string): The value of the secret.
* `environment` (string): The environment in which to create the secret.
* `projectId` (string): The ID of your project.
* `secretPath` (string, optional): The path to the secret.

**Returns:**

* `Secret`: The created secret object.

#### Get Secret

```php  theme={"dark"}
use Infisical\SDK\Models\GetSecretParameters;

$params = new GetSecretParameters(
    secretKey: "SECRET_NAME",
    environment: "dev",
    secretPath: "/",
    projectId: "your-project-id"
);

$secret = $sdk->secrets()->get($params);
```

**Parameters:**

* `secretKey` (string): The name of the secret to retrieve.
* `environment` (string): The environment in which to retrieve the secret.
* `projectId` (string): The ID of your project.
* `secretPath` (string, optional): The path to the secret.

**Returns:**

* `Secret`: The retrieved secret object.

#### Update Secret

```php  theme={"dark"}
use Infisical\SDK\Models\UpdateSecretParameters;

$params = new UpdateSecretParameters(
    secretKey: "SECRET_NAME",
    newSecretValue: "UPDATED_SECRET_VALUE",
    environment: "dev",
    secretPath: "/",
    projectId: "your-project-id"
);

$updatedSecret = $sdk->secrets()->update($params);
```

**Parameters:**

* `secretKey` (string): The name of the secret to update.
* `newSecretValue` (string): The new value of the secret.
* `environment` (string): The environment in which to update the secret.
* `projectId` (string): The ID of your project.
* `secretPath` (string, optional): The path to the secret.

**Returns:**

* `Secret`: The updated secret object.

#### Delete Secret

```php  theme={"dark"}
use Infisical\SDK\Models\DeleteSecretParameters;

$params = new DeleteSecretParameters(
    secretKey: "SECRET_NAME",
    environment: "dev",
    secretPath: "/",
    projectId: "your-project-id"
);

$deletedSecret = $sdk->secrets()->delete($params);
```

**Parameters:**

* `secretKey` (string): The name of the secret to delete.
* `environment` (string): The environment in which to delete the secret.
* `projectId` (string): The ID of your project.
* `secretPath` (string, optional): The path to the secret.

**Returns:**

* `Secret`: The deleted secret object.


# Infisical Python SDK
Source: https://infisical.com/docs/sdks/languages/python



If you're working with Python, the official Infisical Python SDK package is the easiest way to fetch and work with secrets for your application.

### Migrating to version 1.0.3 or above

We have recently rolled out our first stable version of the SDK, version `1.0.3` and above.

The 1.0.3 version comes with a few key changes that may change how you're using the SDK.

1. **Removal of `rest`**: The SDK no longer exposes the entire Infisical API. This was nessecary as we have moved away from using an OpenAPI generator approach. We aim to add support for more API resources in the near future. If you have any specific requests, please [open an issue](https://github.com/Infisical/python-sdk-official/issues).

2. **New response types**: The 1.0.3 release uses return types that differ from the older versions. The new return types such as `BaseSecret`, are all exported from the Infisical SDK.

3. **Property renaming**: Some properties on the responses have been slightly renamed. An example of this would be that the `secret_key` property on the `get_secret_by_name()` method, that has been renamed to `secretKey`.

With this in mind, you're ready to upgrade your SDK version to `1.0.3` or above.

You can refer to our [legacy documentation](https://github.com/Infisical/python-sdk-official/tree/9b0403938ee5ae599d42c5f1fdf9158671a15606?tab=readme-ov-file#infisical-python-sdk) if need be.

## Requirements

Python 3.7+

## Installation

```bash  theme={"dark"}
pip install infisicalsdk
```

## Getting Started

```python  theme={"dark"}
from infisical_sdk import InfisicalSDKClient

# Initialize the client
client = InfisicalSDKClient(host="https://app.infisical.com")

# Authenticate (example using Universal Auth)
client.auth.universal_auth.login(
    client_id="<machine-identity-client-id>", 
    client_secret="<machine-identity-client-secret>"
)

# Use the SDK to interact with Infisical
secrets = client.secrets.list_secrets(project_id="<project-id>", environment_slug="dev", secret_path="/")
```

## InfisicalSDKClient Parameters

The `InfisicalSDKClient` takes the following parameters, which are used as a global configuration for the lifetime of the SDK instance.

* **host** (`str`, *Optional*): The host URL for your Infisical instance. Defaults to `https://app.infisical.com`.
* **token** (`str`, *Optional*): Specify an authentication token to use for all requests. If provided, you will not need to call any of the `auth` methods. Defaults to `None`
* **cache\_ttl** (`int`, *Optional*): The SDK has built-in client-side caching for secrets, greatly improving response times. By default, secrets are cached for 1 minute (60 seconds). You can disable caching by setting `cache_ttl` to `None`, or adjust the duration in seconds as needed.

```python  theme={"dark"}
client = InfisicalSDKClient(
  host="https://app.infisical.com", # Defaults to https://app.infisical.com
  token="<optional-auth-token>", # If not set, use the client.auth() methods.
  cache_ttl = 300 # `None` to disable caching
)
```

## Core Methods

The SDK methods are organized into the following high-level categories:

1. `auth`: Handles authentication methods.
2. `secrets`: Manages CRUD operations for secrets.
3. `kms`: Perform cryptographic operations with Infisical KMS.
4. `folders`: Manages folder-related operations.

### `auth`

The `Auth` component provides methods for authentication:

#### Universal Auth

```python  theme={"dark"}
response = client.auth.universal_auth.login(
    client_id="<machine-identity-client-id>", 
    client_secret="<machine-identity-client-secret>"
)
```

#### AWS Auth

```python  theme={"dark"}
response = client.auth.aws_auth.login(identity_id="<machine-identity-id>")
```

#### OIDC Auth

```python  theme={"dark"}
response = client.auth.oidc_auth.login(
    identity_id="<oidc-identity-id>",
    jwt="<your-oidc-jwt-token>"
)
```

**Parameters:**

* `identity_id` (str): The ID of the OIDC identity configuration in Infisical.
* `jwt` (str): The OIDC JWT token obtained from your identity provider.

This authentication method is useful when integrating with OIDC-compliant identity providers like Okta, Auth0, or any service that issues OIDC tokens.

### `secrets`

This sub-class handles operations related to secrets:

#### List Secrets

```python  theme={"dark"}
secrets = client.secrets.list_secrets(
    project_id="<project-id>",
    environment_slug="dev",
    secret_path="/",
    expand_secret_references=True, # Optional
    view_secret_value=True, # Optional 
    recursive=False, # Optional
    include_imports=True, # Optional
    tag_filters=[] # Optional
)
```

**Parameters:**

* `project_id` (str): The ID of your project.
* `project_slug` (str): The slug of your project.
* `environment_slug` (str): The environment in which to list secrets (e.g., "dev").
* `secret_path` (str): The path to the secrets.
* `expand_secret_references` (bool): Whether to expand secret references.
* `view_secret_value` (bool): Whether or not to include the secret value in the response. If set to false, the `secretValue` will be masked with `<hidden-by-infisical>`. Defaults to true.
* `recursive` (bool): Whether to list secrets recursively.
* `include_imports` (bool): Whether to include imported secrets.
* `tag_filters` (List\[str]): Tags to filter secrets.

**Note:** Exactly one of `project_id` or `project_slug` is required. If both are provided, `project_id` takes precedence.

**Returns:**

* `ListSecretsResponse`: The response containing the list of secrets.

#### Create Secret

```python  theme={"dark"}
new_secret = client.secrets.create_secret_by_name(
    secret_name="NEW_SECRET",
    project_id="<project-id>",
    secret_path="/",
    environment_slug="dev",
    secret_value="secret_value",
    secret_comment="Optional comment",
    skip_multiline_encoding=False,
    secret_reminder_repeat_days=30,  # Optional
    secret_reminder_note="Remember to update this secret",  # Optional
    secret_metadata=[{"key": "metadata_key", "value": "metadata_value"}], # Optional
    tags_ids=["tag_id_1", "tag_id_2"] # Optional
)
```

**Parameters:**

* `secret_name` (str): The name of the secret.
* `project_id` (str): The ID of your project.
* `project_slug` (str): The slug of your project.
* `secret_path` (str): The path to the secret.
* `environment_slug` (str): The environment in which to create the secret.
* `secret_value` (str): The value of the secret.
* `secret_comment` (str, optional): A comment associated with the secret.
* `skip_multiline_encoding` (bool, optional): Whether to skip encoding for multiline secrets.
* `secret_reminder_repeat_days` (Union\[float, int], optional): Number of days after which to repeat secret reminders.
* `secret_reminder_note` (str, optional): A note for the secret reminder.
* `secret_metadata` (List\[Dict\[str, Any]], optional): Metadata associated with the secret.
* `tags_ids` (List\[str], optional): IDs of tags to associate with the secret.

**Note:** Exactly one of `project_id` or `project_slug` is required. If both are provided, `project_id` takes precedence.

**Returns:**

* `BaseSecret`: The response after creating the secret.

#### Update Secret

```python  theme={"dark"}
updated_secret = client.secrets.update_secret_by_name(
    current_secret_name="EXISTING_SECRET",
    project_id="<project-id>",
    project_slug="<project-slug>",
    secret_path="/",
    environment_slug="dev",
    secret_value="new_secret_value",
    secret_comment="Updated comment",  # Optional
    skip_multiline_encoding=False,
    secret_reminder_repeat_days=30,  # Optional
    secret_reminder_note="Updated reminder note",  # Optional
    new_secret_name="NEW_NAME",  # Optional
    secret_metadata=[{"key": "metadata_key", "value": "metadata_value"}], # Optional
    tags_ids=["tag_id_1", "tag_id_2"] # Optional
)
```

**Parameters:**

* `current_secret_name` (str): The current name of the secret.
* `project_id` (str): The ID of your project.
* `project_slug` (str): The slug of your project.
* `secret_path` (str): The path to the secret.
* `environment_slug` (str): The environment in which to update the secret.
* `secret_value` (str, optional): The new value of the secret.
* `secret_comment` (str, optional): An updated comment associated with the secret.
* `skip_multiline_encoding` (bool, optional): Whether to skip encoding for multiline secrets.
* `secret_reminder_repeat_days` (Union\[float, int], optional): Updated number of days after which to repeat secret reminders.
* `secret_reminder_note` (str, optional): An updated note for the secret reminder.
* `new_secret_name` (str, optional): A new name for the secret.
* `secret_metadata` (List\[Dict\[str, Any]], optional): Metadata associated with the secret.
* `tags_ids` (List\[str], optional): IDs of tags to associate with the secret.

**Note:** Exactly one of `project_id` or `project_slug` is required. If both are provided, `project_id` takes precedence.

**Returns:**

* `BaseSecret`: The response after updating the secret.

#### Get Secret by Name

```python  theme={"dark"}
secret = client.secrets.get_secret_by_name(
    secret_name="EXISTING_SECRET",
    project_id="<project-id>",
    environment_slug="dev",
    secret_path="/",
    expand_secret_references=True, # Optional
    view_secret_value=True, # Optional
    include_imports=True, # Optional
    version=None # Optional
)
```

**Parameters:**

* `secret_name` (str): The name of the secret.
* `project_id` (str): The ID of your project.
* `project_slug` (str): The slug of your project.
* `environment_slug` (str): The environment in which to retrieve the secret.
* `secret_path` (str): The path to the secret.
* `expand_secret_references` (bool): Whether to expand secret references.
* `view_secret_value` (bool): Whether or not to include the secret value in the response. If set to false, the `secretValue` will be masked with `<hidden-by-infisical>`. Defaults to true.
* `include_imports` (bool): Whether to include imported secrets.
* `version` (str, optional): The version of the secret to retrieve. Fetches the latest by default.

**Note:** Exactly one of `project_id` or `project_slug` is required. If both are provided, `project_id` takes precedence.

**Returns:**

* `BaseSecret`: The response containing the secret.

#### Delete Secret by Name

```python  theme={"dark"}
deleted_secret = client.secrets.delete_secret_by_name(
    secret_name="EXISTING_SECRET",
    project_id="<project-id>",
    environment_slug="dev",
    secret_path="/"
)
```

**Parameters:**

* `secret_name` (str): The name of the secret to delete.
* `project_id` (str): The ID of your project.
* `project_slug` (str): The slug of your project.
* `environment_slug` (str): The environment in which to delete the secret.
* `secret_path` (str): The path to the secret.

**Note:** Exactly one of `project_id` or `project_slug` is required. If both are provided, `project_id` takes precedence.

**Returns:**

* `BaseSecret`: The response after deleting the secret.

### `kms`

This sub-class handles KMS related operations:

#### List KMS Keys

```python  theme={"dark"}
kms_keys = client.kms.list_keys(
    project_id="<project-id>",
    offset=0, # Optional
    limit=100, # Optional
    order_by=KmsKeysOrderBy.NAME, # Optional
    order_direction=OrderDirection.ASC, # Optional
    search=None # Optional
)
```

**Parameters:**

* `project_id` (str): The ID of your project.
* `offset` (int, optional): The offset to paginate from.
* `limit` (int, optional): The page size for paginating.
* `order_by` (KmsKeysOrderBy, optional): The key property to order the list response by.
* `order_direction` (OrderDirection, optional): The direction to order the list response in.
* `search` (str, optional): The text value to filter key names by.

**Returns:**

* `ListKmsKeysResponse`: The response containing the list of KMS keys.

#### Get KMS Key by ID

```python  theme={"dark"}
kms_key = client.kms.get_key_by_id(
    key_id="<key-id>"
)
```

**Parameters:**

* `key_id` (str): The ID of the key to retrieve.

**Returns:**

* `KmsKey`: The specified key.

#### Get KMS Key by Name

```python  theme={"dark"}
kms_key = client.kms.get_key_by_name(
    key_name="my-key",
    project_id="<project-id>"
)
```

**Parameters:**

* `key_name` (str): The name of the key to retrieve.
* `project_id` (str): The ID of your project.

**Returns:**

* `KmsKey`: The specified key.

#### Create KMS Key

```python  theme={"dark"}
kms_key = client.kms.create_key(
    name="my-key",
    project_id="<project-id>",
    encryption_algorithm=SymmetricEncryption.AES_GCM_256,
    description=None # Optional
)
```

**Parameters:**

* `name` (str): The name of the key (must be slug-friendly).
* `project_id` (str): The ID of your project.
* `encryption_algorithm` (SymmetricEncryption): The encryption algorithm this key should use.
* `description` (str, optional): A description of your key.

**Returns:**

* `KmsKey`: The newly created key.

#### Update KMS Key

```python  theme={"dark"}
updated_key = client.kms.update_key(
    key_id="<key-id>",
    name="my-updated-key", # Optional
    description="Updated description", # Optional
    is_disabled=True # Optional
)
```

**Parameters:**

* `key_id` (str): The ID of the key to be updated.
* `name` (str, optional): The updated name of the key (must be slug-friendly).
* `description` (str): The updated description of the key.
* `is_disabled` (str): The flag to disable operations with this key.

**Returns:**

* `KmsKey`: The updated key.

#### Delete KMS Key

```python  theme={"dark"}
deleted_key = client.kms.delete_key(
    key_id="<key-id>"
)
```

**Parameters:**

* `key_id` (str): The ID of the key to be deleted.

**Returns:**

* `KmsKey`: The deleted key.

#### Encrypt Data with KMS Key

```python  theme={"dark"}
encrypted_data = client.kms.encrypt_data(
    key_id="<key-id>",
    base64EncodedPlaintext="TXkgc2VjcmV0IG1lc3NhZ2U=" # must be base64 encoded
)
```

**Parameters:**

* `key_id` (str): The ID of the key to encrypt the data with.
* `base64EncodedPlaintext` (str): The plaintext data to encrypt (must be base64 encoded).

**Returns:**

* `str`: The encrypted ciphertext.

#### Decrypt Data with KMS Key

```python  theme={"dark"}
decrypted_data = client.kms.decrypt_data(
    key_id="<key-id>",
    ciphertext="Aq96Ry7sMH3k/ogaIB5MiSfH+LblQRBu69lcJe0GfIvI48ZvbWY+9JulyoQYdjAx"
)
```

**Parameters:**

* `key_id` (str): The ID of the key to decrypt the data with.
* `ciphertext` (str): The ciphertext returned from the encrypt operation.

**Returns:**

* `str`: The base64 encoded plaintext.

### `folders`

This sub-class handles operations related to folders:

#### List Folders

```python  theme={"dark"}
folders = client.folders.list_folders(
    project_id="<project-id>",
    environment_slug="dev",
    path="/",
    recursive=False, # Optional
    last_secret_modified=None # Optional
)
```

**Parameters:**

* `project_id` (str): The ID of your project.
* `environment_slug` (str): The environment in which to list folders.
* `path` (str): The path to list folders from.
* `recursive` (bool, optional): Whether to list folders recursively from the specified path and downwards. Defaults to `False`.
* `last_secret_modified` (datetime, optional): The timestamp used to filter folders with secrets modified after the specified date. Defaults to `None`.

**Returns:**

* `ListFoldersResponse`: The response containing the list of folders.

#### Create Folder

```python  theme={"dark"}
new_folder = client.folders.create_folder(
    name="my-folder",
    environment_slug="dev",
    project_id="<project-id>",
    path="/", # Optional
    description=None # Optional
)
```

**Parameters:**

* `name` (str): The name of the folder to create.
* `environment_slug` (str): The slug of the environment to create the folder in.
* `project_id` (str): The ID of your project to create the folder in.
* `path` (str, optional): The path to create the folder in. Defaults to `/`.
* `description` (str, optional): An optional description label for the folder. Defaults to `None`.

**Returns:**

* `CreateFolderResponseItem`: The response containing the created folder.

#### Get Folder by ID

```python  theme={"dark"}
folder = client.folders.get_folder_by_id(
    id="<folder-id>"
)
```

**Parameters:**

* `id` (str): The ID of the folder to retrieve.

**Returns:**

* `SingleFolderResponseItem`: The response containing the folder details.


# Infisical Ruby SDK
Source: https://infisical.com/docs/sdks/languages/ruby



If you're working with Ruby, the official Infisical Ruby SDK package is the easiest way to fetch and work with secrets for your application.

* [Ruby Package](https://rubygems.org/gems/infisical-sdk)
* [Github Repository](https://github.com/infisical/sdk)

<Warning>
  **Deprecation Notice**

  All versions prior to **2.3.9** should be considered deprecated and are no longer supported by Infisical. Please update to version **2.3.9** or newer. All changes are fully backwards compatible with older versions.
</Warning>

## Basic Usage

```ruby  theme={"dark"}
require 'infisical-sdk'

# 1. Create the Infisical client
infisical = InfisicalSDK::InfisicalClient.new('https://app.infisical.com')

infisical.auth.universal_auth(client_id: 'YOUR_CLIENT_ID', client_secret: 'YOUR_CLIENT_SECRET')

test_secret = infisical.secrets.get(
  secret_name: 'API_KEY',
  project_id: 'project-id',
  environment: 'dev'
)
puts "Secret: #{single_test_secret}"
```

This example demonstrates how to use the Infisical Ruby SDK in a simple Ruby application. The application retrieves a secret named `API_KEY` from the `dev` environment of the `YOUR_PROJECT_ID` project.

<Warning>
  We do not recommend hardcoding your [Machine Identity Tokens](/documentation/platform/identities/machine-identities). Setting it as an environment variable would be best.
</Warning>

# Installation

```console  theme={"dark"}
$ gem install infisical-sdk
```

# Configuration

Import the SDK and create a client instance.

```ruby  theme={"dark"}
infisical = InfisicalSDK::InfisicalClient.new('https://app.infisical.com') # Optional parameter, default is https://api.infisical.com
```

### Client parameters

<ParamField query="options" type="object">
  <Expandable title="properties">
    <ParamField query="Site URL" type="string" optional>
      The URL of the Infisical API. Default is `https://api.infisical.com`.
    </ParamField>

    <ParamField query="Cache TTL" type="string" required>
      How long the client should cache secrets for. Default is 5 minutes. Disable by setting to 0.
    </ParamField>
  </Expandable>
</ParamField>

### Authentication

The SDK supports a variety of authentication methods. The most common authentication method is Universal Auth, which uses a client ID and client secret to authenticate.

#### Universal Auth

**Using environment variables**

Call `auth.universal_auth()` with empty arguments to use the following environment variables:

* `INFISICAL_UNIVERSAL_AUTH_CLIENT_ID` - Your machine identity client ID.
* `INFISICAL_UNIVERSAL_AUTH_CLIENT_SECRET` - Your machine identity client secret.

**Using the SDK directly**

```ruby  theme={"dark"}
infisical.auth.universal_auth(client_id: 'your-client-id', client_secret: 'your-client-secret')
```

#### GCP ID Token Auth

<Info>
  Please note that this authentication method will only work if you're running your application on Google Cloud Platform.
  Please [read more](/documentation/platform/identities/gcp-auth) about this authentication method.
</Info>

**Using environment variables**

Call `.auth.gcp_id_token_auth()` with empty arguments to use the following environment variables:

* `INFISICAL_GCP_AUTH_IDENTITY_ID` - Your Infisical Machine Identity ID.

**Using the SDK directly**

```ruby  theme={"dark"}
infisical.auth.gcp_id_token_auth(identity_id: 'MACHINE_IDENTITY_ID')
```

#### GCP IAM Auth

**Using environment variables**

Call `.auth.gcp_iam_auth()` with empty arguments to use the following environment variables:

* `INFISICAL_GCP_IAM_AUTH_IDENTITY_ID` - Your Infisical Machine Identity ID.
* `INFISICAL_GCP_IAM_SERVICE_ACCOUNT_KEY_FILE_PATH` - The path to your GCP service account key file.

**Using the SDK directly**

```ruby  theme={"dark"}
infisical.auth.gcp_iam_auth(identity_id: 'MACHINE_IDENTITY_ID', service_account_key_file_path: 'SERVICE_ACCOUNT_KEY_FILE_PATH')
```

#### AWS IAM Auth

<Info>
  Please note that this authentication method will only work if you're running your application on AWS.
  Please [read more](/documentation/platform/identities/aws-auth) about this authentication method.
</Info>

**Using environment variables**

Call `.auth.aws_iam_auth()` with empty arguments to use the following environment variables:

* `INFISICAL_AWS_IAM_AUTH_IDENTITY_ID` - Your Infisical Machine Identity ID.

**Using the SDK directly**

```ruby  theme={"dark"}
infisical.auth.aws_iam_auth(identity_id: 'MACHINE_IDENTITY_ID')
```

#### Azure Auth

<Info>
  Please note that this authentication method will only work if you're running your application on Azure.
  Please [read more](/documentation/platform/identities/azure-auth) about this authentication method.
</Info>

**Using environment variables**

Call `.auth.azure_auth()` with empty arguments to use the following environment variables:

* `INFISICAL_AZURE_AUTH_IDENTITY_ID` - Your Infisical Machine Identity ID.

**Using the SDK directly**

```ruby  theme={"dark"}
infisical.auth.azure_auth(identity_id: 'MACHINE_IDENTITY_ID')
```

#### Kubernetes Auth

<Info>
  Please note that this authentication method will only work if you're running your application on Kubernetes.
  Please [read more](/documentation/platform/identities/kubernetes-auth) about this authentication method.
</Info>

**Using environment variables**

Call `.auth.kubernetes_auth()` with empty arguments to use the following environment variables:

* `INFISICAL_KUBERNETES_IDENTITY_ID` - Your Infisical Machine Identity ID.
* `INFISICAL_KUBERNETES_SERVICE_ACCOUNT_TOKEN_PATH_ENV_NAME` - The environment variable name that contains the path to the service account token. This is optional and will default to `/var/run/secrets/kubernetes.io/serviceaccount/token`.

**Using the SDK directly**

```ruby  theme={"dark"}
# Service account token path will default to /var/run/secrets/kubernetes.io/serviceaccount/token if empty value is passed
infisical.auth.kubernetes_auth(identity_id: 'MACHINE_IDENTITY_ID', service_account_token_path: nil)
```

## Working with Secrets

### client.secrets.list(options)

```ruby  theme={"dark"}
secrets = infisical.secrets.list(
  project_id: 'PROJECT_ID',
  environment: 'dev',
  path: '/foo/bar',
)
```

Retrieve all secrets within the Infisical project and environment that client is connected to

#### Parameters

<ParamField query="Parameters" type="object">
  <Expandable title="properties">
    <ParamField query="environment" type="string" required>
      The slug name (dev, prod, etc) of the environment from where secrets should be fetched from.
    </ParamField>

    <ParamField query="project_id" type="string">
      The project ID where the secret lives in.
    </ParamField>

    <ParamField query="path" type="string" optional>
      The path from where secrets should be fetched from.
    </ParamField>

    <ParamField query="attach_to_process_env" type="boolean" default="false" optional>
      Whether or not to set the fetched secrets to the process environment. If true, you can access the secrets like so `System.getenv("SECRET_NAME")`.
    </ParamField>

    <ParamField query="include_imports" type="boolean" default="false" optional>
      Whether or not to include imported secrets from the current path. Read about [secret import](/documentation/platform/secret-reference)
    </ParamField>

    <ParamField query="recursive" type="boolean" default="false" optional>
      Whether or not to fetch secrets recursively from the specified path. Please note that there's a 20-depth limit for recursive fetching.
    </ParamField>

    <ParamField query="expand_secret_references" type="boolean" default="true" optional>
      Whether or not to expand secret references in the fetched secrets. Read about [secret reference](/documentation/platform/secret-reference)
    </ParamField>
  </Expandable>
</ParamField>

### client.secrets.get(options)

```ruby  theme={"dark"}
secret = infisical.secrets.get(
  secret_name: 'API_KEY',
  project_id: project_id,
  environment: env_slug
)
```

Retrieve a secret from Infisical.

By default, `Secrets().Retrieve()` fetches and returns a shared secret.

#### Parameters

<ParamField query="Parameters" type="object" optional>
  <Expandable title="properties">
    <ParamField query="secret_name" type="string" required>
      The key of the secret to retrieve.
    </ParamField>

    <ParamField query="project_id" type="string" required>
      The project ID where the secret lives in.
    </ParamField>

    <ParamField query="environment" type="string" required>
      The slug name (dev, prod, etc) of the environment from where secrets should be fetched from.
    </ParamField>

    <ParamField query="path" type="string" optional>
      The path from where secret should be fetched from.
    </ParamField>

    <ParamField query="type" type="string" optional>
      The type of the secret. Valid options are "shared" or "personal". If not specified, the default value is "shared".
    </ParamField>
  </Expandable>
</ParamField>

### client.secrets.create(options)

```ruby  theme={"dark"}
new_secret = infisical.secrets.create(
  secret_name: 'NEW_SECRET',
  secret_value: 'SECRET_VALUE',
  project_id: 'PROJECT_ID',
  environment: 'dev',
)
```

Create a new secret in Infisical.

#### Parameters

<ParamField query="Parameters" type="object" optional>
  <Expandable title="properties">
    <ParamField query="secret_name" type="string" required>
      The key of the secret to create.
    </ParamField>

    <ParamField query="secret_value" type="string" required>
      The value of the secret.
    </ParamField>

    <ParamField query="secret_comment" type="string" optional>
      A comment for the secret.
    </ParamField>

    <ParamField query="project_id" type="string" required>
      The project ID where the secret lives in.
    </ParamField>

    <ParamField query="environment" type="string" required>
      The slug name (dev, prod, etc) of the environment from where secrets should be fetched from.
    </ParamField>

    <ParamField query="path" type="string" optional>
      The path from where secret should be created.
    </ParamField>

    <ParamField query="type" type="string" optional>
      The type of the secret. Valid options are "shared" or "personal". If not specified, the default value is "shared".
    </ParamField>
  </Expandable>
</ParamField>

### client.secrets.update(options)

```ruby  theme={"dark"}
updated_secret = infisical.secrets.update(
  secret_name: 'SECRET_KEY_TO_UPDATE',
  secret_value: 'NEW_SECRET_VALUE',
  project_id: 'PROJECT_ID',
  environment: 'dev',
)
```

Update an existing secret in Infisical.

#### Parameters

<ParamField query="Parameters" type="object" optional>
  <Expandable title="properties">
    <ParamField query="secret_name" type="string" required>
      The key of the secret to update.
    </ParamField>

    <ParamField query="secret_value" type="string" required>
      The new value of the secret.
    </ParamField>

    <ParamField query="skip_multiline_encoding" type="boolean" default="false" optional>
      Whether or not to skip multiline encoding for the new secret value.
    </ParamField>

    <ParamField query="project_id" type="string" required>
      The project ID where the secret lives in.
    </ParamField>

    <ParamField query="environment" type="string" required>
      The slug name (dev, prod, etc) of the environment from where secrets should be fetched from.
    </ParamField>

    <ParamField query="path" type="string" optional>
      The path from where secret should be updated.
    </ParamField>

    <ParamField query="type" type="string" optional>
      The type of the secret. Valid options are "shared" or "personal". If not specified, the default value is "shared".
    </ParamField>
  </Expandable>
</ParamField>

### client.secrets.delete(options)

```ruby  theme={"dark"}
deleted_secret = infisical.secrets.delete(
  secret_name: 'SECRET_TO_DELETE',
  project_id: 'PROJECT_ID',
  environment: 'dev',
)
```

Delete a secret in Infisical.

#### Parameters

<ParamField query="Parameters" type="object" optional>
  <Expandable title="properties">
    <ParamField query="secret_name" type="string">
      The key of the secret to update.
    </ParamField>

    <ParamField query="project_id" type="string" required>
      The project ID where the secret lives in.
    </ParamField>

    <ParamField query="environment" type="string" required>
      The slug name (dev, prod, etc) of the environment from where secrets should be fetched from.
    </ParamField>

    <ParamField query="path" type="string" optional>
      The path from where secret should be deleted.
    </ParamField>

    <ParamField query="type" type="string" optional>
      The type of the secret. Valid options are "shared" or "personal". If not specified, the default value is "shared".
    </ParamField>
  </Expandable>
</ParamField>

## Cryptography

### Create a symmetric key

Create a base64-encoded, 256-bit symmetric key to be used for encryption/decryption.

```ruby  theme={"dark"}
key = infisical.cryptography.create_symmetric_key
```

#### Returns (string)

`key` (string): A base64-encoded, 256-bit symmetric key, that can be used for encryption/decryption purposes.

### Encrypt symmetric

```ruby  theme={"dark"}
encrypted_data = infisical.cryptography.encrypt_symmetric(data: "Hello World!", key: key)
```

#### Parameters

<ParamField query="Parameters" type="object" required>
  <Expandable title="properties">
    <ParamField query="data" type="string">
      The plaintext you want to encrypt.
    </ParamField>

    <ParamField query="key" type="string" required>
      The symmetric key to use for encryption.
    </ParamField>
  </Expandable>
</ParamField>

#### Returns (object)

`tag` (string): A base64-encoded, 128-bit authentication tag.
`iv` (string): A base64-encoded, 96-bit initialization vector.
`ciphertext` (string): A base64-encoded, encrypted ciphertext.

### Decrypt symmetric

```ruby  theme={"dark"}
decrypted_data = infisical.cryptography.decrypt_symmetric(
  ciphertext: encrypted_data['ciphertext'],
  iv: encrypted_data['iv'],
  tag: encrypted_data['tag'],
  key: key
)
```

#### Parameters

<ParamField query="Parameters" type="object" required>
  <Expandable title="properties">
    <ParamField query="ciphertext" type="string">
      The ciphertext you want to decrypt.
    </ParamField>

    <ParamField query="key" type="string" required>
      The symmetric key to use for encryption.
    </ParamField>

    <ParamField query="iv" type="string" required>
      The initialization vector to use for decryption.
    </ParamField>

    <ParamField query="tag" type="string" required>
      The authentication tag to use for decryption.
    </ParamField>
  </Expandable>
</ParamField>

#### Returns (string)

`Plaintext` (string): The decrypted plaintext.


# Infisical Rust SDK
Source: https://infisical.com/docs/sdks/languages/rust



If you're working with Rust, the official Infisical Rust SDK package is the easiest way to fetch and work with secrets for your application.

### Installation

```bash  theme={"dark"}
cargo add infisical
```

### Getting Started

The easiest way to get started is to use the builder pattern for both the client and your requests.

```rust  theme={"dark"}
use infisical::{AuthMethod, Client, InfisicalError, encode_base64, decode_base64};
use infisical::secrets::GetSecretRequest;

async fn fetch_secret() -> Result<(), InfisicalError> {
    // 1. Build the client. You can chain methods to configure it.
    let mut client = Client::builder()
        .base_url("https://app.infisical.com") // Optional: defaults to https://app.infisical.com
        .build()
        .await?;

    // 2. Set up your authentication method and log in.
    let auth_method = AuthMethod::new_universal_auth("<your-client-id>", "<your-client-secret>");
    client.login(auth_method).await?;

    // 3. Build a request to get a secret.
    // Required parameters (name, project_id, environment) are passed to `builder()`.
    let request = GetSecretRequest::builder("API_KEY", "<your-project-id>", "dev")
        .path("/") // Optional parameters are set with builder methods.
        .build();

    // 4. Make the API call.
    let secret = client.secrets().get(request).await?;

    println!("Fetched secret key: {}", secret.secret_key);
    // For security, avoid printing the secret value in production code!
    // println!("Secret value: {}", secret.secret_value);

    Ok(())
}
```

### Client Configuration

The `Client::builder()` provides several configuration options:

```rust  theme={"dark"}
let mut client = Client::builder()
    .base_url("https://app.infisical.com") // Optional: set custom Infisical instance URL
    .build()
    .await?;
```

**Parameters**

* `.base_url(url)`: Optional method to set the Infisical instance URL. Defaults to `https://app.infisical.com` for Infisical Cloud. Use `https://eu.infisical.com` for EU and `http://localhost:8080` for local development.

### Core Methods

The SDK methods are organized into the following high-level categories:

* `Client::builder()`: The main entry point for creating a client.
* `client.login()`: Allows client to make authenticated requests to the API.
* `client.secrets()`: Provides access to all CRUD operations for secrets.
* `client.kms()`: Provides access to all KMS (Key Management Service) operations.

### Helper Functions

The SDK provides utility functions for common operations:

```rust  theme={"dark"}
use infisical::{encode_base64, decode_base64};

// Base64 encode a string
let encoded = encode_base64("sensitive data");
println!("Encoded: {}", encoded);

// Base64 decode a string
let decoded = decode_base64(&encoded)?;
println!("Decoded: {}", decoded);
```

**Available Functions**

* `encode_base64(data: &str) -> String`: Encodes a string as base64
* `decode_base64(data: &str) -> Result<String, InfisicalError>`: Decodes a base64 string

### `secrets`

All secret operations are accessed via `client.secrets()`. Each operation has a dedicated request builder.

#### Create Secret

Create a new secret in your project.

**Example**

```rust  theme={"dark"}
use infisical::secrets::CreateSecretRequest;

let request = CreateSecretRequest::builder(
    "API_KEY",
    "your-secret-value",
    "<your-project-id>",
    "dev"
)
.path("/")
.secret_comment("A comment for the new secret")
.build();

let created_secret = client.secrets().create(request).await?;
```

**Parameters**

* `secret_name`, `secret_value`, `project_id`, `environment`: Required parameters passed to the `builder()` function.
* `.path(path)`: Optional method to set the secret's path (defaults to `/`).
* `.secret_comment(comment)`: Optional method to add a comment.
* `.skip_multiline_encoding(bool)`: Optional method to control multiline encoding (defaults to `false`).
* `.r#type(type)`: Optional method to set the secret type (`shared` or `personal`), defaults to `shared`.

#### Get Secret

Retrieve a specific secret by name.

**Example**

```rust  theme={"dark"}
use infisical::secrets::GetSecretRequest;

let request = GetSecretRequest::builder("API_KEY", "<your-project-id>", "dev")
    .path("/")
    .build();

let secret = client.secrets().get(request).await?;
```

**Parameters**

* `secret_name`, `project_id`, `environment`: Required parameters passed to the `builder()` function.
* `.path(path)`: Optional method to set the secret's path (defaults to `/`).
* `.expand_secret_references(bool)`: Optional method to control secret reference expansion (defaults to `true`).
* `.r#type(type)`: Optional method to set the secret type (`shared` or `personal`), defaults to `shared`.

#### List Secrets

List all secrets in a project and environment.

**Example**

```rust  theme={"dark"}
use infisical::secrets::ListSecretsRequest;

let request = ListSecretsRequest::builder("<your-project-id>", "dev")
    .path("/")
    .recursive(true)
    .build();

let secrets = client.secrets().list(request).await?;
```

**Parameters**

* `project_id`, `environment`: Required parameters passed to the `builder()` function.
* `.path(path)`: Optional method to set the path from which to list secrets (defaults to `/`).
* `.expand_secret_references(bool)`: Optional method to control secret reference expansion (defaults to `true`).
* `.recursive(bool)`: Optional method to recursively list secrets from sub-folders (defaults to `false`).
* `.attach_to_process_env(bool)`: Optional method to attach fetched secrets to the current process's environment variables (defaults to `false`).

#### Update Secret

Update an existing secret.

**Example**

```rust  theme={"dark"}
use infisical::secrets::UpdateSecretRequest;

let request = UpdateSecretRequest::builder("API_KEY", "<your-project-id>", "dev")
    .secret_value("new-secret-value") // Set the new value
    .build();

let updated_secret = client.secrets().update(request).await?;
```

**Parameters**

* `secret_name`, `project_id`, `environment`: Required parameters passed to the `builder()` function.
* `.new_secret_name(name)`: Optional method to rename the secret.
* `.secret_value(value)`: Optional method to set a new value for the secret.
* `.path(path)`: Optional method to set the secret's path.
* `.secret_comment(comment)`: Optional method to add or change the comment.
* `.skip_multiline_encoding(bool)`: Optional method to control multiline encoding.
* `.r#type(type)`: Optional method to set the secret type (`shared` or `personal`).

#### Delete Secret

Delete a secret from your project.

**Example**

```rust  theme={"dark"}
use infisical::secrets::DeleteSecretRequest;

let request = DeleteSecretRequest::builder("API_KEY", "<your-project-id>", "dev")
    .path("/")
    .build();

let deleted_secret = client.secrets().delete(request).await?;
```

**Parameters**

* `secret_name`, `project_id`, `environment`: Required parameters passed to the `builder()` function.
* `.path(path)`: Optional method to set the secret's path (defaults to `/`).
* `.r#type(type)`: Optional method to set the secret type (`shared` or `personal`), defaults to `shared`.

### `kms`

All KMS (Key Management Service) operations are accessed via `client.kms()`. Each operation has a dedicated request builder.

#### List KMS Keys

List all KMS keys in a project.

**Example**

```rust  theme={"dark"}
use infisical::kms::ListKmsKeysRequest;

let request = ListKmsKeysRequest::builder("<your-project-id>").build();

let keys = client.kms().list(request).await?;
```

**Parameters**

* `project_id`: Required parameter passed to the `builder()` function.

#### Get KMS Key

Retrieve a specific KMS key by ID.

**Example**

```rust  theme={"dark"}
use infisical::kms::GetKmsKeyRequest;

let request = GetKmsKeyRequest::builder("<key-id>").build();

let key = client.kms().get(request).await?;
```

**Parameters**

* `key_id`: Required parameter passed to the `builder()` function.

#### Get KMS Key by Name

Retrieve a specific KMS key by name.

**Example**

```rust  theme={"dark"}
use infisical::kms::GetKmsKeyByNameRequest;

let request = GetKmsKeyByNameRequest::builder("<key-name>").build();

let key = client.kms().get_by_name(request).await?;
```

**Parameters**

* `key_name`: Required parameter passed to the `builder()` function.

#### Create KMS Key

Create a new KMS key in your project.

**Example**

```rust  theme={"dark"}
use infisical::kms::{CreateKmsKeyRequest, EncryptionAlgorithm, KeyUsage};

let request = CreateKmsKeyRequest::builder("<your-project-id>", "my-key")
    .description("A key for encryption operations")
    .key_usage(KeyUsage::EncryptDecrypt)
    .encryption_algorithm(EncryptionAlgorithm::Aes256Gcm)
    .build();

let created_key = client.kms().create(request).await?;
```

**Parameters**

* `project_id`, `name`: Required parameters passed to the `builder()` function.
* `.description(description)`: Optional method to set the key description.
* `.key_usage(usage)`: Optional method to set the key usage using the `KeyUsage` enum (defaults to `KeyUsage::EncryptDecrypt`).
* `.encryption_algorithm(algorithm)`: Optional method to set the encryption algorithm using the `EncryptionAlgorithm` enum (defaults to `EncryptionAlgorithm::Aes256Gcm`).

#### Update KMS Key

Update an existing KMS key.

**Example**

```rust  theme={"dark"}
use infisical::kms::UpdateKmsKeyRequest;

let request = UpdateKmsKeyRequest::builder("<key-id>")
    .name("updated-key-name")
    .description("Updated description")
    .is_disabled(false)
    .build();

let updated_key = client.kms().update(request).await?;
```

**Parameters**

* `key_id`: Required parameter passed to the `builder()` function.
* `.name(name)`: Optional method to rename the key.
* `.description(description)`: Optional method to update the key description.
* `.is_disabled(disabled)`: Optional method to enable or disable the key.

#### Delete KMS Key

Delete a KMS key from your project.

**Example**

```rust  theme={"dark"}
use infisical::kms::DeleteKmsKeyRequest;

let request = DeleteKmsKeyRequest::builder("<key-id>").build();

let deleted_key = client.kms().delete(request).await?;
```

**Parameters**

* `key_id`: Required parameter passed to the `builder()` function.

#### Encrypt Data

Encrypt data using a KMS key.

**Example**

```rust  theme={"dark"}
use infisical::kms::EncryptRequest;

let request = EncryptRequest::builder("<key-id>", "sensitive data").build();

let ciphertext = client.kms().encrypt(request).await?;
```

**Parameters**

* `key_id`, `plaintext`: Required parameters passed to the `builder()` function.

#### Decrypt Data

Decrypt data using a KMS key.

**Example**

```rust  theme={"dark"}
use infisical::kms::DecryptRequest;

let request = DecryptRequest::builder("<key-id>", "encrypted-data").build();

let plaintext = client.kms().decrypt(request).await?;
```

**Parameters**

* `key_id`, `ciphertext`: Required parameters passed to the `builder()` function.

#### Sign Data

Sign data using a KMS key.

**Example**

```rust  theme={"dark"}
use infisical::kms::{SigningAlgorithm, SignRequest};

let request = SignRequest::builder("<key-id>", "data to sign")
    .signing_algorithm(SigningAlgorithm::RsassaPkcs1V15Sha256)
    .is_digest(false)
    .build();

let signature = client.kms().sign(request).await?;
```

**Parameters**

* `key_id`, `data`: Required parameters passed to the `builder()` function.
* `.signing_algorithm(algorithm)`: Optional method to set the signing algorithm using the `SigningAlgorithm` enum (defaults to `SigningAlgorithm::RsassaPkcs1V15Sha256`).
* `.is_digest(is_digest)`: Optional method to indicate if the data is a digest (defaults to `false`).

#### Verify Signature

Verify a signature using a KMS key.

**Example**

```rust  theme={"dark"}
use infisical::kms::{SigningAlgorithm, VerifyRequest};

let request = VerifyRequest::builder("<key-id>", "data to sign", "signature")
    .signing_algorithm(SigningAlgorithm::RsassaPkcs1V15Sha256)
    .is_digest(false)
    .build();

let verification = client.kms().verify(request).await?;
```

**Parameters**

* `key_id`, `data`, `signature`: Required parameters passed to the `builder()` function.
* `.signing_algorithm(algorithm)`: Optional method to set the signing algorithm using the `SigningAlgorithm` enum (defaults to `SigningAlgorithm::RsassaPkcs1V15Sha256`).
* `.is_digest(is_digest)`: Optional method to indicate if the data is a digest (defaults to `false`).

#### Get Public Key

Get the public key for a KMS key.

**Example**

```rust  theme={"dark"}
let public_key = client.kms().get_public_key("<key-id>").await?;
```

**Parameters**

* `key_id`: The ID of the key to get the public key for.

#### Get Signing Algorithms

Get the available signing algorithms for a KMS key.

**Example**

```rust  theme={"dark"}
let algorithms = client.kms().get_signing_algorithms("<key-id>").await?;
```

**Parameters**

* `key_id`: The ID of the key to get signing algorithms for.

## Development and Testing

### Environment Setup

For development and testing, you'll need to set up environment variables. Create a `.env` file in your project root:

```env  theme={"dark"}
INFISICAL_CLIENT_ID=your_client_id_here
INFISICAL_CLIENT_SECRET=your_client_secret_here
INFISICAL_BASE_URL=http://localhost:8080  # Optional: for local development

# Project IDs for different resources
INFISICAL_SECRETS_PROJECT_ID=your_project_id_here
INFISICAL_KMS_PROJECT_ID=your_project_id_here
```

### Getting Credentials

To obtain the required credentials:

1. **Client ID and Secret**: Create a Universal Auth machine identity in your Infisical project settings
2. **Project ID**: Found in your project settings or URL when viewing a project in the Infisical dashboard

### Running Tests

Tests that require authentication are marked with `#[ignore]` and need valid credentials:

```bash  theme={"dark"}
# Run ignored tests (requires .env file with valid credentials)
cargo test -- --ignored --nocapture

# Run a specific test
cargo test test_kms_resource -- --ignored --nocapture
```

**Note**: Integration tests require a running Infisical instance and valid authentication credentials.


# SDKs
Source: https://infisical.com/docs/sdks/overview



From local development to production, Infisical SDKs provide the easiest way for your app to fetch back secrets from Infisical on demand.

* Install and initialize a language-specific client SDK into your application
* Provision the client scoped-access to a project and environment in Infisical
* Fetch secrets on demand

<CardGroup cols={2}>
  <Card title="Node.js" href="/sdks/languages/node" icon="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sdks/languages/node.svg">
    Manage secrets for your Node application on demand
  </Card>

  <Card href="/sdks/languages/python" title="Python" icon="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sdks/languages/python.svg">
    Manage secrets for your Python application on demand
  </Card>

  <Card href="/sdks/languages/java" title="Java" icon="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sdks/languages/java.svg">
    Manage secrets for your Java application on demand
  </Card>

  <Card href="/sdks/languages/dotnet" title=".NET" icon="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sdks/languages/dotnet.svg">
    Manage secrets for your .NET application on demand
  </Card>

  <Card href="/sdks/languages/cpp" title="C++" icon="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sdks/languages/cpp.svg">
    Manage secrets for your C++ application on demand
  </Card>

  <Card href="/sdks/languages/rust" title="Rust" icon="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sdks/languages/rust.svg">
    Manage secrets for your Rust application on demand
  </Card>

  <Card href="/sdks/languages/go" title="Go" icon="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sdks/languages/go.svg">
    Manage secrets for your Go application on demand
  </Card>

  <Card href="/sdks/languages/php" title="PHP" icon="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sdks/languages/php.svg">
    Manage secrets for your PHP application on demand
  </Card>

  <Card href="/sdks/languages/ruby" title="Ruby" icon="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/sdks/languages/ruby.svg">
    Manage secrets for your Ruby application on demand
  </Card>
</CardGroup>

<Card title="Did we miss your favorite language?">
  We're always looking for new languages to support. If you'd like to see a new language added, please let us know by opening an issue on our [GitHub repository](https://github.com/Infisical/infisical/issues).
</Card>

## FAQ

<AccordionGroup>
  <Accordion title="What if a request for a secret fails?">
    The SDK caches every secret and falls back to the cached value if a request fails. If no cached
    value ever-existed, the SDK falls back to whatever value is on the process environment.
  </Accordion>

  <Accordion title="Can I attach the environment variables to my process environment?">
    Yes you can! The client SDK provides a method to attach the secrets to your process environment. When using the `listSecrets()` method, you
    can pass a `attachToProcessEnv` parameter, which tells the SDK to attach all the found secrets to your process environment.

    Note: The exact parameter name may differ depending on the language.
  </Accordion>
</AccordionGroup>


# Environment Variables
Source: https://infisical.com/docs/self-hosting/configuration/envars

Read how to configure environment variables for self-hosted Infisical.

Infisical accepts all configurations via environment variables. For a minimal self-hosted instance, at least `ENCRYPTION_KEY`, `AUTH_SECRET`, `DB_CONNECTION_URI` and `REDIS_URL` must be defined.
However, you can configure additional settings to activate more features as needed.

## General platform

Used to configure platform-specific security and operational settings

<ParamField query="ENCRYPTION_KEY" type="string" default="none" required>
  Must be a random 16 byte hex string. Can be generated with `openssl rand -hex
    16`
</ParamField>

<ParamField query="AUTH_SECRET" type="string" default="none" required>
  Must be a random 32 byte base64 string. Can be generated with `openssl rand
    -base64 32`
</ParamField>

<ParamField query="SITE_URL" type="string" default="none" required>
  Must be an absolute URL including the protocol (e.g.
  [https://app.infisical.com](https://app.infisical.com)).
</ParamField>

<ParamField query="PORT" type="int" default="8080" optional>
  Specifies the internal port on which the application listens.
</ParamField>

<ParamField query="HOST" type="string" default="localhost" optional>
  Specifies the network interface Infisical will bind to when accepting incoming connections.

  By default, Infisical binds to `localhost`, which restricts access to connections from the same machine.

  To make the application accessible externally (e.g., for self-hosted deployments), set this to `0.0.0.0`, which tells the server to listen on all network interfaces.

  Example values:

  * `localhost` (default, same as `127.0.0.1`)
  * `0.0.0.0` (all interfaces, accessible externally)
  * `192.168.1.100` (specific interface IP)
</ParamField>

<ParamField query="TELEMETRY_ENABLED" type="string" default="true" optional>
  Telemetry helps us improve Infisical but if you want to disable it you may set
  this to `false`.
</ParamField>

<ParamField query="ALLOW_INTERNAL_IP_CONNECTIONS" type="bool" default="false" optional>
  Determines whether App Connections and Dynamic Secrets are permitted to
  connect with internal/private IP addresses.
</ParamField>

<ParamField query="KUBERNETES_AUTO_FETCH_SERVICE_ACCOUNT_TOKEN" type="bool" default="false" optional>
  Determines whether your Infisical instance can automatically read the service
  account token of the pod it's running on. Used for features such as the IRSA
  auth method.
</ParamField>

<ParamField query="DISABLE_AUDIT_LOG_STORAGE" type="string" default="false">
  Disable storing audit logs in the database. This is useful if you're using
  audit log streams and don't want to store them in the database.
</ParamField>

## CORS

Cross-Origin Resource Sharing (CORS) is a security feature that allows web applications running on one domain to access resources from another domain.
The following environment variables can be used to configure the Infisical Rest API to allow or restrict access to resources from different origins.

<ParamField query="CORS_ALLOWED_ORIGINS" type="string" optional>
  Specify a list of origins that are allowed to access the Infisical API.

  An example value would be `CORS_ALLOWED_ORIGINS=["https://example.com"]`.

  Defaults to the same value as your `SITE_URL` environment variable.
</ParamField>

<ParamField query="CORS_ALLOWED_METHODS" type="string" optional>
  Array of HTTP methods allowed for CORS requests.

  Defaults to reflecting the headers specified in the request's Access-Control-Request-Headers header.
</ParamField>

## Data Layer

The platform utilizes Postgres to persist all of its data and Redis for caching and backgroud tasks

### PostgreSQL

<Info>
  Please note that the database user you create must be granted all privileges
  on the Infisical database. This includes the ability to create new schemas,
  create, update, delete, modify tables and indexes, etc.
</Info>

<ParamField query="DB_CONNECTION_URI" type="string" default="" required>
  Postgres database connection string.
</ParamField>

<ParamField query="DB_ROOT_CERT" type="string" default="" optional>
  Configure the SSL certificate for securing a Postgres connection by first encoding it in base64.
  Use the following command to encode your certificate: `echo "<certificate>" | base64`

  Many cloud providers provide a CA certificate for their data regions that you can use to secure your connection with SSL.

  <AccordionGroup>
    <Accordion title="AWS RDS">
      If you're hosting your database on AWS RDS, you can use their publicly available CA certificate as the database root certificate.

      You can find all the available CA certificates for AWS RDS on the official [AWS RDS documentation](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/UsingWithRDS.SSL.html).

      As an example, if your RDS cluster is hosted in `us-east-1` *(US East, N. Virginia)*, you can use the following root certificate: [https://truststore.pki.rds.amazonaws.com/us-east-1/us-east-1-bundle.pem](https://truststore.pki.rds.amazonaws.com/us-east-1/us-east-1-bundle.pem).

      All the available CA certificates can be found in the AWS RDS documentation linked above.

      Remember to base64 encode the certificate before setting it as the `DB_ROOT_CERT` environment variable. `cat /path/to/certificate.pem | base64`.

      ```bash  theme={"dark"}
      DB_ROOT_CERT=LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1 # .... (base64 encoded certificate)
      DB_CONNECTION_URI=<rds-endpoint>?sslmode=verify-ca # or verify-full depending on your security policies
      ```
    </Accordion>
  </AccordionGroup>
</ParamField>

<ParamField query="DB_READ_REPLICAS" type="string" default="" optional>
  Postgres database read replica connection strings. It accepts a JSON string.

  ```
  DB_READ_REPLICAS=[{"DB_CONNECTION_URI":""}]
  ```

  <Expandable title="Format">
    <ParamField query="DB_CONNECTION_URI" type="string" default="" required>
      Postgres read replica connection string.
    </ParamField>

    <ParamField query="DB_ROOT_CERT" type="string" default="" optional>
      Configure the SSL certificate for securing a Postgres replica connection by first encoding it in base64.
      Use the following command to encode your certificate: `echo "<certificate>" | base64`

      If not provided it will use master SSL certificate.
    </ParamField>
  </Expandable>
</ParamField>

### Redis

Redis is used for caching and background tasks. You can use either a standalone Redis instance or a Redis Sentinel setup.

<Tabs>
  <Tab title="Redis Standalone">
    <ParamField query="REDIS_URL" type="string" default="none" required>
      Redis connection string.
    </ParamField>
  </Tab>

  <Tab title="Redis Sentinel">
    <ParamField query="REDIS_SENTINEL_HOSTS" type="string" default="none" required>
      Comma-separated list of Sentinel host:port pairs. `      192.168.65.254:26379,192.168.65.254:26380`
    </ParamField>

    <ParamField query="REDIS_SENTINEL_MASTER_NAME" type="string" default="mymaster">
      The name of the Redis master set monitored by Sentinel
    </ParamField>

    <ParamField query="REDIS_SENTINEL_ENABLE_TLS" type="bool" default="false">
      Whether to use TLS/SSL for Redis Sentinel connection
    </ParamField>

    <ParamField query="REDIS_SENTINEL_USERNAME" type="string" default="none">
      Authentication username for Redis Sentinel
    </ParamField>

    <ParamField query="REDIS_SENTINEL_PASSWORD" type="string" default="none">
      Authentication password for Redis Sentinel
    </ParamField>

    <ParamField query="REDIS_USERNAME" type="string" default="none">
      Authentication username for Redis Node
    </ParamField>

    <ParamField query="REDIS_PASSWORD" type="string" default="none">
      Authentication password for Redis Node
    </ParamField>
  </Tab>

  <Tab title="Redis Cluster">
    <ParamField query="REDIS_CLUSTER_HOSTS" type="string" default="none" required>
      Comma-separated list of Redis Cluster host:port pairs. `      192.168.65.254:26379,192.168.65.254:26380`
    </ParamField>

    <ParamField query="REDIS_CLUSTER_ENABLE_TLS" type="boolean" default="false">
      Enable Redis TLS encryption on connection.
    </ParamField>

    <ParamField query="REDIS_CLUSTER_AWS_ELASTICACHE_DNS_LOOKUP_MODE" type="boolean" default="false">
      Enable this if you are using AWS encrypt on transit for Elasticache cluster. For more information refer ![here](https://github.com/redis/ioredis?tab=readme-ov-file#special-note-aws-elasticache-clusters-with-tls).
    </ParamField>

    <ParamField query="REDIS_USERNAME" type="string" default="none">
      Authentication username for Redis Node
    </ParamField>

    <ParamField query="REDIS_PASSWORD" type="string" default="none">
      Authentication password for Redis Node
    </ParamField>
  </Tab>

  <Tab title="Redis Read Replica">
    <ParamField query="REDIS_READ_REPLICAS" type="string" default="none" optional>
      Comma-separated list of Redis read replicas host:port pairs. `      192.168.65.254:26379,192.168.65.254:26380`
    </ParamField>

    The paramters like username, password, tls, redis type of the primary instance will be inherited.
  </Tab>
</Tabs>

## Email Service

Without email configuration, Infisical's core functions like sign-up/login and secret operations work, but this disables multi-factor authentication, email invites for projects, alerts for suspicious logins, and all other email-dependent features.

<Accordion title="Generic Configuration">
  <ParamField query="SMTP_HOST" type="string" default="none" optional>
    Hostname to connect to for establishing SMTP connections
  </ParamField>

  <ParamField query="SMTP_PORT" type="string" default="587" optional>
    Port to connect to for establishing SMTP connections
  </ParamField>

  <ParamField query="SMTP_USERNAME" type="string" default="none" optional>
    Credential to connect to host (e.g. [team@infisical.com](mailto:team@infisical.com))
  </ParamField>

  <ParamField query="SMTP_PASSWORD" type="string" default="none" optional>
    Credential to connect to host
  </ParamField>

  <ParamField query="SMTP_FROM_ADDRESS" type="string" default="none" optional>
    Email address to be used for sending emails
  </ParamField>

  <ParamField query="SMTP_FROM_NAME" type="string" default="none" optional>
    Name label to be used in From field (e.g. Team)
  </ParamField>

  <ParamField query="SMTP_IGNORE_TLS" type="bool" default="false" optional>
    If this is `true` and `SMTP_PORT` is not 465 then TLS is not used even if the
    server supports STARTTLS extension.
  </ParamField>

  <ParamField query="SMTP_REQUIRE_TLS" type="bool" default="true" optional>
    If this is `true` and `SMTP_PORT` is not 465 then Infisical tries to use
    STARTTLS even if the server does not advertise support for it. If the
    connection can not be encrypted then message is not sent.
  </ParamField>

  <ParamField query="SMTP_TLS_REJECT_UNAUTHORIZED" type="bool" default="true" optional>
    If this is `true`, Infisical will validate the server's SSL/TLS certificate
    and reject the connection if the certificate is invalid or not trusted. If set
    to `false`, the client will accept the server's certificate regardless of its
    validity, which can be useful in development or testing environments but is
    not recommended for production use.
  </ParamField>

  <ParamField query="SMTP_CUSTOM_CA_CERT" type="string" default="none" optional>
    If your SMTP server uses a certificate signed by a custom Certificate Authority, you should set this variable so that Infisical can trust the custom CA.

    This variable **must be a base64 encoded PEM certificate**. Use the following command to encode your certificate: `echo "<certificate>" | base64`

    Infisical highly encourages the following variables be used alongside this one for maximum security:

    * `SMTP_REQUIRE_TLS=true`
    * `SMTP_TLS_REJECT_UNAUTHORIZED=true`
  </ParamField>
</Accordion>

<Accordion title="Twilio SendGrid">
  1. Create an account and configure [SendGrid](https://sendgrid.com) to send emails.
  2. Create a SendGrid API Key under Settings > [API Keys](https://app.sendgrid.com/settings/api_keys)
  3. Set a name for your API Key, we recommend using "Infisical," and select the "Restricted Key" option. You will need to enable the "Mail Send" permission as shown below:

    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/self-hosting/configuration/email/email-sendgrid-create-key.png" alt="creating sendgrid api key" />

    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/self-hosting/configuration/email/email-sendgrid-restrictions.png" alt="setting sendgrid api key restriction" />

  4. With the API Key, you can now set your SMTP environment variables:

  ```
  SMTP_HOST=smtp.sendgrid.net
  SMTP_USERNAME=apikey
  SMTP_PASSWORD=SG.rqFsfjxYPiqE1lqZTgD_lz7x8IVLx # your SendGrid API Key from step above
  SMTP_PORT=587
  SMTP_FROM_ADDRESS=hey@example.com # your email address being used to send out emails
  SMTP_FROM_NAME=Infisical
  ```

  <Info>
    Remember that you will need to restart Infisical for this to work properly.
  </Info>
</Accordion>

<Accordion title="Mailgun">
  1. Create an account and configure [Mailgun](https://www.mailgun.com) to send emails.
  2. Obtain your Mailgun credentials in Sending > Overview > SMTP

    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/self-hosting/configuration/email/email-mailhog-credentials.png" alt="obtain mailhog api key estriction" />

  3. With your Mailgun credentials, you can now set up your SMTP environment variables:

  ```
  SMTP_HOST=smtp.mailgun.org # obtained from credentials page
  SMTP_USERNAME=postmaster@example.mailgun.org # obtained from credentials page
  SMTP_PASSWORD=password # obtained from credentials page
  SMTP_PORT=587
  SMTP_FROM_ADDRESS=hey@example.com # your email address being used to send out emails
  SMTP_FROM_NAME=Infisical
  ```
</Accordion>

<Accordion title="AWS SES">
  <Steps>
    <Step title="Create a verifed identity">
      This will be used to verify the email you are sending from.
      <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/self-hosting/configuration/email/ses-create-identity.png" alt="Create SES identity" />

      <Info>
        If you AWS SES is under sandbox mode, you will only be able to send emails to verified identies.
      </Info>
    </Step>

    <Step title="Create an account and configure AWS SES">
      Create an IAM user for SMTP authentication and obtain SMTP credentials in SMTP settings > Create SMTP credentials

            <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/self-hosting/configuration/email/email-aws-ses-console.png" alt="opening AWS SES console" />

            <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/self-hosting/configuration/email/email-aws-ses-user.png" alt="creating AWS IAM SES user" />
    </Step>

    <Step title="Set up your SMTP environment variables">
      With your AWS SES SMTP credentials, you can now set up your SMTP environment variables for your Infisical instance.

      ```
      SMTP_HOST=email-smtp.ap-northeast-1.amazonaws.com # SMTP endpoint obtained from SMTP settings
      SMTP_USERNAME=xxx # your SMTP username
      SMTP_PASSWORD=xxx # your SMTP password
      SMTP_PORT=465
      SMTP_FROM_ADDRESS=hey@example.com # your email address being used to send out emails
      SMTP_FROM_NAME=Infisical
      ```
    </Step>
  </Steps>

  <Info>
    Remember that you will need to restart Infisical for this to work properly.
  </Info>
</Accordion>

<Accordion title="SocketLabs">
  1. Create an account and configure [SocketLabs](https://www.socketlabs.com/) to send emails.
  2. From the dashboard, navigate to SMTP Credentials > SMTP & APIs > SMTP Credentials to obtain your SocketLabs SMTP credentials.

    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/self-hosting/configuration/email/email-socketlabs-dashboard.png" alt="opening SocketLabs dashboard" />

    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/self-hosting/configuration/email/email-socketlabs-credentials.png" alt="obtaining SocketLabs credentials" />

  3. With your SocketLabs SMTP credentials, you can now set up your SMTP environment variables:

  ```
  SMTP_HOST=smtp.socketlabs.com
  SMTP_USERNAME=username # obtained from your credentials
  SMTP_PASSWORD=password # obtained from your credentials
  SMTP_PORT=587
  SMTP_FROM_ADDRESS=hey@example.com # your email address being used to send out emails
  SMTP_FROM_NAME=Infisical
  ```

  {" "}

  <Note>
    The `SMTP_FROM_ADDRESS` environment variable should be an email for an
    authenticated domain under Configuration > Domain Management in SocketLabs.
    For example, if you're using SocketLabs in sandbox mode, then you may use an
    email like `team@sandbox.socketlabs.dev`.
  </Note>

    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/self-hosting/configuration/email/email-socketlabs-domains.png" alt="SocketLabs domain management" />

  <Info>
    Remember that you will need to restart Infisical for this to work properly.
  </Info>
</Accordion>

<Accordion title="Resend">
  1. Create an account on [Resend](https://resend.com).
  2. Add a [Domain](https://resend.com/domains).

    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/self-hosting/configuration/email/email-resend-create-domain.png" alt="adding resend domain" />

  3. Create an [API Key](https://resend.com/api-keys).

    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/self-hosting/configuration/email/email-resend-create-key.png" alt="creating resend api key" />

  4. Go to the [SMTP page](https://resend.com/settings/smtp) and copy the values.

    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/self-hosting/configuration/email/email-resend-smtp-settings.png" alt="go to resend smtp settings" />

  5. With the API Key, you can now set your SMTP environment variables variables:

  ```
  SMTP_HOST=smtp.resend.com
  SMTP_USERNAME=resend
  SMTP_PASSWORD=YOUR_API_KEY
  SMTP_PORT=587
  SMTP_FROM_ADDRESS=hey@example.com # your email address being used to send out emails
  SMTP_FROM_NAME=Infisical
  ```

  <Info>
    Remember that you will need to restart Infisical for this to work properly.
  </Info>
</Accordion>

<Accordion title="Gmail">
  Create an account and enable "less secure app access" in Gmail Account Settings > Security. This will allow
  applications like Infisical to authenticate with Gmail via your username and password.

    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/self-hosting/configuration/email/email-gmail-app-access.png" alt="Gmail secure app access" />

  With your Gmail username and password, you can set your SMTP environment variables:

  ```
  SMTP_HOST=smtp.gmail.com
  SMTP_USERNAME=hey@gmail.com # your email
  SMTP_PASSWORD=password # your password
  SMTP_PORT=587
  SMTP_FROM_ADDRESS=hey@gmail.com
  SMTP_FROM_NAME=Infisical
  ```

  <Warning>
    As per the [notice](https://support.google.com/accounts/answer/6010255?hl=en) by Google, you should note that using Gmail credentials for SMTP configuration
    will only work for Google Workspace or Google Cloud Identity customers as of May 30, 2022.

    Put differently, the SMTP configuration is only possible with business (not personal) Gmail credentials.
  </Warning>
</Accordion>

<Accordion title="Office365">
  1. Create an account and configure [Office365](https://www.office.com/) to send emails.

  2. With your login credentials, you can now set up your SMTP environment variables:

  ```
  SMTP_HOST=smtp.office365.com
  SMTP_USERNAME=username@yourdomain.com # your username
  SMTP_PASSWORD=password # your password
  SMTP_PORT=587
  SMTP_FROM_ADDRESS=username@yourdomain.com
  SMTP_FROM_NAME=Infisical
  ```
</Accordion>

<Accordion title="Zoho Mail">
  1. Create an account and configure [Zoho Mail](https://www.zoho.com/mail/) to send emails.

  2. With your email credentials, you can now set up your SMTP environment variables:

  ```
  SMTP_HOST=smtp.zoho.com
  SMTP_USERNAME=username # your email
  SMTP_PASSWORD=password # your password
  SMTP_PORT=587
  SMTP_FROM_ADDRESS=hey@example.com # your personal Zoho email or domain-based email linked to Zoho Mail
  SMTP_FROM_NAME=Infisical
  ```

  {" "}

  <Note>
    You can use either your personal Zoho email address like `you@zohomail.com` or
    a domain-based email address like `you@yourdomain.com`. If using a
    domain-based email address, then please make sure that you've configured and
    verified it with Zoho Mail.
  </Note>

  <Info>
    Remember that you will need to restart Infisical for this to work properly.
  </Info>
</Accordion>

<Accordion title="SMTP2Go">
  1. Create an account and configure [SMTP2Go](https://www.smtp2go.com/) to send emails.
  2. Turn on SMTP authentication

  ```
  SMTP_HOST=mail.smtp2go.com
  SMTP_PORT=You can use one of the following ports: 2525, 80, 25, 8025, or 587
  SMTP_USERNAME=username #Your SMTP2GO account's SMTP username
  SMTP_PASSWORD=password #Your SMTP2GO account's SMTP password
  SMTP_FROM_ADDRESS=hey@example.com # your email address being used to send out emails
  SMTP_FROM_NAME=Infisical
  ```

  {" "}

  <Note>
    Optional (for TLS/SSL):

    TLS: Available on the same ports (2525, 80, 25, 8025, or 587)
    SSL: Available on ports 465, 8465, and 443
  </Note>
</Accordion>

## Authentication

By default, users can only login via email/password based login method.
To login into Infisical with OAuth providers such as Google, configure the associated variables.

<ParamField query="DEFAULT_SAML_ORG_SLUG" type="string">
  When set, all visits to the Infisical login page will automatically redirect users of your Infisical instance to the SAML identity provider associated with the specified organization slug.
</ParamField>

<Accordion title="Google">
  Follow detailed guide to configure [Google SSO](/documentation/platform/sso/google)

  <ParamField query="CLIENT_ID_GOOGLE_LOGIN" type="string" default="none" optional>
    OAuth2 client ID for Google login
  </ParamField>

  <ParamField query="CLIENT_SECRET_GOOGLE_LOGIN" type="string" default="none" optional>
    OAuth2 client secret for Google login
  </ParamField>
</Accordion>

<Accordion title="Github">
  Follow detailed guide to configure [GitHub SSO](/documentation/platform/sso/github)

  <ParamField query="CLIENT_ID_GITHUB_LOGIN" type="string" default="none" optional>
    OAuth2 client ID for GitHub login
  </ParamField>

  <ParamField query="CLIENT_SECRET_GITHUB_LOGIN" type="string" default="none" optional>
    OAuth2 client secret for GitHub login
  </ParamField>
</Accordion>

<Accordion title="Gitlab">
  Follow detailed guide to configure [GitLab SSO](/documentation/platform/sso/gitlab)

  <ParamField query="CLIENT_ID_GITLAB_LOGIN" type="string" default="none" optional>
    OAuth2 client ID for GitLab login
  </ParamField>

  <ParamField query="CLIENT_SECRET_GITLAB_LOGIN" type="string" default="none" optional>
    OAuth2 client secret for GitLab login
  </ParamField>

  <ParamField query="URL_GITLAB_LOGIN" type="string" default="https://gitlab.com" optional>
    URL of your self-hosted instance of GitLab where the OAuth application is registered
  </ParamField>
</Accordion>

<Accordion title="Okta SAML">
  Requires enterprise license. Please contact [team@infisical.com](mailto:team@infisical.com) to get more
  information.
</Accordion>

<Accordion title="Azure SAML">
  Requires enterprise license. Please contact [team@infisical.com](mailto:team@infisical.com) to get more
  information.
</Accordion>

<Accordion title="JumpCloud SAML">
  Requires enterprise license. Please contact [team@infisical.com](mailto:team@infisical.com) to get more
  information.
</Accordion>

## App Connections

You can configure third-party app connections for re-use across Infisical Projects.

<Accordion title="AWS Assume Role Connection">
  <ParamField query="INF_APP_CONNECTION_AWS_ACCESS_KEY_ID" type="string" default="none" optional>
    The AWS IAM User access key ID for assuming roles
  </ParamField>

  <ParamField query="INF_APP_CONNECTION_AWS_SECRET_ACCESS_KEY" type="string" default="none" optional>
    The AWS IAM User secret key for assuming roles
  </ParamField>
</Accordion>

<Accordion title="GitHub App Connection">
  <ParamField query="INF_APP_CONNECTION_GITHUB_APP_ID" type="string" default="none" optional>
    The ID of the GitHub App
  </ParamField>

  <ParamField query="INF_APP_CONNECTION_GITHUB_APP_SLUG" type="string" default="none" optional>
    The slug of the GitHub App
  </ParamField>

  <ParamField query="INF_APP_CONNECTION_GITHUB_APP_CLIENT_ID" type="string" default="none" optional>
    The client ID for the GitHub App
  </ParamField>

  <ParamField query="INF_APP_CONNECTION_GITHUB_APP_CLIENT_SECRET" type="string" default="none" optional>
    The client secret for the GitHub App
  </ParamField>

  <ParamField query="INF_APP_CONNECTION_GITHUB_APP_PRIVATE_KEY" type="string" default="none" optional>
    The private key for the GitHub App
  </ParamField>
</Accordion>

<Accordion title="GitHub Radar App Connection">
  <ParamField query="INF_APP_CONNECTION_GITHUB_RADAR_APP_ID" type="string" default="none" optional>
    The ID of the GitHub Radar App
  </ParamField>

  <ParamField query="INF_APP_CONNECTION_GITHUB_RADAR_APP_SLUG" type="string" default="none" optional>
    The slug of the GitHub Radar App
  </ParamField>

  <ParamField query="INF_APP_CONNECTION_GITHUB_RADAR_APP_CLIENT_ID" type="string" default="none" optional>
    The client ID for the GitHub Radar App
  </ParamField>

  <ParamField query="INF_APP_CONNECTION_GITHUB_RADAR_APP_CLIENT_SECRET" type="string" default="none" optional>
    The client secret for the GitHub Radar App
  </ParamField>

  <ParamField query="INF_APP_CONNECTION_GITHUB_RADAR_APP_PRIVATE_KEY" type="string" default="none" optional>
    The private key for the GitHub Radar App
  </ParamField>

  <ParamField query="INF_APP_CONNECTION_GITHUB_RADAR_APP_WEBHOOK_SECRET" type="string" default="none" optional>
    The webhook secret configured for payload verification in the GitHub Radar App
  </ParamField>
</Accordion>

<Accordion title="GitHub OAuth Connection">
  <ParamField query="INF_APP_CONNECTION_GITHUB_OAUTH_CLIENT_ID" type="string" default="none" optional>
    The OAuth2 client ID for GitHub OAuth Connection
  </ParamField>

  <ParamField query="INF_APP_CONNECTION_GITHUB_OAUTH_CLIENT_SECRET" type="string" default="none" optional>
    The OAuth2 client secret for GitHub OAuth Connection
  </ParamField>
</Accordion>

<Accordion title="GitLab OAuth Connection">
  <ParamField query="INF_APP_CONNECTION_GITLAB_OAUTH_CLIENT_ID" type="string" default="none" optional>
    The Application ID of your GitLab OAuth application.
  </ParamField>

  <ParamField query="INF_APP_CONNECTION_GITLAB_OAUTH_CLIENT_SECRET" type="string" default="none" optional>
    The Secret of your GitLab OAuth application.
  </ParamField>
</Accordion>

<Accordion title="Heroku OAuth Connection">
  <ParamField query="INF_APP_CONNECTION_HEROKU_OAUTH_CLIENT_ID" type="string" default="none" optional>
    The Application ID of your Heroku OAuth application.
  </ParamField>

  <ParamField query="INF_APP_CONNECTION_HEROKU_OAUTH_CLIENT_SECRET" type="string" default="none" optional>
    The Secret of your Heroku OAuth application.
  </ParamField>
</Accordion>

## Native Secret Integrations

To help you sync secrets from Infisical to services such as Github and Gitlab, Infisical provides native integrations out of the box.

<Accordion title="Heroku">
  <ParamField query="CLIENT_ID_HEROKU" type="string" default="none" optional>
    OAuth2 client ID for Heroku integration
  </ParamField>

  <ParamField query="CLIENT_SECRET_HEROKU" type="string" default="none" optional>
    OAuth2 client secret for Heroku integration
  </ParamField>
</Accordion>

<Accordion title="Vercel">
  <ParamField query="CLIENT_ID_VERCEL" type="string" default="none" optional>
    OAuth2 client ID for Vercel integration
  </ParamField>

  {" "}

  <ParamField query="CLIENT_SECRET_VERCEL" type="string" default="none" optional>
    OAuth2 client secret for Vercel integration
  </ParamField>

  <ParamField query="CLIENT_SLUG_VERCEL" type="string" default="none" optional>
    OAuth2 slug for Vercel integration
  </ParamField>
</Accordion>

<Accordion title="Netlify">
  <ParamField query="CLIENT_ID_NETLIFY" type="string" default="none" optional>
    OAuth2 client ID for Netlify integration
  </ParamField>

  <ParamField query="CLIENT_SECRET_NETLIFY" type="string" default="none" optional>
    OAuth2 client secret for Netlify integration
  </ParamField>
</Accordion>

<Accordion title="Github">
  <ParamField query="CLIENT_ID_GITHUB" type="string" default="none" optional>
    OAuth2 client ID for GitHub integration
  </ParamField>

  <ParamField query="CLIENT_SECRET_GITHUB" type="string" default="none" optional>
    OAuth2 client secret for GitHub integration
  </ParamField>
</Accordion>

<Accordion title="Bitbucket">
  <ParamField query="CLIENT_ID_BITBUCKET" type="string" default="none" optional>
    OAuth2 client ID for Bitbucket integration
  </ParamField>

  <ParamField query="CLIENT_SECRET_BITBUCKET" type="string" default="none" optional>
    OAuth2 client secret for Bitbucket integration
  </ParamField>
</Accordion>

<Accordion title="GCP Secrets Manager">
  <ParamField query="CLIENT_ID_GCP_SECRET_MANAGER" type="string" default="none" optional>
    OAuth2 client id for GCP secrets manager integration
  </ParamField>

  <ParamField query="CLIENT_SECRET_GCP_SECRET_MANAGER" type="string" default="none" optional>
    OAuth2 client secret for GCP secrets manager integration
  </ParamField>
</Accordion>

<Accordion title="AWS Integration">
  <ParamField query="CLIENT_ID_AWS_INTEGRATION" type="string" default="none" optional>
    The AWS IAM User access key for assuming roles.
  </ParamField>

  <ParamField query="CLIENT_SECRET_AWS_INTEGRATION" type="string" default="none" optional>
    The AWS IAM User secret key for assuming roles.
  </ParamField>
</Accordion>

<Accordion title="Azure">
  <ParamField query="CLIENT_ID_AZURE" type="string" default="none" optional>
    OAuth2 client id for Azure integration
  </ParamField>

  <ParamField query="CLIENT_SECRET_AZURE" type="string" default="none" optional>
    OAuth2 client secret for Azure integration
  </ParamField>
</Accordion>

<Accordion title="Gitlab">
  <ParamField query="CLIENT_ID_GITLAB" type="string" default="none" optional>
    OAuth2 client id for Gitlab integration
  </ParamField>

  <ParamField query="CLIENT_SECRET_GITLAB" type="string" default="none" optional>
    OAuth2 client secret for Gitlab integration
  </ParamField>
</Accordion>

## Secret Scanning

<Accordion title="GitHub">
  <ParamField query="SECRET_SCANNING_GIT_APP_ID" type="string" default="none" optional>
    The App ID of your GitHub App.
  </ParamField>

  {" "}

  <ParamField query="SECRET_SCANNING_GIT_APP_SLUG" type="string" default="none" optional>
    The slug of your GitHub App.
  </ParamField>

  {" "}

  <ParamField query="SECRET_SCANNING_PRIVATE_KEY" type="string" default="none" optional>
    A private key for your GitHub App.
  </ParamField>

  <ParamField query="SECRET_SCANNING_WEBHOOK_SECRET" type="string" default="none" optional>
    The webhook secret of your GitHub App.
  </ParamField>
</Accordion>

## Observability

You can configure Infisical to collect and expose telemetry data for analytics and monitoring.

<ParamField query="OTEL_TELEMETRY_COLLECTION_ENABLED" type="string" default="false">
  Whether or not to collect and expose telemetry data.
</ParamField>

<ParamField query="OTEL_EXPORT_TYPE" type="enum" optional>
  Supported types are `prometheus` and `otlp`.

  If export type is set to `prometheus`, metric data will be exposed in port 9464 in the `/metrics` path.

  If export type is set to `otlp`, you will have to configure a value for `OTEL_EXPORT_OTLP_ENDPOINT`.
</ParamField>

<ParamField query="OTEL_EXPORT_OTLP_ENDPOINT" type="string">
  Where telemetry data would be pushed to for collection. This is only
  applicable when `OTEL_EXPORT_TYPE` is set to `otlp`.
</ParamField>

<ParamField query="OTEL_COLLECTOR_BASIC_AUTH_USERNAME" type="string">
  The username for authenticating with the telemetry collector.
</ParamField>

<ParamField query="OTEL_COLLECTOR_BASIC_AUTH_PASSWORD" type="string">
  The password for authenticating with the telemetry collector.
</ParamField>

## Identity Auth Method

<ParamField query="IDENTITY_TLS_CERT_AUTH_CLIENT_CERTIFICATE_HEADER_KEY" type="string" default="x-identity-tls-cert-auth-client-cert">
  The TLS header used to propagate the client certificate from the load balancer
  to the server.
</ParamField>

## Environment Variable Overrides

If you can't directly access and modify environment variables, you can update them using the [Server Admin Console](/documentation/platform/admin-panel/server-admin).

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/self-hosting/configuration/overrides/page.png" alt="Environment Variables Overrides Page" />


# Hardware requirements
Source: https://infisical.com/docs/self-hosting/configuration/requirements

Find out the minimal requirements for operating Infisical.

This page details the minimum requirements necessary for installing and using Infisical.
The actual resource requirements will vary in direct proportion to the operations performed by Infisical and the level of utilization by the end users.

## Deployment Sizes

**Small** suitable for most initial production setups, as well as development and testing scenarios.

**Large** suitable for high-demand production environments, characterized by either a high volume of transactions, large number of secrets, or both.

## Hardware Requirements

### Storage

Infisical doesnt require file storage as all persisted data is saved in the database.
However, its logs and metrics are saved to disk for later viewing. As a result, we recommend provisioning 1-2 GB of storage.

### CPU and Memory (Per Container/Instance)

Infisical is stateless and scales horizontally by running across multiple containers/instances. Each instance typically does **not** need more than **24 CPU cores** and **48 GB** of memory.
If you need additional capacity, simply increase the **number** of containers/instances running in parallel.

| **Deployment Size** | **CPU (Cores, per container)** | **Memory (GB, per container)** | **Recommended Number of Containers** |
| ------------------- | ------------------------------ | ------------------------------ | ------------------------------------ |
| **Small**           | 2                              | 4                              | 2+                                   |
| **Medium**          | 24                            | 48                            | 5+                                   |
| **Large**           | 24                            | 48                            | 10+                                  |

> **Note:**
>
> * Adding more containers (horizontal scaling) is generally the best way to handle spikes in secret operations.
> * If you prefer, you can increase CPU/memory on a single container (vertical scaling), but horizontal scaling is more flexible and resilient.

## Database & caching layer

### Postgres

PostgreSQL is the only database supported by Infisical. Infisical has been extensively tested with Postgres version 16. We recommend using versions 14 and up for optimal compatibility.
The compute required for Postgres is largely dependent on the number of secret operations (reads and writes) you expect. The more frequently you read and write secrets, the more compute you will need.
You'll notice that storage requirements are high and this is because audit logs are by default stored in the database.

Recommended resource allocation based on deployment size. You may require more resources if you have a large number of secrets or high transaction volume:

* **small:**2 vCPU / 8 GB RAM / 100 GB Disk
* **medium:** 4vCPU / 16 GB RAM / 200 GB Disk
* **large:** 8vCPU / 32 GB RAM / 500 GB Disk

### Redis

Redis is utilized for session management and background tasks in Infisical.

Redis requirements:

* Use Redis versions 6.x or 7.x. We advise upgrading to at least Redis 6.2.
* Redis Cluster mode is currently not supported; use Redis Standalone, with or without High Availability (HA).
* Redis storage needs are minimal: a setup with 2 vCPU, 4 GB RAM, and 30GB SSD will be sufficient for small deployments.
* Set cache eviction policy to `noeviction`.

## Supported Web Browsers

Infisical supports a range of web browsers. However, features such as browser-based CLI login only work on Google Chrome and Firefox at the moment.

* [Mozilla Firefox](https://www.mozilla.org/en-US/firefox/new/)
* [Google Chrome](https://www.google.com/chrome/)
* [Chromium](https://www.chromium.org/getting-involved/dev-channel/)
* [Apple Safari](https://www.apple.com/safari/)
* [Microsoft Edge](https://www.microsoft.com/en-us/edge?form=MA13FJ)


# Docker Compose
Source: https://infisical.com/docs/self-hosting/deployment-options/docker-compose

Read how to run Infisical with Docker Compose template.

This self-hosting guide will walk you through the steps to self-host Infisical using Docker Compose.

<Tabs>
  <Tab title="Docker Compose">
    ## Prerequisites

    * [Docker](https://docs.docker.com/engine/install/)
    * [Docker compose](https://docs.docker.com/compose/install/)

    <Warning>
      This Docker Compose configuration is not designed for high-availability production scenarios.
      It includes just the essential components needed to set up an Infisical proof of concept (POC).
      To run Infisical in a highly available manner, give the [Docker Swarm guide](/self-hosting/deployment-options/docker-swarm).
    </Warning>

    ## Verify prerequisites

    To verify that Docker compose and Docker are installed on the machine where you plan to install Infisical, run the following commands.

    Check for docker installation

    ```bash  theme={"dark"}
    docker
    ```

    Check for docker compose installation

    ```bash  theme={"dark"}
    docker-compose 
    ```

    ## Download docker compose file

    You can obtain the Infisical docker compose file by using a command-line downloader such as `wget` or `curl`.
    If your system doesn't have either of these, you can use a equivalent command that works with your machine.

    <Tabs>
      <Tab title="curl">
        ```bash  theme={"dark"}
        curl -o docker-compose.prod.yml https://raw.githubusercontent.com/Infisical/infisical/main/docker-compose.prod.yml
        ```
      </Tab>

      <Tab title="wget">
        ```bash  theme={"dark"}
        wget -O docker-compose.prod.yml https://raw.githubusercontent.com/Infisical/infisical/main/docker-compose.prod.yml
        ```
      </Tab>
    </Tabs>

    ## Configure instance credentials

    Infisical requires a set of credentials used for connecting to dependent services such as Postgres, Redis, etc.
    The default credentials can be downloaded using the one of the commands listed below.

    <Tabs>
      <Tab title="curl">
        ```bash  theme={"dark"}
          curl -o .env https://raw.githubusercontent.com/Infisical/infisical/main/.env.example
        ```
      </Tab>

      <Tab title="wget">
        ```bash  theme={"dark"}
          wget -O .env https://raw.githubusercontent.com/Infisical/infisical/main/.env.example
        ```
      </Tab>
    </Tabs>

    Once downloaded, the credentials file will be saved to your working directly as `.env` file.
    View all available configurations [here](/self-hosting/configuration/envars).

    <Warning>
      The default .env file contains credentials that are intended solely for testing purposes.
      Please generate a new `ENCRYPTION_KEY` and `AUTH_SECRET` for use outside of testing.
      Instructions to do so, can be found [here](/self-hosting/configuration/envars).
    </Warning>

    ## Start Infisical

    Run the command below to start Infisical and all related services.

    ```bash  theme={"dark"}
    docker-compose -f docker-compose.prod.yml up
    ```
  </Tab>

  <Tab title="Podman Compose">
    Podman Compose is an alternative way to run Infisical using Podman as a replacement for Docker. Podman is backwards compatible with Docker Compose files.

    ## Prerequisites

    * [Podman](https://podman-desktop.io/docs/installation)
    * [Podman Compose](https://podman-desktop.io/docs/compose)

    <Warning>
      This Docker Compose configuration is not designed for high-availability production scenarios.
      It includes just the essential components needed to set up an Infisical proof of concept (POC).
      To run Infisical in a highly available manner, give the [Docker Swarm guide](/self-hosting/deployment-options/docker-swarm).
    </Warning>

    ## Verify prerequisites

    To verify that Podman compose and Podman are installed on the machine where you plan to install Infisical, run the following commands.

    Check for podman installation

    ```bash  theme={"dark"}
    podman version 
    ```

    Check for podman compose installation

    ```bash  theme={"dark"}
    podman-compose version
    ```

    ## Download Docker Compose file

    You can obtain the Infisical docker compose file by using a command-line downloader such as `wget` or `curl`.
    If your system doesn't have either of these, you can use a equivalent command that works with your machine.

    <Tabs>
      <Tab title="curl">
        ```bash  theme={"dark"}
        curl -o docker-compose.prod.yml https://raw.githubusercontent.com/Infisical/infisical/main/docker-compose.prod.yml
        ```
      </Tab>

      <Tab title="wget">
        ```bash  theme={"dark"}
        wget -O docker-compose.prod.yml https://raw.githubusercontent.com/Infisical/infisical/main/docker-compose.prod.yml
        ```
      </Tab>
    </Tabs>

    ## Configure instance credentials

    Infisical requires a set of credentials used for connecting to dependent services such as Postgres, Redis, etc.
    The default credentials can be downloaded using the one of the commands listed below.

    <Tabs>
      <Tab title="curl">
        ```bash  theme={"dark"}
          curl -o .env https://raw.githubusercontent.com/Infisical/infisical/main/.env.example
        ```
      </Tab>

      <Tab title="wget">
        ```bash  theme={"dark"}
          wget -O .env https://raw.githubusercontent.com/Infisical/infisical/main/.env.example
        ```
      </Tab>
    </Tabs>

    <Note>
      Make sure to rename the `.env.example` file to `.env` before starting Infisical. Additionally it's important that the `.env` file is in the same directory as the `docker-compose.prod.yml` file.
    </Note>

    ## Setup Podman

    Run the commands below to setup Podman for first time use.

    ```bash  theme={"dark"}
    podman machine init --now
    podman machine set --rootful
    podman machine start
    ```

    <Note>
      If you are using a rootless podman installation, you can skip the `podman machine set --rootful` command.
    </Note>

    ## Start Infisical

    Run the command below to start Infisical and all related services.

    ```bash  theme={"dark"}
    podman-compose -f docker-compose.prod.yml up
    ```
  </Tab>
</Tabs>

Your Infisical instance should now be running on port `80`. To access your instance, visit `http://localhost:80`.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/self-hosting/applicable-to-all/selfhost-signup.png" alt="self-hosted sign up" />


# Docker Swarm
Source: https://infisical.com/docs/self-hosting/deployment-options/docker-swarm

How to self-host Infisical with Docker Swarm (HA).

# Self-Hosting Infisical with Docker Swarm

This guide will provide step-by-step instructions on how to self-host Infisical using Docker Swarm. This is particularly helpful for those wanting to self-host Infisical on premise while still maintaining high availability (HA) for the core Infisical components.
The guide will demonstrate a setup with three nodes, ensuring that the cluster can tolerate the failure of one node while remaining fully operational.

## Docker Swarm

[Docker Swarm](https://docs.docker.com/engine/swarm/) is a native clustering and orchestration solution for Docker containers.
It simplifies the deployment and management of containerized applications across multiple nodes, making it a great choice for self-hosting Infisical.

Unlike Kubernetes, which requires a deep understanding of the Kubernetes ecosystem, if you're accustomed to Docker and Docker Compose, you're already familiar with most of Docker Swarm.
For this reason, we suggest teams use Docker Swarm to deploy Infisical in a highly available and fault tolerant manner.

## Prerequisites

* Understanding of Docker Swarm
* Bare/Virtual Machines with Docker installed on each VM.
* Docker Swarm initialized on the VMs.

## Core Components for High Availability

The provided Docker stack includes the following core components to achieve high availability:

1. **Spilo**: [Spilo](https://github.com/zalando/spilo) is used to run PostgreSQL with [Patroni](https://github.com/zalando/patroni) for HA and automatic failover. It utilizes etcd for leader election of the PostgreSQL instances.

2. **Redis**: Redis is used for caching and is set up with Redis Sentinel for HA.
   The stack includes three Redis replicas and three Redis Sentinel instances for monitoring and failover.

3. **Infisical**: Infisical is stateless, allowing for easy scaling and replication across multiple nodes.

4. **HAProxy**: HAProxy is used as a load balancer to distribute traffic to the PostgreSQL and Redis instances.
   It is configured to perform health checks and route requests to the appropriate backend services.

## Node Failure Tolerance

To ensure Infisical is highly available and fault tolerant, it's important to choose the number of nodes in the cluster.
The following table shows the relationship between the number of nodes and the maximum number of nodes that can be down while the cluster continues to function:

| Total Nodes | Max Nodes Down | Min Nodes Required |
| ----------- | -------------- | ------------------ |
| 1           | 0              | 1                  |
| 2           | 0              | 2                  |
| 3           | 1              | 2                  |
| 4           | 1              | 3                  |
| 5           | 2              | 3                  |
| 6           | 2              | 4                  |
| 7           | 3              | 4                  |

The formula for calculating the minimum number of nodes required is: `floor(n/2) + 1`, where `n` is the total number of nodes.

This guide will demonstrate a setup with three nodes, which allows for one node to be down while the cluster remains operational. This fault tolerance applies to the following components:

* Redis Sentinel: With three Sentinel instances, one instance can be down, and the remaining two can still form a quorum to make decisions.
* Redis: With three Redis instances (one master and two replicas), one instance can be down, and the remaining two can continue to provide caching services.
* PostgreSQL: With three PostgreSQL instances managed by Patroni and etcd, one instance can be down, and the remaining two can maintain data consistency and availability.
* Manager Nodes: In a Docker Swarm cluster with three manager nodes, one manager node can be down, and the remaining two can continue to manage the cluster.
  For the sake of simplicity, the example in this guide only contains one manager node.

It's important to note that while the cluster can tolerate the failure of one node in a three-node setup, it's recommended to have a minimum of three nodes to ensure high availability.
With two nodes, the failure of a single node can result in a loss of quorum and potential downtime.

## Docker Deployment Stack Overview

The [Docker stack file](https://github.com/Infisical/infisical/tree/main/docker-swarm) used in this guide defines the services and their configurations for deploying Infisical in a highly available manner. The main components of this stack are as follows.

1. **HAProxy**: The HAProxy service is configured to expose ports for accessing PostgreSQL (5433 for the master, 5434 for replicas), Redis master (6379), and the Infisical backend (8080). It uses a config file (`haproxy.cfg`) to define the load balancing and health check rules.

2. **Infisical**: The Infisical backend service is deployed with the latest PostgreSQL-compatible image. It is connected to the `infisical` network and uses secrets for environment variables.

3. **etcd**: Three etcd instances (etcd1, etcd2, etcd3) are deployed, one on each node, to provide distributed key-value storage for leader election and configuration management.

4. **Spilo**: Three Spilo instances (spolo1, spolo2, spolo3) are deployed, one on each node, to run PostgreSQL with Patroni for high availability. They are connected to the `infisical` network and use persistent volumes for data storage.

5. **Redis**: Three Redis instances (redis\_replica0, redis\_replica1, redis\_replica2) are deployed, one on each node, with redis\_replica0 acting as the master. They are connected to the `infisical` network.

6. **Redis Sentinel**: Three Redis Sentinel instances (redis\_sentinel1, redis\_sentinel2, redis\_sentinel3) are deployed, one on each node, to monitor and manage the Redis instances. They are connected to the `infisical` network.

## Deployment instructions

<Steps>
  <Step title="Install Docker on nodes">
    Run the following on each node to install the Docker engine.

    ```
    curl -fsSL https://get.docker.com -o get-docker.sh && sh get-docker.sh 
    ```
  </Step>

  <Step title="Initialize Docker Swarm on one of the VMs by running the following command">
    ```
    docker swarm init 
    ```

    Replace `<MANAGER_NODE_IP>` with the IP address of the VM that will serve as the manager node. Remember to copy the join token returned by the this init command.

    <Tip>
      For the sake of simplicity, we only use one manager node in this example deployment. However, in production settings, we recommended you have at least 3 manager nodes.
    </Tip>
  </Step>

  <Step title="On the other VMs, join the Docker Swarm by running the command provided by the manager node">
    ```
    docker swarm join --token <JOIN_TOKEN> <MANAGER_NODE_IP>:2377
    ```

    Replace `<JOIN_TOKEN>` with the token provided by the manager node during initialization.
  </Step>

  <Step title="Label the nodes with `node.labels.name` to specify their roles.">
    Labels on nodes will help us select where stateful components such as Postgres and Redis are deployed on. To label nodes, follow the steps below.

    ```
    docker node update --label-add name=node1 <NODE1_ID>
    docker node update --label-add name=node2 <NODE2_ID>
    docker node update --label-add name=node3 <NODE3_ID>
    ```

    Replace `<NODE1_ID>`, `<NODE2_ID>`, and `<NODE3_ID>` with the respective node IDs.
    To view the list of nodes and their ids, run the following on the manager node `docker node ls`.
  </Step>

  <Step title="Copy deployment assets to manager node">
    Copy the Docker stack YAML file, HAProxy configuration file and example `.env` file to the manager node. Ensure that all 3 files are placed in the same file directory.

    * [Docker stack file](https://github.com/Infisical/infisical/blob/main/docker-swarm/stack.yaml) (rename to infisical-stack.yaml)
    * [HA configuration file](https://github.com/Infisical/infisical/blob/main/docker-swarm/haproxy.cfg) (rename to haproxy.cfg)
    * [Example .env file](https://github.com/Infisical/infisical/blob/main/docker-swarm/.env-example) (rename to .env)
  </Step>

  <Step title="Deploy stack">
    ```
    docker stack deploy -c infisical-stack.yaml infisical
    ```
  </Step>

  <Step title="Check service status">
    ```plain  theme={"dark"}
    $ docker service ls 
    ID             NAME                        MODE         REPLICAS   IMAGE                                  PORTS
    4kzq3ub8qgn9   infisical_etcd1             replicated   1/1        ghcr.io/zalando/spilo-16:3.2-p2        
    tqx9t82bn8d9   infisical_etcd2             replicated   1/1        ghcr.io/zalando/spilo-16:3.2-p2        
    t8vbkrasy8fz   infisical_etcd3             replicated   1/1        ghcr.io/zalando/spilo-16:3.2-p2        
    77iei42fcf6q   infisical_haproxy           global       4/4        haproxy:latest                         *:5002-5003->5433-5434/tcp, *:6379->6379/tcp, *:7001->7000/tcp, *:8080->8080/tcp
    jaewzqy8md56   infisical_infisical         replicated   5/5        infisical/infisical:v0.60.1-postgres   
    58w4zablfbtb   infisical_redis_replica0    replicated   1/1        bitnami/redis:6.2.10                   
    w4yag2whq0un   infisical_redis_replica1    replicated   1/1        bitnami/redis:6.2.10                   
    w03mriy0jave   infisical_redis_replica2    replicated   1/1        bitnami/redis:6.2.10                   
    ppo6rk47hc9t   infisical_redis_sentinel1   replicated   1/1        bitnami/redis-sentinel:6.2.10          
    ub29vd0lnq7f   infisical_redis_sentinel2   replicated   1/1        bitnami/redis-sentinel:6.2.10          
    szg3yky7yji2   infisical_redis_sentinel3   replicated   1/1        bitnami/redis-sentinel:6.2.10          
    eqtocpf5tiy0   infisical_spolo1            replicated   1/1        ghcr.io/zalando/spilo-16:3.2-p2        
    3lznscvk7k5t   infisical_spolo2            replicated   1/1        ghcr.io/zalando/spilo-16:3.2-p2        
    v04ml7rz2j5q   infisical_spolo3            replicated   1/1        ghcr.io/zalando/spilo-16:3.2-p2
    ```
  </Step>

  <Step title="View service status">
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/self-hosting/deployment-options/docker-swarm/ha-proxy-ha.png" alt="HA Proxy stats" />
    To view the health of services in your Infisical cluster, visit port `<NODE-IP>:7001` of any node in your Docker swarm.
    This port will expose the HA Proxy stats.

    Run the following command to view the IPs of the nodes in your docker swarm.

    ```plain  theme={"dark"}
    $ docker node ls
    ID                            HOSTNAME    STATUS    AVAILABILITY   MANAGER STATUS   ENGINE VERSION
    0jnegl4gpo235l66nglcwc07t     localhost   Ready     Active                          26.0.2
    no1a7zwj88057k73m196ulkq6 *   localhost   Ready     Active         Leader           26.0.2
    wcb2x27w3tq7ht4v1h7ke49qk     localhost   Ready     Active                          26.0.2
    zov5q7uop7wpxc2ndz712v9oa     localhost   Ready     Active                          26.0.2
    ```

    <Info>
      The stats page may take 1-2 minutes to become accessible.
    </Info>
  </Step>

  <Step title="Initialize Infisical">
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/self-hosting/applicable-to-all/selfhost-signup.png" alt="self-hosting sign up" />
    Once all expected services are up and running, visit `<NODE-IP>:8080` of any node in the swarm. This will take you to the Infisical configuration page.
  </Step>
</Steps>

## FAQ

<Accordion title="How do I scale Infisical cluster further?" defaultOpen="true">
  To further scale and make the system more resilient, you can add more nodes to the Docker Swarm and update the stack configuration accordingly:

  1. Add new VMs and join them to the Docker Swarm as worker nodes.

  2. Update the Docker stack YAML file to include the new nodes in the `deploy` section of the relevant services, specifying the appropriate `node.labels.name` constraints.

  3. Update the HAProxy configuration file (`haproxy.cfg`) to include the new nodes in the backend sections for PostgreSQL and Redis.

  4. Redeploy the updated stack using the `docker stack deploy` command.

  Note that the database containers (PostgreSQL) are stateful and cannot be simply replicated. Instead, one database instance is deployed per node to ensure data consistency and avoid conflicts.
</Accordion>

<Accordion title="How do I configure backups for Postgres and Redis?">
  Native tooling for scheduled backups of Postgres and Redis is currently in development.
  In the meantime, we recommend using a variety of open-source tools available for this purpose.
  For Postgres, [Spilo](https://github.com/zalando/spilo) provides built-in support for scheduled data dumps.
  You can explore other third party tools for managing db backups, one such tool is [docker-db-backup](https://github.com/tiredofit/docker-db-backup).
</Accordion>


# Kubernetes via Helm Chart
Source: https://infisical.com/docs/self-hosting/deployment-options/kubernetes-helm

Learn how to use Helm chart to install Infisical on your Kubernetes cluster.

**Prerequisites**

* You have extensive understanding of [Kubernetes](https://kubernetes.io/)
* Installed [Helm package manager](https://helm.sh/) version v3.11.3 or greater
* You have [kubectl](https://kubernetes.io/docs/reference/kubectl/kubectl/) installed and connected to your kubernetes cluster

<Steps>
  <Step title="Install Infisical Helm repository ">
    ```bash  theme={"dark"}
    helm repo add infisical-helm-charts 'https://dl.cloudsmith.io/public/infisical/helm-charts/helm/charts/' 
    ```

    ```bash  theme={"dark"}
    helm repo update
    ```
  </Step>

  <Step title="Add Helm values">
    Create a `values.yaml` file. This will be used to configure settings for the Infisical Helm chart.
    To explore all configurable properties for your values file, [visit this page](https://raw.githubusercontent.com/Infisical/infisical/main/helm-charts/infisical-standalone-postgres/values.yaml).
  </Step>

  <Step title="Select Infisical version">
    By default, the Infisical version set in your helm chart will likely be outdated.
    Choose the latest Infisical docker image tag from [here](https://hub.docker.com/r/infisical/infisical/tags).

    ```yaml values.yaml theme={"dark"}
    infisical:
      image:
        repository: infisical/infisical
        tag: "<>" #<-- select tag from Dockerhub from the above link
        pullPolicy: IfNotPresent
    ```

    <Warning>
      Do not use the latest docker image tag in production deployments as they can introduce unexpected changes
    </Warning>
  </Step>

  <Step title="Configure environment variables">
    To deploy this Helm chart, a Kubernetes secret named `infisical-secrets` must be present in the same namespace where the chart is being deployed.

    For a minimal installation of Infisical, you need to configure `ENCRYPTION_KEY`, `AUTH_SECRET`, `DB_CONNECTION_URI`, `SITE_URL`, and `REDIS_URL`. [Learn more about configuration settings](/self-hosting/configuration/envars).

    <Tabs>
      <Tab title="Proof of concept deployment">
        For test or proof-of-concept purposes, you may omit `DB_CONNECTION_URI` and `REDIS_URL` from `infisical-secrets`. This is because the Helm chart will automatically provision and connect to the in-cluster instances of Postgres and Redis by default.

        ```yaml simple-values-example.yaml  theme={"dark"}
        apiVersion: v1
        kind: Secret
        metadata:
          name: infisical-secrets
        type: Opaque
        stringData:
          AUTH_SECRET: <>
          ENCRYPTION_KEY: <>
          SITE_URL: <>
        ```
      </Tab>

      <Tab title="Production deployment">
        For production environments, we recommend using Cloud-based Platform as a Service (PaaS) solutions for PostgreSQL and Redis to ensure high availability. In on-premise setups, it's recommended to configure Redis and Postgres for high availability, either by using Bitnami charts or a custom configuration.

        ```yaml simple-values-example.yaml  theme={"dark"}
        apiVersion: v1
        kind: Secret
        metadata:
          name: infisical-secrets
        type: Opaque
        stringData:
          AUTH_SECRET: <>
          ENCRYPTION_KEY: <>
          REDIS_URL: <>
          DB_CONNECTION_URI: <>
          SITE_URL: <>
        ```

        <Tip>
          If you need to configure the SSL certificate for your production Postgres instance, you can use the `DB_ROOT_CERT` environment variable. [Learn more about configuring the SSL certificate](/self-hosting/configuration/envars#aws-rds).
        </Tip>
      </Tab>
    </Tabs>
  </Step>

  <Step title="Routing traffic to Infisical">
    By default, this chart uses Nginx as its Ingress controller to direct traffic to Infisical services.

    ```yaml values.yaml  theme={"dark"}
    ingress:
      nginx:
        enabled: true 
    ```
  </Step>

  <Step title="Install the Helm chart ">
    Once you are done configuring your `values.yaml` file, run the command below.

    ```bash  theme={"dark"}
    helm upgrade --install infisical infisical-helm-charts/infisical-standalone --values /path/to/values.yaml
    ```

    <Accordion title="Full helm values example">
      ```yaml values.yaml theme={"dark"}

      nameOverride: "infisical"
      fullnameOverride: "infisical"

      infisical:
        enabled: true
        name: infisical
        autoDatabaseSchemaMigration: true
        fullnameOverride: ""
        podAnnotations: {}
        deploymentAnnotations: {}
        replicaCount: 6

        image:
          repository: infisical/infisical
          tag: "v0.46.2-postgres"
          pullPolicy: IfNotPresent

        affinity: {}
        kubeSecretRef: "infisical-secrets"
        service:
          annotations: {}
          type: ClusterIP
          nodePort: ""

        resources:
          limits:
            memory: 210Mi
          requests:
            cpu: 200m

      ingress:
        enabled: true
        hostName: ""
        ingressClassName: nginx
        nginx:
          enabled: true
        annotations: {}
        tls: []

      postgresql:
        enabled: true
        name: "postgresql"
        fullnameOverride: "postgresql"
        auth:
          username: infisical
          password: root
          database: infisicalDB

      redis:
        enabled: true
        name: "redis"
        fullnameOverride: "redis"
        cluster:
          enabled: false
        usePassword: true
        auth:
          password: "mysecretpassword"
        architecture: standalone
      ```
    </Accordion>
  </Step>

  <Step title="Access Infisical">
    After deployment, please wait for 2-5 minutes for all pods to reach a running state. Once a significant number of pods are operational, access the IP address revealed through Ingress by your load balancer.
    You can find the IP address/hostname by executing the command `kubectl get ingress`.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/self-hosting/applicable-to-all/selfhost-signup.png" alt="infisical-selfhost" />
  </Step>

  <Step title="Upgrade your instance">
    To upgrade your instance of Infisical simply update the docker image tag in your Helm values and rerun the command below.

    ```bash  theme={"dark"}
    helm upgrade --install infisical infisical-helm-charts/infisical-standalone --values /path/to/values.yaml
    ```

    <Tip>
      Always back up your database before each upgrade, especially in a production environment.
    </Tip>
  </Step>
</Steps>


# Upgrading
Source: https://infisical.com/docs/self-hosting/deployment-options/linux-upgrade

How to upgrade Infisical deployment using linux package

This guide explains how to upgrade Infisical Linux package installations to newer versions.
The Infisical Linux package includes only the Infisical service component itself, as PostgreSQL and Redis databases are managed separately.
Upgrades for PostgreSQL and Redis are not covered in this guide as they depend on your specific database deployment method.

## Upgrade Options

There are two primary methods to upgrade Infisical:

1. **Standard Upgrade (with brief downtime)**: The simplest approach that briefly takes Infisical offline during the upgrade.
2. **Minimal-Downtime Upgrade**: For multi-node deployments where high availability is required.

## Before You Begin

### Checking Your Current Version

Before upgrading, note your current Infisical version:

```bash  theme={"dark"}
cat /opt/infisical-core/version-manifest.txt
```

Look for `infisical` component. This will be the version of Infisical currently installed.

### Prerequisites

* Verify that your PostgreSQL and Redis instances are up and running
* Back up your PostgreSQL database before proceeding with any upgrade
* Review release notes for the version you're upgrading to

### Creating a Database Backup

We strongly recommend backing up your database before upgrading.
Your backup approach may look different depending on how you configured PostgreSQL and whether it's self-managed or using a managed service.
Here is a sample of how you would perform a manual backup:

```bash  theme={"dark"}
# Example PostgreSQL backup command (adjust parameters as needed)
pg_dump -U <username> -h <db-host> -d <db-name> > infisical_backup.sql
```

### Database Migrations During Upgrade

By default, Infisical runs database migrations automatically on startup.

* It uses database locks to ensure only one instance runs migrations at a time
* Other instances will wait for the lock to be released before continuing startup
* This prevents race conditions and database conflicts

## Standard Upgrade (with Downtime)

This method is suitable for single-node deployments or situations where a brief downtime is acceptable.

<Steps>
  <Step title="Stop the Infisical service">
    ```bash  theme={"dark"}
    infisical-ctl stop
    ```
  </Step>

  <Step title="Upgrade the Infisical package">
    To upgrade to the latest version:

    <Tabs>
      <Tab title="Debian/Ubuntu">
        ```bash  theme={"dark"}
        sudo apt-get update && sudo apt-get install -y infisical-core
        ```
      </Tab>

      <Tab title="RHEL/CentOS/Amazon Linux">
        ```bash  theme={"dark"}
        sudo yum update infisical-core
        ```
      </Tab>
    </Tabs>

    To upgrade to a specific version:

    <Tabs>
      <Tab title="Debian/Ubuntu">
        ```bash  theme={"dark"}
        sudo apt-get install -y infisical-core=<version>
        ```
      </Tab>

      <Tab title="RHEL/CentOS/Amazon Linux">
        ```bash  theme={"dark"}
        sudo yum install infisical-core-<version>
        ```
      </Tab>
    </Tabs>
  </Step>

  <Step title="Apply configuration changes">
    ```bash  theme={"dark"}
    infisical-ctl reconfigure
    ```
  </Step>

  <Step title="Start Infisical">
    ```bash  theme={"dark"}
    infisical-ctl start
    ```
  </Step>

  <Step title="Verify the upgrade">
    ```bash  theme={"dark"}
    infisical-ctl status
    ```

    Check the logs for any issues:

    ```bash  theme={"dark"}
    infisical-ctl tail
    ```
  </Step>
</Steps>

## Minimal-Downtime Upgrade

For multi-node setups where you need to maintain availability during upgrades, follow this procedure. This approach requires at least two Infisical nodes behind a load balancer.

### Understanding Traffic Draining

"Draining" a server means gracefully removing it from the pool of active servers without disrupting existing connections. When you drain a server:

1. The load balancer stops sending new requests to the server
2. Existing connections are allowed to complete naturally
3. Once all connections finish, the server can be safely taken offline for maintenance

This approach ensures users/machines do not experience sudden connection errors during the upgrade process.

### Preparing for the Upgrade

1. **Designate a deploy node**: Choose any single node that will run migrations. This node will be upgraded first.

2. **Configure your load balancer**: Ensure your load balancer can perform health checks against Infisical's `api/status` endpoint.

### Upgrade Process

#### On the deploy node:

<Steps>
  <Step title="Drain traffic from the node">
    Drain the traffic on this node gracefully. You can do this in a number of ways depending on the load balancer you have configured.
    Approaches for some common load balancers are provided below:

    <Tabs>
      <Tab title="NGINX">
        If using NGINX as a load balancer, you can remove the server from the upstream pool temporarily:

        ```bash  theme={"dark"}
        # Edit your NGINX configuration to comment out or remove the server
        sudo nano /path/to/your/nginx-config.conf

        # Reload NGINX to apply changes
        sudo nginx -s reload
        ```
      </Tab>

      <Tab title="HAProxy">
        If using HAProxy, you can put the server in maintenance mode:

        ```bash  theme={"dark"}
        # Using the HAProxy socket command
        echo "disable server infisical_backend/infisical-node1" | socat stdio /var/lib/haproxy/stats
        ```
      </Tab>

      <Tab title="AWS ALB/ELB">
        Deregister the instance from the load balancer using the AWS console or CLI
      </Tab>

      <Tab title="Other load balancers">
        Follow your load balancer's documentation for instructions on draining procedure
      </Tab>
    </Tabs>
  </Step>

  <Step title="Verify no new traffic is arriving">
    Verify no new traffic is arriving before proceeding with the upgrade.
  </Step>

  <Step title="Stop Infisical on this node">
    ```bash  theme={"dark"}
    infisical-ctl stop
    ```
  </Step>

  <Step title="Upgrade the Infisical package">
    To upgrade to the latest version:

    <Tabs>
      <Tab title="Debian/Ubuntu">
        ```bash  theme={"dark"}
        sudo apt-get update && sudo apt-get install -y infisical-core
        ```
      </Tab>

      <Tab title="RHEL/CentOS/Amazon Linux">
        ```bash  theme={"dark"}
        sudo yum update infisical-core
        ```
      </Tab>
    </Tabs>

    To upgrade to a specific version:

    <Tabs>
      <Tab title="Debian/Ubuntu">
        ```bash  theme={"dark"}
        sudo apt-get install -y infisical-core=<version>
        ```
      </Tab>

      <Tab title="RHEL/CentOS/Amazon Linux">
        ```bash  theme={"dark"}
        sudo yum install infisical-core-<version>
        ```
      </Tab>
    </Tabs>
  </Step>

  <Step title="Apply configuration and start the service">
    ```bash  theme={"dark"}
    infisical-ctl reconfigure
    ```
  </Step>

  <Step title="Verify the upgrade and migration success">
    ```bash  theme={"dark"}
    infisical-ctl tail
    ```

    Look for successful migration messages in the logs.
  </Step>

  <Step title="Return this node to load balancer pool">
    Re-enable the server in your load balancer using the same method you used to remove it.
  </Step>
</Steps>

#### On all remaining nodes (one at a time):

<Steps>
  <Step title="Drain traffic from the node">
    Follow the same draining procedure as described for the deploy node:

    * Remove the server from your load balancer's active pool
    * Wait for existing connections to complete
    * Verify the node is no longer receiving traffic
  </Step>

  <Step title="Stop Infisical on this node">
    ```bash  theme={"dark"}
    infisical-ctl stop
    ```
  </Step>

  <Step title="Upgrade the Infisical package">
    To upgrade to the latest version:

    <Tabs>
      <Tab title="Debian/Ubuntu">
        ```bash  theme={"dark"}
        sudo apt-get update && sudo apt-get install -y infisical-core
        ```
      </Tab>

      <Tab title="RHEL/CentOS/Amazon Linux">
        ```bash  theme={"dark"}
        sudo yum update infisical-core
        ```
      </Tab>
    </Tabs>

    To upgrade to a specific version:

    <Tabs>
      <Tab title="Debian/Ubuntu">
        ```bash  theme={"dark"}
        sudo apt-get install -y infisical-core=<version>
        ```
      </Tab>

      <Tab title="RHEL/CentOS/Amazon Linux">
        ```bash  theme={"dark"}
        sudo yum install infisical-core-<version>
        ```
      </Tab>
    </Tabs>
  </Step>

  <Step title="Apply configuration and start the service">
    ```bash  theme={"dark"}
    infisical-ctl reconfigure
    ```
  </Step>

  <Step title="Verify the upgrade success">
    ```bash  theme={"dark"}
    infisical-ctl status
    infisical-ctl tail
    ```
  </Step>

  <Step title="Wait for service to be fully operational">
    * Check logs to ensure the service has started successfully
    * Verify it can connect to the database and Redis
  </Step>

  <Step title="Return the node to service">
    Re-enable the server in your load balancer using the same method you used to remove it.
  </Step>

  <Step title="Verify traffic is flowing correctly">
    Check logs and monitoring to ensure traffic is flowing correctly.
  </Step>

  <Step title="Repeat for each remaining node">
    Repeat steps 1-7 for each remaining node, one at a time.
  </Step>

  <Step title="Verify application functionality">
    After all nodes are upgraded, verify that the application is functioning correctly:

    * Test core functionality
    * Check logs for any errors
  </Step>
</Steps>

## Rolling Back

If you need to roll back to a previous version of Infisical, follow steps below.

<Steps>
  <Step title="Stop the Infisical service">
    ```bash  theme={"dark"}
    infisical-ctl stop
    ```
  </Step>

  <Step title="Install the previous version">
    For Debian/Ubuntu:

    ```bash  theme={"dark"}
    sudo apt-get install -y infisical-core=<previous-version>
    ```

    For RHEL/CentOS/Amazon Linux:

    ```bash  theme={"dark"}
    sudo yum downgrade infisical-core-<previous-version>
    ```
  </Step>

  <Step title="Restore your database from backup">
    Restore your Postgres/Redis database from backup.
  </Step>

  <Step title="Start the service">
    ```bash  theme={"dark"}
    infisical-ctl reconfigure
    ```
  </Step>

  <Step title="Verify the rollback">
    ```bash  theme={"dark"}
    infisical-ctl status
    ```
  </Step>
</Steps>

## Troubleshooting

<AccordionGroup>
  <Accordion title="Migration Issues">
    If you encounter database migration issues:

    1. Check the logs:
       ```bash  theme={"dark"}
       infisical-ctl tail
       ```

    2. Ensure the database user has sufficient privileges to create/modify tables.

    3. If migrations fail repeatedly, consider restoring from the backup you took prior to upgrading.
  </Accordion>

  <Accordion title="Service Won't Start After Upgrade">
    1. Check for configuration errors:
       ```bash  theme={"dark"}
       infisical-ctl tail
       infisical-ctl status
       ```

    2. Verify all required environment variables are set in your `/etc/infisical/infisical.rb` file.
  </Accordion>
</AccordionGroup>


# Configurations
Source: https://infisical.com/docs/self-hosting/deployment-options/native/linux-package/commands-configuration

Learn how to configure and manage the Infisical Linux package

## Configuration Overview

All configuration for the Infisical Linux package is managed through a single file called `infisical.rb`, located in the `/etc/infisical` directory.
This file defines all necessary settings, including encryption keys, database connections, and environment-specific settings.

<Info> After making any changes to the `infisical.rb` file, always run `infisical-ctl reconfigure` to apply them. </Info>

### Example Configuration

```ruby infisical.rb theme={"dark"}
# Important: Replace these values with secure keys in production
infisical_core['ENCRYPTION_KEY'] = '6c1fe4e407b8911c104518103505b218'
infisical_core['AUTH_SECRET'] = '5lrMXKKWCVocS/uerPsl7V+TX/aaUaI7iDkgl3tSmLE='

# Database connection strings
infisical_core['DB_CONNECTION_URI'] = 'postgres://<username>:<password>@<host>:5432/<database>'
infisical_core['REDIS_URL'] = 'redis://<host>:6379'
```

For a full list of supported configuration variables, refer to the [configuration variables documentation](/self-hosting/configuration/envars).

## All `infisical-ctl` Commands

The Infisical Linux package includes the `infisical-ctl` command-line tool, which allows you to manage your deployment.
The available commands are listed below.

| Command                     | Description                                                              |
| --------------------------- | ------------------------------------------------------------------------ |
| `infisical-ctl reconfigure` | Applies changes from `infisical.rb` and restarts the Infisical services. |
| `infisical-ctl start`       | Starts the Infisical services.                                           |
| `infisical-ctl stop`        | Stops all running Infisical services.                                    |
| `infisical-ctl status`      | Displays the current status of the Infisical services.                   |
| `infisical-ctl tail`        | Streams real-time logs from the Infisical application.                   |


# Installation
Source: https://infisical.com/docs/self-hosting/deployment-options/native/linux-package/installation

Learn how to deploy Infisical using the Linux package

Infisical can be deployed on Linux virtual machines without the need for containers using our standalone Linux packages.
These packages are available in both .deb (for Debian-based systems) and .rpm (for RHEL-based systems) formats.
The installation includes the Infisical service, along with a CLI tool (infisical-ctl) to help you manage configurations, startup, and application logging.
This approach is ideal for environments where containerization isn't desired, while still providing a lightweight deployment option.

## Prerequisites

This installation method only provides the Infisical application. You are responsible for configuring both PostgreSQL and Redis, either by using managed services (e.g., AWS RDS, Azure Database, GCP Cloud SQL/Memorystore) or by deploying them manually in your on-prem environment.
Please ensure you have the following before beginning installation of Infisical:

* A Linux server running a Debian/Ubuntu or RHEL-based distribution
* A running PostgreSQL database instance (version 14 and up)
* A running Redis database instance (versions 6.x or 7.x)

## Installation Steps

<Steps>
  <Step title="Install the Infisical Package">
    Select your Linux distribution to get started. Only AMD64-based systems are supported at this time, ARM support is coming soon.

    <Tabs>
      <Tab title="Debian/Ubuntu">
        <Warning>
          As of October 10, 2025, all future releases for Debian/Ubuntu will be distributed via the official Infisical repository at [https://artifacts-infisical-core.infisical.com](https://artifacts-infisical-core.infisical.com).
          No new releases will be published for Debian/Ubuntu on Cloudsmith going forward.
        </Warning>

        Add the Infisical repository:

        ```bash  theme={"dark"}
        curl -1sLf 'https://artifacts-infisical-core.infisical.com/setup.deb.sh' | sudo -E bash
        ```

        Install Infisical:

        ```bash  theme={"dark"}
        sudo apt-get update && sudo apt-get install -y infisical-core
        ```

        > **Note**: For production use, we recommend locking to a specific version to ensure consistency. [View available versions](https://github.com/Infisical/infisical/releases). All versions from `infisical-core-0.150.0~nightly~20251005` and above are supported.
      </Tab>

      <Tab title="RedHat/CentOS/Amazon Linux">
        <Warning>
          As of October 10, 2025, all future releases for Red Hat/CentOS/Amazon Linux will be distributed via the official Infisical repository at [https://artifacts-infisical-core.infisical.com](https://artifacts-infisical-core.infisical.com).
          No new releases will be published for Red Hat/CentOS/Amazon Linux on Cloudsmith going forward.
        </Warning>

        Add the Infisical repository:

        ```bash  theme={"dark"}
        curl -1sLf 'https://artifacts-infisical-core.infisical.com/setup.rpm.sh' | sudo -E bash
        ```

        Install Infisical:

        ```bash  theme={"dark"}
        sudo yum install infisical-core
        ```

        > **Note**: For production use, we recommend locking to a specific version to ensure consistency. [View available versions](https://github.com/Infisical/infisical/releases). All versions from `infisical-core-0.150.0~nightly~20251005` and above are supported.
      </Tab>
    </Tabs>

    Verify the installation:

    ```bash  theme={"dark"}
    infisical-ctl help
    ```
  </Step>

  <Step title="Create the Configuration File">
    Create an `infisical.rb` file at `/etc/infisical`. This file contains your database connection strings and other runtime settings.

    ```ruby  theme={"dark"}
    # Important: Replace with secure values in production
    infisical_core['ENCRYPTION_KEY'] = '6c1fe4e407b8911c104518103505b218'
    infisical_core['AUTH_SECRET'] = '5lrMXKKWCVocS/uerPsl7V+TX/aaUaI7iDkgl3tSmLE='

    # Example database connection strings
    infisical_core['DB_CONNECTION_URI'] = 'postgres://<db-username>:<db-password>@<db-host>:<db-port>/<db-name>'
    infisical_core['REDIS_URL'] = 'redis://<redis-host>:<redis-port>'
    ```

    See the full list of options in our [configuration documentation](/self-hosting/configuration/envars).
  </Step>

  <Step title="Start Infisical">
    1. Start the Infisical service:

    ```bash  theme={"dark"}
    infisical-ctl reconfigure
    ```

    The server runs on port `8080` by default (customizable in `infisical.rb`).

    2. Check the service status:
       ```bash  theme={"dark"}
       infisical-ctl status
       ```

    View the service logs in real-time:

    ```bash  theme={"dark"}
    infisical-ctl tail
    ```
  </Step>
</Steps>

## Platform Support

### Microsoft Windows

Infisical is built for Linux-based systems. It is not supported on Microsoft Windows, and we do not plan to support it in the near future. For Windows users, consider running Infisical in a virtual machine or WSL2 environment.

### Unsupported Linux Distributions and Unix-like Systems

Infisical is not tested or officially supported on the following:

* Arch Linux
* Fedora
* FreeBSD
* Gentoo
* macOS

We recommend sticking to officially supported distributions for the best experience.

## Linux vs Containerized Deployments

Infisical is a stateless application, which means it can be easily scaled and redeployed without maintaining internal state between instances.

If your use case requires rolling updates, self-healing, or auto-scaling, we recommend deploying Infisical in a containerized environment such as Kubernetes/OpenShift, or using managed container orchestration services like AWS ECS or Google Cloud Run.
These platforms offer built-in capabilities for high availability and help simplify operational overhead for your deployment.


# Docker
Source: https://infisical.com/docs/self-hosting/deployment-options/standalone-infisical

Learn how to run Infisical with Docker.

Prerequisites:

* Basic knowledge of [Docker](https://www.docker.com/)
* Have Docker installed on your system. If not, follow the installation guide [here](https://docs.docker.com/get-docker/).

Infisical is available as a single Docker image to ease deployment.
This Docker image only includes the application code, meaning you must supply a connection to a Postgres database and a Redis instance.
The following guide provides a detailed step-by-step walkthrough on how you can deploy Infisical with Docker.

<Steps>
  <Step title="Pull the Infisical Docker image">
    Visit [Docker Hub](https://hub.docker.com/r/infisical/infisical/tags) and select a version of Infisical image you would like to deploy.
    Then run the following command in your terminal to pull the specific Infisical Docker image.

    ```
    docker pull infisical/infisical:<version>
    ```

    Remember to replace `<version>` with the docker image tag of your choice.
  </Step>

  <Step title="Start Infisical">
    For a minimal installation of Infisical, you must configure `ENCRYPTION_KEY`, `AUTH_SECRET`, `DB_CONNECTION_URI`, `SITE_URL`, and `REDIS_URL`.     [View all available configurations](/self-hosting/configuration/envars).

    We recommend using Cloud-based Platform as a Service (PaaS) solutions for PostgreSQL and Redis to ensure high availability.

    Once you have added the required environment variables to your docker run command, execute it in your terminal to get Infisical up and running.

    For example:

    ```bash  theme={"dark"}
    docker run -p 80:8080  \
    -e ENCRYPTION_KEY=f40c9178624764ad85a6830b37ce239a \
    -e AUTH_SECRET="q6LRi7c717a3DQ8JUxlWYkZpMhG4+RHLoFUVt3Bvo2U=" \
    -e DB_CONNECTION_URI="<>" \
    -e REDIS_URL="<>" \
    -e SITE_URL="<>" \
    infisical/infisical:<version>
    ```

    <Warning>
      The above environment variable values are only to be used as an example and should not be used in production
    </Warning>

    Once the container is running, verify the installation by opening your web browser and navigating to `http://localhost:80`.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/self-hosting/applicable-to-all/selfhost-signup.png" alt="self-hosted sign up" />
  </Step>
</Steps>

### Additional discussion

It's important to note that the above is a basic example of deploying Infisical using Docker.
In practice, for production deployments, you may want to use container orchestration platforms such as AWS ECS, Google Cloud Run, or Kubernetes.
These platforms offer additional features like scalability, load balancing, and automated deployment, making them suitable for handling production-level traffic and providing high availability.


# Infisical Enterprise
Source: https://infisical.com/docs/self-hosting/ee

Find out how to activate Infisical Enterprise edition (EE) features.

While most features in Infisical are free to use, others are paid and require purchasing an enterprise license to use them.

This guide walks through how you can use these paid features on a self-hosted instance of Infisical.

<Steps>
  <Step title="Purchase a license">
    Start by either signing up for a free demo [here](https://infisical.com/schedule-demo) or contacting [sales@infisical.com](mailto:sales@infisical.com) to purchase a license.

    Once purchased, you will be issued a license key.
  </Step>

  <Step title="Activate the license">
    Depending on whether or not the environment where Infisical is deployed has internet access, you may be issued a regular license or an offline license.

    <Tabs>
      <Tab title="Regular License">
        * Assign the issued license key to the `LICENSE_KEY` environment variable in your Infisical instance.

        * Your Infisical instance will need to communicate with the Infisical license server to validate the license key.
          If you want to limit outgoing connections only to the Infisical license server, you can use the following IP addresses: `13.248.249.247` and `35.71.190.59`

        <Note>
          Ensure that your firewall or network settings allow outbound connections to these IP addresses to avoid any issues with license validation.
        </Note>
      </Tab>

      <Tab title="Offline License">
        * Assign the issued license key to the `LICENSE_KEY_OFFLINE` environment variable in your Infisical instance.

        <Note>
          How you set the environment variable will depend on the deployment method you used. Please refer to the documentation of your deployment method for specific instructions.
        </Note>
      </Tab>
    </Tabs>

    Once your instance starts up, the license key will be validated and youll be able to use the paid features.
    However, when the license expires, Infisical will continue to run, but EE features will be disabled until the license is renewed or a new one is purchased.
  </Step>
</Steps>


# FAQ
Source: https://infisical.com/docs/self-hosting/faq

Frequently Asked Questions about self-hosting Infisical.

Frequently asked questions about self-hosted instance of Infisical can be found on this page.
If you can't find the answer you are looking for, please create an issue on our [GitHub repository](https://github.com/Infisical/infisical) or join our [Slack community](https://infisical.com/slack) for additional support.

<Accordion title="When I refresh any page, it logs me out" defaultOpen="true">
  This issue is typically seen when you haven't set up SSL for your self-hosted instance of Infisical. When SSL is not enabled, you can't receive secure cookies, preventing the session data to not be saved.

  To fix this, we highly recommend that you set up SSL for your instance.
  However, in the event you choose to use Infisical without SSL, you can do so by setting the `HTTPS_ENABLED` environment variable to `"false"` for the backend application.

  [Learn more about secure cookies](https://really-simple-ssl.com/definition/what-are-secure-cookies/)
</Accordion>

<Accordion title="How can I upgrade my Infisical instance to Postgres version?">
  Follow the step by step guide [here](self-hosting/guides/mongo-to-postgres) to learn how.
</Accordion>


# Programmatic Provisioning
Source: https://infisical.com/docs/self-hosting/guides/automated-bootstrapping

Learn how to provision and configure Infisical instances programmatically without UI interaction

Infisical's Automated Bootstrapping feature enables you to provision and configure an Infisical instance without using the UI, allowing for complete automation through static configuration files, API calls, or CLI commands. This is especially valuable for enterprise environments where automated deployment and infrastructure-as-code practices are essential.

The bootstrapping workflow automates creating an admin user account, initializing an organization for the entire instance, establishing an **instance admin machine identity** with full administrative permissions, and returning the machine identity credentials for further automation.

## Prerequisites

* An Infisical instance launched with all required configuration variables
* Access to the Infisical CLI or the ability to make API calls to the instance
* Network connectivity to the Infisical instance

## Key Concepts

* **Instance Initialization**: Infisical requires [configuration variables](/self-hosting/configuration/envars) to be set during launch, after which the bootstrap process can be triggered.
* **Instance Admin Machine Identity**: The bootstrapping process creates a machine identity with instance-level admin privileges, which can be used to programmatically manage all aspects of the Infisical instance.
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/self-hosting/guides/automated-bootstrapping/identity-instance-admin.png" alt="Instance Admin Identity" />
* **Token Auth**: The instance admin machine identity uses [Token Auth](/documentation/platform/identities/token-auth), providing a JWT token that can be used directly to make authenticated requests to the Infisical API.

## Bootstrap Methods

You can bootstrap an Infisical instance using the API, CLI, or Helm chart.

<Tabs>
  <Tab title="Using the API">
    Make a POST request to the bootstrap endpoint:

    ```
    POST: http://your-infisical-instance.com/api/v1/admin/bootstrap
    {
        "email": "admin@example.com",
        "password": "your-secure-password",
        "organization": "your-org-name"
    }
    ```

    Example using curl:

    ```bash  theme={"dark"}
    curl -X POST \
      -H "Content-Type: application/json" \
      -d '{"email":"admin@example.com","password":"your-secure-password","organization":"your-org-name"}' \
      http://your-infisical-instance.com/api/v1/admin/bootstrap
    ```

    ### API Response Structure

    The bootstrap process returns a JSON response with details about the created user, organization, and machine identity:

    ```json  theme={"dark"}
    {
      "identity": {
        "credentials": {
          "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZGVudGl0eUlkIjoiZGIyMjQ3OTItZWQxOC00Mjc3LTlkYWUtNTdlNzUyMzE1ODU0IiwiaWRlbnRpdHlBY2Nlc3NUb2tlbklkIjoiZmVkZmZmMGEtYmU3Yy00NjViLWEwZWEtZjM5OTNjMTg4OGRlIiwiYXV0aFRva2VuVHlwZSI6ImlkZW50aXR5QWNjZXNzVG9rZW4iLCJpYXQiOjE3NDIzMjI0ODl9.mqcZZqIFqER1e9ubrQXp8FbzGYi8nqqZwfMvz09g-8Y"
        },
        "id": "db224792-ed18-4277-9dae-57e752315854",
        "name": "Instance Admin Identity"
      },
      "message": "Successfully bootstrapped instance",
      "organization": {
        "id": "b56bece0-42f5-4262-b25e-be7bf5f84957",
        "name": "dog",
        "slug": "dog-v-e5l"
      },
      "user": {
        "email": "admin@example.com",
        "firstName": "Admin",
        "id": "a418f355-c8da-453c-bbc8-6c07208eeb3c",
        "lastName": "User",
        "superAdmin": true,
        "username": "admin@example.com"
      }
    }
    ```
  </Tab>

  <Tab title="Using the CLI">
    Use the [Infisical CLI](/cli/commands/bootstrap) to bootstrap the instance and extract the token for immediate use in automation:

    ```bash  theme={"dark"}
    infisical bootstrap --domain="http://localhost:8080" --email="admin@example.com" --password="your-secure-password" --organization="your-org-name" | jq ".identity.credentials.token"
    ```

    This example command pipes the output through `jq` to extract only the machine identity token, making it easy to capture and use directly in automation scripts or export as an environment variable for tools like Terraform.

    ### API Response Structure

    The bootstrap process returns a JSON response with details about the created user, organization, and machine identity:

    ```json  theme={"dark"}
    {
      "identity": {
        "credentials": {
          "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZGVudGl0eUlkIjoiZGIyMjQ3OTItZWQxOC00Mjc3LTlkYWUtNTdlNzUyMzE1ODU0IiwiaWRlbnRpdHlBY2Nlc3NUb2tlbklkIjoiZmVkZmZmMGEtYmU3Yy00NjViLWEwZWEtZjM5OTNjMTg4OGRlIiwiYXV0aFRva2VuVHlwZSI6ImlkZW50aXR5QWNjZXNzVG9rZW4iLCJpYXQiOjE3NDIzMjI0ODl9.mqcZZqIFqER1e9ubrQXp8FbzGYi8nqqZwfMvz09g-8Y"
        },
        "id": "db224792-ed18-4277-9dae-57e752315854",
        "name": "Instance Admin Identity"
      },
      "message": "Successfully bootstrapped instance",
      "organization": {
        "id": "b56bece0-42f5-4262-b25e-be7bf5f84957",
        "name": "dog",
        "slug": "dog-v-e5l"
      },
      "user": {
        "email": "admin@example.com",
        "firstName": "Admin",
        "id": "a418f355-c8da-453c-bbc8-6c07208eeb3c",
        "lastName": "User",
        "superAdmin": true,
        "username": "admin@example.com"
      }
    }
    ```
  </Tab>

  <Tab title="Helm Chart">
    When deploying Infisical using the official [Helm chart](/self-hosting/deployment-options/kubernetes-helm#kubernetes-via-helm-chart), you can enable automatic bootstrapping that runs as part of the deployment process. This eliminates the need to manually bootstrap the instance after deployment.

    The bootstrapping process automatically generates a Kubernetes secret containing the instance admin token, which can then be referenced by Crossplane providers, Terraform operators, or other automation systems for further infrastructure provisioning and configuration.

    ### Configuration

    Enable auto bootstrapping in your Helm values by setting `autoBootstrap.enabled: true` and providing the necessary configuration:

    ```yaml  theme={"dark"}
    autoBootstrap:
      enabled: true
      organization: "My Organization"
      secretTemplate: '{"data":{"token":"{{.Identity.Credentials.Token}}"}}'

      secretDestination:
        name: "infisical-bootstrap-secret"
        namespace: "default" # defaults to release namespace if not specified

      credentialSecret:
        name: "infisical-bootstrap-credentials"
    ```

    You'll also need to create a secret containing the bootstrap credentials before deployment. The secret must contain `INFISICAL_ADMIN_EMAIL` and `INFISICAL_ADMIN_PASSWORD` keys:

    ```bash  theme={"dark"}
    kubectl create secret generic infisical-bootstrap-credentials \
      --from-literal=INFISICAL_ADMIN_EMAIL="admin@example.com" \
      --from-literal=INFISICAL_ADMIN_PASSWORD="your-secure-password" \
      --namespace=release-namespace
    ```

    ### How It Works

    The Helm chart auto bootstrap feature:

    1. **Post-Install Hook**: Runs automatically after the main Infisical deployment is complete
    2. **Readiness Check**: Uses an init container with curl to wait for Infisical to be ready by polling the `/api/status` endpoint
    3. **Bootstrap Execution**: Uses the Infisical CLI to bootstrap the instance
    4. **Kubernetes Secret Creation**: Creates a Kubernetes secret directly via the Kubernetes API using the rendered template
    5. **RBAC**: Automatically configures the necessary permissions (`get`, `create`, `update` on secrets) for the bootstrap job

    ### Template System

    The `secretTemplate` field allows you to customize the data section of the created Kubernetes secret. The template has access to the full bootstrap response with the following available data fields:

    * `{{ .Identity.Credentials.Token }}`: The admin machine identity token
    * `{{ .Identity.ID }}`: The identity ID
    * `{{ .Identity.Name }}`: The identity name
    * `{{ .Organization.ID }}`: The organization ID
    * `{{ .Organization.Name }}`: The organization name
    * `{{ .Organization.Slug }}`: The organization slug
    * `{{ .User.Email }}`: The admin user email
    * `{{ .User.ID }}`: The admin user ID
    * `{{ .User.FirstName }}`: The admin user first name
    * `{{ .User.LastName }}`: The admin user last name

    The template also supports the `encodeBase64` function for base64 encoding values.

    Example template for storing multiple values:

    ```yaml  theme={"dark"}
    secretTemplate: |
      {
        "data": {
          "infisical_token": "{{ .Identity.Credentials.Token }}",
          "admin_email": "{{ .User.Email }}",
          "organization": "{{ .Organization.Name }}"
        }
      }
    ```

    ### Benefits

    * **Zero-Touch Deployment**: Complete Infisical setup without manual intervention
    * **Infrastructure as Code**: Bootstrap configuration is versioned with your Helm values
    * **Secure Token Storage**: Admin identity credentials are immediately stored in Kubernetes secrets
    * **Integration Ready**: The created secret can be referenced by other applications or automation tools

    ### Security Considerations

    * The bootstrap job requires permissions to create secrets in the specified namespace
    * Bootstrap credentials should be stored securely and rotated regularly
    * The generated admin token has full instance privileges and should be protected accordingly
    * Consider using Kubernetes RBAC to restrict access to the generated secret
  </Tab>
</Tabs>

## Using the Instance Admin Machine Identity Token

The bootstrap process automatically creates a machine identity with Token Auth configured. The returned token has instance-level admin privileges (the highest level of access) and should be treated with the same security considerations as a root credential.

The token enables full programmatic control of your Infisical instance and can be used in the following ways:

### 1. Infrastructure Automation

Store the token securely for use with infrastructure automation tools. Due to the sensitive nature of this token, ensure it's protected using appropriate secret management practices:

#### Kubernetes Secret (with appropriate RBAC restrictions)

```yaml  theme={"dark"}
apiVersion: v1
kind: Secret
metadata:
  name: infisical-admin-credentials
type: Opaque
data:
  token: <base64-encoded-token>
```

#### Environment Variable for Terraform

```bash  theme={"dark"}
export INFISICAL_TOKEN=your-access-token
terraform apply
```

### 2. Programmatic Resource Management

Use the token to authenticate API calls for creating and managing Infisical resources. The token works exactly like any other Token Auth access token in the Infisical API:

```bash  theme={"dark"}
curl -X POST \
  -H "Authorization: Bearer ${INFISICAL_TOKEN}" \
  -H "Content-Type: application/json" \
  -d '{
    "projectName": "New Project",
    "projectDescription": "A project created via API",
    "slug": "new-project-slug",
    "template": "default",
    "type": "SECRET_MANAGER"
  }' \
  https://your-infisical-instance.com/api/v2/projects
```

## Important Notes

* **Security Warning**: The instance admin machine identity has the highest level of privileges in your Infisical deployment. The token should be treated with the utmost security and handled like a root credential. Unauthorized access to this token could compromise your entire Infisical instance.
* Security controls prevent privilege escalation: instance admin identities cannot be managed by non-instance admin users and identities
* The instance admin permission of the generated identity can be revoked later in the server admin panel if needed
* The generated admin user account can still be used for UI access if needed, or can be removed if you prefer to manage everything through the machine identity
* This process is designed to work with future Crossplane providers and the existing Terraform provider for full infrastructure-as-code capabilities
* All necessary configuration variables should be set during the initial launch of the Infisical instance


# Adding Custom Certificates
Source: https://infisical.com/docs/self-hosting/guides/custom-certificates

Learn how to configure Infisical with custom certificates

By default, the Infisical Docker image includes certificates from well-known public certificate authorities.
However, some integrations with Infisical may need to communicate with your internal services that use private certificate authorities.
To configure trust for custom certificates, follow these steps. This is particularly useful for connecting Infisical with self-hosted services like GitLab.

## Prerequisites

* Docker
* Standalone [Infisical image](https://hub.docker.com/r/infisical/infisical)
* Certificate public key `.crt` files

## Setup

1. Place all your public key `.crt` files into a single directory.
2. Mount the directory containing the `.crt` files to the `/usr/local/share/ca-certificates/` path in the Infisical container.
3. Set the following environment variable on your Infisical container:
   ```
   NODE_EXTRA_CA_CERTS=/etc/ssl/certs/ca-certificates.crt
   ```
4. Start the Infisical container.

By following these steps, your Infisical container will trust the specified certificates, allowing you to securely connect Infisical to your internal services.


# Migrate Mongo to Postgres
Source: https://infisical.com/docs/self-hosting/guides/mongo-to-postgres

Learn how to migrate Infisical from MongoDB to PostgreSQL.

This guide will provide step by step instructions on migrating your Infisical instance running on MongoDB to the newly released PostgreSQL version of Infisical.
The newly released Postgres version of Infisical is the only version of Infisical that will receive feature updates and patches going forward.

<Tip>
  If you have a small set of secrets, we recommend you to download the secrets and upload them to your new instance of Infisical instead of running the migration script.
</Tip>

## Prerequisites

Before starting the migration, ensure you have the following command line tools installed:

* [git](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git)
* [pg\_dump](https://www.postgresql.org/docs/current/app-pgrestore.html)
* [pg\_restore](https://www.postgresql.org/docs/current/app-pgdump.html)
* [mongodump](https://www.mongodb.com/docs/database-tools/mongodump/)
* [mongorestore](https://www.mongodb.com/docs/database-tools/mongorestore/)
* [Docker](https://docs.docker.com/engine/install/)

## Prepare for migration

<Steps>
  <Step title="Backup Production MongoDB Data">
    While the migration script will not mutate any MongoDB production data, we recommend you to take a backup of your MongoDB instance if possible.
  </Step>

  <Step title="Set Migration Mode">
    To prevent new data entries during the migration, set your Infisical instance to migration mode by setting the environment variable `MIGRATION_MODE=true` and redeploying your instance.
    This mode will block all write operations, only allowing GET requests. It also disables user logins and sets up a migration page to prevent UI interactions.
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/self-hosting/guides/mongo-postgres/mongo-migration.png" alt="migration mode" />
  </Step>

  <Step title="Start local instances of Mongo and Postgres databases">
    Start local instances of MongoDB and Postgres. This will be used in later steps to process and transform the data locally.

    To start local instances of the two databases, create a file called `docker-compose.yaml` as shown below.

    ```yaml docker-compose.yaml theme={"dark"}
      version: '3.1'

      services:
        mongodb:
          image: mongo
          restart: always
          environment:
            MONGO_INITDB_ROOT_USERNAME: root
            MONGO_INITDB_ROOT_PASSWORD: example
          ports:
            - "27017:27017"
          volumes:
            - mongodb_data:/data/db

        postgres:
          image: postgres
          restart: always
          environment:
            POSTGRES_PASSWORD: example
          ports:
            - "5432:5432"
          volumes:
            - postgres_data:/var/lib/postgresql/data

      volumes:
        mongodb_data:
        postgres_data:
    ```

    Next, run the command below in the same working directory where the `docker-compose.yaml` file resides to start both services.

    ```
    docker-compose up
    ```
  </Step>
</Steps>

## Dump MongoDB

To speed up the data transformation process, the first step involves transferring the production data from Infisical's MongoDB to a local machine.
This is achieved by creating a dump of the production database and then uploading this dumped data into a local Mongo instance.
By having a running local instance of the production database, we will significantly reduce the time it takes to run the migration script.

<Steps>
  <Step title="Dump MongoDB data to your local machine using">
    ```
    mongodump --uri=<your_mongo_prod_uri> --archive="mongodump-db" --db=<db name> --excludeCollection=auditlogs
    ```
  </Step>

  <Step title="Restore this data to the local MongoDB instance">
    ```
    mongorestore --uri=mongodb://root:example@localhost:27017/ --archive="mongodump-db"
    ```
  </Step>
</Steps>

## Start the migration

Once started, the migration script will transform MongoDB data into an equivalent PostgreSQL format.

<Steps>
  <Step title="Clone Infisical Repository">
    Clone the Infisical MongoDB repository.

    ```
    git clone -b infisical/v0.46.11-postgres https://github.com/Infisical/infisical.git
    ```
  </Step>

  <Step title="Install dependencies for backend">
    ```
    cd backend
    ```

    ```
    npm install
    ```
  </Step>

  <Step title="Install dependencies for script">
    ```
    cd pg-migrator
    ```

    ```
      npm install
    ```
  </Step>

  <Step title="Execute Migration Script">
    ```
      npm run migration
    ```

    When executing the above command, you'll be asked to provide the MongoDB connection string for the database containing your production Infisical data. Since our production Mongo data is transferred to a local Mongo instance, you should input the connection string for this local instance.

    ```
    mongodb://root:example@localhost:27017/<db-name>?authSource=admin
    ```

    <Tip>
      Remember to replace `<db-name>` with the name of the MongoDB database. If you are not sure the name, you can use [Compass](https://www.mongodb.com/products/tools/compass) to view the available databases.
    </Tip>

    Next, you will be asked to enter the Postgres connection string for the database where the transformed data should be stored.
    Input the connection string of the local Postgres instance that was set up earlier in the guide.

    ```
    postgres://infisical:infisical@localhost/infisical?sslmode=disable
    ```
  </Step>

  <Step title="Store migration metadata">
    Once the script has completed, you will notice a new folder has been created called `db` in the `pg-migrator` folder.
    This folder contains meta data for schema mapping and can be helpful when debugging migration related issues.
    We highly recommend you to make a copy of this folder in case you need assistance from the Infisical team during your migration process.

    <Info>
      The `db` folder does not contain any sensitive data
    </Info>
  </Step>
</Steps>

## Finalizing Migration

At this stage, the data from the Mongo instance of Infisical should have been successfully converted into its Postgres equivalent.
The remaining step involves transferring the local Postgres database, which now contains all the migrated data, to your chosen production Postgres environment.
Rather than transferring the data row-by-row from your local machine to the production Postgres database, we will first create a dump file from the local Postgres and then upload this file to your production Postgres instance.

<Steps>
  <Step title="Dump from local PostgreSQL">
    ```
    pg_dump -h localhost -U infisical -Fc -b -v -f dumpfilelocation.sql -d infisical
    ```
  </Step>

  <Step title="Upload to production PostgreSQL">
    ```
    pg_restore --clean -v -h <host> -U <db-user-name> -d <database-name> -j 2 dumpfilelocation.sql 
    ```

    <Tip>
      Remember to replace `<host>`, `<db-user-name>`, `<database-name>` with the corresponding details of your production Postgres database.
    </Tip>
  </Step>

  <Step title="Verify Data Upload">
    Use a tool like Beekeeper Studio to confirm that the data has been successfully transferred to your production Postgres DB.
  </Step>
</Steps>

## Post-Migration Steps

Once the data migration to PostgreSQL is complete, you're ready to deploy Infisical using the deployment method of your choice.
For guidance on deployment options, please visit the [self-hosting documentation](/self-hosting/overview).
Remember to transfer the necessary [environment variables](/self-hosting/configuration/envars) from the MongoDB version of Infisical to the new Postgres based Infisical; rest assured, they are fully compatible.

<Warning>
  The first deployment of Postgres based Infisical must be deployed with Docker image tag `v0.46.11-postgres`.
  After deploying this version, you can proceed to update to any subsequent versions.
</Warning>

## Important Notes

Infisical's [Docker Hub repository](https://hub.docker.com/r/infisical/infisical) uses different tagging conventions to indicate which database backend is used:

* **Before v0.46.11**
  * Infisical ran on MongoDB backend

* **After v0.46.11**
  * Version tags started to be suffixed with `-postgres`
  * Infisical transitioned to PostgreSQL backend

* **After v0.147.0**
  * Infisical remains on PostgreSQL backend
  * The `-postgres` suffix was removed from tags for brevity


# Monitoring and Telemetry Setup
Source: https://infisical.com/docs/self-hosting/guides/monitoring-telemetry

Learn how to set up monitoring and telemetry for your self-hosted Infisical instance using Grafana, Prometheus, and OpenTelemetry.

Infisical provides comprehensive monitoring and telemetry capabilities to help you monitor the health, performance, and usage of your self-hosted instance. This guide covers setting up monitoring using Grafana with two different telemetry collection approaches.

## Overview

Infisical exports metrics in **OpenTelemetry (OTEL) format**, which provides maximum flexibility for your monitoring infrastructure. While this guide focuses on Grafana, the OTEL format means you can easily integrate with:

* **Cloud-native monitoring**: AWS CloudWatch, Google Cloud Monitoring, Azure Monitor
* **Observability platforms**: Datadog, New Relic, Splunk, Dynatrace
* **Custom backends**: Any system that supports OTEL ingestion
* **Traditional monitoring**: Prometheus, Grafana (as covered in this guide)

Infisical supports two telemetry collection methods:

1. **Pull-based (Prometheus)**: Exposes metrics on a dedicated endpoint for Prometheus to scrape
2. **Push-based (OTLP)**: Sends metrics to an OpenTelemetry Collector via OTLP protocol

Both approaches provide the same metrics data in OTEL format, so you can choose the one that best fits your infrastructure and monitoring strategy.

## Prerequisites

* Self-hosted Infisical instance running
* Access to deploy monitoring services (Prometheus, Grafana, etc.)
* Basic understanding of Prometheus and Grafana

## Setup

### Environment Variables

Configure the following environment variables in your Infisical backend:

```bash  theme={"dark"}
# Enable telemetry collection
OTEL_TELEMETRY_COLLECTION_ENABLED=true

# Choose export type: "prometheus" or "otlp"
OTEL_EXPORT_TYPE=prometheus
```

<Tabs>
  <Tab title="Pull-based Monitoring (Prometheus)">
    This approach exposes metrics on port 9464 at the `/metrics` endpoint, allowing Prometheus to scrape the data. The metrics are exposed in Prometheus format but originate from OpenTelemetry instrumentation.

    ### Configuration

    <Steps>
      <Step title="Enable Prometheus export in Infisical">
        ```bash  theme={"dark"}
        OTEL_TELEMETRY_COLLECTION_ENABLED=true
        OTEL_EXPORT_TYPE=prometheus
        ```
      </Step>

      <Step title="Expose the metrics port">
        Expose the metrics port in your Infisical backend:

        * **Docker**: Expose port 9464
        * **Kubernetes**: Create a service exposing port 9464
        * **Other**: Ensure port 9464 is accessible to your monitoring stack
      </Step>

      <Step title="Create Prometheus configuration">
        Create `prometheus.yml`:

        ```yaml  theme={"dark"}
        global:
          scrape_interval: 30s
          evaluation_interval: 30s

        scrape_configs:
          - job_name: "infisical"
            scrape_interval: 30s
            static_configs:
              - targets: ["infisical-backend:9464"] # Adjust hostname/port based on your deployment
            metrics_path: "/metrics"
        ```

        <Note>
          Replace `infisical-backend:9464` with the actual hostname and port where your Infisical backend is running. This could be:

          * **Docker Compose**: `infisical-backend:9464` (service name)
          * **Kubernetes**: `infisical-backend.default.svc.cluster.local:9464` (service name)
          * **Bare Metal**: `192.168.1.100:9464` (actual IP address)
          * **Cloud**: `your-infisical.example.com:9464` (domain name)
        </Note>
      </Step>
    </Steps>

    ### Deployment Options

    Once you've configured Infisical to expose metrics, you'll need to deploy Prometheus to scrape and store them. Below are examples for different deployment environments. Choose the option that matches your infrastructure.

    <Tabs>
      <Tab title="Docker Compose">
        ```yaml  theme={"dark"}
        services:
          prometheus:
            image: prom/prometheus:latest
            ports:
              - "9090:9090"
            volumes:
              - ./prometheus.yml:/etc/prometheus/prometheus.yml:ro
            command:
              - "--config.file=/etc/prometheus/prometheus.yml"

          grafana:
            image: grafana/grafana:latest
            ports:
              - "3000:3000"
            environment:
              - GF_SECURITY_ADMIN_USER=admin
              - GF_SECURITY_ADMIN_PASSWORD=admin
        ```
      </Tab>

      <Tab title="Kubernetes">
        ```yaml  theme={"dark"}
        # prometheus-deployment.yaml
        apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: prometheus
        spec:
          replicas: 1
          selector:
            matchLabels:
              app: prometheus
          template:
            metadata:
              labels:
                app: prometheus
            spec:
              containers:
                - name: prometheus
                  image: prom/prometheus:latest
                  ports:
                    - containerPort: 9090
                  volumeMounts:
                    - name: config
                      mountPath: /etc/prometheus
              volumes:
                - name: config
                  configMap:
                    name: prometheus-config

        ---
        # prometheus-service.yaml
        apiVersion: v1
        kind: Service
        metadata:
          name: prometheus
        spec:
          selector:
            app: prometheus
          ports:
            - port: 9090
              targetPort: 9090
          type: ClusterIP
        ```
      </Tab>

      <Tab title="Helm">
        ```bash  theme={"dark"}
        helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
        helm install prometheus prometheus-community/prometheus \
          --set server.config.global.scrape_interval=30s \
          --set server.config.scrape_configs[0].job_name=infisical \
          --set server.config.scrape_configs[0].static_configs[0].targets[0]=infisical-backend:9464
        ```
      </Tab>
    </Tabs>
  </Tab>

  <Tab title="Push-based Monitoring (OTLP)">
    This approach sends metrics directly to an OpenTelemetry Collector via the OTLP protocol. This gives you the most flexibility as you can configure the collector to export to multiple backends simultaneously.

    ### Configuration

    <Steps>
      <Step title="Enable OTLP export in Infisical">
        ```bash  theme={"dark"}
        OTEL_TELEMETRY_COLLECTION_ENABLED=true
        OTEL_EXPORT_TYPE=otlp
        OTEL_EXPORT_OTLP_ENDPOINT=http://otel-collector:4318/v1/metrics
        OTEL_COLLECTOR_BASIC_AUTH_USERNAME=infisical
        OTEL_COLLECTOR_BASIC_AUTH_PASSWORD=infisical
        OTEL_OTLP_PUSH_INTERVAL=30000
        ```
      </Step>

      <Step title="Create OpenTelemetry Collector configuration">
        Create `otel-collector-config.yaml`:

        ```yaml  theme={"dark"}
        extensions:
          health_check:
          pprof:
          zpages:
          basicauth/server:
            htpasswd:
              inline: |
                your_username:your_password

        receivers:
          otlp:
            protocols:
              http:
                endpoint: 0.0.0.0:4318
                auth:
                  authenticator: basicauth/server

          prometheus:
            config:
              scrape_configs:
                - job_name: otel-collector
                  scrape_interval: 30s
                  static_configs:
                    - targets: [infisical-backend:9464]
                  metric_relabel_configs:
                    - action: labeldrop
                      regex: "service_instance_id|service_name"

        processors:
          batch:

        exporters:
          prometheus:
            endpoint: "0.0.0.0:8889"
            auth:
              authenticator: basicauth/server
            resource_to_telemetry_conversion:
              enabled: true

        service:
          extensions: [basicauth/server, health_check, pprof, zpages]
          pipelines:
            metrics:
              receivers: [otlp]
              processors: [batch]
              exporters: [prometheus]
        ```

        <Warning>
          Replace `your_username:your_password` with your chosen credentials. These must match the values you set in Infisical's `OTEL_COLLECTOR_BASIC_AUTH_USERNAME` and `OTEL_COLLECTOR_BASIC_AUTH_PASSWORD` environment variables.
        </Warning>
      </Step>

      <Step title="Create Prometheus configuration">
        Create Prometheus configuration for the collector:

        ```yaml  theme={"dark"}
        global:
          scrape_interval: 30s
          evaluation_interval: 30s

        scrape_configs:
          - job_name: "otel-collector"
            scrape_interval: 30s
            static_configs:
              - targets: ["otel-collector:8889"] # Adjust hostname/port based on your deployment
            metrics_path: "/metrics"
        ```

        <Note>
          Replace `otel-collector:8889` with the actual hostname and port where your OpenTelemetry Collector is running. This could be:

          * **Docker Compose**: `otel-collector:8889` (service name)
          * **Kubernetes**: `otel-collector.default.svc.cluster.local:8889` (service name)
          * **Bare Metal**: `192.168.1.100:8889` (actual IP address)
          * **Cloud**: `your-collector.example.com:8889` (domain name)
        </Note>
      </Step>
    </Steps>

    ### Deployment Options

    After configuring Infisical and the OpenTelemetry Collector, you'll need to deploy the collector to receive metrics from Infisical. Below are examples for different deployment environments. Choose the option that matches your infrastructure.

    <Tabs>
      <Tab title="Docker Compose">
        ```yaml  theme={"dark"}
        services:
          otel-collector:
            image: otel/opentelemetry-collector-contrib:latest
            ports:
              - 4318:4318 # OTLP http receiver
              - 8889:8889 # Prometheus exporter metrics
            volumes:
              - ./otel-collector-config.yaml:/etc/otelcol-contrib/config.yaml:ro
            command:
              - "--config=/etc/otelcol-contrib/config.yaml"
        ```
      </Tab>

      <Tab title="Kubernetes">
        ```yaml  theme={"dark"}
        # otel-collector-deployment.yaml
        apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: otel-collector
        spec:
          replicas: 1
          selector:
            matchLabels:
              app: otel-collector
          template:
            metadata:
              labels:
                app: otel-collector
            spec:
              containers:
                - name: otel-collector
                  image: otel/opentelemetry-collector-contrib:latest
                  ports:
                    - containerPort: 4318
                    - containerPort: 8889
                  volumeMounts:
                    - name: config
                      mountPath: /etc/otelcol-contrib
              volumes:
                - name: config
                  configMap:
                    name: otel-collector-config
        ```
      </Tab>

      <Tab title="Helm">
        ```bash  theme={"dark"}
        helm repo add open-telemetry https://open-telemetry.github.io/opentelemetry-helm-charts
        helm install otel-collector open-telemetry/opentelemetry-collector \
          --set config.receivers.otlp.protocols.http.endpoint=0.0.0.0:4318 \
          --set config.exporters.prometheus.endpoint=0.0.0.0:8889
        ```
      </Tab>
    </Tabs>
  </Tab>
</Tabs>

## Available Metrics

Infisical exposes the following key metrics in OpenTelemetry format:

### Core API Metrics

These metrics track all HTTP API requests to Infisical, including request counts, latency, and errors. Use these to monitor overall API health, identify performance bottlenecks, and track usage patterns across users and machine identities.

<AccordionGroup>
  <Accordion title="Total API Requests">
    **Metric Name**: `infisical.http.server.request.count`

    **Type**: Counter

    **Unit**: `{request}`

    **Description**: Total number of API requests to Infisical (covers both human users and machine identities)

    **Attributes**:

    * `infisical.organization.id` (string): Organization ID
    * `infisical.organization.name` (string): Organization name (e.g., "Platform Engineering Team")
    * `infisical.user.id` (string, optional): User ID if human user
    * `infisical.user.email` (string, optional): User email (e.g., "[jane.doe@cisco.com](mailto:jane.doe@cisco.com)")
    * `infisical.identity.id` (string, optional): Machine identity ID
    * `infisical.identity.name` (string, optional): Machine identity name (e.g., "prod-k8s-operator")
    * `infisical.auth.method` (string, optional): Auth method used
    * `http.request.method` (string): HTTP method (GET, POST, PUT, DELETE)
    * `http.route` (string): API endpoint route pattern
    * `http.response.status_code` (int): HTTP status code
    * `infisical.project.id` (string, optional): Project ID
    * `infisical.project.name` (string, optional): Project name
    * `user_agent.original` (string, optional): User agent string
    * `client.address` (string, optional): IP address
  </Accordion>

  <Accordion title="Request Duration">
    **Metric Name**: `infisical.http.server.request.duration`

    **Type**: Histogram

    **Unit**: `s` (seconds)

    **Description**: API request latency

    **Buckets**: \[0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1, 2.5, 5, 10]

    **Attributes**:

    * `infisical.organization.id` (string): Organization ID
    * `infisical.organization.name` (string): Organization name
    * `infisical.user.id` (string, optional): User ID if human user
    * `infisical.user.email` (string, optional): User email
    * `infisical.identity.id` (string, optional): Machine identity ID
    * `infisical.identity.name` (string, optional): Machine identity name
    * `http.request.method` (string): HTTP method
    * `http.route` (string): API endpoint route pattern
    * `http.response.status_code` (int): HTTP status code
    * `infisical.project.id` (string, optional): Project ID
    * `infisical.project.name` (string, optional): Project name
  </Accordion>

  <Accordion title="API Errors by Actor">
    **Metric Name**: `infisical.http.server.error.count`

    **Type**: Counter

    **Unit**: `{error}`

    **Description**: API errors grouped by actor (for identifying misconfigured services)

    **Attributes**:

    * `infisical.organization.id` (string): Organization ID
    * `infisical.organization.name` (string): Organization name
    * `infisical.user.id` (string, optional): User ID if human
    * `infisical.user.email` (string, optional): User email
    * `infisical.identity.id` (string, optional): Identity ID if machine
    * `infisical.identity.name` (string, optional): Identity name
    * `http.route` (string): API endpoint where error occurred
    * `http.request.method` (string): HTTP method
    * `error.type` (string): Error category/type (client\_error, server\_error, auth\_error, rate\_limit\_error, etc.)
    * `infisical.project.id` (string, optional): Project ID
    * `infisical.project.name` (string, optional): Project name
    * `client.address` (string, optional): IP address
    * `user_agent.original` (string, optional): User agent information
  </Accordion>
</AccordionGroup>

### Secret Operations Metrics

These metrics provide visibility into secret access patterns, helping you understand which secrets are being accessed, by whom, and from where. Essential for security auditing and access pattern analysis.

<AccordionGroup>
  <Accordion title="Secret Read Operations">
    **Metric Name**: `infisical.secret.read.count`

    **Type**: Counter

    **Unit**: `{operation}`

    **Description**: Number of secret read operations

    **Attributes**:

    * `infisical.organization.id` (string): Organization ID
    * `infisical.organization.name` (string): Organization name
    * `infisical.project.id` (string): Project ID
    * `infisical.project.name` (string): Project name (e.g., "payment-service-secrets")
    * `infisical.environment` (string): Environment (dev, staging, prod)
    * `infisical.secret.path` (string): Path to secrets (e.g., "/microservice-a/database")
    * `infisical.secret.name` (string, optional): Name of secret
    * `infisical.user.id` (string, optional): User ID if human
    * `infisical.user.email` (string, optional): User email
    * `infisical.identity.id` (string, optional): Machine identity ID
    * `infisical.identity.name` (string, optional): Machine identity name
    * `user_agent.original` (string, optional): User agent/SDK information
    * `client.address` (string, optional): IP address
  </Accordion>
</AccordionGroup>

### Authentication Metrics

These metrics track authentication attempts and outcomes, enabling you to monitor login success rates, detect potential security threats, and identify authentication issues.

<AccordionGroup>
  <Accordion title="Login Attempts">
    **Metric Name**: `infisical.auth.attempt.count`

    **Type**: Counter

    **Unit**: `{attempt}`

    **Description**: Authentication attempts (both successful and failed)

    **Attributes**:

    * `infisical.organization.id` (string): Organization ID
    * `infisical.organization.name` (string): Organization name
    * `infisical.user.id` (string, optional): User ID if human (if identifiable)
    * `infisical.user.email` (string, optional): User email (if identifiable)
    * `infisical.identity.id` (string, optional): Identity ID if machine (if identifiable)
    * `infisical.identity.name` (string, optional): Identity name (if identifiable)
    * `infisical.auth.method` (string): Authentication method attempted
    * `infisical.auth.result` (string): success or failure
    * `error.type` (string, optional): Reason for failure if failed (invalid\_credentials, expired\_token, invalid\_token, etc.)
    * `client.address` (string): IP address
    * `user_agent.original` (string, optional): User agent/client information
    * `infisical.auth.attempt.username` (string, optional): Attempted username/email (if available)
  </Accordion>
</AccordionGroup>

### Integration & Secret Sync Metrics

These metrics monitor secret synchronization operations between Infisical and external systems, helping you track sync health, identify integration failures, and troubleshoot connectivity issues.

<AccordionGroup>
  <Accordion title="integration_secret_sync_errors">
    Integration secret sync error count

    * **Labels**: `version`, `integration`, `integrationId`, `type`, `status`, `name`, `projectId`
    * **Example**: Monitor integration sync failures across different services
  </Accordion>

  <Accordion title="secret_sync_sync_secrets_errors">
    Secret sync operation error count

    * **Labels**: `version`, `destination`, `syncId`, `projectId`, `type`, `status`, `name`
    * **Example**: Track secret sync failures to external systems
  </Accordion>

  <Accordion title="secret_sync_import_secrets_errors">
    Secret import operation error count

    * **Labels**: `version`, `destination`, `syncId`, `projectId`, `type`, `status`, `name`
    * **Example**: Monitor secret import failures
  </Accordion>

  <Accordion title="secret_sync_remove_secrets_errors">
    Secret removal operation error count

    * **Labels**: `version`, `destination`, `syncId`, `projectId`, `type`, `status`, `name`
    * **Example**: Track secret removal operation failures
  </Accordion>
</AccordionGroup>

### System Metrics

These low-level HTTP metrics are automatically collected by OpenTelemetry's instrumentation layer, providing baseline performance data for all HTTP traffic.

<AccordionGroup>
  <Accordion title="http_server_duration">
    HTTP server request duration metrics (histogram buckets, count, sum)
  </Accordion>

  <Accordion title="http_client_duration">
    HTTP client request duration metrics (histogram buckets, count, sum)
  </Accordion>
</AccordionGroup>

## Troubleshooting

<Accordion title="Metrics not appearing">
  If your metrics are not showing up in Prometheus or your monitoring system, check the following:

  * Verify `OTEL_TELEMETRY_COLLECTION_ENABLED=true` is set in your Infisical environment variables
  * Ensure the correct `OTEL_EXPORT_TYPE` is set (`prometheus` or `otlp`)
  * Check network connectivity between Infisical and your monitoring services (Prometheus or OTLP collector)
  * For pull-based monitoring: Verify port 9464 is exposed and accessible
  * For push-based monitoring: Verify the OTLP endpoint URL is correct and reachable
  * Check Infisical backend logs for any errors related to metrics export
</Accordion>

<Accordion title="Authentication errors">
  If you're experiencing authentication errors with the OpenTelemetry Collector:

  * Verify basic auth credentials in your OTLP configuration match between Infisical and the collector
  * Check that `OTEL_COLLECTOR_BASIC_AUTH_USERNAME` and `OTEL_COLLECTOR_BASIC_AUTH_PASSWORD` match the credentials in your `otel-collector-config.yaml`
  * Ensure the htpasswd format in the collector configuration is correct
  * Test the collector endpoint manually using curl with the same credentials to verify they work
</Accordion>


# Production Hardening
Source: https://infisical.com/docs/self-hosting/guides/production-hardening

Security hardening recommendations for production Infisical deployments

This document provides specific security hardening recommendations for production Infisical deployments. These recommendations follow Infisical's security model and focus on defense in depth.

Choose your deployment method below and follow the recommendations for your specific setup. Start with **Universal Security Fundamentals** that apply to all deployments, then follow your deployment-specific section.

## Universal Security Fundamentals

These security configurations apply to **all** Infisical deployments regardless of how you deploy.

### Cryptographic Security

#### Generate Secure Keys

Generate strong cryptographic keys for your deployment:

```bash  theme={"dark"}
# Required - Generate secure encryption key
ENCRYPTION_KEY=$(openssl rand -hex 16)

# Required - Generate secure auth secret
AUTH_SECRET=$(openssl rand -base64 32)
```

#### Configure Token Lifetimes

Minimize exposure window for compromised tokens:

```bash  theme={"dark"}
# JWT token configuration (adjust based on security requirements)
JWT_AUTH_LIFETIME=15m        # Authentication tokens
JWT_REFRESH_LIFETIME=24h     # Refresh tokens
JWT_SERVICE_LIFETIME=1h      # Service tokens
```

### Network Security

#### TLS Configuration

Configure HTTPS and secure database connections:

```bash  theme={"dark"}
# Enable HTTPS (recommended for production)
HTTPS_ENABLED=true

# Secure PostgreSQL connection with SSL
DB_CONNECTION_URI="postgresql://user:pass@host:5432/db?sslmode=require"

# For base64-encoded SSL certificate
DB_ROOT_CERT="<base64-encoded-certificate>"
```

#### Redis Security

Use authentication and TLS for Redis:

```bash  theme={"dark"}
# Redis with TLS (if supported by your Redis deployment)
REDIS_URL="rediss://user:password@redis:6380"

# Redis Sentinel configuration for high availability
REDIS_SENTINEL_HOSTS="192.168.65.254:26379,192.168.65.254:26380"
REDIS_SENTINEL_MASTER_NAME="mymaster"
REDIS_SENTINEL_ENABLE_TLS=true
REDIS_SENTINEL_USERNAME="sentinel_user"
REDIS_SENTINEL_PASSWORD="sentinel_password"
```

#### Network Access Controls

Configure network restrictions and firewall rules:

```bash  theme={"dark"}
# Limit CORS to specific domains
CORS_ALLOWED_ORIGINS=["https://your-app.example.com"]

# Prevent connections to internal/private IP addresses
# This blocks access to internal services like metadata endpoints,
# internal APIs, databases, and other sensitive infrastructure
ALLOW_INTERNAL_IP_CONNECTIONS=false
```

**Implement network firewalls**. Restrict network access to only necessary services:

* **Required ports**: Infisical API (8080) and HTTPS (if applicable)
* **Database access**: Restrict PostgreSQL and Redis to authorized sources only
* **Principle**: Default deny incoming, allow only required traffic
* **Implementation**: See your deployment-specific section below for exact configuration

### Application Security

#### Site Configuration

Set proper site URL for your Infisical instance:

```bash  theme={"dark"}
# Required - Must be absolute URL with protocol
SITE_URL="https://app.infisical.com"
```

#### SMTP Security

Use TLS for email communications:

```bash  theme={"dark"}
# SMTP with TLS
SMTP_HOST="smtp.example.com"
SMTP_PORT="587"
SMTP_USERNAME="your-smtp-user"
SMTP_PASSWORD="your-smtp-password"
SMTP_REQUIRE_TLS=true
SMTP_IGNORE_TLS=false
SMTP_FROM_ADDRESS="noreply@example.com"
SMTP_FROM_NAME="Infisical"
```

#### Privacy Configuration

Control telemetry and data collection:

```bash  theme={"dark"}
# Optional - Disable telemetry (enabled by default)
TELEMETRY_ENABLED=false
```

### Database Security

#### High Availability Configuration

Configure database read replicas for high availability PostgreSQL setups:

```bash  theme={"dark"}
# Read replica configuration (JSON format)
DB_READ_REPLICAS='[{"DB_CONNECTION_URI":"postgresql://user:pass@replica:5432/db?sslmode=require"}]'
```

### Operational Security

#### User Access Management

**Establish user off-boarding procedures**. Remove access promptly when users leave:

1. Remove user from organization
2. Revoke active service tokens
3. Remove from external identity providers
4. Audit access logs for the user's activity
5. Rotate any shared secrets the user had access to

#### Maintenance and Updates

**Keep frequent upgrade cadence**. Regularly update to the latest Infisical version for your deployment method.

## Deployment-Specific Hardening

### Docker Deployment

These recommendations are specific to Docker deployments of Infisical.

#### Container Security

**Use read-only root filesystems**. Prevent runtime modifications while allowing necessary temporary access:

```bash  theme={"dark"}
# Run with read-only filesystem but allow /tmp access
docker run --read-only \
  --tmpfs /tmp:rw,exec,size=1G \
  infisical/infisical:latest
```

**Note**: Infisical requires temporary directory access for:

* Secret scanning operations
* SSH certificate generation and validation

The `--tmpfs` mounts provide secure, isolated temporary storage that is:

* Automatically cleaned up on container restart
* Limited in size to prevent disk exhaustion
* Isolated from the host system
* Wiped on container removal

**Drop unnecessary capabilities**. Remove all Linux capabilities:

```bash  theme={"dark"}
# Drop all capabilities
docker run --cap-drop=ALL infisical/infisical:latest
```

**Use specific image tags**. Never use `latest` tags in production:

```bash  theme={"dark"}
# Use specific version tags
docker run infisical/infisical:v0.93.1-postgres
```

#### Resource Management

**Set resource limits**. Prevent resource exhaustion attacks:

```bash  theme={"dark"}
# Set memory and CPU limits
docker run --memory=1g --cpus=0.5 infisical/infisical:latest
```

#### Health Monitoring

**Configure health checks**. Set up Docker health checks:

```dockerfile  theme={"dark"}
# In Dockerfile or docker-compose.yml
HEALTHCHECK --interval=30s --timeout=3s --start-period=10s --retries=3 \
  CMD curl -f http://localhost:8080/api/status || exit 1
```

#### Network Security

**Host firewall configuration**. Configure host-level firewall for Docker deployments:

```bash  theme={"dark"}
# Docker manages its own iptables rules, but configure host firewall
sudo ufw default deny incoming
sudo ufw default allow outgoing

# Allow Docker-mapped ports (adjust based on your port mapping)
sudo ufw allow 8080/tcp  # If mapping container 8080 to host 8080
sudo ufw allow 443/tcp   # If terminating HTTPS at host level

# Enable firewall
sudo ufw --force enable

# Verify Docker iptables integration
sudo iptables -L DOCKER
```

#### Maintenance

**Regular updates**. Monitor [Docker Hub](https://hub.docker.com/r/infisical/infisical/tags) for new releases and update your image tags regularly.

### Kubernetes Deployment

These recommendations are specific to Kubernetes deployments of Infisical.

#### Pod Security

**Use Pod Security Standards**. Apply restricted security profile:

```yaml  theme={"dark"}
# Namespace-level Pod Security Standards
apiVersion: v1
kind: Namespace
metadata:
  name: infisical
  labels:
    pod-security.kubernetes.io/enforce: restricted
    pod-security.kubernetes.io/audit: restricted
    pod-security.kubernetes.io/warn: restricted
```

**Configure security context**. Set comprehensive security context:

```yaml  theme={"dark"}
# Deployment security context
apiVersion: apps/v1
kind: Deployment
metadata:
  name: infisical
spec:
  template:
    spec:
      securityContext:
        runAsNonRoot: true
        runAsUser: 1001
        fsGroup: 1001
      containers:
        - name: infisical
          image: infisical/infisical:v0.93.1-postgres
          securityContext:
            readOnlyRootFilesystem: true
            allowPrivilegeEscalation: false
            runAsNonRoot: true
            runAsUser: 1001
            capabilities:
              drop:
                - ALL
          resources:
            limits:
              memory: 1000Mi
              cpu: 500m
            requests:
              cpu: 350m
              memory: 512Mi
```

#### Network Security

**Configure network policies**. Restrict pod-to-pod communication:

```yaml  theme={"dark"}
# Example Kubernetes NetworkPolicy
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: infisical-netpol
  namespace: infisical
spec:
  podSelector:
    matchLabels:
      app: infisical
  policyTypes:
    - Ingress
    - Egress
  ingress:
    - from:
        - namespaceSelector:
            matchLabels:
              name: ingress-system
      ports:
        - protocol: TCP
          port: 8080
  egress:
    - to:
        - podSelector:
            matchLabels:
              app: postgres
      ports:
        - protocol: TCP
          port: 5432
    - to:
        - podSelector:
            matchLabels:
              app: redis
      ports:
        - protocol: TCP
          port: 6379
```

**Infrastructure firewall considerations**. In addition to the universal host firewalls, implement infrastructure-level security:

For cloud deployments (AWS Security Groups, Azure NSGs, or GCP Firewall Rules):

* Allow ingress from load balancer to NodePort/ClusterIP service
* Allow egress to managed databases
* Block all other traffic

For on-premises deployments, ensure node-level firewalls allow:

* Ingress traffic from ingress controllers
* Egress traffic to external services (databases, SMTP)

#### Access Control

**Use dedicated service accounts**. Create service accounts with minimal permissions:

```yaml  theme={"dark"}
# Service account configuration
apiVersion: v1
kind: ServiceAccount
metadata:
  name: infisical
  namespace: infisical
automountServiceAccountToken: false
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: infisical
spec:
  template:
    spec:
      serviceAccountName: infisical
```

#### Ingress Security

**Configure ingress with TLS**. Set up secure ingress:

```yaml  theme={"dark"}
# Secure ingress configuration
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: infisical-ingress
  namespace: infisical
  annotations:
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
    nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
spec:
  ingressClassName: nginx
  tls:
    - secretName: infisical-tls
      hosts:
        - app.example.com
  rules:
    - host: app.example.com
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: infisical
                port:
                  number: 8080
```

#### Secret Management

**Use Kubernetes secrets**. Store sensitive configuration securely:

```yaml  theme={"dark"}
# Kubernetes secret for environment variables
apiVersion: v1
kind: Secret
metadata:
  name: infisical-secrets
  namespace: infisical
type: Opaque
stringData:
  AUTH_SECRET: "<generate-with-openssl-rand-base64-32>"
  ENCRYPTION_KEY: "<generate-with-openssl-rand-hex-16>"
  DB_CONNECTION_URI: "<your-postgres-connection-string>"
  REDIS_URL: "<your-redis-connection-string>"
  SITE_URL: "<your-site-url>"
```

**Note:** Kubernetes secrets are only base64-encoded by default and are not encrypted at rest unless you explicitly enable etcd encryption. For production environments, you should:

* Enable [etcd encryption at rest](https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/) to protect secrets stored in the cluster
* Limit access to etcd and Kubernetes API to only trusted administrators

#### Health Monitoring

**Set up health checks**. Configure readiness and liveness probes:

```yaml  theme={"dark"}
# Health check configuration
containers:
  - name: infisical
    readinessProbe:
      httpGet:
        path: /api/status
        port: 8080
      initialDelaySeconds: 10
      periodSeconds: 5
    livenessProbe:
      httpGet:
        path: /api/status
        port: 8080
      initialDelaySeconds: 30
      periodSeconds: 10
```

#### Infrastructure Considerations

**Use managed databases (if possible)**. For production deployments, consider using managed PostgreSQL and Redis services instead of in-cluster instances when feasible, as they typically provide better security, backup, and maintenance capabilities.

#### Maintenance

**Regular updates**. Monitor [Docker Hub](https://hub.docker.com/r/infisical/infisical/tags) for new releases and update your deployment manifests with new image tags regularly.

### Linux Binary Deployment

These recommendations are specific to Linux binary deployments of Infisical.

#### System User Management

**Create dedicated user account**. Run Infisical under a dedicated service account:

```bash  theme={"dark"}
# Create dedicated user
sudo useradd --system --shell /bin/false --home-dir /opt/infisical infisical

# Create application directory
sudo mkdir -p /opt/infisical
sudo chown infisical:infisical /opt/infisical
```

#### Service Configuration

**Configure systemd service**. Create a secure systemd service:

```ini  theme={"dark"}
# /etc/systemd/system/infisical.service
[Unit]
Description=Infisical Secret Management
After=network.target

[Service]
Type=simple
# IMPORTANT: Change from default 'root' user to dedicated service account
User=infisical
Group=infisical
WorkingDirectory=/opt/infisical
ExecStart=/opt/infisical/infisical-linux-amd64
Restart=always
RestartSec=10

# Security settings
NoNewPrivileges=true
ProtectSystem=strict
ProtectHome=true
ReadWritePaths=/opt/infisical
PrivateTmp=true
ProtectKernelTunables=true
ProtectKernelModules=true
ProtectControlGroups=true
RestrictSUIDSGID=true
LimitCORE=0
MemorySwapMax=0

# Environment file
EnvironmentFile=/etc/infisical/environment

[Install]
WantedBy=multi-user.target
```

#### Configuration Security

**Secure environment configuration**. Store environment variables securely:

```bash  theme={"dark"}
# Create secure config directory
sudo mkdir -p /etc/infisical
sudo chmod 750 /etc/infisical
sudo chown root:infisical /etc/infisical

# Create environment file
sudo touch /etc/infisical/environment
sudo chmod 640 /etc/infisical/environment
sudo chown root:infisical /etc/infisical/environment
```

#### System Security

**Disable memory swapping**. Prevent sensitive data from being written to disk:

```bash  theme={"dark"}
# Disable swap immediately
sudo swapoff -a

# Disable swap permanently (comment out swap entries)
sudo sed -i '/swap/d' /etc/fstab
```

**Disable core dumps**. Prevent potential exposure of encryption keys:

```bash  theme={"dark"}
# Set system-wide core dump limits
echo "* hard core 0" | sudo tee -a /etc/security/limits.conf

# Disable core dumps for current session
ulimit -c 0
```

#### File Permissions

**Secure file permissions**. Set proper permissions on application files:

```bash  theme={"dark"}
# Set binary permissions
sudo chmod 755 /opt/infisical/infisical-linux-amd64
sudo chown infisical:infisical /opt/infisical/infisical-linux-amd64

# Set config file permissions
sudo chmod 640 /etc/infisical/environment
sudo chown root:infisical /etc/infisical/environment
```

#### Network Security

**Host firewall configuration**. Configure comprehensive firewall for Linux binary deployments:

```bash  theme={"dark"}
# Configure UFW firewall
sudo ufw default deny incoming
sudo ufw default allow outgoing

# Allow Infisical API access
sudo ufw allow 8080/tcp

# Allow HTTPS (if terminating TLS at Infisical)
sudo ufw allow 443/tcp

# If running PostgreSQL locally, restrict to localhost
sudo ufw allow from 127.0.0.1 to any port 5432

# If running Redis locally, restrict to localhost
sudo ufw allow from 127.0.0.1 to any port 6379

# Enable firewall
sudo ufw --force enable
```

#### System Maintenance

**Synchronize system clocks**. Ensure accurate time for JWT tokens and audit logs:

```bash  theme={"dark"}
# Install and configure NTP
sudo apt-get update
sudo apt-get install -y ntp
sudo systemctl enable ntp
sudo systemctl start ntp

# Verify time synchronization
timedatectl status
```

**Regular updates**. Monitor [Cloudsmith releases](https://cloudsmith.io/~infisical/repos/infisical-core/packages) for new binary versions and update your installation regularly.

## Enterprise Security Features

### Hardware Security Module (HSM) Integration

For the highest level of encryption security, integrate with Hardware Security Modules:

HSM integration provides hardware-protected encryption keys stored on tamper-proof devices, offering superior security for encryption operations:

* **Supported HSM Providers**: Thales Luna Cloud HSM, AWS CloudHSM, Fortanix HSM
* **Root Key Protection**: HSM encrypts Infisical's root encryption keys using hardware-protected keys
* **Enterprise Requirements**: Ideal for government, financial, and healthcare organizations

```bash  theme={"dark"}
# HSM Environment Variables (example for production)
HSM_LIB_PATH="/path/to/hsm/library.so"
HSM_PIN="your-hsm-pin"
HSM_SLOT="0"
HSM_KEY_LABEL="infisical-root-key"
```

For complete HSM setup instructions, see the [HSM Integration Guide](/documentation/platform/kms/hsm-integration).

### External Key Management Service (KMS) Integration

Leverage cloud-native KMS providers for enhanced security and compliance:

Infisical can integrate with external KMS providers to encrypt project secrets, providing enterprise-grade key management:

* **Supported Providers**: AWS KMS, Google Cloud KMS, Azure Key Vault (coming soon)
* **Workspace Key Protection**: Each project's encryption key is protected by your external KMS
* **Envelope Encryption**: Infisical uses your cloud KMS to encrypt/decrypt project workspace keys, which in turn encrypt the actual secret data
* **Compliance**: Leverage your cloud provider's compliance certifications (FedRAMP, SOC2, ISO 27001)

#### Benefits for Production Deployments

* **Separation of Concerns**: Keys managed in your cloud infrastructure, separate from Infisical
* **Regulatory Compliance**: Use your existing compliance-certified KMS infrastructure
* **Audit Integration**: KMS operations logged in your cloud provider's audit trails
* **Disaster Recovery**: Keys backed by your cloud provider's HA and backup systems
* **Access Controls**: Leverage your cloud IAM for KMS access management

#### Configuration Resources

For external KMS configuration, see:

* [AWS KMS Integration](/documentation/platform/kms-configuration/aws-kms)
* [GCP KMS Integration](/documentation/platform/kms-configuration/gcp-kms)
* [External KMS Overview](/documentation/platform/kms-configuration/overview)

## Advanced Security Configurations

### Backup Security

**Configure backup encryption**. Encrypt PostgreSQL backups:

```bash  theme={"dark"}
# PostgreSQL backup with encryption
pg_dump $DB_CONNECTION_URI | gpg --cipher-algo AES256 --compress-algo 1 --symmetric --output backup.sql.gpg
```

### Monitoring and Logging

**Implement log monitoring**. Set up centralized logging for security analysis and audit trails. Configure your SIEM or logging platform to monitor Infisical operations.

### Security Updates

**Regular security updates**. Monitor the [Infisical repository](https://github.com/Infisical/infisical) for security updates and apply them promptly.

## Compliance and Monitoring

### Enterprise Compliance Requirements

For enterprise deployments requiring compliance certifications:

* Implement audit log retention policies
* Set up security event monitoring and alerting
* Configure automated vulnerability scanning
* Establish incident response procedures
* Document security controls for compliance audits

### Standards Compliance

#### FIPS 140-3 Compliance

Infisical is compliant with FIPS 140-3, meeting U.S. and Canadian government cryptographic standards through validated cryptographic modules.
This certification is designed for organizations that require government-approved encryption implementations.
To deploy a FIPS-compliant instance, use the [infisical/infisical-fips](https://hub.docker.com/r/infisical/infisical-fips) Docker image, available to Enterprise customers.
Our FIPS 140-3 attestation letter is available in the [Infisical Trust Center](https://trust.infisical.com/).

#### SOC 2 Compliance

Infisical is SOC 2 compliant, demonstrating adherence to rigorous security, availability, and confidentiality standards established by the American Institute of CPAs (AICPA).
This certification validates our security controls and operational practices for organizations requiring third-party audited security assurance. Our SOC 2 report is available in the [Infisical Trust Center](https://trust.infisical.com/).

#### HIPAA Compliance

Infisical is HIPAA compliant, meeting the security and privacy requirements of the Health Insurance Portability and Accountability Act.
This compliance framework ensures appropriate safeguards for protected health information (PHI) for healthcare organizations and their business associates.
Our HIPAA certification is available in the [Infisical Trust Center](https://trust.infisical.com/).


# Release Channels
Source: https://infisical.com/docs/self-hosting/guides/releases

Learn how to configure your deployment for different release schedules.

Infisical uses rolling release channels to deliver new features, security fixes, and improvements with different update frequencies.
This system allows you to balance getting the latest features with maintaining stability in your deployment environment.

## What are release channels?

Release channels define different schedules under which Infisical makes new releases available for you to deploy.
Each channel operates on its own cadence, allowing you to choose how frequently you want to update your self-hosted deployment while balancing access to the latest features with your organization's stability requirements.

## Available Channels

Infisical provides two distinct release channels with different update frequencies and stability profiles.

<Tabs>
  <Tab title="Nightly Channel">
    * **Update Frequency**: Daily builds during weekdays (Monday-Friday)
    * **Versioning Strategy**: Nightly releases provide daily patches and features while making its way towards the next stable release
    * **Version Format**: `vX.Y.0-nightly-YYYYMMDD` where X.Y represents the next minor version increment from the latest stable release
    * **Multiple Daily Builds**: If multiple nightly builds are created on the same day, they are numbered incrementally: `vX.Y.0-nightly-YYYYMMDD.1`, `vX.Y.0-nightly-YYYYMMDD.2`, etc.
    * **Stability**: Latest features with standard CI/CD testing
    * **Release Process**: Built from main branch after all automated tests pass
    * **Intended Audience**: Development environments & early adopters

    **Best for:**

    * Organizations with flexible change management
    * Teams that want to test new features before they are made available via stable release channel

    **Characteristics:**

    * Access to latest features immediately
    * Pre-release versions of upcoming stable releases
    * Faster security patch delivery
    * Higher update frequency (daily)
  </Tab>

  <Tab title="Stable Channel">
    * **Update Frequency**: Monthly releases (typically 1st Tuesday of each month)
    * **Version Tags**: `vX.Y.Z` (e.g., `v0.145.0`, `v0.146.0`)
    * **Stability**: Both code tested and production-proven releases
    * **Release Process**: Features validated through nightly channel for 30+ days
    * **Intended Audience**: Production environments, enterprise teams prioritizing stability

    **Best for:**

    * Enterprise environments with limited change windows
    * Organizations requiring predictable release cycles
    * Teams prioritizing stability and long-term support

    **Characteristics:**

    * Predictable monthly schedule
    * Extensive testing and validation
    * Production-proven features
  </Tab>
</Tabs>

<Warning>
  Schedule Note: Target dates are approximate and subject to change based on critical issues, security updates, or maintenance requirements.
</Warning>

## Staying up to date

Track what features are available in each version across different sources:

* **Released versions**: View detailed changelogs, new features, and breaking changes in our [GitHub Releases](https://github.com/Infisical/infisical/releases)
* **Docker Image Versions**: Browse available container images and tags on [Docker Hub](https://hub.docker.com/r/infisical/infisical)
* **Linux Package Releases**: Access downloadable packages and version history on our [Linux releases page](https://cloudsmith.io/~infisical/repos/infisical-core/packages/)


# Replication
Source: https://infisical.com/docs/self-hosting/guides/replication

Learn how Infisical supports multi-region replication

<Info>
  Infisical replication is a paid feature.

  If you're using Infisical Cloud, then it is available under the **Enterprise Tier**. If you're self-hosting Infisical,
  then you should contact [team@infisical.com](mailto:team@infisical.com) to purchase an enterprise license to use it.
</Info>

Multi-region replication is available in Infisical Enterprise to support globally distributed deployments. Understanding the architecture, use cases, and operational considerations is essential before implementing this feature in production environments.

Infisical uses a primary/secondary (1:N) architecture with asynchronous PostgreSQL replication. This design prioritizes high availability and minimal read latency for applications deployed across multiple geographic regions.

## Use cases

* **Multi-Region Deployments**: Serving secrets to applications distributed across continents from a single region introduces unacceptable latency. A centralized deployment also creates a single point of failure: regional outages can render secrets inaccessible globally, and network connectivity issues impact availability.

* **Geographic Data Locality**: Global organizations need to minimize the time it takes for applications to retrieve secrets and configurations. Regional replicas enable applications to fetch data from nearby instances rather than making cross-continental requests.

* **Disaster Recovery**: Organizations need resilience against primary region failures. Secondary regions with read replicas can be promoted to primary status when needed, maintaining operations during outages or disasters.

## Design Goals

In order to address the common use cases, the implementation reflects several core goals:

* **Optimized Read Performance**: Applications need fast access to secrets regardless of their location. Regional instances use Redis for aggressive caching and read from local PostgreSQL replicas, eliminating cross-region round trips for most read operations.

* **Conflict-Free Architecture**: All mutations flow through the primary instance exclusively. This prevents write conflicts and split-brain scenarios that plague multi-master systems. The trade-off ensures data integrity without requiring conflict resolution strategies.

* **Zero Client Changes**: Existing Infisical integrations, SDKs, and CLI tools work without modification. Regional instances route write operations to the primary while handling reads locally. Authentication tokens and API keys function identically across all instances.

* **Operational Simplicity**: Deploying additional regions requires minimal configuration. PostgreSQL handles replication complexity, and the stateless application tier scales horizontally without coordination overhead.

# Architecture

Infisical distinguishes between *primary* and *secondary* instances. The primary holds write authority and is the sole instance permitted to modify the PostgreSQL database. Secondary instances handle read traffic locally and proxy write operations to the primary.

## Infrastructure components

Two data stores form Infisical's persistence layer:

* **PostgreSQL** maintains the authoritative dataset including secrets with their version history, authentication credentials, user identities, project configurations, access policies, audit trails, and integration settings. All persistent state lives in PostgreSQL.

* **Redis** accelerates read operations through caching and manages asynchronous job queues. Each regional deployment maintains an independent Redis instance optimized for local access patterns.

The Infisical application servers are stateless and therefore hold no persistent data internally. This design simplifies regional deployment and horizontal scaling.

<Tabs>
  <Tab title="Primary region configuration">
    A primary deployment consists of three core components:

    * **Application Servers**: Process all API requests directly, handling both read and write operations without forwarding
    * **PostgreSQL Primary Database**: Accepts read and write queries, serving as the authoritative source of truth
    * **Redis Cache**: Stores frequently accessed data and executes all background jobs including secret synchronization, scheduled tasks, and audit log processing
  </Tab>

  <Tab title="Secondary region configuration">
    Each secondary deployment mirrors the primary structure with key differences:

    * **Application Servers**: Service read requests from local infrastructure but forward any write requests to the primary region
    * **PostgreSQL Read Replica**: Continuously streams changes from the primary database via PostgreSQL replication
    * **PostgreSQL Primary Database**: Connection string to the primary database for write forwarding
    * **Redis Cache**: Maintains a local cache but processes only audit logs (other background jobs remain disabled)

    Configuring a secondary region requires four main environment variables:

    1. `INFISICAL_PRIMARY_INSTANCE_URL`: The primary region's Infisical API endpoint
    2. Postgres primary instance connection details. View related [environment variables](/self-hosting/configuration/envars#postgresql).
    3. Postgres read replica connection details. View related [environment variables](/self-hosting/configuration/envars#postgresql).
    4. Redis connection details. View related [environment variables](/self-hosting/configuration/envars#redis).
  </Tab>
</Tabs>

## How requests are processed

When a client sends a read request to a secondary instance, the application first checks the local Redis cache for the requested data. If the data exists in cache, it's returned immediately to the client. Otherwise, the application queries the local PostgreSQL read replica, caches the result in Redis for future requests, and returns the response to the client.

Write operations follow a different path. When a secondary receives a write request, it forwards the complete request to the primary instance URL. The primary processes the mutation against the authoritative database and returns a response, which the secondary then forwards back to the client. PostgreSQL subsequently streams these changes to all replicas asynchronously.

Operations against the primary instance are more straightforward, as both reads and writes execute directly against local infrastructure without any forwarding.

## Replication mechanism

PostgreSQL streaming replication handles all data synchronization. When transactions commit on the primary, changes are written to the write-ahead log (WAL) and streamed to all configured replicas, which apply the entries to maintain consistency. Replication lag typically remains under one second.

This approach replicates all data stored in PostgreSQL: secrets and their version histories, user accounts and permissions, authentication tokens, project configurations, access policies, audit logs, integration settings, and all other application metadata. Replicas are eventually consistent. This means that all replicas eventually converge to the same state, typically under 1 second. The application layer remains unaware of replication mechanics and operates identically across all instances.

## Caching behavior

Redis caches are regional and independent (no coordination occurs between instances):

* Secondary instances populate caches on demand from read requests
* Cache hits serve data without touching PostgreSQL
* Cache misses fetch from the local replica and populate the cache
* Each region maintains its own hot dataset based on local access patterns

Secrets use versioned caching. When a secret changes, its version identifier changes, causing automatic cache misses. This ensures subsequent reads fetch the updated value from PostgreSQL without requiring active cache invalidation.

# Technical Details

Understanding the implementation details can help evaluate whether Infisical's replication characteristics align with your requirements.
The following sections provide deeper insight into performance behavior, failure modes, and the underlying mechanisms that drive the replication system.

### PostgreSQL streaming replication

Infisical relies on PostgreSQL's native replication, which provides:

* **Asynchronous operation**: The primary commits transactions immediately without waiting for replicas to confirm receipt. Replicas receive and apply changes continuously with typical lag measured in milliseconds to low seconds, depending on network conditions and write volume.

* **Binary-level consistency**: Replication occurs at the storage layer using write-ahead logs, guaranteeing replicas are byte-for-byte identical to the primary at the block level.

* **Promotion capability**: Read replicas can be promoted to primary during disaster recovery. Promotion requires updating Infisical configuration to designate the promoted instance as primary and reconfiguring other secondaries.

Consult PostgreSQL's official documentation for replication setup instructions specific to your hosting environment (RDS, Cloud SQL, self-managed, etc.).

### Version management

All Infisical instances must run identical versions (mixing versions risks database schema mismatches or incompatible API behavior). Database migrations execute only on the primary and replicate to secondaries through standard PostgreSQL mechanisms.

During upgrades:

1. Upgrade the primary instance (migrations run automatically)
2. Upgrade secondary instances to match
3. All instances can continue running during the upgrade process since database migrations don't immediately drop tables/columns

### Request proxying

When a secondary receives a mutation request (POST, PUT, PATCH, DELETE), it functions as a transparent proxy:

1. Preserve the original request completely (headers, authentication context, request body)
2. Forward to the primary instance URL specified in configuration
3. Primary processes the request as a direct client request
4. Return the primary's response unmodified to the client

### Cache management

Infisical uses versioned caching rather than active invalidation:

1. Secrets and other cached entities include version identifiers
2. When data mutates, its version changes in the database
3. Cache lookups include the version in the cache key
4. Version changes cause automatic cache misses
5. Cache misses fetch updated data from PostgreSQL
6. Fresh data populates the cache with the new version

This strategy ensures correctness without requiring cross-region cache invalidation protocols.

### Background job processing

Secondary instances run with restricted background job capabilities:

**Active**: Audit log processing\
**Disabled**: Secret synchronization to third-party systems, scheduled tasks, cron jobs, time-triggered operations

Limiting background jobs to the primary prevents duplicate processing and ensures integrations execute once.


# Upgrade Infisical Instance
Source: https://infisical.com/docs/self-hosting/guides/upgrading-infisical

How to upgrade Infisical self-hosted instance

Keeping your Infisical instance up to date is key to making sure you receive the latest performance improvements, security patches, and feature updates.
We release updates approximately once a week, which may include new features, bug fixes, performance enhancements, and critical security patches.

Since secrets management is a critical component of your infrastructure, we aim to avoid disruptive changes that will impact fetching secrets in downstream clients.
If a release requires specific attention, a note will be attached to the corresponding [release](https://github.com/Infisical/infisical/releases) version.

During an upgrade, two key components are updated:

* **Infisical Application:** The core application code is updated.
* **PostgreSQL Database Schema:** Schema migrations run automatically to ensure your database remains in sync with the updated application.

> **Before You Upgrade:**\
> **Always back up your database.** While our automated migration system is robust, having a backup ensures you can recover quickly in the event of an issue.

## Automated Schema Migrations

In previous versions (prior to `v0.111.0-postgres`), schema migrations had to be executed manually before starting the application.
Now, migrations run automatically during boot-up. This improvement streamlines the upgrade process, reduces manual steps, and minimizes the risk of inconsistencies between your database schema and application code.

### Benefits of Automated Migrations

* **Seamless Integration:**\
  Migrations are now part of the boot-up process, removing the need for manual intervention.

* **Synchronous Upgrades:**\
  In multi-instance deployments, one instance acquires a lock and performs the migration while the others wait. This ensures that if a migration fails, the rollout is halted to prevent inconsistencies.

* **Reduced Room for Error:**\
  Automatic migrations help ensure that your database schema always remains in sync with your application code.

## Upgrade Steps

1. **Back Up Your Data:**
   * Ensure you have a complete backup of your Postgres database.
   * Verify that your backup is current and accessible.

2. **Plan Your Upgrade Path:**
   * Use our [Upgrade Path Tool](https://app.infisical.com/upgrade-path) to analyze your upgrade path between your current version and target version.
   * The tool will show you:
     * **Breaking changes** that require action before upgrading
     * **Database migrations** that may require additional settings or precautions
     * **Step-by-step upgrade path** with intermediate versions if needed
   * Review any breaking changes and plan necessary configuration updates before proceeding.
   * Visit the [Infisical releases page](https://github.com/Infisical/infisical/releases) for a complete list of available versions.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/self-hosting/helper/upgrade-path-tool.png" alt="Upgrade Path Tool showing breaking changes and migration information" />

3. **Start the Upgrade Process:**
   * Launch the new version of Infisical. During startup, the application will automatically compare the current database schema with the updated schema in the code.
   * If any differences are detected, Infisical will apply the necessary migrations automatically.

4. **Multi-Instance Coordination:**
   * In environments with multiple instances, one instance will acquire a lock and perform the migration while the other instances wait.
   * Once the migration is complete, all instances will operate with the updated schema.

5. **Verify the Upgrade:**
   * Review the logs for any migration errors or warnings.
   * Test basic functionality to ensure the upgrade was successful.

## Troubleshooting

### UI Caching Issues After Upgrade

After upgrading your Infisical instance, you may encounter UI-related issues such as:

* Strange loading behavior
* Components not rendering correctly
* Unexpected errors in the browser console
* Features appearing broken or unresponsive

These issues are often caused by browser caching of the previous version's static assets.

**Solution:**

1. **Try a private/incognito browser window first** - This is the quickest way to test if the issue is cache-related.
2. **Clear your browser cache** if the private window works correctly:
   * **Chrome/Edge:** Press `Ctrl+Shift+Delete` (Windows/Linux) or `Cmd+Shift+Delete` (Mac)
   * **Firefox:** Press `Ctrl+Shift+Delete` (Windows/Linux) or `Cmd+Shift+Delete` (Mac)
   * **Safari:** Press `Cmd+Option+E` or go to Develop menu > Empty Caches
3. **Hard refresh the page** by pressing `Ctrl+F5` (Windows/Linux) or `Cmd+Shift+R` (Mac)

<Note>
  Caching issues are temporary and typically resolve themselves as the cache expires, but manually clearing the cache provides immediate resolution.
</Note>

## Downgrade Considerations

While we recommend staying up-to-date with the latest version, there may be scenarios where you need to downgrade your Infisical instance.

<Warning>
  **Database Compatibility:** Downgrading can be complex due to database schema changes. Always ensure you have proper backups before attempting any version changes.
</Warning>

### Safe Downgrade Process

1. **Prepare Database Snapshot:**
   * Create a database snapshot/backup **before** upgrading to the target version
   * Ensure the snapshot is from a version compatible with your desired downgrade target

2. **Stop Infisical Services:**
   * Gracefully shut down all Infisical instances to prevent data corruption

3. **Restore Database:**
   * Restore your database from the pre-upgrade snapshot
   * **Critical:** Do not attempt to downgrade with a database that has run migrations from a newer version

4. **Deploy Previous Version:**
   * Deploy the previous Infisical version
   * Verify that the version matches the database schema in your snapshot

5. **Verify Functionality:**
   * Test critical functionality to ensure the downgrade was successful
   * Monitor logs for any compatibility issues

<Note>
  The safest approach for downgrades is to restore to a known good state (both application and database) rather than attempting to reverse individual migrations.
</Note>


# null
Source: https://infisical.com/docs/self-hosting/overview

Learn how to self-host Infisical on your own infrastructure.

Self-hosting Infisical lets you retain data on your own infrastructure and network.
Choose from a number of deployment options listed below to get started.

<Card title="Docker" color="#000000" icon="docker" href="./deployment-options/standalone-infisical">
  Use the fully packaged docker image to deploy Infisical anywhere.
</Card>

<CardGroup cols={2}>
  <Card title="Docker Compose" color="#000000" icon="docker" href="./deployment-options/docker-compose">
    Install Infisical using our Docker Compose template.
  </Card>

  <Card title="Kubernetes" color="#000000" icon="gear-complex-code" href="./deployment-options/kubernetes-helm">
    Use our Helm chart to Install Infisical on your Kubernetes cluster.
  </Card>
</CardGroup>

<Card title="Linux package" color="#000000" href="./deployment-options/native/linux-package/installation">
  Install Infisical on your system without containers using our Linux package.
</Card>


# AWS ECS (HA)
Source: https://infisical.com/docs/self-hosting/reference-architectures/aws-ecs

Reference architecture for self-hosting Infisical on AWS ECS

This guide will provide high-level architecture design for deploying the Infisical on AWS ECS and give insights into the core components, high availability strategies, and secure credential management for Infisical's root secrets.

## Overview

In this guide, we'll focus on running Infisical on AWS Elastic Container Service (ECS) across multiple Availability Zones (AZs), ensuring high availability and resilience.
The architecture utilizes Amazon Relational Database Service (RDS) for persistent storage, ElastiCache for Redis as an in-memory data store for caching, and Amazon Simple Email Service (SES) to handle email based communications from Infisical.

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/self-hosting/reference-architectures/Infisical-AWS-ECS-architecture.jpeg" alt="AWS ECS architecture" />

### Core Components

* **ECS Fargate:** In this architecture, Infisical is deployed on ECS using Fargate launch type. The ECS services are deployed across multiple Availability Zones to ensure high availability.

* **Amazon RDS:** Infisical uses Postgres as it's persistent layer. As such, RDS for PostgreSQL is used as the database engine. The setup includes a primary instance in one AZ and a read replica in another AZ.
  This ensures that if there is a failure in one availability zone, the working replica will become the primary and continue  processing workloads.

* **Amazon ElastiCache for Redis:** To enhance performance, Infisical requires Redis. In this architecture, Redis is set up with a primary and standby replication group across two AZs to increase availability.

* **Amazon Simple Email Service (SES):** Infisical requires email service to facilitate outbound communication. AWS SES is integrated into the architecture to handle such communication.

### Network Setup

* **Public Subnets:** Each Availability Zone contains a public subnet. There are two main reasons you might need internet access. First, if you intend to use Infisical to communicate with external secrets managers not located within your virtual private network, enabling internet access is necessary. Second, downloading the Docker image from Docker Hub requires internet access, though this can be avoided by utilizing AWS ECR with VPC Endpoints through AWS Private Link.

* **NAT Gateway:** This is used to route outbound requests from Infisical to the internet and is only used to communicate with external secrets manager and or downloading container images.

### Securing Infisical's root credential

* **Parameter Store:** To secure Infisical's root credentials (database connection string, encryption key, etc), we highly recommend that you use AWS Parameter Store and only allow the tasks running Infisical to access them.
* **AWS Secrets Manager:** We strongly advise securing the master credentials for RDS by utilizing the latest AWS RDS integration with AWS Secrets Manager. This integration automatically stores the master database user's credentials in AWS Secrets Manager, thereby reducing the risk of misplacing the root RDS credential.

### High Availability (HA) and Scalability

* **Multi-AZ Deployment:** By spreading resources across multiple Availability Zones, we ensure that if one AZ experiences issues, traffic can be redirected to the remaining healthy AZ without service interruption.

* **Auto Scaling:** AWS Auto Scaling is in place to adjust capacity to maintain steady and predictable performance at the lowest possible cost.

* **Cross-Region Deployment:** For even greater high availability, you may deploy Infisical across multiple regions. This extends the HA capabilities of the architecture and protects against regional service disruptions.

### Frequently asked questions

<Accordion title="Can Infisical run in an air-gapped environment without any internet access?" defaultOpen>
  Yes, Infisical can function in an air-gapped environment. To do so, update your ECS task to use the publicly available AWS Elastic Container Registry (ECR) image instead of the default Docker Hub image. Additionally, it's necessary to configure VPC endpoints, which allows your system to access AWS ECR via a private network route instead of the internet, ensuring all connectivity remains within the secure, private network.
</Accordion>


# Google Cloud Run
Source: https://infisical.com/docs/self-hosting/reference-architectures/google-cloud-run

Reference architecture for self-hosting Infisical on Google Cloud Run.

## Overview

This guide outlines a reference architecture for deploying Infisical in a self-hosted configuration using Google Cloud Run.
It is intended to provide a scalable, secure, and production-ready baseline for organizations choosing Google Cloud Platform (GCP) as their infrastructure provider.

## Core Components

* **Cloud Run:** Infisical service is containerized and deployed as fully managed Cloud Run services.

* **Cloud SQL:** Infisical uses Postgres as its persistence layer. As such, Cloud SQL for PostgreSQL is used.

* **MemoryStore for Redis:** To schedule jobs, process audit logs and cache  performance, Infisical requires Redis.

## Securing Infisical's root credential

* **Secrets Manager:** To secure Infisicals root credentials (database connection string, encryption key, etc.),
  we highly recommend that you use Google Secrets Manager and only allow the tasks running Infisical to access them.

## High Availability and Scalability

This architecture leverages Google Cloud's managed services to achieve high availability and scalability out of the box:

**Cloud Run:**

* Automatically scales the number of container instances up or down based on incoming request volume.
* Supports rapid scaling during traffic spikes, ensuring low latency.
* Configurable minimum and maximum instances to handle baseline and peak loads.

**Cloud SQL:**

* Provides high availability configurations (regional instances with automatic failover) to ensure database uptime.
* Automated backups, point-in-time recovery, and maintenance.

**MemoryStore:**

* Offers highly available Redis configurations with replication.
* Fully managed with automatic scaling and patching.

**Cloud Load Balancer:**

* Distributes user traffic across available Cloud Run instances.
* Provides SSL termination, global load balancing, and health checks.

<Info>
  **Note:** To further improve performance and availability, consider enabling multi-region deployment strategies,
  regional VPC Connectors, and database replicas for read-heavy workloads.
</Info>

## Configuration

<Steps>
  <Step title="Provision Core Infrastructure">
    **Cloud SQL (PostgreSQL):**

    * Create a Cloud SQL instance.
      * Under `Zonal availability`, select the `Multiple zones` option to ensure High Availability.
    * Configure private IP access.

    **MemoryStore (Redis):**

    * Deploy a Redis instance.
    * Configure VPC access.
  </Step>

  <Step title="Get the Infisical Docker image">
    Visit [Docker Hub](https://hub.docker.com/r/infisical/infisical/tags) and select a version of Infisical image you would like to deploy.
    Then, within Cloud Run, paste the URL of the specific Infisical Docker image you would like to use within the `Container image URL` field.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/self-hosting/reference-architectures/google-cloud-run/cloud-run-container-image.png" alt="Cloud Run container image settings UI" />

    Remember to replace `<version>` with the docker image tag of your choice.
  </Step>

  <Step title="Set the environment variables">
    For a minimal installation of Infisical, you must configure the following environment variables:

    ```bash  theme={"dark"}
    ENCRYPTION_KEY=<your_encryption_key>
    AUTH_SECRET=<your_auth_secret>
    DB_CONNECTION_URI="<your_db_connection_uri>"
    SITE_URL="<your_site_url>"
    REDIS_URL="<your_redis_url>"
    ```

    [View all available configurations](/self-hosting/configuration/envars).

    You will want to setup Postgres and Redis within Google Cloud Platform to connect to Infisical.

    Once you have added the required environment variables to the `Environment Variables` section within Cloud Run,
    create the container to get Infisical up and running.

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/self-hosting/reference-architectures/google-cloud-run/container-env-vars.png" alt="Cloud Run container environment variables settings UI" />

    <Warning>
      The above environment variable values are only to be used as an example and should not be used in production
    </Warning>
  </Step>

  <Step title="Network Configuration">
    Enable `Connect to a VPC for outbound traffic`: This enables the service to talk to private resources (e.g., a Cloud SQL database, Redis instance on a private IP) inside your Google Cloud VPC network.

    Select `Send traffic directly to a VPC`: It gives lower latency and better performance, but uses more IPs from the subnet.

    <Info>
      Your Cloud Run revision must be in the same VPC network
    </Info>

        <img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/self-hosting/reference-architectures/google-cloud-run/container-network-configuration.png" alt="Cloud Run container network settings UI" />

    Once the container is running, verify the installation by opening your web browser and navigating to the Site URL.
  </Step>
</Steps>


# Linux (HA)
Source: https://infisical.com/docs/self-hosting/reference-architectures/linux-deployment-ha

Infisical High Availability Deployment architecture for Linux

This guide describes how to achieve a highly available deployment of Infisical on Linux machines without containerization. The architecture provided serves as a foundation for minimum high availability, which you can scale based on your specific requirements.

## Architecture Overview

<img src="https://mintlify.s3.us-west-1.amazonaws.com/infisical/images/self-hosting/deployment-options/native/ha-stack.png" alt="High availability stack" />

The deployment consists of the following key components:

| Service                | Nodes | Recommended Specs   | GCP Instance  | AWS Instance |
| ---------------------- | ----- | ------------------- | ------------- | ------------ |
| External Load Balancer | 1     | 4 vCPU, 4 GB memory | n1-highcpu-4  | c5n.xlarge   |
| Internal Load Balancer | 1     | 4 vCPU, 4 GB memory | n1-highcpu-4  | c5n.xlarge   |
| Etcd Cluster           | 3     | 4 vCPU, 4 GB memory | n1-highcpu-4  | c5n.xlarge   |
| PostgreSQL Cluster     | 3     | 2 vCPU, 8 GB memory | n1-standard-2 | m5.large     |
| Redis + Sentinel       | 3+3   | 2 vCPU, 8 GB memory | n1-standard-2 | m5.large     |
| Infisical Core         | 3     | 2 vCPU, 4 GB memory | n1-highcpu-2  | c5.large     |

### Network Architecture

All servers operate within the 52.1.0.0/24 private network range with the following IP assignments:

| Service                | IP Address |
| ---------------------- | ---------- |
| External Load Balancer | 52.1.0.1   |
| Internal Load Balancer | 52.1.0.2   |
| Etcd Node 1            | 52.1.0.3   |
| Etcd Node 2            | 52.1.0.4   |
| Etcd Node 3            | 52.1.0.5   |
| PostgreSQL Node 1      | 52.1.0.6   |
| PostgreSQL Node 2      | 52.1.0.7   |
| PostgreSQL Node 3      | 52.1.0.8   |
| Redis Node 1           | 52.1.0.9   |
| Redis Node 2           | 52.1.0.10  |
| Redis Node 3           | 52.1.0.11  |
| Sentinel Node 1        | 52.1.0.12  |
| Sentinel Node 2        | 52.1.0.13  |
| Sentinel Node 3        | 52.1.0.14  |
| Infisical Core 1       | 52.1.0.15  |
| Infisical Core 2       | 52.1.0.16  |
| Infisical Core 3       | 52.1.0.17  |

## Component Setup Guide

### 1. Configure Etcd Cluster

The Etcd cluster is needed for leader election in the PostgreSQL HA setup. Skip this step if using managed PostgreSQL.

1. Install Etcd on each node:

```bash  theme={"dark"}
sudo apt update
sudo apt install etcd
```

2. Configure each node with unique identifiers and cluster membership. Example configuration for Node 1 (`/etc/etcd/etcd.conf`):

```yaml  theme={"dark"}
name: etcd1
data-dir: /var/lib/etcd
initial-cluster-state: new
initial-cluster-token: etcd-cluster-1
initial-cluster: etcd1=http://52.1.0.3:2380,etcd2=http://52.1.0.4:2380,etcd3=http://52.1.0.5:2380
initial-advertise-peer-urls: http://52.1.0.3:2380
listen-peer-urls: http://52.1.0.3:2380
listen-client-urls: http://52.1.0.3:2379,http://127.0.0.1:2379
advertise-client-urls: http://52.1.0.3:2379
```

### 2. Configure PostgreSQL

For production deployments, you have two options for highly available PostgreSQL:

#### Option A: Managed PostgreSQL Service (Recommended for Most Users)

Use cloud provider managed services:

* AWS: Amazon RDS for PostgreSQL with Multi-AZ
* GCP: Cloud SQL for PostgreSQL with HA configuration
* Azure: Azure Database for PostgreSQL with zone redundant HA

These services handle replication, failover, and maintenance automatically.

#### Option B: Self-Managed PostgreSQL Cluster

Full HA installation guide of PostgreSQL is beyond the scope of this document. However, we have provided an overview of resources and code snippets below to guide your deployment.

1. Required Components:
   * PostgreSQL 14+ on each node
   * Patroni for cluster management
   * Etcd for distributed consensus

2. Documentation we recommend you read:
   * [Complete Patroni Setup Guide](https://patroni.readthedocs.io/en/latest/README.html)
   * [PostgreSQL Replication Documentation](https://www.postgresql.org/docs/current/high-availability.html)

3. Key Steps Overview:

```bash  theme={"dark"}
# 1. Install requirements on each PostgreSQL node
sudo apt update
sudo apt install -y postgresql-14 postgresql-contrib-14 python3-pip
pip3 install patroni[etcd] psycopg2-binary

# 2. Create Patroni config directory
sudo mkdir /etc/patroni
sudo chown postgres:postgres /etc/patroni

# 3. Create Patroni configuration (example for first node)
# /etc/patroni/config.yml - REQUIRES CAREFUL CUSTOMIZATION
```

```yaml  theme={"dark"}
scope: infisical-cluster
namespace: /db/
name: postgresql1

restapi:
  listen: 52.1.0.6:8008
  connect_address: 52.1.0.6:8008

etcd:
  hosts: 52.1.0.3:2379,52.1.0.4:2379,52.1.0.5:2379

bootstrap:
  dcs:
    ttl: 30
    loop_wait: 10
    retry_timeout: 10
    maximum_lag_on_failover: 1048576
    postgresql:
      use_pg_rewind: true
      parameters:
        max_connections: 1000
        shared_buffers: 2GB
        work_mem: 8MB
        max_worker_processes: 8
        max_parallel_workers_per_gather: 4
        max_parallel_workers: 8
        wal_level: replica
        hot_standby: "on"
        max_wal_senders: 10
        max_replication_slots: 10
        hot_standby_feedback: "on"
```

4. Important considerations:
   * Proper disk configuration for WAL and data directories
   * Network latency between nodes
   * Backup strategy and point-in-time recovery
   * Monitoring and alerting setup
   * Connection pooling configuration
   * Security and network access controls

5. Recommended readings:
   * [PostgreSQL Backup and Recovery](https://www.postgresql.org/docs/current/backup.html)
   * [PostgreSQL Monitoring](https://www.postgresql.org/docs/current/monitoring.html)

### 3. Configure Redis and Sentinel

Similar to PostgreSQL, a full HA Redis setup guide is beyond the scope of this document. Below are the key resources and considerations for your deployment.

#### Option A: Managed Redis Service (Recommended for Most Users)

Use cloud provider managed Redis services:

* AWS: ElastiCache for Redis with Multi-AZ
* GCP: Memorystore for Redis with HA
* Azure: Azure Cache for Redis with zone redundancy

Follow your cloud provider's documentation:

* [AWS ElastiCache Documentation](https://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/WhatIs.html)
* [GCP Memorystore Documentation](https://cloud.google.com/memorystore/docs/redis)
* [Azure Redis Cache Documentation](https://learn.microsoft.com/en-us/azure/azure-cache-for-redis/)

#### Option B: Self-Managed Redis Cluster

Setting up a production Redis HA cluster requires understanding several components. Refer to these linked resources:

1. Required Reading:
   * [Redis Sentinel Documentation](https://redis.io/docs/management/sentinel/)
   * [Redis Replication Guide](https://redis.io/topics/replication)
   * [Redis Security Guide](https://redis.io/topics/security)

2. Key Steps Overview:

```bash  theme={"dark"}
# 1. Install Redis on all nodes
sudo apt update
sudo apt install redis-server

# 2. Configure master node (52.1.0.9)
# /etc/redis/redis.conf
```

```conf  theme={"dark"}
bind 52.1.0.9
port 6379
dir /var/lib/redis
maxmemory 3gb
maxmemory-policy noeviction
requirepass "your_redis_password"
masterauth "your_redis_password"
```

3. Configure replica nodes (`52.1.0.10`, `52.1.0.11`):

```conf  theme={"dark"}
bind 52.1.0.10  # Change for each replica
port 6379
dir /var/lib/redis
replicaof 52.1.0.9 6379
masterauth "your_redis_password"
requirepass "your_redis_password"
```

4. Configure Sentinel nodes (`52.1.0.12`, `52.1.0.13`, `52.1.0.14`):

```conf  theme={"dark"}
port 26379
sentinel monitor mymaster 52.1.0.9 6379 2
sentinel auth-pass mymaster "your_redis_password"
sentinel down-after-milliseconds mymaster 5000
sentinel failover-timeout mymaster 60000
sentinel parallel-syncs mymaster 1
```

5. Recommended Additional Reading:
   * [Redis High Availability Tools](https://redis.io/topics/high-availability)
   * [Redis Sentinel Client Implementation](https://redis.io/topics/sentinel-clients)

### 4. Configure HAProxy Load Balancer

Install and configure HAProxy for internal load balancing:

```conf ha-proxy-config theme={"dark"}
global
    maxconn 10000
    log stdout format raw local0

defaults
    log global
    mode tcp
    retries 3
    timeout client 30m
    timeout connect 10s
    timeout server 30m
    timeout check 5s

listen stats
    mode http
    bind *:7000
    stats enable
    stats uri /

resolvers hostdns
    nameserver dns 127.0.0.11:53
    resolve_retries 3
    timeout resolve 1s
    timeout retry 1s
    hold valid 5s

frontend postgres_master
    bind *:5000
    default_backend postgres_master_backend

frontend postgres_replicas
    bind *:5001
    default_backend postgres_replica_backend

backend postgres_master_backend
    option httpchk GET /master
    http-check expect status 200
    default-server inter 3s fall 3 rise 2 on-marked-down shutdown-sessions
    server postgres-1 52.1.0.6:5432 check port 8008
    server postgres-2 52.1.0.7:5432 check port 8008
    server postgres-3 52.1.0.8:5432 check port 8008

backend postgres_replica_backend
    option httpchk GET /replica
    http-check expect status 200
    default-server inter 3s fall 3 rise 2 on-marked-down shutdown-sessions
    server postgres-1 52.1.0.6:5432 check port 8008
    server postgres-2 52.1.0.7:5432 check port 8008
    server postgres-3 52.1.0.8:5432 check port 8008

frontend redis_master_frontend
    bind *:6379
    default_backend redis_master_backend

backend redis_master_backend
    option tcp-check
    tcp-check send AUTH\ 123456\r\n
    tcp-check expect string +OK
    tcp-check send PING\r\n
    tcp-check expect string +PONG
    tcp-check send info\ replication\r\n
    tcp-check expect string role:master
    tcp-check send QUIT\r\n
    tcp-check expect string +OK
    server redis-1 52.1.0.9:6379 check inter 1s
    server redis-2 52.1.0.10:6379 check inter 1s
    server redis-3 52.1.0.11:6379 check inter 1s

frontend infisical_frontend
    bind *:80
    default_backend infisical_backend

backend infisical_backend
    option httpchk GET /api/status
    http-check expect status 200
    server infisical-1 52.1.0.15:8080 check inter 1s
    server infisical-2 52.1.0.16:8080 check inter 1s
    server infisical-3 52.1.0.17:8080 check inter 1s
```

### 5. Deploy Infisical Core

<Tabs>
  <Tab title="Debian/Ubuntu">
    First, add the Infisical repository:

    ```bash  theme={"dark"}
    curl -1sLf \
    'https://dl.cloudsmith.io/public/infisical/infisical-core/setup.deb.sh' \
    | sudo -E bash
    ```

    Then install Infisical:

    ```bash  theme={"dark"}
    sudo apt-get update && sudo apt-get install -y infisical-core
    ```

    <Info>
      For production environments, we strongly recommend installing a specific version of the package to maintain consistency across reinstalls. View available versions at [Infisical Package Versions](https://cloudsmith.io/~infisical/repos/infisical-core/packages/).
    </Info>
  </Tab>

  <Tab title="RedHat/CentOS/Amazon Linux">
    First, add the Infisical repository:

    ```bash  theme={"dark"}
    curl -1sLf \
    'https://dl.cloudsmith.io/public/infisical/infisical-core/setup.rpm.sh' \
    | sudo -E bash
    ```

    Then install Infisical:

    ```bash  theme={"dark"}
    sudo yum install infisical-core
    ```

    <Info>
      For production environments, we strongly recommend installing a specific version of the package to maintain consistency across reinstalls. View available versions at [Infisical Package Versions](https://cloudsmith.io/~infisical/repos/infisical-core/packages/).
    </Info>
  </Tab>
</Tabs>

Next, create configuration file `/etc/infisical/infisical.rb` with the following:

```ruby  theme={"dark"}
infisical_core['ENCRYPTION_KEY'] = 'your-secure-encryption-key'
infisical_core['AUTH_SECRET'] = 'your-secure-auth-secret'

infisical_core['DB_CONNECTION_URI'] = 'postgres://user:pass@52.1.0.2:5000/infisical'
infisical_core['REDIS_URL'] = 'redis://52.1.0.2:6379'

infisical_core['PORT'] = 8080
```

To generate `ENCRYPTION_KEY` and `AUTH_SECRET` view the [following configurations documentation here](/self-hosting/configuration/envars).

If you are using managed services for either Postgres or Redis, please replace the values of the secrets accordingly.

Lastly, start and verify each node running infisical-core:

```bash  theme={"dark"}
sudo infisical-ctl reconfigure
sudo infisical-ctl status
```

## Monitoring and Maintenance

1. Monitor HAProxy stats: `http://52.1.0.2:7000/haproxy?stats`
2. Monitor Infisical logs: `sudo infisical-ctl tail`
3. Check cluster health:
   * Etcd: `etcdctl cluster-health`
   * PostgreSQL: `patronictl list`
   * Redis: `redis-cli info replication`


# Kubernetes (HA)
Source: https://infisical.com/docs/self-hosting/reference-architectures/on-prem-k8s-ha

Reference architecture for self-hosting Infisical on Kubernetes (HA)

Deploying Infisical on-premise with high availability requires expertise in networking, container orchestration, and database management.
This guide serves as a reference architecture and a starting point. Actual deployments may vary depending on your organization's existing infrastructure and capabilities.

## Architecture Overview

```mermaid  theme={"dark"}
flowchart TB
    subgraph GLB["Global LB (HAProxy/NGINX)"]
    end

    subgraph OS["Object Storage"]
        direction LR
        store["S3/MinIO/Enterprise Storage"]
        subgraph store_contents["Storage Contents"]
            wal["PostgreSQL WAL"]
            pgbackup["PostgreSQL Backups"]
            redisbackup["Redis Backups"]
        end
    end

    subgraph DC1["Active Data Center"]
        direction TB
        subgraph k8s1["Kubernetes Cluster"]
            ing1["Ingress Controller"]
            app1["Infisical Deployment"]
            
            subgraph db1["CloudNativePG"]
                pg1p["PostgreSQL Primary"]
                pg1r["PostgreSQL Replicas"]
            end
            
            subgraph red1["Redis (Bitnami)"]
                rp1["Redis Primary"]
            end
        end
    end

    subgraph DC2["Passive Data Center"]
        direction TB
        subgraph k8s2["Kubernetes Cluster"]
            ing2["Ingress Controller"]
            app2["Infisical Deployment"]
            
            subgraph db2["CloudNativePG"]
                pg2["PostgreSQL Replicas"]
            end
            
            subgraph red2["Redis (Bitnami)"]
                r2["Redis Standby"]
            end
        end
    end

    %% Connections
    GLB --> ing1
    GLB -.-> ing2
    
    %% Database connections
    pg1p --> store
    store --> pg2
    
    %% Redis backup flow
    rp1 --> store
    store -.-> r2
    
    %% Intra-DC connections
    ing1 --> app1
    app1 --> db1
    app1 --> red1
    
    ing2 --> app2
    app2 --> db2
    app2 --> red2

    classDef primary fill:#f96,stroke:#333
    classDef replica fill:#69f,stroke:#333
    classDef storage fill:#9c6,stroke:#333
    classDef lb fill:#c9f,stroke:#333
    
    class pg1p,rp1 primary
    class pg1r,pg2,r2 replica
    class store,wal,pgbackup,redisbackup storage
    class GLB,ing1,ing2 lb
```

The architecture above makes use of Kubernetes for orchestrating both stateless and stateful components.
The architecture spans multiple data centers for increased redundancy, availability and disaster recovery capabilities using an active-passive configuration.

### Stateful vs stateless workloads

While managing databases within Kubernetes has typically been complex, modern operators like [CloudNativePG](https://cloudnative-pg.io/) simplify this process by handling storage provisioning, persistent volume management, and backup/recovery processes.
However, if you lack deep expertise in Kubernetes operators or database management, we recommend a hybrid approach where the database is on a managed service for production deployments.

<Warning>
  Managing stateful components like databases can be challenging without deep expertise or a dedicated in-house database management team.
  To simplify operations and reduce complexity, we recommend offloading databases to managed services from AWS/GCP.
  These managed services automatically handle provisioning, scaling, failover, backups and rollbacks.
</Warning>

## Core Components

### Kubernetes Cluster

Infisical is deployed on a Kubernetes cluster, which allows for container management, auto-scaling, and self-healing capabilities.
A load balancer sits in front of the Kubernetes cluster, directing traffic and making sure there is an even load distribution across the application nodes.
This is the entry point where all other services will interact with Infisical.

### Object Storage

The architecture requires S3-compatible object storage for database backups and cross-datacenter replication. This can be provided by:

* Existing enterprise object storage solution
* Dedicated MinIO deployment
* In-cluster MinIO deployment if neither option above is available

The object storage must be accessible from all Kubernetes clusters and provides:

* Storage for PostgreSQL WAL archiving and backups
* Storage for Redis backups

### CloudNativePG for High Availability PostgreSQL

The database layer is powered by PostgreSQL, managed by CloudNativePG operator for high availability:

* **Redundancy:** CloudNativePG manages a primary-replica setup where the primary handles write operations and replicas handle read operations
* **Failover:** The operator automatically handles failover within a cluster by promoting a replica to primary when needed
* **Backup and Recovery:** Built-in support for backup to S3-compatible storage with point-in-time recovery capabilities

### Redis High Availability

Redis is deployed using the [Bitnami Helm chart](https://github.com/bitnami/charts/tree/main/bitnami/redis) in a simple primary configuration:

* Single Redis instance per cluster without streaming replication
* Regular backups to object storage
* Restore from backup during failover

<Note>
  Infisical does not support Redis cluster mode, and since this is an active-passive setup, we use a simple Redis deployment with backup/restore for failover.
</Note>

#### PostgreSQL Backup and Restore

PostgreSQL is the single source of truth for nearly all application data on Infisical.

CloudNativePG provides well defined backup and restore capabilities:

* **Continuous Backup:** The operator continuously archives WAL files to object storage
* **Point-in-Time Recovery:** Supports restoring to any point in time using WAL archiving
* **Regular Testing:** Periodically test backup restoration to exercise the full lifecycle of this process

#### Redis Backup and Restore

Each Redis instance is backed up through a Kubernetes CronJob that:

1. Executes the Redis `SAVE` command
2. Copies the resulting `dump.rdb` to object storage
3. Manages backup retention

<Accordion title="Example Redis backup CronJob">
  ```yaml  theme={"dark"}
  apiVersion: batch/v1
  kind: CronJob
  metadata:
  name: redis-backup
  spec:
  schedule: "0 * * * *"  # Every hour
  jobTemplate:
      spec:
      template:
          spec:
          containers:
          - name: redis-backup
              image: bitnami/redis
              command:
              - /bin/sh
              - -c
              - |
              redis-cli -a $REDIS_PASSWORD save
              mc cp /data/dump.rdb object-store/redis-backups/
          volumes:
          - name: redis-data
              persistentVolumeClaim:
              claimName: redis-data
  ```
</Accordion>

During failover, the latest Redis backup is restored from object storage to the passive data center. This process is manual and requires operator intervention.

## Multi Data Center Deployment

Infisical can be deployed across multiple data centers in an active-passive configuration for disaster recovery. In this setup, one data center serves as the active site while others remain as passive standbys.

### Active Data Center

The active data center contains:

* The primary PostgreSQL cluster managed by CloudNativePG handling all write operations
* The active Redis instance handling all traffic
* The active Infisical deployment serving all user traffic

### Passive Data Centers

Passive data centers act as disaster recovery sites. Each contains:

* A replica PostgreSQL cluster that replicates from the active site's primary cluster
* A standby Redis instance (not receiving traffic)
* A standby Infisical deployment (not receiving traffic)

### Traffic Management and Failover

Traffic routing between data centers requires:

1. A global load balancer for traffic management. For on-premises deployments, this can be implemented using:
   * HAProxy or NGINX configured as a global load balancer
   * Any enterprise network routing solutions you may already have in place
2. Each data center should have its own ingress or load balancer

The global load balancer should be deployed in a highly available configuration across multiple locations to avoid it becoming a single point of failure.

During normal operation:

* The global load balancer routes all traffic to the active data center
* Replica PostgreSQL clusters continuously replicate from the primary cluster
* Redis backups are regularly created and stored in object storage

During failover:

* A human operator must initiate the failover process
* The operator promotes a replica PostgreSQL cluster in the target passive data center to become primary using CloudNativePG's promotion process
* The latest Redis backup is restored from object storage to the passive data center's Redis instance
* Once database failover is complete, the global load balancer is updated to direct traffic to the new active data center

<Note>
  This is an active-passive setup where failover must be initiated manually by an operator. Automatic failover between data centers is not recommended as it can lead to split-brain scenarios. The operator should verify the state of both data centers before initiating failover.
</Note>

## Data Replication Across Data Centers

### PostgreSQL Replication

CloudNativePG manages replication across data centers:

* **Replica Clusters:** Each data center runs a replica cluster that replicates from the primary cluster
* **WAL Shipping:** Changes are replicated via WAL shipping to object storage
* **Failover:** The operator can promote a replica cluster to primary during planned switchovers or failures

### Object Storage Configuration

If using MinIO for object storage, ensure:

* High availability deployment if running dedicated MinIO cluster
* Proper access controls and encryption for data at rest
* Regular monitoring of storage capacity and performance
* Backup of object storage data itself if running your own MinIO deployment


