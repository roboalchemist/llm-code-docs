# Liveblocks Documentation

Source: https://liveblocks.io/llms-full.txt

---

---
meta:
  title: "@liveblocks/client"
  parentTitle: "API Reference"
  description: "API Reference for the @liveblocks/client package"
alwaysShowAllNavigationLevels: false
---

`@liveblocks/client` provides you with JavaScript bindings for our realtime
collaboration APIs, built on top of WebSockets. Read our
[getting started](/docs/get-started) guides to learn more.

## createClient

Creates a [client](#Client) that allows you to connect to Liveblocks servers.
You must define either `authEndpoint` or `publicApiKey`. Resolver functions
should be placed inside here, and a number of other options are available.

```tsx
import { createClient } from "@liveblocks/client";

const client = createClient({
  authEndpoint: "/api/liveblocks-auth",

  // Other options
  // ...
});
```

```tsx title="Every createClient option" isCollapsable isCollapsed
import { createClient } from "@liveblocks/client";

const client = createClient({
  // Connect with authEndpoint
  authEndpoint: "/api/liveblocks-auth",

  // Alternatively, use an authEndpoint callback
  // authEndpoint: async (room) => {
  //   const response = await fetch("/api/liveblocks-auth", {
  //   method: "POST",
  //   headers: {
  //     Authentication: "<your own headers here>",
  //     "Content-Type": "application/json",
  //   },
  //   body: JSON.stringify({ room }),
  // });
  // return await response.json();
  // },

  // Alternatively, use a public key
  // publicApiKey: "pk_...",

  // Throttle time (ms) between WebSocket updates
  throttle: 100,

  // Prevent browser tab from closing while local changes arenâ€™t synchronized yet
  preventUnsavedChanges: false,

  // Throw lost-connection event after 5 seconds offline
  lostConnectionTimeout: 5000,

  // Disconnect users after X (ms) of inactivity, disabled by default
  backgroundKeepAliveTimeout: undefined,

  // Resolve user info for Comments, Text Editor, and Notifications
  resolveUsers: async ({ userIds }) => {
    const usersData = await __getUsersFromDB__(userIds);

    return usersData.map((userData) => ({
      name: userData.name,
      avatar: userData.avatar.src,
    }));
  },

  // Resolve room info for Notifications
  resolveRoomsInfo: async ({ roomIds }) => {
    const documentsData = await __getDocumentsFromDB__(roomIds);

    return documentsData.map((documentData) => ({
      name: documentData.name,
      // url: documentData.url,
    }));
  },

  // Resolve group info for Comments and Text Editor
  resolveGroupsInfo: async ({ groupIds }) => {
    const groupsData = await __getGroupsFromDB__(groupIds);

    return groupsData.map((groupData) => ({
      avatar: groupData.avatar.src,
      name: groupData.name,
      // description: groupData.description,
    }));
  },

  // Resolve mention suggestions for Comments and Text Editor
  resolveMentionSuggestions: async ({ text, roomId }) => {
    const workspaceUsers = await __getWorkspaceUsersFromDB__(roomId);

    if (!text) {
      // Show all workspace users by default
      return __getUserIds__(workspaceUsers);
    } else {
      const matchingUsers = __findUsers__(workspaceUsers, text);
      return __getUserIds__(matchingUsers);
    }
  },

  // Polyfill options for non-browser environments
  polyfills: {
    // atob,
    // fetch,
    // WebSocket,
  },

  // Set the location of the "Powered by Liveblocks" badge
  // "top-right", "bottom-right", "bottom-left", "top-left"
  badgeLocation: "bottom-right",
});
```

<PropertiesList title="Returns">
  <PropertiesListItem name="client" type="Client">
    Returns a [Client](#Client), used for connecting to Liveblocks.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Options">
  <PropertiesListItem
    name="authEndpoint"
    detailedType="string | async ((room?: string) => CustomAuthenticationResult)"
  >
    The URL of your back endâ€™s [authentication endpoint](/docs/authentication)
    as a string, or an async callback function that returns a Liveblocks token
    result. Either `authEndpoint` or `publicApiKey` are required. Learn more
    about [using a URL string](#createClientAuthEndpoint) and [using a
    callback](#createClientCallback).
  </PropertiesListItem>
  <PropertiesListItem name="publicApiKey" type="string">
    The public API key taken from your projectâ€™s
    [dashboard](/dashboard/apikeys). Generally not recommended for production
    use. Either `authEndpoint` or `publicApiKey` are required. [Learn
    more](#createClientPublicKey).
  </PropertiesListItem>
  <PropertiesListItem name="throttle" type="number" defaultValue="100">
    The throttle time between WebSocket messages in milliseconds, a number
    between `16` and `1000` is allowed. Using `16` means your app will update 60
    times per second. [Learn more](#createClientThrottle).
  </PropertiesListItem>
  <PropertiesListItem
    name="preventUnsavedChanges"
    type="boolean"
    defaultValue="false"
  >
    When set, navigating away from the current page is prevented while
    Liveblocks is still synchronizing local changes. [Learn
    more](#prevent-users-losing-unsaved-changes).
  </PropertiesListItem>
  <PropertiesListItem
    name="lostConnectionTimeout"
    type="number"
    defaultValue="5000"
  >
    After a user disconnects, the time in milliseconds before a
    [`"lost-connection"`](/docs/api-reference/liveblocks-client#Room.subscribe.lost-connection)
    event is fired. [Learn more](#createClientLostConnectionTimeout).
  </PropertiesListItem>
  <PropertiesListItem name="backgroundKeepAliveTimeout" type="number">
    The time before an inactive WebSocket connection is disconnected. This is
    disabled by default, but setting a number will activate it. [Learn
    more](#createClientBackgroundKeepAliveTimeout).
  </PropertiesListItem>
  <PropertiesListItem
    name="resolveUsers"
    detailedType='async? (args: ResolveUsersArgs) => (UserMeta["info"] | undefined)[] | undefined'
  >
    A function that resolves user information in
    [Comments](/docs/ready-made-features/comments), [Text Editor](/docs/ready-made-features/text-editor), and [Notifications](/docs/ready-made-features/notifications). Return an array of
    `UserMeta["info"]` objects in the same order they arrived. [Learn
    more](#createClientResolveUsers).
  </PropertiesListItem>
  <PropertiesListItem
    name="resolveRoomsInfo"
    detailedType="async? (args: ResolveRoomsInfoArgs) => (RoomInfo | undefined)[] | undefined"
  >
    A function that resolves room information in
    [Notifications](/docs/ready-made-features/notifications). Return an array of
    `RoomInfo` objects in the same order they arrived. [Learn
    more](#createClientResolveRoomsInfo).
  </PropertiesListItem>
  <PropertiesListItem
    name="resolveGroupsInfo"
    detailedType="async? (args: ResolveGroupsInfoArgs) => (GroupInfo | undefined)[] | undefined"
  >
    A function that resolves group information in
    [Comments](/docs/ready-made-features/comments) and [Text Editor](/docs/ready-made-features/text-editor). Return an array of
    `GroupInfo` objects in the same order they arrived. [Learn
    more](#createClientResolveGroupsInfo).
  </PropertiesListItem>
  <PropertiesListItem
    name="resolveMentionSuggestions"
    detailedType="async? (args: ResolveMentionSuggestionsArgs) => string[] | MentionData[]"
  >
    A function that resolves mention suggestions in
    [Comments](/docs/ready-made-features/comments) and [Text Editor](/docs/ready-made-features/text-editor). Return an array of user IDs or mention objects.
    [Learn more](#createClientResolveMentionSuggestions).
  </PropertiesListItem>
  <PropertiesListItem name="polyfills">
    Place polyfills for `atob`, `fetch`, and `WebSocket` inside here. Useful
    when using a non-browser environment, such as [Node.js](#createClientNode)
    or [React Native](#createClientReactNative).
  </PropertiesListItem>
  <PropertiesListItem
    name="largeMessageStrategy"
    detailedType='"default" | "split" | "experimental-fallback-to-http"'
    defaultValue={`"default"`}
  >
    <div className="-mb-3">
      How to handle WebSocket messages that are larger than the maximum message size. Can be set to one of these values:
    </div>

    - `"default"` Donâ€™t send anything, but log the error to the console and notify useErrorListener.
    - `"split"` Break the message up into chunks each of which is smaller than the maximum message size. Beware that using `"split"` will sacrifice atomicity of changes! Depending on your use case, this may or may not be problematic.
    - `"experimental-fallback-to-http"` Try sending the update over HTTP instead of WebSockets. This strategy is marked experimental, as it can make the client appear as "synchronizing" indefinitely when used with Liveblocks Storage or Yjs.

  </PropertiesListItem>
  <PropertiesListItem
    name="badgeLocation"
    detailedType='"top-right" | "bottom-right" | "bottom-left" | "top-left"'
    defaultValue={`"bottom-right"`}
  >
    The location of the "Powered by Liveblocks" badge. Can be set to either `"top-right"`, `"bottom-right"`, `"bottom-left"`, or `"top-left"`.
    [Learn more](#createClientBadgeLocation).
  </PropertiesListItem>
  <PropertiesListItem
    name="unstable_streamData"
    type="boolean"
    defaultValue="false"
  >
    Experimental. Stream the initial Storage content over HTTP, instead of
    waiting for a large initial WebSocket message to be sent from the server.
  </PropertiesListItem>
</PropertiesList>

### createClient with public key [#createClientPublicKey]

When creating a client with a public key, you donâ€™t need to set up an
authorization endpoint. We only recommend using a public key when prototyping,
or on public landing pages, as it makes it possible for end users to access any
roomâ€™s data. You should instead use an
[auth endpoint](#createClientAuthEndpoint).

```ts
import { createClient } from "@liveblocks/client";

const client = createClient({
  publicApiKey: "{{PUBLIC_KEY}}",
});
```

### createClient with auth endpoint [#createClientAuthEndpoint]

If you are not using a public key, you need to set up your own `authEndpoint`.
Please refer to our [Authentication guide](/docs/authentication).

```ts
import { createClient } from "@liveblocks/client";

const client = createClient({ authEndpoint: "/api/liveblocks-auth" });
```

### createClient with auth endpoint callback [#createClientCallback]

If you need to add additional headers or use your own function to call your
endpoint, `authEndpoint` can be provided as a custom callback. You should return
the token created with
[`Liveblocks.prepareSession`](/docs/api-reference/liveblocks-node#access-tokens)
or [`liveblocks.identifyUser`](/docs/api-reference/liveblocks-node#id-tokens),
learn more in [authentication guide](/docs/rooms/authentication).

```ts
import { createClient } from "@liveblocks/client";

const client = createClient({
  authEndpoint: async (room) => {
    // Fetch your authentication endpoint and retrieve your access or ID token
    // ...

    return { token: "..." };
  },
});
```

`room` is the room ID that the user is connecting to. When using
[Notifications](/docs/ready-made-features/comments/email-notifications), `room`
can be `undefined`, as the client is requesting a token that grants access to
multiple rooms, rather than a specific room.

#### Fetch your endpoint

Hereâ€™s an example of fetching your API endpoint at `/api/liveblocks-auth` within
the callback.

```ts
import { createClient } from "@liveblocks/client";

const client = createClient({
  authEndpoint: async (room) => {
    const response = await fetch("/api/liveblocks-auth", {
      method: "POST",
      headers: {
        Authentication: "<your own headers here>",
        "Content-Type": "application/json",
      },
      // Donâ€™t forget to pass `room` down. Note that it
      // can be undefined when using Notifications.
      body: JSON.stringify({ room }),
    });
    return await response.json();
  },
});
```

#### Token details

You should return the token created with
[`Liveblocks.prepareSession`](/docs/api-reference/liveblocks-node#access-tokens)
or [`liveblocks.identifyUser`](/docs/api-reference/liveblocks-node#id-tokens).
These are the values the functions can return.

1. A valid token, it returns a `{ "token": "..." }` shaped response.
1. A token that explicitly forbids access, it returns an
   `{ "error": "forbidden", "reason": "..." }` shaped response. If this is
   returned, the client will disconnect and wonâ€™t keep trying to authorize.

Any other error will be treated as an unexpected error, after which the client
will retry the request until it receives either 1. or 2.

### WebSocket throttle [#createClientThrottle]

By default, the client throttles the WebSocket messages sent to one every 100
milliseconds, which translates to 10 updates per second. Itâ€™s possible to
override that configuration with the `throttle` option with a value between `16`
and `1000` milliseconds.

```ts
import { createClient } from "@liveblocks/client";

const client = createClient({
  throttle: 16,

  // Other options
  // ...
});
```

This option is helpful for smoothing out realtime animations in your
application, as you can effectively increase the framerate without using any
interpolation. Here are some examples with their approximate frames per second
(FPS) values.

```ts
throttle:  16, // 60 FPS
throttle:  32, // 30 FPS
throttle: 200, //  5 FPS
```

### Prevent users losing unsaved changes [#prevent-users-losing-unsaved-changes]

Liveblocks usually synchronizes milliseconds after a local change, but if a user
immediately closes their tab, or if they have a slow connection, it may take
longer for changes to synchronize. Enabling `preventUnsavedChanges` will stop
tabs with unsaved changes closing, by opening a dialog that warns users. In
usual circumstances, it will very rarely trigger.

```tsx
import { createClient } from "@liveblocks/client";

const client = createClient({
  preventUnsavedChanges: true,

  // Other options
  // ...
});
```

More specifically, this option triggers when:

- There are unsaved changes after calling any hooks or methods, in all of our
  products.
- There are unsaved changes in a
  [Text Editor](/docs/ready-made-features/text-editor).
- Thereâ€™s an unsubmitted comment in the
  [Composer](/docs/api-reference/liveblocks-react-ui#Composer).
- The user has made changes and is currently offline.

Internally, this option uses the
[beforeunload event](https://developer.mozilla.org/en-US/docs/Web/API/Window/beforeunload_event).

### Lost connection timeout [#createClientLostConnectionTimeout]

If youâ€™re connected to a room and briefly lose connection, Liveblocks will
reconnect automatically and quickly. However, if reconnecting takes longer than
usual, for example if your network is offline, then the room will emit an event
informing you about this.

How quickly this event is triggered can be configured with the
`lostConnectionTimeout` setting, and it takes a number in milliseconds.
`lostConnectionTimeout` can be set between `1000` and `30000` milliseconds. The
default is `5000`, or 5 seconds.

```ts
import { createClient } from "@liveblocks/client";

const client = createClient({
  lostConnectionTimeout: 5000,

  // Other options
  // ...
});
```

You can listen to the event with [`room.subscribe("lost-connection")`][]. Note
that this also affects when `others` are reset to an empty array after a
disconnection. This helps prevent temporary flashes in your application as a
user quickly disconnects and reconnects. For a demonstration of this behavior,
see our [connection status example][].

### Background keep-alive timeout [#createClientBackgroundKeepAliveTimeout]

By default, Liveblocks applications will maintain an active WebSocket connection
to the Liveblocks servers, even when running in a browser tab thatâ€™s in the
background. However, if youâ€™d prefer for background tabs to disconnect after a
period of inactivity, then you can use `backgroundKeepAliveTimeout`.

When `backgroundKeepAliveTimeout` is specified, the client will automatically
disconnect applications that have been in an unfocused background tab for _at
least_ the specified time. When the browser tab is refocused, the client will
immediately reconnect to the room and synchronize the document.

```ts
import { createClient } from "@liveblocks/client";

const client = createClient({
  // Disconnect users after 15 minutes of inactivity
  backgroundKeepAliveTimeout: 15 * 60 * 1000,

  // Other options
  // ...
});
```

`backgroundKeepAliveTimeout` accepts a number in millisecondsâ€”we advise using a
value of at least a few minutes, to avoid unnecessary disconnections.

### resolveUsers [#createClientResolveUsers]

[Comments](/docs/ready-made-features/comments) and
[Text Editor](/docs/ready-made-features/text-editor) store user IDs in their
system, but no other user information. To display user information in Comments,
Text Editor, and Notifications components, such as a userâ€™s name or avatar, you
need to resolve these IDs into user objects. This function receives a list of
user IDs and you should return a list of user objects of the same size, in the
same order.

User IDs are automatically resolved in batches with a maximum of 50 users per
batch to optimize performance and prevent overwhelming your user resolution
function.

```tsx
import { createClient } from "@liveblocks/client";

const client = createClient({
  resolveUsers: async ({ userIds }) => {
    const usersData = await __getUsersFromDB__(userIds);

    return usersData.map((userData) => ({
      name: userData.name,
      avatar: userData.avatar.src,
    }));
  },

  // Other options
  // ...
});
```

The name and avatar you return are rendered in
[`Thread`](/docs/api-reference/liveblocks-react-ui#Thread) components.

#### User objects

The user objects returned by the resolver function take the shape of
`UserMeta["info"]`, which contains `name` and `avatar` by default. These two
values are optional, though if youâ€™re using the
[Comments default components](/docs/api-reference/liveblocks-react-ui#Components),
they are necessary. Hereâ€™s an example of `userIds` and the exact values
returned.

```ts
resolveUsers: async ({ userIds }) => {
  // ["marc@example.com", "nimesh@example.com"];
  console.log(userIds);

  return [
    { name: "Marc", avatar: "https://example.com/marc.png" },
    { name: "Nimesh", avatar: "https://example.com/nimesh.png" },
  ];
};
```

You can also return custom information, for example, a userâ€™s `color`:

```ts
resolveUsers: async ({ userIds }) => {
  // ["marc@example.com"];
  console.log(userIds);

  return [
    {
      name: "Marc",
      avatar: "https://example.com/marc.png",
      // +++
      color: "purple",
      // +++
    },
  ];
};
```

#### Accessing user data in React

You can access any values set within `resolveUsers` with the
[`useUser`](/docs/api-reference/liveblocks-react#useUser) hook.

```tsx
import { useUser } from "@liveblocks/react/suspense";

function Component() {
  const user = useUser("marc@example.com");

  // { name: "Marc", avatar: "https://...", ... }
  console.log(user);
}
```

### resolveRoomsInfo [#createClientResolveRoomsInfo]

When using
[Notifications](/docs/ready-made-features/comments/email-notifications) with
[Comments](/docs/ready-made-features/comments), room IDs will be used to
contextualize notifications (e.g. â€œChris mentioned you in _room-id_â€) in the
[`InboxNotification`](/docs/api-reference/liveblocks-react-ui#InboxNotification)
component. To replace room IDs with more fitting names (e.g. document names,
â€œChris mentioned you in _Document A_â€), you can provide a resolver function to
the `resolveRoomsInfo` option in [`createClient`](#createClient).

This resolver function will receive a list of room IDs and should return a list
of room info objects of the same size and in the same order.

```tsx
import { createClient } from "@liveblocks/client";

const client = createClient({
  resolveRoomsInfo: async ({ roomIds }) => {
    const documentsData = await __getDocumentsFromDB__(roomIds);

    return documentsData.map((documentData) => ({
      name: documentData.name,
      // url: documentData.url,
    }));
  },

  // Other options
  // ...
});
```

In addition to the roomâ€™s name, you can also provide a roomâ€™s URL as the `url`
property. If you do so, the
[`InboxNotification`](/docs/api-reference/liveblocks-react-ui#InboxNotification)
component will automatically use it. Itâ€™s possible to use an inbox
notificationâ€™s `roomId` property to construct a roomâ€™s URL directly in React and
set it on
[`InboxNotification`](/docs/api-reference/liveblocks-react-ui#InboxNotification)
via `href`, but the room ID might not be enough for you to construct the URL,
you might need to call your backend for example. In that case, providing it via
`resolveRoomsInfo` is the preferred way.

### resolveGroupsInfo [#createClientResolveGroupsInfo]

When using group mentions with [Comments](/docs/ready-made-features/comments)
and [Text Editor](/docs/ready-made-features/text-editor), group IDs will be used
instead of user IDs. Similarly to [`resolveUsers`](#createClientResolveUsers),
you can provide a resolver function to the `resolveGroupsInfo` option in
[`createClient`](#createClient) to assign information like names and avatars to
group IDs.

```tsx
import { createClient } from "@liveblocks/client";

const client = createClient({
  resolveGroupsInfo: async ({ groupIds }) => {
    const groupsData = await __getGroupsFromDB__(groupIds);

    return groupsData.map((groupData) => ({
      name: groupData.name,
      avatar: groupData.avatar.src,
    }));
  },

  // Other options
  // ...
});
```

#### Accessing group info in React

You can access any values set within `resolveGroupsInfo` with the
[`useGroupInfo`](/docs/api-reference/liveblocks-react#useGroupInfo) hook.

```tsx
import { useGroupInfo } from "@liveblocks/react/suspense";

function Component() {
  const group = useGroupInfo("group-engineering");

  // { name: "Engineering", avatar: "https://...", ... }
  console.log(group);
}
```

### resolveMentionSuggestions [#createClientResolveMentionSuggestions]

To enable creating mentions in [Comments](/docs/ready-made-features/comments)
and [Text Editor](/docs/ready-made-features/text-editor), you can provide a
resolver function to the `resolveMentionSuggestions` option in
[`createClient`](#createClient). These mentions will be displayed in the
[`Composer`](/docs/api-reference/liveblocks-react-ui#Composer) component and in
text editors.

This resolver function will receive the mention currently being typed (e.g. when
writing â€œ@janeâ€, `text` will be `jane`) and should return a list of user IDs
matching that text. This function will be called every time the text changes but
with some debouncing.

```tsx
import { createClient } from "@liveblocks/client";

const client = createClient({
  resolveMentionSuggestions: async ({ text, roomId }) => {
    const workspaceUsers = await __getWorkspaceUsersFromDB__(roomId);

    if (!text) {
      // Show all workspace users by default
      return __getUserIds__(workspaceUsers);
    } else {
      const matchingUsers = __findUsers__(workspaceUsers, text);
      return __getUserIds__(matchingUsers);
    }
  },

  // Other options
  // ...
});
```

#### Group mentions

To support group mentions in [Comments](/docs/ready-made-features/comments) and
[Text Editor](/docs/ready-made-features/text-editor), you can return a list of
mention objects instead of user IDs to suggest a mix of user and group mentions.

```tsx
import { createClient } from "@liveblocks/client";

const client = createClient({
  resolveMentionSuggestions: async ({ text, roomId }) => {
    const dbUsers = await __findUsersFromDB__(roomId);
    const dbGroups = await __findGroupsFromDB__(roomId);

    // Show groups and users matching the text being typed
    return [
      ...dbGroups.map((group) => ({
        kind: "group",
        id: group.id,
      })),
      ...dbUsers.map((user) => ({
        kind: "user",
        id: user.id,
      })),
    ];
  },

  // Other options
  // ...
});
```

The mention objects specify which kind of mention it is, the ID to mention (user
ID or group ID), etc.

```tsx
// A user mention suggestion
{
  kind: "user",
  id: "user-1",
}

// A group mention suggestion
{
  kind: "group",
  id: "group-1",
}

// A group mention suggestion with fixed group members
// When using fixed group members via `userIds`, they will take precedence
// if the group ID exists on Liveblocks.
{
  kind: "group",
  id: "here",
  members: ["user-1", "user-2"],
}
```

### createClient for Node.js [#createClientNode]

To use `@liveblocks/client` in Node.js, you need to provide [`WebSocket`][] and
[`fetch`][] polyfills. As polyfills, we recommend installing [`ws`][] and
[`node-fetch`][].

```bash
npm install ws node-fetch
```

Then, pass them to the `createClient` polyfill option as below.

```ts
import { createClient } from "@liveblocks/client";
import fetch from "node-fetch";
import WebSocket from "ws";

const client = createClient({
  polyfills: {
    fetch,
    WebSocket,
  },

  // Other options
  // ...
});
```

Note that `node-fetch` v3+
[does not support CommonJS](https://github.com/node-fetch/node-fetch/blob/main/docs/v3-UPGRADE-GUIDE.md#converted-to-es-module).
If you are using CommonJS, downgrade `node-fetch` to v2.

### createClient for React Native [#createClientReactNative]

To use `@liveblocks/client` with [React Native](https://reactnative.dev/), you
need to add an [`atob`][] polyfill. As a polyfill, we recommend installing
[`base-64`][].

```bash
npm install base-64
```

Then you can pass the `decode` function to our `atob` polyfill option when you
create the client.

```ts
import { createClient } from "@liveblocks/client";
import { decode } from "base-64";

const client = createClient({
  polyfills: {
    atob: decode,
  },

  // Other options
  // ...
});
```

### Powered by Liveblocks branding [#createClientBadgeLocation]

By default, Liveblocks displays a "Powered by Liveblocks" badge in your
application. You can adjust the position of the badge by setting the
`badgeLocation` property on `createClient`.

```ts title="Set badge location"
import { createClient } from "@liveblocks/client";

// "top-right", "bottom-right", "bottom-left", "top-left"
const client = createClient({
  badgeLocation: "bottom-right",

  // ...
});
```

If you wish to remove the badge entirely, you can do so by following these
steps:

1. In the Liveblocks dashboard, navigate to your
   [team's settings](/dashboard/settings).
2. Under **General**, toggle on the remove "Powered by Liveblocks" branding
   option.

<Banner title='Removing the "Powered by Liveblocks" badge'>

Removing the "Powered by Liveblocks" badge on your projects requires a
[paid plan](/pricing/). See the [pricing page](/pricing/) for more information.

</Banner>

## Client

Client returned by [`createClient`][] which allows you to connect to Liveblocks
servers in your application, and enter rooms.

### Client.enterRoom

Enters a room and returns both the local `Room` instance, and a `leave`
unsubscribe function. The authentication endpoint is called as soon as you call
this function. Used for setting [initial Presence](#setting-initial-presence)
and [initial Storage](#setting-initial-storage) values.

```ts
const { room, leave } = client.enterRoom("my-room-id", {
  // Options
  // ...
});
```

Note that itâ€™s possible to [add types to your room](#typing-your-data).

<PropertiesList title="Returns">
  <PropertiesListItem
    name="room"
    type="Room<Presence, Storage, UserMeta, RoomEvent>"
  >
    A [Room](#Room), used for building your Liveblocks application. Learn more
    about [typing your room](#typing-your-data).
  </PropertiesListItem>
  <PropertiesListItem name="leave" type="() => void">
    A function thatâ€™s used to leave the room and disconnect.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem name="roomId" type="string" required>
    The ID of the room youâ€™re connecting to.
  </PropertiesListItem>
  <PropertiesListItem name="options.initialPresence" type="JsonObject">
    The initial Presence of the user entering the room. Each user has their own
    presence, and this is readable for all other connected users. A userâ€™s
    Presence resets every time they disconnect. This object must be
    JSON-serializable. [Learn more](#setting-initial-presence).
  </PropertiesListItem>
  <PropertiesListItem name="options.initialStorage" type="LsonObject">
    The initial Storage structure for the room when itâ€™s joined for the first
    time. This is only set a single time, when the room has not yet been
    populated. This object must contain [conflict-free live
    structures](/docs/api-reference/liveblocks-client#Storage). [Learn
    more](#setting-initial-storage).
  </PropertiesListItem>
  <PropertiesListItem
    name="options.autoConnect"
    type="boolean"
    defaultValue="true"
  >
    Whether the room immediately connects to Liveblocks servers.
  </PropertiesListItem>
</PropertiesList>

#### Setting initial Presence [#setting-initial-presence]

Presence is used for storing temporary user-based values, such as a userâ€™s
cursor coordinates, or their current selection. Each user has their own
presence, and this is readable for all other connected users. Set your initial
Presence value by using `initialPresence`.

```ts
const { room, leave } = client.enterRoom("my-room-id", {
  // +++
  initialPresence: {
    cursor: null,
    colors: ["red", "purple"],
    selection: {
      id: 72426,
    },
  },
  // +++

  // Other options
  // ...
});
```

Each userâ€™s Presence resets every time they disconnect, as this is only meant
for temporary data. Any JSON-serializable object is allowed (the `JsonObject`
type).

#### Setting initial Storage [#setting-initial-storage]

Storage is used to store permanent data thatâ€™s used in your application, such as
shapes on a whiteboard, nodes on a flowchart, or text in a form. The first time
a room is entered, you can set an initial value by using `initialStorage`.
`initialStorage` is only read and set a single time, unless a new top-level
property is added.

```ts
import { LiveList, LiveObject } from "@liveblocks/client";

const { room, leave } = client.enterRoom("my-room-id", {
  // +++
  initialStorage: {
    title: "Untitled",
    shapes: new LiveList([
      new LiveObject({ type: "rectangle", color: "yellow" }),
    ]),
  },
  // +++

  // Other options
  // ...
});
```

If a new top-level property is added to `initialStorage`, the next time a user
connects, the new property will be created. Other properties will be unaffected.
Any
[conflict-free live structures](/docs/api-reference/liveblocks-client#Storage)
and JSON-serializable objects are allowed (the `LsonObject` type).

#### Speed up connecting to a room [#speed-up-connecting-to-a-room]

To speed up connecting to a room, you can call
[`Liveblocks.prewarmRoom`](/docs/api-reference/liveblocks-node#get-rooms-roomId-prewarm)
on the server, which will warm up a room for the next 10 seconds. Triggering
this directly before a user navigates to a room is an easy to way use this API.

### Client.getRoom

Gets a room by its ID. Returns `null` if [`client.enterRoom`][] has not been
called previously.

```ts
const room = client.getRoom("my-room");
```

Itâ€™s unlikely youâ€™ll need this API if youâ€™re using the newer
[`client.enterRoom`][] API. Note that itâ€™s possible to
[add types to your room](#typing-your-data).

<PropertiesList title="Returns">
  <PropertiesListItem
    name="room"
    type="Room<Presence, Storage, UserMeta, RoomEvent> | null"
  >
    A [Room](#Room), used for building your Liveblocks application. Returns
    `null` if the room has not yet been joined by the current client. Learn more
    about [typing your room](#typing-your-data).
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem name="roomId" type="string" required>
    The ID of the room youâ€™re connecting to.
  </PropertiesListItem>
</PropertiesList>

### Client.getSyncStatus

Gets the current Liveblocks synchronization status.

```ts
const syncStatus = client.getSyncStatus();
// "synchronizing" | "synchronized"
```

<PropertiesList title="Returns">
  <PropertiesListItem name="returns" type={'"synchronizing" | "synchronized"'}>
    Will be `"synchronizing"` if there are any local changes to any part of
    Liveblocks that still need to be acknowledged by the server. Will be
    `"synchronized"` when all local changes have been persisted.
  </PropertiesListItem>
</PropertiesList>

### Client.logout

Purges any auth tokens from the clientâ€™s memory. If there are any rooms that are
still connected, they will be forced to reauthorize.

```ts
client.logout();
```

<PropertiesListEmpty title="Returns">_Nothing_</PropertiesListEmpty>

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

#### When to logout

Use this function if you have a single page application (SPA) and you wish to
log your user out, and reauthenticate them. This is a way to update your userâ€™s
`info` after a connection has begun.

## AI Copilots

### defineAiTool

Create a custom tool for your AI copilot to use. Defining tools allow the AI
copilot to look up information on-demand, render your own components based on
the toolâ€™s arguments, or perform actions in your application on behalf of the
current user, such as creating content, updating the application state, or
interacting with external services.

```tsx
import { defineAiTool } from "@liveblocks/client";

const myTool = defineAiTool()({
  description: "Fetch user information by ID",
  parameters: {
    type: "object",
    properties: {
      userId: { type: "string", description: "The userâ€™s unique identifier" },
    },
    required: ["userId"],
    additionalProperties: false,
  },
  execute: async ({ userId }) => {
    const user = await getUserById(userId);
    return { data: { user } };
  },
  render: ({ result }) => (
    <AiTool title="User Lookup" icon="ðŸ‘¤">
      {!result.data ? (
        <div>Looking up user...</div>
      ) : (
        <div>Found user: {result.data.user.name}</div>
      )}
    </AiTool>
  ),
});
```

<Banner>

Note that the function should be called like this `defineAiTool()({ ... })`
(double-parens). This allows TypeScriptâ€™s inference to work correctly. For the
best type inference experience, TypeScript 5.3 or higher is recommended. While
Liveblocks supports TypeScript 5.0+, full type inference for `defineAiTool()`
requires TypeScript 5.3+.

</Banner>

<PropertiesList title="Returns">
  <PropertiesListItem name="tool" type="AiOpaqueToolDefinition">
    An AI tool.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem name="description" type="string" required>
    A clear description of what the tool does. Used by AI to understand when to
    call this tool.
  </PropertiesListItem>
  <PropertiesListItem name="parameters" type="JSONSchema7" required>
    JSON Schema defining the toolâ€™s input parameters. The AI will validate
    arguments against this schema.
  </PropertiesListItem>
  <PropertiesListItem name="enabled" type="boolean">
    Whether this tool should be enabled. When set to `false`, the tool will not
    be made available to the AI copilot for any new/future chat messages, but
    will still allow existing tool invocations to be rendered that are part of
    the historic chat record. Defaults to true.
  </PropertiesListItem>
  <PropertiesListItem name="execute" type="function">
    Async function that performs the toolâ€™s action. Receives validated arguments
    and execution context, returns structured data. See [implementing the tool
    call via `execute`](#implement-via-execute).
  </PropertiesListItem>
  <PropertiesListItem name="render" type="function">
    React component function that renders the toolâ€™s UI during different
    execution stages. See [tool call rendering
    stages](#tool-call-rendering-stages).
  </PropertiesListItem>
</PropertiesList>

Tools can be registered globally with
[`RegisterAiTool`](/docs/api-reference/liveblocks-react#RegisterAiTool) or
passed directly to [`AiChat`](/docs/api-reference/liveblocks-react-ui#AiChat).

### Tool call rendering stages [#tool-call-rendering-stages]

Rendering a tool call can be done before the tool call is executed, which allows
you to display a UI during its entire lifecycle. The tool call stages are:

- `receiving` (since [3.4]()) The tool call is being received and its args are
  being streamed in. During this stage, you can access `partialArgs` to display
  a UI while the tool call arguments are still being constructed, but before the
  tool call is executed.
- `executing` The tool call is currently executing, or is ready to be. In this
  stage, the `args` are fully known, but the result of the tool call is not
  known yet.
- `executed` The tool call has been executed, and the result is known. This
  happens after your `execute` function was run, or after you called `respond()`
  inside `render`. In this stage, the `result` object will be available.

The render component will automatically re-render when its stage changes.

### Implementing tool calls

When you implement a tool call, use one of these combinations:

1. Implement `execute` _and_ `render`
1. Implement only `execute`, but no `render`
1. Implement only `render`, but make sure to eventually call `respond()`

#### Implementing your tool call via `execute` [#implement-via-execute]

If you implement the `execute` function, this function will automatically be
invoked when the tool call gets made. The return value of this function will be
the result that will be passed back to the AI copilot.

- `{ data: any, description?: string }` The data to return in case of success.
  `data` must be a legal JSON value. Providing a description is optional. If you
  provide a description, it will be passed to the AI copilot to help it
  understand the returned data or to provide follow-up instructions for how to
  respond to this tool result.
- `{ error: string }` The error message in case the tool call failed to execute.
- `{ cancel: true | string }` If the tool call should be cancelled. You can
  optionally provide a cancel reason as an instruction to the AI copilot.

The returned value can be observed in the `render` method, through the `result`
param:

```tsx
defineAiTool()({
  /* ... */

  execute: async () => {
    await sleep(1000);
    return { data: { user: { name: "Alice" } } };
  },

  render: ({ result }) => {
    if (result.data) {
      return <div>Found user: {result.data.user.name}</div>;
    }

    // Tool hasnâ€™t executed yet
    return <Spinner />;
  },
});
```

If you do not implement `render` alongside `execute`, the tool call will still
be executed, but no UI will be displayed. The result will still be passed back
to the AI copilot.

#### Implementing your tool call via `render` [#implement-via-render]

Sometimes you may not want to immediately execute the tool call. This is most
common to build a Human-in-the-Loop (HITL) style UI where you want the user to
confirm or correct the tool callâ€™s behavior. In these scenarios, you do not want
to implement `execute`. Instead, you could display any UI, as long as you
eventually call the `respond` function that is provided to `render`â€™s props.

```tsx
defineAiTool()({
  /* ... */
  /* NOTE: No execute method used here! */

  render: ({ respond }) => {
    return (
      <div>
        <button
          onClick={() => {
            respond({ data: { user: { name: "Alice" } } });
          }}
        >
          Confirm
        </button>
        <button
          onClick={() => {
            respond({ cancel: true });
          }}
        >
          Cancel
        </button>
      </div>
    );
  },
});
```

In this example, until the Confirm button is clicked, the AI chat will remain in
â€œexecutingâ€ stage, awaiting the result of this tool call.

This example is for illustrative purposes only. In practice, using our
[`AiTool.Confirmation`](/docs/api-reference/liveblocks-react-ui#AiTool.Confirmation)
tool is preferred for building confirm/cancel flows.

Like with the `execute` function, the `respond` function should be called with a
value of this shape:

- `{ data: any, description?: string }` The data to return in case of success.
  `data` must be a legal JSON value. Providing a description is optional. If you
  provide a description, it will be passed to the AI copilot to help it
  understand the returned data or to provide follow-up instructions for how to
  respond to this tool result.
- `{ error: string }` The error message in case the tool call failed to execute.
- `{ cancel: true | string }` If the tool call should be cancelled. You can
  optionally provide a cancel reason as an instruction to the AI copilot.

#### Handling different tool call stages [#handling-stages]

You can handle all three stages of a tool call in your render function to
provide a smooth user experience during tool call streaming and execution:

```tsx
const bookFlightTool = defineAiTool()({
  description: "Book a flight for a user",
  parameters: {
    type: "object",
    properties: {
      origin: { type: "string", description: "Departure city" },
      destination: { type: "string", description: "Arrival city" },
      departureDate: {
        type: "string",
        description: "Departure date (YYYY-MM-DD)",
      },
      passengers: {
        type: "array",
        items: {
          type: "object",
          properties: {
            name: { type: "string" },
            age: { type: "number" },
          },
          required: ["name", "age"],
          additionalProperties: false,
        },
        description: "List of passengers",
      },
    },
    required: ["origin", "destination", "departureDate", "passengers"],
    additionalProperties: false,
  },
  execute: async ({ origin, destination, departureDate, passengers }) => {
    const booking = await bookFlight({
      origin,
      destination,
      departureDate,
      passengers,
    });
    return { data: { bookingId: booking.id } };
  },
  render: ({ stage, partialArgs, args, result }) => {
    return (
      <AiTool title="Flight Booking" icon="âœˆï¸">
        {stage === "receiving" && (
          <div>
            <h4>Preparing flight booking...</h4>
            {partialArgs.origin && <p>From: {partialArgs.origin}</p>}
            {partialArgs.destination && <p>To: {partialArgs.destination}</p>}
            {partialArgs.departureDate && (
              <p>Date: {partialArgs.departureDate}</p>
            )}
            {partialArgs.passengers && (
              <div>
                <p>Passengers ({partialArgs.passengers.length}):</p>
                <ul>
                  {partialArgs.passengers.map((passenger, index) => (
                    <li key={index}>
                      {passenger?.name || "Loading..."}
                      {passenger?.age && ` (${passenger.age})`}
                    </li>
                  ))}
                </ul>
              </div>
            )}
          </div>
        )}
        {stage === "executing" && (
          <div>
            <h4>Booking flight...</h4>
            <p>
              {args.origin} â†’ {args.destination} on {args.departureDate}
            </p>
            <p>{args.passengers.length} passenger(s)</p>
          </div>
        )}
        {stage === "executed" && result.data && (
          <div>
            <h4>Flight booked successfully!</h4>
            <p>Booking ID: {result.data.bookingId}</p>
          </div>
        )}
      </AiTool>
    );
  },
});
```

In this example, the tool arguments stream in progressively during the
`receiving` stage, causing multiple re-renders as each field appears:

- **1st render**: `{ stage: "receiving", partialArgs: {} }`
- **2nd render**: `{ stage: "receiving", partialArgs: { origin: "New York" } }`
- **3rd render**:
  `{ stage: "receiving", partialArgs: { origin: "New York", destination: "London" } }`
- **4th render**:
  `{ stage: "receiving", partialArgs: { origin: "New York", destination: "London", departureDate: "2024-12-15" } }`
- **5th render**: `{ stage: "receiving", partialArgs: { ..., passengers: [] } }`
- **6th render**:
  `{ stage: "receiving", partialArgs: { ..., passengers: [{ name: "John" }] } }`
- **7th render**:
  `{ stage: "receiving", partialArgs: { ..., passengers: [{ name: "John", age: 3 }] } }`
- **8th render**:
  `{ stage: "receiving", partialArgs: { ..., passengers: [{ name: "John", age: 30 }] } }`
- **Final render**: `{ stage: "executing", args: { /* complete object */ } }`

This demonstrates how each field and nested property appears incrementally,
providing real-time feedback to users as the AI constructs the tool call
arguments.

Arguments are streamed in forward-only order. Once a field begins appearing, all
previous fields are complete and wonâ€™t be modified. Youâ€™ll never see
`{ origin: "New York", destination: "London" }` followed by
`{ origin: "San Francisco", destination: "London" }`, but you might see
`{ origin: "New" }` then `{ origin: "New York" }` then
`{ origin: "New York", destination: "London" }`.

## Room

Room returned by [`client.enterRoom`][] (or [`client.getRoom`][]).

### Room.getPresence

Return the current userâ€™s Presence.
[Presence](/docs/ready-made-features/presence) is used to store custom
properties on each user that exist until the user disconnects. An example use
would be storing a userâ€™s cursor coordinates.

```ts
const presence = room.getPresence();

// { cursor: { x: 363, y: 723 } }
console.log(presence);
```

Presence is set with [`updatePresence`](#Room.updatePresence) and can be typed
when you [enter a room](#enter-room-typing-a-room). The example above is using
the following type:

```ts file="liveblocks.config.ts"
declare global {
  interface Liveblocks {
    Presence: {
      cursor: { x: number; y: number };
    };
  }
}
```

<PropertiesList title="Returns">
  <PropertiesListItem name="presence" type="TPresence">
    An object holding the Presence value for the currently connected user.
    Presence is set with [`updatePresence`](#Room.updatePresence). Will always
    be JSON-serializable. `TPresence` is the `Presence` type you set yourself,
    [learn more](#Typing-presence).
  </PropertiesListItem>
</PropertiesList>

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

### Room.updatePresence

Updates the current userâ€™s [Presence](/docs/ready-made-features/presence). Only
pass the properties you wish to updateâ€”any changes will be merged into the
current presence. The entire presence object will not be replaced.

```ts
room.updatePresence({ typing: true });
room.updatePresence({ status: "Online" });

// { typing: true, status: "Online" }
const presence = room.getPresence();
```

<PropertiesListEmpty title="Returns">_Nothing_</PropertiesListEmpty>

<PropertiesList title="Arguments">
  <PropertiesListItem name="update" type="TPresence" required>
    The updated Presence properties for the current user inside an object. The
    userâ€™s entire Presence object will not be replaced, instead these properties
    will be merged with the existing Presence. This object must be
    JSON-serializable.
  </PropertiesListItem>
  <PropertiesListItem
    name="options.addToHistory"
    type="boolean"
    defaultValue="false"
  >
    Adds Presence values to the history stack, meaning using undo and redo
    functions will change them. [Learn more](#add-presence-to-history).
  </PropertiesListItem>
</PropertiesList>

#### Add Presence to history [#add-presence-to-history]

By default, Presence values are not added to history. However, using the
`addToHistory` option will add items to the undo/redo stack.

```ts
room.updatePresence({ color: "blue" }, { addToHistory: true });
room.updatePresence({ color: "red" }, { addToHistory: true });
room.history.undo();

// { color: "blue" }
const presence = room.getPresence();
```

See [`room.history`][] for more information.

### Room.getOthers

Returns an array of currently connected users in the room. Returns a
[`User`](#user-type) object for each user. Note that you can also subscribe to
others using [`Room.subscribe("others")`](#Room.subscribe.others).

```ts
const others = room.getOthers();

for (const other of others) {
  const { connectionId, id, info, presence, canWrite, canComment } = other;
  // Do things
}
```

<PropertiesList title="Returns">
  <PropertiesListItem name="others" type="User<Presence, UserMeta>[]">
    An array holding each connected userâ€™s [`User`](#user-type) object. `User`
    contains the current userâ€™s Presence value, along with other information.
    Presence is set with [`updatePresence`](#Room.updatePresence). Returns an
    empty array when no other users are currently connected. Will always be
    JSON-serializable.
  </PropertiesListItem>
</PropertiesList>

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

### Room.broadcastEvent

Broadcast an event to other users in the Room. Events broadcast to the room can
be listened to with [`Room.subscribe("event")`][]. Takes a custom event payload
as first argument. Should be serializable to JSON.

```ts
room.broadcastEvent({ type: "REACTION", emoji: "ðŸ”¥" });
```

<PropertiesListEmpty title="Returns">_Nothing_</PropertiesListEmpty>

<PropertiesList title="Arguments">
  <PropertiesListItem name="event" type="TRoomEvent" required>
    The event to broadcast to every other user in the room. Must be
    JSON-serializable. `TRoomEvent` is the `RoomEvent` type you set yourself,
    [learn more](#typing-multiple-events).
  </PropertiesListItem>
  <PropertiesListItem
    name="options.shouldQueueEventIfNotReady"
    type="boolean"
    defaultValue="false"
  >
    Queue the event if the connection is currently closed, or has not been
    opened yet. Weâ€™re not sure if we want to support this option in the future
    so it might be deprecated to be replaced by something else. [Learn
    more](#broadcasting-an-event-when-disconnected).
  </PropertiesListItem>
</PropertiesList>

#### Receiving an event

To receive an event, use [`Room.subscribe("event")`][]. The `user` property
received on the other end is the senderâ€™s [`User`](#user-type) instance.

```ts
// User 1
room.broadcastEvent({ type: "REACTION", emoji: "ðŸ”¥" });

// User 2
const unsubscribe = room.subscribe("event", ({ event, user, connectionId }) => {
  //                                                  ^^^^ User 1
  if (event.type === "REACTION") {
    // Do something
  }
});
```

We recommend using a property such as `type`, so that itâ€™s easy to distinguish
between different events on the receiving end.

#### Typing multiple events [#typing-multiple-events]

When [defining your types](#typing-your-data), you can pass a `RoomEvent` type
in your config file to receive type hints in your app. To define multiple
different custom events, use a union.

```ts
declare global {
  interface Liveblocks {
    RoomEvent:
      | { type: "REACTION"; emoji: string }
      | { type: "ACTION"; action: string };
  }
}
```

```ts
room.subscribe("event", ({ event, user, connectionId }) => {
  if (event.type === "REACTION") {
    // Do something
  }
  if (event.type === "ACTION") {
    // Do something else
  }
});
```

#### Broadcasting an event when disconnected [#broadcasting-an-event-when-disconnected]

By default, broadcasting an event is a â€œfire and forgetâ€ action. If the sending
client is not currently connected to a room, the event is simply discarded. When
passing the `shouldQueueEventIfNotReady` option, the client will queue up the
event, and only send it once the connection to the room is (re)established.

<Banner>

Weâ€™re not sure if we want to support `shouldQueueEventIfNotReady` in the future,
so it may be deprecated and replaced with something else.

</Banner>

```ts
room.broadcastEvent(
  { type: "REACTION", emoji: "ðŸ”¥" },
  {
    // +++
    shouldQueueEventIfNotReady: true,
    // +++
  }
);
```

### Room.getSelf

Gets the current [`User`](#user-type). Returns `null` if the client is not yet
connected to the room.

```ts
const { connectionId, presence, id, info, canWrite, canComment } =
  room.getSelf();
```

<PropertiesList title="Returns">
  <PropertiesListItem name="user" type="User<Presence, UserMeta> | null">
    Returns the current [`User`](#user-type). Returns `null` if the client is
    not yet connected to the room.
  </PropertiesListItem>
</PropertiesList>

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

Hereâ€™s an example of a full return value, assuming `Presence` and `UserMeta`
[have been set](#user-type).

```ts
const user = room.getSelf();

// {
//   connectionId: 52,
//   presence: {
//     cursor: { x: 263, y: 786 },
//   },
//   id: "mislav.abha@example.com",
//   info: {
//     avatar: "/mislav.png",
//   },
//   canWrite: true,
//   canComment: true,
// }
console.log(user);
```

### Room.getStatus

Gets the current WebSocket connection status of the room. The possible value
are: `initial`, `connecting`, `connected`, `reconnecting`, or `disconnected`.

```ts
const status = room.getStatus();

// "connected"
console.log(status);
```

<PropertiesList title="Returns">
  <PropertiesListItem
    name="status"
    type={`"initial" | "connecting" | "connected" | "reconnecting" | "disconnected"`}
  >
    <div className="-mb-3">
    Returns the roomâ€™s current connection status. It can return one of five values:
    </div>

    - `"initial"` The room has not attempted to connect yet.
    - `"connecting"` The room is currently authenticating or connecting.
    - `"connected"` The room is connected.
    - `"reconnecting"` The room has disconnected, and is trying to connect again.
    - `"disconnected"` The room is disconnected, and is no longer attempting to connect.

  </PropertiesListItem>
</PropertiesList>

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

### Room.getStorageStatus

Get the Storage status. Use this to tell whether Storage has been synchronized
with the Liveblocks servers.

```ts
const status = room.getStorageStatus();

// "synchronizing"
console.log(status);
```

<PropertiesList title="Returns">
  <PropertiesListItem
    name="status"
    type={`"not-loaded" | "loading" | "synchronizing" | "synchronized"`}
  >
    <div className="-mb-3">
    The current roomâ€™s Storage status. `status` can be one of four types.
    </div>

    - `"not-loaded"` Storage has not been loaded yet as [`room.getStorage`][] has not been called.
    - `"loading"` Storage is currently loading for the first time.
    - `"synchronizing"` Local Storage changes are currently being synchronized.
    - `"synchronized"` Local Storage changes have been synchronized.

  </PropertiesListItem>
</PropertiesList>

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

### Room.subscribe(storageItem)

Subscribe to updates on a particular storage item, and takes a callback function
thatâ€™s called when the storage item is updated. The Storage `root` is a
[`LiveObject`][], which means you can subscribe to this, as well as other live
structures. Returns an unsubscribe function.

```ts
const { root } = await room.getStorage();

const unsubscribe = room.subscribe(root, (updatedRoot) => {
  // Do something
});
```

<PropertiesList title="Returns">
  <PropertiesListItem name="unsubscribe" type="() => void">
    Unsubscribe function. Call it to cancel the subscription.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem
    name="storageItem"
    type="L extends (LiveObject | LiveMap | LiveList)"
    required
  >
    The `LiveObject`, `LiveMap`, or `LiveList` which is being subscribed to.
    Each time the structure is updated, the callback is called.
  </PropertiesListItem>
  <PropertiesListItem name="callback" type="(node: L) => void" required>
    Function thatâ€™s called when `storageItem` updates. Returns the updated
    storage structure.
  </PropertiesListItem>
  <PropertiesListItem name="options.isDeep" type="boolean">
    Subscribe to both `storageItem` and its children. The callback function will
    be passed a list of updates instead of just the new Storage item. [Learn
    more](#listening-for-nested-changes).
  </PropertiesListItem>
</PropertiesList>

#### Typing Storage

To type the Storage values you receive, make sure to set your `Storage` type.

```ts file="liveblocks.config.ts"
import { LiveList } from "@liveblocks/client";

declare global {
  interface Liveblocks {
    Storage: {
      animals: LiveList<{ name: string }>;
    };
  }
}
```

The type received in the callback will match the type passed. Learn more under
[typing your room](#typing-your-data).

```ts
const { root } = await room.getStorage();
const animals = root.get("animals");

const unsubscribe = room.subscribe(animals, (updatedAnimals) => {
  // LiveList<[{ name: "Fido" }, { name: "Felix" }]>
  console.log(updatedAnimals);
});
```

#### Subscribe to any live structure

You can subscribe to any live structure, be it the Storage `root`, a child, or a
structure even more deeply nested.

```ts file="liveblocks.config.ts"
import { LiveMap, LiveObject } from "@liveblocks/client";

type Person = LiveObject<{ name: string; age: number }>;

declare global {
  interface Liveblocks {
    Storage: {
      people: LiveMap<string, Person>;
    };
  }
}
```

```ts
const { root } = await room.getStorage();
const people = root.get("people");
const steven = people.get("steven");

const unsubscribeRoot = room.subscribe(root, (updatedRoot) => {
  // ...
});

const unsubscribePeople = room.subscribe(people, (updatedPeople) => {
  // ...
});

const unsubscribeSteven = room.subscribe(steven, (updatedSteven) => {
  // ...
});
```

#### Listening for nested changes [#listening-for-nested-changes]

Itâ€™s also possible to subscribe to a Storage item and all of its children by
passing an optional `isDeep` option in the third argument. In this case, the
callback will be passed a list of updates instead of just the new Storage item.
Each such update is a `{ type, node, updates }` object.

```ts
const { root } = await room.getStorage();

const unsubscribe = room.subscribe(
  root,
  (storageUpdates) => {
    for (const update of storageUpdates) {
      const {
        type, // "LiveObject", "LiveList", or "LiveMap"
        node,
        updates,
      } = update;
      switch (type) {
        case "LiveObject": {
          // updates["property"]?.type; is "update" or "delete"
          // update.node is the LiveObject that has been updated/deleted
          break;
        }
        case "LiveMap": {
          // updates["key"]?.type; is "update" or "delete"
          // update.node is the LiveMap that has been updated/deleted
          break;
        }
        case "LiveList": {
          // updates[0]?.type; is "delete", "insert", "move", or "set"
          // update.node is the LiveList that has been updated, deleted, or modified
          break;
        }
      }
    }
  },
  { isDeep: true }
);
```

#### Using async functions

You use an `async` function inside the subscription callback, though bear in
mind that the callback itself is synchronous, and thereâ€™s no guarantee the
`async` function will complete before the callback is run again.

```ts
const { root } = await room.getStorage();

const unsubscribe = room.subscribe(root, (updatedRoot) => {
  async function doThing() {
    await fetch(/* ... */);
  }

  doThing();
});
```

If the order of updates is important in your application, and itâ€™s important to
ensure that your `async` function doesnâ€™t start before the previous one
finishes, you can use a package such as
[`async-mutex`](https://www.npmjs.com/package/async-mutex) to help you with
this. Using `runExclusive` will effectively form a queue for all upcoming
updates, guaranteeing serial execution.

```ts
import { Mutex } from "async-mutex";

const { root } = await room.getStorage();
const myMutex = new Mutex();

const unsubscribeUpdates = room.subscribe(root, (root) => {
  void myMutex.runExclusive(async () => {
    await fetch(/* ... */);
  });
});
```

Note that this may cause a performance penalty in your application, as certain
updates will be ignored.

### Room.subscribe("event") [#Room.subscribe.event]

Subscribe to events broadcast by [`Room.broadcastEvent`][]. Takes a callback
thatâ€™s run when another user calls [`Room.broadcastEvent`][]. Provides the
`event` along with the `user` and their `connectionId` of the user that sent the
message. Returns an unsubscribe function.

```ts
// User 1
room.broadcastEvent({ type: "REACTION", emoji: "ðŸ”¥" });

// +++
// User 2
const unsubscribe = room.subscribe("event", ({ event, user, connectionId }) => {
  //                                                  ^^^^ Will be User 1
  if (event.type === "REACTION") {
    // Do something
  }
});
// +++
```

<PropertiesList title="Returns">
  <PropertiesListItem name="unsubscribe" type="() => void">
    Unsubscribe function. Call it to cancel the subscription.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem name="eventType" type={`"event"`} required>
    Listen to events.
  </PropertiesListItem>
  <PropertiesListItem
    name="callback"
    detailedType="(event: RoomEventMessage<Presence, UserMeta, RoomEvent>) => void"
    required
  >
    Function thatâ€™s called when another user sends an event. Receives the event,
    the [`user`](#user-type) that sent the event, and their `connectionId`. If
    this event was sent via
    [`liveblocks.broadcastEvent`](/docs/api-reference/liveblocks-node#post-broadcast-event)
    or the [Broadcast event
    API](/docs/api-reference/rest-api-endpoints#post-broadcast-event), `user`
    will be `null` and `connectionId` will be `-1`. [Learn
    more](#receiving-events-from-the-server)
  </PropertiesListItem>
</PropertiesList>

#### Typing events

When [defining your types](#typing-your-data), you can pass a `RoomEvent` type
to your config file to receive type hints in your app. To define multiple
different custom events, use a union.

```ts
declare global {
  interface Liveblocks {
    RoomEvent:
      | { type: "REACTION"; emoji: string }
      | { type: "ACTION"; action: string };
  }
}
```

```ts
room.subscribe("event", ({ event, user, connectionId }) => {
  if (event.type === "REACTION") {
    // Do something
  }
  if (event.type === "ACTION") {
    // Do something else
  }
});
```

#### Receiving events from the server [#receiving-events-from-the-server]

Events can be received from the server with either
[`liveblocks.broadcastEvent`](/docs/api-reference/liveblocks-node#post-broadcast-event)
or the
[Broadcast Event API](/docs/api-reference/rest-api-endpoints#post-broadcast-event).
In events sent from the server, `user` will be `null`, and `connectionId` will
be `-1`.

```ts
import { Liveblocks } from "@liveblocks/node";

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

export async function POST() {
  await liveblocks.broadcastEvent({ type: "REACTION", emoji: "ðŸ”¥" });
}
```

```ts
const unsubscribe = room.subscribe("event", ({ event, user, connectionId }) => {
  // `null`, `-1`
  console.log(user, connectionId);
});
```

### Room.subscribe("my-presence") [#Room.subscribe.my-presence]

Subscribe to the current userâ€™s Presence. Takes a callback that is called every
time the current user presence is updated with [`Room.updatePresence`][].
Returns an unsubscribe function.

```ts
const unsubscribe = room.subscribe("my-presence", (presence) => {
  // Do something
});
```

<PropertiesList title="Returns">
  <PropertiesListItem name="unsubscribe" type="() => void">
    Unsubscribe function. Call it to cancel the subscription.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem name="eventType" type={`"my-presence"`} required>
    Listen to the current userâ€™s presence.
  </PropertiesListItem>
  <PropertiesListItem
    name="callback"
    type="(presence: TPresence) => void"
    required
  >
    Function thatâ€™s called when the current userâ€™s Presence has updated, for
    example with [`Room.updatePresence`][]. Receives the updates Presence value.
  </PropertiesListItem>
</PropertiesList>

#### Typing Presence

To type the Presence values you receive, make sure to set your Presence type.

```ts file="liveblocks.config.ts"
declare global {
  interface Liveblocks {
    Presence: {
      status: string;
      cursor: { x: number; y: number };
    };
  }
}
```

The type received in the callback will match the type passed. Learn more under
[typing your data](#typing-your-data).

```ts
const unsubscribe = room.subscribe("my-presence", (presence) => {
  // { status: "typing", cursor: { x: 45, y: 67 }
  console.log(presence);
});
```

### Room.subscribe("others") [#Room.subscribe.others]

Subscribe to every other usersâ€™ updates. Takes a callback thatâ€™s called when a
userâ€™s Presence updates, or when they enter or leave the room. Returns an
unsubscribe function.

```ts
const unsubscribe = room.subscribe("others", (others, event) => {
  // Do something
});
```

<PropertiesList title="Returns">
  <PropertiesListItem name="unsubscribe" type="() => void">
    Unsubscribe function. Call it to cancel the subscription.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem name="eventType" type={`"others"`} required>
    Listen to others.
  </PropertiesListItem>
  <PropertiesListItem
    name="callback"
    type="(others: User<Presence, UserMeta>[], event: OthersEvent) => void"
    required
  >
    Function thatâ€™s called when another userâ€™s Presence has updated, for example
    with [`Room.updatePresence`][], or an others event has occurred. Receives an
    array of [`User`](#user-type) values for each currently connected user. Also
    received an object with information about the event that has triggered the
    update, [learn more](#listening-for-others-events).
  </PropertiesListItem>
</PropertiesList>

#### Typing Presence

To type the Presence values you receive, make sure to set your Presence type.

```ts file="liveblocks.config.ts"
declare global {
  interface Liveblocks {
    Presence: {
      status: string;
      cursor: { x: number; y: number };
    };
  }
}
```

The type received in the callback will match the type passed. Learn more under
[typing your data](#typing-your-data).

```ts
const unsubscribe = room.subscribe("others", (others, event) => {
  // { status: "typing", cursor: { x: 45, y: 67 }
  console.log(others[0].presence);
});
```

#### Listening for others events [#listening-for-others-events]

The `event` parameter returns information on why the callback has just run, for
example if their Presence has updated, if theyâ€™ve just left or entered the room,
or if the current user has disconnected.

```ts
const unsubscribe = room.subscribe("others", (others, event) => {
  if (event.type === "leave") {
    // A user has left the room
    // event.user;
  }

  if (event.type === "enter") {
    // A user has entered the room
    // event.user;
  }

  if (event.type === "update") {
    // A user has updated
    // event.user;
    // event.updates;
  }

  if (event.type === "reset") {
    // A disconnection has occurred and others has reset
  }
});
```

#### Live cursors

Hereâ€™s a basic example showing you how to render live cursors.
[`Room.updatePresence`](/docs/api-reference/liveblocks-client#Room.updatePresence)
is being used to update each userâ€™s cursor position.

```ts file="liveblocks.config.ts"
declare global {
  interface Liveblocks {
    Presence: {
      cursor: { x: number; y: number };
    };
  }
}
```

```ts
const { room, leave } = client.enterRoom("my-room-id");

// Call this to update the current userâ€™s Presence
function updateCursorPosition({ x, y }) {
  room.updatePresence({ cursor: { x, y } });
}

const others = room.getOthers();

// Run __renderCursor__ when any other connected user updates their presence
const unsubscribe = room.subscribe("others", (others, event) => {
  for (const { id, presence } of others) {
    const { x, y } = presence.cursor;
    __renderCursor__(id, { x, y });
  }
}

// Handle events and rendering
// ...
```

Check our [examples page](/examples/browse/cursors) for live demos.

### Room.subscribe("status") [#Room.subscribe.status]

Subscribe to WebSocket connection status updates. Takes a callback that is
called whenever the connection status changes. Possible value are: `initial`,
`connecting`, `connected`, `reconnecting`, or `disconnected`. Returns an
unsubscribe function.

```ts
const unsubscribe = room.subscribe("status", (status) => {
  // "connected"
  console.log(status);
});
```

<PropertiesList title="Returns">
  <PropertiesListItem name="unsubscribe" type="() => void">
    Unsubscribe function. Call it to cancel the subscription.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem name="eventType" type={`"status"`} required>
    Listen to status updates.
  </PropertiesListItem>
  <PropertiesListItem
    name="callback"
    detailedType={`(status: "initial" | "connecting" | "connected" | "reconnecting" | "disconnected") => void`}
    required
  >
    <div className="-mb-3">
    Function thatâ€™s called when the roomâ€™s connection status has changed. It can return one of five values:
    </div>

    - `"initial"` The room has not attempted to connect yet.
    - `"connecting"` The room is currently authenticating or connecting.
    - `"connected"` The room is connected.
    - `"reconnecting"` The room has disconnected, and is trying to connect again.
    - `"disconnected"` The room is disconnected, and is no longer attempting to connect.

  </PropertiesListItem>
</PropertiesList>

#### When to use status

Status is a low-level API that exposes the WebSocketâ€™s connectivity status. You
can use this, for example, to update a connection status indicator in your UI.
It would be normal for a client to briefly lose the connection and restore it
with quick `connected` â†’ `reconnecting` â†’ `connected` status jumps.

```ts
let indicator = "âšª";

const unsubscribe = room.subscribe("status", (status) => {
  switch (status) {
    case "connecting":
      indicator = "ðŸŸ¡";
      break;
    case "connected":
      indicator = "ðŸŸ¢";
      break;
    // ...
  }
});
```

If youâ€™d like to let users know that there may be connectivity issues, donâ€™t use
this API, but instead refer to [`Room.subscribe("lost-connection")`][] which was
specially built for this purpose.

Do not use this API to detect when Storage or Presence are initialized or
loaded. "Connected" does not guarantee that Storage or Presence are ready. To
detect when Storage is loaded, rely on awaiting the [`Room.getStorage`][]
promise or using the [`Room.subscribe("storage-status")`][] event.

### Room.subscribe("lost-connection") [#Room.subscribe.lost-connection]

A special-purpose event that will fire when a previously connected Liveblocks
client has lost connection, for example due to a network outage, and was unable
to recover quickly. This event is
[designed to help improve UX for your users](#when-to-use-lost-connection-events),
and will not trigger on short interruptions, those that are less than
[5 seconds by default](#setting-lost-connection-timeout). The event only
triggers if a previously connected client disconnects.

```ts
const unsubscribe = room.subscribe("lost-connection", (event) => {
  // "lost"
  console.log(event);
});
```

<PropertiesList title="Returns">
  <PropertiesListItem name="unsubscribe" type="() => void">
    Unsubscribe function. Call it to cancel the subscription.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem name="eventType" type={`"lost-connection"`} required>
    Listen to lost connection events.
  </PropertiesListItem>
  <PropertiesListItem
    name="callback"
    detailedType={`(event: "lost" | "restored" | "failed") => void`}
    required
  >
    <div className="-mb-3">
    Function thatâ€™s called when a roomâ€™s lost connection event has been triggered. It can return one of three values:
    </div>

    - `"lost"` A connection has been lost for longer than [`lostConnectionTimeout`][].
    - `"restored"` The connection has been restored again.
    - `"failed"` The room has been unable to reconnect again, and is no longer trying. This may happen if a userâ€™s
    network has recovered, but the roomâ€™s authentication values no longer allow them to enter.

  </PropertiesListItem>
</PropertiesList>

#### When to use lost connection events [#when-to-use-lost-connection-events]

Lost connections events allows you to build high-quality UIs by warning your
users that the application is still trying to re-establish the connection, for
example through a toast notification. You may want to take extra care in the
mean time to ensure their changes wonâ€™t go unsaved, or to help them understand
why theyâ€™re not seeing updates made by others yet.

When this happens, this callback is called with the event `lost`. Then, once the
connection restores, the callback will be called with the value `restored`. If
the connection could definitively not be restored, it will be called with
`failed` (uncommon).

```ts
import { toast } from "my-preferred-toast-library";

const unsubscribe = room.subscribe("lost-connection", (event) => {
  switch (event) {
    case "lost":
      toast.warn("Still trying to reconnect...");
      break;

    case "restored":
      toast.success("Successfully reconnected again!");
      break;

    case "failed":
      toast.error("Could not restore the connection");
      break;
  }
});
```

#### Setting lost connection timeout [#setting-lost-connection-timeout]

The [`lostConnectionTimeout`][] configuration option will determine how quickly
the event triggers after a connection loss occurs. By default, itâ€™s set to
`5000`ms, which is 5 seconds.

```ts
import { createClient } from "@liveblocks/client";

const client = createClient({
  // Throw lost-connection event after 5 seconds offline
  lostConnectionTimeout: 5000,

  // ...
});
```

### Room.subscribe("error") [#Room.subscribe.error]

Subscribe to unrecoverable room connection errors. This event will be emitted
immediately before the client disconnects and wonâ€™t try reconnecting again.
Returns an unsubscribe function. If youâ€™d like to retry connecting, call
[`room.reconnect`][].

```ts
const unsubscribe = room.subscribe("error", (error) => {
  switch (error.context.code) {
    case -1:
      // Authentication error
      break;

    case 4001:
      // Could not connect because you donâ€™t have access to this room
      break;

    case 4005:
      // Could not connect because room was full
      break;

    case 4006:
      // The room ID has changed, get the new room ID (use this for redirecting)
      const newRoomId = error.message;
      break;

    default:
      // Unexpected error
      break;
  }
});
```

<PropertiesList title="Returns">
  <PropertiesListItem name="unsubscribe" type="() => void">
    Unsubscribe function. Call it to cancel the subscription.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem name="eventType" type={`"error"`} required>
    Listen to error events.
  </PropertiesListItem>
  <PropertiesListItem
    name="callback"
    detailedType={`(error: LiveblocksError) => void`}
    required
  >
    <div className="-mb-3">
    Function thatâ€™s called when an unrecoverable error event has been triggered. `error.code` can return one of these
    values:
    </div>

    - `-1` Authentication error.
    - `4001` Could not connect because you donâ€™t have access to this room.
    - `4005` Could not connect because room was full.
    - `4006` The room ID has changed.

  </PropertiesListItem>
</PropertiesList>

#### When to use error events

You can use this event to trigger a â€œNot allowedâ€ screen/dialog. It can also be
helpful for implementing a redirect to another page.

```ts
const unsubscribe = room.subscribe("error", (error) => {
  // Could not connect because you donâ€™t have access to this room
  if (error.context.code === 4001)
    return __displayForbiddenEntryDialog__();
  }
});
```

#### When a room ID has changed

When a room ID has been changed with
[`liveblocks.updateRoomId`](/docs/api-reference/liveblocks-node#post-rooms-update-roomId)
or the
[Update Room ID API](/docs/api-reference/rest-api-endpoints#post-rooms-update-roomId),
`error.message` will contain the new room ID.

```ts
const unsubscribe = room.subscribe("error", (error) => {
  // The room ID has changed, get the new room ID
  if (error.context.code === 4006)
    const newRoomId = error.message;
    return __redirect__(`/app/${newRoomId}`)
  }
});
```

### Room.subscribe("history") [#Room.subscribe.history]

Subscribe to the current userâ€™s history changes. Returns an unsubscribe
function.

```ts
const unsubscribe = room.subscribe("history", ({ canUndo, canRedo }) => {
  // Do something
});
```

<PropertiesList title="Returns">
  <PropertiesListItem name="unsubscribe" type="() => void">
    Unsubscribe function. Call it to cancel the subscription.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem name="eventType" type={`"history"`} required>
    Listen to history events.
  </PropertiesListItem>
  <PropertiesListItem
    name="callback"
    detailedType={`({ canUndo: boolean, canRedo: boolean }) => void`}
    required
  >
    Function thatâ€™s called when the current userâ€™s history changes. Returns
    booleans that describe whether the user can use
    [undo](/docs/api-reference/liveblocks-client#Room.history.undo) or
    [redo](/docs/api-reference/liveblocks-client#Room.history.redo).
  </PropertiesListItem>
</PropertiesList>

### Room.subscribe("storage-status") [#Room.subscribe.storage-status]

Subscribe to Storage status changes. Use this to tell whether Storage has been
synchronized with the Liveblocks servers. Returns an unsubscribe function.

```ts
const unsubscribe = room.subscribe("storage-status", (status) => {
  switch (status) {
    case "not-loaded":
      // Storage has not been loaded yet
      break;
    case "loading":
      // Storage is currently loading
      break;
    case "synchronizing":
      // Local Storage changes are being synchronized
      break;
    case "synchronized":
      // Local Storage changes have been synchronized
      break;
  }
});
```

<PropertiesList title="Returns">
  <PropertiesListItem name="unsubscribe" type="() => void">
    Unsubscribe function. Call it to cancel the subscription.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem name="eventType" type={`"storage-status"`} required>
    Listen to Storage status events.
  </PropertiesListItem>
  <PropertiesListItem
    name="callback"
    detailedType={`(status: "not-loaded" | "loading" | "synchronizing" | "synchronized") => void`}
    required
  >
    <div className="-mb-3">
    Function thatâ€™s called when the current userâ€™s Storage updated status have
    changed. `status` can be one of four types.
    </div>

    - `"not-loaded` - Storage has not been loaded yet as [`getStorage`][] has not been called.
    - `"loading"` - Storage is currently loading for the first time.
    - `"synchronizing"` - Local Storage changes are currently being synchronized.
    - `"synchronized"` - Local Storage changes have been synchronized

  </PropertiesListItem>
</PropertiesList>

### Room.batch

Batches Storage and Presence modifications made during the given function. Each
modification is grouped together, which means that other clients receive the
changes as a single message after the batch function has run. When undoing or
redoing these changes, the entire batch will be undone/redone together instead
of atomically.

```ts
const { root } = await room.getStorage();

room.batch(() => {
  root.set("x", 0);
  room.updatePresence({ cursor: { x: 100, y: 100 } });
});
```

<PropertiesList title="Returns">
  <PropertiesListItem name="return" type="T">
    Returns the return value from the callback.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem name="callback" type="() => T" required>
    A callback containing every Storage and Presence notification that will be
    part of the batch. Cannot be an `async` function.
  </PropertiesListItem>
</PropertiesList>

#### When to batch updates

For the most part, _you donâ€™t need to batch updates_. For example, given a
[whiteboard application](/examples/browse/whiteboard), itâ€™s perfectly fine to
update a noteâ€™s position on the board multiple times per second, in separate
updates. However, should you implement a â€œDelete allâ€ button, that may delete 50
notes at once, this is where you should use a batch.

```ts
const { root } = await room.getStorage();
const notes = root.get("notes");

// âœ… Batch simultaneous changes together
room.batch(() => {
  for (const noteId of notes.keys()) {
    notes.delete(noteId);
  }
});
```

This batch places each
[`LiveMap.delete`](/docs/api-reference/liveblocks-client#LiveMap.delete) call
into a single WebSocket update, instead of sending multiple updates. This will
be much quicker.

#### Batching groups history changes

Batching changes will also group changes into a single history state.

```ts
const { root } = await room.getStorage();
const pet = root.set("pet", new LiveObject({ name: "Fido", age: 5 }));

// âœ… Batch groups changes into one
room.batch(() => {
  pet.set("name", "Felix");
  pet.set("age", 10);
});

// { name: "Felix", age: 10 }
pet.toImmutable();

room.history.undo();

// { name: "Fido", age: 5 }
pet.toImmutable();
```

#### Doesnâ€™t work with async functions

Note that `room.batch` cannot take an `async` function.

```tsx
// âŒ Wonâ€™t work
room.batch(async () => {
  // ...
});

// âœ… Will work
room.batch(() => {
  // ...
});
```

### Room.history

Roomâ€™s history contains functions that let you undo and redo operations made to
Storage and Presence on the current client. Each user has a separate history
stored in memory, and history is reset when the page is reloaded.

```ts
const { undo, redo, pause, resume /*, ... */ } = room.history;
```

<Banner title="History in Yjs">

Note that to undo or redo in Yjs, you must use a separate history manager,
[`Y.UndoManager`](https://docs.yjs.dev/api/undo-manager).

</Banner>

#### Add Presence to history

By default, history is only enabled for Storage. However, you can use the
`addToHistory` option to additionally
[add Presence state to history](/docs/api-reference/liveblocks-client#add-presence-to-history).

```tsx
room.updatePresence({ color: "blue" }, { addToHistory: true });
```

### Room.history.undo

Reverts the last operation. It does not impact operations made by other clients,
and will only undo changes made by the current client.

```ts
const person = new LiveObject();
person.set("name", "Pierre");
person.set("name", "Jonathan");

room.history.undo();

// "Pierre"
root.get("name");
```

<PropertiesListEmpty title="Returns">_Nothing_</PropertiesListEmpty>

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

### Room.history.redo

Restores the last undone operation. It does not impact operations made by other
clients, and will only restore changes made by the current client.

```ts
const person = new LiveObject();
person.set("name", "Pierre");
person.set("name", "Jonathan");

room.history.undo();
room.history.redo();

// "Jonathan"
root.get("name");
```

<PropertiesListEmpty title="Returns">_Nothing_</PropertiesListEmpty>

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

### Room.history.canUndo

Returns true or false, depending on whether there are any operations to undo.
Helpful for disabling undo buttons.

```ts
const person = new LiveObject();
person.set("name", "Pierre");

// true
room.history.canUndo();

room.history.undo();

// false
room.history.canUndo();
```

<PropertiesList title="Returns">
  <PropertiesListItem name="canUndo" type="boolean">
    Whether there is an undo operation in the current history stack.
  </PropertiesListItem>
</PropertiesList>

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

### Room.history.canRedo

Returns true or false, depending on whether there are any operations to redo.
Helpful for disabling redo buttons.

```ts
const person = new LiveObject();
person.set("name", "Pierre");

// false
room.history.canRedo();

room.history.undo();

// true
room.history.canRedo();
```

<PropertiesList title="Returns">
  <PropertiesListItem name="canRedo" type="boolean">
    Whether there is a redo operation in the current history stack.
  </PropertiesListItem>
</PropertiesList>

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

### Room.history.clear

Clears the undo and redo stacks for the current client. Explicitly clearing
history resets the ability to undo beyond the current document state. Other
clientsâ€™ histories are unaffected.

```ts
const person = new LiveObject();
person.set("name", "Pierre");

// true
room.history.canUndo();

room.history.clear();

// false
room.history.canUndo();
```

<PropertiesListEmpty title="Returns">_Nothing_</PropertiesListEmpty>

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

### Room.history.pause

All future modifications made on the Room will be merged together to create a
single history item until resume is called.

```ts
const info = new LiveObject({ time: "one" });

room.history.pause();
info.set("time", "two");
info.set("time", "three");
room.history.resume();

room.history.undo();

// "one"
room.get("time");
```

<PropertiesListEmpty title="Returns">_Nothing_</PropertiesListEmpty>

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

### Room.history.resume

Resumes history after a [pause](#Room.history.pause). Modifications made on the
Room are not merged into a single history item any more.

```ts
const info = new LiveObject({ time: "one" });

room.history.pause();
info.set("time", "two");
info.set("time", "three");
room.history.resume();

room.history.undo();

// "one"
room.get("time");
```

<PropertiesListEmpty title="Returns">_Nothing_</PropertiesListEmpty>

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

### Room.connect

Connect the local room instance to the Liveblocks server. Does nothing if the
room is already connecting, reconnecting or connected. We donâ€™t recommend using
this API directly.

```ts
room.connect();
```

<PropertiesListEmpty title="Returns">_Nothing_</PropertiesListEmpty>

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

### Room.reconnect

Reconnect the local room instance to the Liveblocks server, using a new
WebSocket connection.

```ts
room.reconnect();
```

<PropertiesListEmpty title="Returns">_Nothing_</PropertiesListEmpty>

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

### Room.disconnect

Disconnect the local room instance from the Liveblocks server. The room instance
will remain functional (for example, it will still allow local presence or
storage mutations), but since itâ€™s no longer connected, changes will not be
persisted or synchronized until the room instance is reconnected again. We donâ€™t
recommend using this API directly.

```ts
room.disconnect();
```

<PropertiesListEmpty title="Returns">_Nothing_</PropertiesListEmpty>

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

## Comments

### Room.getThreads

Returns threads, and their associated inbox notifications and subscriptions,
that are in the current room. It also returns the request date that can be used
for subsequent polling. Itâ€™s possible to filter for
[a threadâ€™s resolved status](#filtering-resolved-status) and using
[custom metadata](#filtering-metadata).

```ts
const { threads, inboxNotifications, requestedAt } = await room.getThreads();

// [{ id: "th_s436g8...", type: "thread" }, ...]
console.log(threads);

// [{ id: "in_fwh3d4...", kind: "thread", }, ...]
console.log(inboxNotifications);
```

<PropertiesList title="Returns">
  <PropertiesListItem name="threads" type="ThreadData[]">
    Threads within the current room.
  </PropertiesListItem>
  <PropertiesListItem name="inboxNotifications" type="InboxNotificationData[]">
    Inbox notifications associated with the threads.
  </PropertiesListItem>
  <PropertiesListItem name="subscriptions" type="SubscriptionData[]">
    Subscriptions associated with the threads.
  </PropertiesListItem>
  <PropertiesListItem name="requestedAt" type="Date">
    The request date to use for subsequent polling.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Options">
  <PropertiesListItem name="resolved" type="boolean">
    Only return `resolved` or `unresolved` threads. [Learn more](#filtering-resolved-status).
  </PropertiesListItem>
  <PropertiesListItem name="subscribed" type="boolean">
    Only return `subscribed` or `unsubscribed` threads. [Learn more](#filtering-subscribed-status).
  </PropertiesListItem>
  <PropertiesListItem name="metadata" type="Partial<ThreadMetadata>">
    Only return threads containing the custom metadata. Metadata is set yourself when creating a thread, for example `{ priority: "HIGH" }`. [Learn more](#filtering-metadata).
  </PropertiesListItem>
</PropertiesList>

#### Filtering resolved status [#filtering-resolved-status]

You can filter threads by those that are resolved, or unresolved, by passing a
`boolean` to `query.resolved`.

```ts
// Filtering for threads that are unresolved
const threads = await room.getThreads({
  query: {
    // +++
    resolved: false,
    // +++
  },
});
```

#### Filtering subscribed status [#filtering-subscribed-status]

You can filter threads by those that the user is subscribed to, or not, by
passing a `boolean` to `query.subscribed`.

```ts
// Filtering for threads that the user is subscribed to
const threads = await room.getThreads({
  query: {
    // +++
    subscribed: true,
    // +++
  },
});
```

#### Filtering metadata [#filtering-metadata]

You can define custom metadata when
[creating a thread](/docs/api-reference/liveblocks-client#Room.createThread),
and the `query.metadata` option allows you to return only threads that match.

```ts
// Creating a thread with `priority` metadata
await room.createThread({
  body: {
    // ...
  },
  // +++
  metadata: { priority: "HIGH" },
  // +++
});

// Filtering for threads with the same metadata
const threads = await room.getThreads({
  query: {
    // +++
    metadata: { priority: "HIGH" },
    // +++
  },
});
```

You can also filter for metadata that begins with a specific string.

```ts
// Creating a thread with `{ assigned: "sales:stacy" } metadata
await room.createThread({
  body: {
    // ...
  },
  // +++
  metadata: { assigned: "sales:stacy" },
  // +++
});

// Filtering for threads with `assigned` metadata that starts with `sales:`
const threads = await room.getThreads({
  query: {
    // +++
    metadata: {
      assigned: {
        startsWith: "sales:",
      },
    },
    // +++
  },
});
```

You can also filter for metadata using numeric operators.

```ts
// Creating a thread with `{ posX: 87, level: 5 } metadata
await room.createThread({
  body: {
    // ...
  },
  // +++
  metadata: { posX: 87, level: 5 },
  // +++
});

// Filtering for threads with `posX` greater than 50 and lower than 100, and level greater than or equal to 5
const threads = await room.getThreads({
  query: {
    // +++
    metadata: {
      posX: {
        gt: 50,
        lt: 100,
      },
      level: {
        gte: 5,
      },
    },
    // +++
  },
});
```

### Room.getThreadsSince

Returns threads, and their associated inbox notifications and subscriptions,
that have been updated or deleted since the requested date. Helpful when used in
combination with [`Room.getThreads`](#Room.getThreads) to initially fetch all
threads, then receive updates later.

```ts
const initial = await room.getThreads();

const { threads, inboxNotifications, subscriptions, requestedAt } =
  await room.getThreadsSince({ since: initial.requestedAt });

// { updated: [{ id: "th_s4368s...", type: "thread" }, ...], deleted: [...] }
console.log(threads);

// { updated: [{ id: "in_ds83hs...", kind: "thread", }, ...], deleted: [...] }
console.log(inboxNotifications);

// { updated: [{ subjectId: "th_s4368s...", kind: "thread", }, ...], deleted: [...] }
console.log(subscriptions);
```

<PropertiesList title="Returns">
  <PropertiesListItem
    name="threads"
    detailedType="{ updated: ThreadData[], deleted: ThreadDeleteInfo[] }"
  >
    Threads that have been updated or deleted since the requested date.
  </PropertiesListItem>
  <PropertiesListItem
    name="inboxNotifications"
    detailedType="{ updated: InboxNotificationData[], deleted: InboxNotificationDeleteInfo[] }"
  >
    Inbox notifications that have been updated or deleted since the requested
    date.
  </PropertiesListItem>
  <PropertiesListItem
    name="subscriptions"
    detailedType="{ updated: SubscriptionData[], deleted: SubscriptionDeleteInfo[] }"
  >
    Subscriptions that have been updated or deleted since the requested date.
  </PropertiesListItem>
  <PropertiesListItem name="requestedAt" type="Date">
    The request date to use for subsequent polling.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Options">
  <PropertiesListItem name="since" type="Date" required>
    Only return threads that have been updated or deleted after this date.
  </PropertiesListItem>
</PropertiesList>

### Room.getThread

Returns a thread and its associated inbox notification and subscription, from
its ID, if it exists.

```ts
const { thread, inboxNotification, subscription } =
  await room.getThread("th_xxx");
```

The thread ID can be retrieved from existing threads.

```ts
const newThread = await room.createThread(/* ... */);

const { thread, inboxNotification } = await room.getThread(newThread.id);
```

<PropertiesList title="Returns">
  <PropertiesListItem name="thread" type="ThreadData | undefined">
    The requested thread, or `undefined` if it doesnâ€™t exist.
  </PropertiesListItem>
  <PropertiesListItem
    name="inboxNotification"
    type="InboxNotificationThreadData | undefined"
  >
    The inbox notification associated with the thread, or `undefined` if it
    doesnâ€™t exist.
  </PropertiesListItem>
  <PropertiesListItem name="subscription" type="SubscriptionData | undefined">
    The subscription associated with the thread, or `undefined` if it doesnâ€™t
    exist.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem name="value" type="string" required>
    The ID of the thread you want to retrieve.
  </PropertiesListItem>
</PropertiesList>

### Room.createThread

Creates a thread, and its initial comment, in the current room. A commentâ€™s body
is an array of paragraphs, each containing child nodes, learn more under
[creating thread content](#creating-thread-content).

```ts
const thread = await room.createThread({
  body: {
    version: 1,
    content: [{ type: "paragraph", children: [{ text: "Hello" }] }],
  },
});
```

<PropertiesList title="Returns">
  <PropertiesListItem name="value" type="ThreadData">
    The thread that has been created.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Options">
  <PropertiesListItem name="body" type="CommentBody" required>
    The content of the comment, see [creating thread
    content](#creating-thread-content).
  </PropertiesListItem>
  <PropertiesListItem name="attachmentIds" type="string[]">
    The IDs of the commentâ€™s attachments.
  </PropertiesListItem>
  <PropertiesListItem name="commentMetadata" type="CommentMetadata">
    Custom metadata to be attached to the initial comment, see [defining comment
    metadata](#defining-comment-metadata).
  </PropertiesListItem>
  <PropertiesListItem name="metadata" type="ThreadMetadata">
    Custom metadata to be attached to the thread, see [defining thread
    metadata](#defining-thread-metadata).
  </PropertiesListItem>
</PropertiesList>

#### Creating thread content [#creating-thread-content]

A commentâ€™s body is an array of paragraphs, each containing child nodes. Hereâ€™s
an example of how to construct the following simple comment body, which can be
passed to `room.createThread`.

> Hello **world**
>
> <div className="h-2"></div>
> _Second_ paragraph!

```tsx
import { CommentBody } from "@liveblocks/client";

const body: CommentBody = {
  version: 1,
  content: [
    // +++
    {
      type: "paragraph",
      children: [{ text: "Hello " }, { text: "world", bold: true }],
    },
    {
      type: "paragraph",
      children: [{ text: "Second", italic: true }, { text: " paragraph!" }],
    },
    // +++
  ],
};

const thread = await room.createThread({ body });
```

Itâ€™s also possible to create links and mentions.

> <span title="jody.hekla">**@Jody Hekla**</span> the
> **[Liveblocks](https://liveblocks.io)** website is cool!

```ts
const body: CommentBody = {
  version: 1,
  content: [
    // +++
    {
      type: "paragraph",
      children: [
        { type: "mention", id: "jody.hekla" },
        { text: " the " },
        { text: "Liveblocks", type: "link", url: "https://liveblocks.io" },
        { text: " website is cool!" },
      ],
    },
    // +++
  ],
};
```

#### Defining thread metadata [#defining-thread-metadata]

Custom metadata can be attached to each thread. `string`, `number`, and
`boolean` properties are allowed.

```ts
const metadata: Liveblocks["ThreadMetadata"] = {
  color: "blue",
  page: 3,
  pinned: true,
};

const thread = await room.createThread({ body, metadata });
```

### Room.deleteThread

Deletes a thread by its ID.

```ts
await room.deleteThread("th_xxx");
```

<PropertiesListEmpty title="Returns">_Nothing_</PropertiesListEmpty>

<PropertiesList title="Arguments">
  <PropertiesListItem name="threadId" type="string" required>
    The ID of the thread to delete.
  </PropertiesListItem>
</PropertiesList>

### Room.editThreadMetadata

Edits a threadâ€™s custom metadata. Metadata can be a `string`, `number`, or
`boolean`. To delete an existing metadata property, set its value to `null`.

```ts
await room.editThreadMetadata({
  threadId: "th_xxx",
  metadata: {
    color: "blue",
    page: 3,
    pinned: true,
  },
});
```

<PropertiesList title="Returns">
  <PropertiesListItem name="metadata" type="ThreadMetadata">
    The thread metadata.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Options">
  <PropertiesListItem name="threadId" type="string" required>
    The ID of the thread.
  </PropertiesListItem>
  <PropertiesListItem name="metadata" type="Patchable<ThreadMetadata>" required>
    An object containing the metadata properties to update. Metadata can be a
    `string`, `number`, or `boolean`. To delete an existing metadata property,
    set its value to `null`.
  </PropertiesListItem>
</PropertiesList>

### Room.markThreadAsResolved

Marks a thread as resolved.

```ts
await room.markThreadAsResolved("th_xxx");
```

<PropertiesListEmpty title="Returns">_Nothing_</PropertiesListEmpty>

<PropertiesList title="Arguments">
  <PropertiesListItem name="threadId" type="string" required>
    The ID of the thread to resolve.
  </PropertiesListItem>
</PropertiesList>

### Room.markThreadAsUnresolved

Marks a thread as unresolved.

```ts
await room.markThreadAsUnresolved("th_xxx");
```

<PropertiesListEmpty title="Returns">_Nothing_</PropertiesListEmpty>

<PropertiesList title="Arguments">
  <PropertiesListItem name="threadId" type="string" required>
    The ID of the thread to resolve.
  </PropertiesListItem>
</PropertiesList>

### Room.subscribeToThread

Subscribes the user to a thread, meaning they will receive inbox notifications
when new comments are posted.

```ts
await room.subscribeToThread("th_xxx");
```

<PropertiesList title="Returns">
  <PropertiesListItem name="value" type="SubscriptionData">
    The threadâ€™s subscription.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem name="threadId" type="string" required>
    The ID of the thread to subscribe to.
  </PropertiesListItem>
</PropertiesList>

#### Replacing room-level subscriptions

Subscribing will replace any existing subscription for the current thread
[set at room-level](#Room.updateSubscriptionSettings). This value can also be
overridden by a room-level call that is run afterwards.

```ts
// 1. Disables notifications for all threads
await room.updateSubscriptionSettings({
  threads: "none",
});

// 2. Enables notifications just for this thread, "th_d75sF3..."
await room.subscribeToThread("th_d75sF3...");

// 3. Disables notifications for all threads, including "th_d75sF3..."
await room.updateSubscriptionSettings({
  threads: "none",
});
```

### Room.unsubscribeFromThread

Unsubscribes the user from a thread, meaning they will no longer receive inbox
notifications when new comments are posted.

```ts
await room.unsubscribeFromThread("th_xxx");
```

<PropertiesListEmpty title="Returns">_Nothing_</PropertiesListEmpty>

<PropertiesList title="Arguments">
  <PropertiesListItem name="threadId" type="string" required>
    The ID of the thread to unsubscribe from.
  </PropertiesListItem>
</PropertiesList>

#### Replacing room-level unsubscriptions

Unsubscribing will replace any existing unsubscription for the current thread
[set at room-level](#Room.updateSubscriptionSettings). This value can also be
overridden by a room-level call that is run afterwards.

```ts
// 1. Enable notifications for all threads
await room.updateSubscriptionSettings({
  threads: "all",
});

// 2. Disables notifications just for this thread, "th_d75sF3..."
await room.unsubscribeFromThread("th_d75sF3...");

// 3. Enables notifications for all threads, including "th_d75sF3..."
await room.updateSubscriptionSettings({
  threads: "all",
});
```

### Room.createComment

Creates a comment in a given thread.

```ts
const comment = await room.createComment({
  threadId: "th_xxx",
  body: {
    version: 1,
    content: [{ type: "paragraph", children: [{ text: "Hello" }] }],
  },
});
```

<PropertiesList title="Returns">
  <PropertiesListItem name="value" type="CommentData">
    The comment that has been created.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Options">
  <PropertiesListItem name="threadId" type="string" required>
    The ID of the thread that the comment will be added to.
  </PropertiesListItem>
  <PropertiesListItem name="body" type="CommentBody" required>
    The content of the comment, see [creating comment
    content](#creating-comment-content).
  </PropertiesListItem>
  <PropertiesListItem name="attachmentIds" type="string[]">
    The IDs of the commentâ€™s attachments.
  </PropertiesListItem>
  <PropertiesListItem name="metadata" type="CommentMetadata">
    Custom metadata to be attached to the comment, see [defining comment
    metadata](#defining-comment-metadata).
  </PropertiesListItem>
</PropertiesList>

#### Creating comment content [#creating-comment-content]

A commentâ€™s body is an array of paragraphs, each containing child nodes. Hereâ€™s
an example of how to construct the following simple comment body, which can be
passed to `room.createComment`.

> Hello **world**
>
> <div className="h-2"></div>
> _Second_ paragraph!

```tsx
import { CommentBody } from "@liveblocks/client";

const thread = await room.createThread(/* ... */);

const body: CommentBody = {
  version: 1,
  content: [
    // +++
    {
      type: "paragraph",
      children: [{ text: "Hello " }, { text: "world", bold: true }],
    },
    {
      type: "paragraph",
      children: [{ text: "Second", italic: true }, { text: " paragraph!" }],
    },
    // +++
  ],
};

const comment = await room.createComment({ threadId: thread.id, body });
```

Itâ€™s also possible to create links and mentions.

> <span title="jody.hekla">**@Jody Hekla**</span> the
> **[Liveblocks](https://liveblocks.io)** website is cool!

```ts
const body: CommentBody = {
  version: 1,
  content: [
    // +++
    {
      type: "paragraph",
      children: [
        { type: "mention", id: "jody.hekla" },
        { text: " the " },
        { text: "Liveblocks", type: "link", url: "https://liveblocks.io" },
        { text: " website is cool!" },
      ],
    },
    // +++
  ],
};
```

#### Defining comment metadata [#defining-comment-metadata]

Custom metadata can be attached to each comment. `string`, `number`, and
`boolean` properties are allowed.

```ts
const metadata: Liveblocks["CommentMetadata"] = {
  priority: 2,
  reviewed: true,
};

const comment = await room.createComment({
  threadId: "th_xxx",
  body,
  metadata,
});
```

### Room.editComment

Edits a comment, replacing its existing comment body and optionally updating its
attachments and metadata. Learn more about
[creating comment content](#creating-comment-content).

```ts
const comment = await room.editComment({
  threadId: "th_xxx",
  commentId: "cm_xxx",
  body: {
    version: 1,
    content: [{ type: "paragraph", children: [{ text: "Hello" }] }],
  },
});
```

<PropertiesList title="Returns">
  <PropertiesListItem name="value" type="CommentData">
    The comment that has been edited.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Options">
  <PropertiesListItem name="threadId" type="string" required>
    The ID of the thread containing the comment.
  </PropertiesListItem>
  <PropertiesListItem name="commentId" type="string" required>
    The ID of the comment thatâ€™s being edited.
  </PropertiesListItem>
  <PropertiesListItem name="body" type="CommentBody" required>
    The content of the comment, see [creating comment
    content](#creating-comment-content).
  </PropertiesListItem>
  <PropertiesListItem name="attachmentIds" type="string[]">
    The IDs of the commentâ€™s attachments.
  </PropertiesListItem>
  <PropertiesListItem name="metadata" type="CommentMetadata">
    Custom metadata to be attached to the comment.
  </PropertiesListItem>
</PropertiesList>

### Room.editCommentMetadata

Edits a commentâ€™s custom metadata. Metadata can be a `string`, `number`, or
`boolean`. To delete an existing metadata property, set its value to `null`.

```ts
await room.editCommentMetadata({
  threadId: "th_xxx",
  commentId: "cm_xxx",
  metadata: {
    tag: "important",
    priority: 2,
    flagged: true,
  },
});
```

<PropertiesList title="Returns">
  <PropertiesListItem name="metadata" type="CommentMetadata">
    The comment metadata.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Options">
  <PropertiesListItem name="threadId" type="string" required>
    The ID of the thread containing the comment.
  </PropertiesListItem>
  <PropertiesListItem name="commentId" type="string" required>
    The ID of the comment.
  </PropertiesListItem>
  <PropertiesListItem
    name="metadata"
    type="Patchable<CommentMetadata>"
    required
  >
    An object containing the metadata properties to update. Metadata can be a
    `string`, `number`, or `boolean`. To delete an existing metadata property,
    set its value to `null`.
  </PropertiesListItem>
</PropertiesList>

### Room.deleteComment

Deletes a comment. If it is the last non-deleted comment, the thread also gets
deleted.

```ts
await room.deleteComment({
  threadId: "th_xxx",
  commentId: "cm_xxx",
});
```

<PropertiesListEmpty title="Returns">_Nothing_</PropertiesListEmpty>

<PropertiesList title="Options">
  <PropertiesListItem name="threadId" type="string" required>
    The ID of the thread containing the comment.
  </PropertiesListItem>
  <PropertiesListItem name="commentId" type="string" required>
    The ID of the comment thatâ€™s being edited.
  </PropertiesListItem>
</PropertiesList>

### Room.addReaction

Adds a reaction from the current user on a comment.

```ts
const reaction = await room.addReaction({
  threadId: "th_xxx",
  commentId: "cm_xxx",
  emoji: "ðŸ‘",
});
```

<PropertiesList title="Returns">
  <PropertiesListItem name="value" type="CommentUserReaction">
    The reaction that has been created.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Options">
  <PropertiesListItem name="threadId" type="string" required>
    The ID of the thread containing the comment.
  </PropertiesListItem>
  <PropertiesListItem name="commentId" type="string" required>
    The ID of the comment to add a reaction to.
  </PropertiesListItem>
  <PropertiesListItem name="emoji" type="string" required>
    The emoji reaction to add.
  </PropertiesListItem>
</PropertiesList>

### Room.removeReaction

Removes a reaction from a comment.

```ts
await room.removeReaction({
  threadId: "th_xxx",
  commentId: "cm_xxx",
  emoji: "ðŸ‘",
});
```

<PropertiesListEmpty title="Returns">_Nothing_</PropertiesListEmpty>

<PropertiesList title="Options">
  <PropertiesListItem name="threadId" type="string" required>
    The ID of the thread containing the comment.
  </PropertiesListItem>
  <PropertiesListItem name="commentId" type="string" required>
    The ID of the comment to remove a reaction from.
  </PropertiesListItem>
  <PropertiesListItem name="emoji" type="string" required>
    The emoji reaction to remove.
  </PropertiesListItem>
</PropertiesList>

### Room.prepareAttachment

Creates a local attachment from a file.

```ts
const attachment = room.prepareAttachment({
  file: new File(["Hello, world!"], "hello.txt"),
});

// { "id": "at_1e6nNX...", "name": "hello.txt", "type": "attachment", ... }
console.log(attachment);
```

<PropertiesList title="Returns">
  <PropertiesListItem name="value" type="CommentLocalAttachment">
    The local attachment that has been created.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem name="file" type="File" required>
    The file to create the attachment from.
  </PropertiesListItem>
</PropertiesList>

### Room.uploadAttachment

Uploads a local attachment.

```ts
const attachment = room.prepareAttachment(file);
await room.uploadAttachment(attachment);
```

Optionally, an
[`AbortSignal`](https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal)
can be passed to cancel the upload.

```ts
const attachment = room.prepareAttachment(file);

// Cancel the upload after 5 seconds
room.uploadAttachment(attachment, { signal: AbortSignal.timeout(5000) });
```

<PropertiesList title="Returns">
  <PropertiesListItem name="value" type="CommentAttachment">
    The attachment that has been uploaded.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem name="attachment" type="CommentLocalAttachment" required>
    The file to create the attachment from.
  </PropertiesListItem>
  <PropertiesListItem name="options" type="UploadAttachmentOptions">
    A set of options.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Options">
  <PropertiesListItem name="signal" type="AbortSignal">
    Only the inbox notifications updated or deleted after this date will be
    returned.
  </PropertiesListItem>
</PropertiesList>

### Room.getAttachmentUrl

Returns a presigned URL for an attachment by its ID.

```ts
const url = await room.getAttachmentUrl("at_xxx");

// "https://..."
console.log(url);
```

<PropertiesList title="Returns">
  <PropertiesListItem name="value" type="string">
    A presigned URL for the attachment.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem name="attachmentId" type="string" required>
    The ID of the attachment to get the URL for.
  </PropertiesListItem>
</PropertiesList>

## Notifications

### Client.getInboxNotifications

Returns the current userâ€™s inbox notifications and their associated threads and
subscriptions. It also returns the request date that can be used for subsequent
polling.

```ts
const { inboxNotifications, threads, subscriptions, requestedAt } =
  await client.getInboxNotifications();

// [{ id: "in_fwh3d4...", kind: "thread", }, ...]
console.log(inboxNotifications);

// [{ id: "th_s436g8...", type: "thread" }, ...]
console.log(threads);

// [{ subjectId: "th_s436g8...", kind: "thread", }, ...]
console.log(subscriptions);
```

<PropertiesList title="Returns">
  <PropertiesListItem name="inboxNotifications" type="InboxNotificationData[]">
    Current userâ€™s inbox notifications.
  </PropertiesListItem>
  <PropertiesListItem name="threads" type="ThreadData[]">
    Threads associated with the inbox notifications.
  </PropertiesListItem>
  <PropertiesListItem name="subscriptions" type="SubscriptionData[]">
    Subscriptions associated with the inbox notifications.
  </PropertiesListItem>
  <PropertiesListItem name="requestedAt" type="Date">
    The request date to use for subsequent polling.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Options">
  <PropertiesListItem name="roomId" type="string">
    Only return inbox notifications for the given room. [Learn
    more](#filtering-inbox-notifications).
  </PropertiesListItem>
  <PropertiesListItem name="kind" type="string">
    Only return inbox notifications for the kind. [Learn
    more](#filtering-inbox-notifications).
  </PropertiesListItem>
</PropertiesList>

#### Filtering inbox notifications [#filtering-inbox-notifications]

You can filter inbox notifications by those that are associated with a specific
room or kind, by passing a `string` to `query.roomId` or `query.kind`.

```ts
// Filtering for inbox notifications that are associated with a specific room or kind
const { inboxNotifications } = await client.getInboxNotifications({
  query: {
    // +++
    roomId: "room1",
    kind: "thread",
    // +++
  },
});
```

### Client.getInboxNotificationsSince

Returns the updated and deleted inbox notifications and their associated threads
and subscriptions since the requested date. Helpful when used in combination
with [`Client.getInboxNotifications`](#Client.getInboxNotifications) to
initially fetch all notifications, then receive updates later.

```ts
const initial = await client.getInboxNotifications();

const { inboxNotifications, threads, subscriptions, requestedAt } =
  await client.getInboxNotificationsSince({ since: initial.requestedAt });

// { updated: [{ id: "in_ds83hs...", kind: "thread", }, ...], deleted: [...] }
console.log(inboxNotifications);

// { updated: [{ id: "th_s4368s...", type: "thread" }, ...], deleted: [...] }
console.log(threads);

// { updated: [{ subjectId: "th_s4368s...", kind: "thread", }, ...], deleted: [...] }
console.log(subscriptions);
```

<PropertiesList title="Returns">
  <PropertiesListItem
    name="inboxNotifications"
    detailedType="{ updated: InboxNotificationData[], deleted: InboxNotificationDeleteInfo[] }"
  >
    Inbox notifications that have been updated or deleted since the requested
    date.
  </PropertiesListItem>
  <PropertiesListItem
    name="threads"
    detailedType="{ updated: ThreadData[], deleted: ThreadDeleteInfo[] }"
  >
    Threads that have been updated or deleted since the requested date.
  </PropertiesListItem>
  <PropertiesListItem name="requestedAt" type="Date">
    The request date to use for subsequent polling.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Options">
  <PropertiesListItem name="since" type="Date" required>
    Only the inbox notifications updated or deleted after this date will be
    returned.
  </PropertiesListItem>
</PropertiesList>

### Client.getUnreadInboxNotificationsCount

Gets the number of unread inbox notifications for the current user.

```ts
const count = await client.getUnreadInboxNotificationsCount();
```

<PropertiesList title="Returns">
  <PropertiesListItem name="value" type="number">
    Number of unread inbox notifications.
  </PropertiesListItem>
</PropertiesList>

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

### Client.markAllInboxNotificationsAsRead

Marks all inbox notifications as read, for the current user.

```ts
await client.markAllInboxNotificationsAsRead();
```

<PropertiesListEmpty title="Returns">_Nothing_</PropertiesListEmpty>

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

### Client.markInboxNotificationAsRead

Marks an inbox notification as read, for the current user.

```ts
await client.markInboxNotificationAsRead("in_xxx");
```

<PropertiesListEmpty title="Returns">_Nothing_</PropertiesListEmpty>

<PropertiesList title="Arguments">
  <PropertiesListItem name="inboxNotificationId" type="string" required>
    The ID of the inbox notification to be marked as read.
  </PropertiesListItem>
</PropertiesList>

### Client.deleteAllInboxNotifications

Deletes an inbox notification for the current user.

```ts
await client.deleteAllInboxNotifications();
```

<PropertiesListEmpty title="Returns">_Nothing_</PropertiesListEmpty>

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

### Client.deleteInboxNotification

Deletes an inbox notification for the current user.

```ts
await client.deleteInboxNotification("in_xxx");
```

<PropertiesListEmpty title="Returns">_Nothing_</PropertiesListEmpty>

<PropertiesList title="Arguments">
  <PropertiesListItem name="inboxNotificationId" type="string" required>
    The ID of the inbox notification to be deleted.
  </PropertiesListItem>
</PropertiesList>

### Room.getSubscriptionSettings

Gets the userâ€™s subscription settings for the current room. This notates which
[`inboxNotifications`](/docs/api-reference/liveblocks-client#Client.getInboxNotifications)
the current user receives in the current room.

```ts
const settings = await room.getSubscriptionSettings();
```

<PropertiesList title="Returns">
  <PropertiesListItem
    name="settings"
    type="{ threads, textMentions }"
  >
    Subscription settings for Liveblocks products.
  </PropertiesListItem>
  <PropertiesListItem
    name="settings.threads"
    type={`"all" | "replies_and_mentions" | "none"`}
  >
    <div className="-mb-3">
      Returns the current roomâ€™s subscription settings for threads. It can return one of three values:
    </div>

    - `"all"` Receive notifications for every activity in every thread.
    - `"replies_and_mentions"` Receive notifications for mentions and threads youâ€™re participating in.
    - `"none"` No notifications are received.

  </PropertiesListItem>
    <PropertiesListItem
    name="settings.textMentions"
    type={`"mine" | "none"`}
  >
    <div className="-mb-3">
      Returns the current roomâ€™s subscription settings for text mentions. It can be one of two values:
    </div>

    - `"mine"` Receive notifications for mentions of you.
    - `"none"` No notifications are received.

  </PropertiesListItem>
</PropertiesList>

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

### Room.updateSubscriptionSettings

Updates the userâ€™s subscription settings for the current room. Updating this
setting will change which
[`inboxNotifications`](/docs/api-reference/liveblocks-client#Client.getInboxNotifications)
the current user receives in the current room.

```ts
const settings = await room.updateSubscriptionSettings({
  threads: "replies_and_mentions",
});
```

<PropertiesList title="Returns">
  <PropertiesListItem
    name="settings"
    type="{ threads, textMentions }"
  >
    Subscription settings for Liveblocks products.
  </PropertiesListItem>
  <PropertiesListItem
    name="settings.threads"
    type={`"all" | "replies_and_mentions" | "none"`}
  >
    <div className="-mb-3">
      Returns the current roomâ€™s subscription settings for threads. It can return one of three values:
    </div>

    - `"all"` Receive notifications for every activity in every thread.
    - `"replies_and_mentions"` Receive notifications for mentions and threads youâ€™re participating in.
    - `"none"` No notifications are received.

  </PropertiesListItem>
    <PropertiesListItem
    name="settings.textMentions"
    type={`"mine" | "none"`}
  >
    <div className="-mb-3">
      Returns the current roomâ€™s subscription settings for text mentions. It can be one of two values:
    </div>

    - `"mine"` Receive notifications for mentions of you.
    - `"none"` No notifications are received.

  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Options">
    <PropertiesListItem
    name="threads"
    type={`"all" | "replies_and_mentions" | "none"`}
  >
    <div className="-mb-3">
      Sets the current roomâ€™s subscription settings for threads. It can be one of three values:
    </div>

    - `"all"` Receive notifications for every activity in every thread.
    - `"replies_and_mentions"` Receive notifications for mentions and threads youâ€™re participating in.
    - `"none"` No notifications are received.

  </PropertiesListItem>
  <PropertiesListItem
    name="textMentions"
    type={`"mine" | "none"`}
  >
    <div className="-mb-3">
      Sets the current roomâ€™s subscription settings for text mentions. It can be one of two values:
    </div>

    - `"mine"` Receive notifications for mentions of you.
    - `"none"` No notifications are received.

  </PropertiesListItem>
</PropertiesList>

#### Replacing individual thread subscriptions

Subscribing will replace any
[existing thread subscriptions](#Room.subscribeToThread) in the current room.
This value can also be overridden by a room-level call that is run afterwards.

```ts
// 1. Enables notifications just for this thread, "th_d75sF3..."
await room.subscribeToThread("th_d75sF3...");

// 2. Disables notifications for all threads, including "th_d75sF3..."
await room.updateSubscriptionSettings({
  threads: "none",
});
```

### Client.getNotificationSettings [@badge=Beta]

Returns the userâ€™s notification settings in the current project, in other words
which [notification webhook events](/docs/platform/webhooks#NotificationEvent)
will be sent for the current user. Notification settings are project-based,
which means that this returns the current userâ€™s settings for every room.

```ts
const settings = await client.getNotificationSettings();

// { email: { thread: true, ... }, slack: { thread: false, ... }, ... }
console.log(settings);
```

A userâ€™s initial settings are set in the dashboard, and different kinds should
be enabled there. If no kind is enabled on the current channel, `null` will be
returned. For example, with the email channel:

```ts
const settings = await client.getNotificationSettings();

// { email: null, ... }
console.log(settings);
```

<PropertiesList title="Returns">
  <PropertiesListItem name="settings" type="NotificationSettings">
    Current userâ€™s notification settings.
  </PropertiesListItem>
</PropertiesList>

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

### Client.updateNotificationSettings [@badge=Beta]

Updates the current userâ€™s notification settings, which affects which
[notification webhook events](/docs/platform/webhooks#NotificationEvent) will be
sent for the current user. Notification settings are project-based, which means
that this modifies the current userâ€™s settings in every room. Each notification
`kind` must first be enabled on your projectâ€™s notification dashboard page
before settings can be used.

```ts
const settings = await client.updateNotificationSettings({
  email: { thread: false },
  slack: { textMention: true },
});

// { email: { thread: false, ... }, slack: { textMention: true, ... }, ... }
console.log(settings);
```

<PropertiesList title="Returns">
  <PropertiesListItem name="settings" type="NotificationSettings">
    Current userâ€™s notification settings.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem name="settings" type="object" required>
    A deep partial object containing the notification settings to
    update. Custom notifications can be set too.

    <div className="-mt-2">
    ```js title="Examples" isCollapsable isCollapsed
    // You only need to pass partials
    await client.updateNotificationSettings({
      email: { thread: true },
    });

    // Enabling a custom notification on the slack channel
    await client.updateNotificationSettings({
      slack: { $myCustomNotification: true },
    });

    // Setting complex settings
    await client.updateNotificationSettings({
      email: {
        thread: true,
        textMention: false,
        $newDocument: true,
      },
        slack: {
        thread: false,
        $fileUpload: false,
      },
        teams: {
        thread: true,
      },
    });
    ```
    </div>

  </PropertiesListItem>
  <PropertiesListItem name="settings.email" type="NotificationChannelSettings">
    The email notification settings.
  </PropertiesListItem>
  <PropertiesListItem name="settings.slack" type="NotificationChannelSettings">
    The Slack notification settings.
  </PropertiesListItem>
  <PropertiesListItem name="settings.teams" type="NotificationChannelSettings">
    The Microsoft Teams notification settings.
  </PropertiesListItem>
  <PropertiesListItem name="settings.webPush" type="NotificationChannelSettings">
    The Web Push notification settings.
  </PropertiesListItem>
</PropertiesList>

## Storage

Each room contains Storage, a conflict-free data store that multiple users can
edit at the same time. When users make edits simultaneously, conflicts are
resolved automatically, and each user will see the same state. Storage is ideal
for storing permanent document state, such as shapes on a canvas, notes on a
whiteboard, or cells in a spreadsheet.

### Data structures

Storage provides three different conflict-free data structures, which you can
use to build your application. All structures are permanent and persist when all
users have left the room, unlike [Presence](/docs/ready-made-features/presence)
which is temporary.

- [`LiveObject`][] - Similar to JavaScript object. Use this for storing records
  with fixed key names and where the values donâ€™t necessarily have the same
  types. For example, a `Person` with a `name: string` and an `age: number`
  field. If multiple clients update the same property simultaneously, the last
  modification received by the Liveblocks servers is the winner.

- [`LiveList`][] - An ordered collection of items synchronized across clients.
  Even if multiple users add/remove/move elements simultaneously, LiveList will
  solve the conflicts to ensure everyone sees the same collection of items.

- [`LiveMap`][] - Similar to a JavaScript Map. Use this for indexing values that
  all have the same structure. For example, to store an index of `Person` values
  by their name. If multiple users update the same property simultaneously, the
  last modification received by the Liveblocks servers is the winner.

### Typing Storage [#typing-storage]

To type the Storage values you receive, make sure to set your `Storage` type.

```ts file="liveblocks.config.ts"
import { LiveList } from "@liveblocks/client";

declare global {
  interface Liveblocks {
    Storage: {
      animals: LiveList<{ name: string }>;
    };
  }
}
```

The type received in the callback will match the type passed. Learn more under
[typing your data](#typing-your-data).

```ts
const { root } = await room.getStorage();
const animals = root.get("animals");

const unsubscribe = room.subscribe(animals, (updatedAnimals) => {
  // LiveList<[{ name: "Fido" }, { name: "Felix" }]>
  console.log(updatedAnimals);
});
```

### Nesting data structures

All Storage data structures can be nested, allowing you to create complex trees
of conflict-free data.

```ts file="liveblocks.config.ts"
import { LiveObject, LiveList, LiveMap } from "@liveblocks/client";

type Person = LiveObject<{
  name: string;
  pets: LiveList<string>;
}>;

declare global {
  interface Liveblocks {
    Storage: {
      people: LiveMap<string, Person>;
    };
  }
}
```

```ts
import { LiveObject, LiveList, LiveMap } from "@liveblocks/client";

const pets = new LiveList(["Cat", "Dog"]);
const person = new LiveObject({ name: "Alicia", pets });
const people = new LiveMap();
people.set("alicia", person);

const { root } = await room.getStorage();
root.set(people);
```

<Banner title="Need help troubleshooting Storage?">

Get the [Liveblocks DevTools extension](/devtools) to develop and debug your
application as you build it.

</Banner>

### Room.getStorage

Get the roomâ€™s Storage asynchronously (returns a Promise). The promise will
resolve once the Storageâ€™s root is loaded and available. The Storageâ€™s root is
always a [`LiveObject`][].

```ts
const { root } = await room.getStorage();
```

<PropertiesList title="Returns">
  <PropertiesListItem name="storage" type="{ root: LiveObject<TStorage> }">
    The roomâ€™s Storage structures. `root` is a `LiveObject`, and is the root of
    your Storage. Learn more about [typing Storage](#typing-storage).
  </PropertiesListItem>
</PropertiesList>

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

## LiveObject

The `LiveObject` class is similar to a JavaScript object that is synchronized on
all clients. Use this for storing records with fixed key names and where the
values donâ€™t necessarily have the same types. For example, a `Person` with
`name` and `age` fields. To add typing, read more under
[typing Storage](#typing-storage).

```ts
type Person = LiveObject<{
  name: string;
  age: number;
}>;
```

Keys are strings, and values can contain other Storage structures, or
JSON-serializable data. If multiple clients update the same property
simultaneously, the last modification received by the Liveblocks servers is the
winner.

### new LiveObject [#LiveObject.constructor]

Create an empty `LiveObject`

```ts
import { LiveObject } from "@liveblocks/client";

const object = new LiveObject();
```

Create a `LiveObject` with initial data.

```ts
import { LiveObject } from "@liveblocks/client";

const object = new LiveObject({ firstName: "Margaret", lastName: "Hamilton" });
```

<PropertiesList title="Returns">
  <PropertiesListItem name="LiveObject" type="LiveObject<L>">
    The newly created `LiveObject`.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem name="initialValue" type="L extends LsonObject" required>
    The initial value for the `LiveObject`. Can contain JSON-serializable data
    and other Liveblocks conflict-free data structures.
  </PropertiesListItem>
</PropertiesList>

#### Add a LiveObject to Storage

The Storage root is `LiveObject` itself, so you can use [`LiveObject.set`]() to
add a new property to your root. If youâ€™ve [typed Storage](#typing-storage)
youâ€™ll have type hints as you build.

```ts
import { LiveObject } from "@liveblocks/client";

const { root } = await room.getStorage();

const person = new LiveObject({ name: "Alicia" });
root.set("person", person);
```

### delete [#LiveObject.delete]

Delete a property from the `LiveObject`

```ts
const object = new LiveObject({ firstName: "Ada", lastName: "Lovelace" });
object.delete("lastName");

// { firstName: "Ada" }
object.toImmutable();
```

<PropertiesListEmpty title="Returns">_Nothing_</PropertiesListEmpty>

<PropertiesList title="Arguments">
  <PropertiesListItem name="key" type="string" required>
    The key of the property youâ€™re deleting. If the property doesnâ€™t exist,
    nothing will occur.
  </PropertiesListItem>
</PropertiesList>

### get [#LiveObject.get]

Get a property from the `LiveObject`.

```ts
const object = new LiveObject({ firstName: "Ada", lastName: "Lovelace" });

// "Ada"
object.get("firstName");
```

<PropertiesList title="Returns">
  <PropertiesListItem name="value">
    The value of the property. Returns `undefined` if it doesnâ€™t exist.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem name="key" type="string" required>
    The key of the property youâ€™re getting.
  </PropertiesListItem>
</PropertiesList>

### set [#LiveObject.set]

Adds or updates a property with the specified key and a value.

```ts
const object = new LiveObject({ firstName: "Marie" });
object.set("lastName", "Curie");

// { firstName: "Ada", lastName: "Curie" }
object.toImmutable();
```

<PropertiesListEmpty title="Returns">_Nothing_</PropertiesListEmpty>

<PropertiesList title="Arguments">
  <PropertiesListItem name="key" type="string" required>
    The key of the property youâ€™re setting.
  </PropertiesListItem>
  <PropertiesListItem name="value" type="LsonObject" required>
    The value of the property youâ€™re setting. Can contain JSON-serializable data
    and other Liveblocks conflict-free data structures.
  </PropertiesListItem>
</PropertiesList>

### update [#LiveObject.update]

Adds or updates multiple properties at once. Nested changes to other Storage
types will not be applied.

```ts
const object = new LiveObject({ firstName: "Grace" });
object.update({ lastName: "Hopper", job: "Computer Scientist" });

// { firstName: "Grace", lastName: "Hopper", job: "Computer Scientist" }
object.toImmutable();
```

<PropertiesListEmpty title="Returns">_Nothing_</PropertiesListEmpty>

<PropertiesList title="Arguments">
  <PropertiesListItem name="value" type="LsonObject" required>
    The keys and values youâ€™re updating. Can contain JSON-serializable data and
    other Liveblocks conflict-free data structures. Nested changes to other
    Storage types will not be applied.
  </PropertiesListItem>
</PropertiesList>

### clone [#LiveObject.clone]

Returns a deep copy of the `LiveObject` that can be inserted elsewhere in the
Storage tree.

```ts
const obj = new LiveObject(/* ... */);
root.set("a", obj);
root.set("b", obj.clone());
```

<PropertiesList title="Returns">
  <PropertiesListItem name="clonedStructure" type="LiveObject">
    The cloned `LiveObject`.
  </PropertiesListItem>
</PropertiesList>

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

### toImmutable [#LiveObject.toImmutable]

Returns an immutable JavaScript object that is equivalent to the `LiveObject`.
Nested values will also be immutable. Calling this method multiple times has no
performance penalty. It will return the same cached immutable value as long as
its (nested) contents have not changed.

```ts
const liveObject = new LiveObject({
  firstName: "Grace",
  lastName: "Hopper",
  hobbies: new LiveList(["reading", "piano"]),
});

// {
//   firstName: "Grace",
//   lastName: "Hopper",
//   hobbies: ["reading", "piano"]
// }
liveObject.toImmutable();
```

<PropertiesList title="Returns">
  <PropertiesListItem name="immutableStructure" type="object">
    Returns a JavaScript object in the shape of your data structure.
    `LiveObject` is converted to an object, `LiveMap` to a map, and `LiveList`
    to an array.
  </PropertiesListItem>
</PropertiesList>

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

### toObject [#LiveObject.toObject]

<Banner title="Will be deprecated in the future">

Starting with 0.18, we recommend [`toImmutable`][] instead. Itâ€™s faster, cached,
and leads to fewer surprises.

</Banner>

Transform the `LiveObject` into a normal JavaScript object.

```ts
const liveObject = new LiveObject({ firstName: "Grace", lastName: "Hopper" });
liveObject.toObject();
// { firstName: "Grace", lastName: "Hopper" }
```

Please note that this method wonâ€™t recursively convert Live structures, which
may be surprising:

```ts
const liveObject = new LiveObject({
  animals: new LiveList(["ðŸ¦", "ðŸ¦Š", "ðŸµ"]),
});
liveObject.toObject();
// { animals: <LiveList instance> } // â—ï¸
```

## LiveMap

The `LiveMap` class is similar to a
[JavaScript Map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map)
that is synchronized on all clients. Use this for indexing values that all have
the same structure. For example, to store an index of `Person` values by their
name. To add typing, read more under [typing Storage](#typing-storage).

```ts
type Shapes = LiveMap<string, LiveObject<{ name: string }>>;
```

Keys are strings, and values can contain other Storage structures, or
JSON-serializable data. If multiple clients update the same property
simultaneously, the last modification received by the Liveblocks servers is the
winner.

### new LiveMap [#LiveMap.constructor]

Create an empty `LiveMap`.

```ts
const map = new LiveMap();
```

Create a `LiveMap` with initial data.

```ts
const map = new LiveMap([
  ["nimesh", "developer"],
  ["pierre", "designer"],
]);
```

<PropertiesList title="Returns">
  <PropertiesListItem name="LiveMap" type="LiveMap<string, L>">
    The newly created `LiveMap`.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem
    name="initialValue"
    type="[string, L extends LsonObject][]"
    required
  >
    The initial value for the `LiveMap`. An array of tuples, each containing a
    key and a value. The values can contain JSON-serializable data and other
    Liveblocks conflict-free data structures.
  </PropertiesListItem>
</PropertiesList>

#### Add a LiveMap to Storage

The Storage root is a `LiveObject`, so you can create a new `LiveMap` then use
[`LiveObject.set`]() to add it to your root. If youâ€™ve
[typed Storage](#typing-storage) youâ€™ll have type hints as you build.

```ts
import { LiveMap } from "@liveblocks/client";

const { root } = await room.getStorage();

const people = new LiveMap([
  ["vincent", "engineer"],
  ["marc", "designer"],
]);
root.set("people", people);
```

### delete [#LiveMap.delete]

Removes the specified element by key. Returns true if an element existed and has
been removed, or false if the element does not exist.

```ts
const map = new LiveMap([
  ["nimesh", "developer"],
  ["pierre", "designer"],
]);

// true
map.delete("nimesh");

// Map { "pierre" => "designer" }
map.toImmutable();
```

<PropertiesList title="Returns">
  <PropertiesListItem name="deleted" type="boolean">
    If the element existed and was removed.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem name="key" type="string" required>
    The key of the element youâ€™re deleting. If the element doesnâ€™t exist,
    nothing will occur.
  </PropertiesListItem>
</PropertiesList>

### entries [#LiveMap.entries]

Returns a new
[Iterator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators)
object that contains the `[key, value]` pairs for each element.

```ts
for (const [key, value] of map.entries()) {
  // Iterate over all the keys and values of the map
}
```

<Banner title="Iteration with TypeScript">

If your TypeScript project targets <code>es5</code> or lower, youâ€™ll need to
enable the <code>--downlevelIteration</code> option to use this API.

</Banner>

<PropertiesList title="Returns">
  <PropertiesListItem name="iterator" type="IterableIterator<[string, L]>">
    A new Iterator object for the `LiveMap`, containing the `[key, value]` pairs
    for each element.
  </PropertiesListItem>
</PropertiesList>

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

### forEach [#LiveMap.forEach]

Executes a provided function once per each key/value pair in the Map object, in
insertion order.

```ts
const map = new LiveMap([
  ["nimesh", "developer"],
  ["pierre", "designer"],
]);

// "developer", "designer"
map.forEach((value, key, liveMap) => console.log(value));
```

<PropertiesListEmpty title="Returns">_Nothing_</PropertiesListEmpty>

<PropertiesList title="Arguments">
  <PropertiesListItem
    name="callback"
    detailedType="(value: L, key: string, map: LiveMap<string, L>) => void"
    required
  >
    A callback for each entry. The callback is passed the current `value`,
    `key`, and the `LiveMap`. Return values are ignored.
  </PropertiesListItem>
</PropertiesList>

### get [#LiveMap.get]

Returns a specified element from the `LiveMap`. Returns `undefined` if the key
canâ€™t be found.

```ts
const map = new LiveMap([
  ["nimesh", "developer"],
  ["pierre", "designer"],
]);

// "developer"
map.get("nimesh");

// undefined
map.get("alicia");
```

<PropertiesList title="Returns">
  <PropertiesListItem name="value" type="L | undefined">
    The value of the entry. Returns `undefined` if it doesnâ€™t exist.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem name="key" type="string" required>
    The key of the entry youâ€™re getting.
  </PropertiesListItem>
</PropertiesList>

### has [#LiveMap.has]

Returns a boolean indicating whether an element with the specified key exists or
not.

```ts
const map = new LiveMap([
  ["nimesh", "developer"],
  ["pierre", "designer"],
]);

// true
map.has("nimesh");

// false
map.has("alicia");
```

<PropertiesList title="Returns">
  <PropertiesListItem name="exists" type="boolean">
    Whether the entry exists.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem name="key" type="string" required>
    The key of the entry youâ€™re getting.
  </PropertiesListItem>
</PropertiesList>

### keys [#LiveMap.keys]

Returns a new
[Iterator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators)
object that contains the keys for each element.

```ts
for (const key of map.keys()) {
  // Iterate over all the keys and values of the map
}
```

<Banner title="Iteration with TypeScript">

If your TypeScript project targets <code>es5</code> or lower, youâ€™ll need to
enable the <code>--downlevelIteration</code> option to use this API.

</Banner>

<PropertiesList title="Returns">
  <PropertiesListItem name="iterator" type="IterableIterator<string>">
    A new Iterator object for the `LiveMap`, containing the keys of each entry.
  </PropertiesListItem>
</PropertiesList>

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

### set [#LiveMap.set]

Adds or updates an element with a specified key and a value.

```ts
const map = new LiveMap();
map.set("vincent", "engineer");

// Map { "vincent" => "engineer" }
map.toImmutable();
```

<PropertiesListEmpty title="Returns">_Nothing_</PropertiesListEmpty>

<PropertiesList title="Arguments">
  <PropertiesListItem name="key" type="string" required>
    The key of the entry youâ€™re setting.
  </PropertiesListItem>
  <PropertiesListItem name="value" type="LsonObject" required>
    The value of the entry youâ€™re setting. Can contain JSON-serializable data
    and other Liveblocks conflict-free data structures.
  </PropertiesListItem>
</PropertiesList>

### size [#LiveMap.size]

Returns the number of elements in the `LiveMap`.

```ts
const map = new LiveMap([
  ["nimesh", "developer"],
  ["pierre", "designer"],
]);

// 2
map.size;
```

<PropertiesList title="Returns">
  <PropertiesListItem name="size" type="number">
    The number of entries in the `LiveMap`
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem>_N/A_</PropertiesListItem>
</PropertiesList>

### values [#LiveMap.values]

Returns a new
[Iterator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators)
object that contains the values for each element.

```ts
for (const value of map.values()) {
  // Iterate over all the values of the map
}
```

<Banner title="Iteration with TypeScript">

If your TypeScript project targets <code>es5</code> or lower, youâ€™ll need to
enable the <code>--downlevelIteration</code> option to use this API.

</Banner>

<PropertiesList title="Returns">
  <PropertiesListItem name="iterator" type="IterableIterator<L>">
    A new Iterator object for the `LiveMap`, containing the values of each
    entry.
  </PropertiesListItem>
</PropertiesList>

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

### clone [#LiveMap.clone]

Returns a deep copy of the `LiveMap` that can be inserted elsewhere in the
Storage tree.

```ts
const map = new LiveMap(/* ... */);
root.set("a", map);
root.set("b", map.clone());
```

<PropertiesList title="Returns">
  <PropertiesListItem name="clonedStructure" type="LiveMap">
    The cloned `LiveMap`.
  </PropertiesListItem>
</PropertiesList>

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

### toImmutable [#LiveMap.toImmutable]

Returns an immutable ES6 Map that is equivalent to the `LiveMap`. Nested values
will also be immutable. Calling this method multiple times has no performance
penalty. It will return the same cached immutable value as long as its (nested)
contents have not changed.

```ts
const map = new LiveMap([
  ["florent", new LiveObject({ role: "engineer" })],
  ["marc", new LiveObject({ role: "designer" })],
]);

// Map {
//   "florent" => { role: "engineer" },
//   "marc" => { role: "designer" },
// }
map.toImmutable();
```

<PropertiesList title="Returns">
  <PropertiesListItem name="immutableStructure" type="object">
    Returns a JavaScript object in the shape of your data structure. `LiveMap`
    is converted to a map, `LiveObject` to an object, and `LiveList` to an
    array.
  </PropertiesListItem>
</PropertiesList>

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

## LiveList

The `LiveList` class represents an ordered collection of items that is
synchronized across clients. To add typing, read more under
[typing Storage](#typing-storage).

```ts
type Names = LiveList<string>;
```

Items can contain other Storage structures, or JSON-serializable data.

### new LiveList [#LiveList.constructor]

Create an empty `LiveList`.

```ts
const list = new LiveList();
```

Create a `LiveList` with initial data.

```ts
const list = new LiveList(["adrien", "jonathan"]);
```

<PropertiesList title="Returns">
  <PropertiesListItem name="LiveList" type="LiveList<L>">
    The newly created `LiveList`.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem
    name="initialValue"
    type="Array<L extends LsonObject>"
    required
  >
    The initial array of values for the `LiveList`. Can contain
    JSON-serializable data and other Liveblocks conflict-free data structures.
  </PropertiesListItem>
</PropertiesList>

### clear [#LiveList.clear]

Removes all the elements.

```ts
const list = new LiveList(["adrien", "jonathan"]);
list.clear();

// []
list.toImmutable();
```

<PropertiesListEmpty title="Returns">_Nothing_</PropertiesListEmpty>

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

### delete [#LiveList.delete]

Deletes the element living at the specified index locally. If the index doesn't
exist, an `Error` is thrown.

```ts
const list = new LiveList(["adrien", "jonathan"]);
list.delete(0);

// ["jonathan"]
list.toImmutable();
```

This operation uses ID-based semantics, not position-based. When called, it
reads the item at the specified index from the local state, then sends a "delete
item with ID X" instruction to the server.

If clients A and B both see a LiveList containing `["foo", "bar"]`, and client A
calls `.insert("qux", 0)`, while client B simultaneously calls `.delete(0)`, the
end result will always be `["qux", "bar"]` on both clients, and never
`["foo", "bar"]`.

<PropertiesListEmpty title="Returns">_Nothing_</PropertiesListEmpty>

<PropertiesList title="Arguments">
  <PropertiesListItem name="index" type="number" required>
    The index of the property youâ€™re deleting. If the property doesnâ€™t exist, an
    `Error` is thrown.
  </PropertiesListItem>
</PropertiesList>

### every [#LiveList.every]

Tests whether all elements pass the test implemented by the provided function.
Returns true if the predicate function returns a truthy value for every element.
Otherwise, false.

```ts
const list = new LiveList([0, 2, 4]);

// true
list.every((i) => i % 2 === 0);

list.push(5);

// false
list.every((i) => i % 2 === 0);
```

<PropertiesList title="Returns">
  <PropertiesListItem name="isEvery" type="boolean">
    Whether all elements pass the test implemented by the provided function.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem
    name="callback"
    type="(value: L, index: number) => unknown"
    required
  >
    A function to execute for each item in the array. It should return a truthy
    value to indicate the element passes the test, and a falsy value otherwise.
    The function is passed the `value` of the item and its current `index`.
  </PropertiesListItem>
</PropertiesList>

### filter [#LiveList.filter]

Creates an array with all elements that pass the test implemented by the
provided function.

```ts
const list = new LiveList([0, 1, 2, 3, 4]);

// [0, 2, 4]
list.filter((i) => i % 2 === 0);
```

<PropertiesList title="Returns">
  <PropertiesListItem name="filteredArray" type="L[]">
    An array containing each item of the `LiveList` that passed the test
    implemented by the provided function.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem
    name="callback"
    type="(value: L, index: number) => unknown"
    required
  >
    A function to execute for each item in the array. It should return a truthy
    value to indicate the element passes the test, and a falsy value otherwise.
    The function is passed the `value` of the item and its current `index`.
  </PropertiesListItem>
</PropertiesList>

### find [#LiveList.find]

Returns the first element that satisfies the provided testing function. If no
item passes the test, `undefined` is returned.

```ts
const list = new LiveList(["apple", "lemon", "tomato"]);

// "lemon"
list.find((value, index) => value.startsWith("l"));
```

<PropertiesList title="Returns">
  <PropertiesListItem name="item" type="L | undefined">
    The item that has been found. If no item passes the test, `undefined` is
    returned.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem
    name="callback"
    type="(value: L, index: number) => unknown"
    required
  >
    A function to execute for each item in the array. It should return a truthy
    value to indicate the element passes the test, and a falsy value otherwise.
    The function is passed the `value` of the item and its current `index`.
  </PropertiesListItem>
</PropertiesList>

### findIndex [#LiveList.findIndex]

Returns the index of the first element in the `LiveList` that satisfies the
provided testing function. If no item passes the test, `-1` is returned.

```ts
const list = new LiveList(["apple", "lemon", "tomato"]);

// 1
list.findIndex((value, index) => value.startsWith("l"));
```

<PropertiesList title="Returns">
  <PropertiesListItem name="index" type="number">
    The index of the item that has been found. If no item passes the test, `-1`
    is returned.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem
    name="callback"
    type="(value: L, index: number) => unknown"
    required
  >
    A function to execute for each item in the array. It should return a truthy
    value to indicate the element passes the test, and a falsy value otherwise.
    The function is passed the `value` of the item and its current `index`.
  </PropertiesListItem>
</PropertiesList>

### forEach [#LiveList.forEach]

Executes a provided function once for each element.

```ts
const list = new LiveList(["adrien", "jonathan"]);

// "adrien", "jonathan"
list.forEach((item) => console.log(item));
```

<PropertiesListEmpty title="Returns">_Nothing_</PropertiesListEmpty>

<PropertiesList title="Arguments">
  <PropertiesListItem
    name="callback"
    detailedType="(value: L, index: number) => void"
    required
  >
    A callback for each item. The callback is passed the current `value` and
    `index`. Return values are ignored.
  </PropertiesListItem>
</PropertiesList>

### get [#LiveList.get]

Get the element at the specified index. Returns `undefined` if the index doesnâ€™t
exist.

```ts
const list = new LiveList(["adrien", "jonathan"]);

// "jonathan"
list.get(1);
```

<PropertiesList title="Returns">
  <PropertiesListItem name="item" type="L | undefined">
    The value of the item at the index. Returns `undefined` if it doesnâ€™t exist.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem name="index" type="number" required>
    The index of the item youâ€™re getting.
  </PropertiesListItem>
</PropertiesList>

### indexOf [#LiveList.indexOf]

Returns the first index at which a given element can be found in the `LiveList`.
Returns `-1` if it is not present.

```ts
const list = new LiveList(["adrien", "jonathan"]);

// 1
list.indexOf("jonathan");

// undefined
list.indexOf("chris");
```

<PropertiesList title="Returns">
  <PropertiesListItem name="index" type="number">
    The index of the item. Returns `-1` if it doesnâ€™t exist.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem name="searchElement" type="L" required>
    The item youâ€™re locating.
  </PropertiesListItem>
  <PropertiesListItem name="index" type="number">
    The index to start the search at.
  </PropertiesListItem>
</PropertiesList>

### insert [#LiveList.insert]

Inserts one element at a specified index. Throws an `Error` if the index is out
of bounds.

```ts
const list = new LiveList(["adrien", "jonathan"]);

list.insert("chris", 1);

// ["adrien", "chris", "jonathan"]
list.toImmutable();
```

<PropertiesListEmpty title="Returns">_Nothing_</PropertiesListEmpty>

<PropertiesList title="Arguments">
  <PropertiesListItem name="value" type="L extends LsonObject" required>
    The value of the item youâ€™re inserting.
  </PropertiesListItem>
  <PropertiesListItem name="index" type="number" required>
    The index to insert the item into.
  </PropertiesListItem>
</PropertiesList>

### lastIndexOf [#LiveList.lastIndexOf]

Returns the last index at which a given element can be found in the `LiveList`,
or -1 if it is not present. The `LiveList` is searched backwards, starting at
fromIndex. Returns `-1` if it is not present.

```ts
const list = new LiveList(["adrien", "jonathan", "adrien"]);

// 2
list.indexOf("adrien");

// undefined
list.indexOf("chris");
```

<PropertiesList title="Returns">
  <PropertiesListItem name="index" type="number">
    The index of the item. Returns `-1` if it doesnâ€™t exist.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem name="searchElement" type="L" required>
    The item youâ€™re locating.
  </PropertiesListItem>
  <PropertiesListItem name="index" type="number">
    The index at which to start searching backwards.
  </PropertiesListItem>
</PropertiesList>

### length [#LiveList.length]

Returns the number of elements.

```ts
const list = new LiveList(["adrien", "jonathan"]);

// 2
list.length;
```

<PropertiesList title="Returns">
  <PropertiesListItem name="length" type="number">
    The number of items in the `LiveList`.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem>_N/A_</PropertiesListItem>
</PropertiesList>

### map [#LiveList.map]

Creates an array populated with the results of calling a provided function on
every element.

```ts
const list = new LiveList(["apple", "lemon", "tomato"]);

// ["APPLE", "LEMON", "TOMATO"]
list.map((value, index) => value.toUpperCase());
```

<PropertiesList title="Returns">
  <PropertiesListItem name="array">
    The array of each item has been transformed by the callback function.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem
    name="callback"
    detailedType="(value: L, index: number) => void"
    required
  >
    A callback for each item. The callback is passed the current `value` and
    `index`. Return values are used in the returned array.
  </PropertiesListItem>
</PropertiesList>

### move [#LiveList.move]

Moves one element at a specified index.

```ts
const list = new LiveList(["adrien", "chris", "jonathan"]);

list.move(2, 0);

// ["jonathan", "adrien", "chris"]
list.toImmutable();
```

<PropertiesListEmpty title="Returns">_Nothing_</PropertiesListEmpty>

<PropertiesList title="Arguments">
  <PropertiesListItem name="index" type="number" required>
    The index of the item to move.
  </PropertiesListItem>
  <PropertiesListItem name="targetIndex" type="number" required>
    The index where the element should be after moving.
  </PropertiesListItem>
</PropertiesList>

### push [#LiveList.push]

Adds one element to the end of the `LiveList`.

```ts
const list = new LiveList(["adrien", "jonathan"]);

list.push("chris");

// ["adrien", "jonathan", "chris"]
list.toImmutable();
```

<PropertiesListEmpty title="Returns">_Nothing_</PropertiesListEmpty>

<PropertiesList title="Arguments">
  <PropertiesListItem name="index" type="L" required>
    The item to add to the end of the `LiveList`.
  </PropertiesListItem>
</PropertiesList>

### set [#LiveList.set]

Replace one element at the specified index.

```ts
const list = new LiveList(["adrien", "jonathan"]);

list.set(1, "chris");

// equals ["adrien", "chris"]
list.toImmutable();
```

### some [#LiveList.some]

Tests whether at least one element in the `LiveList` passes the test implemented
by the provided function.

```ts
const list = new LiveList(["apple", "lemon", "tomato"]);

// true
list.some((value, index) => value.startsWith("l"));

// false
list.some((value, index) => value.startsWith("x"));
```

<PropertiesList title="Returns">
  <PropertiesListItem name="areSome" type="boolean">
    Whether any elements pass the test implemented by the provided function.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem
    name="callback"
    type="(value: L, index: number) => unknown"
    required
  >
    A function to execute for each item in the array. It should return a truthy
    value to indicate the element passes the test, and a falsy value otherwise.
    The function is passed the `value` of the item and its current `index`.
  </PropertiesListItem>
</PropertiesList>

### clone [#LiveList.clone]

Returns a deep copy of the `LiveList` that can be inserted elsewhere in the
Storage tree.

```ts
const list = new LiveList(/* ... */);
root.set("a", list);
root.set("b", list.clone());
```

<PropertiesList title="Returns">
  <PropertiesListItem name="clonedStructure" type="LiveList">
    The cloned `LiveList`.
  </PropertiesListItem>
</PropertiesList>

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

### toImmutable [#LiveList.toImmutable]

Returns an immutable JavaScript array that is equivalent to the `LiveList`.
Nested values will also be immutable. Calling this method multiple times has no
performance penalty. It will return the same cached immutable value as long as
its (nested) contents have not changed.

```ts
const list = new LiveList([
  new LiveObject({ name: "Olivier" }),
  new LiveObject({ name: "Vincent" }),
]);

// [
//   { name: "Olivier" },
//   { name: "Vincent" },
// ]
list.toImmutable();
```

<PropertiesList title="Returns">
  <PropertiesListItem name="immutableStructure" type="object">
    Returns a JavaScript object in the shape of your data structure. `ListList`
    is converted to an array, `LiveObject` to an object, and `LiveMap` to a map.
  </PropertiesListItem>
</PropertiesList>

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

### toArray [#LiveList.toArray]

<Banner title="Will be deprecated in the future">

Starting with 0.18, we recommend [`toImmutable`][] instead. Itâ€™s faster, cached,
and leads to fewer surprises.

</Banner>

Transforms the `LiveList` into a normal JavaScript array.

```ts
const list = new LiveList(["ðŸ¦", "ðŸ¦Š", "ðŸµ"]);
list.toArray();
// ["ðŸ¦", "ðŸ¦Š", "ðŸµ"]
```

Please note that this method wonâ€™t recursively convert Live structures, which
may be surprising:

```ts
const list = new LiveList([
  new LiveObject({ firstName: "Grace", lastName: "Hopper" }),
]);
list.toArray();
// [ <LiveObject instance> ]  // â—ï¸
```

## Resolvers

### invalidateUsers

`client.resolvers.invalidateUsers` can be used to invalidate some or all users
that were previously cached by [`resolveUsers`](#createClientResolveUsers).

It can be used when updating the current userâ€™s avatar for example, to instantly
refresh the user data everywhere without having to perform a page reload.

```tsx
// Invalidate all users
client.resolvers.invalidateUsers();

// Only invalidate "user-0" and "user-1"
client.resolvers.invalidateUsers(["user-0", "user-1"]);
```

### invalidateRoomsInfo

`client.resolvers.invalidateRoomsInfo` can be used to invalidate some or all
rooms that were previously cached by
[`resolveRoomsInfo`](#createClientResolveRoomsInfo).

It can be used when updating a roomâ€™s name for example, to instantly refresh the
room info everywhere without having to perform a page reload.

```tsx
// Invalidate all rooms
client.resolvers.invalidateRoomsInfo();

// Only invalidate "room-0" and "room-1"
client.resolvers.invalidateRoomsInfo(["room-0", "room-1"]);
```

### invalidateGroupsInfo

`client.resolvers.invalidateGroupsInfo` can be used to invalidate some or all
groups that were previously cached by
[`resolveGroupsInfo`](#createClientResolveGroupsInfo).

It can be used when updating a groupâ€™s name for example, to instantly refresh
the group info everywhere without having to perform a page reload.

```tsx
// Invalidate all groups
client.resolvers.invalidateGroupsInfo();

// Only invalidate "group-0" and "group-1"
client.resolvers.invalidateGroupsInfo(["group-0", "group-1"]);
```

### invalidateMentionSuggestions

`client.resolvers.invalidateMentionSuggestions` can be used to invalidate all
mention suggestions that were previously cached by
[`resolveMentionSuggestions`](#createClientResolveMentionSuggestions).

It can be used when updating a roomâ€™s list of users for example, to prevent
creating out-of-date mentions without having to perform a page reload.

```tsx
// Invalidate all mention suggestions
client.resolvers.invalidateMentionSuggestions();
```

## Utilities

### getMentionsFromCommentBody [#get-mentions-from-comment-body]

Returns an array of mentions from a `CommentBody` (found under `comment.body`).

```ts
import { getMentionsFromCommentBody } from "@liveblocks/client";

const mentions = getMentionsFromCommentBody(comment.body);
```

An optional second argument can be used to filter the returned mentions. By
default, if itâ€™s not provided, all mentions are returned, including future
mention kinds (e.g. group mentions in the future).

```tsx
// All mentions (same as `getMentionsFromCommentBody(commentBody)`)
getMentionsFromCommentBody(commentBody);

// Only user mentions with an ID of "123"
getMentionsFromCommentBody(
  commentBody,
  (mention) => mention.kind === "user" && mention.id === "123"
);

// Only mentions with an ID which starts with "prefix:"
getMentionsFromCommentBody(commentBody, (mention) => (
  mention.id.startsWith("prefix:")
);
```

Hereâ€™s an example with a custom `CommentBody`.

```ts
import { CommentBody, getMentionsFromCommentBody } from "@liveblocks/client";

// Create a custom `CommentBody`
const commentBody: CommentBody = {
  version: 1,
  content: [
    {
      type: "paragraph",
      children: [
        { text: "Hello " },
        { type: "mention", id: "chris@example.com" },
      ],
    },
  ],
};

// Get the mentions inside the commentâ€™s body
const mentions = getMentionsFromCommentBody(commentBody);

// [{ kind: "user", id: "chris@example.com" }]
console.log(mentions);
```

<Banner title="Also available from @liveblocks/node">

If youâ€™d like to use this on the server side, itâ€™s also available from
[`@liveblocks/node`](/docs/api-reference/liveblocks-node#get-mentions-from-comment-body).

</Banner>

### stringifyCommentBody [#stringify-comment-body]

Used to convert a `CommentBody` (found under `comment.body`) into either a plain
string, Markdown, HTML, or a custom format.

```ts
import { stringifyCommentBody } from "@liveblocks/client";

const stringComment = await stringifyCommentBody(comment.body);

// "Hello marc@example.com from https://liveblocks.io"
console.log(stringComment);
```

A number of options are available.

```ts
import { stringifyCommentBody } from "@liveblocks/client";

const stringComment = await stringifyCommentBody(comment.body, {
  // Optional, convert to specific format, "plain" (default) | "markdown" | "html"
  format: "markdown",

  // Optional, supply a separator to be used between paragraphs
  separator: `\n\n`,

  // Optional, override any elements in the CommentBody with a custom string
  elements: {
    // Optional, override the `paragraph` element
    paragraph: ({ element, children }) => `<p>${children}</p>`,

    // Optional, override the `text` element
    text: ({ element }) =>
      element.bold ? `<strong>${element.text}</strong>` : `${element.text}`,

    // Optional, override the `link` element
    link: ({ element, href }) =>
      `<a href="${href}" target="_blank">${element.url}</a>`,

    // Optional, override the `mention` element.
    // `user` and `group` are the optional data returned from `resolveUsers` and `resolveGroupsInfo`
    mention: ({ element, user, group }) =>
      `<a href="${user?.profileUrl ?? group?.settingsUrl ?? "#"}">${
        element.id
      }</a>`,
  },

  // Optional, get your userâ€™s names and info from their ID to be displayed in mentions
  async resolveUsers({ userIds }) {
    const usersData = await __getUsersFromDB__(userIds);

    return usersData.map((userData) => ({
      // Name is inserted into the output instead of a userâ€™s ID
      name: userData.name,

      // Custom formatting in `elements.mention` allows custom properties to be used
      profileUrl: userData.profileUrl,
    }));
  },

  // Optional, get your groupâ€™s names and info from their ID to be displayed in mentions
  async resolveGroupsInfo({ groupIds }) {
    const groupsData = await __getGroupsFromDB__(groupIds);

    return groupsData.map((groupData) => ({
      // Name is inserted into the output instead of a groupâ€™s ID
      name: groupData.name,

      // Custom formatting in `elements.mention` allows custom properties to be used
      settingsUrl: groupData.settingsUrl,
    }));
  },
});
```

<Banner title="Also available from @liveblocks/node">

If youâ€™d like to use this on the server side, itâ€™s also available from
[`@liveblocks/node`](/docs/api-reference/liveblocks-node#stringify-comment-body).

</Banner>

#### Formatting examples

Here are a number of different formatting examples derived from the same
`CommentBody`.

```ts
// "Hello marc@example.com from https://liveblocks.io"
await stringifyCommentBody(comment.body);

// "Hello @Marc from https://liveblocks.io"
await stringifyCommentBody(comment.body, {
  resolveUsers({ userIds }) {
    return [{ name: "Marc" }];
  },
});

// "**Hello** @Marc from [https://liveblocks.io](https://liveblocks.io)"
await stringifyCommentBody(comment.body, {
  format: "markdown",

  resolveUsers() {
    return [{ name: "Marc" }];
  },
});

// "<b>Hello</b> <span data-mention>@Marc</span> from
// <a href="https://liveblocks.io">https://liveblocks.io</a>"
await stringifyCommentBody(comment.body, {
  format: "html",

  resolveUsers() {
    return [{ name: "Marc" }];
  },
});

// "<b>Hello</b> <a href="https://example.com" data-id="marc@example.com">@Marc</a> from
// <a href="https://liveblocks.io">https://liveblocks.io</a>"
await stringifyCommentBody(comment.body, {
  format: "html",

  mention: ({ element, user }) =>
    `<a href="${user.profileUrl}" data-id="${element.id}">${user.name}</a>`,

  resolveUsers() {
    return [{ name: "Marc", profileUrl: "https://example.com" }];
  },
});
```

## TypeScript

### Typing your data

Itâ€™s possible to have automatic types flow through your application by defining
a global `Liveblocks` interface. We recommend doing this in a
`liveblocks.config.ts` file in the root of your app, so itâ€™s easy to keep track
of your types. Each type (`Presence`, `Storage`, etc.), is optional, but itâ€™s
recommended to make use of them.

```ts file="liveblocks.config.ts"
declare global {
  interface Liveblocks {
    // Each userâ€™s Presence
    Presence: {};

    // The Storage tree for the room
    Storage: {};

    UserMeta: {
      id: string;
      // Custom user info set when authenticating with a secret key
      info: {};
    };

    // Custom events
    RoomEvent: {};

    // Custom metadata set on threads
    ThreadMetadata: {};

    // Custom metadata set on comments
    CommentMetadata: {};

    // Custom room info set with resolveRoomsInfo
    RoomInfo: {};

    // Custom group info set with resolveGroupsInfo
    GroupInfo: {};

    // Custom activities data for custom notification kinds
    ActivitiesData: {};
  }
}

// Necessary if you have no imports/exports
export {};
```

Here are some example values that might be used.

```ts file="liveblocks.config.ts"
import { LiveList } from "@liveblocks/client";

declare global {
  interface Liveblocks {
    // Each userâ€™s Presence
    Presence: {
      // Example, real-time cursor coordinates
      cursor: { x: number; y: number };
    };

    // The Storage tree for the room
    Storage: {
      // Example, a conflict-free list
      animals: LiveList<string>;
    };

    UserMeta: {
      id: string;
      // Custom user info set when authenticating with a secret key
      info: {
        // Example properties
        name: string;
        avatar: string;
      };
    };

    // Custom events
    // Example has two events, using a union
    RoomEvent: { type: "PLAY" } | { type: "REACTION"; emoji: "ðŸ”¥" };

    // Custom metadata set on threads
    ThreadMetadata: {
      // Example, attaching coordinates to a thread
      x: number;
      y: number;
    };

    // Custom metadata set on comments
    CommentMetadata: {
      // Example, attaching a tag and a spam flag to a comment
      tag: string;
      spam: boolean;
    };

    // Custom room info set with resolveRoomsInfo
    RoomInfo: {
      // Example, rooms with a title and url
      title: string;
      url: string;
    };

    // Custom group info set with resolveGroupsInfo
    GroupInfo: {
      // Example, groups with a name and a badge
      name: string;
      badge: string;
    };

    // Custom activities data for custom notification kinds
    ActivitiesData: {
      // Example, a custom $alert kind
      $alert: {
        title: string;
        message: string;
      };
    };
  }
}

// Necessary if you have no imports/exports
export {};
```

### Typing with client.enter

Before Liveblocks 2.0, it was recommended to type your data by passing
`Presence`, `Storage`, `UserMeta`, and `RoomEvents` types to
[`client.enterRoom`][]. This is no longer
[the recommended method](#Typing-your-data) for setting up Liveblocks, but it
can still be helpful, for example you can use `client.enter` multiple times to
create different room types, each with their own correctly typed hooks.

```ts
import { LiveList } from "@liveblocks/client";

// Each userâ€™s Presence
type Presence = {
  cursor: { x: number; y: number };
};

// The Storage tree for the room
type Storage = {
  animals: LiveList<string>;
};

// User information set when authenticating with a secret key
type UserMeta = {
  id: string;
  info: {
    // Custom properties, corresponds with userInfo
  };
};

// Custom events that can be broadcast, use a union for multiple events
type RoomEvent = {
  type: "REACTION";
  emoji: "ðŸ”¥";
};

const { room, leave } = client.enterRoom<
  Presence,
  Storage,
  UserMeta,
  RoomEvent
>("my-room-id");
```

You can also pass types to
[`client.getRoom`](/docs/api-reference/liveblocks-client#Client.getRoom).

```ts
const { room, leave } = client.getRoom<Presence, Storage, UserMeta, RoomEvent>(
  "my-room-id"
);
```

### ToolDefinition

Type definition for AI tools that can be executed by the AI. This type
represents the structure of a tool that can be registered and used in AI
interactions.

```ts
type ToolDefinition<TArgs = any, TResult = any> = {
  description: string;
  parameters: JSONSchema7;
  execute: (
    args: TArgs,
    context: ToolExecutionContext
  ) => Promise<{ data: TResult }>;
  render: (props: ToolRenderProps<TArgs, TResult>) => ReactNode;
};
```

<PropertiesList title="Properties">
  <PropertiesListItem name="description" type="string">
    A clear description of what the tool does. Used by AI to understand when to
    call this tool.
  </PropertiesListItem>
  <PropertiesListItem name="parameters" type="JSONSchema7">
    JSON Schema defining the toolâ€™s input parameters. The AI will validate
    arguments against this schema.
  </PropertiesListItem>
  <PropertiesListItem name="execute" type="function">
    Async function that performs the toolâ€™s action. Receives validated arguments
    and execution context, returns structured data.
  </PropertiesListItem>
  <PropertiesListItem name="render" type="function">
    React component function that renders the toolâ€™s UI during different
    execution stages.
  </PropertiesListItem>
</PropertiesList>

### AiKnowledgeSource

Type definition for knowledge sources that provide contextual information to AI.
Knowledge sources help the AI understand your applicationâ€™s current state and
make more informed responses.

```ts
type AiKnowledgeSource = {
  description: string;
  value: string;
};
```

<PropertiesList title="Properties">
  <PropertiesListItem name="description" type="string">
    A clear description of what this knowledge represents (e.g., "Current userâ€™s
    profile", "Application settings").
  </PropertiesListItem>
  <PropertiesListItem
    name="value"
    type="string | object | array | number | boolean | null"
  >
    The knowledge content. Can be any JSON-compatible format that provides
    context to the AI.
  </PropertiesListItem>
</PropertiesList>

Knowledge sources can be registered using
[`RegisterAiKnowledge`](/docs/api-reference/liveblocks-react#RegisterAiKnowledge)
or passed directly to [`AiChat`](/docs/api-reference/liveblocks-react-ui#AiChat)
via the `knowledge` prop.

```ts
// Example knowledge sources
const userKnowledge: AiKnowledgeSource = {
  description: "Current user information",
  value: { name: "John Doe", role: "admin" },
};

const appStateKnowledge: AiKnowledgeSource = {
  description: "Current application state",
  value: "The user is currently editing a document in dark mode",
};
```

### User [#user-type]

`User` is a type thatâ€™s returned by [`room.getSelf`][], [`room.getOthers`][],
and other functions. Some of its values are set when
[typing your room](#Typing-your-data), here are some example values:

```ts file="liveblocks.config.ts"
declare global {
  interface Liveblocks {
    // Each userâ€™s Presence
    // +++
    Presence: {
      cursor: { x: number; y: number };
    };
    // +++

    UserMeta: {
      id: string;
      // Custom user info set when authenticating with a secret key
      // +++
      info: {
        name: string;
        avatar: string;
      };
      // +++
    };
  }
}
```

```ts
const { room, leave } = client.enterRoom("my-room-id");

// {
//   connectionId: 52,
//   +++
//   presence: {
//     cursor: { x: 263, y: 786 },
//   },
//   +++
//   id: "mislav.abha@example.com",
//   +++
//   info: {
//     name: "Mislav Abha",
//     avatar: "/mislav.png",
//   },
//   +++
//   canWrite: true,
//   canComment: true,
// }
const user = room.getSelf();
```

<PropertiesList title="Properties">
  <PropertiesListItem name="connectionId" type="number">
    The connection ID of the User. It is unique and increments with every new
    connection.
  </PropertiesListItem>
  <PropertiesListItem name="id" type={`UserMeta["id"]`}>
    The ID of the User that has been set in the authentication endpoint. Useful
    to get additional information about the connected user.
  </PropertiesListItem>
  <PropertiesListItem name="info" type={`UserMeta["info"]`}>
    Additional user information that has been set in the authentication
    endpoint.
  </PropertiesListItem>
  <PropertiesListItem name="presence" type={`TPresence`}>
    The userâ€™s Presence data.
  </PropertiesListItem>
  <PropertiesListItem name="canWrite" type="boolean">
    `true` if the user can mutate the Roomâ€™s Storage and/or YDoc, `false` if
    they can only read but not mutate it. Set via your [room
    permissions](/docs/authentication#Room-permissions).
  </PropertiesListItem>
  <PropertiesListItem name="canComment" type="boolean">
    `true` if the user can leave a comment in the room, `false` if they can only
    read comments but not leave them. Set via your [room
    permissions](/docs/authentication#Room-permissions).
  </PropertiesListItem>
</PropertiesList>

[`atob`]: https://developer.mozilla.org/en-US/docs/Web/API/atob
[`base-64`]: https://www.npmjs.com/package/base-64
[`client.enterroom`]: /docs/api-reference/liveblocks-client#Client.enterRoom
[`client.getroom`]: /docs/api-reference/liveblocks-client#Client.getRoom
[`createclient`]: /docs/api-reference/liveblocks-client#createClient
[`fetch`]: https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API
[`livelist`]: /docs/api-reference/liveblocks-client#LiveList
[`livemap`]: /docs/api-reference/liveblocks-client#LiveMap
[`liveobject`]: /docs/api-reference/liveblocks-client#LiveObject
[`lostconnectiontimeout`]:
  /docs/api-reference/liveblocks-client#createClientLostConnectionTimeout
[`toimmutable`]: /docs/api-reference/liveblocks-client#LiveObject.toImmutable
[`node-fetch`]: https://npmjs.com/package/node-fetch
[`room.broadcastevent`]:
  /docs/api-reference/liveblocks-client#Room.broadcastEvent
[`room.getstorage`]: /docs/api-reference/liveblocks-client#Room.getStorage
[`room.reconnect`]: /docs/api-reference/liveblocks-client#Room.reconnect
[`room.getself`]: /docs/api-reference/liveblocks-client#Room.getSelf
[`room.getothers`]: /docs/api-reference/liveblocks-client#Room.getOthers
[`room.getstorage`]: /docs/api-reference/liveblocks-client#Room.getStorage
[`room.getsubscriptionsettings`]:
  /docs/api-reference/liveblocks-client#Room.getSubscriptionSettings
[`room.updatesubscriptionsettings`]:
  /docs/api-reference/liveblocks-client#Room.updateSubscriptionSettings
[`room.history`]: /docs/api-reference/liveblocks-client#Room.history
[`room.subscribe("event")`]:
  /docs/api-reference/liveblocks-client#Room.subscribe.event
[`room.subscribe("status")`]:
  /docs/api-reference/liveblocks-client#Room.subscribe.status
[`room.subscribe("lost-connection")`]:
  /docs/api-reference/liveblocks-client#Room.subscribe.lost-connection
[`room.subscribe("storage-status")`]:
  /docs/api-reference/liveblocks-client#Room.subscribe.storage-status
[`room.updatepresence`]:
  /docs/api-reference/liveblocks-client#Room.updatePresence
[`websocket`]: https://developer.mozilla.org/en-US/docs/Web/API/WebSocket
[`ws`]: https://www.npmjs.com/package/ws
[connection status example]:
  https://liveblocks.io/examples/connection-status/nextjs
[3.4]: https://github.com/liveblocks/liveblocks/releases/tag/v3.4.0

---
meta:
  title: "@liveblocks/emails"
  parentTitle: "API Reference"
  description: "API Reference for the @liveblocks/emails package"
alwaysShowAllNavigationLevels: false
---

`@liveblocks/emails` provides a set of functions that simplifies sending styled
emails with [Notifications](/docs/ready-made-features/notifications) and
[webhooks](/docs/platform/webhooks). This library is only intended for use in
your Node.js back end.

## Requirements

`@liveblocks/emails` requires the
[`@liveblocks/node`](/docs/api-reference/liveblocks-node) package to be
installed and for [`react`](https://react.dev/) to be a peer dependency in your
project.

## Setup

This package exposes functions that enable easy creation of styled emails with
React and HTML. Each method is designed to be used with our
[webhooks](/docs/platform/webhooks) which means you must
[set them up](/docs/guides/how-to-test-webhooks-on-localhost) first. Webhooks
require an API endpoint in your application, and this is typically what they
will look like.

```tsx title="Next.js route handler for webhooks"
import { isThreadNotificationEvent, WebhookHandler } from "@liveblocks/node";
import { Liveblocks } from "@liveblocks/node";
// +++
import { prepareThreadNotificationEmailAsReact } from "@liveblocks/emails";
// +++

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

const webhookHandler = new WebhookHandler(
  process.env.LIVEBLOCKS_WEBHOOK_SECRET_KEY as string
);

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // +++
  // Using `@liveblocks/emails` to create an email
  if (isThreadNotificationEvent(event)) {
    const emailData = await prepareThreadNotificationEmailAsReact(
      liveblocks,
      event
    );

    if (emailData.type === "unreadMention") {
      const email = (
        <div>
          <div>
            @{emailData.comment.author.id} at {emailData.comment.createdAt}
          </div>
          <div>{emailData.comment.body}</div>
        </div>
      );

      // Send unread mention email
      // ...
    }
  }
  // +++

  return new Response(null, { status: 200 });
}
```

**Weâ€™ll only show the highlighted part below**, as itâ€™s assumed youâ€™ve set this
already, and your file contains `liveblocks` and `event`.

### End-to-end guides

We have two guides that take you through every step of setting up your email
notifications, including setting up webhooks:

- [How to send email notifications of unread comments](/docs/guides/how-to-send-email-notifications-of-unread-comments).
- [How to send email notifications for unread text editor mentions ](/docs/guides/how-to-send-email-notifications-for-unread-text-editor-mentions).

### Ready-made email templates

We have a number of examples that show you how to set up emails with your
Comments or Text Editor application. Each [Resend](https://resend.com) example
has full ready-made email templates inside, which are a great starting point for
your application.

- [Comments + Resend](/examples/comments-emails/nextjs-comments-emails-resend).
- [Comments + SendGrid](/examples/comments-emails/nextjs-comments-emails-sendgrid).
- [Text Editor/Tiptap + Resend](/examples/collaborative-text-editor-emails/nextjs-tiptap-emails-resend).
- [Text Editor/Lexical + Resend](/examples/collaborative-text-editor-emails/nextjs-lexical-emails-resend).

## Thread notification emails [#thread-notification-emails]

These functions help you create emails to notify users of _unread comments_ in
threads. They fetch each relevant comment, filtering out any that have already
been read, and help you style each commentâ€™s body with either
[React](#prepare-thread-notification-email-as-react) or
[HTML](#prepare-thread-notification-email-as-html).

<Figure>
  <Image
    src="/assets/emails/new-comments-email.png"
    alt="An email showing 7 new comments, with comment bodies and links to each comment"
    width={1567}
    height={830}
  />
</Figure>

<Banner>

This screenshot shows a ready-made template from our
[Comments + Resend](/examples/comments-emails/nextjs-comments-emails-resend)
example.

</Banner>

These functions also help you distinguish between _unread mentions_ and _unread
replies_.

A thread has _unread replies_ if a comment was created after the `readAt` date
on the notification, and created before or at the same time as the `notifiedAt`
date. All unread replies are returned in an array.

```js
{
  type: "unreadReplies",
  roomId: "my-room-id",
  comments: [
    {/* Comment data */},
    // ...
  ],
}
```

A thread has an _unread mention_ if it has unread replies, and one of the
replies mentions the user. A single comment with the latest mention is returned.

```js
{
  type: "unreadMention",
  roomId: "my-room-id",
  comment: {/* Comment data */},
}
```

### prepareThreadNotificationEmailAsReact [#prepare-thread-notification-email-as-react]

Takes a
[thread notification webhook event](/docs/platform/webhooks#Thread-notification)
and returns unread comment body(s) related to the notification, as React nodes.
It can return one of three formats, an `unreadMention` type containing one
comment, an `unreadReplies` type returning multiple comments, or `null` if there
are no unread mentions/replies. You can also
[resolve public data](#prepare-thread-notification-email-as-react-resolving-data)
and
[customize the components](#prepare-thread-notification-email-as-react-customizing-components).

```tsx
import { prepareThreadNotificationEmailAsReact } from "@liveblocks/emails";
import { isThreadNotificationEvent } from "@liveblocks/node";

// Get `liveblocks` and `event` (see "Setup" section)
// ...

if (isThreadNotificationEvent(event)) {
  // +++
  const emailData = await prepareThreadNotificationEmailAsReact(
    liveblocks,
    event
  );
  // +++
  let email;

  switch (emailData.type) {
    case "unreadMention": {
      email = (
        <div>
          <div>
            @{emailData.comment.author.id} at {emailData.comment.createdAt}
          </div>
          <div>{emailData.comment.body}</div>
        </div>
      );
      break;
    }

    case "unreadReplies": {
      email = (
        <div>
          {emailData.comments.map((comment) => (
            <div key={comment.id}>
              <div>
                @{comment.author.id} at {comment.createdAt}
              </div>
              <div>{comment.body}</div>
            </div>
          ))}
        </div>
      );
      break;
    }
  }
}

// Send your email
// ...
```

Itâ€™s designed to be used in a webhook event, which requires a
[`Liveblocks`](/docs/api-reference/liveblocks-node#Liveblocks-client) Node.js
client and a
[`WebhookHandler`](/docs/api-reference/liveblocks-node#WebhookHandler). Check
for the correct webhook event using
[`isThreadNotificationEvent`](/docs/api-reference/liveblocks-node#isThreadNotificationEvent)
before running the function, such as in this Next.js route handler.

```tsx title="Full Next.js route handler example" isCollapsed isCollapsable
import { isThreadNotificationEvent, WebhookHandler } from "@liveblocks/node";
import { Liveblocks } from "@liveblocks/node";
// +++
import { prepareThreadNotificationEmailAsReact } from "@liveblocks/emails";
// +++

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

const webhookHandler = new WebhookHandler(
  process.env.LIVEBLOCKS_WEBHOOK_SECRET_KEY as string
);

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // +++
  if (isThreadNotificationEvent(event)) {
    const emailData = await prepareThreadNotificationEmailAsReact(
      liveblocks,
      event
    );
    let email;

    switch (emailData.type) {
      case "unreadMention": {
        email = (
          <div>
            <div>
              @{emailData.comment.author.id} at {emailData.comment.createdAt}
            </div>
            <div>{emailData.comment.body}</div>
          </div>
        );
        break;
      }

      case "unreadReplies": {
        email = (
          <div>
            {emailData.comments.map((comment) => (
              <div key={comment.id}>
                <div>
                  @{comment.author.id} at {comment.createdAt}
                </div>
                <div>{comment.body}</div>
              </div>
            ))}
          </div>
        );
        break;
      }
    }

    // Send your email
    // ...
  }
  // +++

  return new Response(null, { status: 200 });
}
```

<PropertiesList title="Returns">
  <PropertiesListItem
    name="value"
    type="ThreadNotificationEmailDataAsReact | null"
  >
    Returns comment information, and a formatted React body, ready for use in emails. Returns `null` if there are no unread mentions or replies. The result has two formats depending on whether this notification is for a *single unread mention*, or for *multiple unread replies*:

    ```js title="Unread mention" isCollapsable isCollapsed
    {
      type: "unreadMention",
      roomId: "my-room-id",

      // An unread mention has just one comment
      comment: {
        id: "cm_asfs8f...",
        threadId: "th_sj30as...",
        createdAt: Date <Fri Dec 15 2023 14:15:22 GMT+0000 (Greenwich Mean Time)>,

        // The formatted comment, pass it to React `children`
        body: { /* ... */},

        author: {
          id: "aurÃ©lien@example.com",
          info: { /* Custom user info you have resolved */ },
        },
      },
    }
    ```

    <div className="-mt-2">

    ```js title="Unread replies" isCollapsable isCollapsed
    {
      type: "unreadReplies",
      roomId: "my-room-id",

      // Unread replies means multiple comments
      comments: [
        {
          id: "cm_asfs8f...",
          threadId: "th_sj30as..."
          createdAt: Date <Fri Dec 15 2023 14:15:22 GMT+0000 (Greenwich Mean Time)>,

          // The formatted comment, pass it to React `children`
          body: { /* ... */},

          author: {
            id: "aurÃ©lien@example.com",
            info: { /* Custom user info you have resolved */ },
          },
        },

        // More comments
        //...
      ],
    }
    ```

    </div>

  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem name="client" type="Liveblocks" required>
    A [`Liveblocks`](/docs/api-reference/liveblocks-node#Liveblocks-client)
    Node.js client.
  </PropertiesListItem>
  <PropertiesListItem name="event" type="ThreadNotificationEvent" required>
    An object passed from a webhook event, specifically the
    [`ThreadNotificationEvent`](/docs/platform/webhooks#Thread-notification).
    [Learn more about setting this up](#Setup).
  </PropertiesListItem>
  <PropertiesListItem name="options" type="object">
    A number of options to customize the format of the comments, adding user
    info, room info, and styles.
  </PropertiesListItem>
  <PropertiesListItem
    name="options.resolveUsers"
    detailedType='async? (args: ResolveUsersArgs) => (UserMeta["info"] | undefined)[] | undefined'
  >
    A function that resolves user information. Return an array of
    `UserMeta["info"]` objects in the same order they arrived. Works similarly
    to the [resolver on the
    client](/docs/api-reference/liveblocks-react#LiveblocksProviderResolveUsers).
    [Learn more](#prepare-thread-notification-email-as-react-resolving-data).
  </PropertiesListItem>
  <PropertiesListItem
    name="options.resolveGroupsInfo"
    detailedType="async? (args: ResolveGroupsInfoArgs) => (GroupInfo | undefined)[] | undefined"
  >
    A function that resolves group information. Return an array of `GroupInfo`
    objects in the same order they arrived. Works similarly to the [resolver on
    the
    client](/docs/api-reference/liveblocks-react#LiveblocksProviderResolveGroupsInfo).
    [Learn more](#prepare-thread-notification-email-as-react-resolving-data).
  </PropertiesListItem>
  <PropertiesListItem
    name="options.resolveRoomInfo"
    detailedType="async? (args: ResolveRoomInfoArgs) => RoomInfo | undefined"
  >
    A function that resolves room information. Return a `RoomInfo` object, as
    matching your types. Works similarly to the [resolver on the
    client](/docs/api-reference/liveblocks-react#LiveblocksProviderResolveRoomsInfo)
    but for one room. [Learn
    more](#prepare-thread-notification-email-as-react-resolving-data).
  </PropertiesListItem>
  <PropertiesListItem name="options.components" type="object">
    Pass different React components to customize the elements in the comment
    bodies. Five components can be passed to the object: `Container`,
    `Paragraph`, `Text`, `Link`, `Mention`. [Learn
    more](#prepare-thread-notification-email-as-react-customizing-components).
  </PropertiesListItem>
  <PropertiesListItem
    name="options.components.Container"
    type="({ children: ReactNode }) => ReactNode"
  >
    The comment body container.
  </PropertiesListItem>
  <PropertiesListItem
    name="options.components.Paragraph"
    type="({ children: ReactNode }) => ReactNode"
  >
    The paragraph block.
  </PropertiesListItem>
  <PropertiesListItem
    name="options.components.Text"
    type="({ children: ReactNode }) => ReactNode"
  >
    The text element.
  </PropertiesListItem>
  <PropertiesListItem
    name="options.components.Link"
    detailedType="({ element: CommentBodyLink, href: string }) => ReactNode"
  >
    The link element.
  </PropertiesListItem>
  <PropertiesListItem
    name="options.components.Mention"
    detailedType={`({ element: CommentBodyMention, user?: UserInfo["info"], group?: GroupInfo }) => ReactNode`}
  >
    The mention element.
  </PropertiesListItem>
</PropertiesList>

#### Resolving data [#prepare-thread-notification-email-as-react-resolving-data]

Similarly to on the client, you can resolve
[users](/docs/api-reference/liveblocks-react#LiveblocksProviderResolveUsers),
[group info](/docs/api-reference/liveblocks-react#LiveblocksProviderResolveGroupsInfo),
and
[room info](/docs/api-reference/liveblocks-react#LiveblocksProviderResolveRoomsInfo),
making it easier to render your emails. For example, you can resolve a userâ€™s ID
into their name, and show their name in the email.

<Banner title="Resolving users and groups" type="info">
  When resolving users and groups, the function receives a list of IDs and you
  should return a list of objects of the same size, in the same order.
</Banner>

```tsx
const emailData = await prepareThreadNotificationEmailAsReact(
  liveblocks,
  webhookEvent,
  {
    // +++
    resolveUsers: async ({ userIds }) => {
      const usersData = await __getUsersFromDB__(userIds);

      return usersData.map((userData) => ({
        name: userData.name, // "Nimesh"
        avatar: userData.avatar.src, // "https://..."
      }));
    },
    resolveGroupsInfo: async ({ groupIds }) => {
      const groupsData = await __getGroupsFromDB__(groupIds);

      return groupsData.map((groupData) => ({
        name: groupData.name, // "Engineering"
        avatar: groupData.avatar.src, // "https://..."
      }));
    },
    resolveRoomInfo({ roomId }) {
      return {
        name: roomId, // "my-room-name"
        url: `https://example.com/${roomId}`,
      };
    },
    // +++
  }
);

// { type: "unreadMention", comment: { ... }, ... }
console.log(emailData);

// { name: "Nimesh", avatar: "https://..." }
console.log(emailData.comment.author.info);

// { name: "my-room-name", url: "https://example.com/my-room-name" }
console.log(emailData.roomInfo);
```

#### Customizing components [#prepare-thread-notification-email-as-react-customizing-components]

Each React component in the comment body can be replaced with a custom React
component, if you wish to apply different styles. Five components are available:
`Container`, `Paragraph`, `Text`, `Link`, `Mention`.

```tsx
const emailData = await prepareThreadNotificationEmailAsReact(
  liveblocks,
  webhookEvent,
  {
    // +++
    components: {
      Paragraph: ({ children }) => <p>{children}</p>,

      // `react-email` components are supported
      Text: ({ children }) => (
        <Text className="text-sm text-black m-0 mb-4">{children}</Text>
      ),

      // `user` and `group` are the optional data returned from `resolveUsers` and `resolveGroupsInfo`
      Mention: ({ element, user, group }) => (
        <span style={{ color: "red" }}>
          @{user?.name ?? group?.name ?? element.id}
        </span>
      ),

      // If the link is rich-text render it, otherwise use the URL
      Link: ({ element, href }) => <a href={href}>{element?.text ?? href}</a>,
    },
    // +++
  }
);

// { type: "unreadMention", comment: { ... }, ... }
console.log(emailData);

// The previously defined components are used in the body property, now formatted as React nodes.
console.log(emailData.comment.body);
```

### prepareThreadNotificationEmailAsHtml [#prepare-thread-notification-email-as-html]

Takes a
[thread notification webhook event](/docs/platform/webhooks#Thread-notification)
and returns unread comment body(s) related to the notification, as an HTML-safe
string. It can return one of three formats, an `unreadMention` type containing
one comment, an `unreadReplies` type returning multiple comments, or `null` if
there are no unread mentions/replies. You can also
[resolve public data](#prepare-thread-notification-email-as-html-resolving-data)
and
[customize the styles](#prepare-thread-notification-email-as-html-styling-elements).

```ts
import { prepareThreadNotificationEmailAsHtml } from "@liveblocks/emails";
import { isThreadNotificationEvent } from "@liveblocks/node";

// Get `liveblocks` and `event` (see "Setup" section)
// ...

if (isThreadNotificationEvent(event)) {
  // +++
  const emailData = await prepareThreadNotificationEmailAsHtml(
    liveblocks,
    event
  );
  // +++
  let email;

  switch (emailData.type) {
    case "unreadMention": {
      email = `
        <div>
          <div>
            @${emailData.comment.author.id} at ${emailData.comment.createdAt}
          </div>
          <div>${emailData.comment.body}</div>
        </div>
      `;
      break;
    }

    case "unreadReplies": {
      email = `
        <div>
          ${emailData.comments
            .map(
              (comment) => `
                <div>
                  <div>
                    @${comment.author.id} at ${comment.createdAt}
                  </div>
                  <div>${comment.body}</div>
                </div>
              `
            )
            .join("")}
        </div>
      `;
      break;
    }
  }
}

// Send your email
// ...
```

Itâ€™s designed to be used in a webhook event, which requires a
[`Liveblocks`](/docs/api-reference/liveblocks-node#Liveblocks-client) Node.js
client, a
[`WebhookHandler`](/docs/api-reference/liveblocks-node#WebhookHandler). Check
for the correct webhook event using
[`isThreadNotificationEvent`](/docs/api-reference/liveblocks-node#isThreadNotificationEvent)
before running the function, such as in this Next.js route handler.

```tsx title="Full Next.js route handler example" isCollapsed isCollapsable
import { isThreadNotificationEvent, WebhookHandler } from "@liveblocks/node";
import { Liveblocks } from "@liveblocks/node";
// +++
import { prepareThreadNotificationEmailAsHtml } from "@liveblocks/emails";
// +++

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

const webhookHandler = new WebhookHandler(
  process.env.LIVEBLOCKS_WEBHOOK_SECRET_KEY as string
);

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // +++
  if (isThreadNotificationEvent(event)) {
    const emailData = await prepareThreadNotificationEmailAsHtml(
      liveblocks,
      event
    );
    let email;

    switch (emailData.type) {
      case "unreadMention": {
        email = `
        <div>
          <div>
            @${emailData.comment.author.id} at ${emailData.comment.createdAt}
          </div>
          <div>${emailData.comment.body}</div>
        </div>
      `;
        break;
      }

      case "unreadReplies": {
        email = `
        <div>
          ${emailData.comments
            .map(
              (comment) => `
                <div>
                  <div>
                    @${comment.author.id} at ${comment.createdAt}
                  </div>
                  <div>${comment.body}</div>
                </div>
              `
            )
            .join("")}
        </div>
      `;
        break;
      }
    }

    // Send your email
    // ...
  }
  // +++

  return new Response(null, { status: 200 });
}
```

<PropertiesList title="Returns">
  <PropertiesListItem
    name="value"
    type="ThreadNotificationEmailDataAsHtml | null"
  >
    Returns comment information, and a formatted HTML body, ready for use in emails. Returns `null` if there are no unread mentions or comments. The result has two formats depending on whether this notification is for a *single unread mention*, or for *multiple unread replies*:

    ```js title="Unread mention" isCollapsable isCollapsed
    {
      type: "unreadMention",
      roomId: "my-room-id",

      // An unread mention has just one comment
      comment: {
        id: "cm_asfs8f...",
        threadId: "th_sj30as...",
        createdAt: Date <Fri Dec 15 2023 14:15:22 GMT+0000 (Greenwich Mean Time)>,

        // The formatted comment, as an HTML string
        body: "<div>...</div>",

        author: {
          id: "aurÃ©lien@example.com",
          info: { /* Custom user info you have resolved */ },
        },
      },
    }
    ```

    <div className="-mt-2">

      ```js title="Unread replies" isCollapsable isCollapsed
      {
        type: "unreadReplies",
        roomId: "my-room-id",

        // Unread replies means multiple comments
        comments: [
          {
            id: "cm_asfs8f...",
            threadId: "th_sj30as...",
            createdAt: Date <Fri Dec 15 2023 14:15:22 GMT+0000 (Greenwich Mean Time)>,

            // The formatted comment, as an HTML string
            body: "<div>...</div>",

            author: {
              id: "aurÃ©lien@example.com",
              info: { /* Custom user info you have resolved */ },
            },
          },

        // More comments
        //...
        ],
      }
      ```

    </div>

  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem name="client" type="Liveblocks" required>
    A [`Liveblocks`](/docs/api-reference/liveblocks-node#Liveblocks-client)
    Node.js client.
  </PropertiesListItem>
  <PropertiesListItem name="event" type="ThreadNotificationEvent" required>
    An object passed from a webhook event, specifically the
    [`ThreadNotificationEvent`](/docs/platform/webhooks#Thread-notification).
    [Learn more about setting this up](#Setup).
  </PropertiesListItem>
  <PropertiesListItem name="options" type="object">
    A number of options to customize the format of the comments, adding user
    info, room info, and styles.
  </PropertiesListItem>
  <PropertiesListItem
    name="options.resolveUsers"
    detailedType='async? (args: ResolveUsersArgs) => (UserMeta["info"] | undefined)[] | undefined'
  >
    A function that resolves user information in
    [Comments](/docs/ready-made-features/comments). Return an array of
    `UserMeta["info"]` objects in the same order they arrived. Works similarly
    to the [resolver on the
    client](/docs/api-reference/liveblocks-react#LiveblocksProviderResolveUsers).
    [Learn more](#prepare-thread-notification-email-as-html-resolving-data).
  </PropertiesListItem>
  <PropertiesListItem
    name="options.resolveGroupsInfo"
    detailedType="async? (args: ResolveGroupsInfoArgs) => (GroupInfo | undefined)[] | undefined"
  >
    A function that resolves group information. Return an array of `GroupInfo`
    objects in the same order they arrived. Works similarly to the [resolver on
    the
    client](/docs/api-reference/liveblocks-react#LiveblocksProviderResolveGroupsInfo).
    [Learn more](#prepare-thread-notification-email-as-react-resolving-data).
  </PropertiesListItem>
  <PropertiesListItem
    name="options.resolveRoomInfo"
    detailedType="async? (args: ResolveRoomInfoArgs) => RoomInfo | undefined"
  >
    A function that resolves room information. Return a `RoomInfo` object, as
    matching your types. Works similarly to the [resolver on the
    client](/docs/api-reference/liveblocks-react#LiveblocksProviderResolveRoomsInfo)
    but for one room. [Learn
    more](#prepare-thread-notification-email-as-html-resolving-data).
  </PropertiesListItem>
  <PropertiesListItem name="options.styles" type="object">
    Pass CSS properties to style the different HTML elements in the comment
    bodies. Five elements can be styled: `paragraph`, `code`, `strong`, `link`,
    `mention`. [Learn
    more](#prepare-thread-notification-email-as-html-styling-elements).
  </PropertiesListItem>
  <PropertiesListItem name="options.styles.container" type="CSSProperties">
    Inline styles to apply to the comment body container.
  </PropertiesListItem>
  <PropertiesListItem name="options.styles.paragraph" type="CSSProperties">
    Inline styles to apply to the paragraph block.
  </PropertiesListItem>
  <PropertiesListItem name="options.styles.code" type="CSSProperties">
    Inline styles to apply to the code element.
  </PropertiesListItem>
  <PropertiesListItem name="options.styles.strong" type="CSSProperties">
    Inline styles to apply to the strong element.
  </PropertiesListItem>
  <PropertiesListItem name="options.styles.mention" type="CSSProperties">
    Inline styles to apply to the mention element.
  </PropertiesListItem>
  <PropertiesListItem name="options.styles.link" type="CSSProperties">
    Inline styles to apply to the link element.
  </PropertiesListItem>
</PropertiesList>

#### Resolving data [#prepare-thread-notification-email-as-html-resolving-data]

Similarly to on the client, you can resolve
[users](/docs/api-reference/liveblocks-react#LiveblocksProviderResolveUsers),
[group info](/docs/api-reference/liveblocks-react#LiveblocksProviderResolveGroupsInfo),
and
[room info](/docs/api-reference/liveblocks-react#LiveblocksProviderResolveRoomsInfo),
making it easier to render your emails. For example, you can resolve a userâ€™s ID
into their name, and show their name in the email.

<Banner title="Resolving users and groups" type="info">
  When resolving users and groups, the function receives a list of IDs and you
  should return a list of objects of the same size, in the same order.
</Banner>

```tsx
const emailData = await prepareThreadNotificationEmailAsHtml(
  liveblocks,
  webhookEvent,
  {
    // +++
    resolveUsers: async ({ userIds }) => {
      const usersData = await __getUsersFromDB__(userIds);

      return usersData.map((userData) => ({
        name: userData.name, // "Nimesh"
        avatar: userData.avatar.src, // "https://..."
      }));
    },
    resolveGroupsInfo: async ({ groupIds }) => {
      const groupsData = await __getGroupsFromDB__(groupIds);

      return groupsData.map((groupData) => ({
        name: groupData.name, // "Engineering"
        avatar: groupData.avatar.src, // "https://..."
      }));
    },
    resolveRoomInfo({ roomId }) {
      return {
        name: roomId, // "my-room-name"
        url: `https://example.com/${roomId}`,
      };
    },
    // +++
  }
);

// { type: "unreadMention", comment: { ... }, ... }
console.log(emailData);

// { name: "Nimesh", avatar: "https://..." }
console.log(emailData.comment.author.info);

// { name: "my-room-name", url: "https://example.com/my-room-name" }
console.log(emailData.roomInfo);
```

#### Styling elements [#prepare-thread-notification-email-as-html-styling-elements]

Each element in the comment body can be styled with custom CSS properties, if
you would like to change the appearance. Five elements are available:
`paragraph`, `code`, `strong`, `mention`, `link`.

```tsx
const emailData = await prepareThreadNotificationEmailAsHtml(
  liveblocks,
  webhookEvent,
  {
    // +++
    styles: {
      paragraph: { margin: "12px 0" },

      mention: {
        fontWeight: "bold",
        color: "red",
      },

      link: {
        textDecoration: "underline",
      },
    },
    // +++
  }
);

// { type: "unreadMention", comment: { ... }, ... }
console.log(emailData);

// The elements in the comment body are now styled
console.log(emailData.comment.body);
```

## Text Mention notification emails [#text-mention-notification-emails]

These functions help you create emails to notify users when they have an _unread
mention_ in a [Text Editor](/docs/ready-made-features/text-editor) document. In
this case, a mention is not related to comments, but is instead an inline
mention inside the text editor itself. If the mention has not been read, the
functions fetch a text mention and its surrounding text, giving you more
context, and helping you style the mention content with either
[React](#prepare-text-mention-notification-email-as-react) or
[HTML](#prepare-text-mention-notification-email-as-html).

<Figure>
  <Image
    src="/assets/emails/new-text-mention-email.png"
    alt="An email showing a text mention in a text editor document"
    width={1126}
    height={470}
  />
</Figure>

<Banner>

This screenshot shows a ready-made template from our
[Text Editor + Resend](/examples/collaborative-text-editor-emails/nextjs-tiptap-emails-resend)
examples.

</Banner>

The functions help to determine if the mention still exists in the document and
will indicate that thereâ€™s no email to send in this case. Currently, only
mentions in paragraph blocks create notifications, as there are limitations
around retrieving mentions in plugins.

### Limitations

Before you get started, there are some limitations with text mentions that you
should be aware of.

#### Mentions in plugins

If a user is mentioned in a plugin or extension, a text mention notification is
not sent. This is because Liveblocks doesnâ€™t know the exact schema of your
editor and all its plugins, and we canâ€™t extract the data correctly. This means
that _only mentions in paragraph blocks are sent_, and mentions in lists,
checkboxes, etc., are not, as they are all powered by plugins. Weâ€™re
investigating solutions for this, and weâ€™d like to
[hear from you](/contact/support) if you have any thoughts.

#### Multiple Tiptap editors

Tiptap optionally allows you to
[render multiple editors per page](/docs/ready-made-features/text-editor/tiptap#Multiple-editors),
instead of just one. For now, these functions only support one editor per room,
but weâ€™ll be looking to add support for more later.

#### BlockNote

This package does not yet support our
[collaborative BlockNote text editor](/docs/api-reference/liveblocks-react-blocknote)
integration. Support of BlockNote is planned for a future release and is
currently on our development roadmap. Users requiring BlockNote compatibility
should monitor package updates for this upcoming feature.

### prepareTextMentionNotificationEmailAsReact [#prepare-text-mention-notification-email-as-react]

Takes a
[text mention notification webhook event](/docs/platform/webhooks#TextMention-notification)
and returns an unread text mention with its surrounding text as React nodes. It
can also return `null` if the text mention does not exist anymore or has been
already been read. You can also
[resolve public data](#prepare-text-mention-notification-email-as-react-resolving-data)
and
[customize the components](#prepare-text-mention-notification-email-as-react-customizing-components).

```tsx
import { prepareTextMentionNotificationEmailAsReact } from "@liveblocks/emails";
import { isTextMentionNotificationEvent } from "@liveblocks/node";

// Get `liveblocks` and `event` (see "Setup" section)
// ...

if (isTextMentionNotificationEvent(event)) {
  // +++
  const emailData = await prepareTextMentionNotificationEmailAsReact(
    liveblocks,
    event
  );
  // +++

  const email = (
    <div>
      <div>
        @{emailData.mention.author.id} at {emailData.mention.createdAt}
      </div>
      <div>{emailData.mention.content}</div>
    </div>
  );
}

// Send your email
// ...
```

Itâ€™s designed to be used in a webhook event, which requires a
[`Liveblocks`](/docs/api-reference/liveblocks-node#Liveblocks-client) Node.js
client and a
[`WebhookHandler`](/docs/api-reference/liveblocks-node#WebhookHandler). Check
for the correct webhook event using
[`isTextMentionNotificationEvent`](/docs/api-reference/liveblocks-node#isTextMentionNotificationEvent)
before running the function, such as in this Next.js route handler.

```tsx title="Full Next.js route handler example" isCollapsed isCollapsable
import {
  isTextMentionNotificationEvent,
  WebhookHandler,
} from "@liveblocks/node";
import { Liveblocks } from "@liveblocks/node";
// +++
import { prepareTextMentionNotificationEmailAsReact } from "@liveblocks/emails";
// +++

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

const webhookHandler = new WebhookHandler(
  process.env.LIVEBLOCKS_WEBHOOK_SECRET_KEY as string
);

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // +++
  if (isTextMentionNotificationEvent(event)) {
    const emailData = await prepareTextMentionNotificationEmailAsReact(
      liveblocks,
      event
    );

    const email = (
      <div>
        <div>
          @{emailData.mention.author.id} at {emailData.mention.createdAt}
        </div>
        <div>{emailData.mention.content}</div>
      </div>
    );

    // Send your email
    // ...
  }
  // +++

  return new Response(null, { status: 200 });
}
```

<PropertiesList title="Returns">
  <PropertiesListItem
    name="value"
    type="TextMentionNotificationEmailDataAsReact | null"
  >
    Returns text mention information, and a formatted React content ready for
    use in emails. Returns `null` if the text mention does not exist anymore or
    has already been read.

    ```js title="Unread text mention"
    {
      roomInfo: {
        name: "my room name",
        url: "https://my-room-url.io"
      },
      mention: {
        kind: "user",
        textMentionId: "in_oiujhdg...",
        id: "user-0",
        roomId: "my-room-id",
        createdAt: Date <Fri Dec 15 2023 14:15:22 GMT+0000 (Greenwich Mean Time)>,

        // The formatted content, pass it to React `children`
        content: { /* ... */}

        author: {
          id: "vincent@example.com",
          info: { /* Custom user info you have resolved */ }
        }
      },
    }
    ```

  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem name="client" type="Liveblocks" required>
    A [`Liveblocks`](/docs/api-reference/liveblocks-node#Liveblocks-client)
    Node.js client.
  </PropertiesListItem>
  <PropertiesListItem name="event" type="TextMentionNotificationEvent" required>
    An object passed from a webhook event, specifically the
    [`TextMentionNotificationEvent`](/docs/platform/webhooks#TextMention-notification).
    [Learn more about setting this up](#Setup).
  </PropertiesListItem>
  <PropertiesListItem name="options" type="object">
    A number of options to customize the format of the content, adding user
    info, room info, and styles.
  </PropertiesListItem>
  <PropertiesListItem
    name="options.resolveUsers"
    detailedType='async? (args: ResolveUsersArgs) => (UserMeta["info"] | undefined)[] | undefined'
  >
    A function that resolves user information in
    [Comments](/docs/ready-made-features/comments). Return an array of
    `UserMeta["info"]` objects in the same order they arrived. Works similarly
    to the [resolver on the
    client](/docs/ready-made-features/text-editor/lexical#Users-and-mentions).
    [Learn
    more](#prepare-text-mention-notification-email-as-react-resolving-data).
  </PropertiesListItem>
  <PropertiesListItem
    name="options.resolveGroupsInfo"
    detailedType="async? (args: ResolveGroupsInfoArgs) => (GroupInfo | undefined)[] | undefined"
  >
    A function that resolves group information. Return an array of `GroupInfo`
    objects in the same order they arrived. Works similarly to the [resolver on
    the
    client](/docs/api-reference/liveblocks-react#LiveblocksProviderResolveGroupsInfo).
    [Learn more](#prepare-thread-notification-email-as-react-resolving-data).
  </PropertiesListItem>
  <PropertiesListItem
    name="options.resolveRoomInfo"
    detailedType="async? (args: ResolveRoomInfoArgs) => RoomInfo | undefined"
  >
    A function that resolves room information. Return a `RoomInfo` object, as
    matching your types. Works similarly to the [resolver on the
    client](/docs/api-reference/liveblocks-react#LiveblocksProviderResolveRoomsInfo)
    but for one room. [Learn
    more](#prepare-text-mention-notification-email-as-react-resolving-data).
  </PropertiesListItem>
  <PropertiesListItem name="options.components" type="object">
    Pass different React components to customize the elements in the mention
    content. Three components can be passed to the object: `Container`, `Text`,
    and `Mention`. [Learn
    more](#prepare-text-mention-notification-email-as-react-customizing-components).
  </PropertiesListItem>
  <PropertiesListItem
    name="options.components.Container"
    type="({ children: ReactNode }) => ReactNode"
  >
    The mention and its surrounding text container
  </PropertiesListItem>
  <PropertiesListItem
    name="options.components.Text"
    type="({ children: ReactNode }) => ReactNode"
  >
    The text element.
  </PropertiesListItem>
  <PropertiesListItem
    name="options.components.Mention"
    detailedType={`({ element: LiveblocksTextEditorMentionNode, user?: UserInfo["info"], group?: GroupInfo }) => ReactNode`}
  >
    The mention element.
  </PropertiesListItem>
</PropertiesList>

#### Resolving data [#prepare-text-mention-notification-email-as-react-resolving-data]

Similarly to on the client, you can resolve
[users](/docs/api-reference/liveblocks-react#LiveblocksProviderResolveUsers),
[group info](/docs/api-reference/liveblocks-react#LiveblocksProviderResolveGroupsInfo),
and
[room info](/docs/api-reference/liveblocks-react#LiveblocksProviderResolveRoomsInfo),
making it easier to render your emails. For example, you can resolve a userâ€™s ID
into their name, and show their name in the email.

<Banner title="Resolving users and groups" type="info">
  When resolving users and groups, the function receives a list of IDs and you
  should return a list of objects of the same size, in the same order.
</Banner>

```tsx
const emailData = await prepareTextMentionNotificationEmailAsReact(
  liveblocks,
  webhookEvent,
  {
    // +++
    resolveUsers: async ({ userIds }) => {
      const usersData = await __getUsersFromDB__(userIds);

      return usersData.map((userData) => ({
        name: userData.name, // "Nimesh"
        avatar: userData.avatar.src, // "https://..."
      }));
    },
    resolveGroupsInfo: async ({ groupIds }) => {
      const groupsData = await __getGroupsFromDB__(groupIds);

      return groupsData.map((groupData) => ({
        name: groupData.name, // "Engineering"
        avatar: groupData.avatar.src, // "https://..."
      }));
    },
    resolveRoomInfo({ roomId }) {
      return {
        name: roomId, // "my-room-name"
        url: `https://example.com/${roomId}`,
      };
    },
    // +++
  }
);

// { mention: { ... }, ... }
console.log(emailData);

// { name: "Nimesh", avatar: "https://..." }
console.log(emailData.mention.author.info);

// { name: "my-room-name", url: "https://example.com/my-room-name" }
console.log(emailData.roomInfo);
```

#### Customizing components [#prepare-text-mention-notification-email-as-react-customizing-components]

Each React component in the mention context can be replaced with a custom React
component, if you wish to apply different styles. Three components are
available: `Container`, `Text`, and `Mention`.

```tsx
const emailData = await prepareTextMentionNotificationEmailAsReact(
  liveblocks,
  webhookEvent,
  {
    // +++
    components: {
      // `react-email` components are supported
      Container: ({ children }) => <Section>{children}</Section>,

      Text: ({ children }) => (
        <Text className="text-sm text-black m-0 mb-4">{children}</Text>
      ),

      // `user` and `group` are the optional data returned from `resolveUsers` and `resolveGroupsInfo`
      Mention: ({ element, user, group }) => (
        <span style={{ color: "red" }}>
          @{user?.name ?? group?.name ?? element.id}
        </span>
      ),
    },
    // +++
  }
);

// { mention: { ... }, ... }
console.log(emailData);

// The components are now used in this React content
console.log(emailData.mention.content);
```

### prepareTextMentionNotificationEmailAsHtml [#prepare-text-mention-notification-email-as-html]

Takes a
[text mention notification webhook event](/docs/platform/webhooks#TextMention-notification)
and returns an unread text mention with its surrounding text as an HTML string.
It can also return `null` if the text mention does not exist anymore or has been
already been read. You can also
[resolve public data](#prepare-text-mention-notification-email-as-html-resolving-data)
and
[customize the styles](#prepare-text-mention-notification-email-as-html-styling-elements).

```tsx
import { prepareTextMentionNotificationEmailAsHtml } from "@liveblocks/emails";
import { isTextMentionNotificationEvent } from "@liveblocks/node";

// Get `liveblocks` and `event` (see "Setup" section)
// ...

if (isTextMentionNotificationEvent(event)) {
  // +++
  const emailData = await prepareTextMentionNotificationEmailAsHtml(
    liveblocks,
    event
  );
  // +++

  const email = (
    <div>
      <div>
        @{emailData.mention.author.id} at {emailData.mention.createdAt}
      </div>
      <div>{emailData.mention.content}</div>
    </div>
  );
}

// Send your email
// ...
```

Itâ€™s designed to be used in a webhook event, which requires a
[`Liveblocks`](/docs/api-reference/liveblocks-node#Liveblocks-client) Node.js
client and a
[`WebhookHandler`](/docs/api-reference/liveblocks-node#WebhookHandler). Check
for the correct webhook event using
[`isTextMentionNotificationEvent`](/docs/api-reference/liveblocks-node#isTextMentionNotificationEvent)
before running the function, such as in this Next.js route handler.

```tsx title="Full Next.js route handler example" isCollapsed isCollapsable
import {
  isTextMentionNotificationEvent,
  WebhookHandler,
} from "@liveblocks/node";
import { Liveblocks } from "@liveblocks/node";
// +++
import { prepareTextMentionNotificationEmailAsHtml } from "@liveblocks/emails";
// +++

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

const webhookHandler = new WebhookHandler(
  process.env.LIVEBLOCKS_WEBHOOK_SECRET_KEY as string
);

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // +++
  if (isTextMentionNotificationEvent(event)) {
    const emailData = await prepareTextMentionNotificationEmailAsHtml(
      liveblocks,
      event
    );

    const email = `
    <div>
      <div>
        @${emailData.mention.author.id} at ${emailData.mention.createdAt}
      </div>
      <div>${emailData.mention.content}</div>
    </div>
    `;

    // Send your email
    // ...
  }
  // +++

  return new Response(null, { status: 200 });
}
```

<PropertiesList title="Returns">
  <PropertiesListItem
    name="value"
    type="TextMentionNotificationEmailDataAsHtml | null"
  >
    Returns text mention information, and formatted HTML content ready for
    use in emails. Returns `null` if the text mention does not exist anymore or
    has already been read.

    ```js title="Unread text mention"
    {
      roomInfo: {
        name: "my room name"
        url: "https://my-room-url.io"
      },
      mention: {
        kind: "user",
        textMentionId: "in_oiujhdg...",
        id: "user-0",
        roomId: "my-room-id",
        createdAt: Date <Fri Dec 15 2023 14:15:22 GMT+0000 (Greenwich Mean Time)>,

        // The formatted content, as an HTML string
        content: { /* ... */}

        author: {
          id: "vincent@example.com",
          info: { /* Custom user info you have resolved */ }
        }
      },
    }
    ```

  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem name="client" type="Liveblocks" required>
    A [`Liveblocks`](/docs/api-reference/liveblocks-node#Liveblocks-client)
    Node.js client.
  </PropertiesListItem>
  <PropertiesListItem name="event" type="TextMentionNotificationEvent" required>
    An object passed from a webhook event, specifically the
    [`TextMentionNotificationEvent`](/docs/platform/webhooks#TextMention-notification).
    [Learn more about setting this up](#Setup).
  </PropertiesListItem>
  <PropertiesListItem name="options" type="object">
    A number of options to customize the format of the content, adding user
    info, room info, and styles.
  </PropertiesListItem>
  <PropertiesListItem
    name="options.resolveUsers"
    detailedType='async? (args: ResolveUsersArgs) => (UserMeta["info"] | undefined)[] | undefined'
  >
    A function that resolves user information in
    [Comments](/docs/ready-made-features/comments). Return an array of
    `UserMeta["info"]` objects in the same order they arrived. Works similarly
    to the [resolver on the
    client](/docs/ready-made-features/text-editor/lexical#Users-and-mentions).
    [Learn
    more](#prepare-text-mention-notification-email-as-html-resolving-data).
  </PropertiesListItem>
  <PropertiesListItem
    name="options.resolveGroupsInfo"
    detailedType="async? (args: ResolveGroupsInfoArgs) => (GroupInfo | undefined)[] | undefined"
  >
    A function that resolves group information. Return an array of `GroupInfo`
    objects in the same order they arrived. Works similarly to the [resolver on
    the
    client](/docs/api-reference/liveblocks-react#LiveblocksProviderResolveGroupsInfo).
    [Learn more](#prepare-thread-notification-email-as-react-resolving-data).
  </PropertiesListItem>
  <PropertiesListItem
    name="options.resolveRoomInfo"
    detailedType="async? (args: ResolveRoomInfoArgs) => RoomInfo | undefined"
  >
    A function that resolves room information. Return a `RoomInfo` object, as
    matching your types. Works similarly to the [resolver on the
    client](/docs/api-reference/liveblocks-react#LiveblocksProviderResolveRoomsInfo)
    but for one room. [Learn
    more](#prepare-text-mention-notification-email-as-html-resolving-data).
  </PropertiesListItem>
  <PropertiesListItem name="options.styles" type="object">
    Pass CSS properties to style the different HTML elements in the mention
    content. Four elements can be styled: `paragraph`, `code`, `strong`,
    `mention`, and, `link`. [Learn
    more](#prepare-text-mention-notification-email-as-html-styling-elements).
  </PropertiesListItem>
  <PropertiesListItem name="options.styles.paragraph" type="CSSProperties">
    Inline styles to apply to the mention container. It's a `<div />` element
    under the hood.
  </PropertiesListItem>
  <PropertiesListItem name="options.styles.code" type="CSSProperties">
    Inline styles to apply to the code element.
  </PropertiesListItem>
  <PropertiesListItem name="options.styles.strong" type="CSSProperties">
    Inline styles to apply to the strong element.
  </PropertiesListItem>
  <PropertiesListItem name="options.styles.mention" type="CSSProperties">
    Inline styles to apply to the mention element.
  </PropertiesListItem>
  <PropertiesListItem name="options.styles.link" type="CSSProperties">
    Inline styles to apply to the link element.
  </PropertiesListItem>
</PropertiesList>

#### Resolving data [#prepare-text-mention-notification-email-as-html-resolving-data]

Similarly to on the client, you can resolve
[users](/docs/api-reference/liveblocks-react#LiveblocksProviderResolveUsers),
[group info](/docs/api-reference/liveblocks-react#LiveblocksProviderResolveGroupsInfo),
and
[room info](/docs/api-reference/liveblocks-react#LiveblocksProviderResolveRoomsInfo),
making it easier to render your emails. For example, you can resolve a userâ€™s ID
into their name, and show their name in the email.

<Banner title="Resolving users and groups" type="info">
  When resolving users and groups, the function receives a list of IDs and you
  should return a list of objects of the same size, in the same order.
</Banner>

```tsx
const emailData = await prepareTextMentionNotificationEmailAsHtml(
  liveblocks,
  webhookEvent,
  {
    // +++
    resolveUsers: async ({ userIds }) => {
      const usersData = await __getUsersFromDB__(userIds);

      return usersData.map((userData) => ({
        name: userData.name, // "Nimesh"
        avatar: userData.avatar.src, // "https://..."
      }));
    },
    resolveGroupsInfo: async ({ groupIds }) => {
      const groupsData = await __getGroupsFromDB__(groupIds);

      return groupsData.map((groupData) => ({
        name: groupData.name, // "Engineering"
        avatar: groupData.avatar.src, // "https://..."
      }));
    },
    resolveRoomInfo({ roomId }) {
      return {
        name: roomId, // "my-room-name"
        url: `https://example.com/${roomId}`,
      };
    },
    // +++
  }
);

// { mention: { ... }, ... }
console.log(emailData);

// { name: "Nimesh", avatar: "https://..." }
console.log(emailData.mention.author.info);

// { name: "my-room-name", url: "https://example.com/my-room-name" }
console.log(emailData.roomInfo);
```

#### Styling elements [#prepare-text-mention-notification-email-as-html-styling-elements]

Each element in the comment body can be styled with custom CSS properties, if
you would like to change the appearance. Five elements are available:
`paragraph`, `code`, `strong`, `mention`, and `link`.

```tsx
const emailData = await prepareTextMentionNotificationEmailAsHtml(
  liveblocks,
  webhookEvent,
  {
    // +++
    styles: {
      paragraph: { margin: "12px 0" },

      mention: {
        fontWeight: "bold",
        color: "red",
      },
    },
    // +++
  }
);

// { mention: { ... }, ... }
console.log(emailData);

// The elements in the mention content are now styled
console.log(emailData.mention.content);
```

---
meta:
  title: "@liveblocks/node-lexical"
  parentTitle: "API Reference"
  description: "API Reference for the @liveblocks/node-lexical package"
alwaysShowAllNavigationLevels: false
---

`@liveblocks/node-lexical` provides a Node.js package to export and modify
[Lexical](https://lexical.dev/) documents on the server.

## withLexicalDocument

`withLexicalDocument` is the main entry point to modifying a document on the
server. It takes a room ID and a
[Liveblocks Node client](/docs/api-reference/liveblocks-node#Liveblocks-client),
and returns a callback used to work with Lexical documents stored in Liveblocks.

```ts highlight="8-14"
import { Liveblocks } from "@liveblocks/node";
import { withLexicalDocument } from "@liveblocks/node-lexical";

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

await withLexicalDocument(
  { roomId: "your-room-id", client: liveblocks },
  async (doc) => {
    // Modify your Lexical `doc`
    // ...
  }
);
```

<PropertiesList title="Returns">
  <PropertiesListItem name="returns" type="T">
    Returns the value you return from the `doc` callback.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Options">
  <PropertiesListItem name="roomId" type="string" required>
    The ID of the room to use.
  </PropertiesListItem>
  <PropertiesListItem name="client" type="Liveblocks" required>
    The [Liveblocks
    client](/docs/api-reference/liveblocks-node#Liveblocks-client) to use.
  </PropertiesListItem>
  <PropertiesListItem
    name="nodes"
    type="Klass<LexicalNode>[] | LexicalNodeReplacement[]"
  >
    Optional. The Lexical nodes used in the document. Will extend the default
    schema which uses Liveblocks mentions and Liveblocks comments.
  </PropertiesListItem>
</PropertiesList>

### Returning data

Get your editorâ€™s text content by returning `doc.getTextContent` inside the
callback.

```ts
const textContent = await withLexicalDocument(
  { roomId: "my-room-id", client: liveblocks },
  // +++
  async (doc) => {
    return doc.getTextContent();
  }
  // +++
);

// "My content"
console.log(textContent);
```

### Custom nodes

If your Lexical document has custom nodes, they must be passed into the
`withLexicalDocument`, similarly to with a front end Lexical client.

```ts highlight="4"
import { CodeNode } from "@lexical/code";

await withLexicalDocument(
  { roomId: "my-room-id", client: liveblocks, nodes: [CodeNode] },
  async (doc) => {
    // Modify your Lexical `doc`
    // ...
  }
);
```

### Lexical document API

You can easily modify your document with the Lexical document API.

#### doc.update

Liveblocks provides `doc.update` which is a callback function similar to
Lexicalâ€™s `editor.update`. This makes it easy to use Lexicalâ€™s editor functions.
Any edits will be persisted and appear in realtime to connected users as soon as
the `update` promise resolves. Unlike Lexicalâ€™s `editor.update`, this change is
always discrete. The callback can also be an `async` function.

```ts
await withLexicalDocument(
  { roomId: "my-room-id", client: liveblocks },
  async (doc) => {
    // +++
    await doc.update(() => {
      // Make your modifications
      // ...
    });
    // +++
  }
);
```

<PropertiesListEmpty title="Returns">_Nothing_</PropertiesListEmpty>

<PropertiesList title="Arguments">
  <PropertiesListItem name="callback" type="() => void">
    Callback function where you should handle your modifications.
  </PropertiesListItem>
</PropertiesList>

##### Example usage

Hereâ€™s an example of some modifications to a Lexical document.

```ts
import { $getRoot } from "lexical";
import { $createParagraphNode, $createTextNode } from "lexical/nodes";

await withLexicalDocument(
  { roomId: "my-room-id", client: liveblocks },
  async (doc) => {
    await doc.update(() => {
      // Adding a paragraph node with contained text node
      // +++
      const root = $getRoot();
      const paragraphNode = $createParagraphNode();
      const textNode = $createTextNode("Hello world");
      paragraphNode.append(textNode);
      root.append(paragraphNode);
      // +++
    });
  }
);
```

#### doc.getTextContent

Returns the text content from the root node as a `string`.

```ts
const textContent = await withLexicalDocument(
  { roomId: "my-room-id", client: liveblocks },
  // +++
  async (doc) => {
    return doc.getTextContent();
  }
  // +++
);
```

<PropertiesList title="Returns">
  <PropertiesListItem name="content" type="string">
    Returns the text retrieved from the document.
  </PropertiesListItem>
</PropertiesList>

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

#### doc.getEditorState

Returns Lexicalâ€™s [editorState](https://lexical.dev/docs/concepts/editor-state).

```ts
const editorState = await withLexicalDocument(
  { roomId: "my-room-id", client: liveblocks },
  // +++
  async (doc) => {
    return doc.getEditorState();
  }
  // +++
);
```

<PropertiesList title="Returns">
  <PropertiesListItem name="editorState" type="EditorState">
    Your editorâ€™s Lexical state.
  </PropertiesListItem>
</PropertiesList>

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

#### doc.getLexicalEditor

Returns a headless Lexical editor.
[@lexical/headless](https://lexical.dev/docs/packages/lexical-headless).

```ts
const headlessEditor = await withLexicalDocument(
  { roomId: "my-room-id", client: liveblocks },
  // +++
  async (doc) => {
    return doc.getLexicalEditor();
  }
  // +++
);
```

<PropertiesList title="Returns">
  <PropertiesListItem name="headlessEditor" type="LexicalEditor">
    Your headless Lexical editor.
  </PropertiesListItem>
</PropertiesList>

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

#### doc.toJSON

Returns a serialized JSON object representation of your document. See Lexicalâ€™s
[Serialization & Deserialization](https://lexical.dev/docs/concepts/serialization)
page for more information.

```ts
const docAsJSON = await withLexicalDocument(
  { roomId: "my-room-id", client: liveblocks },
  // +++
  async (doc) => {
    return doc.toJSON();
  }
  // +++
);
```

<PropertiesList title="Returns">
  <PropertiesListItem
    name="docAsJson"
    type="SerializedEditorState<SerializedLexicalNode>"
  >
    A serialized JSON object representation of your document.
  </PropertiesListItem>
</PropertiesList>

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

#### doc.toMarkdown

Returns a markdown `string` of your document. See Lexicalâ€™s
[@lexical/markdown](https://lexical.dev/docs/concepts/serialization) page for
more information.

```ts
const markdown = await withLexicalDocument(
  { roomId: "my-room-id", client: liveblocks },
  // +++
  async (doc) => {
    return doc.toMarkdown();
  }
  // +++
);
```

<PropertiesList title="Returns">
  <PropertiesListItem name="markdown" type="string">
    Returns the markdown string.
  </PropertiesListItem>
</PropertiesList>

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

---
meta:
  title: "@liveblocks/node-prosemirror"
  parentTitle: "API Reference"
  description: "API Reference for the @liveblocks/node-prosemirror package"
alwaysShowAllNavigationLevels: false
---

`@liveblocks/node-prosemirror` provides a Node.js package to export and modify
[ProseMirror](https://prosemirror.net/). Because Tiptap uses ProseMirror under
the hood, this package can be used to modify
[Tiptap](/docs/api-reference/liveblocks-react-tiptap) documents as well.

## withProsemirrorDocument

`withProsemirrorDocument` is the main entry point to modifying a document on the
server. It takes a room ID and a
[Liveblocks Node client](/docs/api-reference/liveblocks-node#Liveblocks-client),
and returns a callback used to work with ProseMirror documents stored in
Liveblocks.

```ts highlight="8-14"
import { Liveblocks } from "@liveblocks/node";
import { withProsemirrorDocument } from "@liveblocks/node-prosemirror";

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

await withProsemirrorDocument(
  { roomId: "your-room-id", client: liveblocks },
  (api) => {
    // Modify your document with the api
    // ...
  }
);
```

<PropertiesList title="Returns">
  <PropertiesListItem name="returns" type="T">
    Returns the value you return from the `api` callback.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Options">
  <PropertiesListItem name="roomId" type="string" required>
    The ID of the room to use.
  </PropertiesListItem>
  <PropertiesListItem name="client" type="Liveblocks" required>
    The [Liveblocks
    client](/docs/api-reference/liveblocks-node#Liveblocks-client) to use.
  </PropertiesListItem>
  <PropertiesListItem name="schema" type="Schema">
    Optional. The ProseMirror schema to use for the document. If no schema is
    provided, the default schema is [Tiptap
    StarterKit](https://tiptap.dev/docs/editor/extensions/functionality/starterkit),
    Liveblocks mentions, and Liveblocks comments.
  </PropertiesListItem>
  <PropertiesListItem name="field" type="string">
    Optional. The
    [field](/docs/api-reference/liveblocks-react-tiptap#Multiple-editors) to use
    for the document. Defaults to `default`.
  </PropertiesListItem>
</PropertiesList>

### Returning data

Get your editorâ€™s text content by returning `api.getText()` inside the callback.

```ts
const textContent = await withProsemirrorDocument(
  { roomId: "my-room-id", client: liveblocks },
  (api) => api.getText()
);

// "My content"
console.log(textContent);
```

### ProseMirror document API

You can easily modify your document with the ProseMirror document API.

#### api.update

Liveblocks provides `api.update` which is a callback that provides the current
document and a ProseMirror transaction. This makes it easy to use ProseMirrorâ€™s
built in functions. When you've finished, return the transaction and any changes
will be persisted, and appear in realtime to connected users as soon as the
`update` promise resolves.

```ts
await withProsemirrorDocument(
  {
    client,
    roomId: "test-room",
  },
  async (api) => {
    // +++
    await api.update((doc, tr) => {
      return tr.insertText("Hello world");
    });
    // +++
  }
);
```

<PropertiesListEmpty title="Returns">_Nothing_</PropertiesListEmpty>

<PropertiesList title="Arguments">
  <PropertiesListItem
    name="callback"
    type="(doc: Node, tr: Transaction) => Transaction"
  >
    `doc` is the ProseMirror document. `tr` is an editor state transaction.
    Transaction is a subclass of ProseMirrorâ€™s Transforms. On the ProseMirror
    website you can find a full list of
    [transforms](https://prosemirror.net/docs/ref/#transform.Document_transforms)
    and [transactions
    functions](https://prosemirror.net/docs/ref/#state.Transaction).
  </PropertiesListItem>
</PropertiesList>

#### api.getText

Returns the text content of the document. This API uses Tiptapâ€™s `getText`
internally. TextSerializers are a concept from
[Tiptap](https://github.com/ueberdosis/tiptap/blob/3e59097b34ce8bc8c39e1def67eb31a1d9f9e5c2/packages/core/src/types.ts#L357).
If you are having trouble with a ProseMirror document, you may want to use
`api.getEditorState().doc.textBetween()` instead.

```ts
const textContent = await withProsemirrorDocument(
  { roomId: "my-room-id", client: liveblocks },
  async (api) => {
    // +++
    return api.getText({
      // Options
      // ...
    });
    // +++
  }
);
```

<PropertiesList title="Returns">
  <PropertiesListItem name="content" type="string">
    Returns the text retrieved from the document.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem name="options.blockSeparator" type="string">
    Optional. The separator to use for blocks, e.g. `<br />
    `. Defaults to `\n\n`.
  </PropertiesListItem>
  <PropertiesListItem name="options.textSerializers" type="string">
    Optional. The serializers to use for text. Defaults to `{}`.
  </PropertiesListItem>
</PropertiesList>

#### api.setContent

For convenience, some methods such as `setContent` are provided at the API
level. Hereâ€™s an example that sets a document and returns the JSON content after
it has been updated.

```ts
const exampleDoc = {
  type: "doc",
  content: [
    {
      type: "paragraph",
      content: [
        {
          type: "text",
          text: "Example Text",
        },
      ],
    },
  ],
};

const json = await withProsemirrorDocument<string>(
  {
    client,
    roomId: "test-room",
  },
  async (api) => {
    // +++
    await api.setContent(exampleDoc);
    // +++
    return JSON.stringify(api.toJSON());
  }
);
```

<PropertiesListEmpty title="Returns">_Nothing_</PropertiesListEmpty>

<PropertiesList title="Arguments">
  <PropertiesListItem name="content" type="null | object | string" required>
    The content to replace your document.
  </PropertiesListItem>
</PropertiesList>

#### api.getEditorState

Returns the current ProseMirror state.

```ts
const editorState = await withProsemirrorDocument(
  { roomId: "my-room-id", client: liveblocks },
  async (api) => {
    // +++
    return api.getEditorState();
    // +++
  }
);
```

<PropertiesList title="Returns">
  <PropertiesListItem name="editorState" type="EditorState">
    Your editorâ€™s ProseMirror state.
  </PropertiesListItem>
</PropertiesList>

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

#### api.toJSON

Returns a serialized JSON object representation of your document. See
ProseMirrorâ€™s
[.toJSON](https://prosemirror.net/docs/ref/#state.EditorState.toJSON)
documentation for more information.

```ts
const docAsJSON = await withProsemirrorDocument(
  { roomId: "my-room-id", client: liveblocks },
  async (api) => {
    // +++
    return api.toJSON();
    // +++
  }
);
```

<PropertiesList title="Returns">
  <PropertiesListItem name="editorState" type="string">
    Your editorâ€™s serialized JSON state.
  </PropertiesListItem>
</PropertiesList>

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

#### api.clearContent

Clears the content of the document.

```ts
await withProsemirrorDocument(
  { roomId: "my-room-id", client: liveblocks },
  async (api) => {
    // +++
    return api.clearContent();
    // +++
  }
);
```

<PropertiesListEmpty title="Returns">_Nothing_</PropertiesListEmpty>

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

#### api.toMarkdown

Returns a markdown `string` of your document.

```ts
const markdown = await withProsemirrorDocument(
  { roomId: "my-room-id", client: liveblocks },
  async (api) => {
    // +++
    return api.toMarkdown();
    // +++
  }
);
```

<PropertiesList title="Returns">
  <PropertiesListItem name="markdown" type="string">
    Returns the markdown string.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem name="serializer" type="MarkdownSerializer">
    Optional. A markdown serializer to use. By default it uses the
    `defaultMarkdownSerializer` from
    [prosemirror-markdown](https://github.com/prosemirror/prosemirror-markdown).
  </PropertiesListItem>
</PropertiesList>

##### Custom markdown serializer

You can use a custom markdown serializer.

```ts
import { defaultMarkdownSerializer } from "prosemirror-markdown";

const mySerializer = new MarkdownSerializer({
  marks: {
    ...defaultMarkdownSerializer.marks,
    em: {
      open: "*",
      close: "*",
      mixable: true,
      expelEnclosingWhitespace: true,
    },
  },
});

const markdown = await withProsemirrorDocument(
  { roomId: "my-room-id", client: liveblocks },
  async (api) => {
    // +++
    return api.toMarkdown(mySerializer);
    // +++
  }
);
```

---
meta:
  title: "@liveblocks/node"
  parentTitle: "API Reference"
  description: "API Reference for the @liveblocks/node package"
alwaysShowAllNavigationLevels: false
---

`@liveblocks/node` provides you with Node.js APIs for
[authenticating Liveblocks users](#Liveblocks-client) and for
[implementing webhook handlers](#WebhookHandler). This library is only intended
for use in your Node.js back end.

## Liveblocks client [#Liveblocks-client]

The `Liveblocks` client offers access to our REST API.

```ts showLineNumbers={false}
import { Liveblocks } from "@liveblocks/node";

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});
```

### Authentication [#Authorization]

To authenticate your users with Liveblocks, you have the choice between two
different APIs.

- [`Liveblocks.identifyUser`](#id-tokens) ID token authentication is recommend
  for most applications.
- [`Liveblocks.prepareSession`](#access-tokens) Access token authentication is
  best if you prefer handle permissions on your end, though it has
  [limitations](/docs/authentication/access-token#limitations).

#### Liveblocks.identifyUser [#id-tokens]

Creates an ID token that is used to authenticate a user in your application.
This is a wrapper around the
[Get ID Token API](/docs/api-reference/rest-api-endpoints#post-identify-user)
and returns the same response.

```ts
const { body, status } = await liveblocks.identifyUser({
  // Required, the current user's ID
  userId: "marie@example.com",
});
```

<Banner>
  Learn how to [get started with ID tokens](/docs/authentication).
</Banner>

A number of options are also available, enabling you to set up permissions and
user metadata.

```ts
const { body, status } = await liveblocks.identifyUser(
  {
    // Required, the current user's ID
    userId: "marie@example.com",

    // Optional, only view resources on this tenant
    tenantId: "acme-corp",

    // Optional, used to provision room access on group level
    groupIds: ["marketing", "engineering"],
  },
  {
    // Optional, custom user metadata
    userInfo: {
      name: "Marie",
      color: "#00ff00",
      avatar: "https://example.com/avatar/marie.jpg",
    },
  }
);
```

##### Granting ID token permissions

You can pass additional options to `identifyUser`, enabling you to create
complex [workspace permissions](/docs/authentication#permissions) and
[room permissions](/docs/authentication#Room-permissions). For example, this
user can only see resources in the `acme-corp` workspace, and theyâ€™re part of a
`marketing` rooms group within it.

```ts
const { body, status } = await liveblocks.identifyUser({
  // Required, the current user's ID
  userId: "marie@example.com",

  // Optional, only view resources on this workspace
  // +++
  tenantId: "acme-corp",
  // +++

  // Optional, used to provision room access on group level
  // +++
  groupIds: ["marketing"],
  // +++
});
```

<Banner>
  Learn more about [ID token permissions](/docs/authentication#permissions).
</Banner>

##### Text editor user data

When using
[text editor integrations](/docs/ready-made-features/multiplayer#Text-editor-integrations),
user data is inserted into their live cursor within the editor, showing their
name and color. This data originates from the `userInfo` property.

```ts
const { body, status } = await liveblocks.identifyUser(
  {
    // Required, the current user's ID
    userId: "marie@example.com",
  },
  {
    // Optional, custom user metadata
    userInfo: {
      // Used in text editor live carets
      // +++
      name: "Marie",
      color: "#00ff00",
      // +++
    },
  }
);
```

##### Custom user metadata

You can pass additional options to `prepareSession`, enabling you to add custom
user metadata to the session. This metadata can be accessed by all users in the
room, and is useful for building features such as live avatar stacks.

```ts
const { body, status } = await liveblocks.identifyUser(
  {
    // Required, the current user's ID
    userId: "marie@example.com",
  },
  {
    // Optional, custom user metadata
    userInfo: {
      // Add custom properties to use on front end, e.g. avatar stacks
      // +++
      avatar: "https://example.com/avatar/marie.jpg",
      // +++
      // ...
    },
  }
);
```

To access it on the front end, use hooks such as
[`useSelf`](/docs/api-reference/liveblocks-react#useSelf) and
[`useOthers`](/docs/api-reference/liveblocks-react#useOthers).

```tsx
const currentUser = useSelf();

// "https://example.com/avatar/marie.jpg"
console.log(currentUser.info.avatar);
```

##### How ID tokens work

The purpose of this API is to help you implement your custom authentication back
end (i.e. the _server_ part of the diagram). You use the
`liveblocks.identifyUser()` API if youâ€™d like to issue
[ID tokens](/docs/authentication/id-token) from your back end. An ID token does
not grant any permissions in the token directly. Instead, it only securely
identifies your user, and then uses any permissions set via the [Permissions
REST API][] to decide whether to allow the user on a room-by-room basis.

Use this approach if youâ€™d like Liveblocks to be the source of truth for your
userâ€™s permissions.

<Banner title="What are ID tokens?">
  Issuing identity tokens is like issuing _membership cards_. Anyone with a
  membership card can try to enter a room, but your permissions will be checked
  at the door. The Liveblocks servers perform this authorization, so your
  permissions need to be set up front using the Liveblocks REST API.
</Banner>

<Figure>
  <Image
    src="/assets/id-token-auth-diagram.png"
    alt="Auth diagram"
    width={768}
    height={576}
  />
</Figure>

Implement your back end endpoint as follows:

```ts showLineNumbers={false}
const { body, status } = await liveblocks.identifyUser(
  {
    userId: "marie@example.com", // Required, user ID from your DB
    groupIds: ["marketing", "engineering"],
    // Optional, identify the user in a specific tenant
    tenantId: "acme-corp",
  },

  // Optional
  {
    userInfo: {
      name: "Marie",
      avatar: "https://example.com/avatar/marie.jpg",
    },
  }
);

return new Response(body, { status });
```

`userId` (required) is a string identifier to uniquely identify your user with
Liveblocks. This value will be used when counting unique MAUs in your Liveblocks
dashboard. You can refer to these user IDs in the [Permissions REST API][] when
assigning group permissions.

`groupIds` (optional) can be used to specify which groups this user belongs to.
These are arbitrary identifiers that make sense to your app, and that you can
refer to in the [Permissions REST API][] when assigning group permissions.

`tenantId` (optional) is the tenant for this user, will be set to `default` if
not provided.

`userInfo` (optional) is any custom JSON value, which you can use to attach
static metadata to this userâ€™s session. This will be publicly visible to all
other people in the room. Useful for metadata like the userâ€™s full name, or
their avatar URL.

##### ID tokens example

Hereâ€™s a real-world example of ID tokens in a Next.js route handler/endpoint.
You can find examples for other frameworks in our
[authentication section](/docs/authentication/id-token).

```ts file="Next.js"
import { Liveblocks } from "@liveblocks/node";

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

export default async function auth(req, res) {
  /**
   * Implement your own security here.
   *
   * It's your responsibility to ensure that the caller of this endpoint
   * is a valid user by validating the cookies or authentication headers
   * and that it has access to the requested room.
   */

  // Get the current user from your database
  const user = __getUserFromDB__(req);

  // Create an ID token for the user
  const { body, status } = await liveblocks.identifyUser(
    {
      userId: user.id,
    },
    {
      userInfo: {
        name: user.fullName,
        color: user.favoriteColor,
      },
    }
  );

  return new Response(body, { status });
}
```

#### Liveblocks.prepareSession [#access-tokens]

Creates an access token that is used to authenticate a user in your application.
This is a wrapper around the
[Get Access Token API](/docs/api-reference/rest-api-endpoints#post-authorize-user)
and returns the same response.

```ts
const session = liveblocks.prepareSession(
  // Required, the current user's ID
  "marie@example.com"
);
```

<Banner>
  Learn how to [get started with access
  tokens](/docs/authentication/access-token).
</Banner>

A number of options are also available, enabling you to set up permissions and
user metadata.

```ts
const session = liveblocks.prepareSession(
  // Required, the current user's ID
  "marie@example.com",
  {
    // Optional, only view resources on this tenant
    tenantId: "acme-corp",

    // Optional, used to provision room access on group level
    groupIds: ["marketing"],

    // Optional, custom user metadata
    userInfo: {
      name: "Marie",
      color: "#00ff00",
      avatar: "https://example.com/avatar/marie.jpg",
    },
  }
);
```

##### Granting access token permissions

Using `session.allow()`, you can grant full or read-only permissions to the user
to select rooms. Wildcards can be used to enable granting permissions to
multiple rooms at once using
[naming patterns](/docs/authentication/access-token#Naming-pattern).

```ts
const session = liveblocks.prepareSession(
  // Required, the current user's ID
  "marie@example.com"
);

// Giving access to an individual rooms
session.allow("room-id-1", session.FULL_ACCESS);

// Giving read-only access to this room
session.allow("room-id-2", session.READ_ACCESS);

// Giving access to multiple rooms with a wildcard
// `design-room-1`, `design-room-2`, etc.
session.allow("design-room:*", session.FULL_ACCESS);
```

<Banner>
  Learn more about [access token
  permissions](/docs/authentication/access-token#permissions).
</Banner>

Additionally, you can pass additional options to `prepareSession`, enabling you
to create complex permissions using [tenants](/docs/authentication/tenants) and
[accesses](/docs/authentication/access-tokens/permissions). For example, this
user can only see resources in the `acme-corp` tenant, and theyâ€™re part of a
`marketing` group within it.

```ts
const session = liveblocks.prepareSession(
  // Required, the current user's ID
  "marie@example.com",
  {
    // Optional, only view resources on this tenant
    // +++
    tenantId: "acme-corp",
    // +++

    // Optional, used to provision room access on group level
    // +++
    groupIds: ["marketing"],
    // +++
  }
);
```

##### Text editor user data

When using
[text editor integrations](/docs/ready-made-features/multiplayer#Text-editor-integrations),
user data is inserted into their live cursor within the editor, showing their
name and color. This data originates from the `userInfo` property of the
session.

```ts
const session = liveblocks.prepareSession(
  // Required, the current user's ID
  "marie@example.com",
  {
    // Optional, user metadata
    userInfo: {
      // Used in text editor live carets
      // +++
      name: "Marie",
      color: "#00ff00",
      // +++
    },
  }
);
```

##### Custom user metadata

You can pass additional options to `prepareSession`, enabling you to add custom
user metadata to the session. This metadata can be accessed by all users in the
room, and is useful for building features such as live avatar stacks.

```ts
const session = liveblocks.prepareSession(
  // Required, the current user's ID
  "marie@example.com",
  {
    // Optional, custom user metadata
    userInfo: {
      // Add custom properties to use on front end, e.g. avatar stacks
      // +++
      avatar: "https://example.com/avatar/marie.jpg",
      // +++
      // ...
    },
  }
);
```

To access it on the front end, use hooks such as
[`useSelf`](/docs/api-reference/liveblocks-react#useSelf) and
[`useOthers`](/docs/api-reference/liveblocks-react#useOthers).

```tsx
const currentUser = useSelf();

// "https://example.com/avatar/marie.jpg"
console.log(currentUser.info.avatar);
```

##### How access tokens work

The purpose of this API is to help you implement your custom authentication back
end (i.e. the _server_ part of the diagram). You use the
`liveblocks.prepareSession()` API if youâ€™d like to issue
[access tokens](/docs/authentication/access-token) from your back end.

<Banner title="What are access tokens?">
  Issuing access tokens is like issuing _hotel key cards_ from a hotelâ€™s front
  desk (your back end). Any client with a key card can enter any room that the
  card gives access to. Itâ€™s easy to give out those key cards right from your
  back end.
</Banner>

<Figure>
  <Image
    src="/assets/access-token-auth-diagram.png"
    alt="Auth diagram"
    width={768}
    height={576}
  />
</Figure>

To implement your back end, follow these steps:

<Steps>
  <Step>
    <StepTitle>Create a session</StepTitle>

    <StepContent>
      ```ts showLineNumbers={false}
      const session = liveblocks.prepareSession(
        "marie@example.com",   // Required, user ID from your DB
        {
          // Optional, custom static metadata for the session
          userInfo: {
            name: "Marie",
            avatar: "https://example.com/avatar/marie.jpg",
          },
          // Optional, authenticate this user on a specific tenant
          tenantId: "acme-corp",
        }
      );
      ```

      The `userId` (required) is an identifier to uniquely identifies
      your user with Liveblocks. This value will be used when counting
      unique MAUs in your Liveblocks dashboard.

      The `userInfo` (optional) is any custom JSON value, which can be
      attached to static metadata to this userâ€™s session. This will be
      publicly visible to all other people in the room. Useful for
      metadata like the userâ€™s full name, or their avatar URL.

      The `tenantId` (optional) is the tenant for this session, will be set to `default` if not provided.

    </StepContent>

  </Step>

  <Step>
    <StepTitle>Decide which permissions to allow this session</StepTitle>
    <StepContent>
      ```ts showLineNumbers={false}
      session.allow("my-room-1", session.FULL_ACCESS);
      session.allow("my-room-2", session.FULL_ACCESS);
      session.allow("my-room-3", session.FULL_ACCESS);
      session.allow("my-team:*", session.READ_ACCESS);
      ```

      <Banner title="Be diligent" type="warning">
        Youâ€™re specifying whatâ€™s going to be allowed so be careful what
        permissions youâ€™re giving your users. Youâ€™re responsible for this
        part.
      </Banner>
    </StepContent>

  </Step>

  <Step lastStep>
    <StepTitle>Authorize the session</StepTitle>
    <StepContent>
      Finally, authorize the session. This step makes the HTTP call to the
      Liveblocks servers. Liveblocks will return a signed **access token** that
      you can return to your client.

      ```ts showLineNumbers={false}
      // Requests the Liveblocks servers to authorize this session
      const { body, status } = await session.authorize();
      return new Response(body, { status });
      ```
    </StepContent>

  </Step>

</Steps>

##### Access tokens example [#access-token-example]

Hereâ€™s a real-world example of access tokens in a Next.js route
handler/endpoint. You can find examples for other frameworks in our
[authentication section](/docs/authentication/access-token).

```ts file="route.ts"
import { Liveblocks } from "@liveblocks/node";

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

export async function POST(request: Request) {
  /**
   * Implement your own security here.
   *
   * It's your responsibility to ensure that the caller of this endpoint
   * is a valid user by validating the cookies or authentication headers
   * and that it has access to the requested room.
   */

  // Get the current user from your database
  const user = __getUserFromDB__(request);

  // Start an auth session inside your endpoint
  const session = liveblocks.prepareSession(
    user.id,
    { userInfo: user.metadata } // Optional
  );

  // Implement your own security, and give the user access to the room
  const { room } = await request.json();
  if (room && __shouldUserHaveAccess__(user, room)) {
    session.allow(room, session.FULL_ACCESS);
  }

  // Retrieve a token from the Liveblocks servers and pass it to the
  // requesting client
  const { body, status } = await session.authorize();
  return new Response(body, { status });
}
```

### Room

#### Liveblocks.getRooms [#get-rooms]

Returns a list of rooms that are in the current project. The project is
determined by the secret key youâ€™re using. Rooms are sorted by creation time,
with the newest room at index `0`. This is a wrapper around the
[Get Rooms API](/docs/api-reference/rest-api-endpoints#get-rooms) and returns
the same response.

```ts
const { data: rooms, nextCursor } = await liveblocks.getRooms();

// A list of rooms
// [{ type: "room", id: "my-room-id", ... }, ...]
console.log(rooms);

// A pagination cursor used for retrieving the next page of results with `startingAfter`
// "L3YyL3Jvb21z..."
console.log(nextCursor);
```

A number of options are also available, enabling you to filter for certain
rooms.

```ts
const { data: rooms, nextCursor } = await liveblocks.getRooms({
  // Optional, the amount of rooms to load, between 1 and 100, defaults to 20
  limit: 20,

  // Optional, filter for rooms that allow entry to group ID(s) in `groupsAccesses`
  groupIds: ["engineering", "design"],

  // Optional, filter for rooms that allow entry to a user's ID in `usersAccesses`
  userId: "my-user-id",

  // Optional, use advanced filtering
  query: {
    // Optional, filter for rooms with an ID that starts with specific string
    roomId: {
      startsWith: "liveblocks:",
    },
    // Optional, filter for rooms with custom metadata in `metadata`
    metadata: {
      roomType: "whiteboard",
    },
  },

  // Optional, authenticate this user on a specific tenant
  tenantId: "my-tenant-id",

  // Optional, cursor used for pagination, use `nextCursor` from the previous page's response
  startingAfter: "L3YyL3Jvb21z...",
});
```

The `query` option also allows you to pass a
[query language](/docs/guides/how-to-filter-rooms-using-query-language) string
instead of a `query` object.

##### Pagination

You can use `nextCursor` to paginate rooms. In this example, when `getNextPage`
is called, the next set of rooms is added to `pages`.

```ts
import { RoomData } from "@liveblocks/node";

// An array of pages, each containing a list of retrieved rooms
const pages: RoomData[][] = [];

// Holds the pagination cursor for the next set of rooms
let startingAfter;

// Call to get the next page of rooms
async function getNextPage() {
  const { data, nextCursor } = await liveblocks.getRooms({ startingAfter });
  pages.push(data);
  startingAfter = nextCursor;
}
```

If youâ€™d like to iterate over all your rooms, itâ€™s most convenient to use
[`liveblocks.iterRooms`](#iter-rooms) instead. This method automatically
paginates your API requests.

#### Liveblocks.iterRooms [#iter-rooms]

Works similarly to [`liveblocks.getRooms`](#get-rooms), but instead returns an
asynchronous iterator, which helps you iterate over all selected rooms in your
project, without having to manually paginate through the results.

```ts
const roomsIterator = liveblocks.iterRooms();

for await (const room of roomsIterator) {
  // { type: "room", id: "my-room-id", metadata: {...}, ... }
  console.log(room);
}
```

A number of options are also available, enabling you to filter for certain
rooms.

```ts
const roomsIterator = await liveblocks.iterRooms({
  // Optional, filter for rooms that allow entry to group ID(s) in `groupsAccesses`
  groupIds: ["engineering", "design"],

  // Optional, filter for rooms that allow entry to a user's ID in `usersAccesses`
  userId: "my-user-id",

  // Optional, use advanced filtering
  query: {
    // Optional, filter for rooms with an ID that starts with specific string
    roomId: {
      startsWith: "liveblocks:",
    },
    // Optional, filter for rooms with custom metadata in `metadata`
    metadata: {
      roomType: "whiteboard",
    },
  },
});

for await (const room of roomsIterator) {
  // { type: "room", id: "my-room-id", metadata: {...}, ... }
  console.log(room);
}
```

The `query` option also allows you to pass a
[query language](/docs/guides/how-to-filter-rooms-using-query-language) string
instead of a `query` object.

##### Mass deleting rooms

You can use `iterRooms` to efficiently delete multiple rooms at once. This
example shows how to delete rooms in batches of 50 concurrent deletions at a
time:

```ts
const MAX_CONCURRENT = 50;
const queue: Promise<void>[] = [];

for await (const room of liveblocks.iterRooms({
  // Optionally filter for certain rooms
  // ...
})) {
  if (queue.length >= MAX_CONCURRENT) {
    await Promise.race(queue);
  }

  const promise = liveblocks
    .deleteRoom(room.id)
    .finally(() => queue.splice(queue.indexOf(promise), 1));

  queue.push(promise);
}

await Promise.all(queue);
```

This approach is useful when you need to delete a large number of rooms, as it
automatically handles pagination and allows you to control the concurrency of
deletions. You can use any of the filtering options shown above to select which
rooms to delete.

#### Liveblocks.createRoom [#post-rooms]

Programmatically creates a new room from a room ID. The `defaultAccesses` option
is required. Setting `defaultAccesses` to `["room:write"]` creates a public
room, whereas setting it to `[]` will create a private room that needs
[ID token permission to enter](/docs/authentication/id-token). This is a wrapper
around the [Create Room API](/docs/api-reference/rest-api-endpoints#post-rooms)
and returns the same response.

```ts
const room = await liveblocks.createRoom("my-room-id", {
  defaultAccesses: ["room:write"],
});

// { type: "room", id: "my-room-id", metadata: {...}, ... }
console.log(room);
```

A number of room creation options are available, allowing you to set permissions
and attach custom metadata.

```ts
const room = await liveblocks.createRoom("my-room-id", {
  // The default room permissions. `[]` for private, `["room:write"]` for public.
  defaultAccesses: [],

  // Optional, the room's group ID permissions
  groupsAccesses: {
    design: ["room:write"],
    engineering: ["room:presence:write", "room:read"],
  },

  // Optional, the room's user ID permissions
  usersAccesses: {
    "my-user-id": ["room:write"],
  },

  // Optional, custom metadata to attach to the room
  metadata: {
    myRoomType: "whiteboard",
  },

  // Optional, create it on a specific tenant
  tenantId: "acme-corp",
});
```

Group and user permissions are only used with
[ID token authorization](/docs/api-reference/liveblocks-node#id-tokens), learn
more about [managing permission with ID tokens](/docs/authentication/id-token).

#### Liveblocks.getRoom [#get-rooms-roomId]

Returns a room. Throws an error if the room isnâ€™t found. This is a wrapper
around the
[Get Room API](/docs/api-reference/rest-api-endpoints#get-rooms-roomId) and
returns the same response.

```ts
const room = await liveblocks.getRoom("my-room-id");

// { type: "room", id: "my-room-id", metadata: {...}, ... }
console.log(room);
```

#### Liveblocks.getOrCreateRoom [#get-or-create-rooms-roomId]

Get a room by its ID. If the room doesnâ€™t exist, create it instead. The
`defaultAccesses` option is required. Setting `defaultAccesses` to
`["room:write"]` creates a public room, whereas setting it to `[]` will create a
private room that needs
[ID token permission to enter](/docs/authentication/id-token). Returns the same
response as the
[Create Room API](/docs/api-reference/rest-api-endpoints#post-rooms).

```ts
const room = await liveblocks.getOrCreateRoom("my-room-id", {
  defaultAccesses: ["room:write"],
});

// { type: "room", id: "my-room-id", metadata: {...}, ... }
console.log(room);
```

A number of room creation options are available, allowing you to set permissions
and attach custom metadata.

```ts
const room = await liveblocks.getOrCreateRoom("my-room-id", {
  // The default room permissions. `[]` for private, `["room:write"]` for public.
  defaultAccesses: [],

  // Optional, the room's group ID permissions
  groupsAccesses: {
    design: ["room:write"],
    engineering: ["room:presence:write", "room:read"],
  },

  // Optional, the room's user ID permissions
  usersAccesses: {
    "my-user-id": ["room:write"],
  },

  // Optional, custom metadata to attach to the room
  metadata: {
    myRoomType: "whiteboard",
  },

  // Optional, create it on a specific tenant
  tenantId: "acme-corp",
});
```

Group and user permissions are only used with
[ID token authorization](/docs/api-reference/liveblocks-node#id-tokens), learn
more about [managing permission with ID tokens](/docs/authentication/id-token).

#### Liveblocks.updateRoom [#post-rooms-roomId]

Updates properties on a room. Throws an error if the room isnâ€™t found. This is a
wrapper around the
[Update Room API](/docs/api-reference/rest-api-endpoints#post-rooms-roomId) and
returns the same response.

```ts
const room = await liveblocks.updateRoom("my-room-id", {
  // The metadata or permissions you're updating
  // ...
});

// { type: "room", id: "my-room-id", metadata: {...}, ... }
console.log(room);
```

Permissions and metadata properties can be updated on the room. Note that you
need only pass the properties youâ€™re updating. Setting a property to `null` will
delete the property.

```ts
const room = await liveblocks.updateRoom("my-room-id", {
  // Optional, update the default room permissions. `[]` for private, `["room:write"]` for public.
  defaultAccesses: [],

  // Optional, update the room's group ID permissions
  groupsAccesses: {
    design: ["room:write"],
    engineering: ["room:presence:write", "room:read"],
  },

  // Optional, update the room's user ID permissions
  usersAccesses: {
    "my-user-id": ["room:write"],
  },

  // Optional, custom metadata to update on the room
  metadata: {
    myRoomType: "whiteboard",
  },
});
```

Group and user permissions are only used with
[ID token authorization](/docs/api-reference/liveblocks-node#id-tokens), learn
more about [managing permission with ID tokens](/docs/authentication/id-token).

#### Liveblocks.upsertRoom [#upsert-rooms-roomId]

Update a roomâ€™s properties by its ID. If the room doesnâ€™t exist, create it
instead. The `defaultAccesses` option is required. Setting `defaultAccesses` to
`["room:write"]` creates a public room, whereas setting it to `[]` will create a
private room that needs
[ID token permission to enter](/docs/authentication/id-token). Returns the same
response as the
[Create Room API](/docs/api-reference/rest-api-endpoints#post-rooms).

```ts
const room = await liveblocks.upsertRoom("my-room-id", {
  // These fields will get updated when the room exists, or will be created
  update: {
    metadata: { color: "red" },
  },
  // These fields will only be set when the room will get created
  create: {
    defaultAccesses: ["room:write"],
  },
});

// { type: "room", id: "my-room-id", metadata: {...}, ... }
console.log(room);
```

A number of room update or creation options are available, allowing you to set
permissions and attach custom metadata.

```ts
const room = await liveblocks.upsertRoom("my-room-id", {
  update: {
    // The default room permissions. `[]` for private, `["room:write"]` for public.
    defaultAccesses: [],

    // Optional, the room's group ID permissions
    groupsAccesses: {
      design: ["room:write"],
      engineering: ["room:presence:write", "room:read"],
    },

    // Optional, the room's user ID permissions
    usersAccesses: {
      "my-user-id": ["room:write"],
    },

    // Optional, custom metadata to attach to the room
    metadata: {
      myRoomType: "whiteboard",
    },
  },
});
```

Group and user permissions are only used with
[ID token authorization](/docs/api-reference/liveblocks-node#id-tokens), learn
more about [managing permission with ID tokens](/docs/authentication/id-token).

#### Liveblocks.deleteRoom [#delete-rooms-roomId]

Deletes a room. If the room doesnâ€™t exist, or has already been deleted, no error
will throw. This is a wrapper around the
[Delete Room API](/docs/api-reference/rest-api-endpoints#delete-rooms-roomId)
and returns no response.

```ts
await liveblocks.deleteRoom("my-room-id");
```

##### Mass deleting rooms

If you need to delete multiple rooms at once, you can use
[`liveblocks.iterRooms`](#iter-rooms) to efficiently iterate through rooms and
delete them in batches. This example shows how to delete rooms in batches of 50
concurrent deletions at a time:

```ts
const MAX_CONCURRENT = 50;
const queue: Promise<void>[] = [];

for await (const room of liveblocks.iterRooms({
  // Optionally filter for certain rooms
  // ...
})) {
  if (queue.length >= MAX_CONCURRENT) {
    await Promise.race(queue);
  }

  const promise = liveblocks
    .deleteRoom(room.id)
    .finally(() => queue.splice(queue.indexOf(promise), 1));

  queue.push(promise);
}

await Promise.all(queue);
```

You can use any of the filtering options available in
[`liveblocks.iterRooms`](#iter-rooms) to select which rooms to delete, such as
filtering by metadata, room ID prefix, or user/group access.

#### Liveblocks.prewarmRoom [#get-rooms-roomId-prewarm]

Speeds up connecting to a room for the next 10 seconds. Use this when you know a
user will be connecting to a room with
[`RoomProvider`](/docs/api-reference/liveblocks-react#RoomProvider) or
[`enterRoom`](/docs/api-reference/liveblocks-client#Client.enterRoom) within 10
seconds, and the room will load quicker. This is a wrapper around the
[Prewarm Room API](/docs/api-reference/rest-api-endpoints#get-rooms-roomId-prewarm)
and returns no response.

```ts
await liveblocks.prewarmRoom("my-room-id");
```

##### Warm a room before navigating

Triggering a room directly before a user navigates to a room is an easy to way
use this API. Hereâ€™s a Next.js server actions example, showing how to trigger
prewarming with `onPointerDown`.

```ts title="actions.ts"
"use server";

import { Liveblocks } from "@liveblocks/node";

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

export async function prewarmRoom(roomId: string) {
  // +++
  await liveblocks.prewarmRoom(roomId);
  // +++
}
```

```tsx title="RoomLink.tsx"
"use client";

import { prewarmRoom } from "../actions";
import Link from "next/link";

export function JoinButton({ roomId }: { roomId: string }) {
  return (
    // +++
    <Link href={`/rooms/${roomId}`} onPointerDown={() => prewarmRoom(roomId)}>
      // +++
      {roomId}
    </Link>
  );
}
```

`onPointerDown` is slightly quicker than `onClick` because it triggers before
the user releases their pointer.

#### Liveblocks.updateRoomId [#post-rooms-update-roomId]

Permanently updates a roomâ€™s ID. `newRoomId` will replace `currentRoomId`. Note
that this will disconnect connected users from the room, but this can be worked
around. Throws an error if the room isnâ€™t found. This is a wrapper around the
[Update Room API](/docs/api-reference/rest-api-endpoints#post-rooms-update-roomId)
and returns the same response.

```ts
const room = await liveblocks.updateRoomId({
  currentRoomId: "my-room-id",
  newRoomId: "new-room-id",
});

// { type: "room", id: "my-room-id", metadata: {...}, ... }
console.log(room);
```

##### Redirect connected users to the new room

When a roomâ€™s ID is changed it disconnects all users that are currently
connected. To redirect connected users to the new room you can use
[`useErrorListener`](/docs/api-reference/liveblocks-react#useErrorListener) or
[`room.subscribe("error")`](/docs/api-reference/liveblocks-client#Room.subscribe.error)
in your application to get the new roomâ€™s ID, and redirect users to the renamed
room.

```tsx
import { useErrorListener } from "@liveblocks/react/suspense";

function App() {
  useErrorListener((error) => {
    if (error.context.code === 4006) {
      // Room ID has been changed, get the new ID and redirect
      const newRoomId = error.message;
      __redirect__(`https://example.com/document/${newRoomId}}`);
    }
  });
}
```

#### Liveblocks.getActiveUsers [#get-rooms-roomId-active-users]

Returns a list of users that are currently present in the room. Throws an error
if the room isnâ€™t found. This is a wrapper around the
[Get Active Users API](/docs/api-reference/rest-api-endpoints#get-rooms-roomId-active-users)
and returns the same response.

```ts
const activeUsers = await liveblocks.getActiveUsers("my-room-id");

// { data: [{ type: "user", id: "my-user-id", ... }, ...] }
console.log(activeUsers);
```

#### Liveblocks.broadcastEvent [#post-broadcast-event]

Broadcasts a custom event to the room. Throws an error if the room isnâ€™t found.
This is a wrapper around the
[Broadcast Event API](/docs/api-reference/rest-api-endpoints#post-broadcast-event)
and returns no response.

```ts
const customEvent = {
  type: "EMOJI",
  emoji: "ðŸ”¥",
};

await liveblocks.broadcastEvent("my-room-id", customEvent);
```

You can respond to custom events on the front end with
[`useEventListener`](/docs/api-reference/liveblocks-react#useEventListener) and
[`room.subscribe("event")`](/docs/api-reference/liveblocks-client#Room.subscribe.event).
When receiving an event sent with `Liveblocks.broadcastEvent`, `user` will be
`null` and `connectionId` will be `-1`.

```tsx
import { useEventListener } from "@liveblocks/react/suspense";

// When receiving an event sent from `@liveblocks/node`
useEventListener(({ event, user, connectionId }) => {
  // `null`
  console.log(user);

  // `-1`
  console.log(connectionId);
});
```

### Groups

Groups allow you to manage users for group mentions in comments and text
editors.

#### Liveblocks.createGroup [#create-group]

Creates a new group with the specified members. This is a wrapper around the
[Create Group API](/docs/api-reference/rest-api-endpoints#post-groups) and
returns the same response.

```ts
const group = await liveblocks.createGroup({
  groupId: "engineering-team",
  memberIds: ["alice@example.com", "bob@example.com"],
});

// { type: "group", id: "engineering-team", tenantId: "acme-corp", createdAt: "...", updatedAt: "...", scopes: { mention: true }, members: [...] }
console.log(group);
```

You can also create a group without members and add them later:

```ts
const group = await liveblocks.createGroup({
  groupId: "design-team",
  // Optional, add members when creating the group
  memberIds: ["charlie@example.com"],

  // Optional, create it on a specific tenant
  tenantId: "company-123",

  // Optional, set group scopes (defaults to { mention: true })
  scopes: { mention: true },
});
```

#### Liveblocks.getGroup [#get-group]

Returns a group by its ID. Throws an error if the group isnâ€™t found. This is a
wrapper around the
[Get Group API](/docs/api-reference/rest-api-endpoints#get-groups-groupId) and
returns the same response.

```ts
const group = await liveblocks.getGroup({
  groupId: "engineering-team",
});

// { type: "group", id: "engineering-team", tenantId: "acme-corp", createdAt: "...", updatedAt: "...", scopes: { mention: true }, members: [...] }
console.log(group);
```

#### Liveblocks.getGroups [#get-groups]

Returns a list of all groups in your project. This is a wrapper around the
[Get Groups API](/docs/api-reference/rest-api-endpoints#get-groups) and returns
the same response.

```ts
const { data: groups, nextCursor } = await liveblocks.getGroups();

// A list of groups
// [{ type: "group", id: "engineering-team", tenantId: "acme-corp", createdAt: "...", updatedAt: "...", scopes: { mention: true }, members: [...] }, ...]
console.log(groups);

// A pagination cursor for the next page
console.log(nextCursor);
```

You can also paginate through groups:

```ts
const { data: groups, nextCursor } = await liveblocks.getGroups({
  // Optional, the number of groups to return (defaults to 20)
  limit: 50,

  // Optional, cursor for pagination
  startingAfter: nextCursor,
});
```

#### Liveblocks.getUserGroups [#get-user-groups]

Returns all groups that a specific user is a member of. This is a wrapper around
the
[Get User Groups API](/docs/api-reference/rest-api-endpoints#get-users-userId-groups)
and returns the same response.

```ts
const { data: userGroups, nextCursor } = await liveblocks.getUserGroups({
  userId: "alice@example.com",
});

// A list of groups the user belongs to
// [{ type: "group", id: "engineering-team", ... }, ...]
console.log(userGroups);
```

You can also paginate through user groups:

```ts
const { data: userGroups, nextCursor } = await liveblocks.getUserGroups({
  userId: "alice@example.com",
  limit: 25,
  startingAfter: "L3YyL2dyb3Vwcy...",
});
```

#### Liveblocks.addGroupMembers [#add-group-members]

Adds new members to an existing group. This is a wrapper around the
[Add Group Members API](/docs/api-reference/rest-api-endpoints#post-groups-groupId-add-members)
and returns the same response.

```ts
const updatedGroup = await liveblocks.addGroupMembers({
  groupId: "engineering-team",
  memberIds: ["david@example.com", "eve@example.com"],
});

// { type: "group", id: "engineering-team", tenantId: "acme-corp", createdAt: "...", updatedAt: "...", scopes: { mention: true }, members: [...] }
console.log(updatedGroup);
```

#### Liveblocks.removeGroupMembers [#remove-group-members]

Removes members from an existing group. This is a wrapper around the
[Remove Group Members API](/docs/api-reference/rest-api-endpoints#post-groups-groupId-remove-members)
and returns the same response.

```ts
const updatedGroup = await liveblocks.removeGroupMembers({
  groupId: "engineering-team",
  memberIds: ["david@example.com"],
});

// { type: "group", id: "engineering-team", tenantId: "acme-corp", createdAt: "...", updatedAt: "...", scopes: { mention: true }, members: [...] }
console.log(updatedGroup);
```

#### Liveblocks.deleteGroup [#delete-group]

Deletes a group. If the group doesnâ€™t exist, no error will be thrown. This is a
wrapper around the
[Delete Group API](/docs/api-reference/rest-api-endpoints#delete-groups-groupId)
and returns no response.

```ts
await liveblocks.deleteGroup({
  groupId: "old-team",
});
```

### Storage

#### Liveblocks.getStorageDocument [#get-rooms-roomId-storage]

Returns the contents of a roomâ€™s Storage tree. By default, returns Storage in
LSON format. Throws an error if the room isnâ€™t found. This is a wrapper around
the
[Get Storage Document API](/docs/api-reference/rest-api-endpoints#get-rooms-roomId-storage)
and returns the same response.

```ts
const storage = await liveblocks.getStorageDocument("my-room-id");
```

LSON is a custom Liveblocks format that preserves information about the
conflict-free data types used. By default, `getStorageDocument` returns Storage
in this format. This is the same as using `"plain-json"` in the second argument.

```ts highlight="2"
// Retrieve LSON Storage data
const storage = await liveblocks.getStorageDocument("my-room-id", "plain-lson");

// If this were your Storage type...
declare global {
  interface Liveblocks {
    Storage: {
      names: LiveList<string>;
    };
  }
}

// {
//   liveblocksType: "LiveObject",
//   data: {
//     names: {
//       liveblocksType: "LiveList",
//       data: ["Olivier", "Nimesh"],
//     }
//   }
// }
console.log(storage);
```

You can also retrieve Storage as JSON by passing `"json"` into the second
argument.

```ts highlight="2"
// Retrieve JSON Storage data
const storage = await liveblocks.getStorageDocument("my-room-id", "json");

// If this were your Storage type...
declare global {
  interface Liveblocks {
    Storage: {
      names: LiveList<string>;
    };
  }
}

// {
//   names: ["Olivier", "Nimesh"]
// }
console.log(storage);
```

#### Liveblocks.initializeStorageDocument [#post-rooms-roomId-storage]

Initializes a roomâ€™s Storage tree with given LSON data. To use this, the room
must have [already been created](#post-rooms) and have empty Storage. Throws an
error if the room isnâ€™t found. Calling this will disconnect all active users
from the room. This is a wrapper around the
[Initialize Storage Document API](/docs/api-reference/rest-api-endpoints#post-rooms-roomId-storage)
and returns the same response.

```ts
// Create a new room
const room = await liveblocks.createRoom("my-room-id", {
  defaultAccesses: ["room:write"],
});

// Initialize Storage
const storage = await liveblocks.initializeStorageDocument("my-room-id", {
  // Your LSON Storage value
  // ...
});
```

LSON is a custom Liveblocks format that preserves information about
conflict-free data types. The easiest way to create it is using the
`toPlainLson` helper provided by `@liveblocks/client`. Note that your Storage
root should always be a `LiveObject`.

```ts highlight="11-13,18-20,25"
import { toPlainLson, LiveList, LiveObject } from "@liveblocks/client";

// Create a new room
const room = await liveblocks.createRoom("my-room-id", {
  defaultAccesses: ["room:write"],
});

// If this were your Storage type...
declare global {
  interface Liveblocks {
    Storage: {
      names: LiveList<string>;
    };
  }
}

// Create the initial conflict-free data
const initialStorage: LiveObject<Liveblocks["Storage"]> = new LiveObject({
  names: new LiveList(["Olivier", "Nimesh"]),
});

// Convert to LSON and create Storage
const storage = await liveblocks.initializeStorageDocument(
  "my-room-id",
  toPlainLson(initialStorage)
);
```

Itâ€™s also possible to create plain LSON manually, without the helper function.

```ts highlight="9-11,17-23"
// Create a new room
const room = await liveblocks.createRoom("my-room-id", {
  defaultAccesses: ["room:write"],
});

// If this were your Storage type...
declare global {
  interface Liveblocks {
    Storage: {
      names: LiveList<string>;
    };
  }
}

// Create this Storage and add names to the LiveList
const storage = await liveblocks.initializeStorageDocument("my-room-id", {
  liveblocksType: "LiveObject",
  data: {
    names: {
      liveblocksType: "LiveList",
      data: ["Olivier", "Nimesh"],
    },
  },
});
```

#### Liveblocks.mutateStorage [#mutate-storage]

Modify Storage contents from the server. No presence will be shown when you make
changes.

```ts
// Mutate a single room
await liveblocks.mutateStorage(
  "my-room-id",

  ({ root }) => {
    root.get("list").push("item3");
  }
);
```

The callback can be asynchronous, in which case a stream of mutations can happen
over time.

```ts
// Mutate a single room
await liveblocks.mutateStorage(
  "my-room-id",

  async ({ root }) => {
    // These changes happen immediately
    const animals = root.get("animals");
    animals.clear();
    animals.push("Thinking...");

    await thinkForAWhile();

    // These changes happen after `await` has run
    animals.clear();
    animals.push("ðŸ¶");
    animals.push("ðŸ¦˜");
  }
);
```

Learn how to
[type your Storage](/docs/api-reference/liveblocks-react#Typing-your-data).

#### Liveblocks.massMutateStorage [#mass-mutate-storage]

Modify Storage contents for multiple rooms simultaneously. With the default
query value `{}` it will loop through every room in your project.

```ts
// Mutate a number of rooms
await liveblocks.massMutateStorage(
  {},

  // Callback runs on every selected room
  ({ room, root }) => {
    // { type: "room", id: "my-room-id", metadata: {...}, ... }
    console.log(room);

    root.get("animals").push("ðŸ¦");
  }
);
```

A number of options are also available, enabling you to filter for certain
rooms. Additionally, you can set options for concurrency and provide an abort
signal to cancel the mutations.

```ts
// Mutate a number of rooms
await liveblocks.massMutateStorage(
  {
    // +++
    // Optional, filter for rooms that allow entry to group ID(s) in `groupsAccesses`
    groupIds: ["engineering", "design"],

    // Optional, filter for rooms that allow entry to a user's ID in `usersAccesses`
    userId: "my-user-id",

    // Optional, use advanced filtering
    query: {
      // Optional, filter for rooms with an ID that starts with specific string
      roomId: {
        startsWith: "liveblocks:",
      },
      // Optional, filter for rooms with custom metadata in `metadata`
      metadata: {
        roomType: "whiteboard",
      },
    },
    // +++
  },

  ({ room, root }) => {
    // { type: "room", id: "my-room-id", metadata: {...}, ... }
    console.log(room);

    root.get("animals").push("ðŸ¦");
  },

  // Optional
  // +++
  {
    concurrency: 10, // Optional, process at most 10 rooms simultaneously
    signal, // Optional, provide an abort signal to cancel mutations mid-way
  }
  // +++
);
```

Learn how to
[type your Storage](/docs/api-reference/liveblocks-react#Typing-your-data).

#### Liveblocks.deleteStorageDocument [#delete-rooms-roomId-storage]

Deletes a roomâ€™s Storage data. Calling this will disconnect all active users
from the room. Throws an error if the room isnâ€™t found. This is a wrapper around
the
[Delete Storage Document API](/docs/api-reference/rest-api-endpoints#delete-rooms-roomId-storage)
and returns no response.

```ts
await liveblocks.deleteStorageDocument("my-room-id");
```

### Yjs

#### Liveblocks.getYjsDocument [#get-rooms-roomId-ydoc]

Returns a JSON representation of a roomâ€™s Yjs document. Throws an error if the
room isnâ€™t found. This is a wrapper around the
[Get Yjs Document API](/docs/api-reference/rest-api-endpoints#get-rooms-roomId-ydoc)
and returns the same response.

```ts
const yjsDocument = await liveblocks.getYjsDocument("my-room-id");

// { yourYText: "...", yourYArray: [...], ... }
console.log(yjsDocument);
```

A number of options are available.

```ts
const yjsDocument = await liveblocks.getYjsDocument("my-room-id", {
  // Optional, if true, `yText` values will return formatting
  format: true,

  // Optional, return a single key's value, e.g. `yDoc.get("my-key-id").toJson()`
  key: "my-key-id",

  // Optional, override the inferred `key` type, e.g. "ymap" for `doc.get(key, Y.Map)`
  type: "ymap",
});
```

#### Liveblocks.sendYjsBinaryUpdate [#put-rooms-roomId-ydoc]

Send a Yjs binary update to a roomâ€™s Yjs document. You can use this to update or
initialize the roomâ€™s Yjs document. Throws an error if the room isnâ€™t found.
This is a wrapper around the
[Send a Binary Yjs Update API](/docs/api-reference/rest-api-endpoints#put-rooms-roomId-ydoc)
and returns no response.

```ts
await liveblocks.sendYjsBinaryUpdate("my-room-id", update);
```

Hereâ€™s an example of how to update a roomâ€™s Yjs document with your changes.

```ts
import * as Y from "yjs";

// Create a Yjs document
const yDoc = new Y.Doc();

// Create your data structures and make your update
// If you're using a text editor, you need to match its format
const yText = yDoc.getText("text");
yText.insert(0, "Hello world");

// Encode the document state as an update
const update = Y.encodeStateAsUpdate(yDoc);

// Send update to Liveblocks
await liveblocks.sendYjsBinaryUpdate("my-room-id", update);
```

To update a subdocument instead of the main document, pass its `guid`.

```ts
await liveblocks.sendYjsBinaryUpdate("my-room-id", update, {
  // Optional, update a subdocument instead. guid is its unique identifier
  guid: "c4a755...",
});
```

To create a new room and initialize its Yjs document, call
[`liveblocks.createRoom`](#post-rooms) before sending the binary update.

```ts highlight="1-2"
// Create new room
const room = await liveblocks.createRoom("my-room-id");

// Set initial Yjs document value
await liveblocks.sendYjsBinaryUpdate("my-room-id", state);
```

##### Different editors

Note that each text and code editor handles binary updates in a different way,
and may use a different Yjs shared type, for example
[`Y.XmlFragment`](https://docs.yjs.dev/api/shared-types/y.xmlfragment) instead
of [`Y.Text`](https://docs.yjs.dev/api/shared-types/y.text).

Create a binary update with [Slate](https://www.slatejs.org/):

```ts title="Slate binary update" highlight="3,13-17,19-21" isCollapsed isCollapsable
import { Liveblocks } from "@liveblocks/node";
import * as Y from "yjs";
import { slateNodesToInsertDelta } from "@slate-yjs/core";

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

export async function POST() {
  // Create a Yjs document
  const yDoc = new Y.Doc();

  // Create Slate document state
  const slateDoc = {
    type: "paragraph",
    children: [{ text: "Hello world" }],
  };

  // Create your data structures and make your update
  const insertDelta = slateNodesToInsertDelta(slateDoc);
  (yDoc.get("content", Y.XmlText) as Y.XmlText).applyDelta(insertDelta);

  // Encode the document state as an update
  const update = Y.encodeStateAsUpdate(yDoc);

  // Send update to Liveblocks
  await liveblocks.sendYjsBinaryUpdate("my-room-id", update);
}
```

Create a binary update with
[Tiptap](https://tiptap.dev/docs/editor/api/extensions/collaboration):

```ts title="Tiptap binary update" highlight="12-14,16-18" isCollapsed isCollapsable
import * as Y from "yjs";
import { Liveblocks } from "@liveblocks/node";

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

export async function POST() {
  // Create a Yjs document
  const yDoc = new Y.Doc();

  // Create Tiptap Yjs state
  const yXmlElement = new Y.XmlElement("paragraph");
  yXmlElement.insert(0, [new Y.XmlText("Hello world")]);

  // Create your data structures and make your update
  const yXmlFragment = yDoc.getXmlFragment("default");
  yXmlFragment.insert(0, [yXmlElement]);

  // Encode the document state as an update message
  const yUpdate = Y.encodeStateAsUpdate(yDoc);

  // Initialize the Yjs document with the update
  await liveblocks.sendYjsBinaryUpdate("my-room-id", {
    update: yUpdate,
  });
}
```

Read the [Yjs documentation](https://docs.yjs.dev/api/document-updates) to learn
more about creating binary updates.

#### Liveblocks.getYjsDocumentAsBinaryUpdate [#get-rooms-roomId-ydoc-binary]

Return a roomâ€™s Yjs document as a single binary update. You can use this to get
a copy of your Yjs document in your back end. Throws an error if the room isnâ€™t
found. This is a wrapper around the
[Get Yjs Document Encoded as a Binary Yjs Update API](/docs/api-reference/rest-api-endpoints#get-rooms-roomId-ydoc-binary)
and returns the same response.

```ts
const binaryYjsUpdate =
  await liveblocks.getYjsDocumentAsBinaryUpdate("my-room-id");
```

To return a subdocument instead of the main document, pass its `guid`.

```ts
const binaryYjsUpdate = await liveblocks.getYjsDocumentAsBinaryUpdate(
  "my-room-id",
  {
    // Optional, return a subdocument instead. guid is its unique identifier
    guid: "c4a755...",
  }
);
```

Read the [Yjs documentation](https://docs.yjs.dev/api/document-updates) to learn
more about using binary updates.

### Schema validation

#### Liveblocks.createSchema [#post-create-new-schema]

Creates a schema that can be used to enforce a roomâ€™s Storage data structure.
The schema consists of a unique name, and a body which specifies the data shape
of the room in Liveblocks
[schema syntax](/docs/platform/schema-validation/syntax). This is a wrapper
around the
[Create Schema API](/docs/api-reference/rest-api-endpoints#post-create-new-schema)
and returns the same response.

```ts
const schemaBody = `
  type Storage {
    names: LiveList<string>
  }
`;

const schema = await liveblocks.createSchema("my-schema-name", schemaBody);

// { id: "my-schema-name@1", name: "my-schema-name", version: 1, ... }
console.log(schema);
```

Read the [schema validation](/docs/platform/schema-validation) page to learn
more.

#### Liveblocks.getSchema [#get-create-new-schema]

Returns a schema from its ID. A schemaâ€™s ID is a combination of its name and
version, for example the ID for version `1` of `my-schema-name` is
`my-schema-name@1`. This is a wrapper around the
[Get Schema API](/docs/api-reference/rest-api-endpoints#get-create-new-schema)
and returns the same response.

```ts
const updatedBody = `
  type Storage {
    names: LiveMap<string, string>
  }
`;

const schema = await liveblocks.getSchema("my-schema-name@1", updatedBody);

// { id: "my-schema-name@1", name: "my-schema-name", version: 1, ... }
console.log(schema);
```

Read the [schema validation](/docs/platform/schema-validation) page to learn
more.

#### Liveblocks.updateSchema [#put-update-new-schema]

Updates a schemaâ€™s body and increments its version. A schemaâ€™s body specifies
the data shape of the room in Liveblocks
[schema syntax](/docs/platform/schema-validation/syntax). Find the schema by its
ID, a combination of its name and version, for example the ID for version `1` of
`my-schema-name` is `my-schema-name@1`. This is a wrapper around the
[Update Schema API](/docs/api-reference/rest-api-endpoints#put-update-new-schema)
and returns the same response.

```ts
const schema = await liveblocks.updateSchema("my-schema-name@1");

// { id: "my-schema-name@1", name: "my-schema-name", version: 1, ... }
console.log(schema);
```

Read the [schema validation](/docs/platform/schema-validation) page to learn
more.

#### Liveblocks.deleteSchema [#delete-a-schema]

Deletes a schema. This is only allowed if the schema is not attached to a room.
Find the schema by its ID, a combination of its name and version, for example
the ID for version `1` of `my-schema-name` is `my-schema-name@1`. This is a
wrapper around the
[Delete Schema API](/docs/api-reference/rest-api-endpoints#delete-a-schema) and
returns no response.

```ts
await liveblocks.deleteSchema("my-schema-name@1");
```

Read the [schema validation](/docs/platform/schema-validation) page to learn
more.

#### Liveblocks.getSchemaByRoomId [#get-new-schema]

Returns the schema attached to a room. Throws an error if the room isnâ€™t found.
This is a wrapper around the
[Get Schema By Room API](/docs/api-reference/rest-api-endpoints#get-new-schema)
and returns the same response.

```ts
const schema = await liveblocks.getSchemaByRoomId("my-room-id");

// { id: "my-schema-name@1", name: "my-schema-name", version: 1, ... }
console.log(schema);
```

Read the [schema validation](/docs/platform/schema-validation) page to learn
more.

#### Liveblocks.attachSchemaToRoom [#post-attach-schema-to-room]

Attaches a schema to a room, and instantly enables runtime schema validation in
it. Attach the schema by its ID, a combination of its name and version, for
example the ID for version `1` of `my-schema-name` is `my-schema-name@1`. This
is a wrapper around the
[Attach Schema to a Room API](/docs/api-reference/rest-api-endpoints#post-attach-schema-to-room)
and returns the same response.

If the current contents of the roomâ€™s Storage do not match the schema, attaching
will fail and the error message will give details on why the schema failed to
attach. Itâ€™ll also throw an error if the room isnâ€™t found.

```ts
const schema = await liveblocks.attachSchemaToRoom(
  "my-room-id",
  "my-schema-name@1"
);

// { id: "my-schema-name@1", name: "my-schema-name", version: 1, ... }
console.log(schema);
```

Read the [schema validation](/docs/platform/schema-validation) page to learn
more.

#### Liveblocks.detachSchemaFromRoom [#delete-detach-schema-to-room]

Detaches a schema from a room. This is a wrapper around the
[Detach Schema from a Room API](/docs/api-reference/rest-api-endpoints#post-detach-schema-to-room)
and returns no response.

```ts
await liveblocks.detachSchemaFromRoom("my-room-id");
```

### Comments

#### Liveblocks.getThreads [#get-rooms-roomId-threads]

Returns a list of threads found inside a room. Throws an error if the room isnâ€™t
found. This is a wrapper around the
[Get Room Threads API](/docs/api-reference/rest-api-endpoints#get-rooms-roomId-threads)
and returns the same response.

```ts
const { data: threads } = await liveblocks.getThreads({
  roomId: "my-room-id",
});

// [{ type: "thread", id: "th_d75sF3...", ... }, ...]
console.log(threads);
```

Itâ€™s also possible to filter threads by their string, boolean, and number
metadata using a query parameter. You can also pass `startsWith` to match the
start of a string.

```ts
const { data: threads } = await liveblocks.getThreads({
  roomId: "my-room-id",

  // Optional, use advanced filtering
  query: {
    // Optional, filter based on resolved status
    resolved: false,
    // Optional, filter for metadata values
    metadata: {
      status: "open",
      pinned: true,
      priority: 3,

      // You can match the start of a metadata string
      organization: {
        startsWith: "liveblocks:",
      },
    },
  },
});
```

You can also pass a
[query language](/docs/guides/how-to-filter-threads-using-query-language) string
instead of a `query` object.

#### Liveblocks.createThread [#post-rooms-roomId-threads]

Creates a new thread within a specific room, using room ID and thread data. This
is a wrapper around the
[Create Thread API](/docs/api-reference/rest-api-endpoints#post-rooms-roomId-threads)
and returns the new thread.

```ts
const thread = await liveblocks.createThread({
  roomId: "my-room-id",

  data: {
    comment: {
      userId: "florent@example.com",
      body: {
        version: 1,
        content: [
          /* The comment's body text goes here, see below */
        ],
      },
    },
  },
});

// { type: "thread", id: "th_d75sF3...", ... }
console.log(thread);
```

A commentâ€™s body is an array of paragraphs, each containing child nodes. Hereâ€™s
an example of how to construct a commentâ€™s body, which can be submitted under
`data.comment.body`.

```tsx highlight="3-11,20"
import { CommentBody } from "@liveblocks/node";

const body: CommentBody = {
  version: 1,
  content: [
    {
      type: "paragraph",
      children: [{ text: "Hello " }, { text: "world", bold: true }],
    },
  ],
};

const thread = await liveblocks.createThread({
  roomId: "my-room-id",

  data: {
    // ...
    comment: {
      // The comment's body, uses the `CommentBody` type
      body,

      // ...
    },
  },
});
```

This method has a number of options, allowing for custom metadata and a creation
date for the comment.

```ts
const thread = await liveblocks.createThread({
  roomId: "my-room-id",

  data: {
    // Optional, custom metadata properties
    metadata: {
      color: "blue",
      page: 3,
      pinned: true,
    },

    // Data for the first comment in the thread
    comment: {
      // The ID of the user that created the comment
      userId: "florent@example.com",

      // Optional, when the comment was created.
      createdAt: new Date(),

      // Optional, custom comment metadata
      metadata: {
        tag: "important",
        spam: false,
      },

      // The comment's body, uses the `CommentBody` type
      body: {
        version: 1,
        content: [
          /* The comment's body text goes here, see above */
        ],
      },
    },
  },
});

// { type: "thread", id: "th_d75sF3...", ... }
console.log(thread);
```

#### Liveblocks.getThread [#get-rooms-roomId-threads-threadId]

Returns a thread. Throws an error if the room or thread isnâ€™t found. This is a
wrapper around the
[Get Thread API](/docs/api-reference/rest-api-endpoints#get-rooms-roomId-threads-threadId)
and returns the same response.

```ts
const thread = await liveblocks.getThread({
  roomId: "my-room-id",
  threadId: "th_d75sF3...",
});

// { type: "thread", id: "th_d75sF3...", ... }
console.log(thread);
```

#### Liveblocks.editThreadMetadata [#post-rooms-roomId-threads-threadId-metadata]

Updates the metadata of a specific thread within a room. This method allows you
to modify the metadata of a thread, including user information and the date of
the last update. Throws an error if the room or thread isnâ€™t found. This is a
wrapper around the
[Update Thread Metadata API](/docs/api-reference/rest-api-endpoints#post-rooms-roomId-threads-threadId-metadata)
and returns the updated metadata.

```ts
const editedMetadata = await liveblocks.editThreadMetadata({
  roomId: "my-room-id",
  threadId: "th_d75sF3...",

  data: {
    metadata: {
      color: "yellow",
    },
    userId: "marc@example.com",
    updatedAt: new Date(), // Optional
  },
});

// { color: "yellow", page: 3, pinned: true }
console.log(editedMetadata);
```

Metadata can be a `string`, `number`, or `boolean`. You can also use `null` to
remove metadata from a thread. Hereâ€™s an example using every option.

```ts
const editedMetadata = await liveblocks.editThreadMetadata({
  roomId: "my-room-id",
  threadId: "th_d75sF3...",

  data: {
    // Custom metadata
    metadata: {
      // Metadata can be a string, number, or boolean
      title: "My thread title",
      page: 3,
      pinned: true,

      // Remove metadata with null
      color: null,
    },

    // The ID of the user that updated the metadata
    userId: "marc@example.com",

    // Optional, the time the user updated the metadata
    updatedAt: new Date(),
  },
});

// { title: "My thread title", page: 3, pinned: true }
console.log(editedMetadata);
```

#### Liveblocks.editCommentMetadata [#post-rooms-roomId-threads-threadId-comments-commentId-metadata]

Updates the metadata of a specific comment within a thread. This method allows
you to modify the metadata of a comment, including user information and the date
of the last update. Throws an error if the room, thread, or comment isnâ€™t found.
This is a wrapper around the
[Update Comment Metadata API](/docs/api-reference/rest-api-endpoints#post-rooms-roomId-threads-threadId-comments-commentId-metadata)
and returns the updated metadata.

```ts
const editedMetadata = await liveblocks.editCommentMetadata({
  roomId: "my-room-id",
  threadId: "th_d75sF3...",
  commentId: "cm_agH76a...",

  data: {
    metadata: {
      spam: false,
    },
    userId: "stacy@example.com",
    updatedAt: new Date(), // Optional
  },
});

// { spam: false }
console.log(editedMetadata);
```

Metadata can be a `string`, `number`, or `boolean`. You can also use `null` to
remove metadata from a comment. Hereâ€™s an example using every option.

```ts
const editedMetadata = await liveblocks.editCommentMetadata({
  roomId: "my-room-id",
  threadId: "th_d75sF3...",
  commentId: "cm_agH76a...",

  data: {
    // Custom metadata
    metadata: {
      // Metadata can be a string, number, or boolean
      tag: "important",
      priority: 2,
      spam: true,

      // Remove metadata with null
      assignedTo: null,
    },

    // The ID of the user that updated the metadata
    userId: "stacy@example.com",

    // Optional, the time the user updated the metadata
    updatedAt: new Date(),
  },
});

// { tag: "important", priority: 2, flagged: true }
console.log(editedMetadata);
```

#### Liveblocks.markThreadAsResolved [#post-rooms-roomId-threads-threadId-mark-as-resolved]

Marks a thread as resolved, which means it sets the `resolved` property on the
specified thread to `true`. Takes a `userId`, which is the ID of the user that
resolved the thread. Throws an error if the room or thread isnâ€™t found. This is
a wrapper around the
[Mark Thread As Resolved API](/docs/api-reference/rest-api-endpoints#post-rooms-roomId-threads-threadId-mark-as-resolved)
and returns the same response.

```ts
const thread = await liveblocks.markThreadAsResolved({
  roomId: "my-room-id",
  threadId: "th_d75sF3...",
  data: {
    userId: "steven@example.com",
  },
});

// { type: "thread", id: "th_d75sF3...", ... }
console.log(thread);
```

#### Liveblocks.markThreadAsUnresolved [#post-rooms-roomId-threads-threadId-mark-as-unresolved]

Marks a thread as unresolved, which means it sets the `resolved` property on the
specified thread to `false`. Takes a `userId`, which is the ID of the user that
unresolved the thread. Throws an error if the room or thread isnâ€™t found. This
is a wrapper around the
[Mark Thread As Unresolved API](/docs/api-reference/rest-api-endpoints#post-rooms-roomId-threads-threadId-mark-as-unresolved)
and returns the same response.

```ts
const thread = await liveblocks.markThreadAsUnresolved({
  roomId: "my-room-id",
  threadId: "th_d75sF3...",
  data: {
    userId: "steven@example.com",
  },
});

// { type: "thread", id: "th_d75sF3...", ... }
console.log(thread);
```

#### Liveblocks.deleteThread [#delete-rooms-roomId-threads-threadId]

Deletes a thread. Throws an error if the room or thread isnâ€™t found. This is a
wrapper around the
[Delete Thread API](/docs/api-reference/rest-api-endpoints#delete-rooms-roomId-threads-threadId)
and returns no response.

```ts
await liveblocks.deleteThread({
  roomId: "my-room-id",
  threadId: "th_d75sF3...",
});
```

#### Liveblocks.subscribeToThread [#post-rooms-roomId-threads-threadId-subscribe]

Subscribes a user to a thread, meaning they will receive inbox notifications
when new comments are posted. Throws an error if the room or thread isnâ€™t found.
This is a wrapper around the
[Subscribe To Thread API](/docs/api-reference/rest-api-endpoints#post-rooms-roomId-threads-threadId-subscribe)
and returns the same response.

```ts
const subscription = await liveblocks.subscribeToThread({
  roomId: "my-room-id",
  threadId: "th_d75sF3...",
  data: {
    userId: "steven@example.com",
  },
});

// { kind: "thread", subjectId: "th_d75sF3...", ... }
console.log(subscription);
```

Subscribing will replace any existing subscription for the current thread
[set at room-level](#post-rooms-roomId-users-userId-subscription-settings). This
value can also be overridden by a room-level call that is run afterwards.

```ts
const roomId = "my-room-id";
const userId = "steven@example.com";

// 1. Disables notifications for all threads
await liveblocks.updateRoomSubscriptionSettings({
  roomId,
  userId,
  data: {
    threads: "none",
  },
});

// 2. Enables notifications just for this thread, "th_d75sF3..."
await liveblocks.subscribeToThread({
  roomId,
  threadId: "th_d75sF3...",
  data: { userId },
});

// 3. Disables notifications for all threads, including "th_d75sF3..."
await liveblocks.updateRoomSubscriptionSettings({
  roomId,
  userId,
  data: {
    threads: "none",
  },
});
```

#### Liveblocks.unsubscribeFromThread [#post-rooms-roomId-threads-threadId-unsubscribe]

Unsubscribes a user from a thread, meaning they will no longer receive inbox
notifications when new comments are posted. Throws an error if the room or
thread isnâ€™t found. This is a wrapper around the
[Unsubscribe From Thread API](/docs/api-reference/rest-api-endpoints#post-rooms-roomId-threads-threadId-unsubscribe)
and returns the same response.

```ts
await liveblocks.unsubscribeFromThread({
  roomId: "my-room-id",
  threadId: "th_d75sF3...",
  data: {
    userId: "steven@example.com",
  },
});
```

Unsubscribing will replace any existing subscription for the current thread
[set at room-level](#post-rooms-roomId-users-userId-subscription-settings). This
value can also be overridden by a room-level call that is run afterwards.

```ts
const roomId = "my-room-id";
const userId = "steven@example.com";

// 1. Enables notifications for all thread activity
await liveblocks.updateRoomSubscriptionSettings({
  roomId,
  userId,
  data: {
    threads: "all",
  },
});

// 2. Disables notifications just for this thread, "th_d75sF3..."
await liveblocks.unsubscribeFromThread({
  roomId,
  threadId: "th_d75sF3...",
  data: { userId },
});

// 3. Enables notifications for all thread activity, including "th_d75sF3..."
await liveblocks.updateRoomSubscriptionSettings({
  roomId,
  userId,
  data: {
    threads: "none",
  },
});
```

#### Liveblocks.getThreadSubscriptions [#get-rooms-roomId-threads-threadId-subscriptions]

Gets a threadâ€™s subscriptions, returning a list of users that will receive
notifications when new comments are posted. Throws an error if the room or
thread isnâ€™t found. This is a wrapper around the
[Get Thread Subscriptions API](/docs/api-reference/rest-api-endpoints#get-rooms-roomId-threads-threadId-subscriptions)
and returns the same response.

```ts
const { data: subscriptions } = await liveblocks.getThreadSubscriptions({
  roomId: "my-room-id",
  threadId: "th_d75sF3...",
});

// [{ kind: "thread", subjectId: "th_d75sF3...", userId: "steven@example.com", ... }, ...]
console.log(subscriptions);
```

#### Liveblocks.createComment [#post-rooms-roomId-threads-threadId-comments]

Creates a new comment in a specific thread within a room. This method allows
users to add comments to a conversation thread, specifying the user who made the
comment and the content of the comment. This method is a wrapper around the
[Create Comment API](/docs/api-reference/rest-api-endpoints#post-rooms-roomId-threads-threadId-comments)
and returns the new comment.

```ts
const comment = await liveblocks.createComment({
  roomId: "my-room-id",
  threadId: "th_d75sF3...",

  data: {
    body: {
      version: 1,
      content: [
        /* The comment's body text goes here, see below */
      ],
    },
    userId: "pierre@example.com",
    createdAt: new Date(), // Optional
  },
});
```

A commentâ€™s body is an array of paragraphs, each containing child nodes. Hereâ€™s
an example of how to construct a commentâ€™s body, which can be submitted under
`data.body`.

```tsx highlight="3-11,19"
import { CommentBody } from "@liveblocks/node";

const body: CommentBody = {
  version: 1,
  content: [
    {
      type: "paragraph",
      children: [{ text: "Hello " }, { text: "world", bold: true }],
    },
  ],
};

const comment = await liveblocks.createComment({
  roomId: "my-room-id",
  threadId: "th_d75sF3...",

  data: {
    // The comment's body, uses the `CommentBody` type
    body,

    // ...
  },
});
```

This method has a number of options, including the option to add a custom
creation date and metadata to the comment.

```ts
const comment = await liveblocks.createComment({
  roomId: "my-room-id",
  threadId: "th_d75sF3...",

  data: {
    // The comment's body, uses the `CommentBody` type
    body: {
      version: 1,
      content: [
        /* The comment's body text goes here, see above */
      ],
    },

    // The ID of the user that created the comment
    userId: "adrien@example.com",

    // Optional, the time the comment was created
    createdAt: new Date(),

    // Optional, custom comment metadata
    metadata: {
      tag: "important",
      reviewed: false,
    },
  },
});
```

#### Liveblocks.getComment [#get-rooms-roomId-threads-threadId-comments-commentId]

Returns a comment. Throws an error if the room, thread, or comment isnâ€™t found.
This is a wrapper around the
[Get Comment API](/docs/api-reference/rest-api-endpoints#get-rooms-roomId-threads-threadId-comments-commentId)
and returns the same response.

```ts
const comment = await liveblocks.getComment({
  roomId: "my-room-id",
  threadId: "th_d75sF3...",
  commentId: "cm_agH76a...",
});

// { type: "comment", threadId: "th_d75sF3...", ... }
console.log(comment);
```

#### Liveblocks.editComment [#post-rooms-roomId-threads-threadId-comments-commentId]

Edits an existing comment in a specific thread within a room. This method allows
users to update the content of their previously posted comments, with the option
to specify the time of the edit. Throws an error if the comment isnâ€™t found.
This is a wrapper around the
[Edit Comment API](/docs/api-reference/rest-api-endpoints#post-rooms-roomId-threads-threadId-comments-commentId)
and returns the updated comment.

```ts
const editedComment = await liveblocks.editComment({
  roomId: "my-room-id",
  threadId: "th_d75sF3...",
  commentId: "cm_agH76a...",

  data: {
    userId: "alicia@example.com",
    body: {
      version: 1,
      content: [
        /* The comment's body text goes here, see below */
      ],
    },

    // Optional, the time the comment was edited
    editedAt: new Date(),

    // Optional, custom comment metadata
    metadata: {
      tag: "important",
      spam: false,
    },
  },
});

// { type: "comment", threadId: "th_d75sF3...", ... }
console.log(editedComment);
```

A commentâ€™s body is an array of paragraphs, each containing child nodes. Hereâ€™s
an example of how to construct a commentâ€™s body, which can be submitted under
`data.body`.

```tsx
import { CommentBody } from "@liveblocks/node";

// +++
const body: CommentBody = {
  version: 1,
  content: [
    {
      type: "paragraph",
      children: [{ text: "Hello " }, { text: "world", bold: true }],
    },
  ],
};
// +++

const editedComment = await liveblocks.editComment({
  roomId: "my-room-id",
  threadId: "th_d75sF3...",
  commentId: "cm_agH76a...",

  data: {
    // The comment's body, uses the `CommentBody` type
    // +++
    body,
    // +++

    // ...
  },
});
```

#### Liveblocks.deleteComment [#delete-rooms-roomId-threads-threadId-comments-commentId]

Deletes a specific comment from a thread within a room. If there are no
remaining comments in the thread, the thread is also deleted. This method throws
an error if the comment isnâ€™t found. This is a wrapper around the
[Delete Comment API](/docs/api-reference/rest-api-endpoints#post-rooms-roomId-threads-threadId-comments-commentId)
and returns no response.

```ts
await liveblocks.deleteComment({
  roomId: "my-room-id",
  threadId: "th_d75sF3...",
  commentId: "cm_agH76a...",
});
```

#### Liveblocks.addCommentReaction [#post-rooms-roomId-threads-threadId-comments-commentId-add-reaction]

Adds a reaction to a specific comment in a thread within a room. Throws an error
if the comment isnâ€™t found or if the user has already added the same reaction on
the comment. This is a wrapper around the
[Add Comment Reaction API](/docs/api-reference/rest-api-endpoints#post-rooms-roomId-threads-threadId-comments-commentId-add-reaction)
and returns the new reaction.

```ts
const reaction = await liveblocks.addCommentReaction({
  roomId: "my-room-id",
  threadId: "th_d75sF3...",
  commentId: "cm_agH76a...",

  data: {
    emoji: "ðŸ‘¨â€ðŸ‘©â€ðŸ‘§",
    userId: "guillaume@example.com",
    createdAt: new Date(), // Optional, the time the reaction was added
  },
});

// { emoji: "ðŸ‘¨â€ðŸ‘©â€ðŸ‘§", userId "guillaume@example.com", ... }
console.log(reaction);
```

#### Liveblocks.removeCommentReaction [#post-rooms-roomId-threads-threadId-comments-commentId-remove-reaction]

Removes a reaction from a specific comment in a thread within a room. Throws an
error if the comment reaction isnâ€™t found. This is a wrapper around the
[Remove Comment Reaction API](/docs/api-reference/rest-api-endpoints#post-rooms-roomId-threads-threadId-comments-commentId-remove-reaction)
and returns no response.

```ts
await liveblocks.removeCommentReaction({
  roomId: "my-room-id",
  threadId: "th_d75sF3...",
  commentId: "cm_agH76a...",

  data: {
    emoji: "ðŸ‘¨â€ðŸ‘©â€ðŸ‘§",
    userId: "steven@example.com",
    removedAt: new Date(), // Optional, the time the reaction is to be removed
  },
});
```

#### Liveblocks.getRoomSubscriptionSettings [#get-rooms-roomId-users-userId-subscription-settings]

Returns a userâ€™s subscription settings for a specific room, specifying which
`thread` and `textMention` inbox notifications they are set to receive. This is
a wrapper around the
[Get Room Subscription Settings API](/docs/api-reference/rest-api-endpoints#get-rooms-roomId-users-userId-subscription-settings).

```ts
const subscriptionSettings = await liveblocks.getRoomSubscriptionSettings({
  roomId: "my-room-id",
  userId: "steven@example.com",
});

// { threads: "all", textMentions: "mine" }
console.log(subscriptionSettings);
```

For `"threads"`, these are the three possible values:

- `"all"` Receive notifications for every activity in every thread.
- `"replies_and_mentions"` Receive notifications for mentions and threads youâ€™re
  participating in.
- `"none"` No notifications are received.

For `"textMentions"`, these are the two possible values:

- `"mine"` Receive notifications for mentions of you.
- `"none"` No notifications are received.

#### Liveblocks.updateRoomSubscriptionSettings [#post-rooms-roomId-users-userId-subscription-settings]

Updates a userâ€™s subscription settings for a specific room, defining which
`thread` and `textMention` inbox notifications they will receive. This is a
wrapper around the
[Update Room Subscription Settings API](/docs/api-reference/rest-api-endpoints#post-rooms-roomId-users-userId-subscription-settings).

```ts
const updatedSubscriptionSettings =
  await liveblocks.updateRoomSubscriptionSettings({
    roomId: "my-room-id",
    userId: "steven@example.com",
    data: {
      threads: "replies_and_mentions",
      textMentions: "mine",
    },
  });

// { threads: "replies_and_mentions", ... }
console.log(updatedSubscriptionSettings);
```

For `"threads"`, these are the three possible values that can be set:

- `"all"` Receive notifications for every activity in every thread.
- `"replies_and_mentions"` Receive notifications for mentions and threads youâ€™re
  participating in.
- `"none"` No notifications are received.

For `"textMentions"`, these are the two possible values that can be set:

- `"mine"` Receive notifications for mentions of you.
- `"none"` No notifications are received.

##### Replacing individual thread subscriptions

Subscribing will replace any
[existing thread subscriptions](#post-rooms-roomId-users-userId-subscription-settings)
in the current room. This value can also be overridden by a room-level call that
is run afterwards.

```ts
const roomId = "my-room-id";
const userId = "steven@example.com";

// 1. Enables notifications just for this thread, "th_d75sF3..."
await liveblocks.subscribeToThread({
  roomId,
  threadId: "th_d75sF3...",
  data: { userId },
});

// 2. Disables notifications for all threads, including "th_d75sF3..."
await liveblocks.updateRoomSubscriptionSettings({
  roomId,
  userId,
  data: {
    threads: "none",
  },
});
```

#### Liveblocks.deleteRoomSubscriptionSettings [#delete-rooms-roomId-users-userId-subscription-settings]

Deletes a userâ€™s subscription settings for a specific room. This is a wrapper
around the
[Delete Room Subscription Settings API](/docs/api-reference/rest-api-endpoints#delete-rooms-roomId-users-userId-subscription-settings).

```ts
await liveblocks.deleteRoomSubscriptionSettings({
  roomId: "my-room-id",
  userId: "steven@example.com",
});
```

#### Liveblocks.getUserRoomSubscriptionSettings [#get-users-userId-room-subscription-settings]

Returns a list of a userâ€™s subscription settings for all rooms. This is a
wrapper around the
[Get User Room Subscription Settings API](/docs/api-reference/rest-api-endpoints#get-users-userId-room-subscription-settings).

```ts
const { data: subscriptionSettings, nextCursor } =
  await liveblocks.getUserRoomSubscriptionSettings({
    userId: "steven@example.com",

    // Optional, filter for a specific tenant
    tenantId: "acme-corp",
  });

console.log(subscriptionSettings);

// { roomId: "my-room-id", threads: "all", ... }

// Pagination
if (nextCursor) {
  const { data: nextPage } = await liveblocks.getUserRoomSubscriptionSettings({
    userId: "steven@example.com",
    startingAfter: nextCursor,
  });
}
```

### Notifications

#### Liveblocks.getInboxNotifications [#get-users-userId-inboxNotifications]

Returns a list of a userâ€™s inbox notifications. This is a wrapper around the
[Get Inbox Notifications API](/docs/api-reference/rest-api-endpoints#get-users-userId-inboxNotifications).
It also provides an unread query parameter to filter unread notifications.

```ts
const { data: inboxNotifications, nextCursor } =
  await liveblocks.getInboxNotifications({ userId: "steven@example.com" });

// [{ id: "in_3dH7sF3...", kind: "thread", ... }, { id: "in_3dH7sF3...", kind: "textMention", ... }, ...]
console.log(inboxNotifications);

// Filter unread notifications
const { data: unreadInboxNotifications, nextCursor } =
  await liveblocks.getInboxNotifications({
    userId: "steven@example.com",
    query: { unread: true },

    // Optional, filter for a specific tenant
    tenantId: "acme-corp",
  });
```

##### Pagination

You can use `nextCursor` to paginate inbox notifications. In this example, when
`getNextPage` is called, the next page of inbox notifications is added to
`pages`.

```ts
import { InboxNotificationData } from "@liveblocks/node";

// An array of pages, each containing a list of retrieved inbox notifications
const pages: InboxNotificationData[][] = [];

// Holds the pagination cursor for the next set of inbox notifications
let startingAfter;

// Call to get the next page of inbox notifications
async function getNextPage() {
  const { data, nextCursor } = await liveblocks.getInboxNotifications({
    startingAfter,
  });
  pages.push(data);
  startingAfter = nextCursor;
}
```

If youâ€™d like to iterate over all your inbox notifications, itâ€™s most convenient
to use
[`liveblocks.iterInboxNotifications`](#iter-users-userId-inboxNotifications)
instead. This method automatically paginates your API requests.

#### Liveblocks.iterInboxNotifications [#iter-users-userId-inboxNotifications]

Returns a list of inbox notifications for the given user. Works similarly to
[`liveblocks.getInboxNotifications`](#get-users-userId-inboxNotifications), but
instead returns an asynchronous iterator, which helps you iterate over all the
inbox notifications, without having to manually paginate through the results.

```ts
const userId = "steven@example.com";

for await (const item of liveblocks.iterInboxNotifications({
  userId,
  // Optional, filter for a specific tenant
  tenantId: "acme-corp",
})) {
  console.log(item.id); // in_3dH7sF3...
  console.log(item.kind); // "thread", "textMention", ...
}
```

#### Liveblocks.getInboxNotification [#get-users-userId-inboxNotifications-inboxNotificationId]

Returns a userâ€™s inbox notification. This is a wrapper around the
[Get Inbox Notification API](/docs/api-reference/rest-api-endpoints#get-users-userId-inboxNotifications-inboxNotificationId).

```ts
const inboxNotification = await liveblocks.getInboxNotification({
  userId: "steven@example.com",
  inboxNotificationId: "in_3dH7sF3...",
});

// { id: "in_3dH7sF3...", kind: "thread", ... }
// or { id: "in_3dH7sF3...", kind: "textMention", ... }
// or { id: "in_3dH7sF3...", kind: "$yourKind", ... }
console.log(inboxNotification);
```

#### Liveblocks.triggerInboxNotification [#post-inbox-notifications-trigger]

Triggers a custom inbox notification. `kind` must start with a `$`, and
represents the type of notification. `activityData` is used to send custom data
with the notification, and properties can have `string`, `number`, or `boolean`
values. Notifications [can be batched](#Batching-custom-notifications). This is
a wrapper around the
[Trigger Inbox Notification API](/docs/api-reference/rest-api-endpoints#post-inbox-notifications-trigger).

```ts
await liveblocks.triggerInboxNotification({
  // The ID of the user that will receive the inbox notification
  userId: "steven@example.com",

  // The custom notification kind, must start with a $
  kind: "$fileUploaded",

  // Custom ID for this specific notification
  subjectId: "my-file",

  // Custom data related to the activity that you need to render the inbox notification
  activityData: {
    // Data can be a string, number, or boolean
    file: "https://example.com/my-file.zip",
    size: 256,
    success: true,
  },

  // Optional, define the room ID the notification was sent from
  roomId: "my-room-id",

  // Optional, trigger it for a specific tenant
  tenantId: "acme-corp",
});
```

##### Typing custom notifications

To type custom notifications, edit the `ActivitiesData` type in your config
file.

```ts file="liveblocks.config.ts" highlight="4-10"
declare global {
  interface Liveblocks {
    // Custom activities data for custom notification kinds
    ActivitiesData: {
      // Example, a custom $alert kind
      $alert: {
        title: string;
        message: string;
      };
    };

    // Other kinds
    // ...
  }
}
```

##### Batching custom notifications

You can configure a custom notification kind to have batching enabled. When itâ€™s
enabled, triggering an inbox notification activity for a specific `subjectId`,
will update the existing inbox notification instead of creating a new one.

To use this, you must first
[enable batching in the dashboard](/docs/ready-made-features/notifications/concepts#Notification-batching).
Next, trigger a notification with the same `subjectId` as an existing
notification, and the result will be added to the `activityData` array.

```ts
const options = {
  userId: "steven@example.com",
  kind: "$fileUploaded",
  subjectId: "my-file",
};

await liveblocks.triggerInboxNotification({
  ...options,

  // +++
  activityData: {
    status: "processing",
  },
  // +++
});

await liveblocks.triggerInboxNotification({
  ...options,

  // +++
  activityData: {
    status: "complete",
  },
  // +++
});

const { data: inboxNotifications } = await liveblocks.getInboxNotifications({
  userId: "steven@example.com",
});

// {
//   id: "in_3dH7sF3...",
//   kind: "$fileUploaded",
// +++
//   activities: [
//     { status: "processing" },
//     { status: "complete" },
//   ],
// +++
//   ...
// }
console.log(inboxNotifications[0]);
```

An inbox notification can have up to 50 activities, if you exceed this number, a
new inbox notification will be created.

#### Liveblocks.deleteInboxNotification [#delete-users-userId-inboxNotifications-inboxNotificationId]

Deletes a userâ€™s inbox notification. This is a wrapper around the
[Delete Inbox Notification API](/docs/api-reference/rest-api-endpoints#delete-users-userId-inboxNotifications-inboxNotificationId).

```ts
await liveblocks.deleteInboxNotification({
  userId: "steven@example.com",
  inboxNotificationId: "in_3dH7sF3...",
});
```

#### Liveblocks.deleteAllInboxNotifications [#delete-users-userId-inboxNotifications]

Deletes all the userâ€™s inbox notifications. This is a wrapper around the
[Delete Inbox Notifications API](/docs/api-reference/rest-api-endpoints#delete-users-userId-inboxNotifications).

```ts
await liveblocks.deleteAllInboxNotifications({
  userId: "steven@example.com",
  // Optional, delete for a specific tenant
  tenantId: "acme-corp",
});
```

#### Liveblocks.getNotificationSettings [#get-users-userId-notification-settings] [@badge=Beta]

Returns a userâ€™s notification settings in the current project, in other words
which [notification webhook events](/docs/platform/webhooks#NotificationEvent)
will be sent for the user. Notification settings are project-based, which means
that this returns the userâ€™s settings for every room. This a wrapper around the
[Get Notification Settings API](/docs/api-reference/rest-api-endpoints#get-users-userId-notification-settings).

```ts
const settings = await liveblocks.getNotificationSettings({
  userId: "guillaume@liveblocks.io",
});

// { email: { thread: true, ... }, slack: { thread: false, ... }, ... }
console.log(settings);
```

A userâ€™s initial settings are set in the dashboard, and different kinds should
be enabled there. If no kind is enabled on the current channel, `null` will be
returned. For example, with the email channel:

```ts
const settings = await liveblocks.getNotificationSettings({
  userId: "guillaume@liveblocks.io",
});

// { email: null, ... }
console.log(settings);
```

#### Liveblocks.updateNotificationSettings [#post-users-userId-notification-settings] [@badge=Beta]

Updates a userâ€™s notification settings, which affects which
[notification webhook events](/docs/platform/webhooks#NotificationEvent) will be
sent for the user. Notification settings are project-based, which means that
this modifies the userâ€™s settings in every room. Each notification `kind` must
first be enabled on your projectâ€™s notification dashboard page before settings
can be used. This a wrapper around the
[Update Notification Settings API](/docs/api-reference/rest-api-endpoints#post-users-userId-notification-settings).

```ts
const updatedSettings = await liveblocks.updateNotificationSettings({
  userId: "steven@example.com",
  data: {
    email: { thread: false },
    slack: { textMention: true },
  },
});

// { email: { thread: false, ... }, slack: { textMention: true, ... }, ... }
console.log(updatedSettings);
```

You can pass a partial object, or many settings at once.

```ts
// You only need to pass partials
await liveblocks.updateNotificationSettings({
  userId: "steven@example.com",
  email: { thread: true },
});

// Enabling a custom notification on the slack channel
await liveblocks.updateNotificationSettings({
  userId: "steven@example.com",
  slack: { $myCustomNotification: true },
});

// Setting complex settings
await liveblocks.updateNotificationSettings({
  userId: "steven@example.com",
  email: {
    thread: true,
    textMention: false,
    $newDocument: true,
  },
  slack: {
    thread: false,
    $fileUpload: false,
  },
  teams: {
    thread: true,
  },
});
```

#### Liveblocks.deleteNotificationSettings [#delete-users-userId-notification-settings] [@badge=Beta]

Deletes the userâ€™s notification settings, resetting them to the default values.
The default values can be adjusted in a projectâ€™s notification dashboard page.
This a wrapper around the
[Delete Notification Settings API](/docs/api-reference/rest-api-endpoints#delete-users-userId-notification-settings).

```ts
await liveblocks.deleteNotificationSettings({
  userId: "adri@example.com",
});
```

### AI Copilots

#### Liveblocks.getAiCopilots [#get-ai-copilots]

Returns a paginated list of AI copilots. The copilots are returned sorted by
creation date, from newest to oldest. This is a wrapper around the
[Get AI Copilots API](/docs/api-reference/rest-api-endpoints#get-ai-copilots)
and returns the same response.

```ts
const { data: copilots, nextCursor } = await liveblocks.getAiCopilots();

// A list of AI copilots
// [{ type: "copilot", id: "co_abc123...", name: "My Copilot", ... }, ...]
console.log(copilots);

// A pagination cursor used for retrieving the next page of results with `startingAfter`
// "L3YyL3Jvb21z..."
console.log(nextCursor);
```

Pagination options are available to control the number of results returned.

```ts
const { data: copilots, nextCursor } = await liveblocks.getAiCopilots({
  // Optional, the amount of copilots to load, between 1 and 100, defaults to 20
  limit: 20,

  // Optional, cursor used for pagination, use `nextCursor` from the previous page's response
  startingAfter: "L3YyL3Jvb21z...",
});
```

#### Liveblocks.createAiCopilot [#create-ai-copilot]

Creates a new AI copilot with the given configuration. This is a wrapper around
the
[Create AI Copilot API](/docs/api-reference/rest-api-endpoints#create-ai-copilot)
and returns the same response.

```ts
const copilot = await liveblocks.createAiCopilot({
  name: "My AI Assistant",
  systemPrompt: "You are a helpful AI assistant for our team.",
  provider: "openai",
  providerModel: "gpt-4",
  providerApiKey: "sk-...", // Your OpenAI API key
});

// { type: "copilot", id: "co_abc123...", name: "My AI Assistant", ... }
console.log(copilot);
```

The method supports various configuration options for different AI providers.

```ts
const copilot = await liveblocks.createAiCopilot({
  // Required, the name of the copilot
  name: "Documentation Helper",

  // Optional, a description of what the copilot does
  description: "Helps users understand our documentation",

  // Required, the system prompt that defines the copilot's behavior
  systemPrompt:
    "You are an expert at helping users understand technical documentation.",

  // Optional, additional knowledge context for the copilot
  knowledgePrompt: "Use our company's style guide when providing examples.",

  // Required, the AI provider to use
  provider: "openai",

  // Required for standard providers, the model to use
  providerModel: "gpt-4-turbo",

  // Required, your API key for the provider
  providerApiKey: "sk-...",

  // Optional, provider-specific options
  providerOptions: {
    openai: {
      reasoningEffort: "low",
      // Optional, restrict web search to specific domains for OpenAI
      webSearch: {
        allowedDomains: ["docs.liveblocks.io", "example.com"],
      },
    },
  },

  // Optional, model settings
  settings: {
    maxTokens: 1000,
    temperature: 0.7,
    topP: 0.9,
    frequencyPenalty: 0.1,
    presencePenalty: 0.1,
    stopSequences: ["END"],
    seed: 42,
    maxRetries: 3,
  },
});
```

For OpenAI-compatible providers, use a different configuration:

```ts
const copilot = await liveblocks.createAiCopilot({
  name: "Custom AI Helper",
  systemPrompt: "You are a helpful assistant.",
  provider: "openai-compatible",
  compatibleProviderName: "my-custom-provider",
  providerBaseUrl: "https://api.mycustomprovider.com/v1",
  providerApiKey: "your-api-key-here", // Your API key for the custom provider
  providerModel: "custom-provider-model",
});
```

You can also configure Anthropic or Google providers with provider-specific
options:

```ts
// Anthropic example
await liveblocks.createAiCopilot({
  name: "Anthropic Helper",
  systemPrompt: "You are a helpful assistant.",
  provider: "anthropic",
  providerModel: "claude-3-5-sonnet-latest",
  providerApiKey: "sk-...",
  providerOptions: {
    anthropic: {
      thinking: { type: "disabled" },
      webSearch: {
        allowedDomains: ["example.com"],
      },
    },
  },
});

// Google example
await liveblocks.createAiCopilot({
  name: "Gemini Helper",
  systemPrompt: "You are a helpful assistant.",
  provider: "google",
  providerModel: "gemini-2.5-pro",
  providerApiKey: "sk-...",
  providerOptions: {
    google: {
      thinkingConfig: { thinkingBudget: 2000 },
    },
  },
});
```

#### Liveblocks.getAiCopilot [#get-ai-copilot]

Returns an AI copilot by its ID. Throws an error if the copilot isnâ€™t found.
This is a wrapper around the
[Get AI Copilot API](/docs/api-reference/rest-api-endpoints#get-ai-copilot) and
returns the same response.

```ts
const copilot = await liveblocks.getAiCopilot("co_abc123...");

// { type: "copilot", id: "co_abc123...", name: "My AI Assistant", ... }
console.log(copilot);
```

#### Liveblocks.updateAiCopilot [#update-ai-copilot]

Updates an existing AI copilotâ€™s configuration. You only need to pass the
properties you want to update. Throws an error if the copilot isnâ€™t found. This
is a wrapper around the
[Update AI Copilot API](/docs/api-reference/rest-api-endpoints#update-ai-copilot)
and returns the same response.

```ts
const updatedCopilot = await liveblocks.updateAiCopilot("co_abc123...", {
  name: "Updated AI Assistant",
  description: "Now with improved capabilities",
});

// { type: "copilot", id: "co_abc123...", name: "Updated AI Assistant", ... }
console.log(updatedCopilot);
```

You can update various aspects of the copilot:

```ts
const updatedCopilot = await liveblocks.updateAiCopilot("co_abc123...", {
  // Optional, update the name
  name: "Better AI Helper",

  // Optional, update the description
  description: "Enhanced with new features",

  // Optional, update the system prompt
  systemPrompt: "You are an even more helpful AI assistant.",

  // Optional, update the knowledge prompt
  knowledgePrompt: "Reference our latest guidelines.",

  // Optional, update provider-specific options (replaces the entire nested options object)
  // Set to null to clear options
  providerOptions: null,

  // Optional, update model settings
  settings: {
    temperature: 0.5,
    maxTokens: 1500,
  },
});
```

You can also update provider options. When updating `providerOptions`, it fully
replaces the previous nested options (no deep merge):

```ts
// Update OpenAI provider options (replaces prior options)
await liveblocks.updateAiCopilot("co_abc123...", {
  provider: "openai",
  providerOptions: {
    openai: {
      reasoningEffort: "medium",
      webSearch: { allowedDomains: ["docs.liveblocks.io"] },
    },
  },
});

// Update Anthropic thinking/web search settings
await liveblocks.updateAiCopilot("co_abc123...", {
  provider: "anthropic",
  providerOptions: {
    anthropic: {
      thinking: { type: "enabled", budgetTokens: 2000 },
      webSearch: { maxUses: 2 },
    },
  },
});
```

Certain properties can be set to `null` to clear them from the copilotâ€™s
configuration. This includes `description`, `knowledgePrompt`, `settings`, and
`providerOptions`.

```ts
const updatedCopilot = await liveblocks.updateAiCopilot("co_abc123...", {
  // Clear the description
  description: null,

  // Clear the knowledge prompt
  knowledgePrompt: null,

  // Clear all model settings
  settings: null,
});
```

The method returns a 422 response if the update doesnâ€™t apply due to validation
failures. For example, if the existing copilot uses the "openai" provider and
you attempt to update the provider model to an incompatible value for the
provider, like "gemini-2.5-pro", youâ€™ll receive a 422 response with an error
message explaining where the validation failed.

#### Liveblocks.deleteAiCopilot [#delete-ai-copilot]

Deletes an AI copilot by its ID. A deleted copilot is no longer accessible and
cannot be restored. Throws an error if the copilot isnâ€™t found. This is a
wrapper around the
[Delete AI Copilot API](/docs/api-reference/rest-api-endpoints#delete-ai-copilot)
and returns no response.

```ts
await liveblocks.deleteAiCopilot("co_abc123...");
```

### Knowledge Sources

#### Liveblocks.createWebKnowledgeSource [#create-web-knowledge-source]

Creates a web knowledge source for an AI copilot. This allows the copilot to
access and learn from web content. This is a wrapper around the
[Create Web Knowledge Source API](/docs/api-reference/rest-api-endpoints#create-web-knowledge-source)
and returns the ID of the created knowledge source.

```ts
const { id } = await liveblocks.createWebKnowledgeSource({
  copilotId: "co_abc123...",
  url: "https://example.com/documentation",
  type: "individual_link",
});

// "ks_def456..."
console.log(id);
```

Different types of web knowledge sources are supported:

```ts
// Index a single web page
const singlePage = await liveblocks.createWebKnowledgeSource({
  copilotId: "co_abc123...",
  url: "https://example.com/important-page",
  type: "individual_link",
});

// Crawl an entire website
const crawledSite = await liveblocks.createWebKnowledgeSource({
  copilotId: "co_abc123...",
  url: "https://example.com",
  type: "crawl",
});

// Use a sitemap to index multiple pages
const sitemapSource = await liveblocks.createWebKnowledgeSource({
  copilotId: "co_abc123...",
  url: "https://example.com/sitemap.xml",
  type: "sitemap",
});
```

#### Liveblocks.createFileKnowledgeSource [#create-file-knowledge-source]

Creates a file knowledge source for an AI copilot by uploading a file. The
copilot can then reference the content of the file when responding. This is a
wrapper around the
[Create File Knowledge Source API](/docs/api-reference/rest-api-endpoints#create-file-knowledge-source)
and returns the ID of the created knowledge source.

**Note:** Currently only PDF files (`application/pdf`) and images (`image/*`)
are supported.

```ts
const { id } = await liveblocks.createFileKnowledgeSource({
  copilotId: "co_abc123...",
  file: pdfFile, // Must be a PDF or image file
});

// "ks_ghi789..."
console.log(id);
```

#### Liveblocks.getKnowledgeSources [#get-knowledge-sources]

Returns a paginated list of knowledge sources for a specific AI copilot. This is
a wrapper around the
[Get Knowledge Sources API](/docs/api-reference/rest-api-endpoints#get-knowledge-sources)
and returns the same response.

```ts
const { data: sources, nextCursor } = await liveblocks.getKnowledgeSources({
  copilotId: "co_abc123...",
});

// [{ type: "ai-knowledge-web-source", id: "ks_abc123...", ... }, ...]
console.log(sources);
```

Pagination options are available:

```ts
const { data: sources, nextCursor } = await liveblocks.getKnowledgeSources({
  copilotId: "co_abc123...",
  // Optional, the amount of knowledge sources to load, between 1 and 100, defaults to 20
  limit: 20,
  // Optional, cursor used for pagination
  startingAfter: "L3YyL3Jvb21z...",
});
```

#### Liveblocks.getKnowledgeSource [#get-knowledge-source]

Returns a specific knowledge source by its ID. Throws an error if the knowledge
source isnâ€™t found. This is a wrapper around the
[Get Knowledge Source API](/docs/api-reference/rest-api-endpoints#get-knowledge-source)
and returns the same response.

```ts
const source = await liveblocks.getKnowledgeSource({
  copilotId: "co_abc123...",
  knowledgeSourceId: "ks_def456...",
});

// { type: "ai-knowledge-web-source", id: "ks_def456...", ... }
// or { type: "ai-knowledge-file-source", id: "ks_def456...", ... }
console.log(source);
```

#### Liveblocks.getFileKnowledgeSourceMarkdown [#get-file-knowledge-source-markdown]

Returns the content of a file knowledge source as Markdown. This allows you to
see what content the AI copilot has access to from uploaded files. Throws an
error if the knowledge source isnâ€™t found. This is a wrapper around the
[Get File Knowledge Source Content API](/docs/api-reference/rest-api-endpoints#get-file-knowledge-source-content)
and returns the content as a string.

```ts
const content = await liveblocks.getFileKnowledgeSourceMarkdown({
  copilotId: "co_abc123...",
  knowledgeSourceId: "ks_def456...",
});

// "# Document Title\n\nThis is the content of the uploaded file..."
console.log(content);
```

#### Liveblocks.getWebKnowledgeSourceLinks [#get-web-knowledge-source-links]

Returns a paginated list of links that were indexed from a web knowledge source.
This is useful for understanding what content the AI copilot has access to from
web sources. This is a wrapper around the
[Get Web Knowledge Source Links API](/docs/api-reference/rest-api-endpoints#get-web-knowledge-source-links)
and returns the same response.

```ts
const { data: links, nextCursor } = await liveblocks.getWebKnowledgeSourceLinks(
  {
    copilotId: "co_abc123...",
    knowledgeSourceId: "ks_def456...",
  }
);

// [{ id: "link_123...", url: "https://example.com/page1", status: "ready", ... }, ...]
console.log(links);
```

Pagination options are available:

```ts
const { data: links, nextCursor } = await liveblocks.getWebKnowledgeSourceLinks(
  {
    copilotId: "co_abc123...",
    knowledgeSourceId: "ks_def456...",
    // Optional, the amount of links to load, between 1 and 100, defaults to 20
    limit: 20,
    // Optional, cursor used for pagination
    startingAfter: "L3YyL3Jvb21z...",
  }
);
```

#### Liveblocks.deleteWebKnowledgeSource [#delete-web-knowledge-source]

Deletes a web knowledge source from an AI copilot. The copilot will no longer
have access to the content from this source. Throws an error if the knowledge
source isnâ€™t found. This is a wrapper around the
[Delete Web Knowledge Source API](/docs/api-reference/rest-api-endpoints#delete-web-knowledge-source)
and returns no response.

```ts
await liveblocks.deleteWebKnowledgeSource({
  copilotId: "co_abc123...",
  knowledgeSourceId: "ks_def456...",
});
```

#### Liveblocks.deleteFileKnowledgeSource [#delete-file-knowledge-source]

Deletes a file knowledge source from an AI copilot. The copilot will no longer
have access to the content from this file. Throws an error if the knowledge
source isnâ€™t found. This is a wrapper around the
[Delete File Knowledge Source API](/docs/api-reference/rest-api-endpoints#delete-file-knowledge-source)
and returns no response.

```ts
await liveblocks.deleteFileKnowledgeSource({
  copilotId: "co_abc123...",
  knowledgeSourceId: "ks_def456...",
});
```

### Error handling [#error-handling]

Errors in our API methods, such as network failures, invalid arguments, or
server-side issues, are reported through the `LiveblocksError` class. This
custom error class extends the standard JavaScript
[`Error`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error)
and includes a `status` property, which provides the HTTP status code for the
error, such as 404 for not found or 500 for server errors.

Example of handling errors in a typical API call:

```ts
try {
  const room = await liveblocks.getRoom("my-room-id");
  // Process room
} catch (error) {
  if (error instanceof LiveblocksError) {
    // Handle specific LiveblocksError cases
    console.error(`Error fetching room: ${error.status} - ${error.message}`);
    switch (
      error.status
      // Specific cases based on status codes
    ) {
    }
  } else {
    // Handle general errors
    console.error(`Unexpected error: ${error.message}`);
  }
}
```

## Utilities

### getMentionsFromCommentBody [#get-mentions-from-comment-body]

Returns an array of mentions from a `CommentBody` (found under `comment.body`).

```ts
import { getMentionsFromCommentBody } from "@liveblocks/node";

const mentions = getMentionsFromCommentBody(comment.body);
```

An optional second argument can be used to filter the returned mentions. By
default, if itâ€™s not provided, all mentions are returned, including future
mention kinds (e.g. group mentions in the future).

```tsx
// All mentions (same as `getMentionsFromCommentBody(commentBody)`)
getMentionsFromCommentBody(commentBody);

// Only user mentions with an ID of "123"
getMentionsFromCommentBody(
  commentBody,
  (mention) => mention.kind === "user" && mention.id === "123"
);

// Only mentions with an ID which starts with "prefix:"
getMentionsFromCommentBody(commentBody, (mention) => (
  mention.id.startsWith("prefix:")
);
```

This is most commonly used in combination with the
[Comments API functions](/docs/api-reference/liveblocks-node#Comments), for
example [`getComment`](/docs/api-reference/liveblocks-node#get-comment).

```ts
import { Liveblocks, getMentionsFromCommentBody } from "@liveblocks/node";

// Create a node client
const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

// Retrieve a comment
const comment = await liveblocks.getComment({
  roomId: "my-room-id",
  threadId: "my-thread-id",
  commentId: "my-comment-id",
});

// Get the mentions inside the comment's body
const mentions = getMentionsFromCommentBody(comment.body);

// [{ kind: "user", id: "marc@example.com" }, { kind: "user", id: "vincent@example.com" }, ...]
console.log(mentions);
```

Hereâ€™s an example with a custom `CommentBody`.

```ts
import { CommentBody, getMentionsFromCommentBody } from "@liveblocks/node";

// Create a custom `CommentBody`
const commentBody: CommentBody = {
  version: 1,
  content: [
    {
      type: "paragraph",
      children: [
        { text: "Hello " },
        { type: "mention", id: "chris@example.com" },
      ],
    },
  ],
};

// Get the mentions inside the comment's body
const mentions = getMentionsFromCommentBody(commentBody);

// [{ kind: "user", id: "chris@example.com" }]
console.log(mentions);
```

<Banner title="Also available from @liveblocks/client">

If youâ€™d like to use this on the client side, itâ€™s also available from
[`@liveblocks/client`](/docs/api-reference/liveblocks-client#get-mentions-from-comment-body).

</Banner>

### stringifyCommentBody [#stringify-comment-body]

Used to convert a `CommentBody` (found under `comment.body`) into either a plain
string, Markdown, HTML, or a custom format.

```ts
import { stringifyCommentBody } from "@liveblocks/node";

const stringComment = await stringifyCommentBody(comment.body);
```

This is most commonly used in combination with the
[Comments API functions](/docs/api-reference/liveblocks-node#Comments), for
example [`getComment`](/docs/api-reference/liveblocks-node#get-comment).

```ts
import { Liveblocks, stringifyCommentBody } from "@liveblocks/node";

// Create a node client
const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

// Retrieve a comment
const comment = await liveblocks.getComment({
  roomId: "my-room-id",
  threadId: "my-thread-id",
  commentId: "my-comment-id",
});

// Convert CommentBody to plain string
const stringComment = await stringifyCommentBody(comment.body);

// "Hello marc@example.com from https://liveblocks.io"
console.log(stringComment);
```

A number of options are also available.

```ts
import { stringifyCommentBody } from "@liveblocks/client";

const stringComment = await stringifyCommentBody(comment.body, {
  // Optional, convert to specific format, "plain" (default) | "markdown" | "html"
  format: "markdown",

  // Optional, supply a separator to be used between paragraphs
  separator: `\n\n`,

  // Optional, override any elements in the CommentBody with a custom string
  elements: {
    // Optional, override the `paragraph` element
    paragraph: ({ element, children }) => `<p>${children}</p>`,

    // Optional, override the `text` element
    text: ({ element }) =>
      element.bold ? `<strong>${element.text}</strong>` : `${element.text}`,

    // Optional, override the `link` element
    link: ({ element, href }) =>
      `<a href="${href}" target="_blank">${element.url}</a>`,

    // Optional, override the `mention` element.
    // `user` and `group` are the optional data returned from `resolveUsers` and `resolveGroupsInfo`
    mention: ({ element, user, group }) =>
      `<a href="${user?.profileUrl ?? group?.settingsUrl ?? "#"}">${element.id}</a>`,
  },

  // Optional, get your userâ€™s names and info from their ID to be displayed in mentions
  async resolveUsers({ userIds }) {
    const usersData = await __getUsersFromDB__(userIds);

    return usersData.map((userData) => ({
      // Name is inserted into the output instead of a userâ€™s ID
      name: userData.name,

      // Custom formatting in `elements.mention` allows custom properties to be used
      profileUrl: userData.profileUrl,
    }));
  },

  // Optional, get your groupâ€™s names and info from their ID to be displayed in mentions
  async resolveGroupsInfo({ groupIds }) {
    const groupsData = await __getGroupsFromDB__(groupIds);

    return groupsData.map((groupData) => ({
      // Name is inserted into the output instead of a groupâ€™s ID
      name: groupData.name,

      // Custom formatting in `elements.mention` allows custom properties to be used
      settingsUrl: groupData.settingsUrl,
    }));
  },
});
```

<Banner title="Also available from @liveblocks/client">

If youâ€™d like to use this on the client side, itâ€™s also available from
[`@liveblocks/client`](/docs/api-reference/liveblocks-client#stringify-comment-body).

</Banner>

#### Formatting examples

Here are a number of different formatting examples derived from the same
`CommentBody`.

```ts
// "Hello marc@example.com from https://liveblocks.io"
await stringifyCommentBody(comment.body);

// "Hello @Marc from https://liveblocks.io"
await stringifyCommentBody(comment.body, {
  resolveUsers({ userIds }) {
    return [{ name: "Marc" }];
  },
});

// "**Hello** @Marc from [https://liveblocks.io](https://liveblocks.io)"
await stringifyCommentBody(comment.body, {
  format: "markdown",

  resolveUsers() {
    return [{ name: "Marc" }];
  },
});

// "<b>Hello</b> <span data-mention>@Marc</span> from
// <a href="https://liveblocks.io">https://liveblocks.io</a>"
await stringifyCommentBody(comment.body, {
  format: "html",

  resolveUsers() {
    return [{ name: "Marc" }];
  },
});

// "<b>Hello</b> <a href="https://example.com" data-id="marc@example.com">@Marc</a> from
// <a href="https://liveblocks.io">https://liveblocks.io</a>"
await stringifyCommentBody(comment.body, {
  format: "html",

  mention: ({ element, user }) =>
    `<a href="${user.profileUrl}" data-id="${element.id}">${user.name}</a>`,

  resolveUsers() {
    return [{ name: "Marc", profileUrl: "https://example.com" }];
  },
});
```

### WebhookHandler [#WebhookHandler]

<Banner title="Need help implementing webhooks?">

Read the [Webhooks guide](/docs/platform/webhooks) to learn how to use them
within your product, allowing you to react to Liveblocks events as they happen.

</Banner>

The `WebhookHandler` class is a helper to handle webhook requests from
Liveblocks.

Itâ€™s initialized with a signing secret that you can find in your projectâ€™s
webhook page.

```js
const webhookHandler = new WebhookHandler(process.env.WEBHOOK_SECRET);
```

#### verifyRequest [#verifyRequest]

Verifies the request and returns the event. Note that `rawBody` takes the body
as a `string`.

```js
const event = webhookHandler.verifyRequest({
  headers: req.headers,
  rawBody: req.body,
});
```

Some frameworks parse request bodies into objects, which means using
`JSON.stringify` may be necessary.

```js highlight="3"
const event = webhookHandler.verifyRequest({
  headers: req.headers,
  rawBody: JSON.stringify(req.body),
});
```

##### Example using Next.js [#webhook-example]

```js
import { WebhookHandler } from "@liveblocks/node";

// Will fail if not properly initialized with a secret
// Obtained from the Webhooks section of your project dashboard
// https://liveblocks.io/dashboard
const webhookHandler = new WebhookHandler(process.env.WEBHOOK_SECRET);

export function POST(request) {
  try {
    const event = webhookHandler.verifyRequest({
      headers: req.headers,
      rawBody: JSON.stringify(req.body),
    });

    // Handle `WebhookEvent`

    if (event.type === "storageUpdated") {
      // Handle `StorageUpdatedEvent`
    } else if (event.type === "userEntered") {
      // Handle `UserEnteredEvent`
    } else if (event.type === "userLeft") {
      // Handle `UserLeftEvent`
    }
  } catch (error) {
    console.error(error);
    return new Response(error, { status: 400 });
  }
}
```

### isThreadNotificationEvent [#isThreadNotificationEvent]

Type guard to check if a received webhook event is a
[`ThreadNotificationEvent`](/docs/platform/webhooks#Thread-notification) send
from Comments. Particularly helpful when creating
[thread notification emails](/docs/api-reference/liveblocks-emails#thread-notification-emails)
with webhooks.

```js
import { isThreadNotificationEvent } from "@liveblocks/node";

const event = webhookHandler.verifyRequest({
  headers: req.headers,
  rawBody: req.body,
});

// +++
if (isThreadNotificationEvent(event)) {
  // Handle `ThreadNotificationEvent`
}
// +++
```

The check is made against the event type and event data kind.

### isTextMentionNotificationEvent [#isTextMentionNotificationEvent]

Type guard to check if a received webhook event is a
[`TextMentionNotificationEvent`](/docs/platform/webhooks#TextMention-notification)
sent from Text Editor. Particularly helpful for identifying text mentions when
sending email notifications.

```js
import { isTextMentionNotificationEvent } from "@liveblocks/node";

const event = webhookHandler.verifyRequest({
  headers: req.headers,
  rawBody: req.body,
});

// +++
if (isTextMentionNotificationEvent(event)) {
  // Handle `TextMentionNotificationEvent`
}
// +++
```

### isCustomNotificationEvent [#isCustomNotificationEvent]

Type guard to check if a received webhook event is a
[`CustomNotificationEvent`](/docs/platform/webhooks#Custom-notification) sent
from
[`triggerInboxNotification`](/docs/api-reference/liveblocks-node#post-inbox-notifications-trigger).
Particularly helpful for identifying custom notifications when sending email
notifications.

```js
import { isCustomNotificationEvent } from "@liveblocks/node";

const event = webhookHandler.verifyRequest({
  headers: req.headers,
  rawBody: req.body,
});

// +++
if (isCustomNotificationEvent(event)) {
  // Handle `CustomNotificationEvent`
}
// +++
```

The check is made against the event type and event data kind.

[`room.getothers`]: /docs/api-reference/liveblocks-client#Room.getOthers
[Permissions REST API]: /docs/authentication/id-token

---
meta:
  title: "@liveblocks/react-blocknote"
  parentTitle: "API Reference"
  description: "API Reference for the @liveblocks/react-blocknote package"
alwaysShowAllNavigationLevels: false
---

`@liveblocks/react-blocknote` provides you with a [React](https://react.dev/)
plugin that adds collaboration to any
[BlockNote rich-text editor](https://www.blocknotejs.org/). It also adds
realtime cursors, document persistence on the cloud, comments, and mentions. Use
[`@liveblocks/node-prosemirror`](/docs/api-reference/liveblocks-node-prosemirror)
for server-side editing.

## Setup

To set up your collaborative BlockNote editor, create an editor with
[`useCreateBlockNoteWithLiveblocks`](#useCreateBlockNoteWithLiveblocks) and pass
it into the
[`BlockNoteView`](https://www.blocknotejs.org/docs/editor-basics/setup#rendering-the-editor-with-blocknoteview)
component provided by `@blocknote/mantine`.

```tsx
import { useCreateBlockNoteWithLiveblocks } from "@liveblocks/react-blocknote";
import { BlockNoteView } from "@blocknote/mantine";

function TextEditor() {
  // +++
  const editor = useCreateBlockNoteWithLiveblocks({});
  // +++

  return (
    <div>
      // +++
      <BlockNoteView editor={editor} />
      // +++
    </div>
  );
}
```

Liveblocks BlockNote components should be passed `editor` to enable them.

```tsx
import {
  useCreateBlockNoteWithLiveblocks,
  // +++
  FloatingComposer,
  // +++
} from "@liveblocks/react-blocknote";
import { BlockNoteView } from "@blocknote/mantine";

function TextEditor() {
  const editor = useCreateBlockNoteWithLiveblocks({});

  return (
    <div>
      <BlockNoteView editor={editor} />
      // +++
      <FloatingComposer editor={editor} style={{ width: "350px" }} />
      // +++
    </div>
  );
}
```

Learn more in our [get started guides](/docs/get-started/text-editor/blocknote).

## Default components

### FloatingComposer

Displays a [`Composer`][] near the current BlockNote selection, allowing you to
create threads.

```tsx highlight="3"
<FloatingComposer editor={editor} />
```

<Figure>
  <Image
    src="/assets/text-editor/floating-composer.jpg"
    alt="FloatingComposer"
    width={960}
    height={558}
  />
</Figure>

Submitting a comment will attach an annotation thread at the current selection.
Should be passed your BlockNote `editor`, and itâ€™s recommended you set a width
value. Display created threads with [`AnchoredThreads`][] or
[`FloatingThreads`][].

```tsx
import {
  // +++
  FloatingComposer,
  // +++
  FloatingThreads,
  useCreateBlockNoteWithLiveblocks,
} from "@liveblocks/react-blocknote";
import { BlockNoteView } from "@blocknote/mantine";

function TextEditor() {
  const editor = useCreateBlockNoteWithLiveblocks({});

  return (
    <div>
      <BlockNoteView editor={editor} />
      // +++
      <FloatingComposer editor={editor} style={{ width: "350px" }} />
      // +++
      <FloatingThreads editor={editor} style={{ width: "350px" }} />
    </div>
  );
}
```

#### Opening the composer

To open the `FloatingComposer`, you need to click the comment button in the
BlockNote toolbar, or call the `addPendingComment`
[command](https://tiptap.dev/docs/editor/api/commands) added by Liveblocks. You
can use `liveblocksCommentMark` to check if the current selection is a comment.

```tsx
import { BlockNoteEditor } from "@blocknote/core";

function Toolbar({ editor }: { editor: BlockNoteEditor | null }) {
  if (!editor) {
    return null;
  }

  return (
    <button
      onClick={() => {
        // +++
        (editor._tiptapEditor as any).chain().focus().addPendingComment().run();
        // +++
      }}
      // +++
      data-active={(editor._tiptapEditor as any).isActive(
        "liveblocksCommentMark"
      )}
      // +++
    >
      ðŸ’¬ New comment
    </button>
  );
}
```

#### Props [#FloatingComposer-props]

<PropertiesList>
  <PropertiesListItem name="metadata" type="ThreadMetadata">
    The metadata of the thread to create.
  </PropertiesListItem>
  <PropertiesListItem name="commentMetadata" type="CommentMetadata">
    The metadata of the comment to create.
  </PropertiesListItem>
  <PropertiesListItem
    name="onComposerSubmit"
    type="function"
    detailedType="(comment: ComposerSubmitComment, event: FormEvent<HTMLFormElement>) => Promise<void> | void"
  >
    The event handler called when the composer is submitted.
  </PropertiesListItem>
  <PropertiesListItem name="defaultValue" type="CommentBody">
    The composerâ€™s initial value.
  </PropertiesListItem>
  <PropertiesListItem name="collapsed" type="boolean">
    Whether the composer is collapsed. Setting a value will make the composer
    controlled.
  </PropertiesListItem>
  <PropertiesListItem
    name="onCollapsedChange"
    type="function"
    detailedType="(collapsed: boolean) => void"
  >
    The event handler called when the collapsed state of the composer changes.
  </PropertiesListItem>
  <PropertiesListItem name="defaultCollapsed" type="boolean">
    Whether the composer is initially collapsed. Setting a value will make the
    composer uncontrolled.
  </PropertiesListItem>
  <PropertiesListItem name="disabled" type="boolean">
    Whether the composer is disabled.
  </PropertiesListItem>
  <PropertiesListItem name="autoFocus" type="boolean">
    Whether to focus the composer on mount.
  </PropertiesListItem>
  <PropertiesListItem
    name="overrides"
    type="Partial<GlobalOverrides & ComposerOverrides>"
  >
    Override the componentâ€™s strings.
  </PropertiesListItem>
</PropertiesList>

### FloatingThreads

Displays floating [`Thread`][] components below text highlights in the editor.

```tsx highlight="3"
<FloatingThreads editor={editor} threads={threads} />
```

<Figure>
  <Image
    src="/assets/text-editor/floating-threads.jpg"
    alt="FloatingThreads"
    width={960}
    height={558}
  />
</Figure>

Takes a list of threads retrieved from [`useThreads`][] and renders them to the
page. Each thread is opened by clicking on its corresponding text highlight.
Should be passed your BlockNote `editor`, and itâ€™s recommended you set a width
value.

```tsx
// +++
import { useThreads } from "@liveblocks/react/suspense";
// +++
import {
  FloatingComposer,
  // +++
  FloatingThreads,
  // +++
  useCreateBlockNoteWithLiveblocks,
} from "@liveblocks/react-blocknote";
import { BlockNoteView } from "@blocknote/mantine";

function TextEditor() {
  const editor = useCreateBlockNoteWithLiveblocks({});

  // +++
  const { threads } = useThreads();
  // +++

  return (
    <div>
      <BlockNoteView editor={editor} />
      <FloatingComposer editor={editor} style={{ width: "350px" }} />
      // +++
      <FloatingThreads
        editor={editor}
        threads={threads}
        style={{ width: "350px" }}
      />
      // +++
    </div>
  );
}
```

<Banner title="Resolved threads">

The `FloatingThreads` component automatically excludes resolved threads from
display. Any resolved threads passed in the threads list will not be shown.

</Banner>

#### Recommended usage [#FloatingThreads-recommended-usage]

[`FloatingThreads`][] and [`AnchoredThreads`][] have been designed to work
together to provide the optimal experience on mobile and desktop. We generally
recommend using both components, hiding one on smaller screens, as we are below
with Tailwind classes. Most apps also donâ€™t need to display resolved threads, so
we can filter those out with a [`useThreads`][] option.

```tsx
import { useThreads } from "@liveblocks/react/suspense";
import { AnchoredThreads, FloatingThreads } from "@liveblocks/react-blocknote";
import { BlockNoteEditor } from "@blocknote/core";

function ThreadOverlay({ editor }: { editor: BlockNoteEditor | null }) {
  const { threads } = useThreads({ query: { resolved: false } });

  return (
    <>
      <FloatingThreads
        editor={editor}
        threads={threads}
        className="w-[350px] block md:hidden"
      />
      <AnchoredThreads
        editor={editor}
        threads={threads}
        className="w-[350px] hidden sm:block"
      />
    </>
  );
}
```

```tsx title="Alternatively use a media query hook" isCollapsed isCollapsable
import { useSyncExternalStore } from "react";
import { useThreads } from "@liveblocks/react/suspense";
import { AnchoredThreads, FloatingThreads } from "@liveblocks/react-blocknote";
import { BlockNoteEditor } from "@blocknote/core";

function ThreadOverlay({ editor }: { editor: BlockNoteEditor | null }) {
  const { threads } = useThreads({ query: { resolved: false } });
  // +++
  const isMobile = useIsMobile();
  // +++

  // +++
  if (isMobile) {
    return (
      <FloatingThreads
        editor={editor}
        threads={threads}
        style={{ width: "350px" }}
      />
    );
  }
  // +++

  // +++
  return (
    <AnchoredThreads
      editor={editor}
      threads={threads}
      style={{ width: "350px" }}
    />
  );
  // +++
}

export function useIsMobile() {
  return useSyncExternalStore(subscribe, getSnapshot, getSnapshot);
}

function subscribe(callback: () => void) {
  const query = window.matchMedia("(max-width: 1024px)");

  query.addEventListener("change", callback);
  return () => query.removeEventListener("change", callback);
}

function getSnapshot() {
  const query = window.matchMedia("(max-width: 1024px)");
  return query.matches;
}
```

We can place this component inside [`ClientSideSuspense`][] to prevent it
rendering until threads have loaded.

```tsx
<div>
  <BlockNoteView editor={editor} />
  <FloatingComposer editor={editor} style={{ width: "350px" }} />
  // +++
  <ClientSideSuspense fallback={null}>
    <ThreadOverlay editor={editor} />
  </ClientSideSuspense>
  // +++
</div>
```

#### Customization [#FloatingThreads-customization]

The `FloatingThreads` component acts as a wrapper around each individual
[`Thread`][]. You can treat the component like you would a `div`, using classes,
listeners, and more.

```tsx
<FloatingThreads
  editor={editor}
  threads={threads}
  className="my-floating-thread"
/>
```

To apply styling to each [`Thread`][], you can pass a custom `Thread` property
to `components` and modify this in any way. This is the best way to modify a
threadâ€™s width.

```tsx
import { Thread } from "@liveblocks/react-ui";

<FloatingThreads
  editor={editor}
  threads={threads}
  className="my-floating-thread"
  // +++
  components={{
    Thread: (props) => (
      <Thread {...props} className="border shadow" style={{ width: "300px" }} />
    ),
  }}
  // +++
/>;
```

You can return any custom `ReactNode` here, including anything from a simple
wrapper around `Thread`, up to a full custom `Thread` component built using our
[Comment primitives](/docs/api-reference/liveblocks-react-ui#primitives-Comment).

```tsx
import { Comment } from "@liveblocks/react-ui/primitives";

<FloatingThreads
  editor={editor}
  threads={threads}
  className="my-floating-thread"
  components={{
    Thread: (props) => (
      // +++
      <div>
        {props.thread.comments.map((comment) => (
          <Comment.Body
            key={comment.id}
            body={comment.body}
            components={/* ... */}
          />
        ))}
      </div>
      // +++
    ),
  }}
/>;
```

#### Props [#FloatingThreads-props]

<PropertiesList>
  <PropertiesListItem name="threads" type="ThreadData[]" required>
    The threads to display.
  </PropertiesListItem>
  <PropertiesListItem
    name="components"
    type="Partial<AnchoredThreadsComponents>"
  >
    Override the componentâ€™s components.
  </PropertiesListItem>
  <PropertiesListItem
    name="components.Thread"
    type="(props: ThreadProps) => ReactNode"
  >
    Override the [`Thread`](/docs/api-reference/liveblocks-react-ui#Thread)
    component.
  </PropertiesListItem>
</PropertiesList>

### AnchoredThreads

Displays a list of [`Thread`][] components vertically alongside the editor.

```tsx highlight="3"
<AnchoredThreads editor={editor} threads={threads} />
```

<Figure>
  <Image
    src="/assets/text-editor/anchored-threads.jpg"
    alt="AnchoredThreads"
    width={960}
    height={558}
  />
</Figure>

Takes a list of threads retrieved from [`useThreads`][] and renders them to the
page. Each thread is displayed at the same vertical coordinates as its
corresponding text highlight. If multiple highlights are in the same location,
each thread is placed in order below the previous thread.

```tsx
// +++
import { useThreads } from "@liveblocks/react/suspense";
// +++
import {
  FloatingComposer,
  // +++
  AnchoredThreads,
  // +++
  useCreateBlockNoteWithLiveblocks,
} from "@liveblocks/react-blocknote";
import { BlockNoteView } from "@blocknote/mantine";

function TextEditor() {
  const editor = useCreateBlockNoteWithLiveblocks({});

  // +++
  const { threads } = useThreads();
  // +++

  return (
    <div>
      <BlockNoteView editor={editor} />
      <FloatingComposer editor={editor} style={{ width: "350px" }} />
      // +++
      <AnchoredThreads
        editor={editor}
        threads={threads}
        style={{ width: "350px" }}
      />
      // +++
    </div>
  );
}
```

<Banner title="Resolved threads">

The `AnchoredThreads` component automatically excludes resolved threads from
display. Any resolved threads passed in the threads list will not be shown.

</Banner>

#### Recommended usage [#AnchoredThreads-recommended-usage]

[`FloatingThreads`][] and [`AnchoredThreads`][] have been designed to work
together to provide the optimal experience on mobile and desktop. We generally
recommend using both components, hiding one on smaller screens, as we are below
with Tailwind classes. Most apps also donâ€™t need to display resolved threads, so
we can filter those out with a [`useThreads`][] option.

```tsx
import { useThreads } from "@liveblocks/react/suspense";
import { AnchoredThreads, FloatingThreads } from "@liveblocks/react-blocknote";
import { BlockNoteEditor } from "@blocknote/core";

function ThreadOverlay({ editor }: { editor: BlockNoteEditor | null }) {
  const { threads } = useThreads({ query: { resolved: false } });

  return (
    <>
      <FloatingThreads
        editor={editor}
        threads={threads}
        className="w-[350px] block md:hidden"
      />
      <AnchoredThreads
        editor={editor}
        threads={threads}
        className="w-[350px] hidden sm:block"
      />
    </>
  );
}
```

```tsx title="Alternatively use a media query hook" isCollapsed isCollapsable
import { useSyncExternalStore } from "react";
import { useThreads } from "@liveblocks/react/suspense";
import { AnchoredThreads, FloatingThreads } from "@liveblocks/react-blocknote";
import { BlockNoteEditor } from "@blocknote/core";

function ThreadOverlay({ editor }: { editor: BlockNoteEditor | null }) {
  const { threads } = useThreads({ query: { resolved: false } });
  // +++
  const isMobile = useIsMobile();
  // +++

  // +++
  if (isMobile) {
    return (
      <FloatingThreads
        editor={editor}
        threads={threads}
        style={{ width: "350px" }}
      />
    );
  }
  // +++

  // +++
  return (
    <AnchoredThreads
      editor={editor}
      threads={threads}
      style={{ width: "350px" }}
    />
  );
  // +++
}

export function useIsMobile() {
  return useSyncExternalStore(subscribe, getSnapshot, getSnapshot);
}

function subscribe(callback: () => void) {
  const query = window.matchMedia("(max-width: 1024px)");

  query.addEventListener("change", callback);
  return () => query.removeEventListener("change", callback);
}

function getSnapshot() {
  const query = window.matchMedia("(max-width: 1024px)");
  return query.matches;
}
```

We can place this component inside [`ClientSideSuspense`][] to prevent it
rendering until threads have loaded.

```tsx
<div>
  <BlockNoteView editor={editor} />
  <FloatingComposer editor={editor} style={{ width: "350px" }} />
  // +++
  <ClientSideSuspense fallback={null}>
    <ThreadOverlay editor={editor} />
  </ClientSideSuspense>
  // +++
</div>
```

#### Customization [#AnchoredThreads-customization]

The `AnchoredThreads` component acts as a wrapper around each [`Thread`][]. It
has no width, so setting this is required, and each thread will take on the
width of the wrapper. You can treat the component like you would a `div`, using
classes, listeners, and more.

```tsx
<AnchoredThreads
  editor={editor}
  threads={threads}
  style={{ width: "350px" }}
  className="my-anchored-thread"
/>
```

To apply styling to each [`Thread`][], you can pass a custom `Thread` property
to `components` and modify this in any way.

```tsx
import { Thread } from "@liveblocks/react-ui";

<AnchoredThreads
  editor={editor}
  threads={threads}
  style={{ width: "350px" }}
  className="my-anchored-thread"
  // +++
  components={{
    Thread: (props) => (
      <Thread
        {...props}
        className="border shadow"
        style={{ background: "white" }}
      />
    ),
  }}
  // +++
/>;
```

You can return any custom `ReactNode` here, including anything from a simple
wrapper around `Thread`, up to a full custom `Thread` component built using our
[Comment primitives](/docs/api-reference/liveblocks-react-ui#primitives-Comment).

```tsx
import { Comment } from "@liveblocks/react-ui/primitives";

<AnchoredThreads
  editor={editor}
  threads={threads}
  style={{ width: "350px" }}
  className="my-anchored-thread"
  components={{
    Thread: (props) => (
      // +++
      <div>
        {props.thread.comments.map((comment) => (
          <Comment.Body
            key={comment.id}
            body={comment.body}
            components={/* ... */}
          />
        ))}
      </div>
      // +++
    ),
  }}
/>;
```

##### Modifying thread floating positions

Using CSS variables you can modify the gap between threads, and the horizontal
offset thatâ€™s added when a thread is selected.

```css
.lb-tiptap-anchored-threads {
  /* Minimum gap between threads */
  --lb-tiptap-anchored-threads-gap: 8px;

  /* How far the active thread is offset to the left */
  --lb-tiptap-anchored-threads-active-thread-offset: 12px;
}
```

#### Props [#AnchoredThreads-props]

<PropertiesList>
  <PropertiesListItem name="threads" type="ThreadData[]" required>
    The threads to display.
  </PropertiesListItem>
  <PropertiesListItem
    name="components"
    type="Partial<AnchoredThreadsComponents>"
  >
    Override the componentâ€™s components.
  </PropertiesListItem>
  <PropertiesListItem
    name="components.Thread"
    type="(props: ThreadProps) => ReactNode"
  >
    Override the [`Thread`](/docs/api-reference/liveblocks-react-ui#Thread)
    component.
  </PropertiesListItem>
</PropertiesList>

### HistoryVersionPreview [@badge=beta]

The `HistoryVersionPreview` component allows you to display a preview of a
specific version of your BlockNote editorâ€™s content. It also contains a button
and logic for restoring. To render a list of versions, see
[`VersionHistory`](/docs/api-reference/liveblocks-react-ui#Version-History).

#### Usage [#HistoryVersionPreview-usage]

```tsx
import { HistoryVersionPreview } from "@liveblocks/react-blocknote";

function VersionPreview({ selectedVersion, onVersionRestore }) {
  return (
    <HistoryVersionPreview
      version={selectedVersion}
      onVersionRestore={onVersionRestore}
    />
  );
}
```

#### Props [#HistoryVersionPreview-props]

<PropertiesList>
  <PropertiesListItem name="version" type="HistoryVersion" required>
    The version of the editor content to preview.
  </PropertiesListItem>
  <PropertiesListItem
    name="onVersionRestore"
    type="(version: HistoryVersion) => void"
  >
    Callback function called when the user chooses to restore this version.
  </PropertiesListItem>
</PropertiesList>

The `HistoryVersionPreview` component renders a read-only view of the specified
version of the editor content. It also provides a button for users to restore
the displayed version.

## Hooks

### useCreateBlockNoteWithLiveblocks

Creates a Liveblocks collaborative BlockNote editor. Use this hook instead of
[`useCreateBlockNote`](https://www.blocknotejs.org/docs/editor-basics/setup#usecreateblocknote-hook).
`editor` should be passed to
[`BlockNoteView`](https://www.blocknotejs.org/docs/editor-basics/setup#rendering-the-editor-with-blocknoteview).

```tsx
import { useCreateBlockNoteWithLiveblocks } from "@liveblocks/react-blocknote";
import { BlockNoteView } from "@blocknote/mantine";

function TextEditor() {
  // +++
  const editor = useCreateBlockNoteWithLiveblocks({});
  // +++

  return (
    <div>
      // +++
      <BlockNoteView editor={editor} />
      // +++
    </div>
  );
}
```

A number of options can be applied to BlockNote and Liveblocks.

```tsx
const editor = useCreateBlockNoteWithLiveblocks(
  {
    // +++
    animations: false,
    trailingBlock: false,
    // +++

    // Other BlockNote options
    // ...
  },
  {
    // +++
    initialContent: "<p>Hello world</p>",
    field: "editor-one",
    // +++

    // Other Liveblocks options
    // ...
  }
);
```

<PropertiesList title="Returns">
  <PropertiesListItem name="liveblocks" type="Extension">
    Returns a [BlockNote
    editor](https://www.blocknotejs.org/docs/editor-basics/setup) with
    collaborative Liveblocks features.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem name="blockNoteOptions" type="BlockNoteEditorOptions">
    Options to apply to BlockNote. [Learn
    more](https://www.blocknotejs.org/docs/editor-basics/setup#usecreateblocknote-hook).
  </PropertiesListItem>
  <PropertiesListItem name="liveblocksOptions" type="object">
    Options to apply to Liveblocks.
  </PropertiesListItem>
  <PropertiesListItem name="liveblocksOptions.initialContent" type="Content">
    The initial content for the editor, if itâ€™s never been set. [Learn
    more](#Setting-initial-content).
  </PropertiesListItem>
  <PropertiesListItem name="liveblocksOptions.field" type="string">
    The name of this text editorâ€™s field. Allows you to use multiple editors on
    one page, if each has a separate field value. [Learn
    more](#Multiple-editors).
  </PropertiesListItem>
  <PropertiesListItem
    name="liveblocksOptions.offlineSupport_experimental"
    defaultValue="false"
    type="boolean"
  >
    Experimental. Enable offline support using IndexedDB. This means that after
    the first load, documents will be stored locally and load instantly. [Learn
    more](#Offline-support).
  </PropertiesListItem>
  <PropertiesListItem
    name="liveblocksOptions.comments"
    defaultValue="true"
    type="boolean"
  >
    Enable comments in the editor.
  </PropertiesListItem>
  <PropertiesListItem
    name="liveblocksOptions.mentions"
    defaultValue="true"
    type="boolean"
  >
    Enable mentions in the editor.
  </PropertiesListItem>
</PropertiesList>

#### Setting initial content

Initial content for the editor can be set with `initialContent`. This content
will only be used if the current editor has never been edited by any users, and
is ignored otherwise.

```tsx
import { useCreateBlockNoteWithLiveblocks } from "@liveblocks/react-blocknote";

function TextEditor() {
  const editor = useCreateBlockNoteWithLiveblocks(
    {},
    {
      // +++
      initialContent: "<p>Hello world</p>",
      // +++
    }
  );

  // ...
}
```

#### Multiple editors

Itâ€™s possible to use multiple editors on one page by passing values to the
`field` property. Think of it like an ID for the current editor.

```tsx
import { useCreateBlockNoteWithLiveblocks } from "@liveblocks/react-blocknote";

function TextEditor() {
  const editor = useCreateBlockNoteWithLiveblocks(
    {},
    {
      // +++
      field: "editor-one",
      // +++
    }
  );

  // ...
}
```

Hereâ€™s an example of how multiple editors may be set up.

```tsx
import { useCreateBlockNoteWithLiveblocks } from "@liveblocks/react-blocknote";
import { BlockNoteView } from "@blocknote/mantine";

function TextEditors() {
  return (
    <div>
      // +++
      <TextEditor field="one" />
      <TextEditor field="two" />
      // +++
    </div>
  );
}

function TextEditor({ field }: { field: string }) {
  const editor = useCreateBlockNoteWithLiveblocks(
    {},
    {
      // +++
      field,
      // +++
    }
  );

  return (
    <div>
      <BlockNoteView editor={editor} />
    </div>
  );
}
```

#### Offline support [@badge=experimental]

Itâ€™s possible to enable offline support in your editor with an experimental
option. This means that once a document has been opened, itâ€™s saved locally on
the browser, and can be shown instantly without a loading screen. As soon as
Liveblocks connects, any remote changes will be synchronized, without any load
spinner. Enable this by passing a `offlineSupport_experimental` value.

```tsx
import { useCreateBlockNoteWithLiveblocks } from "@liveblocks/react-blocknote";

function TextEditor() {
  const editor = useCreateBlockNoteWithLiveblocks(
    {},
    {
      // +++
      offlineSupport_experimental: true,
      // +++
    }
  );

  // ...
}
```

To make sure that your editor loads instantly, you must structure your app
carefully to avoid any Liveblocks hooks and [`ClientSideSuspense`][] components
from triggering a loading screen. For example, if youâ€™re displaying threads in
your editor with [`useThreads`][], you must place this inside a separate
component and wrap it in [`ClientSideSuspense`][].

```tsx
"use client";

import { ClientSideSuspense, useThreads } from "@liveblocks/react/suspense";
import {
  useCreateBlockNoteWithLiveblocks,
  AnchoredThreads,
  FloatingComposer,
} from "@liveblocks/react-blocknote";
import { BlockNoteView } from "@blocknote/mantine";
import { BlockNoteEditor } from "@blocknote/core";

export function BlockNoteEditor() {
  const editor = useCreateBlockNoteWithLiveblocks(
    {},
    {
      // +++
      offlineSupport_experimental: true,
      // +++
    }
  );

  return (
    <>
      <BlockNoteView editor={editor} />
      <FloatingComposer editor={editor} style={{ width: 350 }} />
      // +++
      <ClientSideSuspense fallback={null}>
        <Threads editor={editor} />
      </ClientSideSuspense>
      // +++
    </>
  );
}

// +++
function Threads({ editor }: { editor: BlockNoteEditor }) {
  const { threads } = useThreads();

  return <AnchoredThreads editor={editor} threads={threads} />;
}
// +++
```

### useIsEditorReady

Used to check if the editor content has been loaded or not, helpful for
displaying a loading skeleton.

```ts
import { useIsEditorReady } from "@liveblocks/react-blocknote";

const status = useIsEditorReady();
```

Here's how it can be used in the context of your editor.

```tsx
import {
  useCreateBlockNoteWithLiveblocks,
  useIsEditorReady,
} from "@liveblocks/react-blocknote";
import { BlockNoteView } from "@blocknote/mantine";

function TextEditor() {
  const editor = useCreateBlockNoteWithLiveblocks({});
  // +++
  const ready = useIsEditorReady();
  // +++

  return (
    <div>
      // +++
      {!ready ? <div>Loading...</div> : <BlockNoteView editor={editor} />}
      // +++
    </div>
  );
}
```

## Stylesheets

React BlockNote comes with default styles, and these can be imported into the
root of your app or directly into a CSS file with `@import`. Note that you must
also install and import a stylesheet from
[`@liveblocks/react-ui`](/docs/api-reference/liveblocks-react-ui) to use these
styles.

```tsx
import "@liveblocks/react-ui/styles.css";
import "@liveblocks/react-blocknote/styles.css";
```

### Customizing your styles

Adding dark mode and customizing your styles is part of `@liveblocks/react-ui`,
learn how to do this under
[styling and customization](/docs/api-reference/liveblocks-react-ui#Styling-and-customization).

[`Thread`]: /docs/api-reference/liveblocks-react-ui#Thread
[`Composer`]: /docs/api-reference/liveblocks-react-ui#Composer
[`useThreads`]: /docs/api-reference/liveblocks-react#useThreads
[`Icon`]: /docs/api-reference/liveblocks-react-ui#Icon
[`FloatingToolbar`]: #FloatingToolbar
[`FloatingComposer`]: #FloatingComposer
[`FloatingThreads`]: #FloatingThreads
[`AnchoredThreads`]: #AnchoredThreads
[`ClientSideSuspense`]: /docs/api-reference/liveblocks-react#ClientSideSuspense

---
meta:
  title: "@liveblocks/react-lexical"
  parentTitle: "API Reference"
  description: "API Reference for the @liveblocks/react-lexical package"
alwaysShowAllNavigationLevels: false
---

`@liveblocks/react-lexical` provides you with a [React](https://react.dev/)
plugin that adds collaboration to any [Lexical](https://lexical.dev/) text
editor. It also adds realtime cursors, document persistence on the cloud,
comments, and mentions. Read our
[get started guides](/docs/get-started/text-editor/lexical) to learn more.

## Setup

To set up your collaborative Lexical editor, you must use
[`LiveblocksPlugin`](#LiveblocksPlugin) and
[`liveblocksConfig`](#liveblocksConfig).

### LiveblocksPlugin

Liveblocks plugin for Lexical that adds collaboration to your editor.

```tsx highlight="2"
<LexicalComposer initialConfig={initialConfig}>
  <LiveblocksPlugin />
</LexicalComposer>
```

{/* TODO: Image */}

`LiveblocksPlugin` should always be nested inside [`LexicalComposer`][], and
each [Lexical default component](#Default-components) youâ€™re using should be
placed inside the plugin.

```tsx
import { LexicalComposer } from "@lexical/react/LexicalComposer";
import { RichTextPlugin } from "@lexical/react/LexicalRichTextPlugin";
import { ContentEditable } from "@lexical/react/LexicalContentEditable";
import { LexicalErrorBoundary } from "@lexical/react/LexicalErrorBoundary";
// +++
import { liveblocksConfig, LiveblocksPlugin } from "@liveblocks/react-lexical";
// +++

const initialConfig = liveblocksConfig({
  namespace: "MyEditor",
  theme: {},
  nodes: [],
  onError: (err) => console.error(err),
});

function Editor() {
  return (
    <LexicalComposer initialConfig={initialConfig}>
      // +++
      <LiveblocksPlugin>
        <FloatingThreads />
        <FloatingComposer />
        <AnchoredThreads />
      </LiveblocksPlugin>
      // +++
      <RichTextPlugin
        contentEditable={<ContentEditable />}
        placeholder={<div>Enter some text...</div>}
        ErrorBoundary={LexicalErrorBoundary}
      />
    </LexicalComposer>
  );
}
```

<Banner title="Resolved threads">

Annotations associated with resolved threads are hidden by default on the
editor.

</Banner>

Learn more in our [get started guides](/docs/get-started/text-editor/lexical).

### liveblocksConfig

Function that takes a Lexical editor config and modifies it to add the necessary
`nodes` and `theme` to make [`LiveblocksPlugin`][] works correctly.

```tsx
import { liveblocksConfig } from "@liveblocks/react-lexical";

const initialConfig = liveblocksConfig({
  namespace: "MyEditor",
  theme: {},
  nodes: [],
  onError: (err) => console.error(err),
});
```

The config created by `liveblocksConfig` should be passed to `initialConfig` in
[`LexicalComposer`][].

```tsx highlight="7-12,16"
import { LexicalComposer } from "@lexical/react/LexicalComposer";
import { RichTextPlugin } from "@lexical/react/LexicalRichTextPlugin";
import { ContentEditable } from "@lexical/react/LexicalContentEditable";
import { LexicalErrorBoundary } from "@lexical/react/LexicalErrorBoundary";
import { liveblocksConfig, LiveblocksPlugin } from "@liveblocks/react-lexical";

const initialConfig = liveblocksConfig({
  namespace: "MyEditor",
  theme: {},
  nodes: [],
  onError: (err) => console.error(err),
});

function Editor() {
  return (
    <LexicalComposer initialConfig={initialConfig}>
      <LiveblocksPlugin>
        <FloatingThreads />
        <FloatingComposer />
        <AnchoredThreads />
      </LiveblocksPlugin>
      <RichTextPlugin
        contentEditable={<ContentEditable />}
        placeholder={<div>Enter some text...</div>}
        ErrorBoundary={LexicalErrorBoundary}
      />
    </LexicalComposer>
  );
}
```

Note that `liveblocksConfig` sets `editorState` to `null` because
`LiveblocksPlugin` is responsible for initializing it on the server.

## Default components

### Toolbar

Displays a toolbar, allowing you to change the styles of selected text. You can
add content [before or after](#toolbar-extending-the-defaults), or the toolbarâ€™s
options can be [customized](#creating-a-custom-toolbar). A
[floating toolbar](#FloatingToolbar) also exists.

```tsx
<LexicalComposer initialConfig={initialConfig}>
  <LiveblocksPlugin>
    // +++
    <Toolbar />
    // +++
  </LiveblocksPlugin>
</LexicalComposer>
```

<Figure>
  <Image
    src="/assets/text-editor/toolbar.png"
    alt="Toolbar"
    width={960}
    height={558}
  />
</Figure>

By default, one of the toolbar buttons can create comment threadsâ€”to enable this
add [`FloatingComposer`][] and display threads with [`AnchoredThreads`][] or
[`FloatingThreads`][]. Should be nested inside [`LiveblocksPlugin`][].

```tsx
import { LexicalComposer } from "@lexical/react/LexicalComposer";
import { RichTextPlugin } from "@lexical/react/LexicalRichTextPlugin";
import { ContentEditable } from "@lexical/react/LexicalContentEditable";
import { LexicalErrorBoundary } from "@lexical/react/LexicalErrorBoundary";
import { useThreads } from "@liveblocks/react/suspense";
import {
  liveblocksConfig,
  LiveblocksPlugin,
  FloatingComposer,
  // +++
  Toolbar,
  // +++
} from "@liveblocks/react-lexical";

const initialConfig = liveblocksConfig({
  namespace: "MyEditor",
  theme: {},
  nodes: [],
  onError: (err) => console.error(err),
});

function Editor() {
  const { threads } = useThreads();

  return (
    <LexicalComposer initialConfig={initialConfig}>
      <LiveblocksPlugin>
        // +++
        <Toolbar />
        // +++
        <FloatingComposer style={{ width: "350px" }} />
        <FloatingThreads threads={threads} style={{ width: "350px" }} />
      </LiveblocksPlugin>
      <RichTextPlugin
        contentEditable={<ContentEditable />}
        placeholder={<div>Enter some text...</div>}
        ErrorBoundary={LexicalErrorBoundary}
      />
    </LexicalComposer>
  );
}
```

#### Extending the defaults [#toolbar-extending-the-defaults]

You can insert content `before` the first button and `after` the last button
using `before` and `after`. Components such as [`Toolbar.Button`][] and
[`Toolbar.Toggle`][] can be used to create new buttons.

```tsx
import { Toolbar } from "@liveblocks/react-lexical";
import { Icon } from "@liveblocks/react-ui";

<Toolbar
  // +++
  before={<>I'm at the start</>}
  after={
    <Toolbar.Button
      name="Help"
      icon={<Icon.QuestionMark />}
      shortcut="CMD-H"
      onClick={() => console.log("help")}
    />
  }
  // +++
/>;
```

For more complex customization, instead read
[creating a custom floating toolbar](#creating-a-custom-toolbar).

#### Creating a custom toolbar [#creating-a-custom-toolbar]

By passing elements as children, itâ€™s possible to create a fully custom toolbar.

```tsx highlight="6"
import { Toolbar } from "@liveblocks/react-lexical";

function CustomToolbar() {
  return (
    <Toolbar>
      Hello <strong>world</strong>
    </Toolbar>
  );
}
```

Each part of our default toolbar is available as blocks which can be slotted
together. This is how the default toolbar is constructed:

```tsx
import { Toolbar } from "@liveblocks/react-lexical";

function CustomToolbar() {
  return (
    <Toolbar>
      // +++
      <Toolbar.BlockSelector />
      <Toolbar.SectionInline />
      <Toolbar.Separator />
      <Toolbar.SectionCollaboration />
      // +++
    </Toolbar>
  );
}
```

You can mix these default components with any custom ones of your own. Below the
[`Toolbar.SectionHistory`][] component is added alongside some custom buttons
created with [`Toolbar.Button`][], [`Toolbar.Toggle`][], and [`Icon`][].

```tsx
import { FORMAT_TEXT_COMMAND } from "lexical";
import { useLexicalComposerContext } from "@lexical/react/LexicalComposerContext";
import { isTextFormatActive, Toolbar } from "@liveblocks/react-lexical";
import { Icon } from "@liveblocks/react-ui";

function CustomToolbar() {
  const [editor] = useLexicalComposerContext();

  return (
    <Toolbar>
      // +++
      <Toolbar.SectionHistory />
      <Toolbar.Separator />
      <Toolbar.Button
        name="Help"
        icon={<Icon.QuestionMark />}
        shortcut="CMD-H"
        onClick={() => console.log("help")}
      />
      <Toolbar.Toggle
        name="Bold"
        icon={<strong>Bï¸</strong>}
        active={isTextFormatActive(editor, "bold")}
        onClick={() => editor.dispatchCommand(FORMAT_TEXT_COMMAND, "bold")}
      />
      // +++
    </Toolbar>
  );
}
```

To learn more about the different components, read more below.

#### Props [#Toolbar-props]

<PropertiesList>
  <PropertiesListItem name="editor" type="LexicalEditor" required>
    The Lexical editor.
  </PropertiesListItem>
  <PropertiesListItem name="children" type="ReactNode">
    The content of the toolbar, overriding the default content. Use the `before`
    and `after` props if you want to keep and extend the default content. Any
    `ReactNode` or `Toolbar.*` components work inside.
  </PropertiesListItem>
  <PropertiesListItem name="before" type="ReactNode">
    The content to display at the start of the toolbar. Any `ReactNode` or
    `Toolbar.*` components work inside.
  </PropertiesListItem>
  <PropertiesListItem name="after" type="ReactNode">
    The content to display at the end of the toolbar. Any `ReactNode` or
    `Toolbar.*` components work inside.
  </PropertiesListItem>
</PropertiesList>

#### Toolbar.Button

A button for triggering actions. The `name` is displayed in a tooltip. Props
such as `onClick` will be passed to the underlying `button` element.

```tsx
import { Toolbar } from "@liveblocks/react-lexical";

<Toolbar>
  <Toolbar.Button name="Question" onClick={(e) => console.log("Clicked")} />
</Toolbar>;
```

Optionally takes an icon which will visually replace the `name`. Also optionally
accepts a shortcut, which is displayed in the tooltip. Comment key names are
converted to symbols. Here are various examples.

```tsx
import { Toolbar } from "@liveblocks/react-lexical";
import { Icon } from "@liveblocks/react-ui";

// Button says "Question"
<Toolbar.Toggle name="Question" onClick={/* ... */} />

// Tooltip says "Question [âŒ˜+Q]"
<Toolbar.Button name="Question" shortcut="CMD+Q" onClick={/* ... */} />

// Custom icon, replaces the name in the button
<Toolbar.Button name="Question" icon={<div>?</div>} onClick={/* ... */} />

// Using a Liveblocks icon, replaces the name in the button
<Toolbar.Button name="Question" icon={<Icon.QuestionMark />} onClick={/* ... */} />

// Passing children visually replaces the `name` and `icon`
<Toolbar.Button name="Question" onClick={/* ... */}>
  ? Ask a question
</Toolbar.Button>

// Props are passed to the inner `button`
<Toolbar.Button
  name="Question"
  style={{ marginLeft: 10 }}
  className="custom-button"
  onMouseOver={() => console.log("Hovered")}
/>
```

##### Props [#ToolbarButton-props]

<PropertiesList>
  <PropertiesListItem name="name" type="string" required>
    The name of this button displayed in its tooltip. Will also be displayed in
    the button if no `icon` or `children` are passed.
  </PropertiesListItem>
  <PropertiesListItem name="icon" type="ReactNode">
    An optional icon displayed in this button.
  </PropertiesListItem>
  <PropertiesListItem name="shortcut" type="string">
    An optional keyboard shortcut displayed in this buttonâ€™s tooltip. Common
    shortcuts such will be replaced by their symbols, for example `CMD` â†’ `âŒ˜`.
  </PropertiesListItem>
</PropertiesList>

#### Toolbar.Toggle

A toggle button for values that can be active or inactive. Best used with text
editor commands. The `name` is displayed in a tooltip. Props will be passed to
the underlying `button` element.

```tsx
import { FORMAT_TEXT_COMMAND } from "lexical";
import { isTextFormatActive, Toolbar } from "@liveblocks/react-lexical";

<Toolbar>
  <Toolbar.Toggle
    name="Highlight"
    active={isTextFormatActive(editor, "bold")}
    onClick={() => editor.dispatchCommand(FORMAT_TEXT_COMMAND, "bold")}
  />
</Toolbar>;
```

The snippet above shows how to toggle bold styling. The toggle button can also
be toggled with `useState`.

```tsx
import { Toolbar } from "@liveblocks/react-lexical";
import { useState } from "react";

function CustomToggle() {
  const [active, setActive] = useState(false);

  return (
    <Toolbar.Toggle
      name="Toggle options"
      active={active}
      onClick={() => setActive(!active)}
    />
  );
}
```

`Toolbar.Toggle` optionally takes an icon which will visually replace the
`name`. Also optionally accepts a shortcut, which is displayed in the tooltip.
Comment key names are converted to symbols. Here are various examples.

```tsx
import { Toolbar } from "@liveblocks/react-lexical";
import { Icon } from "@liveblocks/react-ui";

// Button says "Highlight"
<Toolbar.Toggle
  name="Highlight"
  active={/* ... */}
  onClick={/* ... */}
/>

// Tooltip says "Highlight [âŒ˜+H]"
<Toolbar.Toggle
  name="Highlight"
  shortcut="CMD+H"
  active={/* ... */}
  onClick={/* ... */}
/>

// Custom icon, replaces the name in the button
<Toolbar.Toggle
  name="Highlight"
  icon={<div>ðŸ–Š</div>}
  active={/* ... */}
  onClick={/* ... */}
/>

// Using a Liveblocks icon, replaces the name in the button
<Toolbar.Toggle
  name="Highlight"
  icon={<Icon.QuestionMark />}
  active={/* ... */}
  onClick={/* ... */}
/>

// Passing children visually replaces the `name` and `icon`
<Toolbar.Toggle
  name="Highlight"
  active={/* ... */}
  onClick={/* ... */}
>
  ðŸ–Šï¸Highlight
</Toolbar.Toggle>

// Props are passed to the inner `button`
<Toolbar.Toggle
  name="Highlight"
  active={/* ... */}
  onClick={/* ... */}
  style={{ marginLeft: 10 }}
  className="custom-toggle"
  onMouseOver={() => console.log("Hovered")}
/>
```

##### Props [#ToolbarToggle-props]

<PropertiesList>
  <PropertiesListItem name="name" type="string" required>
    The name of this button displayed in its tooltip. Will also be displayed in
    the button if no `icon` or `children` are passed.
  </PropertiesListItem>
  <PropertiesListItem name="active" type="boolean" required>
    Whether the button is toggled.
  </PropertiesListItem>
  <PropertiesListItem name="icon" type="ReactNode">
    An optional icon displayed in this button.
  </PropertiesListItem>
  <PropertiesListItem name="shortcut" type="string">
    An optional keyboard shortcut displayed in this buttonâ€™s tooltip. Common
    shortcuts such will be replaced by their symbols, for example `CMD` â†’ `âŒ˜`.
  </PropertiesListItem>
</PropertiesList>

#### Toolbar.BlockSelector

Adds a dropdown selector for switching between different block types, such as
_text_, _heading 1_, _blockquote_. Props will be passed to the inner `button`
element. Can also be placed inside [`FloatingToolbar`][].

```tsx
import { Toolbar } from "@liveblocks/react-lexical";

<Toolbar>
  <Toolbar.BlockSelector />
</Toolbar>;
```

##### Use custom item options

If youâ€™d like to change the items shown in the dropdown menu, you can pass a
custom `items` array. Below a code block item
([Lexical extension](https://lexical.dev/docs/api/modules/lexical_code)) is
added after the default options.

```tsx
import { isBlockNodeActive, Toolbar } from "@liveblocks/react-lexical";
import { $setBlocksType } from "@lexical/selection";
import { $isCodeNode } from "@lexical/code";
import { $getSelection } from "lexical";

<Toolbar>
  <Toolbar.BlockSelector
    items={(defaultItems) => [
      ...defaultItems,
      {
        name: "Code block",
        icon: <div>â® â¯</div>, // Optional
        isActive: (editor) => isBlockNodeActive(editor, $isCodeNode),
        setActive: (editor) =>
          $setBlocksType($getSelection(), () => $createCodeNode()),
      },
    ]}
  />
</Toolbar>;
```

##### Customize item styles

By passing a `label` property, you can overwrite the styles of the dropdown
items. The toolbar button will still display the `name`, but in the dropdown,
the `label` will be used instead of the `name` and `icon`. Below, a new item is
added and its `label` is customized.

```tsx
import { isBlockNodeActive, Toolbar } from "@liveblocks/react-lexical";
import { $setBlocksType } from "@lexical/selection";
import { $isCodeNode } from "@lexical/code";
import { $getSelection } from "lexical";

<Toolbar>
  <Toolbar.BlockSelector
    items={(defaultItems) => [
      ...defaultItems,
      {
        name: "Code block",
        // +++
        label: <div className="font-mono">Code</div>, // Optional, overwrites `icon` + `name`
        // +++
        isActive: (editor) => isBlockNodeActive(editor, $isCodeNode),
        setActive: (editor) =>
          $setBlocksType($getSelection(), () => $createCodeNode()),
      },
    ]}
  />
</Toolbar>;
```

You can also customize the default items. Below each item is styled to represent
the effect each block applies to the document.

```tsx
import { Toolbar } from "@liveblocks/react-lexical";

<Toolbar.BlockSelector
  items={(defaultItems) =>
    defaultItems.map((item) => {
      let label;

      if (item.name === "Text") {
        label = <span>Regular text</span>;
      }

      if (item.name === "Heading 1") {
        label = (
          <span style={{ fontSize: 18, fontWeight: "bold" }}>Heading 1</span>
        );
      }

      if (item.name === "Heading 2") {
        label = (
          <span style={{ fontSize: 16, fontWeight: "bold" }}>Heading 2</span>
        );
      }

      if (item.name === "Heading 3") {
        label = (
          <span style={{ fontSize: 15, fontWeight: "bold" }}>Heading 3</span>
        );
      }

      if (item.name === "Blockquote") {
        label = (
          <span style={{ borderLeft: "3px solid gray", paddingLeft: 8 }}>
            Blockquote
          </span>
        );
      }

      return {
        ...item,
        label,
        icon: null, // Hide all icons
      };
    })
  }
/>;
```

##### Props [#ToolbarBlockSelector-props]

<PropertiesList>
  <PropertiesListItem
    name="items"
    type="array | function"
    detailedType="ToolbarBlockSelectorItem[] | (defaultItems: ToolbarBlockSelectorItem[]) => ToolbarBlockSelectorItem[]"
  >
    The items displayed in this block selector. When provided as an array, the
    default items are overridden. To avoid this, a function can be provided
    instead and it will receive the default items.
  </PropertiesListItem>
</PropertiesList>

#### Toolbar.Separator

Adds a visual, and accessible, separator used to separate sections in the
toolbar. Props will be passed to the inner `div` element. Can also be placed
inside [`FloatingToolbar`][].

```tsx
import { Toolbar } from "@liveblocks/react-lexical";

<Toolbar>
  // +++
  <Toolbar.SectionHistory />
  // +++
</Toolbar>;
```

#### Toolbar.SectionHistory

Adds a section containing _undo_ and _redo_ buttons. Can also be placed inside
[`FloatingToolbar`][].

```tsx
import { Toolbar } from "@liveblocks/react-lexical";

<Toolbar>
  // +++
  <Toolbar.SectionHistory />
  // +++
</Toolbar>;
```

#### Toolbar.SectionInline

Adds a section containing inline formatting actions such as _bold_, _italic_,
_underline_. Can also be placed inside [`FloatingToolbar`][].

```tsx
import { Toolbar } from "@liveblocks/react-lexical";

<Toolbar>
  // +++
  <Toolbar.SectionInline />
  // +++
</Toolbar>;
```

#### Toolbar.SectionCollaboration

Adds a section containing an _add comment_ button. Can also be placed inside
[`FloatingToolbar`][].

```tsx
import { Toolbar } from "@liveblocks/react-lexical";

<Toolbar>
  // +++
  <Toolbar.SectionCollaboration />
  // +++
</Toolbar>;
```

### FloatingToolbar

Displays a floating toolbar near the current Lexical selection, allowing you to
change styles. You can add content
[before or after](#floating-toolbar-extending-the-defaults), or the toolbarâ€™s
options can be [customized](#creating-a-custom-floating-toolbar). A
[static toolbar](#Toolbar) also exists.

```tsx
<LexicalComposer initialConfig={initialConfig}>
  <LiveblocksPlugin>
    // +++
    <FloatingToolbar />
    // +++
  </LiveblocksPlugin>
</LexicalComposer>
```

<Figure>
  <Image
    src="/assets/text-editor/floating-toolbar.png"
    alt="FloatingToolbar"
    width={960}
    height={558}
  />
</Figure>

By default, one of the toolbar buttons can create comment threadsâ€”to enable this
add [`FloatingComposer`][] and display threads with [`AnchoredThreads`][] or
[`FloatingThreads`][]. Should be nested inside [`LiveblocksPlugin`][].

```tsx
import { LexicalComposer } from "@lexical/react/LexicalComposer";
import { RichTextPlugin } from "@lexical/react/LexicalRichTextPlugin";
import { ContentEditable } from "@lexical/react/LexicalContentEditable";
import { LexicalErrorBoundary } from "@lexical/react/LexicalErrorBoundary";
import { useThreads } from "@liveblocks/react/suspense";
import {
  liveblocksConfig,
  LiveblocksPlugin,
  FloatingComposer,
  // +++
  FloatingToolbar,
  // +++
} from "@liveblocks/react-lexical";

const initialConfig = liveblocksConfig({
  namespace: "MyEditor",
  theme: {},
  nodes: [],
  onError: (err) => console.error(err),
});

function Editor() {
  const { threads } = useThreads();

  return (
    <LexicalComposer initialConfig={initialConfig}>
      <LiveblocksPlugin>
        // +++
        <FloatingToolbar />
        // +++
        <FloatingComposer style={{ width: "350px" }} />
        <FloatingThreads threads={threads} style={{ width: "350px" }} />
      </LiveblocksPlugin>
      <RichTextPlugin
        contentEditable={<ContentEditable />}
        placeholder={<div>Enter some text...</div>}
        ErrorBoundary={LexicalErrorBoundary}
      />
    </LexicalComposer>
  );
}
```

#### Changing float position

Using `position` and `offset` you can reposition the toolbar relative to the
current selection. `position` can be set to `"top"` or `"bottom"`, and `offset`
defines the vertical distance in pixels from the selection.

```tsx
<FloatingToolbar
  // +++
  position="bottom" // Position can be `top` or `bottom`
  offset={12} // Distance in px from selection
  // +++
/>
```

#### Extending the defaults [#floating-toolbar-extending-the-default]

You can insert custom content `before` the first button and `after` the last
button using `before` and `after`. Components such as [`Toolbar.Button`][] and
[`Toolbar.Toggle`][] can be used to create new buttons.

```tsx
import { FloatingToolbar } from "@liveblocks/react-lexical";
import { Icon } from "@liveblocks/react-ui";

<FloatingToolbar
  // +++
  before={<>I'm at the start</>}
  after={
    <Toolbar.Button
      name="Help"
      icon={<Icon.QuestionMark />}
      shortcut="CMD-H"
      onClick={() => console.log("help")}
    />
  }
  // +++
/>;
```

For more complex customization, instead read
[creating a custom floating toolbar](#creating-a-custom-floating-toolbar).

#### Creating a custom floating toolbar [#creating-a-custom-floating-toolbar]

By passing elements as children, itâ€™s possible to create a fully custom floating
toolbar.

```tsx highlight="7"
import { FloatingToolbar } from "@liveblocks/react-lexical";

function CustomToolbar() {
  return (
    <FloatingToolbar>
      Hello <strong>world</strong>
    </FloatingToolbar>
  );
}
```

Each part of our default toolbar is available as blocks which can be slotted
together. This is how the default floating toolbar is constructed:

```tsx
import { FloatingToolbar } from "@liveblocks/react-lexical";

function CustomToolbar() {
  return (
    <FloatingToolbar>
      // +++
      <Toolbar.BlockSelector />
      <Toolbar.SectionInline />
      <Toolbar.Separator />
      <Toolbar.SectionCollaboration />
      // +++
    </FloatingToolbar>
  );
}
```

You can mix these default components with any custom ones of your own. Below the
[`Toolbar.SectionHistory`][] component is added alongside some custom buttons
created with [`Toolbar.Button`][], [`Toolbar.Toggle`][], and [`Icon`][].

```tsx
import { FORMAT_TEXT_COMMAND } from "lexical";
import { useLexicalComposerContext } from "@lexical/react/LexicalComposerContext";
import { isTextFormatActive, FloatingToolbar } from "@liveblocks/react-lexical";
import { Icon } from "@liveblocks/react-ui";

function CustomToolbar() {
  const [editor] = useLexicalComposerContext();

  return (
    <FloatingToolbar>
      // +++
      <Toolbar.SectionHistory />
      <Toolbar.Separator />
      <Toolbar.Button
        name="Help"
        icon={<Icon.QuestionMark />}
        shortcut="CMD-H"
        onClick={() => console.log("help")}
      />
      <Toolbar.Toggle
        name="Bold"
        icon={<strong>Bï¸</strong>}
        active={isTextFormatActive(editor, "bold")}
        onClick={() => editor.dispatchCommand(FORMAT_TEXT_COMMAND, "bold")}
      />
      // +++
    </FloatingToolbar>
  );
}
```

To learn more about the different components, read more under [`Toolbar`][].

#### Props [#FloatingToolbar-props]

<PropertiesList>
  <PropertiesListItem name="editor" type="LexicalEditor" required>
    The Lexical editor.
  </PropertiesListItem>
  <PropertiesListItem name="position" type={`"top" | "bottom"`}>
    The vertical position of the floating toolbar.
  </PropertiesListItem>
  <PropertiesListItem name="offset" type="number">
    The vertical offset of the floating toolbar from the selection.
  </PropertiesListItem>
  <PropertiesListItem name="children" type="ReactNode">
    The content of the toolbar, overriding the default content. Use the `before`
    and `after` props if you want to keep and extend the default content. Any
    `ReactNode` or `Toolbar.*` components work inside.
  </PropertiesListItem>
  <PropertiesListItem name="before" type="ReactNode">
    The content to display at the start of the toolbar. Any `ReactNode` or
    `Toolbar.*` components work inside.
  </PropertiesListItem>
  <PropertiesListItem name="after" type="ReactNode">
    The content to display at the end of the toolbar. Any `ReactNode` or
    `Toolbar.*` components work inside.
  </PropertiesListItem>
</PropertiesList>

### FloatingComposer

Displays a [`Composer`][] near the current Lexical selection, allowing you to
create threads.

```tsx highlight="3"
<LexicalComposer initialConfig={initialConfig}>
  <LiveblocksPlugin>
    <FloatingComposer />
  </LiveblocksPlugin>
</LexicalComposer>
```

<Figure>
  <Image
    src="/assets/text-editor/floating-composer.jpg"
    alt="FloatingComposer"
    width={960}
    height={558}
  />
</Figure>

Submitting a comment will attach an annotation thread at the current selection.
Should be nested inside [`LiveblocksPlugin`][].

```tsx highlight="8,22"
import { LexicalComposer } from "@lexical/react/LexicalComposer";
import { RichTextPlugin } from "@lexical/react/LexicalRichTextPlugin";
import { ContentEditable } from "@lexical/react/LexicalContentEditable";
import { LexicalErrorBoundary } from "@lexical/react/LexicalErrorBoundary";
import {
  liveblocksConfig,
  LiveblocksPlugin,
  FloatingComposer,
} from "@liveblocks/react-lexical";

const initialConfig = liveblocksConfig({
  namespace: "MyEditor",
  theme: {},
  nodes: [],
  onError: (err) => console.error(err),
});

function Editor() {
  return (
    <LexicalComposer initialConfig={initialConfig}>
      <LiveblocksPlugin>
        <FloatingComposer style={{ width: "350px" }} />
      </LiveblocksPlugin>
      <RichTextPlugin
        contentEditable={<ContentEditable />}
        placeholder={<div>Enter some text...</div>}
        ErrorBoundary={LexicalErrorBoundary}
      />
    </LexicalComposer>
  );
}
```

Display created threads with [`AnchoredThreads`][] or [`FloatingThreads`][].

#### Opening the composer

To open the `FloatingComposer`, you need to dispatch the
`OPEN_FLOATING_COMPOSER_COMMAND`
[Lexical command](https://lexical.dev/docs/concepts/commands).

```tsx highlight="10"
import { useLexicalComposerContext } from "@lexical/react/LexicalComposerContext";
import { OPEN_FLOATING_COMPOSER_COMMAND } from "@liveblocks/react-lexical";

function Toolbar() {
  const [editor] = useLexicalComposerContext();

  return (
    <button
      onClick={() => {
        editor.dispatchCommand(OPEN_FLOATING_COMPOSER_COMMAND, undefined);
      }}
    >
      ðŸ’¬ New comment
    </button>
  );
}
```

#### Customization [#FloatingComposer-customization]

The `FloatingComposer` component acts as a wrapper around a [`Composer`][], near
the current selection. You can treat the component like you would a `form`,
using classes, listeners, and more.

```tsx
<FloatingComposer style={{ width: "350px" }} className="my-floating-composer" />
```

To apply styling to the composer, you can pass a custom `Composer` property to
`components` and modify this in any way.

```tsx
import { Composer } from "@liveblocks/react-ui";

<FloatingComposer
  style={{ width: "350px" }}
  // +++
  components={{
    Composer: (props) => (
      <Composer
        {...props}
        className="border shadow"
        style={{ width: "300px" }}
      />
    ),
  }}
  // +++
/>;
```

You can return any custom `ReactNode` here, including anything from a simple
wrapper around `Composer`, up to a full custom `Composer` component built using
our
[Composer primitives](/docs/api-reference/liveblocks-react-ui#primitives-Composer).

```tsx
import { Composer } from "@liveblocks/react-ui/primitives";

<FloatingComposer
  style={{ width: "350px" }}
  components={{
    // +++
    Composer: ({ onComposerSubmit }) => (
      <Composer.Form onComposerSubmit={onComposerSubmit}>
        <Composer.Editor />
        <Composer.Submit>Send</Composer.Submit>
      </Composer.Form>
    ),
    // +++
  }}
/>;
```

You can also customize submission behavior by passing a custom
`onComposerSubmit` function to the `Composer.Form` component.

```tsx
import { Composer } from "@liveblocks/react-ui/primitives";

<FloatingComposer
  editor={editor}
  style={{ width: "350px" }}
  components={{
    Composer: () => (
      <Composer.Form
        // +++
          onComposerSubmit={(comment, event) => {
            event.preventDefault();

            const thread = createThread({
              body: comment.body,
              attachments: comment.attachments,
              metadata: ...,
            });

            editor.dispatchCommand(ATTACH_THREAD_COMMAND, thread.id);
          }}
          // +++
        >
          <Composer.Editor />
          <Composer.Submit>Send</Composer.Submit>
        </Composer.Form>
      )
  }}
/>;
```

#### Props [#FloatingComposer-props]

<PropertiesList>
  <PropertiesListItem name="metadata" type="ThreadMetadata">
    The metadata of the thread to create.
  </PropertiesListItem>
  <PropertiesListItem name="commentMetadata" type="CommentMetadata">
    The metadata of the comment to create.
  </PropertiesListItem>
  <PropertiesListItem
    name="onComposerSubmit"
    type="function"
    detailedType="(comment: ComposerSubmitComment, event: FormEvent<HTMLFormElement>) => Promise<void> | void"
  >
    The event handler called when the composer is submitted.
  </PropertiesListItem>
  <PropertiesListItem name="defaultValue" type="CommentBody">
    The composerâ€™s initial value.
  </PropertiesListItem>
  <PropertiesListItem name="collapsed" type="boolean">
    Whether the composer is collapsed. Setting a value will make the composer
    controlled.
  </PropertiesListItem>
  <PropertiesListItem
    name="onCollapsedChange"
    type="function"
    detailedType="(collapsed: boolean) => void"
  >
    The event handler called when the collapsed state of the composer changes.
  </PropertiesListItem>
  <PropertiesListItem name="defaultCollapsed" type="boolean">
    Whether the composer is initially collapsed. Setting a value will make the
    composer uncontrolled.
  </PropertiesListItem>
  <PropertiesListItem name="disabled" type="boolean">
    Whether the composer is disabled.
  </PropertiesListItem>
  <PropertiesListItem name="autoFocus" type="boolean">
    Whether to focus the composer on mount.
  </PropertiesListItem>
  <PropertiesListItem
    name="overrides"
    type="Partial<GlobalOverrides & ComposerOverrides>"
  >
    Override the componentâ€™s strings.
  </PropertiesListItem>
  <PropertiesListItem
    name="components"
    type="Partial<FloatingComposerComponents>"
  >
    Override the componentâ€™s components.
  </PropertiesListItem>
  <PropertiesListItem
    name="components.Composer"
    type="(props: ComposerProps) => ReactNode"
  >
    Override the [`Composer`](/docs/api-reference/liveblocks-react-ui#Composer)
    component.
  </PropertiesListItem>
</PropertiesList>

### FloatingThreads

Displays floating [`Thread`][] components below text highlights in the editor.

```tsx highlight="3"
<LexicalComposer initialConfig={initialConfig}>
  <LiveblocksPlugin>
    <FloatingThreads threads={threads} />
  </LiveblocksPlugin>
</LexicalComposer>
```

<Figure>
  <Image
    src="/assets/text-editor/floating-threads.jpg"
    alt="FloatingThreads"
    width={960}
    height={558}
  />
</Figure>

Takes a list of threads retrieved from [`useThreads`][] and renders them to the
page. Each thread is opened by clicking on its corresponding text highlight.

```tsx
import { LexicalComposer } from "@lexical/react/LexicalComposer";
import { RichTextPlugin } from "@lexical/react/LexicalRichTextPlugin";
import { ContentEditable } from "@lexical/react/LexicalContentEditable";
import { LexicalErrorBoundary } from "@lexical/react/LexicalErrorBoundary";
import { useThreads } from "@liveblocks/react/suspense";
import {
  liveblocksConfig,
  LiveblocksPlugin,
  FloatingComposer,
  // +++
  FloatingThreads,
  // +++
} from "@liveblocks/react-lexical";

const initialConfig = liveblocksConfig({
  namespace: "MyEditor",
  theme: {},
  nodes: [],
  onError: (err) => console.error(err),
});

function Editor() {
  // +++
  const { threads } = useThreads();
  // +++

  return (
    <LexicalComposer initialConfig={initialConfig}>
      <LiveblocksPlugin>
        <FloatingComposer />
        // +++
        <FloatingThreads threads={threads} style={{ width: "350px" }} />
        // +++
      </LiveblocksPlugin>
      <RichTextPlugin
        contentEditable={<ContentEditable />}
        placeholder={<div>Enter some text...</div>}
        ErrorBoundary={LexicalErrorBoundary}
      />
    </LexicalComposer>
  );
}
```

Should be nested inside [`LiveblocksPlugin`][].

<Banner title="Resolved threads">

The `FloatingThreads` component automatically excludes resolved threads from
display. Any resolved threads passed in the threads list will not be shown.

</Banner>

#### Recommended usage [#FloatingThreads-recommended-usage]

[`FloatingThreads`][] and [`AnchoredThreads`][] have been designed to work
together to provide the optimal experience on mobile and desktop. We generally
recommend using both components, hiding one on smaller screens, as we are below
with Tailwind classes. Most apps also donâ€™t need to display resolved threads, so
we can filter those out with a [`useThreads`][] option.

```tsx
import { useThreads } from "@liveblocks/react/suspense";
import { AnchoredThreads, FloatingThreads } from "@liveblocks/react-lexical";

function ThreadOverlay() {
  const { threads } = useThreads({ query: { resolved: false } });

  return (
    <>
      <FloatingThreads
        threads={threads}
        className="w-[350px] block md:hidden"
      />
      <AnchoredThreads
        threads={threads}
        className="w-[350px] hidden sm:block"
      />
    </>
  );
}
```

```tsx title="Alternatively use a media query hook" isCollapsed isCollapsable
import { useSyncExternalStore } from "react";
import { useThreads } from "@liveblocks/react/suspense";
import { AnchoredThreads, FloatingThreads } from "@liveblocks/react-lexical";

function ThreadOverlay() {
  const { threads } = useThreads({ query: { resolved: false } });
  // +++
  const isMobile = useIsMobile();
  // +++

  // +++
  if (isMobile) {
    return <FloatingThreads threads={threads} style={{ width: "350px" }} />;
  }
  // +++

  // +++
  return <AnchoredThreads threads={threads} style={{ width: "350px" }} />;
  // +++
}

export function useIsMobile() {
  return useSyncExternalStore(subscribe, getSnapshot, getSnapshot);
}

function subscribe(callback: () => void) {
  const query = window.matchMedia("(max-width: 1024px)");

  query.addEventListener("change", callback);
  return () => query.removeEventListener("change", callback);
}

function getSnapshot() {
  const query = window.matchMedia("(max-width: 1024px)");
  return query.matches;
}
```

We can place this component inside [`ClientSideSuspense`][] to prevent it
rendering until threads have loaded.

```tsx
<LexicalComposer initialConfig={initialConfig}>
  <LiveblocksPlugin>
    <FloatingComposer />
    // +++
    <ClientSideSuspense fallback={null}>
      <ThreadOverlay />
    </ClientSideSuspense>
    // +++
  </LiveblocksPlugin>
</LexicalComposer>
```

#### Customization [#FloatingThreads-customization]

The `FloatingThreads` component acts as a wrapper around each individual
[`Thread`][]. You can treat the component like you would a `div`, using classes,
listeners, and more.

```tsx
<FloatingThreads threads={threads} className="my-floating-thread" />
```

To apply styling to each [`Thread`][], you can pass a custom `Thread` property
to `components` and modify this in any way. This is the best way to modify a
threadâ€™s width.

```tsx
import { Thread } from "@liveblocks/react-ui";

<FloatingThreads
  threads={threads}
  className="my-floating-thread"
  // +++
  components={{
    Thread: (props) => (
      <Thread {...props} className="border shadow" style={{ width: "300px" }} />
    ),
  }}
  // +++
/>;
```

You can return any custom `ReactNode` here, including anything from a simple
wrapper around `Thread`, up to a full custom `Thread` component built using our
[Comment primitives](/docs/api-reference/liveblocks-react-ui#primitives-Comment).

```tsx
import { Comment } from "@liveblocks/react-ui/primitives";

<FloatingThreads
  threads={threads}
  className="my-floating-thread"
  components={{
    Thread: (props) => (
      // +++
      <div>
        {props.thread.comments.map((comment) => (
          <Comment.Body
            key={comment.id}
            body={comment.body}
            components={/* ... */}
          />
        ))}
      </div>
      // +++
    ),
  }}
/>;
```

#### Props [#FloatingThreads-props]

<PropertiesList>
  <PropertiesListItem name="threads" type="ThreadData[]" required>
    The threads to display.
  </PropertiesListItem>
  <PropertiesListItem
    name="components"
    type="Partial<AnchoredThreadsComponents>"
  >
    Override the componentâ€™s components.
  </PropertiesListItem>
  <PropertiesListItem
    name="components.Thread"
    type="(props: ThreadProps) => ReactNode"
  >
    Override the [`Thread`](/docs/api-reference/liveblocks-react-ui#Thread)
    component.
  </PropertiesListItem>
</PropertiesList>

### AnchoredThreads

Displays a list of [`Thread`][] components vertically alongside the editor.

```tsx highlight="3"
<LexicalComposer initialConfig={initialConfig}>
  <LiveblocksPlugin>
    <AnchoredThreads threads={threads} />
  </LiveblocksPlugin>
</LexicalComposer>
```

<Figure>
  <Image
    src="/assets/text-editor/anchored-threads.jpg"
    alt="AnchoredThreads"
    width={960}
    height={558}
  />
</Figure>

Takes a list of threads retrieved from [`useThreads`][] and renders them to the
page. Each thread is displayed at the same vertical coordinates as its
corresponding text highlight. If multiple highlights are in the same location,
each thread is placed in order below the previous thread.

```tsx
import { LexicalComposer } from "@lexical/react/LexicalComposer";
import { RichTextPlugin } from "@lexical/react/LexicalRichTextPlugin";
import { ContentEditable } from "@lexical/react/LexicalContentEditable";
import { LexicalErrorBoundary } from "@lexical/react/LexicalErrorBoundary";
import { useThreads } from "@liveblocks/react/suspense";
import {
  liveblocksConfig,
  LiveblocksPlugin,
  FloatingComposer,
  // +++
  AnchoredThreads,
  // +++
} from "@liveblocks/react-lexical";

const initialConfig = liveblocksConfig({
  namespace: "MyEditor",
  theme: {},
  nodes: [],
  onError: (err) => console.error(err),
});

function Editor() {
  // +++
  const { threads } = useThreads();
  // +++

  return (
    <LexicalComposer initialConfig={initialConfig}>
      <LiveblocksPlugin>
        <FloatingComposer />
        // +++
        <AnchoredThreads threads={threads} style={{ width: "350px" }} />
        // +++
      </LiveblocksPlugin>
      <RichTextPlugin
        contentEditable={<ContentEditable />}
        placeholder={<div>Enter some text...</div>}
        ErrorBoundary={LexicalErrorBoundary}
      />
    </LexicalComposer>
  );
}
```

Should be nested inside [`LiveblocksPlugin`][].

<Banner title="Resolved threads">

The `AnchoredThreads` component automatically excludes resolved threads from
display. Any resolved threads passed in the threads list will not be shown.

</Banner>

#### Recommended usage [#AnchoredThreads-recommended-usage]

[`FloatingThreads`][] and [`AnchoredThreads`][] have been designed to work
together to provide the optimal experience on mobile and desktop. We generally
recommend using both components, hiding one on smaller screens, as we are below
with Tailwind classes. Most apps also donâ€™t need to display resolved threads, so
we can filter those out with a [`useThreads`][] option.

```tsx
import { useThreads } from "@liveblocks/react/suspense";
import { AnchoredThreads, FloatingThreads } from "@liveblocks/react-lexical";

function ThreadOverlay() {
  const { threads } = useThreads({ query: { resolved: false } });

  return (
    <>
      <FloatingThreads
        threads={threads}
        className="w-[350px] block md:hidden"
      />
      <AnchoredThreads
        threads={threads}
        className="w-[350px] hidden sm:block"
      />
    </>
  );
}
```

```tsx title="Alternatively use a media query hook" isCollapsed isCollapsable
import { useSyncExternalStore } from "react";
import { useThreads } from "@liveblocks/react/suspense";
import { AnchoredThreads, FloatingThreads } from "@liveblocks/react-lexical";

function ThreadOverlay() {
  const { threads } = useThreads({ query: { resolved: false } });
  // +++
  const isMobile = useIsMobile();
  // +++

  // +++
  if (isMobile) {
    return <FloatingThreads threads={threads} style={{ width: "350px" }} />;
  }
  // +++

  // +++
  return <AnchoredThreads threads={threads} style={{ width: "350px" }} />;
  // +++
}

export function useIsMobile() {
  return useSyncExternalStore(subscribe, getSnapshot, getSnapshot);
}

function subscribe(callback: () => void) {
  const query = window.matchMedia("(max-width: 1024px)");

  query.addEventListener("change", callback);
  return () => query.removeEventListener("change", callback);
}

function getSnapshot() {
  const query = window.matchMedia("(max-width: 1024px)");
  return query.matches;
}
```

We can place this component inside [`ClientSideSuspense`][] to prevent it
rendering until threads have loaded.

```tsx
<LexicalComposer initialConfig={initialConfig}>
  <LiveblocksPlugin>
    <FloatingComposer />
    // +++
    <ClientSideSuspense fallback={null}>
      <ThreadOverlay />
    </ClientSideSuspense>
    // +++
  </LiveblocksPlugin>
</LexicalComposer>
```

#### Customization [#AnchoredThreads-customization]

The `AnchoredThreads` component acts as a wrapper around each [`Thread`][]. It
has no width, so setting this is required, and each thread will take on the
width of the wrapper. You can treat the component like you would a `div`, using
classes, listeners, and more.

```tsx
<AnchoredThreads
  threads={threads}
  style={{ width: "350px" }}
  className="my-anchored-thread"
/>
```

To apply styling to each [`Thread`][], you can pass a custom `Thread` property
to `components` and modify this in any way.

```tsx
import { Thread } from "@liveblocks/react-ui";

<AnchoredThreads
  threads={threads}
  style={{ width: "350px" }}
  className="my-anchored-thread"
  // +++
  components={{
    Thread: (props) => (
      <Thread
        {...props}
        className="border shadow"
        style={{ background: "white" }}
      />
    ),
  }}
  // +++
/>;
```

You can return any custom `ReactNode` here, including anything from a simple
wrapper around `Thread`, up to a full custom `Thread` component built using our
[Comment primitives](/docs/api-reference/liveblocks-react-ui#primitives-Comment).

```tsx
import { Comment } from "@liveblocks/react-ui/primitives";

<AnchoredThreads
  threads={threads}
  style={{ width: "350px" }}
  className="my-anchored-thread"
  components={{
    Thread: (props) => (
      // +++
      <div>
        {props.thread.comments.map((comment) => (
          <Comment.Body
            key={comment.id}
            body={comment.body}
            components={/* ... */}
          />
        ))}
      </div>
      // +++
    ),
  }}
/>;
```

##### Modifying thread floating positions

Using CSS variables you can modify the gap between threads, and the horizontal
offset thatâ€™s added when a thread is selected.

```css
.lb-lexical-anchored-threads {
  /* Minimum gap between threads */
  --lb-lexical-anchored-threads-gap: 8px;

  /* How far the active thread is offset to the left */
  --lb-lexical-anchored-threads-active-thread-offset: 12px;
}
```

#### Props [#AnchoredThreads-props]

<PropertiesList>
  <PropertiesListItem name="threads" type="ThreadData[]" required>
    The threads to display.
  </PropertiesListItem>
  <PropertiesListItem
    name="components"
    type="Partial<AnchoredThreadsComponents>"
  >
    Override the componentâ€™s components.
  </PropertiesListItem>
  <PropertiesListItem
    name="components.Thread"
    type="(props: ThreadProps) => ReactNode"
  >
    Override the [`Thread`](/docs/api-reference/liveblocks-react-ui#Thread)
    component.
  </PropertiesListItem>
</PropertiesList>

### HistoryVersionPreview

The `HistoryVersionPreview` component allows you to display a preview of a
specific version of your Lexical editor's content. It also contains a button and
logic for restoring. It must be used inside the `<LiveblocksPlugin>` context. To
render a list of versions, see
[`VersionHistory`](/docs/api-reference/liveblocks-react-ui#Version-History).

#### Usage

```tsx
import { HistoryVersionPreview } from "@liveblocks/react-lexical";

function VersionPreview({ selectedVersion, onVersionRestore }) {
  return (
    <HistoryVersionPreview
      version={selectedVersion}
      onVersionRestore={onVersionRestore}
    />
  );
}
```

#### Props

<PropertiesList>
  <PropertiesListItem name="version" type="HistoryVersion" required>
    The version of the editor content to preview.
  </PropertiesListItem>
  <PropertiesListItem
    name="onVersionRestore"
    type="(version: HistoryVersion) => void"
  >
    Callback function called when the user chooses to restore this version.
  </PropertiesListItem>
</PropertiesList>

The `HistoryVersionPreview` component renders a read-only view of the specified
version of the editor content. It also provides a button for users to restore
the displayed version.

## Hooks

### useIsEditorReady

Used to check if the editor content has been loaded or not, helpful for
displaying a loading skeleton.

```ts
import { useIsEditorReady } from "@liveblocks/react-lexical";

const status = useIsEditorReady();
```

Hereâ€™s how it can be used in the context of your editor.

```tsx
import { LexicalComposer } from "@lexical/react/LexicalComposer";
import { RichTextPlugin } from "@lexical/react/LexicalRichTextPlugin";
import { ContentEditable } from "@lexical/react/LexicalContentEditable";
import { LexicalErrorBoundary } from "@lexical/react/LexicalErrorBoundary";
import {
  liveblocksConfig,
  LiveblocksPlugin,
  // +++
  useIsEditorReady,
  // +++
} from "@liveblocks/react-lexical";

const initialConfig = liveblocksConfig({
  namespace: "MyEditor",
  theme: {},
  nodes: [],
  onError: (err) => console.error(err),
});

function Editor() {
  // +++
  const ready = useIsEditorReady();
  // +++

  return (
    <LexicalComposer initialConfig={initialConfig}>
      <LiveblocksPlugin>
        <FloatingThreads />
        <FloatingComposer />
        <AnchoredThreads />
      </LiveblocksPlugin>
      // +++
      {!ready ? (
        <div>Loading...</div>
      ) : (
        <RichTextPlugin
          contentEditable={<ContentEditable />}
          placeholder={<div>Enter some text...</div>}
          ErrorBoundary={LexicalErrorBoundary}
        />
      )}
      // +++
    </LexicalComposer>
  );
}
```

### useIsThreadActive

Accepts a thread id and returns whether the thread annotation for this thread is
selected or not in the Lexical editor. This hook must be used in a component
nested inside [`LiveblocksPlugin`][].

```ts
import { useIsThreadActive } from "@liveblocks/react-lexical";

const isActive = useIsThreadActive(thread.id);
```

<PropertiesList title="Arguments">
  <PropertiesListItem name="threadId" type="string" required>
    The ID of the thread.
  </PropertiesListItem>
</PropertiesList>

This hook can be useful to style threads based on whether their associated
thread annotations are selected or not in the editor.

## Utilities

### isTextFormatActive

Checks if a text format (bold, italic, etc.) is active in the current selection.
Takes a Lexical editor, and returns a `boolean`.

```tsx
import { isTextFormatActive } from "@liveblocks/react-lexical";

// "true" | "false"
const isActive = isTextFormatActive(editor, "bold");
```

<PropertiesList title="Arguments">
  <PropertiesListItem name="editor" type="LexicalEditor" required>
    The Lexical editor.
  </PropertiesListItem>
  <PropertiesListItem name="format" type="TextFormatType" required>
    The Lexical text format to check for in the current selection.
  </PropertiesListItem>
</PropertiesList>

#### Creating toggle buttons

The `isTextFormatActive` helper is particularly useful for creating buttons with
[`Toolbar.Toggle`][].

```tsx
import { FORMAT_TEXT_COMMAND } from "lexical";
import { useLexicalComposerContext } from "@lexical/react/LexicalComposerContext";
// +++
import { isTextFormatActive, Toolbar } from "@liveblocks/react-lexical";
// +++

function CustomToggleButton() {
  const [editor] = useLexicalComposerContext();

  return (
    <Toolbar.Toggle
      name="Bold"
      icon={<strong>Bï¸</strong>}
      // +++
      active={isTextFormatActive(editor, "bold")}
      // +++
      onClick={() => editor.dispatchCommand(FORMAT_TEXT_COMMAND, "bold")}
    />
  );
}
```

### isBlockNodeActive

Checks if a block node is active in the current selection. If the selection
contains multiple block nodes, it will only return `true` if all of them are of
the same type.

```tsx
import { isBlockNodeActive } from "@liveblocks/react-lexical";
import { $isTextNode } from "lexical";

// Checking if text node is currently active
const isActive = isBlockNodeActive(editor, $isTextNode);
```

<PropertiesList title="Arguments">
  <PropertiesListItem name="editor" type="LexicalEditor" required>
    The Lexical editor.
  </PropertiesListItem>
  <PropertiesListItem
    name="isActive"
    type="(node: LexicalNode) => boolean"
    required
  >
    Function that passes the current node, helping you check if the current
    block node is active. Helpful in combination with `$is___Node` functions.
  </PropertiesListItem>
</PropertiesList>

#### Creating custom block selector items

The `isBlockNodeActive` helper is particularly useful for adding custom
[`Toolbar.BlockSelector`][] items.

```tsx
// +++
import { isBlockNodeActive, Toolbar } from "@liveblocks/react-lexical";
// +++
import { $setBlocksType } from "@lexical/selection";
import { $isCodeNode } from "@lexical/code";
import { $getSelection } from "lexical";

<Toolbar>
  <Toolbar.BlockSelector
    items={(defaultItems) => [
      ...defaultItems,
      {
        name: "Code block",
        icon: <div>â® â¯</div>,
        // +++
        isActive: (editor) => isBlockNodeActive(editor, $isCodeNode),
        // +++
        setActive: (editor) =>
          $setBlocksType($getSelection(), () => $createCodeNode()),
      },
    ]}
  />
</Toolbar>;
```

## Stylesheets

React Lexical comes with default styles, and these can be imported into the root
of your app or directly into a CSS file with `@import`. Note that you must also
install and import a stylesheet from
[`@liveblocks/react-ui`](/docs/api-reference/liveblocks-react-ui) to use these
styles.

```tsx
import "@liveblocks/react-ui/styles.css";
import "@liveblocks/react-lexical/styles.css";
```

### Customizing your styles

Adding dark mode and customizing your styles is part of `@liveblocks/react-ui`,
learn how to do this under
[styling and customization](/docs/api-reference/liveblocks-react-ui#Styling-and-customization).

## Deprecated

### useEditorStatus

<Banner title="Deprecated">

This is no longer supported. Starting with 2.12.0, we recommend using
[`useSyncStatus`][] instead for tracking sync status, because it will reflect
sync status of all parts of Liveblocks, not just Storage.

</Banner>

Returns the current editor status.

```ts
import { useEditorStatus } from "@liveblocks/react-lexical";

const status = useEditorStatus();
```

The possible values are:

- `not-loaded`: Initial editor state when entering the room.
- `loading`: Once the editor state has been requested by `LiveblocksPlugin`.
- `synchronized`: The editor state is sync with Liveblocks servers.

[`LiveblocksPlugin`]: #LiveblocksPlugin
[`LexicalComposer`]: https://lexical.dev/docs/react/plugins
[`Thread`]: /docs/api-reference/liveblocks-react-ui#Thread
[`Composer`]: /docs/api-reference/liveblocks-react-ui#Composer
[`useThreads`]: /docs/api-reference/liveblocks-react#useThreads
[`Icon`]: /docs/api-reference/liveblocks-react-ui#Icon
[`Toolbar`]: #Toolbar
[`Toolbar.Button`]: #Toolbar.Button
[`Toolbar.Toggle`]: #Toolbar.Toggle
[`Toolbar.BlockSelector`]: #Toolbar.BlockSelector
[`Toolbar.Separator`]: #Toolbar.Separator
[`Toolbar.SectionHistory`]: #Toolbar.SectionHistory
[`Toolbar.SectionInline`]: #Toolbar.SectionInline
[`Toolbar.SectionCollaboration`]: #Toolbar.SectionCollaboration
[`FloatingToolbar`]: #FloatingToolbar
[`FloatingComposer`]: #FloatingComposer
[`FloatingThreads`]: #FloatingThreads
[`AnchoredThreads`]: #AnchoredThreads
[`ClientSideSuspense`]: /docs/api-reference/liveblocks-react#ClientSideSuspense
[`useSyncStatus`]: /docs/api-reference/liveblocks-react#useSyncStatus

---
meta:
  title: "@liveblocks/react-tiptap"
  parentTitle: "API Reference"
  description: "API Reference for the @liveblocks/react-tiptap package"
alwaysShowAllNavigationLevels: false
---

`@liveblocks/react-tiptap` provides you with a [React](https://react.dev/)
plugin that adds collaboration to any [Tiptap](https://tiptap.dev/) text editor.
It also adds realtime cursors, document persistence on the cloud, comments, and
mentions. Read our [get started guides](/docs/get-started/text-editor/tiptap) to
learn more. Use
[`@liveblocks/node-prosemirror`](/docs/api-reference/liveblocks-node-prosemirror)
for server-side editing.

## Setup

To set up your collaborative Tiptap editor, add
[`useLiveblocksExtension`](#useLiveblocksExtension) to your editor, passing the
return value `useEditor` extension array.

```tsx
import { useLiveblocksExtension } from "@liveblocks/react-tiptap";
import { useEditor, EditorContent } from "@tiptap/react";

function TextEditor() {
  // +++
  const liveblocks = useLiveblocksExtension();
  // +++

  const editor = useEditor({
    extensions: [
      // +++
      liveblocks,
      // +++
      // ...
    ],
  });

  return (
    <div>
      <EditorContent editor={editor} />
    </div>
  );
}
```

Liveblocks Tiptap components should be passed `editor` to enable them.

```tsx
import {
  useLiveblocksExtension,
  // +++
  FloatingComposer,
  // +++
} from "@liveblocks/react-tiptap";
import { useEditor, EditorContent } from "@tiptap/react";

function TextEditor() {
  const liveblocks = useLiveblocksExtension();

  const editor = useEditor({
    extensions: [
      liveblocks,
      // ...
    ],
  });

  return (
    <div>
      <EditorContent editor={editor} />
      // +++
      <FloatingComposer editor={editor} style={{ width: "350px" }} />
      // +++
    </div>
  );
}
```

Learn more in our [get started guides](/docs/get-started/text-editor/tiptap).

## Default components

### Toolbar

Displays a toolbar, allowing you to change the styles of selected text. You can
add content [before or after](#toolbar-extending-the-defaults), or the toolbarâ€™s
options can be [customized](#creating-a-custom-toolbar). A
[floating toolbar](#FloatingToolbar) also exists.

```tsx
<Toolbar editor={editor} />
```

<Figure>
  <Image
    src="/assets/text-editor/toolbar.png"
    alt="Toolbar"
    width={960}
    height={558}
  />
</Figure>

Pass your Tiptap `editor` to use the component. By default, one of the toolbar
buttons can create comment threadsâ€”to enable this add [`FloatingComposer`][] and
display threads with [`AnchoredThreads`][] or [`FloatingThreads`][].

```tsx
import {
  useLiveblocksExtension,
  // +++
  Toolbar,
  // +++
  FloatingComposer,
  FloatingThreads,
} from "@liveblocks/react-tiptap";
import { useEditor, EditorContent } from "@tiptap/react";

function TextEditor() {
  const liveblocks = useLiveblocksExtension();

  const editor = useEditor({
    extensions: [
      liveblocks,
      // ...
    ],
  });

  return (
    <div>
      // +++
      <Toolbar editor={editor} />
      // +++
      <EditorContent editor={editor} />
      <FloatingComposer editor={editor} style={{ width: "350px" }} />
      <FloatingThreads editor={editor} style={{ width: "350px" }} />
    </div>
  );
}
```

#### Extending the defaults [#toolbar-extending-the-defaults]

You can insert content `before` the first button and `after` the last button
using `before` and `after`. Components such as [`Toolbar.Button`][] and
[`Toolbar.Toggle`][] can be used to create new buttons.

```tsx
import { Toolbar } from "@liveblocks/react-tiptap";
import { Icon } from "@liveblocks/react-ui";

<Toolbar
  editor={editor}
  // +++
  before={<>I'm at the start</>}
  after={
    <Toolbar.Button
      name="Help"
      icon={<Icon.QuestionMark />}
      shortcut="CMD-H"
      onClick={() => console.log("help")}
    />
  }
  // +++
/>;
```

For more complex customization, instead read
[creating a custom floating toolbar](#creating-a-custom-toolbar).

#### Creating a custom toolbar [#creating-a-custom-toolbar]

By passing elements as children, itâ€™s possible to create a fully custom toolbar.

```tsx highlight="7"
import { Toolbar } from "@liveblocks/react-tiptap";
import { Editor } from "@tiptap/react";

function CustomToolbar({ editor }: { editor: Editor | null }) {
  return (
    <Toolbar editor={editor}>
      Hello <strong>world</strong>
    </Toolbar>
  );
}
```

Each part of our default toolbar is available as blocks which can be slotted
together. This is how the default toolbar is constructed:

```tsx
import { Toolbar } from "@liveblocks/react-tiptap";
import { Editor } from "@tiptap/react";

function CustomToolbar({ editor }: { editor: Editor | null }) {
  return (
    <Toolbar editor={editor}>
      // +++
      <Toolbar.BlockSelector />
      <Toolbar.SectionInline />
      <Toolbar.Separator />
      <Toolbar.SectionCollaboration />
      // +++
    </Toolbar>
  );
}
```

You can mix these default components with any custom ones of your own. Below the
[`Toolbar.SectionHistory`][] component is added alongside some custom buttons
created with [`Toolbar.Button`][], [`Toolbar.Toggle`][], and [`Icon`][]. The
highlight toggle button requires a
[Tiptap extension](https://tiptap.dev/docs/editor/extensions/marks/highlight).

```tsx
import { Toolbar } from "@liveblocks/react-tiptap";
import { Icon } from "@liveblocks/react-ui";
import { Editor } from "@tiptap/react";

function CustomToolbar({ editor }: { editor: Editor | null }) {
  return (
    <Toolbar editor={editor}>
      // +++
      <Toolbar.SectionHistory />
      <Toolbar.Separator />
      <Toolbar.Button
        name="Help"
        icon={<Icon.QuestionMark />}
        shortcut="CMD-H"
        onClick={() => console.log("help")}
      />
      <Toolbar.Toggle
        name="Highlight"
        icon={<div>ðŸ–Šï¸</div>}
        active={editor?.isActive("highlight") ?? false}
        onClick={() => editor?.chain().focus().toggleHighlight().run()}
        disabled={!editor?.can().chain().focus().toggleHighlight().run()}
      />
      // +++
    </Toolbar>
  );
}
```

To learn more about the different components, read more below.

#### Props [#Toolbar-props]

<PropertiesList>
  <PropertiesListItem name="editor" type="Editor | null" required>
    The Tiptap editor.
  </PropertiesListItem>
  <PropertiesListItem name="children" type="ReactNode">
    The content of the toolbar, overriding the default content. Use the `before`
    and `after` props if you want to keep and extend the default content. Any
    `ReactNode` or `Toolbar.*` components work inside.
  </PropertiesListItem>
  <PropertiesListItem name="before" type="ReactNode">
    The content to display at the start of the toolbar. Any `ReactNode` or
    `Toolbar.*` components work inside.
  </PropertiesListItem>
  <PropertiesListItem name="after" type="ReactNode">
    The content to display at the end of the toolbar. Any `ReactNode` or
    `Toolbar.*` components work inside.
  </PropertiesListItem>
</PropertiesList>

#### Toolbar.Button

A button for triggering actions. The `name` is displayed in a tooltip. Props
such as `onClick` will be passed to the underlying `button` element.

```tsx
import { Toolbar } from "@liveblocks/react-tiptap";

<Toolbar editor={editor}>
  <Toolbar.Button name="Question" onClick={(e) => console.log("Clicked")} />
</Toolbar>;
```

Optionally takes an icon which will visually replace the `name`. Also optionally
accepts a shortcut, which is displayed in the tooltip. Comment key names are
converted to symbols. Here are various examples.

```tsx
import { Toolbar } from "@liveblocks/react-tiptap";
import { Icon } from "@liveblocks/react-ui";

// Button says "Question"
<Toolbar.Toggle name="Question" onClick={/* ... */} />

// Tooltip says "Question [âŒ˜+Q]"
<Toolbar.Button name="Question" shortcut="CMD+Q" onClick={/* ... */} />

// Custom icon, replaces the name in the button
<Toolbar.Button name="Question" icon={<div>?</div>} onClick={/* ... */} />

// Using a Liveblocks icon, replaces the name in the button
<Toolbar.Button name="Question" icon={<Icon.QuestionMark />} onClick={/* ... */} />

// Passing children visually replaces the `name` and `icon`
<Toolbar.Button name="Question" onClick={/* ... */}>
  ? Ask a question
</Toolbar.Button>

// Props are passed to the inner `button`
<Toolbar.Button
  name="Question"
  style={{ marginLeft: 10 }}
  className="custom-button"
  onMouseOver={() => console.log("Hovered")}
/>
```

##### Props [#ToolbarButton-props]

<PropertiesList>
  <PropertiesListItem name="name" type="string" required>
    The name of this button displayed in its tooltip. Will also be displayed in
    the button if no `icon` or `children` are passed.
  </PropertiesListItem>
  <PropertiesListItem name="icon" type="ReactNode">
    An optional icon displayed in this button.
  </PropertiesListItem>
  <PropertiesListItem name="shortcut" type="string">
    An optional keyboard shortcut displayed in this buttonâ€™s tooltip. Common
    shortcuts such will be replaced by their symbols, for example `CMD` â†’ `âŒ˜`.
  </PropertiesListItem>
</PropertiesList>

#### Toolbar.Toggle

A toggle button for values that can be active or inactive. Best used with text
editor commands. The `name` is displayed in a tooltip. Props will be passed to
the underlying `button` element.

```tsx
import { Toolbar } from "@liveblocks/react-tiptap";

<Toolbar editor={editor}>
  <Toolbar.Toggle
    name="Highlight"
    active={editor?.isActive("highlight") ?? false}
    onClick={() => editor?.chain().focus().toggleHighlight().run()}
  />
</Toolbar>;
```

The snippet above shows how to use the Toggle with the
[Tiptap highlight extension](https://tiptap.dev/docs/editor/extensions/marks/highlight).
The toggle button can also be toggled with `useState`.

```tsx
import { Toolbar } from "@liveblocks/react-tiptap";
import { Editor } from "@tiptap/react";
import { useState } from "react";

function CustomToggle({ editor }: { editor: Editor | null }) {
  const [active, setActive] = useState(false);

  return (
    <Toolbar.Toggle
      name="Toggle options"
      active={active}
      onClick={() => setActive(!active)}
    />
  );
}
```

`Toolbar.Toggle` optionally takes an icon which will visually replace the
`name`. Also optionally accepts a shortcut, which is displayed in the tooltip.
Comment key names are converted to symbols. Here are various examples.

```tsx
import { Toolbar } from "@liveblocks/react-tiptap";
import { Icon } from "@liveblocks/react-ui";

// Button says "Highlight"
<Toolbar.Toggle
  name="Highlight"
  active={/* ... */}
  onClick={/* ... */}
/>

// Tooltip says "Highlight [âŒ˜+H]"
<Toolbar.Toggle
  name="Highlight"
  shortcut="CMD+H"
  active={/* ... */}
  onClick={/* ... */}
/>

// Custom icon, replaces the name in the button
<Toolbar.Toggle
  name="Highlight"
  icon={<div>ðŸ–Š</div>}
  active={/* ... */}
  onClick={/* ... */}
/>

// Using a Liveblocks icon, replaces the name in the button
<Toolbar.Toggle
  name="Highlight"
  icon={<Icon.QuestionMark />}
  active={/* ... */}
  onClick={/* ... */}
/>

// Passing children visually replaces the `name` and `icon`
<Toolbar.Toggle
  name="Highlight"
  active={/* ... */}
  onClick={/* ... */}
>
  ðŸ–Šï¸Highlight
</Toolbar.Toggle>

// Props are passed to the inner `button`
<Toolbar.Toggle
  name="Highlight"
  active={/* ... */}
  onClick={/* ... */}
  style={{ marginLeft: 10 }}
  className="custom-toggle"
  onMouseOver={() => console.log("Hovered")}
/>
```

##### Props [#ToolbarToggle-props]

<PropertiesList>
  <PropertiesListItem name="name" type="string" required>
    The name of this button displayed in its tooltip. Will also be displayed in
    the button if no `icon` or `children` are passed.
  </PropertiesListItem>
  <PropertiesListItem name="active" type="boolean" required>
    Whether the button is toggled.
  </PropertiesListItem>
  <PropertiesListItem name="icon" type="ReactNode">
    An optional icon displayed in this button.
  </PropertiesListItem>
  <PropertiesListItem name="shortcut" type="string">
    An optional keyboard shortcut displayed in this buttonâ€™s tooltip. Common
    shortcuts such will be replaced by their symbols, for example `CMD` â†’ `âŒ˜`.
  </PropertiesListItem>
</PropertiesList>

#### Toolbar.BlockSelector

Adds a dropdown selector for switching between different block types, such as
_text_, _heading 1_, _blockquote_. Props will be passed to the inner `button`
element. Can also be placed inside [`FloatingToolbar`][].

```tsx
import { Toolbar } from "@liveblocks/react-tiptap";

<Toolbar editor={editor}>
  <Toolbar.BlockSelector />
</Toolbar>;
```

##### Use custom item options

If youâ€™d like to change the items shown in the dropdown menu, you can pass a
custom `items` array. Below a code block item
([Tiptap extension](https://tiptap.dev/docs/editor/extensions/nodes/code-block))
is added after the default options.

```tsx
import { Toolbar } from "@liveblocks/react-tiptap";

<Toolbar editor={editor}>
  <Toolbar.BlockSelector
    items={(defaultItems) => [
      ...defaultItems,
      {
        name: "Code block",
        icon: <div>â® â¯</div>, // Optional
        isActive: (editor) => editor.isActive("codeBlock"),
        setActive: (editor) =>
          editor.chain().focus().clearNodes().toggleCodeBlock().run(),
      },
    ]}
  />
</Toolbar>;
```

##### Customize item styles

By passing a `label` property, you can overwrite the styles of the dropdown
items. The toolbar button will still display the `name`, but in the dropdown,
the `label` will be used instead of the `name` and `icon`. Below, a new item is
added and its `label` is customized.

```tsx
import { Toolbar } from "@liveblocks/react-tiptap";

<Toolbar editor={editor}>
  <Toolbar.BlockSelector
    items={(defaultItems) => [
      ...defaultItems,
      {
        name: "Code block",
        // +++
        label: <div className="font-mono">Code</div>, // Optional, overwrites `icon` + `name`
        // +++
        isActive: (editor) => editor.isActive("codeBlock"),
        setActive: (editor) =>
          editor.chain().focus().clearNodes().toggleCodeBlock().run(),
      },
    ]}
  />
</Toolbar>;
```

You can also customize the default items. Below each item is styled to represent
the effect each block applies to the document.

```tsx
import { Toolbar } from "@liveblocks/react-tiptap";

<Toolbar.BlockSelector
  items={(defaultItems) =>
    defaultItems.map((item) => {
      let label;

      if (item.name === "Text") {
        label = <span>Regular text</span>;
      }

      if (item.name === "Heading 1") {
        label = (
          <span style={{ fontSize: 18, fontWeight: "bold" }}>Heading 1</span>
        );
      }

      if (item.name === "Heading 2") {
        label = (
          <span style={{ fontSize: 16, fontWeight: "bold" }}>Heading 2</span>
        );
      }

      if (item.name === "Heading 3") {
        label = (
          <span style={{ fontSize: 15, fontWeight: "bold" }}>Heading 3</span>
        );
      }

      if (item.name === "Blockquote") {
        label = (
          <span style={{ borderLeft: "3px solid gray", paddingLeft: 8 }}>
            Blockquote
          </span>
        );
      }

      return {
        ...item,
        label,
        icon: null, // Hide all icons
      };
    })
  }
/>;
```

##### Props [#ToolbarBlockSelector-props]

<PropertiesList>
  <PropertiesListItem
    name="items"
    type="array | function"
    detailedType="ToolbarBlockSelectorItem[] | (defaultItems: ToolbarBlockSelectorItem[]) => ToolbarBlockSelectorItem[]"
  >
    The items displayed in this block selector. When provided as an array, the
    default items are overridden. To avoid this, a function can be provided
    instead and it will receive the default items.
  </PropertiesListItem>
</PropertiesList>

#### Toolbar.Separator

Adds a visual, and accessible, separator used to separate sections in the
toolbar. Props will be passed to the inner `div` element. Can also be placed
inside [`FloatingToolbar`][].

```tsx
import { Toolbar } from "@liveblocks/react-tiptap";

<Toolbar editor={editor}>
  // +++
  <Toolbar.SectionHistory />
  // +++
</Toolbar>;
```

#### Toolbar.SectionHistory

Adds a section containing _undo_ and _redo_ buttons. Can also be placed inside
[`FloatingToolbar`][].

```tsx
import { Toolbar } from "@liveblocks/react-tiptap";

<Toolbar editor={editor}>
  // +++
  <Toolbar.SectionHistory />
  // +++
</Toolbar>;
```

#### Toolbar.SectionInline

Adds a section containing inline formatting actions such as _bold_, _italic_,
_underline_. Can also be placed inside [`FloatingToolbar`][].

```tsx
import { Toolbar } from "@liveblocks/react-tiptap";

<Toolbar editor={editor}>
  // +++
  <Toolbar.SectionInline />
  // +++
</Toolbar>;
```

#### Toolbar.SectionCollaboration

Adds a section containing an _add comment_ button. Can also be placed inside
[`FloatingToolbar`][].

```tsx
import { Toolbar } from "@liveblocks/react-tiptap";

<Toolbar editor={editor}>
  // +++
  <Toolbar.SectionCollaboration />
  // +++
</Toolbar>;
```

### FloatingToolbar

Displays a floating toolbar near the current Tiptap selection, allowing you to
change styles. You can add content
[before or after](#floating-toolbar-extending-the-defaults), or the toolbarâ€™s
options can be [customized](#creating-a-custom-floating-toolbar). A
[static toolbar](#Toolbar) also exists.

```tsx
<FloatingToolbar editor={editor} />
```

<Figure>
  <Image
    src="/assets/text-editor/floating-toolbar.png"
    alt="FloatingToolbar"
    width={960}
    height={558}
  />
</Figure>

Pass your Tiptap `editor` to use the component. By default, one of the toolbar
buttons can create comment threadsâ€”to enable this add [`FloatingComposer`][] and
display threads with [`AnchoredThreads`][] or [`FloatingThreads`][].

```tsx
import {
  useLiveblocksExtension,
  // +++
  FloatingToolbar,
  // +++
  FloatingComposer,
  FloatingThreads,
} from "@liveblocks/react-tiptap";
import { useEditor, EditorContent } from "@tiptap/react";

function TextEditor() {
  const liveblocks = useLiveblocksExtension();

  const editor = useEditor({
    extensions: [
      liveblocks,
      // ...
    ],
  });

  return (
    <div>
      <EditorContent editor={editor} />
      // +++
      <FloatingToolbar editor={editor} />
      // +++
      <FloatingComposer editor={editor} style={{ width: "350px" }} />
      <FloatingThreads editor={editor} style={{ width: "350px" }} />
    </div>
  );
}
```

#### Changing float position

Using `position` and `offset` you can reposition the toolbar relative to the
current selection. `position` can be set to `"top"` or `"bottom"`, and `offset`
defines the vertical distance in pixels from the selection.

```tsx
<FloatingToolbar
  editor={editor}
  // +++
  position="bottom" // Position can be `top` or `bottom`
  offset={12} // Distance in px from selection
  // +++
/>
```

#### Extending the defaults [#floating-toolbar-extending-the-default]

You can insert custom content `before` the first button and `after` the last
button using `before` and `after`. Components such as [`Toolbar.Button`][] and
[`Toolbar.Toggle`][] can be used to create new buttons.

```tsx
import { Toolbar } from "@liveblocks/react-tiptap";
import { Icon } from "@liveblocks/react-ui";

<FloatingToolbar
  editor={editor}
  // +++
  before={<>I'm at the start</>}
  after={
    <Toolbar.Button
      name="Help"
      icon={<Icon.QuestionMark />}
      shortcut="CMD-H"
      onClick={() => console.log("help")}
    />
  }
  // +++
/>;
```

For more complex customization, instead read
[creating a custom floating toolbar](#creating-a-custom-floating-toolbar).

#### Creating a custom floating toolbar [#creating-a-custom-floating-toolbar]

By passing elements as children, itâ€™s possible to create a fully custom floating
toolbar.

```tsx highlight="7"
import { FloatingToolbar } from "@liveblocks/react-tiptap";
import { Editor } from "@tiptap/react";

function CustomToolbar({ editor }: { editor: Editor | null }) {
  return (
    <FloatingToolbar editor={editor}>
      Hello <strong>world</strong>
    </FloatingToolbar>
  );
}
```

Each part of our default toolbar is available as blocks which can be slotted
together. This is how the default floating toolbar is constructed:

```tsx
import { FloatingToolbar, Toolbar } from "@liveblocks/react-tiptap";
import { Editor } from "@tiptap/react";

function CustomToolbar({ editor }: { editor: Editor | null }) {
  return (
    <FloatingToolbar editor={editor}>
      // +++
      <Toolbar.BlockSelector />
      <Toolbar.SectionInline />
      <Toolbar.Separator />
      <Toolbar.SectionCollaboration />
      // +++
    </FloatingToolbar>
  );
}
```

You can mix these default components with any custom ones of your own. Below the
[`Toolbar.SectionHistory`][] component is added alongside some custom buttons
created with [`Toolbar.Button`][], [`Toolbar.Toggle`][], and [`Icon`][]. The
highlight toggle button requires a
[Tiptap extension](https://tiptap.dev/docs/editor/extensions/marks/highlight).

```tsx
import { FloatingToolbar, Toolbar } from "@liveblocks/react-tiptap";
import { Icon } from "@liveblocks/react-ui";
import { Editor } from "@tiptap/react";

function CustomToolbar({ editor }: { editor: Editor | null }) {
  return (
    <FloatingToolbar editor={editor}>
      // +++
      <Toolbar.SectionHistory />
      <Toolbar.Separator />
      <Toolbar.Button
        name="Help"
        icon={<Icon.QuestionMark />}
        shortcut="CMD-H"
        onClick={() => console.log("help")}
      />
      <Toolbar.Toggle
        name="Highlight"
        icon={<div>ðŸ–Šï¸</div>}
        active={editor?.isActive("highlight") ?? false}
        onClick={() => editor?.chain().focus().toggleHighlight().run()}
        disabled={!editor?.can().chain().focus().toggleHighlight().run()}
      />
      // +++
    </FloatingToolbar>
  );
}
```

To learn more about the different components, read more under [`Toolbar`][].

#### Props [#FloatingToolbar-props]

<PropertiesList>
  <PropertiesListItem name="editor" type="Editor | null" required>
    The Tiptap editor.
  </PropertiesListItem>
  <PropertiesListItem name="position" type={`"top" | "bottom"`}>
    The vertical position of the floating toolbar.
  </PropertiesListItem>
  <PropertiesListItem name="offset" type="number">
    The vertical offset of the floating toolbar from the selection.
  </PropertiesListItem>
  <PropertiesListItem name="children" type="ReactNode">
    The content of the toolbar, overriding the default content. Use the `before`
    and `after` props if you want to keep and extend the default content. Any
    `ReactNode` or `Toolbar.*` components work inside.
  </PropertiesListItem>
  <PropertiesListItem name="before" type="ReactNode">
    The content to display at the start of the toolbar. Any `ReactNode` or
    `Toolbar.*` components work inside.
  </PropertiesListItem>
  <PropertiesListItem name="after" type="ReactNode">
    The content to display at the end of the toolbar. Any `ReactNode` or
    `Toolbar.*` components work inside.
  </PropertiesListItem>
</PropertiesList>

### FloatingComposer

Displays a [`Composer`][] near the current Tiptap selection, allowing you to
create threads.

```tsx highlight="3"
<FloatingComposer editor={editor} />
```

<Figure>
  <Image
    src="/assets/text-editor/floating-composer.jpg"
    alt="FloatingComposer"
    width={960}
    height={558}
  />
</Figure>

Submitting a comment will attach an annotation thread at the current selection.
Should be passed your Tiptap `editor`, and itâ€™s recommended you set a width
value. Display created threads with [`AnchoredThreads`][] or
[`FloatingThreads`][].

```tsx
import {
  useLiveblocksExtension,
  // +++
  FloatingComposer,
  // +++
  FloatingThreads,
} from "@liveblocks/react-tiptap";
import { useEditor, EditorContent } from "@tiptap/react";

function TextEditor() {
  const liveblocks = useLiveblocksExtension();

  const editor = useEditor({
    extensions: [
      liveblocks,
      // ...
    ],
  });

  return (
    <div>
      <EditorContent editor={editor} />
      // +++
      <FloatingComposer editor={editor} style={{ width: "350px" }} />
      // +++
      <FloatingThreads editor={editor} style={{ width: "350px" }} />
    </div>
  );
}
```

#### Opening the composer

To open the `FloatingComposer`, you need to click the â€œCommentâ€ button in the
[`Toolbar`][] or call the `addPendingComment`
[command](https://tiptap.dev/docs/editor/api/commands) added by Liveblocks. You
can use `liveblocksCommentMark` to check if the current selection is a comment.

```tsx
import { Editor } from "@tiptap/react";

function Toolbar({ editor }: { editor: Editor | null }) {
  if (!editor) {
    return null;
  }

  return (
    <button
      onClick={() => {
        // +++
        editor.chain().focus().addPendingComment().run();
        // +++
      }}
      // +++
      data-active={editor.isActive("liveblocksCommentMark")}
      // +++
    >
      ðŸ’¬ New comment
    </button>
  );
}
```

#### Customization [#FloatingComposer-customization]

The `FloatingComposer` component acts as a wrapper around a [`Composer`][], near
the current selection. You can treat the component like you would a `form`,
using classes, listeners, and more.

```tsx
<FloatingComposer
  editor={editor}
  style={{ width: "350px" }}
  className="my-floating-composer"
/>
```

To apply styling to the composer, you can pass a custom `Composer` property to
`components` and modify this in any way.

```tsx
import { Composer } from "@liveblocks/react-ui";

<FloatingComposer
  editor={editor}
  style={{ width: "350px" }}
  // +++
  components={{
    Composer: (props) => (
      <Composer
        {...props}
        className="border shadow"
        style={{ width: "300px" }}
      />
    ),
  }}
  // +++
/>;
```

You can return any custom `ReactNode` here, including anything from a simple
wrapper around `Composer`, up to a full custom `Composer` component built using
our
[Composer primitives](/docs/api-reference/liveblocks-react-ui#primitives-Composer).

```tsx
import { Composer } from "@liveblocks/react-ui/primitives";

<FloatingComposer
  editor={editor}
  style={{ width: "350px" }}
  components={{
    Composer: ({ onComposerSubmit }) => (
      // +++
      <Composer.Form onComposerSubmit={onComposerSubmit}>
        <Composer.Editor />
        <Composer.Submit>Send</Composer.Submit>
      </Composer.Form>
      // +++
    ),
  }}
/>;
```

You can also customize submission behavior by passing a custom
`onComposerSubmit` function to the `Composer.Form` component.

```tsx
import { Composer } from "@liveblocks/react-ui/primitives";

<FloatingComposer
  editor={editor}
  style={{ width: "350px" }}
  components={{
    Composer: () => (
      <Composer.Form
        // +++
          onComposerSubmit={(comment, event) => {
            event.preventDefault();

            const thread = createThread({
              body: comment.body,
              attachments: comment.attachments,
              metadata: ...,
            });

            editor.commands.addComment(thread.id);
          }}
          // +++
        >
          <Composer.Editor />
          <Composer.Submit>Send</Composer.Submit>
        </Composer.Form>
      ),
  }}
/>;
```

#### Props [#FloatingComposer-props]

<PropertiesList>
  <PropertiesListItem name="metadata" type="ThreadMetadata">
    The metadata of the thread to create.
  </PropertiesListItem>
  <PropertiesListItem name="commentMetadata" type="CommentMetadata">
    The metadata of the comment to create.
  </PropertiesListItem>
  <PropertiesListItem
    name="onComposerSubmit"
    type="function"
    detailedType="(comment: ComposerSubmitComment, event: FormEvent<HTMLFormElement>) => Promise<void> | void"
  >
    The event handler called when the composer is submitted.
  </PropertiesListItem>
  <PropertiesListItem name="defaultValue" type="CommentBody">
    The composerâ€™s initial value.
  </PropertiesListItem>
  <PropertiesListItem name="collapsed" type="boolean">
    Whether the composer is collapsed. Setting a value will make the composer
    controlled.
  </PropertiesListItem>
  <PropertiesListItem
    name="onCollapsedChange"
    type="function"
    detailedType="(collapsed: boolean) => void"
  >
    The event handler called when the collapsed state of the composer changes.
  </PropertiesListItem>
  <PropertiesListItem name="defaultCollapsed" type="boolean">
    Whether the composer is initially collapsed. Setting a value will make the
    composer uncontrolled.
  </PropertiesListItem>
  <PropertiesListItem name="disabled" type="boolean">
    Whether the composer is disabled.
  </PropertiesListItem>
  <PropertiesListItem name="autoFocus" type="boolean">
    Whether to focus the composer on mount.
  </PropertiesListItem>
  <PropertiesListItem
    name="overrides"
    type="Partial<GlobalOverrides & ComposerOverrides>"
  >
    Override the componentâ€™s strings.
  </PropertiesListItem>
  <PropertiesListItem
    name="components"
    type="Partial<FloatingComposerComponents>"
  >
    Override the componentâ€™s components.
  </PropertiesListItem>
  <PropertiesListItem
    name="components.Composer"
    type="(props: ComposerProps) => ReactNode"
  >
    Override the [`Composer`](/docs/api-reference/liveblocks-react-ui#Composer)
    component.
  </PropertiesListItem>
</PropertiesList>

### FloatingThreads

Displays floating [`Thread`][] components below text highlights in the editor.

```tsx highlight="3"
<FloatingThreads editor={editor} threads={threads} />
```

<Figure>
  <Image
    src="/assets/text-editor/floating-threads.jpg"
    alt="FloatingThreads"
    width={960}
    height={558}
  />
</Figure>

Takes a list of threads retrieved from [`useThreads`][] and renders them to the
page. Each thread is opened by clicking on its corresponding text highlight.
Should be passed your Tiptap `editor`, and itâ€™s recommended you set a width
value.

```tsx
// +++
import { useThreads } from "@liveblocks/react/suspense";
// +++
import {
  useLiveblocksExtension,
  FloatingComposer,
  // +++
  FloatingThreads,
  // +++
} from "@liveblocks/react-tiptap";
import { useEditor, EditorContent } from "@tiptap/react";

function TextEditor() {
  const liveblocks = useLiveblocksExtension();

  const editor = useEditor({
    extensions: [
      liveblocks,
      // ...
    ],
  });

  // +++
  const { threads } = useThreads();
  // +++

  return (
    <div>
      <EditorContent editor={editor} />
      <FloatingComposer editor={editor} style={{ width: "350px" }} />
      // +++
      <FloatingThreads
        editor={editor}
        threads={threads}
        style={{ width: "350px" }}
      />
      // +++
    </div>
  );
}
```

<Banner title="Resolved threads">

The `FloatingThreads` component automatically excludes resolved threads from
display. Any resolved threads passed in the threads list will not be shown.

</Banner>

#### Recommended usage [#FloatingThreads-recommended-usage]

[`FloatingThreads`][] and [`AnchoredThreads`][] have been designed to work
together to provide the optimal experience on mobile and desktop. We generally
recommend using both components, hiding one on smaller screens, as we are below
with Tailwind classes. Most apps also donâ€™t need to display resolved threads, so
we can filter those out with a [`useThreads`][] option.

```tsx
import { useThreads } from "@liveblocks/react/suspense";
import { AnchoredThreads, FloatingThreads } from "@liveblocks/react-tiptap";
import { Editor } from "@tiptap/react";

function ThreadOverlay({ editor }: { editor: Editor | null }) {
  const { threads } = useThreads({ query: { resolved: false } });

  return (
    <>
      <FloatingThreads
        editor={editor}
        threads={threads}
        className="w-[350px] block md:hidden"
      />
      <AnchoredThreads
        editor={editor}
        threads={threads}
        className="w-[350px] hidden sm:block"
      />
    </>
  );
}
```

```tsx title="Alternatively use a media query hook" isCollapsed isCollapsable
import { useSyncExternalStore } from "react";
import { useThreads } from "@liveblocks/react/suspense";
import { AnchoredThreads, FloatingThreads } from "@liveblocks/react-tiptap";
import { Editor } from "@tiptap/react";

function ThreadOverlay({ editor }: { editor: Editor | null }) {
  const { threads } = useThreads({ query: { resolved: false } });
  // +++
  const isMobile = useIsMobile();
  // +++

  // +++
  if (isMobile) {
    return (
      <FloatingThreads
        editor={editor}
        threads={threads}
        style={{ width: "350px" }}
      />
    );
  }
  // +++

  // +++
  return (
    <AnchoredThreads
      editor={editor}
      threads={threads}
      style={{ width: "350px" }}
    />
  );
  // +++
}

export function useIsMobile() {
  return useSyncExternalStore(subscribe, getSnapshot, getSnapshot);
}

function subscribe(callback: () => void) {
  const query = window.matchMedia("(max-width: 1024px)");

  query.addEventListener("change", callback);
  return () => query.removeEventListener("change", callback);
}

function getSnapshot() {
  const query = window.matchMedia("(max-width: 1024px)");
  return query.matches;
}
```

We can place this component inside [`ClientSideSuspense`][] to prevent it
rendering until threads have loaded.

```tsx
<div>
  <EditorContent editor={editor} />
  <FloatingComposer editor={editor} style={{ width: "350px" }} />
  // +++
  <ClientSideSuspense fallback={null}>
    <ThreadOverlay editor={editor} />
  </ClientSideSuspense>
  // +++
</div>
```

#### Customization [#FloatingThreads-customization]

The `FloatingThreads` component acts as a wrapper around each individual
[`Thread`][]. You can treat the component like you would a `div`, using classes,
listeners, and more.

```tsx
<FloatingThreads
  editor={editor}
  threads={threads}
  className="my-floating-thread"
/>
```

To apply styling to each [`Thread`][], you can pass a custom `Thread` property
to `components` and modify this in any way. This is the best way to modify a
threadâ€™s width.

```tsx
import { Thread } from "@liveblocks/react-ui";

<FloatingThreads
  editor={editor}
  threads={threads}
  className="my-floating-thread"
  // +++
  components={{
    Thread: (props) => (
      <Thread {...props} className="border shadow" style={{ width: "300px" }} />
    ),
  }}
  // +++
/>;
```

You can return any custom `ReactNode` here, including anything from a simple
wrapper around `Thread`, up to a full custom `Thread` component built using our
[Comment primitives](/docs/api-reference/liveblocks-react-ui#primitives-Comment).

```tsx
import { Comment } from "@liveblocks/react-ui/primitives";

<FloatingThreads
  editor={editor}
  threads={threads}
  className="my-floating-thread"
  components={{
    Thread: (props) => (
      // +++
      <div>
        {props.thread.comments.map((comment) => (
          <Comment.Body
            key={comment.id}
            body={comment.body}
            components={/* ... */}
          />
        ))}
      </div>
      // +++
    ),
  }}
/>;
```

#### Props [#FloatingThreads-props]

<PropertiesList>
  <PropertiesListItem name="threads" type="ThreadData[]" required>
    The threads to display.
  </PropertiesListItem>
  <PropertiesListItem
    name="components"
    type="Partial<AnchoredThreadsComponents>"
  >
    Override the componentâ€™s components.
  </PropertiesListItem>
  <PropertiesListItem
    name="components.Thread"
    type="(props: ThreadProps) => ReactNode"
  >
    Override the [`Thread`](/docs/api-reference/liveblocks-react-ui#Thread)
    component.
  </PropertiesListItem>
</PropertiesList>

### AnchoredThreads

Displays a list of [`Thread`][] components vertically alongside the editor.

```tsx highlight="3"
<AnchoredThreads editor={editor} threads={threads} />
```

<Figure>
  <Image
    src="/assets/text-editor/anchored-threads.jpg"
    alt="AnchoredThreads"
    width={960}
    height={558}
  />
</Figure>

Takes a list of threads retrieved from [`useThreads`][] and renders them to the
page. Each thread is displayed at the same vertical coordinates as its
corresponding text highlight. If multiple highlights are in the same location,
each thread is placed in order below the previous thread.

```tsx
// +++
import { useThreads } from "@liveblocks/react/suspense";
// +++
import {
  useLiveblocksExtension,
  FloatingComposer,
  // +++
  AnchoredThreads,
  // +++
} from "@liveblocks/react-tiptap";
import { useEditor, EditorContent } from "@tiptap/react";

function TextEditor() {
  const liveblocks = useLiveblocksExtension();

  const editor = useEditor({
    extensions: [
      liveblocks,
      // ...
    ],
  });

  // +++
  const { threads } = useThreads();
  // +++

  return (
    <div>
      <EditorContent editor={editor} />
      <FloatingComposer editor={editor} style={{ width: "350px" }} />
      // +++
      <AnchoredThreads
        editor={editor}
        threads={threads}
        style={{ width: "350px" }}
      />
      // +++
    </div>
  );
}
```

<Banner title="Resolved threads">

The `AnchoredThreads` component automatically excludes resolved threads from
display. Any resolved threads passed in the threads list will not be shown.

</Banner>

#### Recommended usage [#AnchoredThreads-recommended-usage]

[`FloatingThreads`][] and [`AnchoredThreads`][] have been designed to work
together to provide the optimal experience on mobile and desktop. We generally
recommend using both components, hiding one on smaller screens, as we are below
with Tailwind classes. Most apps also donâ€™t need to display resolved threads, so
we can filter those out with a [`useThreads`][] option.

```tsx
import { useThreads } from "@liveblocks/react/suspense";
import { AnchoredThreads, FloatingThreads } from "@liveblocks/react-tiptap";
import { Editor } from "@tiptap/react";

function ThreadOverlay({ editor }: { editor: Editor | null }) {
  const { threads } = useThreads({ query: { resolved: false } });

  return (
    <>
      <FloatingThreads
        editor={editor}
        threads={threads}
        className="w-[350px] block md:hidden"
      />
      <AnchoredThreads
        editor={editor}
        threads={threads}
        className="w-[350px] hidden sm:block"
      />
    </>
  );
}
```

```tsx title="Alternatively use a media query hook" isCollapsed isCollapsable
import { useSyncExternalStore } from "react";
import { useThreads } from "@liveblocks/react/suspense";
import { AnchoredThreads, FloatingThreads } from "@liveblocks/react-tiptap";
import { Editor } from "@tiptap/react";

function ThreadOverlay({ editor }: { editor: Editor | null }) {
  const { threads } = useThreads({ query: { resolved: false } });
  // +++
  const isMobile = useIsMobile();
  // +++

  // +++
  if (isMobile) {
    return (
      <FloatingThreads
        editor={editor}
        threads={threads}
        style={{ width: "350px" }}
      />
    );
  }
  // +++

  // +++
  return (
    <AnchoredThreads
      editor={editor}
      threads={threads}
      style={{ width: "350px" }}
    />
  );
  // +++
}

export function useIsMobile() {
  return useSyncExternalStore(subscribe, getSnapshot, getSnapshot);
}

function subscribe(callback: () => void) {
  const query = window.matchMedia("(max-width: 1024px)");

  query.addEventListener("change", callback);
  return () => query.removeEventListener("change", callback);
}

function getSnapshot() {
  const query = window.matchMedia("(max-width: 1024px)");
  return query.matches;
}
```

We can place this component inside [`ClientSideSuspense`][] to prevent it
rendering until threads have loaded.

```tsx
<div>
  <EditorContent editor={editor} />
  <FloatingComposer editor={editor} style={{ width: "350px" }} />
  // +++
  <ClientSideSuspense fallback={null}>
    <ThreadOverlay editor={editor} />
  </ClientSideSuspense>
  // +++
</div>
```

#### Customization [#AnchoredThreads-customization]

The `AnchoredThreads` component acts as a wrapper around each [`Thread`][]. It
has no width, so setting this is required, and each thread will take on the
width of the wrapper. You can treat the component like you would a `div`, using
classes, listeners, and more.

```tsx
<AnchoredThreads
  editor={editor}
  threads={threads}
  style={{ width: "350px" }}
  className="my-anchored-thread"
/>
```

To apply styling to each [`Thread`][], you can pass a custom `Thread` property
to `components` and modify this in any way.

```tsx
import { Thread } from "@liveblocks/react-ui";

<AnchoredThreads
  editor={editor}
  threads={threads}
  style={{ width: "350px" }}
  className="my-anchored-thread"
  // +++
  components={{
    Thread: (props) => (
      <Thread
        {...props}
        className="border shadow"
        style={{ background: "white" }}
      />
    ),
  }}
  // +++
/>;
```

You can return any custom `ReactNode` here, including anything from a simple
wrapper around `Thread`, up to a full custom `Thread` component built using our
[Comment primitives](/docs/api-reference/liveblocks-react-ui#primitives-Comment).

```tsx
import { Comment } from "@liveblocks/react-ui/primitives";

<AnchoredThreads
  editor={editor}
  threads={threads}
  style={{ width: "350px" }}
  className="my-anchored-thread"
  components={{
    Thread: (props) => (
      // +++
      <div>
        {props.thread.comments.map((comment) => (
          <Comment.Body
            key={comment.id}
            body={comment.body}
            components={/* ... */}
          />
        ))}
      </div>
      // +++
    ),
  }}
/>;
```

##### Modifying thread floating positions

Using CSS variables you can modify the gap between threads, and the horizontal
offset thatâ€™s added when a thread is selected.

```css
.lb-tiptap-anchored-threads {
  /* Minimum gap between threads */
  --lb-tiptap-anchored-threads-gap: 8px;

  /* How far the active thread is offset to the left */
  --lb-tiptap-anchored-threads-active-thread-offset: 12px;
}
```

#### Props [#AnchoredThreads-props]

<PropertiesList>
  <PropertiesListItem name="threads" type="ThreadData[]" required>
    The threads to display.
  </PropertiesListItem>
  <PropertiesListItem
    name="components"
    type="Partial<AnchoredThreadsComponents>"
  >
    Override the componentâ€™s components.
  </PropertiesListItem>
  <PropertiesListItem
    name="components.Thread"
    type="(props: ThreadProps) => ReactNode"
  >
    Override the [`Thread`](/docs/api-reference/liveblocks-react-ui#Thread)
    component.
  </PropertiesListItem>
</PropertiesList>

### HistoryVersionPreview [@badge=beta]

The `HistoryVersionPreview` component allows you to display a preview of a
specific version of your Tiptap editorâ€™s content. It also contains a button and
logic for restoring. To render a list of versions, see
[`VersionHistory`](/docs/api-reference/liveblocks-react-ui#Version-History).

#### Usage [#HistoryVersionPreview-usage]

```tsx
import { HistoryVersionPreview } from "@liveblocks/react-tiptap";

function VersionPreview({ selectedVersion, onVersionRestore }) {
  return (
    <HistoryVersionPreview
      version={selectedVersion}
      onVersionRestore={onVersionRestore}
    />
  );
}
```

#### Props [#HistoryVersionPreview-props]

<PropertiesList>
  <PropertiesListItem name="version" type="HistoryVersion" required>
    The version of the editor content to preview.
  </PropertiesListItem>
  <PropertiesListItem
    name="onVersionRestore"
    type="(version: HistoryVersion) => void"
  >
    Callback function called when the user chooses to restore this version.
  </PropertiesListItem>
</PropertiesList>

The `HistoryVersionPreview` component renders a read-only view of the specified
version of the editor content. It also provides a button for users to restore
the displayed version.

### AiToolbar [@badge=beta]

<Banner title="Private beta">

AI Copilots is currently in private beta. If you would like access to the beta,
please [contact us](https://liveblocks.io/contact/sales). Weâ€™d love to hear from
you.

</Banner>

Displays a floating AI toolbar near the current Tiptap selection, allowing you
to use AI to apply changes to the document or ask questions about it.

```tsx
<AiToolbar editor={editor} />
```

Pass your Tiptap `editor` to use the component, and enable (or customize) the AI
option in [`useLiveblocksExtension`][].

```tsx
import {
  useLiveblocksExtension,
  // +++
  AiToolbar,
  // +++
  FloatingToolbar,
} from "@liveblocks/react-tiptap";
import { useEditor, EditorContent } from "@tiptap/react";

function TextEditor() {
  const liveblocks = useLiveblocksExtension({
    // +++
    ai: true,
    // +++
  });

  const editor = useEditor({
    extensions: [
      liveblocks,
      // ...
    ],
  });

  return (
    <div>
      <EditorContent editor={editor} />
      // +++
      <AiToolbar editor={editor} />
      // +++
      <FloatingToolbar editor={editor} />
    </div>
  );
}
```

#### Opening the toolbar [#AiToolbar-opening]

To open the `AiToolbar`, you need to call the `askAi`
[command](https://tiptap.dev/docs/editor/api/commands) added by Liveblocks.

```tsx
import { Editor } from "@tiptap/react";

function Toolbar({ editor }: { editor: Editor | null }) {
  if (!editor) {
    return null;
  }

  return (
    <button
      onClick={() => {
        // +++
        editor.chain().focus().askAi().run();
        // +++
      }}
    >
      âœ¨ Ask AI
    </button>
  );
}
```

You can also pass a prompt to the `askAi` command and it will directly request
it when opening the toolbar.

```tsx
<button
  onClick={() => {
    // +++
    editor.chain().focus().askAi("Add emojis to the text").run();
    // +++
  }}
>
  ðŸ˜ƒ Emojify
</button>
```

#### Customizing suggestions [#AiToolbar-suggestions]

By default, the AI toolbar displays a list of suggestions (e.g. â€œFix mistakesâ€,
â€œExplainâ€, etc). These can be customized via the `suggestions` prop and the
[`AiToolbar.Suggestion`][] component.

```tsx
<AiToolbar
  editor={editor}
  // +++
  suggestions={
    <>
      <AiToolbar.SuggestionsLabel>Suggested</AiToolbar.SuggestionsLabel>
      <AiToolbar.Suggestion>Fix mistakes</AiToolbar.Suggestion>
      <AiToolbar.Suggestion prompt="Add emojis to the text">
        Emojify
      </AiToolbar.Suggestion>
      <AiToolbar.SuggestionsSeparator />
      <AiToolbar.Suggestion icon={<Icon.Sparkles />}>
        Continue writing
      </AiToolbar.Suggestion>
    </>
  }
  // +++
/>
```

Doing so will override the default suggestions, instead you can use a function
to keep them while adding your own.

```tsx
<AiToolbar
  editor={editor}
  // +++
  suggestions={({ children }) => (
    <>
      {children}
      // +++
      <AiToolbar.SuggestionsSeparator />
      <AiToolbar.SuggestionsLabel>Custom</AiToolbar.SuggestionsLabel>
      <AiToolbar.Suggestion>Custom suggestion</AiToolbar.Suggestion>
    </>
  )}
/>
```

#### Props [#AiToolbar-props]

<PropertiesList>
  <PropertiesListItem name="editor" type="Editor | null" required>
    The Tiptap editor.
  </PropertiesListItem>
  <PropertiesListItem name="offset" type="number">
    The vertical offset of the AI toolbar from the selection.
  </PropertiesListItem>
  <PropertiesListItem name="suggestions" type="ReactNode">
    The prompt suggestions to display below the AI toolbar.
  </PropertiesListItem>
</PropertiesList>

#### AiToolbar.Suggestion

A prompt suggestion displayed below the AI toolbar.

```tsx
import { AiToolbar } from "@liveblocks/react-tiptap";

<AiToolbar
  editor={editor}
  suggestions={
    <>
      // +++
      <AiToolbar.Suggestion>Fix mistakes</AiToolbar.Suggestion>
      // +++
    </>
  }
/>;
```

By default, selecting a suggestion will use its label from the `children` as the
prompt, this can be overridden with the `prompt` prop. Also optionally takes an
icon.

```tsx
import { AiToolbar } from "@liveblocks/react-tiptap";
import { Icon } from "@liveblocks/react-ui";

// "Translate to French" is displayed in the suggestion and used as the prompt
<AiToolbar.Suggestion>Translate to French</AiToolbar.Suggestion>

// "Emojify" is displayed in the suggestion but "Add emojis to the text" is used as the prompt
<AiToolbar.Suggestion prompt="Add emojis to the text">Emojify</AiToolbar.Suggestion>

// Custom icon
<AiToolbar.Suggestion icon={<div>?</div>}>Explain</AiToolbar.Suggestion>

// Using a Liveblocks icon
<AiToolbar.Suggestion icon={<Icon.QuestionMark />}>Explain</AiToolbar.Suggestion>
```

##### Props [#AiToolbarSuggestion-props]

<PropertiesList>
  <PropertiesListItem name="children" type="ReactNode">
    The suggestionâ€™s label, used as the prompt if the `prompt` prop is not set.
  </PropertiesListItem>
  <PropertiesListItem name="icon" type="ReactNode">
    An optional icon displayed before the label.
  </PropertiesListItem>
  <PropertiesListItem name="prompt" type="string">
    The prompt to use instead of the label.
  </PropertiesListItem>
</PropertiesList>

#### AiToolbar.SuggestionsLabel

A label to describe a group of prompt suggestions displayed in the AI toolbar.

```tsx
import { AiToolbar } from "@liveblocks/react-tiptap";

<AiToolbar
  editor={editor}
  suggestions={
    <>
      // +++
      <AiToolbar.SuggestionsLabel>Translation</AiToolbar.SuggestionsLabel>
      // +++
      <AiToolbar.Suggestion>Translate in French</AiToolbar.Suggestion>
      <AiToolbar.Suggestion>Translate in English</AiToolbar.Suggestion>
    </>
  }
/>;
```

#### AiToolbar.SuggestionsSeparator

A separator between groups of prompt suggestions displayed in the AI toolbar.

```tsx
import { AiToolbar } from "@liveblocks/react-tiptap";

<AiToolbar
  editor={editor}
  suggestions={
    <>
      <AiToolbar.Suggestion>Translate in French</AiToolbar.Suggestion>
      <AiToolbar.Suggestion>Translate in English</AiToolbar.Suggestion>
      // +++
      <AiToolbar.SuggestionsSeparator />
      // +++
      <AiToolbar.Suggestion>Custom suggestion</AiToolbar.Suggestion>
    </>
  }
/>;
```

## Hooks

### useLiveblocksExtension

Liveblocks plugin for Tiptap that adds collaboration to your editor.
`liveblocks` should be passed to Tiptapâ€™s `useEditor` as an extension.

```tsx
import { useLiveblocksExtension } from "@liveblocks/react-tiptap";
import { useEditor, EditorContent } from "@tiptap/react";

function TextEditor() {
  // +++
  const liveblocks = useLiveblocksExtension();
  // +++

  const editor = useEditor({
    extensions: [
      // +++
      liveblocks,
      // +++
      // ...
    ],
  });

  return (
    <div>
      <EditorContent editor={editor} />
    </div>
  );
}
```

A number of options can be applied.

```tsx
const liveblocks = useLiveblocksExtension({
  // +++
  initialContent: "Hello world",
  field: "editor-one",
  // +++

  // Other options
  // ...
});
```

<PropertiesList title="Returns">
  <PropertiesListItem name="liveblocks" type="Extension">
    Returns a Liveblocks [Tiptap
    extension](https://tiptap.dev/docs/editor/core-concepts/extensions#create-a-new-extension).
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem name="options.initialContent" type="Content">
    The initial content for the editor, if itâ€™s never been set. [Learn
    more](#Setting-initial-content).
  </PropertiesListItem>
  <PropertiesListItem name="options.field" type="string">
    The name of this text editorâ€™s field. Allows you to use multiple editors on
    one page, if each has a separate field value. [Learn
    more](#Multiple-editors).
  </PropertiesListItem>
  <PropertiesListItem
    name="options.offlineSupport_experimental"
    defaultValue="false"
    type="boolean"
  >
    Experimental. Enable offline support using IndexedDB. This means that after
    the first load, documents will be stored locally and load instantly. [Learn
    more](#Offline-support).
  </PropertiesListItem>
  <PropertiesListItem
    name="options.comments"
    defaultValue="true"
    type="boolean"
  >
    Enable comments in the editor.
  </PropertiesListItem>
  <PropertiesListItem
    name="options.mentions"
    defaultValue="true"
    type="boolean"
  >
    Enable mentions in the editor.
  </PropertiesListItem>
  <PropertiesListItem
    name="options.ai"
    defaultValue="false"
    type="boolean | AiConfiguration"
  >
    Enable AI in the editor and optionally customize configuration options.
  </PropertiesListItem>
</PropertiesList>

#### Setting initial content

Initial content for the editor can be set with `initialContent`. This content
will only be used if the current editor has never been edited by any users, and
is ignored otherwise.

```tsx
import { useLiveblocksExtension } from "@liveblocks/react-tiptap";

function TextEditor() {
  const liveblocks = useLiveblocksExtension({
    // +++
    initialContent: "<p>Hello world</p>",
    // +++
  });

  // ...
}
```

#### Multiple editors

Itâ€™s possible to use multiple editors on one page by passing values to the
`field` property. Think of it like an ID for the current editor.

```tsx
import { useLiveblocksExtension } from "@liveblocks/react-tiptap";

function TextEditor() {
  const liveblocks = useLiveblocksExtension({
    // +++
    field: "editor-one",
    // +++
  });

  // ...
}
```

Hereâ€™s an example of how multiple editors may be set up.

```tsx
import { useLiveblocksExtension } from "@liveblocks/react-tiptap";
import { useEditor, EditorContent } from "@tiptap/react";

function TextEditors() {
  return (
    <div>
      // +++
      <TextEditor field="one" />
      <TextEditor field="two" />
      // +++
    </div>
  );
}

function TextEditor({ field }: { field: string }) {
  // +++
  const liveblocks = useLiveblocksExtension({ field });
  // +++

  const editor = useEditor({
    extensions: [
      liveblocks,
      // ...
    ],
  });

  return (
    <div>
      <EditorContent editor={editor} />
    </div>
  );
}
```

#### Offline support [@badge=experimental]

Itâ€™s possible to enable offline support in your editor with an experimental
option. This means that once a document has been opened, itâ€™s saved locally on
the browser, and can be shown instantly without a loading screen. As soon as
Liveblocks connects, any remote changes will be synchronized, without any load
spinner. Enable this by passing a `offlineSupport_experimental` value.

```tsx
import { useLiveblocksExtension } from "@liveblocks/react-tiptap";

function TextEditor() {
  const liveblocks = useLiveblocksExtension({
    offlineSupport_experimental: true,
  });

  // ...
}
```

To make sure that your editor loads instantly, you must structure your app
carefully to avoid any Liveblocks hooks and [`ClientSideSuspense`][] components
from triggering a loading screen. For example, if youâ€™re displaying threads in
your editor with [`useThreads`][], you must place this inside a separate
component and wrap it in [`ClientSideSuspense`][].

```tsx
"use client";

import { ClientSideSuspense, useThreads } from "@liveblocks/react/suspense";
import {
  useLiveblocksExtension,
  AnchoredThreads,
  FloatingComposer,
} from "@liveblocks/react-tiptap";
import { Editor, EditorContent, useEditor } from "@tiptap/react";

export function TiptapEditor() {
  const liveblocks = useLiveblocksExtension({
    offlineSupport_experimental: true,
  });

  const editor = useEditor({
    extensions: [
      liveblocks,
      // ...
    ],
    immediatelyRender: false,
  });

  return (
    <>
      <EditorContent editor={editor} />
      <FloatingComposer editor={editor} style={{ width: 350 }} />
      // +++
      <ClientSideSuspense fallback={null}>
        <Threads editor={editor} />
      </ClientSideSuspense>
      // +++
    </>
  );
}

// +++
function Threads({ editor }: { editor: Editor }) {
  const { threads } = useThreads();

  return <AnchoredThreads editor={editor} threads={threads} />;
}
// +++
```

#### Customizing AI components [@badge=beta]

<Banner title="Private beta">

AI Copilots is currently in private beta. If you would like access to the beta,
please [contact us](https://liveblocks.io/contact/sales). Weâ€™d love to hear from
you.

</Banner>

By default, AI components like [`AiToolbar`][] use the term `"AI"`. This can be
customized with the `ai.name` option in [`useLiveblocksExtension`][]. This value
will be used throughout the AI components: `"Ask {name}"` in the [`Toolbar`][]/
[`FloatingToolbar`][] default buttons, `"{name} is thinkingâ€¦"` in the
[`AiToolbar`][], etc.

```tsx
import { useLiveblocksExtension } from "@liveblocks/react-tiptap";
import { useEditor } from "@tiptap/react";

function TextEditor() {
  const liveblocks = useLiveblocksExtension({
    ai: {
      // +++
      // "Ask Liveblocks anythingâ€¦", "Liveblocks is thinkingâ€¦", etc
      name: "Liveblocks",
      // +++
    },
  });

  const editor = useEditor({
    extensions: [
      liveblocks,
      // ...
    ],
  });

  // ...
}
```

If youâ€™re after visual customization, AI components like [`AiToolbar`][]
integrate with the rest of Liveblocks' styles, heavily using tokens like
`--lb-accent` for example. Learn more about [styling](#Stylesheets).

#### Generating AI toolbar responses [@badge=beta]

<Banner title="Private beta">

AI Copilots is currently in private beta. If you would like access to the beta,
please [contact us](https://liveblocks.io/contact/sales). Weâ€™d love to hear from
you.

</Banner>

By default, the [`AiToolbar`][] component sends its requests to Liveblocks to
generate its responses. This can be customized via the
`ai.resolveContextualPrompt` option in [`useLiveblocksExtension`][]. This option
accepts an async function which will be called by the AI toolbar whenever a
prompt is requested, it will receive the prompt and some context (the documentâ€™s
and selectionâ€™s text, the previous request if itâ€™s a follow-up, etc) and is
expected to return the type of response and the text to use.

```tsx
import { useLiveblocksExtension } from "@liveblocks/react-tiptap";
import { useEditor } from "@tiptap/react";

function TextEditor() {
  const liveblocks = useLiveblocksExtension({
    ai: {
      // +++
      resolveContextualPrompt: async ({ prompt, context, signal }) => {
        const response = await fetch("/api/contextual-prompt", {
          method: "POST",
          body: JSON.stringify({ prompt, context }),
          signal,
        });

        return response.json();
      },
      // +++
    },
  });

  const editor = useEditor({
    extensions: [
      liveblocks,
      // ...
    ],
  });

  // ...
}
```

### useIsEditorReady

Used to check if the editor content has been loaded or not, helpful for
displaying a loading skeleton.

```ts
import { useIsEditorReady } from "@liveblocks/react-tiptap";

const status = useIsEditorReady();
```

Hereâ€™s how it can be used in the context of your editor.

```tsx
// +++
import {
  useIsEditorReady,
  useLiveblocksExtension,
} from "@liveblocks/react-tiptap";
import { useEditor, EditorContent } from "@tiptap/react";
// +++

function TextEditor() {
  const liveblocks = useLiveblocksExtension();
  // +++
  const ready = useIsEditorReady();
  // +++

  const editor = useEditor({
    extensions: [
      liveblocks,
      // ...
    ],
  });

  return (
    <div>
      // +++
      {!ready ? <div>Loading...</div> : <EditorContent editor={editor} />}
      // +++
    </div>
  );
}
```

## Stylesheets

React Tiptap comes with default styles, and these can be imported into the root
of your app or directly into a CSS file with `@import`. Note that you must also
install and import a stylesheet from
[`@liveblocks/react-ui`](/docs/api-reference/liveblocks-react-ui) to use these
styles.

```tsx
import "@liveblocks/react-ui/styles.css";
import "@liveblocks/react-tiptap/styles.css";
```

### Customizing your styles

Adding dark mode and customizing your styles is part of `@liveblocks/react-ui`,
learn how to do this under
[styling and customization](/docs/api-reference/liveblocks-react-ui#Styling-and-customization).

[`useLiveblocksExtension`]: #useLiveblocksExtension
[`Thread`]: /docs/api-reference/liveblocks-react-ui#Thread
[`Composer`]: /docs/api-reference/liveblocks-react-ui#Composer
[`useThreads`]: /docs/api-reference/liveblocks-react#useThreads
[`Icon`]: /docs/api-reference/liveblocks-react-ui#Icon
[`Toolbar`]: #Toolbar
[`Toolbar.Button`]: #Toolbar.Button
[`Toolbar.Toggle`]: #Toolbar.Toggle
[`Toolbar.BlockSelector`]: #Toolbar.BlockSelector
[`Toolbar.Separator`]: #Toolbar.Separator
[`Toolbar.SectionHistory`]: #Toolbar.SectionHistory
[`Toolbar.SectionInline`]: #Toolbar.SectionInline
[`Toolbar.SectionCollaboration`]: #Toolbar.SectionCollaboration
[`FloatingToolbar`]: #FloatingToolbar
[`FloatingComposer`]: #FloatingComposer
[`FloatingThreads`]: #FloatingThreads
[`AnchoredThreads`]: #AnchoredThreads
[`AiToolbar`]: #AiToolbar
[`AiToolbar.Suggestion`]: #AiToolbar.Suggestion
[`AiToolbar.SuggestionsLabel`]: #AiToolbar.SuggestionsLabel
[`AiToolbar.SuggestionsSeparator`]: #AiToolbar.SuggestionsSeparator
[`ClientSideSuspense`]: /docs/api-reference/liveblocks-react#ClientSideSuspense

---
meta:
  title: "@liveblocks/react-ui"
  parentTitle: "API Reference"
  description: "API Reference for the @liveblocks/react-ui package"
alwaysShowAllNavigationLevels: false
---

`@liveblocks/react-ui` provides you with [React](https://react.dev/) components
to build collaborative experiences. Read our
[Comments](/docs/get-started/comments) and
[Notifications](/docs/get-started/notifications) get started guides to learn
more.

## AI Copilots

### Default components [#AI-Copilots-Components]

#### AiChat

Displays an interactive AI chat. AI can
[use knowledge](/docs/api-reference/liveblocks-react#RegisterAiKnowledge) and
[run actions or display content via tools](/docs/api-reference/liveblocks-react#RegisterAiTool).

```tsx
<AiChat chatId="my-chat-id" />
```

<Figure>
  <Image
    src="/assets/ai-copilots/ai-chat.jpg"
    alt="AI Chat"
    width={768}
    height={446}
    style={{ borderRadius: 12 }}
  />
</Figure>

Each chat is stored permanently, and is identified by its unique `chatId`. Chats
are only visible to the [authenticated user](/docs/authentication) who created
the chat.

```tsx
import { AiChat } from "@liveblocks/react-ui";

function Chat() {
  return <AiChat chatId="my-chat-id" />;
}
```

##### Assigning a copilot [#AiChat-copilot]

Use a custom copilot in your chat. You can define copilots with custom prompts &
settings in the [Liveblocks dashboard](/dashboard), passing your API key from
OpenAI, Anthropic, or Google. Copy the copilot's ID and pass it to the
`copilotId` prop.

```tsx
import { AiChat } from "@liveblocks/react-ui";

function Chat() {
  return (
    <AiChat
      chatId="my-chat-id"
      // +++
      copilotId="co_a7Gd3x..."
      // +++
    />
  );
}
```

Dynamically switching copilots is possible, and messages will use whichever
`copilotId` is set when a message is sent.

##### Show placeholder content in new chats [#AiChat-placeholder]

In chats without messages, you can display placeholder content to welcome and
guide the user. To set this content, use the `Empty` property under
`components`.

```tsx
import { AiChat } from "@liveblocks/react-ui";

function Chat() {
  return (
    <AiChat
      chatId="my-chat-id"
      // +++
      components={{ Empty: <div>I'm an empty chat!</div> }}
      // +++
    />
  );
}
```

Additionally, you can add suggestion buttons which will automatically submit new
messages to the chat when clicked. Create them with
[`useSendAiMessage`](/docs/api-reference/liveblocks-react#useSendAiMessage).

```tsx
import { useSendAiMessage } from "@liveblocks/react";
import { AiChat } from "@liveblocks/react-ui";

function Chat({ chatId }: { chatId: string }) {
  // +++
  const sendAiMessage = useSendAiMessage(chatId);
  // +++

  return (
    <AiChat
      chatId="my-chat-id"
      components={{
        Empty: (
          <div>
            <div>Suggestions</div>
            // +++
            <button onClick={() => sendAiMessage("What's new?")}>
              Update me
            </button>
            <button onClick={() => sendAiMessage("Create a new document")}>
              Draft a document
            </button>
            // +++
          </div>
        ),
      }}
    />
  );
}
```

##### List the userâ€™s chats and switch between them [#AiChat-chat-listing]

You can display a list of all chats created by the current user with
[`useAiChats`](/docs/api-reference/liveblocks-react#useAiChats). For example,
you can render a list of buttons that allow you to switch between chats. In each
button, you can display the chatâ€™s automatically generated title, as seen below.
Chats can be deleted with
[`useDeleteAiChat`](/docs/api-reference/liveblocks-react#useDeleteAiChat).

```tsx
import { useState } from "react";
import { AiChat } from "@liveblocks/react-ui";
import { useAiChats } from "@liveblocks/react";
import { Timestamp } from "@liveblocks/react-ui/primitives";

function Chats() {
  // +++
  const { chats, error, isLoading } = useAiChats();
  const [chatId, setChatId] = useState();
  const deleteChat = useDeleteAiChat();
  // +++

  if (isLoading) {
    return <div>Loading...</div>;
  }

  if (error) {
    return <div>Error: {error.message}</div>;
  }

  return (
    <div style={{ display: "flex" }}>
      <ul>
        // +++
        {chats.map((chat) => (
          <li key={chat.id}>
            <button onClick={() => setChatId(chat.id)}>
              {chat.title || "Untitled"}
            </button>
            <Timestamp date={chat.lastMessageAt || chat.createdAt} />
            <button onClick={() => deleteChat(chat.id)}>âŒ</button>
          </li>
        ))}
        // +++
      </ul>
      // +++
      <AiChat chatId={chatId} />
      // +++
    </div>
  );
}
```

##### Display the chatâ€™s title [#AiChat-title]

Each chat has a `title` property, automatically generated by AI. The title of a
new chat starts empty, and is updated after AI receives the first message and
writes a response. You can render this alongside your chat with
[`useAiChat`](/docs/api-reference/liveblocks-react#useAiChat).

```tsx
import { AiChat } from "@liveblocks/react-ui";
import { useAiChat } from "@liveblocks/react";

function ChatWithTitle({ chatId }: { chatId: string }) {
  // +++
  const { chat, error, isLoading } = useAiChat(chatId);
  // +++

  if (isLoading) {
    return <div>Loading...</div>;
  }

  if (error) {
    return <div>Error: {error.message}</div>;
  }

  return (
    <div>
      // +++
      <h1>{chat.title || "Untitled chat"}</h1>
      // +++
      <AiChat chatId={chatId} />
    </div>
  );
}
```

##### Add front-end knowledge [#AiChat-front-end-knowledge]

You can add front-end knowledge to chats, meaning the AI will understand the
information you pass, and will answer questions or call tools based on it. This
is particularly helpful for passing user info, app state, and small contextual
knowledge.

Itâ€™s generally recommended to use
[`RegisterAiKnowledge`](/docs/api-reference/liveblocks-react#RegisterAiKnowledge)
for adding knowledge, as this will add knowledge to all AI features on the page.
However, if youâ€™d like knowledge that is specific to one chat, you can add it
with the `knowledge` prop on `AiChat`. No other chats will have access to this
knowledge.

```tsx
import { AiChat } from "@liveblocks/react-ui";

function Chat() {
  return (
    <AiChat
      chatId="my-chat-id"
      // +++
      knowledge={[
        { description: "The current user's payment plan", value: "Enterprise" },
        {
          description: "The current user's info",
          value: {
            name: "Jody Hekla",
            email: "jody@liveblocks.io",
            teams: ["Engineering", "Product"],
          },
        },
      ]}
      // +++
    />
  );
}
```

##### Add back-end knowledge [#AiChat-back-end-knowledge]

You can add back-end knowledge to chats, meaning the AI will understand the
information you pass, and can answer questions or call tools based on it. This
is a way to pass large amounts of project-wide information, for example complex
documentation.

{/* TODO screenshot */}

When creating or editing a copilot in the [Liveblocks dashboard](/dashboard)
navigate to the Knowledge tab. Within here you can upload any relevant files, or
submit websites for indexing. Your copilot will internalize this knowledge using
retrieval-augmented generation (RAG).

##### Adjusting the chatâ€™s width [#AiChat-width]

When using the default `inset` layout, itâ€™s possible to adjust the chatâ€™s width
by setting the `--lb-ai-chat-container-width` CSS variable. This allows the
chatâ€™s scroll window to stay full width, whilst keeping the composer and
messages centered in the middle.

```css
.lb-ai-chat {
  --lb-ai-chat-container-width: 600px;
}
```

```tsx title="Set variable in React" isCollapsable isCollapsed
import { CSSProperties } from "react";
import { AiChat } from "@liveblocks/react-ui";

function Chat() {
  return (
    <AiChat
      chatId="my-chat-id"
      // +++
      style={{ "--lb-ai-chat-container-width": 600 } as CSSProperties}
      // +++
    />
  );
}
```

```tsx title="Set variable in Tailwind CSS" isCollapsable isCollapsed
import { CSSProperties } from "react";
import { AiChat } from "@liveblocks/react-ui";

function Chat() {
  return (
    <AiChat
      chatId="my-chat-id"
      // +++
      className="[--lb-ai-chat-container-width:600px]"
      // +++
    />
  );
}
```

##### Compact layout mode [#AiChat-compact-layout]

An alternate `compact` layout mode is available, ideal for smaller UI components
such as pop-up windows. Compact layout mode removes the shadow and padding on
the composer, makes it full-width, and displays a border above it.

```tsx
import { AiChat } from "@liveblocks/react-ui";

function Chat() {
  return (
    <AiChat
      chatId="my-chat-id"
      // +++
      layout="compact"
      // +++
    />
  );
}
```

##### Change background color [#AiChat-background]

You can change the background color of the chat by setting the `--lb-background`
CSS variable on `.lb-ai-chat`.

```css
.lb-ai-chat {
  --lb-background: #eeeeee;
}
```

```tsx title="Set variable in React" isCollapsable isCollapsed
import { CSSProperties } from "react";
import { AiChat } from "@liveblocks/react-ui";

function Chat() {
  return (
    <AiChat
      chatId="my-chat-id"
      // +++
      style={{ "--lb-background": "#EEEEEE" } as CSSProperties}
      // +++
    />
  );
}
```

```tsx title="Set variable in Tailwind CSS" isCollapsable isCollapsed
import { CSSProperties } from "react";
import { AiChat } from "@liveblocks/react-ui";

function Chat() {
  return (
    <AiChat
      chatId="my-chat-id"
      // +++
      className="[--lb-background:#EEEEEE]"
      // +++
    />
  );
}
```

##### Customize CSS variables and classes [#AiChat-variables-and-classes]

You can customize the default styles of the chat by modifying CSS variables and
classes prefixed with `lb`. Here are some examples.

```css
/* Lowers spacing and shrinks font size */
.lb-ai-chat {
  --lb-spacing: 0.6em;
  font-size: 14px;
}

/* Removes composer shadow and adds border */
.lb-ai-chat-composer {
  box-shadow: 0;
  border: 1px solid #f0f0f0;
}

/* Removes padding below the composer */
.lb-ai-chat-footer {
  padding-bottom: 0;
}
```

##### Customize how Markdown is rendered [#AiChat-markdown]

You can customize how Markdown is rendered in messages by passing components to
the `components` prop. A full list is [available here](#AiChat-components).

```tsx
<AiChat
  chatId="my-chat-id"
  components={{
    // +++
    markdown: {
      // Example: Use custom paragraph styles
      Paragraph: ({ children }) => <p className="my-3">{children}</p>,

      // Example: Use an existing component for quotes
      Blockquote: ({ children }) => <MyQuote>{children}</MyQuote>,

      // Example: Use `next/link` instead of default `<a>` tag
      Link: ({ children, href }) => <Link href={href || ""}>{children}</Link>,

      // Example: Use an external library to add syntax highlighting to code blocks
      CodeBlock: ({ language, code }) => (
        <SyntaxHighlighter language={language}>{code}</SyntaxHighlighter>
      ),

      // `Heading`, `Inline`, `List`, `Table`, `Image`, `Separator`, etc.
      // ...
    },
    // +++
  }}
/>
```

##### Props [#AiChat-props]

<PropertiesList>
  <PropertiesListItem name="chatId" type="string" required>
    The unique identifier for the chat. Each chat is stored permanently and is
    only visible to the authenticated user who created it.
  </PropertiesListItem>
  <PropertiesListItem name="autoFocus" type="boolean">
    Whether to automatically focus the composer input when the chat loads.
    Defaults to `false`.
  </PropertiesListItem>
  <PropertiesListItem name="copilotId" type="string">
    The ID of the custom copilot to use for this chat. Copy this from your
    copilot configuration in the [Liveblocks
    dashboard](https://liveblocks.io/dashboard/copilots).
  </PropertiesListItem>
  <PropertiesListItem name="knowledge" type="AiKnowledgeSource[]">
    Array of knowledge sources specific to this chat. This knowledge will only
    be available to this chat instance and not to other AI features on the page.
  </PropertiesListItem>
  <PropertiesListItem name="tools" type="Record<string, AiToolDefinition>">
    Object mapping tool names to tool definitions that should be available in
    this chat.
  </PropertiesListItem>
  <PropertiesListItem
    name="onComposerSubmit"
    type="function"
    detailedType="(comment: AiComposerSubmitMessage, event: FormEvent<HTMLFormElement>) => Promise<void> | void"
  >
    The event handler called when the composer is submitted.
  </PropertiesListItem>
  <PropertiesListItem name="layout" type="'inset' | 'compact'">
    The layout mode for the chat. Use `'inset'` (default) for standalone chats,
    or `'compact'` for embedded scenarios like pop-up windows.
  </PropertiesListItem>
  <PropertiesListItem name="overrides" type="AiChatOverrides">
    Advanced customization options for overriding default chat behavior and
    styling.
  </PropertiesListItem>
  <PropertiesListItem name="components" type="AiChatComponents">
    Custom components to override specific parts of the chat UI, such as the
    `Empty` placeholder component or Markdown components.
  </PropertiesListItem>
  <PropertiesListItem name="responseTimeout" type="number">
    The time, in milliseconds, before an AI response will timeout. Defaults to
    30_000.
  </PropertiesListItem>
  <PropertiesListItem name="showReasoning" type="boolean | 'during'">
    Whether to show reasoning. Defaults to `true`. If set to `'during'`,
    reasoning will only be shown during reasoning.
  </PropertiesListItem>
  <PropertiesListItem
    name="showRetrievals"
    type="boolean | 'during' | { ... } | undefined"
    advancedType="boolean | 'during' | { web?: boolean | 'during', knowledge?: boolean | 'during' } | undefined"
  >
    Whether to show retrievals. Defaults to `true`. If set to `'during'`,
    retrievals will only be shown during retrieval.
  </PropertiesListItem>
  <PropertiesListItem name="showSources" type="boolean">
    Whether to show sources. Defaults to `true`.
  </PropertiesListItem>
  <PropertiesListItem name="className" type="string">
    CSS class name to apply to the chat container.
  </PropertiesListItem>
  <PropertiesListItem name="style" type="CSSProperties">
    Inline styles to apply to the chat container. Useful for setting CSS custom
    properties.
  </PropertiesListItem>
</PropertiesList>

###### components [#AiChat-components]

Override specific parts of `AiChat` with custom components.

<PropertiesList>
  <PropertiesListItem
    name="Empty"
    type="({ chatId: string, copilotId?: string }) => ReactNode"
  >
    The component used to render the empty state of the chat. Defaults to
    nothing.
  </PropertiesListItem>
  <PropertiesListItem name="Loading" type="() => ReactNode">
    The component used to render the loading state of the chat. Defaults to a
    loading spinner.
  </PropertiesListItem>
  <PropertiesListItem name="markdown" type="Partial<MarkdownComponents>">
    The components used to render Markdown content.
  </PropertiesListItem>
  <PropertiesListItem
    name="markdown.Paragraph"
    type="({ children: ReactNode }) => ReactNode"
  >
    The component used to render paragraphs.
  </PropertiesListItem>
  <PropertiesListItem
    name="markdown.Inline"
    detailedType={`({ type: "strong" | "em" | "code" | "del", children: ReactNode }) => ReactNode`}
  >
    The component used to render inline elements (bold, italic, strikethrough,
    and inline code).
  </PropertiesListItem>
  <PropertiesListItem
    name="markdown.Link"
    type={`({ href: string, title?: string, children: ReactNode }) => ReactNode`}
  >
    The component used to render links.
  </PropertiesListItem>
  <PropertiesListItem
    name="markdown.Heading"
    type={`({ level: 1 | 2 | 3 | 4 | 5 | 6, children: ReactNode }) => ReactNode`}
  >
    The component used to render headings.
  </PropertiesListItem>
  <PropertiesListItem
    name="markdown.Blockquote"
    type="({ children: ReactNode }) => ReactNode"
  >
    The component used to render blockquotes.
  </PropertiesListItem>
  <PropertiesListItem
    name="markdown.CodeBlock"
    type={`({ code: string, language?: string }) => ReactNode`}
  >
    The component used to render code blocks.
  </PropertiesListItem>
  <PropertiesListItem
    name="markdown.Image"
    type={`({ src: string, alt: string, title?: string }) => ReactNode`}
  >
    The component used to render images.
  </PropertiesListItem>
  <PropertiesListItem
    name="markdown.List"
    detailedType={`({ type: "ordered" | "unordered", items: { checked?: boolean, children: ReactNode }[], start?: number }) => ReactNode`}
  >
    The component used to render lists.
  </PropertiesListItem>
  <PropertiesListItem
    name="markdown.Table"
    detailedType={`({ headings: { align?: "left" | "center" | "right"; children: ReactNode }[], rows: { align?: "left" | "center" | "right"; children: ReactNode }[] }) => ReactNode`}
  >
    The component used to render tables.
  </PropertiesListItem>
  <PropertiesListItem name="markdown.Separator" type="() => ReactNode">
    The component used to render separators.
  </PropertiesListItem>
</PropertiesList>

#### AiTool

Displays [AI tool calls](/docs/ready-made-features/ai-copilots/features#tools)
and their progress. Can be customized for many different UIs.

{/* TODO AI tool image */}

```tsx
<AiTool />
```

By default, `AiTool` will display the name of the current tool, and a loading
spinner as it runs.

```tsx
import { defineAiTool } from "@liveblocks/client";
import { RegisterAiTool } from "@liveblocks/react";
import { AiTool, AiChat } from "@liveblocks/react-ui";

function App() {
  return (
    <>
      <RegisterAiTool
        name="get-weather"
        tool={defineAiTool()({
          description: "Get current weather information",
          parameters: {
            type: "object",
            properties: {
              location: { type: "string", description: "City name" },
            },
            required: ["location"],
            additionalProperties: false,
          },
          execute: async (args) => {
            const { temperature, condition } = await __getWeather__(
              args.location
            );
            return { data: { temperature, condition } };
          },
          render: ({ result }) => (
            // +++
            <AiTool>
              {result ? (
                <div>
                  {result.temperature}Â°F - {result.condition}
                </div>
              ) : null}
            </AiTool>
            // +++
          ),
        })}
      />
      <AiChat chatId="my-chat" />
    </>
  );
}
```

Optionally, you can provide a `title` and `icon` to render the UI differently.

```tsx
// Title
render: () => <AiTool title="Event booked" />

// Title and a collapsible description
render: () => <AiTool title="Event booked">We've booked the event!</AiTool>,

// Title and emoji icon
render: () => <AiTool title="Event booked" icon="ðŸ“…" />,

// Title and icon component
render: () => <AiTool title="Event booked" icon={<Icon.Calendar />} />,

// Props are passed to the inner `div`
render: () => (
  <AiTool
    title="Event booked"
    style={{ marginLeft: 10 }}
    className="event-booked-tool"
    onMouseOver={() => console.log("Hovered")}
  />
),
```

##### Props [#AiTool-props]

<PropertiesList>
  <PropertiesListItem name="title" type="ReactNode">
    The title to display for the tool. If not provided, the tool name will be
    formatted as a human-readable string.
  </PropertiesListItem>
  <PropertiesListItem name="icon" type="ReactNode">
    Icon to display alongside the tool title. Can be an emoji string, React
    component, or any ReactNode.
  </PropertiesListItem>
  <PropertiesListItem name="children" type="ReactNode">
    Content to display inside the tool container. Typically used for
    tool-specific UI or descriptions.
  </PropertiesListItem>
  <PropertiesListItem name="variant" type="'block' | 'minimal'">
    The visual appearance of the tool. The `"block"` variant (default) displays
    the tool as a block with a border.
  </PropertiesListItem>
  <PropertiesListItem name="collapsed" type="boolean">
    Whether the tool content should be collapsed. When collapsed, only the title
    and icon are visible.
  </PropertiesListItem>
  <PropertiesListItem
    name="onCollapsedChange"
    type="(collapsed: boolean) => void"
  >
    Callback fired when the collapsed state changes. Use this to control the
    collapsed state externally.
  </PropertiesListItem>
  <PropertiesListItem name="collapsible" type="boolean">
    Whether the tool content can be collapsed. If set to `false`, clicking on it
    will have no effect. If there's no content, this prop has no effect.
  </PropertiesListItem>
  <PropertiesListItem name="className" type="string">
    CSS class name to apply to the tool container.
  </PropertiesListItem>
  <PropertiesListItem name="style" type="CSSProperties">
    Inline styles to apply to the tool container.
  </PropertiesListItem>
</PropertiesList>

All other HTML `div` props are also supported and will be passed through to the
underlying container element.

##### AiTool.Confirmation

Displays an AI tool with a confirmation UI. This allows you to create actions
that users must confirm or cancel before theyâ€™re run.

```tsx
<AiTool>
  <AiTool.Confirmation confirm={() => /* ... */} cancel={() => /* ... */} />
</AiTool>
```

{/* TODO ai tool confirmation image */}

Use the `confirm` and `cancel` props to define which actions should be taken
when the users clicks the buttons. You can return information that helps the AI
understand what has taken place, and data which you can use in `render` after
the tool is called.

```tsx
import { defineAiTool } from "@liveblocks/client";
import { RegisterAiTool } from "@liveblocks/react";
import { AiTool } from "@liveblocks/react-ui";

const deleteFileTool = defineAiTool<{ deletedFileName: string }>()({
  description: "Delete a file from the user's workspace",
  parameters: {
    type: "object",
    properties: {
      fileName: { type: "string", description: "Name of the file to delete" },
    },
    required: ["fileName"],
    additionalProperties: false,
  },
  render: ({ stage, args, result, types }) => {
    if (stage === "receiving") {
      return "Loading...";
    }
    return (
      <AiTool title="Delete File" icon="ðŸ—‘ï¸">
        {!result.data ? (
          // +++
          <AiTool.Confirmation
            // Make `confirm` and `cancel` type-safe
            types={types}
            confirm={async ({ fileName }) => {
              await deleteFile(fileName);
              return {
                data: { deletedFileName: fileName },
              };
            }}
          >
            Are you sure you want to delete {args.fileName}?
          </AiTool.Confirmation>
        ) : (
          // +++
          <div>Deleted {result.data.deletedFileName}</div>
        )}
      </AiTool>
    );
  },
});

function App() {
  return (
    <>
      <RegisterAiTool name="delete-file" tool={deleteFileTool} />
      <AiChat chatId="my-chat" />
    </>
  );
}
```

`AiTool.Confirmation` will display different content depending on the stage of
the tool. For example, the confirm and cancel buttons will disappear when
clicked.

###### Props [#AiTool.Confirmation-props]

<PropertiesList>
  <PropertiesListItem
    name="confirm"
    type="(args: TArgs) => Promise<ToolResultResponse>"
    required
  >
    Function called when the user clicks the confirm button. It can return data
    which will be stored and accessible in `render`, and optionally also a
    description for the AI to understand the result: `{ data: { formId: 123 }, description: "The user accepted and submitted the form" }`
  </PropertiesListItem>
  <PropertiesListItem
    name="cancel"
    type="(args: TArgs) => Promise<ToolResultResponse>"
  >
    Function called when the user clicks the cancel button.
  </PropertiesListItem>
  <PropertiesListItem name="children" type="ReactNode">
    Content to display in the confirmation UI. Typically a question or
    description of the action being confirmed.
  </PropertiesListItem>
  <PropertiesListItem name="variant" type="'destructive' | 'default'">
    The visual appearance of the confirmation UI.
  </PropertiesListItem>
  <PropertiesListItem
    name="overrides"
    type="Partial<GlobalOverrides & AiToolConfirmationOverrides>"
  >
    Override the componentâ€™s strings. It can be used the change the "confirm"
    and "cancel" labels.
  </PropertiesListItem>
</PropertiesList>

All other HTML `div` props are also supported and will be passed through to the
underlying element.

##### AiTool.Inspector

Displays formatted view of the JSON arguments sent to and results returned by
the AI during the current tool invocation. This is useful for debugging or for
providing developers with insight into the data exchanged within your app.

```tsx
<AiTool>
  <AiTool.Inspector />
</AiTool>
```

To use, simply include `<AiTool.Inspector />` inside an `<AiTool />` component
to display the toolâ€™s input arguments and resulting output.

```tsx
import { defineAiTool } from "@liveblocks/client";
import { RegisterAiTool } from "@liveblocks/react";
import { AiTool, AiChat } from "@liveblocks/react-ui";

function App() {
  return (
    <>
      <RegisterAiTool
        name="toggle-todo"
        tool={defineAiTool()({
          description: "Toggle a todo's completion status",
          parameters: {
            type: "object",
            properties: {
              id: {
                description: "The id of the todo to toggle",
                type: "number",
              },
            },
            required: ["id"],
            additionalProperties: false,
          },
          execute: ({ id }) => {
            toggleTodo(id);
          },
          render: () => (
            <AiTool>
              // +++
              <AiTool.Inspector />
              // +++
            </AiTool>
          ),
        })}
      />
      <AiChat chatId="my-chat" />
    </>
  );
}
```

###### Props [#AiTool.Inspector-props]

All HTML `div` props are supported and will be passed through to the underlying
element.

## Comments

### Default components [#Components]

#### Thread

Displays a thread of comments. Each thread has a composer for creating replies.

```tsx
<Thread thread={thread} />
```

<Figure>
  <Image
    src="/assets/comments/thread.png"
    alt="Thread"
    width={768}
    height={446}
  />
</Figure>

Map through `threads` to render a list of the roomâ€™s threads and comments.
Threads can be retrieved with
[`useThreads`](/docs/api-reference/liveblocks-react#useThreads).

```tsx highlight="10"
import { Thread } from "@liveblocks/react-ui";
import { useThreads } from "@liveblocks/react/suspense";

function Component() {
  const { threads } = useThreads();

  return (
    <>
      {threads.map((thread) => (
        <Thread key={thread.id} thread={thread} />
      ))}
    </>
  );
}
```

##### Resolved and unresolved threads

A thread can be marked as resolved or unresolved via its `resolved` property.
The `Thread` component automatically handles this through its `resolved` toggle
button displayed by default.

You can additionally use `thread.resolved` to filter the displayed threads for
example. Or if you want to create your own `Thread` component using
[the primitives](/docs/ready-made-features/comments/primitives), you can use
[`useMarkThreadAsResolved`](/docs/api-reference/liveblocks-react#useMarkThreadAsResolved)
and
[`useMarkThreadAsUnresolved`](/docs/api-reference/liveblocks-react#useMarkThreadAsUnresolved)
to update the property.

##### Collapsed threads

You can collapse threads by setting the `maxVisibleComments` prop. If a thread
contains more comments than the limit set, some of the comments will be hidden
and a "Show more replies" button will be displayed instead. Clicking on it will
expand the thread to show all comments.

```tsx
<Thread thread={thread} maxVisibleComments={5} />
```

The first and last comments are always visible, and by default the oldest
comments are more likely to be hidden. You can customize this behavior by
setting `maxVisibleComments` to an object.

```tsx
// This is the default behavior, the same as `maxVisibleComments={5}`.
<Thread thread={thread} maxVisibleComments={{ max: 5, show: "newest" }} />

// Only show the last comment, and all the older ones to fit the limit.
<Thread thread={thread} maxVisibleComments={{ max: 5, show: "oldest" }} />

// Show as many old comments as new ones to fit the limit.
<Thread thread={thread} maxVisibleComments={{ max: 5, show: "both" }} />
```

##### Custom dropdown items

`Thread` shows a dropdown menu for threads and comments which contains actions
related to them: â€œSubscribe to threadâ€, â€œEdit commentâ€, â€œDelete commentâ€, etc.

The prop `commentDropdownItems` allows customizing the dropdownâ€™s items, for
example adding new items. Items can be built with the `Comment.DropdownItem`
component which accepts an `onSelect` prop that is called when the item is
selected.

```tsx
<Thread
  commentDropdownItems={
    <>
      <Comment.DropdownItem
        onSelect={() => {
          console.log("Open details");
        }}
      >
        Details
      </Comment.DropdownItem>
      <Comment.DropdownItem
        onSelect={() => {
          console.log("Move comment");
        }}
      >
        Move
      </Comment.DropdownItem>
    </>
  }
/>
```

These new items will be displayed below the default items, but itâ€™s possible to
change that by passing a function. This function receives a `children` prop
which contains the default items, so you can decide to display them above or
below your new items, or even not display them at all. This function also
receives a `comment` prop which contains the comment itâ€™s attached to.

```tsx
<Thread
  // +++
  commentDropdownItems={({ children }) => {
    // +++
    return (
      <>
        <Comment.DropdownItem
          onSelect={() => {
            // +++
            openDetails(comment.id);
            // +++
          }}
        >
          Details
        </Comment.DropdownItem>
        // +++
        {/* The "Details" item will be displayed above the default items */}
        {children}
        // +++
      </>
    );
  }}
/>
```

The `Comment.DropdownItem` component also accepts an `icon` prop to display an
icon next to the itemâ€™s label.

```tsx
<Comment.DropdownItem
  onSelect={() => {
    openDetails(comment.id);
  }}
  // +++
  icon={<Icon.Details />}
  // +++
>
  Details
</Comment.DropdownItem>
```

[`Comment`](/docs/api-reference/liveblocks-react-ui#Comment) offers the same as
`Thread`â€™s `commentDropdownItems` but named `dropdownItems` instead.

##### Props [#Thread-props]

<PropertiesList>
  <PropertiesListItem name="thread" type="ThreadData" required>
    The thread to display.
  </PropertiesListItem>
  <PropertiesListItem
    name="showComposer"
    type='boolean | "collapsed"'
    defaultValue='"collapsed"'
  >
    How to show or hide the composer to reply to the thread.
  </PropertiesListItem>
  <PropertiesListItem
    name="showActions"
    type='boolean | "hover"'
    defaultValue='"hover"'
  >
    How to show or hide the actions.
  </PropertiesListItem>
  <PropertiesListItem name="showReactions" type="boolean" defaultValue="true">
    Whether to show reactions.
  </PropertiesListItem>
  <PropertiesListItem name="showAttachments" type="boolean" defaultValue="true">
    Whether to show attachments.
  </PropertiesListItem>
  <PropertiesListItem
    name="showComposerFormattingControls"
    type="boolean"
    defaultValue="true"
  >
    Whether to show the composerâ€™s formatting controls.
  </PropertiesListItem>
  <PropertiesListItem
    name="blurComposerOnSubmit"
    type="boolean"
    defaultValue="true"
  >
    Whether to blur the composer editor when the composer is submitted.
  </PropertiesListItem>
  <PropertiesListItem
    name="showResolveAction"
    type="boolean"
    defaultValue="true"
  >
    Whether to show the action to resolve the thread.
  </PropertiesListItem>
  <PropertiesListItem
    name="maxVisibleComments"
    type="number | object"
    detailedType='number | { max: number; show: "oldest" | "newest" | "both" }'
    defaultValue="No limit"
  >
    The maximum number of comments to show.
  </PropertiesListItem>
  <PropertiesListItem
    name="indentCommentContent"
    type="boolean"
    defaultValue="true"
  >
    Whether to indent the commentsâ€™ content.
  </PropertiesListItem>
  <PropertiesListItem
    name="showDeletedComments"
    type="boolean"
    defaultValue="false"
  >
    Whether to show deleted comments.
  </PropertiesListItem>
  <PropertiesListItem
    name="commentDropdownItems"
    type="ReactNode | (props) => ReactNode"
    detailedType="ReactNode | ((props: { children: ReactNode, comment: CommentData }) => ReactNode)"
  >
    Add (or change) items to display in the commentâ€™s dropdown.
  </PropertiesListItem>
  <PropertiesListItem
    name="onComposerSubmit"
    type="function"
    detailedType="(comment: ComposerSubmitComment, event: FormEvent<HTMLFormElement>) => Promise<void> | void"
  >
    The event handler called when the composer is submitted.
  </PropertiesListItem>
  <PropertiesListItem
    name="onResolvedChange"
    type="function"
    detailedType="(resolved: boolean) => void"
  >
    The event handler called when changing the resolved status.
  </PropertiesListItem>
  <PropertiesListItem
    name="onThreadDelete"
    type="function"
    detailedType="(thread: ThreadData) => void"
  >
    The event handler called when the thread is deleted. A thread is deleted
    when all its comments are deleted.
  </PropertiesListItem>
  <PropertiesListItem
    name="onCommentEdit"
    type="function"
    detailedType="(comment: CommentData) => void"
  >
    The event handler called when a comment is edited.
  </PropertiesListItem>
  <PropertiesListItem
    name="onCommentDelete"
    type="function"
    detailedType="(comment: CommentData) => void"
  >
    The event handler called when a comment is deleted.
  </PropertiesListItem>
  <PropertiesListItem
    name="onAuthorClick"
    type="function"
    detailedType="(userId: string, event: MouseEvent<HTMLElement>) => void"
  >
    The event handler called when clicking on a commentâ€™s author.
  </PropertiesListItem>
  <PropertiesListItem
    name="onMentionClick"
    type="function"
    detailedType="(mention: MentionData, event: MouseEvent<HTMLElement>) => void"
  >
    The event handler called when clicking on a mention.
  </PropertiesListItem>
  <PropertiesListItem
    name="onAttachmentClick"
    type="function"
    detailedType="(args: CommentAttachmentArgs, event: MouseEvent<HTMLElement>) => void"
  >
    The event handler called when clicking on a commentâ€™s attachment.
  </PropertiesListItem>
  <PropertiesListItem
    name="overrides"
    type="Partial<GlobalOverrides & ThreadOverrides & CommentOverrides & ComposerOverrides>"
  >
    Override the componentâ€™s strings.
  </PropertiesListItem>
</PropertiesList>

{/* TODO: Document classes and data attributes */}

#### Composer

Displays a composer for creating threads or comments.

```tsx
<Composer />
```

<Figure>
  <Image
    src="/assets/comments/composer.png"
    alt="Composer"
    width={768}
    height={446}
  />
</Figure>

By default, submitting the composer will create a new thread.

```tsx
import { Composer } from "@liveblocks/react-ui";

// Creates a new thread
function Component() {
  return <Composer />;
}
```

##### Adding thread metadata

If youâ€™d like to attach custom metadata to the newly created thread, you can add
a `metadata` prop.

```tsx
import { Composer } from "@liveblocks/react-ui";

// Creates a new thread with custom metadata
function Component() {
  return (
    <Composer
      metadata={{
        // Custom metadata here, e.g. colors, coordinates
        color: "purple",
        x: 80,
        y: 120,
      }}
    />
  );
}
```

###### Typed metadata

You can use TypeScript to type your custom metadata by editing your config file.
Metadata properties can be `string`, `number`, or `boolean`.

```ts file="liveblocks.config.ts"
declare global {
  interface Liveblocks {
    // Set your custom metadata types
    // +++
    ThreadMetadata: {
      // Example types, e.g. colors, coordinates
      color: string;
      x: number;
      y: number;
    };
    CommentMetadata: {
      // Example types, e.g. tags, context, external IDs
      tag?: string;
      spam: boolean;
      slackMessageTs: string;
    };
    // +++

    // Other types
    // ...
  }
}
```

##### Replying to a thread

If you provide a `threadId`, then submitting the composer will add a new reply
to the thread.

```tsx
import { Composer } from "@liveblocks/react-ui";

// Adds a new comment to a thread
function Component({ threadId }) {
  return <Composer threadId={threadId} />;
}
```

##### Adding comment metadata

If youâ€™d like to attach custom metadata to a reply, you can add a
`commentMetadata` prop.

```tsx
import { Composer } from "@liveblocks/react-ui";

// Creates a new reply to an existing thread with custom metadata
function Component({ threadId }) {
  return (
    <Composer
      threadId={threadId}
      commentMetadata={{
        // Custom metadata here, e.g. tags, context, external IDs
        tag: "important",
        spam: false,
      }}
    />
  );
}
```

##### Modifying a comment

If you provide both a `threadId` and a `commentId`, then submitting the composer
will edit the comment.

```tsx
import { Composer } from "@liveblocks/react-ui";

// Edits an existing comment
function Component({ threadId, commentId }) {
  return <Composer threadId={threadId} commentId={commentId} />;
}
```

##### Custom behavior

If youâ€™d like to customize submission behavior, you can use
`event.preventDefault()` in `onComposerSubmit` to disable the default behavior
and call comment and thread mutation methods manually.

```tsx
import { Composer } from "@liveblocks/react-ui";
import { useEditComment, useAddReaction } from "@liveblocks/react/suspense";

// Custom submission behavior (edits a comment and adds a reaction)
function Component({ threadId, commentId }) {
  const editComment = useEditComment();
  const addReaction = useAddReaction();

  return (
    <Composer
      onComposerSubmit={({ body, attachments }, event) => {
        event.preventDefault();

        // Example mutations
        editComment({ threadId, commentId, body, attachments });
        addReaction({ threadId, commentId, emoji: "âœ…" });

        // Other custom behavior
        // ...
      }}
    />
  );
}
```

Learn more about mutation hooks under
[`@liveblocks/react`](/docs/api-reference/liveblocks-react#Comments).

##### Props [#Composer-props]

<PropertiesList>
  <PropertiesListItem name="threadId" type="string">
    The ID of the thread to reply to or to edit a comment in.
  </PropertiesListItem>
  <PropertiesListItem name="commentId" type="string">
    The ID of the comment to edit.
  </PropertiesListItem>
  <PropertiesListItem name="metadata" type="ThreadMetadata">
    The metadata of the thread to create.
  </PropertiesListItem>
  <PropertiesListItem
    name="commentMetadata"
    type="CommentMetadata | Partial<CommentMetadata>"
  >
    The metadata of the comment to create or edit.
  </PropertiesListItem>
  <PropertiesListItem
    name="onComposerSubmit"
    type="function"
    detailedType="(comment: ComposerSubmitComment, event: FormEvent<HTMLFormElement>) => Promise<void> | void"
  >
    The event handler called when the composer is submitted.
  </PropertiesListItem>
  <PropertiesListItem name="blurOnSubmit" type="boolean" defaultValue="true">
    Whether to blur the composer editor when the composer is submitted.
  </PropertiesListItem>
  <PropertiesListItem name="defaultValue" type="CommentBody">
    The composerâ€™s initial value.
  </PropertiesListItem>
  <PropertiesListItem name="defaultAttachments" type="CommentAttachment[]">
    The composerâ€™s initial attachments.
  </PropertiesListItem>
  <PropertiesListItem name="collapsed" type="boolean">
    Whether the composer is collapsed. Setting a value will make the composer
    controlled.
  </PropertiesListItem>
  <PropertiesListItem
    name="onCollapsedChange"
    type="function"
    detailedType="(collapsed: boolean) => void"
  >
    The event handler called when the collapsed state of the composer changes.
  </PropertiesListItem>
  <PropertiesListItem name="showAttachments" type="boolean" defaultValue="true">
    Whether to show and allow adding attachments.
  </PropertiesListItem>
  <PropertiesListItem
    name="showFormattingControls"
    type="boolean"
    defaultValue="true"
  >
    Whether to show formatting controls (e.g. a floating toolbar with formatting
    toggles when selecting text)
  </PropertiesListItem>
  <PropertiesListItem name="defaultCollapsed" type="boolean">
    Whether the composer is initially collapsed. Setting a value will make the
    composer uncontrolled.
  </PropertiesListItem>
  <PropertiesListItem name="disabled" type="boolean">
    Whether the composer is disabled.
  </PropertiesListItem>
  <PropertiesListItem name="autoFocus" type="boolean">
    Whether to focus the composer on mount.
  </PropertiesListItem>
  <PropertiesListItem
    name="overrides"
    type="Partial<GlobalOverrides & ComposerOverrides>"
  >
    Override the componentâ€™s strings.
  </PropertiesListItem>
</PropertiesList>

#### Comment

Displays a single comment.

```tsx
<Comment comment={comment} />
```

<Figure>
  <Image
    src="/assets/comments/comment.png"
    alt="Comment"
    width={768}
    height={446}
  />
</Figure>

Map through `thread.comments` to render each comment in a thread. Threads can be
retrieved with [`useThreads`](/docs/api-reference/liveblocks-react#useThreads).

```tsx highlight="9"
import { Comment } from "@liveblocks/react-ui";
import { ThreadData } from "@liveblocks/client";

// Renders a list of comments attach to the specified `thread`
function Component({ thread }: { thread: ThreadData }) {
  return (
    <>
      {thread.comments.map((comment) => (
        <Comment key={comment.id} comment={comment} />
      ))}
    </>
  );
}
```

##### Custom thread components

[`Comment`](#Comment) can be used in combination with [`Composer`](#Composer) to
create a custom thread component. The composer in this example is used to
[reply to the existing thread](/docs/api-reference/liveblocks-react-ui#Replying-to-a-thread).

```tsx highlight="10"
import { Comment, Composer } from "@liveblocks/react-ui";
import { ThreadData } from "@liveblocks/client";
import { useThreads } from "@liveblocks/react/suspense";

// Renders a list of comments and a composer for adding new comments
function CustomThread({ thread }: { thread: ThreadData }) {
  return (
    <>
      {thread.comments.map((comment) => (
        <Comment key={comment.id} comment={comment} />
      ))}
      <Composer threadId={thread.id} />
    </>
  );
}

// Renders a list of custom thread components
function Component() {
  const { threads } = useThreads();

  return (
    <>
      {threads.map((thread) => (
        <CustomThread key={thread.id} />
      ))}
    </>
  );
}
```

##### Props [#Comment-props]

<PropertiesList>
  <PropertiesListItem name="comment" type="CommentData" required>
    The comment to display.
  </PropertiesListItem>
  <PropertiesListItem
    name="showActions"
    type='boolean | "hover"'
    defaultValue='"hover"'
  >
    How to show or hide the actions.
  </PropertiesListItem>
  <PropertiesListItem name="showReactions" type="boolean" defaultValue="true">
    Whether to show reactions.
  </PropertiesListItem>
  <PropertiesListItem name="showAttachments" type="boolean" defaultValue="true">
    Whether to show attachments.
  </PropertiesListItem>
  <PropertiesListItem
    name="showComposerFormattingControls"
    type="boolean"
    defaultValue="true"
  >
    Whether to show the composerâ€™s formatting controls when editing the comment.
  </PropertiesListItem>
  <PropertiesListItem name="indentContent" type="boolean" defaultValue="true">
    Whether to indent the commentâ€™s content.
  </PropertiesListItem>
  <PropertiesListItem name="showDeleted" type="boolean" defaultValue="false">
    Whether to show the comment if it was deleted. If set to `false`, it will
    render deleted comments as `null`.
  </PropertiesListItem>
  <PropertiesListItem
    name="dropdownItems"
    type="ReactNode | (props) => ReactNode"
    detailedType="ReactNode | ((props: { children: ReactNode, comment: CommentData }) => ReactNode)"
  >
    Add (or change) items to display in the commentâ€™s dropdown.
  </PropertiesListItem>
  <PropertiesListItem
    name="onCommentEdit"
    type="function"
    detailedType="(comment: CommentData) => void"
  >
    The event handler called when the comment is edited.
  </PropertiesListItem>
  <PropertiesListItem
    name="onCommentDelete"
    type="function"
    detailedType="(comment: CommentData) => void"
  >
    The event handler called when the comment is deleted.
  </PropertiesListItem>
  <PropertiesListItem
    name="onAuthorClick"
    type="function"
    detailedType="(userId: string, event: MouseEvent<HTMLElement>) => void"
  >
    The event handler called when clicking on the author.
  </PropertiesListItem>
  <PropertiesListItem
    name="onMentionClick"
    type="function"
    detailedType="(mention: MentionData, event: MouseEvent<HTMLElement>) => void"
  >
    The event handler called when clicking on a mention.
  </PropertiesListItem>
  <PropertiesListItem
    name="onAttachmentClick"
    type="function"
    detailedType="(args: CommentAttachmentArgs, event: MouseEvent<HTMLElement>) => void"
  >
    The event handler called when clicking on a commentâ€™s attachment.
  </PropertiesListItem>
  <PropertiesListItem
    name="overrides"
    type="Partial<GlobalOverrides & CommentOverrides & ComposerOverrides>"
  >
    Override the componentâ€™s strings.
  </PropertiesListItem>
</PropertiesList>

### Primitives

Primitives are unstyled, headless components that can be used to create fully
custom commenting experiences. We have a
[primitives example](/examples/comments-primitives) highlighting how to use
them.

<Banner title="Using primitives with TypeScript">

If you run into the
`Cannot find module '@liveblocks/react-ui/primitives' or its corresponding type declarations`
error, you should update your `tsconfig.json`â€™s `moduleResolution`
[property](https://www.typescriptlang.org/tsconfig#moduleResolution) to
`"node16"` or `"nodenext"` (or `"bundler"` if youâ€™re on TS >=5).

</Banner>

#### Composition

All primitives are composable; they forward their props and refs, merge their
classes and styles, and chain their event handlers.

Inspired by [Radix](https://www.radix-ui.com/) (and powered by its
[`Slot`](https://www.radix-ui.com/primitives/docs/utilities/slot) utility), most
of the primitives also support an `asChild` prop to replace the rendered element
by any provided child, and both set of props will be merged.

```tsx
import { Button } from "@/my-design-system";

// Use the default <button> element
<Composer.Submit disabled>Send</Composer.Submit>;

// Use an existing custom <Button> component
<Composer.Submit disabled asChild>
  <Button variant="primary">Send</Button>
</Composer.Submit>;
```

Learn more about this concept on
[Radixâ€™s composition guide](https://www.radix-ui.com/primitives/docs/guides/composition).

#### Composer [#primitives-Composer]

Used to render a composer for creating, or editing, threads and comments.

```tsx
<Composer.Form>
  <Composer.AttachmentsDropArea />
  <Composer.Editor
    components={{
      Mention: () => <Composer.Mention />,
      MentionSuggestions: () => (
        <Composer.Suggestions>
          <Composer.SuggestionsList>
            <Composer.SuggestionsListItem />
          </Composer.SuggestionsList>
        </Composer.Suggestions>
      ),
      Link: () => <Composer.Link />,
    }}
  />
  <Composer.AttachFiles />
  <Composer.Submit />
</Composer.Form>
```

Combine with
[`useCreateThread`](/docs/api-reference/liveblocks-react#useCreateThread) to
render a composer that creates threads.

```tsx
import {
  Composer,
  CommentBodyLinkProps,
  CommentBodyMentionProps,
  ComposerEditorMentionSuggestionsProps,
  ComposerSubmitComment,
} from "@liveblocks/react-ui/primitives";
import { useCreateThread, useUser } from "@liveblocks/react/suspense";
import { FormEvent } from "react";

// Render a custom composer that creates a thread on submit
function MyComposer() {
  // +++
  const createThread = useCreateThread();
  // +++

  function handleComposerSubmit(
    { body, attachments }: ComposerSubmitComment,
    event: FormEvent<HTMLFormElement>
  ) {
    event.preventDefault();

    // Create a new thread
    // +++
    const thread = createThread({
      body,
      attachments,
      metadata: {},
    });
    // +++
  }

  return (
    // +++
    <Composer.Form onComposerSubmit={handleComposerSubmit}>
      <Composer.Editor
        components={{
          Mention,
          MentionSuggestions,
          Link,
        }}
      />
      <Composer.Submit>Create thread</Composer.Submit>
    </Composer.Form>
    // +++
  );
}

// Render a mention in the composer's editor, e.g. "@Emil Joyce"
function Mention({ mention }: CommentBodyMentionProps) {
  return <Comment.Mention>@{mention.id}</Comment.Mention>;
}

// Render a list of mention suggestions, used after typing "@" in the editor
function MentionSuggestions({
  mentions,
  selectedMentionId,
}: ComposerEditorMentionSuggestionsProps) {
  return (
    <Composer.Suggestions>
      <Composer.SuggestionsList>
        {mentions.map((mention) => {
          switch (mention.kind) {
            case "user":
              return (
                <UserMentionSuggestion key={mention.id} userId={mention.id} />
              );
            case "group":
              return (
                <GroupMentionSuggestion key={mention.id} groupId={mention.id} />
              );
          }
        })}
      </Composer.SuggestionsList>
    </Composer.Suggestions>
  );
}

// Render a single mention suggestion from a `userId`
function UserMentionSuggestion({ userId }: { userId: string }) {
  const { user } = useUser(userId);

  return (
    <Composer.SuggestionsListItem value={user.id}>
      <img src={user.avatar} alt={user.name} />
      {user.name}
    </Composer.SuggestionsListItem>
  );
}

// Render a single mention suggestion from a `groupId`
function GroupMentionSuggestion({ groupId }: { groupId: string }) {
  const { group } = useGroupInfo(groupId);

  return (
    <Composer.SuggestionsListItem value={group.id}>
      <img src={group.avatar} alt={group.name} />
      {group.name}
    </Composer.SuggestionsListItem>
  );
}

// Render a link in the composer's editor, e.g. "https://liveblocks.io"
function Link({ href, children }: CommentBodyLinkProps) {
  return <Comment.Link href={href}>{children}</Comment.Link>;
}
```

##### Composer.Form [#primitives-Composer.Form]

Surrounds the composerâ€™s content and handles submissions. By default, no action
occurs when the composer is submitted. You must create your own mutations within
`onComposerSubmit` for
[creating threads](/docs/api-reference/liveblocks-react#useCreateThread),
[creating comments](/docs/api-reference/liveblocks-react#useCreateComment),
[editing comments](/docs/api-reference/liveblocks-react#useEditComment), etc.

```tsx
<Composer.Form
  onComposerSubmit={({ body, attachments }) => {
    // Mutate your comments
    // ...
  }}
>
  {/* ... */}
</Composer.Form>
```

<PropertiesList>
  <PropertiesListItem name="defaultAttachments" type="CommentAttachment[]">
    The composerâ€™s initial attachments.
  </PropertiesListItem>
  <PropertiesListItem
    name="pasteFilesAsAttachments"
    type="boolean"
    defaultValue="false"
  >
    Whether to create attachments when pasting files into the editor.
  </PropertiesListItem>
  <PropertiesListItem
    name="preventUnsavedChanges"
    type="boolean"
    defaultValue="true"
  >
    When `preventUnsavedChanges` is set on your [Liveblocks
    client](/docs/api-reference/liveblocks-client#prevent-users-losing-unsaved-changes)
    on
    [`LiveblocksProvider`](/docs/api-reference/liveblocks-react#prevent-users-losing-unsaved-changes),
    then closing a browser tab will be prevented when there are unsaved changes.
    By default, that will include draft text or attachments that are being
    uploaded via this composer, but not submitted yet. If you want to prevent
    unsaved changes with Liveblocks, but not for this composer, you can opt-out
    this composer instance by setting this prop to `false`.
  </PropertiesListItem>
  <PropertiesListItem name="blurOnSubmit" type="boolean" defaultValue="true">
    Whether to blur the editor when the form is submitted.
  </PropertiesListItem>
  <PropertiesListItem
    name="onComposerSubmit"
    type="function"
    detailedType="(comment: ComposerSubmitComment, event: FormEvent<HTMLFormElement>) => Promise<void> | void"
  >
    The event handler called when the form is submitted.
  </PropertiesListItem>
  <PropertiesListItem name="disabled" type="boolean" defaultValue="false">
    Whether the composer is disabled.
  </PropertiesListItem>
  <PropertiesListItem name="asChild" type="boolean" defaultValue="false">
    Replace the rendered element by the one passed as a child.
  </PropertiesListItem>
</PropertiesList>

##### Composer.Editor [#primitives-Composer.Editor]

Displays the composerâ€™s editor.

```tsx
<Composer.Editor placeholder="Write a commentâ€¦" />
```

<PropertiesList>
  <PropertiesListItem name="defaultValue" type="CommentBody">
    The editorâ€™s initial value.
  </PropertiesListItem>
  <PropertiesListItem name="placeholder" type="string">
    The text to display when the editor is empty.
  </PropertiesListItem>
  <PropertiesListItem name="disabled" type="boolean">
    Whether the editor is disabled.
  </PropertiesListItem>
  <PropertiesListItem name="autoFocus" type="boolean">
    Whether to focus the editor on mount.
  </PropertiesListItem>
  <PropertiesListItem name="dir" type='"ltr" | "rtl"'>
    The reading direction of the editor and related elements.
  </PropertiesListItem>
  <PropertiesListItem
    name="components"
    type="Partial<ComposerEditorComponents>"
  >
    The components displayed within the editor.
  </PropertiesListItem>
</PropertiesList>

<Table columns={["28%", "auto"]}>

| Attribute       | Value                                   |
| --------------- | --------------------------------------- |
| `data-focused`  | Present when the component is focused.  |
| `data-disabled` | Present when the component is disabled. |

</Table>

###### components [#primitives-Composer.Editor-components]

The components displayed within the editor.

<PropertiesList>
  <PropertiesListItem
    name="Mention"
    type="ComponentType<ComposerEditorMentionProps>"
  >
    The component used to display mentions. Defaults to the mentionâ€™s `id`
    prefixed by an @.
  </PropertiesListItem>
  <PropertiesListItem
    name="MentionSuggestions"
    type="ComponentType<ComposerEditorMentionSuggestionProps>"
  >
    The component used to display mention suggestions. Defaults to a list of the
    suggested mentionsâ€™ `id`.
  </PropertiesListItem>
  <PropertiesListItem name="Link" type="ComponentType<ComposerEditorLinkProps>">
    The component used to display links. Defaults to the linkâ€™s `children`
    property.
  </PropertiesListItem>
  <PropertiesListItem
    name="FloatingToolbar"
    type="ComponentType<ComposerEditorFloatingToolbarProps>"
  >
    The component used to display a floating toolbar attached to the selection.
  </PropertiesListItem>
</PropertiesList>

###### Mention [#primitives-Composer.Editor-Mention]

The component used to display mentions.

```tsx
<Composer.Editor
  components={{
    Mention: ({ mention, isSelected }) => (
      <Composer.Mention>@{mention.id}</Composer.Mention>
    ),
  }}
/>
```

<PropertiesList>
  <PropertiesListItem name="mention" type="MentionData">
    The mention to display.
  </PropertiesListItem>
  <PropertiesListItem name="isSelected" type="boolean">
    Whether the mention is selected.
  </PropertiesListItem>
</PropertiesList>

###### MentionSuggestions [#primitives-Composer.Editor-MentionSuggestions]

The component used to display mention suggestions.

<PropertiesList>
  <PropertiesListItem name="mentions" type="MentionData[]">
    The list of suggested mentions.
  </PropertiesListItem>
  <PropertiesListItem name="selectedMentionId" type="string">
    The currently selected mentionâ€™s ID.
  </PropertiesListItem>
</PropertiesList>

```tsx
<Composer.Editor
  components={{
    MentionSuggestions: () => (
      <Composer.Suggestions>
        <Composer.SuggestionsList>
          <Composer.SuggestionsListItem />
        </Composer.SuggestionsList>
      </Composer.Suggestions>
    ),
  }}
/>
```

###### Link [#primitives-Composer.Editor-Link]

The component used to display links.

```tsx
<Composer.Editor
  components={{
    Link: ({ href, children }) => <Composer.Link>{children}</Composer.Link>,
  }}
/>
```

<PropertiesList>
  <PropertiesListItem name="href" type="string">
    The linkâ€™s absolute URL.
  </PropertiesListItem>
  <PropertiesListItem name="children" type="ReactNode">
    The linkâ€™s content.
  </PropertiesListItem>
</PropertiesList>

###### FloatingToolbar [#primitives-Composer.Editor-FloatingToolbar]

Displays a floating toolbar attached to the selection within `Composer.Editor`.

```tsx
<Composer.Editor
  components={{
    FloatingToolbar: () => (
      <Composer.FloatingToolbar>
        <Composer.MarkToggle mark="bold">Bold</Composer.MarkToggle>
        <Composer.MarkToggle mark="italic">Italic</Composer.MarkToggle>
      </Composer.FloatingToolbar>
    ),
  }}
/>
```

##### Composer.Mention [#primitives-Composer.Mention]

Displays mentions within `Composer.Editor`.

```tsx
<Composer.Mention>@{mention.id}</Composer.Mention>
```

<PropertiesList>
  <PropertiesListItem name="asChild" type="boolean" defaultValue="false">
    Replace the rendered element by the one passed as a child.
  </PropertiesListItem>
</PropertiesList>

<Table columns={["28%", "auto"]}>

| Attribute       | Value                                 |
| --------------- | ------------------------------------- |
| `data-selected` | Present when the mention is selected. |

</Table>

##### Composer.Suggestions [#primitives-Composer.Suggestions]

Contains suggestions within `Composer.Editor`.

```tsx
<Composer.Suggestions>{/* ... */}<Composer.Suggestions>
```

<PropertiesList>
  <PropertiesListItem name="asChild" type="boolean" defaultValue="false">
    Replace the rendered element by the one passed as a child.
  </PropertiesListItem>
</PropertiesList>

##### Composer.SuggestionsList [#primitives-Composer.SuggestionsList]

Displays a list of suggestions within `Composer.Editor`.

```tsx
<Composer.SuggestionsList>
  {mentions.map((mention) => (
    <Composer.SuggestionsListItem key={mention.id} value={mention.id}>
      @{mention.id}
    </Composer.SuggestionsListItem>
  ))}
</Composer.SuggestionsList>
```

<PropertiesList>
  <PropertiesListItem name="asChild" type="boolean" defaultValue="false">
    Replace the rendered element by the one passed as a child.
  </PropertiesListItem>
</PropertiesList>

##### Composer.SuggestionsListItem [#primitives-Composer.SuggestionsListItem]

Displays a suggestion within `Composer.SuggestionsList`.

```tsx
<Composer.SuggestionsListItem key={mention.id} value={mention.id}>
  @{mention.id}
</Composer.SuggestionsListItem>
```

<PropertiesList>
  <PropertiesListItem name="value" type="string" required>
    The suggestionâ€™s value.
  </PropertiesListItem>
  <PropertiesListItem name="asChild" type="boolean" defaultValue="false">
    Replace the rendered element by the one passed as a child.
  </PropertiesListItem>
</PropertiesList>

<Table columns={["28%", "auto"]}>

| Attribute       | Value                              |
| --------------- | ---------------------------------- |
| `data-selected` | Present when the item is selected. |

</Table>

##### Composer.Link [#primitives-Composer.Link]

Displays links within `Composer.Editor`.

```tsx
<Composer.Link href={href}>{children}</Composer.Link>
```

<PropertiesList>
  <PropertiesListItem name="asChild" type="boolean" defaultValue="false">
    Replace the rendered element by the one passed as a child.
  </PropertiesListItem>
</PropertiesList>

##### Composer.Submit [#primitives-Composer.Submit]

A button to submit the composer.

```tsx
<Composer.Submit>Send</Composer.Submit>
```

<PropertiesList>
  <PropertiesListItem name="asChild" type="boolean" defaultValue="false">
    Replace the rendered element by the one passed as a child.
  </PropertiesListItem>
</PropertiesList>

##### Composer.FloatingToolbar [#primitives-Composer.FloatingToolbar]

Displays a floating toolbar attached to the selection within `Composer.Editor`.

```tsx
<Composer.FloatingToolbar>
  <Composer.MarkToggle mark="bold">Bold</Composer.MarkToggle>
  <Composer.MarkToggle mark="italic">Italic</Composer.MarkToggle>
</Composer.FloatingToolbar>
```

<PropertiesList>
  <PropertiesListItem name="asChild" type="boolean" defaultValue="false">
    Replace the rendered element by the one passed as a child.
  </PropertiesListItem>
</PropertiesList>

##### Composer.MarkToggle

A toggle button which toggles a specific text mark.

```tsx
<Composer.MarkToggle mark="bold">Bold</Composer.MarkToggle>
```

<PropertiesList>
  <PropertiesListItem name="mark" type="ComposerBodyMark" required>
    The text mark to toggle.
  </PropertiesListItem>
  <PropertiesListItem
    name="onValueChange"
    type="function"
    detailedType="(mark: ComposerBodyMark) => void"
  >
    The event handler called when the mark is toggled.
  </PropertiesListItem>
  <PropertiesListItem name="asChild" type="boolean" defaultValue="false">
    Replace the rendered element by the one passed as a child.
  </PropertiesListItem>
</PropertiesList>

##### Composer.AttachFiles [#primitives-Composer.AttachFiles]

A button which opens a file picker to create attachments.

```tsx
<Composer.AttachFiles>Attach files</Composer.AttachFiles>
```

<PropertiesList>
  <PropertiesListItem name="asChild" type="boolean" defaultValue="false">
    Replace the rendered element by the one passed as a child.
  </PropertiesListItem>
</PropertiesList>

##### Composer.AttachmentsDropArea [#primitives-Composer.AttachmentsDropArea]

A drop area which accepts files to create attachments.

```tsx
<Composer.AttachmentsDropArea>Drop files here</Composer.AttachmentsDropArea>
```

<PropertiesList>
  <PropertiesListItem name="asChild" type="boolean" defaultValue="false">
    Replace the rendered element by the one passed as a child.
  </PropertiesListItem>
</PropertiesList>

#### Comment [#primitives-Comment]

Used to render a single comment.

```tsx
<Comment.Body
  components={{
    Mention: Comment.Mention,
    Link: Comment.Link,
  }}
/>
```

Map through `thread.comments` to render each comment in a thread. Threads can be
retrieved with [`useThreads`](/docs/api-reference/liveblocks-react#useThreads).

```tsx highlight="13-21"
import {
  Comment,
  CommentBodyLinkProps,
  CommentBodyMentionProps,
} from "@liveblocks/react-ui/primitives";
import { ThreadData } from "@liveblocks/client";

// Render custom comments in a thread. Pass a thread from `useThreads`.
function MyComments({ thread }: { thread: ThreadData }) {
  return (
    <>
      {thread.comments.map((comment) => (
        <div key={comment.id}>
          <Comment.Body
            body={comment.body}
            components={{
              Mention,
              Link,
            }}
          />
        </div>
      ))}
    </>
  );
}

// Render a mention in the comment, e.g. "@Emil Joyce"
function Mention({ mention }: CommentBodyMentionProps) {
  return <Comment.Mention>@{mention.id}</Comment.Mention>;
}

// Render a link in the comment, e.g. "https://liveblocks.io"
function Link({ href, children }: CommentBodyLinkProps) {
  return <Comment.Link href={href}>{children}</Comment.Link>;
}
```

##### Comment.Body [#primitives-Comment.Body]

Displays a comment body.

```tsx
<Comment.Body body={comment.body} />
```

<PropertiesList>
  <PropertiesListItem name="body" type="CommentBody">
    The comment body to display. If not defined, the component will render
    `null`.
  </PropertiesListItem>
  <PropertiesListItem name="components" type="Partial<CommentBodyComponents>">
    The components displayed within the comment body.
  </PropertiesListItem>
  <PropertiesListItem name="asChild" type="boolean" defaultValue="false">
    Replace the rendered element by the one passed as a child.
  </PropertiesListItem>
</PropertiesList>

###### components [#primitives-Comment.Body-components]

The components displayed within the comment body.

<PropertiesList>
  <PropertiesListItem
    name="Mention"
    type="ComponentType<CommentBodyMentionProps>"
  >
    The component used to display mentions. Defaults to the mentionâ€™s `id`
    prefixed by an @.
  </PropertiesListItem>
  <PropertiesListItem name="Link" type="ComponentType<CommentBodyLinkProps>">
    The component used to display links. Defaults to the linkâ€™s `children`
    property.
  </PropertiesListItem>
</PropertiesList>

###### Mention [#primitives-Comment.Body-Mention]

The component used to display mentions.

```tsx
<Comment.Body
  components={{
    Mention: ({ mention }) => <Comment.Mention>@{mention.id}</Comment.Mention>,
  }}
/>
```

<PropertiesList>
  <PropertiesListItem name="mention" type="MentionData">
    The mention to display.
  </PropertiesListItem>
</PropertiesList>

###### Link [#primitives-Comment.Body-Link]

The component used to display links.

```tsx
<Comment.Body
  components={{
    Link: ({ href, children }) => (
      <Comment.Link href={href}>{children}</Comment.Link>
    ),
  }}
/>
```

<PropertiesList>
  <PropertiesListItem name="href" type="string">
    The linkâ€™s absolute URL.
  </PropertiesListItem>
  <PropertiesListItem name="children" type="ReactNode">
    The linkâ€™s content.
  </PropertiesListItem>
</PropertiesList>

##### Comment.Mention [#primitives-Comment.Mention]

Displays mentions within `Comment.Body`.

```tsx
<Comment.Mention>@{mention.id}</Comment.Mention>
```

<PropertiesList>
  <PropertiesListItem name="asChild" type="boolean" defaultValue="false">
    Replace the rendered element by the one passed as a child.
  </PropertiesListItem>
</PropertiesList>

##### Comment.Link [#primitives-Comment.Link]

Displays links within `Comment.Body`.

```tsx
<Comment.Link href={href}>{children}</Comment.Link>
```

<PropertiesList>
  <PropertiesListItem name="asChild" type="boolean" defaultValue="false">
    Replace the rendered element by the one passed as a child.
  </PropertiesListItem>
</PropertiesList>

#### Timestamp [#primitives-Timestamp]

Displays a formatted date, and automatically re-renders to support relative
formatting. Defaults to relative formatting for nearby dates (e.g. â€œ5 minutes
agoâ€ or "in 1 day") and a short absolute formatting for more distant ones (e.g.
â€œ25 Augâ€).

```tsx
<Timestamp date={new Date()} />
```

Use with `comment.createdAt`, `comment.editedAt`, or `comment.deletedAt` to
display a human-readable time.

```tsx
import { Timestamp, Comment } from "@liveblocks/react-ui/primitives";
import { ThreadData } from "@liveblocks/client";

function MyComments({ thread }: { thread: ThreadData }) {
  return (
    <>
      {thread.comments.map((comment) => (
        <div key={comment.id}>
          // +++
          <Timestamp date={comment.createdAt} />
          // +++
          <Comment.Body body={comment.body} components={/* ... */} />
        </div>
      ))}
    </>
  );
}
```

<PropertiesList>
  <PropertiesListItem name="date" type="Date | string | number" required>
    The date to display.
  </PropertiesListItem>
  <PropertiesListItem
    name="children"
    type="function"
    detailedType="(date: Date) => ReactNode"
  >
    A function to format the displayed date. Defaults to a relative date
    formatting function.
  </PropertiesListItem>
  <PropertiesListItem
    name="title"
    type="string | function"
    detailedType="string | ((date: Date) => string)"
  >
    The `title` attributeâ€™s value or a function to format it. Defaults to an
    absolute date formatting function.
  </PropertiesListItem>
  <PropertiesListItem
    name="interval"
    type="number | false"
    defaultValue="30000"
  >
    The interval in milliseconds at which the component will re-render. Can be
    set to `false` to disable re-rendering.
  </PropertiesListItem>
  <PropertiesListItem name="locale" type="string">
    The locale used when formatting the date. Defaults to the browserâ€™s locale.
  </PropertiesListItem>
  <PropertiesListItem name="asChild" type="boolean" defaultValue="false">
    Replace the rendered element by the one passed as a child.
  </PropertiesListItem>
</PropertiesList>

#### Duration [#primitives-Duration]

Displays a formatted duration, and automatically re-renders to if the duration
is in progress. Defaults to a short format (e.g. â€œ5sâ€ or â€œ1m 40sâ€).

```tsx
<Duration duration={3 * 60 * 1000} />
```

Instead of providing a duration in milliseconds, you can also provide start and
end dates for the duration via the `from` and `to` props. If only `from` is
provided it means that the duration is in progress, and the component will
re-render at an interval, customizable with the `interval` prop.

<PropertiesList>
  <PropertiesListItem name="duration" type="number">
    The duration in milliseconds. If provided, `from` and `to` will be ignored.
  </PropertiesListItem>
  <PropertiesListItem name="from" type="Date | string | number">
    The date at which the duration starts. If provided, `duration` will be
    ignored. If provided without `to` it means that the duration is in progress,
    and the component will re-render at an interval, customizable with the
    `interval` prop.
  </PropertiesListItem>
  <PropertiesListItem name="to" type="Date | string | number">
    The date at which the duration ends. If `from` is provided without `to`,
    `Date.now()` will be used.
  </PropertiesListItem>
  <PropertiesListItem
    name="children"
    type="function"
    detailedType="(duration: number) => ReactNode"
  >
    A function to format the displayed date. Defaults to a short duration
    formatting function.
  </PropertiesListItem>
  <PropertiesListItem
    name="title"
    type="string | function"
    detailedType="string | ((duration: number) => string)"
  >
    The `title` attributeâ€™s value or a function to format it. Defaults to an
    longer duration formatting function.
  </PropertiesListItem>
  <PropertiesListItem name="interval" type="number | false" defaultValue="500">
    The interval in milliseconds at which the component will re-render if `from`
    is provided without `to`, meaning that the duration is in progress. Can be
    set to `false` to disable re-rendering.
  </PropertiesListItem>
  <PropertiesListItem name="locale" type="string">
    The locale used when formatting the duration. Defaults to the browserâ€™s
    locale.
  </PropertiesListItem>
  <PropertiesListItem name="asChild" type="boolean" defaultValue="false">
    Replace the rendered element by the one passed as a child.
  </PropertiesListItem>
</PropertiesList>

#### FileSize [#primitives-FileSize]

Displays a formatted file size.

```tsx
<FileSize size={100000} />
```

Use with `attachment.size` to display a human-readable file size.

```tsx
import { FileSize } from "@liveblocks/react-ui/primitives";
import { CommentData } from "@liveblocks/client";

function MyComment({ comment }: { comment: CommentData }) {
  return (
    <div>
      {/* ... */}

      {comment.attachments.map((attachment) => (
        <div key={attachment.id}>
          {attachment.name}
          // +++
          <FileSize size={attachment.size} />
          // +++
        </div>
      ))}
    </div>
  );
}
```

<PropertiesList>
  <PropertiesListItem name="size" type="number" required>
    The file size to display.
  </PropertiesListItem>
  <PropertiesListItem
    name="children"
    type="function"
    detailedType="(size: number) => ReactNode"
  >
    A function to format the displayed file size. Defaults to a human-readable
    file size formatting function.
  </PropertiesListItem>
  <PropertiesListItem name="locale" type="string">
    The locale used when formatting the file size. Defaults to the browserâ€™s
    locale.
  </PropertiesListItem>
  <PropertiesListItem name="asChild" type="boolean" defaultValue="false">
    Replace the rendered element by the one passed as a child.
  </PropertiesListItem>
</PropertiesList>

#### Emoji picker [#emoji-picker]

Using [Frimousse](https://frimousse.liveblocks.io) alongside
[`useAddReaction`](/docs/api-reference/liveblocks-react#useAddReaction), a
package originally designed for Comments, you can easily add an emoji picker to
your primitive Comments components.

```tsx
import { EmojiPicker } from "frimousse";
import { useAddReaction } from "@liveblocks/react/suspense";
import { CommentData } from "@liveblocks/client";

export function MyEmojiPicker({ comment }: { comment: CommentData }) {
  const addReaction = useAddReaction();

  return (
    <EmojiPicker.Root
      onEmojiSelect={({ emoji }) => {
        addReaction({
          threadId: comment.threadId,
          commentId: comment.id,
          emoji,
        });
      }}
    >
      <EmojiPicker.Search />
      <EmojiPicker.Viewport>
        <EmojiPicker.Loading>Loadingâ€¦</EmojiPicker.Loading>
        <EmojiPicker.Empty>No emoji found.</EmojiPicker.Empty>
        <EmojiPicker.List />
      </EmojiPicker.Viewport>
    </EmojiPicker.Root>
  );
}
```

Find a full code snippet of this in our
[Comments primitives example](/examples/comments-primitives/nextjs-comments-primitives).

#### Emoji reactions [#emoji-reactions]

A list of clickable emoji reactions can be created using the
[`useAddReaction`](/docs/api-reference/liveblocks-react#useAddReaction),
[`useRemoveReaction`](/docs/api-reference/liveblocks-react#useRemoveReaction),
and [`useSelf`](/docs/api-reference/liveblocks-react#useSelf) hooks.

```tsx
import { CommentData } from "@liveblocks/client";
import {
  useAddReaction,
  useRemoveReaction,
  useSelf,
} from "@liveblocks/react/suspense";

export function MyEmojiReactions({ comment }: { comment: CommentData }) {
  const userId = useSelf().id;
  const addReaction = useAddReaction();
  const removeReaction = useRemoveReaction();

  return (
    <>
      {comment.reactions.map((reaction) => {
        const hasPicked = reaction.users.some((user) => user.id === userId);
        const reactionObject = {
          threadId: comment.threadId,
          commentId: comment.id,
          emoji: reaction.emoji,
        };

        return (
          <button
            key={reaction.emoji}
            onClick={() =>
              hasPicked
                ? removeReaction(reactionObject)
                : addReaction(reactionObject)
            }
            data-picked={hasPicked || undefined /* Use for CSS styling */}
          >
            {reaction.emoji} {reaction.users.length}
          </button>
        );
      })}
    </>
  );
}
```

### Hooks

#### useComposer

Returns states and methods related to the composer. Can only be used within the
[`Composer.Form`](#primitives-Composer.Form) primitive.
[All values listed below](#useComposer-values).

```tsx
import { useComposer } from "@liveblocks/react-ui/primitives";

const { isEmpty, attachments, submit /* ... */ } = useComposer();
```

##### Custom composer behavior

`useComposer` can be used in combination with
[`Composer` primitives](#primitives-Composer) to create a custom composer, and
control its behavior. For example, `createMention` allows you to create a button
which focuses the editor, adds `@`, and opens the mention suggestions dropdown.

```tsx
import { Composer, useComposer } from "@liveblocks/react-ui/primitives";
import { useCreateThread } from "@liveblocks/react/suspense";

function MyComposer() {
  const createThread = useCreateThread();

  return (
    <Composer.Form
      onComposerSubmit={({ body, attachments }) => {
        const thread = createThread({
          body,
          attachments,
          metadata: {},
        });
      }}
    >
      <Editor />
    </Composer.Form>
  );
}

function Editor() {
  // +++
  const { createMention } = useComposer();
  // +++

  return (
    <>
      <Composer.Editor components={/* Your custom component parts */} />
      // +++
      <button onClick={createMention}>Add mention</button>
      // +++
    </>
  );
}
```

##### Handle attachments

When using primitives,
[`Composer.AttachFiles`](#primitives-Composer.AttachFiles) and
[`Composer.AttachmentsDropArea`](#primitives-Composer.AttachmentsDropArea) add
attachments to the composer, but theyâ€™re not rendered without `useComposer`. The
`attachments` array can be used to render the current attachments, and
`removeAttachment` allows you to remove them.

```tsx
import { Composer, useComposer } from "@liveblocks/react-ui/primitives";
import { useCreateThread } from "@liveblocks/react/suspense";

function MyComposer() {
  const createThread = useCreateThread();

  return (
    <Composer.Form
      onComposerSubmit={({ body, attachments }) => {
        const thread = createThread({
          body,
          attachments,
          metadata: {},
        });
      }}
    >
      <Composer.Editor components={/* Your custom component parts */} />
      // +++
      <MyComposerAttachments />
      // +++
      <Composer.AttachFiles>Attach Files</Composer.AttachFiles>
      <Composer.Submit>Submit</Composer.Submit>
    </Composer.Form>
  );
}

function MyComposerAttachments() {
  // +++
  const { attachments, removeAttachment } = useComposer();
  // +++

  return (
    <div>
      // +++
      {attachments.map((attachment) => (
        <div key={attachment.id}>
          {attachment.name} ({attachment.status})
          <button onClick={() => removeAttachment(attachment.id)}>
            Remove
          </button>
        </div>
      ))}
      // +++
    </div>
  );
}
```

##### Values [#useComposer-values]

<PropertiesList>
  <PropertiesListItem name="isDisabled" type="boolean">
    Whether the composer is currently disabled.
  </PropertiesListItem>
  <PropertiesListItem name="isFocused" type="boolean">
    Whether the editor is currently focused.
  </PropertiesListItem>
  <PropertiesListItem name="isEmpty" type="boolean">
    Whether the editor is currently empty.
  </PropertiesListItem>
  <PropertiesListItem name="canSubmit" type="boolean">
    Whether the composer can currently be submitted.
  </PropertiesListItem>
  <PropertiesListItem name="submit" type="function" detailedType="() => void">
    Submit the editor programmatically.
  </PropertiesListItem>
  <PropertiesListItem name="clear" type="function" detailedType="() => void">
    Clear the editor programmatically.
  </PropertiesListItem>
  <PropertiesListItem name="select" type="function" detailedType="() => void">
    Select the editor programmatically.
  </PropertiesListItem>
  <PropertiesListItem name="focus" type="function" detailedType="() => void">
    Focus the editor programmatically.
  </PropertiesListItem>
  <PropertiesListItem name="blur" type="function" detailedType="() => void">
    Blur the editor programmatically.
  </PropertiesListItem>
  <PropertiesListItem name="marks" type="ComposerBodyMarks">
    Which text marks are currently active and which arenâ€™t.
  </PropertiesListItem>
  <PropertiesListItem
    name="toggleMark"
    type="function"
    detailedType="(mark: ComposerBodyMark) => void"
  >
    Toggle a specific text mark.
  </PropertiesListItem>
  <PropertiesListItem
    name="createMention"
    type="function"
    detailedType="() => void"
  >
    Start creating a mention at the current selection.
  </PropertiesListItem>
  <PropertiesListItem
    name="insertText"
    type="function"
    detailedType="(text: string) => void"
  >
    Insert text at the current selection.
  </PropertiesListItem>
  <PropertiesListItem
    name="attachFiles"
    type="function"
    detailedType="() => void"
  >
    Open a file picker programmatically to create attachments.
  </PropertiesListItem>
  <PropertiesListItem name="attachments" type="ComposerAttachment[]">
    The composerâ€™s current attachments.
  </PropertiesListItem>
  <PropertiesListItem
    name="removeAttachment"
    type="function"
    detailedType="(attachmentId: string) => void"
  >
    Remove an attachment by its ID.
  </PropertiesListItem>
</PropertiesList>

#### Other hooks

Other Comments hooks are part of
[`@liveblocks/react`](/docs/api-reference/liveblocks-react), you can find them
on the
[React API reference page](/docs/api-reference/liveblocks-react#Comments).

- [`useThreads`](/docs/api-reference/liveblocks-react#useThreads)
- [`useThreadSubscription`](/docs/api-reference/liveblocks-react#useThreadSubscription)
- [`useCreateThread`](/docs/api-reference/liveblocks-react#useCreateThread)
- [`useDeleteThread`](/docs/api-reference/liveblocks-react#useDeleteThread)
- [`useEditThreadMetadata`](/docs/api-reference/liveblocks-react#useEditThreadMetadata)
- [`useMarkThreadAsResolved`](/docs/api-reference/liveblocks-react#useMarkThreadAsResolved)
- [`useMarkThreadAsUnresolved`](/docs/api-reference/liveblocks-react#useMarkThreadAsUnresolved)
- [`useMarkThreadAsRead`](/docs/api-reference/liveblocks-react#useMarkThreadAsRead)
- [`useCreateComment`](/docs/api-reference/liveblocks-react#useCreateComment)
- [`useEditComment`](/docs/api-reference/liveblocks-react#useEditComment)
- [`useEditCommentMetadata`](/docs/api-reference/liveblocks-react#useEditCommentMetadata)
- [`useDeleteComment`](/docs/api-reference/liveblocks-react#useDeleteComment)
- [`useAddReaction`](/docs/api-reference/liveblocks-react#useAddReaction)
- [`useRemoveReaction`](/docs/api-reference/liveblocks-react#useRemoveReaction)
- [`useAttachmentUrl`](/docs/api-reference/liveblocks-react#useAttachmentUrl)

## Notifications

### Default components

#### InboxNotification

Displays a single inbox notification.

```tsx
<InboxNotification inboxNotification={inboxNotification} />
```

<Figure>
  <Image
    src="/assets/notifications/inbox-notification.png"
    alt="InboxNotification"
    width={768}
    height={446}
  />
</Figure>

Map through `inboxNotifications` with
[`useInboxNotifications`](/docs/api-reference/liveblocks-react#useInboxNotifications)
to render a list of the roomâ€™s notifications.

```tsx highlight="10-13"
import { InboxNotification } from "@liveblocks/react-ui";
import { useInboxNotifications } from "@liveblocks/react/suspense";

function Component() {
  const { inboxNotifications } = useInboxNotifications();

  return (
    <>
      {inboxNotifications.map((inboxNotification) => (
        <InboxNotification
          key={inboxNotification.id}
          inboxNotification={inboxNotification}
        />
      ))}
    </>
  );
}
```

##### Rendering notification kinds differently

Different `kinds` of notifications are available, for example `thread` which is
triggered when using Comments, or `$myCustomNotification` which would be a
custom notification youâ€™ve triggered manually. You can choose to render each
notification differently.

```tsx highlight="4-14"
<InboxNotification
  inboxNotification={inboxNotification}
  kinds={{
    thread: (props) => (
      <InboxNotification.Thread {...props} showRoomName={false} />
    ),
    $myCustomNotification: (props) => (
      <InboxNotification.Custom
        {...props}
        title="New notification"
        aside={<InboxNotification.Icon>â•</InboxNotification.Icon>}
      >
        My custom notification
      </InboxNotification.Custom>
    ),
  }}
/>
```

Adding these two properties to `kinds` will overwrite the default component
thatâ€™s displayed for those two notification types. Using
[`InboxNotification.Thread`](/docs/api-reference/liveblocks-react-ui#InboxNotification.Thread)
and
[`InboxNotification.Custom`](/docs/api-reference/liveblocks-react-ui#InboxNotification.Custom)
in this way allow you to easily create components that fit into the existing
design system, whilst still adding lots of customization. However, itâ€™s also
valid to render any custom JSX.

```tsx highlight="3-5"
<InboxNotification
  inboxNotification={inboxNotification}
  kinds={{
    $myCustomNotification: (props) => <div>New notification</div>,
  }}
/>
```

##### Typing custom notifications

To type custom notifications, edit the `ActivitiesData` type in your config
file.

```ts file="liveblocks.config.ts" highlight="4-10"
declare global {
  interface Liveblocks {
    // Custom activities data for custom notification kinds
    ActivitiesData: {
      // Example, a custom $alert kind
      $alert: {
        title: string;
        message: string;
      };
    };

    // Other kinds
    // ...
  }
}
```

Your activities data is now correctly typed in inline functions.

```tsx highlight="5-6"
<InboxNotification
  inboxNotification={inboxNotification}
  kinds={{
    $alert: (props) => {
      // `title` and `message` are correctly typed, as defined in your config
      const { title, message } = props.inboxNotification.activities[0].data;

      return (
        <InboxNotification.Custom
          {...props}
          title={title}
          aside={<InboxNotification.Icon>â—</InboxNotification.Icon>}
        >
          {message}
        </InboxNotification.Custom>
      );
    },
  }}
/>
```

If youâ€™d like to create a typed function elsewhere, you can use
`InboxNotificationCustomProps` with a generic. In the example below weâ€™re using
the `$alert` notification kind as a generic,
`InboxNotificationCustomKindProps<"$alert">`.

```tsx highlight="6-8,25"
import {
  InboxNotification,
  InboxNotificationCustomKindProps,
} from "@liveblocks/react-ui";

function AlertNotification(props: InboxNotificationCustomKindProps<"$alert">) {
  // `title` and `message` are correctly typed, as defined in your config
  const { title, message } = props.inboxNotification.activities[0].data;

  return (
    <InboxNotification.Custom
      {...props}
      title={title}
      aside={<InboxNotification.Icon>â—</InboxNotification.Icon>}
    >
      {message}
    </InboxNotification.Custom>
  );
}

function Notification({ inboxNotification }) {
  return (
    <InboxNotification
      inboxNotification={inboxNotification}
      kinds={{ $alert: AlertNotification }}
    />
  );
}
```

##### Batching custom notifications

If youâ€™re
[batching custom notifications](/docs/api-reference/liveblocks-node#Batching-custom-notifications),
you can render each activity inside a single notification.

```tsx
<InboxNotification
  inboxNotification={inboxNotification}
  kinds={{
    $alert: (props) => {
      // Each batched `activityData` is added to the `activities` array
      const { activities } = props.inboxNotification;

      return (
        <InboxNotification.Custom
          {...props}
          title={title}
          aside={<InboxNotification.Icon>â—</InboxNotification.Icon>}
        >
          {activities.map((activity) => (
            <div key={activity.id}>
              <div>{activity.data.title}</div>
              <div>{activity.data.message}</div>
            </div>
          ))}
        </InboxNotification.Custom>
      );
    },
  }}
/>
```

##### Props [#InboxNotification-props]

<PropertiesList>
  <PropertiesListItem
    name="inboxNotification"
    type="InboxNotificationData"
    required
  >
    The inbox notification to display.
  </PropertiesListItem>
  <PropertiesListItem name="href" type="string">
    The URL which the inbox notification links to.
  </PropertiesListItem>
  <PropertiesListItem name="showActions" type='boolean | "hover"'>
    How to show or hide the actions.
  </PropertiesListItem>
  <PropertiesListItem name="kinds" type="Partial<InboxNotificationKinds>">
    Override specific kinds of inbox notifications.
  </PropertiesListItem>
  <PropertiesListItem
    name="overrides"
    type="Partial<GlobalOverrides & InboxNotificationOverrides & CommentOverrides>"
  >
    Override the componentâ€™s strings.
  </PropertiesListItem>
  <PropertiesListItem name="components" type="Partial<GlobalComponents>">
    Override the componentâ€™s components.
  </PropertiesListItem>
</PropertiesList>

###### kinds [#InboxNotification-kinds]

Override specific kinds of inbox notifications.

<PropertiesList>
  <PropertiesListItem
    name="thread"
    type="ComponentType<InboxNotificationThreadKindProps>"
  >
    The component used to display thread notifications. Defaults to
    `InboxNotification.Thread`.
  </PropertiesListItem>
  <PropertiesListItem
    name="textMention"
    type="ComponentType<InboxNotificationTextMentionKindProps>"
  >
    The component used to display text mention notifications. Defaults to
    `InboxNotification.TextMention`.
  </PropertiesListItem>
  <PropertiesListItem
    name="$${string}"
    type="ComponentType<InboxNotificationCustomKindProps>"
  >
    The component used to display a custom notification kind. Custom
    notification kinds must start with a `$`.
  </PropertiesListItem>
</PropertiesList>

###### InboxNotification.Thread [#InboxNotification.Thread]

Displays a thread inbox notification kind.

```tsx
<InboxNotification
  inboxNotification={inboxNotification}
  kinds={{
    thread: (props) => (
      <InboxNotification.Thread {...props} showRoomName={false} />
    ),
  }}
/>
```

<PropertiesList>
  <PropertiesListItem
    name="inboxNotification"
    type="InboxNotificationThreadData"
    required
  >
    The inbox notification to display.
  </PropertiesListItem>
  <PropertiesListItem name="showActions" type='boolean | "hover"'>
    How to show or hide the actions.
  </PropertiesListItem>
  <PropertiesListItem name="showRoomName" type="boolean" defaultValue="true">
    Whether to show the room name in the title.
  </PropertiesListItem>
  <PropertiesListItem name="showReactions" type="boolean" defaultValue="true">
    Whether to show reactions.
  </PropertiesListItem>
  <PropertiesListItem name="showAttachments" type="boolean" defaultValue="true">
    Whether to show attachments.
  </PropertiesListItem>
</PropertiesList>

###### InboxNotification.TextMention [#InboxNotification.TextMention]

Displays a text mention inbox notification kind.

```tsx
<InboxNotification
  inboxNotification={inboxNotification}
  kinds={{
    textMention: (props) => (
      <InboxNotification.TextMention {...props} showRoomName={false} />
    ),
  }}
/>
```

<PropertiesList>
  <PropertiesListItem
    name="inboxNotification"
    type="InboxNotificationTextMentionData"
    required
  >
    The inbox notification to display.
  </PropertiesListItem>
  <PropertiesListItem name="showActions" type='boolean | "hover"'>
    How to show or hide the actions.
  </PropertiesListItem>
  <PropertiesListItem name="showRoomName" type="boolean" defaultValue="true">
    Whether to show the room name in the title.
  </PropertiesListItem>
</PropertiesList>

###### InboxNotification.Custom [#InboxNotification.Custom]

Displays a custom notification kind.

```tsx
<InboxNotification
  inboxNotification={inboxNotification}
  kinds={{
    $myCustomNotificationKind: (props) => {
      const activityData = props.inboxNotification.activities[0].data;

      return (
        <InboxNotification.Custom
          title={
            <>
              User <strong>{activityData.file}</strong>
            </>
          }
          aside={<InboxNotification.Icon>âŒ</InboxNotification.Icon>}
          {...props}
        >
          {activityData.errorDescription}
        </InboxNotification.Custom>
      );
    },
  }}
/>
```

<PropertiesList>
  <PropertiesListItem
    name="inboxNotification"
    type="InboxNotificationCustomData"
    required
  >
    The inbox notification to display.
  </PropertiesListItem>
  <PropertiesListItem name="title" type="ReactNode" required>
    The inbox notificationâ€™s title.
  </PropertiesListItem>
  <PropertiesListItem name="children" type="ReactNode" required>
    The inbox notificationâ€™s content.
  </PropertiesListItem>
  <PropertiesListItem name="showActions" type='boolean | "hover"'>
    How to show or hide the actions.
  </PropertiesListItem>
  <PropertiesListItem name="aside" type="ReactNode">
    The inbox notificationâ€™s aside content. Can be combined with{" "}
    <code>InboxNotification.Icon</code> or <code>InboxNotification.Avatar</code>{" "}
    to easily follow default styles.
  </PropertiesListItem>
  <PropertiesListItem name="asChild" type="boolean" defaultValue="false">
    Replace the rendered element by the one passed as a child.
  </PropertiesListItem>
</PropertiesList>

###### InboxNotification.Inspector [#InboxNotification.Inspector]

Displays the inbox notificationâ€™s data in a JSON code snippet. Useful when
debugging notifications in your app.

```tsx
<InboxNotification
  inboxNotification={inboxNotification}
  kinds={{
    $myCustomNotificationKind: InboxNotification.Inspector,
  }}
/>
```

<PropertiesList>
  <PropertiesListItem
    name="inboxNotification"
    type="InboxNotificationData"
    required
  >
    The inbox notification to display.
  </PropertiesListItem>
  <PropertiesListItem name="showActions" type='boolean | "hover"'>
    How to show or hide the actions.
  </PropertiesListItem>
</PropertiesList>

#### InboxNotificationList

Displays inbox notifications as a list. Each
[`InboxNotification`](#InboxNotification) component will be wrapped in a `li`
element.

```tsx
<InboxNotificationList>
  <InboxNotification />
  <InboxNotification />
  <InboxNotification />
</InboxNotificationList>
```

<Figure>
  <Image
    src="/assets/notifications/inbox-notification-list.png"
    alt="InboxNotificationList"
    width={768}
    height={446}
  />
</Figure>

##### Props [#InboxNotificationList-props]

<PropertiesList>
  <PropertiesListItem name="children" type="ReactNode">
    The inbox notifications to display.
  </PropertiesListItem>
</PropertiesList>

### Hooks [#Notification-hooks]

All hooks for Notifications are in
[`@liveblocks/react`](/docs/api-reference/liveblocks-react#Notifications).

## Version History

Version history enables you to track and restore versions of your
[Lexical](https://liveblocks.io/docs/api-reference/liveblocks-react-lexical) or
[Yjs](/docs/api-reference/liveblocks-yjs) document. Versions can be
automatically created when enabled in your project settings, or manually created
using the
[REST API](/docs/api-reference/rest-api-endpoints#post-rooms-roomId-version).
These components aid in displaying a list of those versions.

### Default components

### HistoryVersionSummary

Displays a version summary which includes the author and date.

```tsx
<HistoryVersionSummary
  onClick={() => {
    setSelectedVersionId(version.id);
  }}
  version={version}
  selected={version.id === selectedVersionId}
/>
```

##### Props [#HistoryVersionSummary-props]

<PropertiesList>
  <PropertiesListItem name="onClick" type="() => void">
    The function to call when the version summary is clicked.
  </PropertiesListItem>
  <PropertiesListItem name="version" type="Version">
    The version object containing information about the specific version.
  </PropertiesListItem>
  <PropertiesListItem name="selected" type="boolean">
    Whether this version is currently selected.
  </PropertiesListItem>
</PropertiesList>

#### HistoryVersionSummaryList

Displays a list of version summaries for a documentâ€™s history including authors
and dates.

```tsx
<HistoryVersionSummaryList>
  {versions?.map((version) => (
    <HistoryVersionSummary
      onClick={() => {
        setSelectedVersionId(version.id);
      }}
      key={version.id}
      version={version}
      selected={version.id === selectedVersionId}
    />
  ))}
</HistoryVersionSummaryList>
```

##### Props [#HistoryVersionSummaryList-props]

<PropertiesList>
  <PropertiesListItem name="children" type="ReactNode">
    The version summaries to display, typically an array of
    HistoryVersionSummary components.
  </PropertiesListItem>
</PropertiesList>

## Utilities

### Components [#utilities-components]

#### Icon

Most icons used in the default components can be exported via `<Icon.* />`.
Theyâ€™re stroke-based and designed for use at 20Ã—20 pixels.

```tsx
import { Icon } from "@liveblocks/react-ui";

<Icon.QuestionMark />
<Icon.Mention  />
```

Find a full list of available icons in
[our GitHub repo](https://github.com/liveblocks/liveblocks/blob/main/packages/liveblocks-react-ui/src/icon.ts).

#### LiveblocksUiConfig

Set configuration options for all `@liveblocks/react-ui` components, such as
[overrides](#overrides).

```tsx
<LiveblocksUiConfig overrides={{ locale: "fr", USER_UNKNOWN: "Anonyme" }} />
```

##### Props [#LiveblocksUiConfig-props]

<PropertiesList>
  <PropertiesListItem name="overrides" type="Partial<Overrides>">
    Override the componentsâ€™ strings.
  </PropertiesListItem>
  <PropertiesListItem name="components" type="Partial<Components>">
    Override the componentsâ€™ components.
  </PropertiesListItem>
  <PropertiesListItem
    name="portalContainer"
    type="HTMLElement"
    defaultValue="document.body"
  >
    The container to render the portal into.
  </PropertiesListItem>
  <PropertiesListItem
    name="preventUnsavedComposerChanges"
    type="boolean"
    defaultValue="true"
  >
    When `preventUnsavedChanges` is set on your Liveblocks client (or set on
    `LiveblocksProvider`), then closing a browser tab will be prevented when
    there are unsaved changes. By default, that will include draft texts or
    attachments that are (being) uploaded via comments/threads composers, but
    not submitted yet. If you want to prevent unsaved changes with Liveblocks,
    but not for composers, you can opt-out by setting this option to `false`.
  </PropertiesListItem>
  <PropertiesListItem
    name="emojibaseUrl"
    type="string"
    defaultValue={`"https://cdn.jsdelivr.net/npm/emojibase-data"`}
  >
    Use this option to host your own emoji data.

    The Liveblocks emoji picker (visible when adding reactions in `Comment`) is built with
    [Frimousse](https://github.com/liveblocks/frimousse), which fetches its data
    from [Emojibase](https://emojibase.dev/docs/datasets/).

    This option allows you to change the base URL of where the
    [`emojibase-data`](https://www.npmjs.com/package/emojibase-data) files
    should be fetched from, used as follows: `${emojibaseUrl}/${locale}/${file}.json`.
    (e.g. `${emojibaseUrl}/en/data.json`).

  </PropertiesListItem>
</PropertiesList>

### Hooks [#Version-History-hooks]

All hooks for Version History are in
[`@liveblocks/react`](/docs/api-reference/liveblocks-react#Version-History).

## Styling and customization

### Default styles

The default components come with default styles. These styles can be imported
into the root of your app or directly into a CSS file with `@import`.

```tsx
import "@liveblocks/react-ui/styles.css";
```

### Dark mode

You can also import default dark mode styling. There are two versions to choose
from, the first uses the
[system theme](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/prefers-color-scheme).

```tsx
// Dark mode using the system theme with `prefers-color-scheme`
import "@liveblocks/react-ui/styles/dark/media-query.css";
```

The second uses the `dark` class name, and two commonly used data attributes.

```tsx
// Dark mode using `className="dark"`, `data-theme="dark"`, or `data-dark="true"`
import "@liveblocks/react-ui/styles/dark/attributes.css";
```

### CSS variables

The default components are built around a set of customizable CSS variables. Set
these variables within `.lb-root` to globally style your components.

```css
/* Styles all default Comments components */
.lb-root {
  --lb-accent: purple;
  --lb-spacing: 1em;
  --lb-radius: 0;
}
```

<PropertiesList>
  <PropertiesListItem name="--lb-radius" defaultValue="0.5em">
    The border radius scale. `em` values recommended.
  </PropertiesListItem>
  <PropertiesListItem name="--lb-spacing" defaultValue="1em">
    The spacing scale. `em` values recommended.
  </PropertiesListItem>
  <PropertiesListItem name="--lb-accent" defaultValue="#1177ff">
    The accent color.
  </PropertiesListItem>
  <PropertiesListItem name="--lb-accent-foreground" defaultValue="#ffffff">
    The foreground color used over the accent color.
  </PropertiesListItem>
  <PropertiesListItem name="--lb-destructive" defaultValue="#ff4455">
    The destructive color.
  </PropertiesListItem>
  <PropertiesListItem name="--lb-destructive-foreground" defaultValue="#ffffff">
    The foreground color used over the destructive color.
  </PropertiesListItem>
  <PropertiesListItem name="--lb-background" defaultValue="#ffffff">
    The main background color.
  </PropertiesListItem>
  <PropertiesListItem name="--lb-foreground" defaultValue="#111111">
    The main foreground color.
  </PropertiesListItem>
  <PropertiesListItem name="--lb-line-height" defaultValue="1.5">
    The line height of main elements (e.g. comment bodies).
  </PropertiesListItem>
  <PropertiesListItem name="--lb-icon-size" defaultValue="20px">
    The size of icons.
  </PropertiesListItem>
  <PropertiesListItem name="--lb-icon-weight" defaultValue="1.5px">
    The stroke weight of icons.
  </PropertiesListItem>
  <PropertiesListItem name="--lb-avatar-radius" defaultValue="50%">
    The border radius used for avatars.
  </PropertiesListItem>
  <PropertiesListItem
    name="--lb-button-radius"
    defaultValue="calc(0.75 * var(--lb-radius))"
  >
    The border radius used for buttons.
  </PropertiesListItem>
  <PropertiesListItem name="--lb-transition-duration" defaultValue="0.1s">
    The duration used for transitioned elements.
  </PropertiesListItem>
  <PropertiesListItem
    name="--lb-transition-easing"
    defaultValue="cubic-bezier(0.4, 0, 0.2, 1)"
  >
    The easing function used for transitioned elements.
  </PropertiesListItem>
  <PropertiesListItem
    name="--lb-elevation-shadow"
    defaultValue="0 0 0 1px rgb(0 0 0 / 4%), 0 2px 6px rgb(0 0 0 / 8%),  0 8px 26px rgb(0 0 0 / 12%)"
  >
    The box shadow added to elevated elements.
  </PropertiesListItem>
  <PropertiesListItem
    name="--lb-elevation-shadow-moderate"
    defaultValue="  0 0 0 1px rgb(0 0 0 / 4%), 0 2px 6px rgb(0 0 0 / 6%), 0 8px 26px rgb(0 0 0 / 8%)"
  >
    The box shadow added to moderately elevated elements.
  </PropertiesListItem>
  <PropertiesListItem
    name="--lb-tooltip-shadow"
    defaultValue="0 2px 4px rgb(0 0 0 / 8%), 0 4px 12px rgb(0 0 0 / 12%)"
  >
    The box shadow added to tooltips.
  </PropertiesListItem>
  <PropertiesListItem name="--lb-accent-contrast" defaultValue="8%">
    Affects the lightness of accent colors. `%` value required.
  </PropertiesListItem>
  <PropertiesListItem name="--lb-destructive-contrast" defaultValue="8%">
    Affects the lightness of destructive colors. `%` value required.
  </PropertiesListItem>
  <PropertiesListItem name="--lb-foreground-contrast" defaultValue="6%">
    Affects the lightness of foreground colors. `%` value required.
  </PropertiesListItem>
</PropertiesList>

{/* TODO: Explain automatic color scales (with a palette-type visual) */}

### Class names

Each default component has a set of predefined class names, which can be helpful
for custom styling, for example.

```css
.lb-thread {
  /* Customise thread */
}

.lb-composer {
  /* Customise composer */
}
```

Additionally, some elements also have data attributes to provide contextual
information, for example:

```css
.lb-button[data-variant="primary"] {
  /* Customise primary buttons */
}

.lb-avatar[data-loading] {
  /* Customise avatar loading state */
}
```

<Banner title="Internal classes" type="warning">

Classes containing colons `:` are internal and may change over time.

</Banner>

### Portaled elements

Floating elements within the default components (e.g. tooltips, dropdowns, etc)
are portaled to the end of the document to avoid `z-index` conflicts and
`overflow` issues.

When portaled, those elements are also wrapped in a container to handle their
positioning. These containers donâ€™t have any specific class names or data
attributes so they shouldnâ€™t be targeted or styled directly, but they will
mirror whichever `z-index` value is set on their inner element (which would be
`auto` by default). So if you need to set a specific `z-index` value on floating
elements, you should set it on the floating elements themselves directly,
ignoring their containers. You can either target specific floating elements
(e.g. `.lb-tooltip`, `.lb-dropdown`, etc) or all of them at once via the
`.lb-portal` class name.

```css
/* Target all floating elements */
.lb-portal {
  z-index: 5;
}

/* Target a specific floating element */
.lb-tooltip {
  z-index: 10;
}
```

### Overrides

Overrides can be used to customize componentsâ€™ strings and localization-related
properties, such as locale and reading direction.

They can be set globally for all components using `LiveblocksUiConfig`:

```tsx
import { LiveblocksUiConfig } from "@liveblocks/react-ui";

export function App() {
  return (
    <LiveblocksUiConfig
      overrides={{ locale: "fr", USER_UNKNOWN: "Anonyme" /* ... */ }}
    >
      {/* ... */}
    </LiveblocksUiConfig>
  );
}
```

Overrides can also be set per-component, and these settings will take precedence
over global settings. This is particularly useful in certain contexts, for
example when youâ€™re using a `<Composer />` component for creating replies to
threads:

```tsx
<Composer
  overrides={{
    COMPOSER_PLACEHOLDER: "Reply to threadâ€¦",
    COMPOSER_SEND: "Reply",
  }}
/>
```

#### Override names

Here's a list of all available override names, their descriptions, and default
values.

##### Localization

Localization overrides can only be set on
[`LiveblocksUiConfig`](/docs/api-reference/liveblocks-react-ui#LiveblocksUiConfig).

| Name     | Description    | Default value |
| -------- | -------------- | ------------- |
| `locale` | Locale code    | `"en"`        |
| `dir`    | Text direction | `"ltr"`       |

##### Global

Global overrides can only be set on
[`LiveblocksUiConfig`](/docs/api-reference/liveblocks-react-ui#LiveblocksUiConfig).

| Name                              | Description              | Default value                      |
| --------------------------------- | ------------------------ | ---------------------------------- |
| `USER_SELF`                       | Current user label       | `"you"`                            |
| `USER_UNKNOWN`                    | Unknown user label       | `"Anonymous"`                      |
| `LIST_REMAINING`                  | Remaining items          | `"X more"`                         |
| `LIST_REMAINING_USERS`            | Remaining users          | `"X others"`                       |
| `LIST_REMAINING_COMMENTS`         | Remaining comments       | `"X more comments"`                |
| `EMOJI_PICKER_SEARCH_PLACEHOLDER` | Emoji search placeholder | `"Searchâ€¦"`                        |
| `EMOJI_PICKER_EMPTY`              | Empty emoji results      | `"No emoji found."`                |
| `EMOJI_PICKER_ERROR`              | Emoji picker error       | `"There was an errorâ€¦"`            |
| `EMOJI_PICKER_CHANGE_SKIN_TONE`   | Skin tone button label   | `"Change skin tone"`               |
| `ATTACHMENT_TOO_LARGE`            | File too large error     | `"The file is larger than X"`      |
| `ATTACHMENT_ERROR`                | Upload error             | `"The file couldn't be uploaded."` |
| `COPY_TO_CLIPBOARD`               | Copy button label        | `"Copy"`                           |

##### Composer

Composer overrides can be set on both
[`Composer`](/docs/api-reference/liveblocks-react-ui#Composer) and
[`LiveblocksUiConfig`](/docs/api-reference/liveblocks-react-ui#LiveblocksUiConfig).

| Name                         | Description             | Default value              |
| ---------------------------- | ----------------------- | -------------------------- |
| `COMPOSER_INSERT_MENTION`    | Mention button label    | `"Mention someone"`        |
| `COMPOSER_INSERT_EMOJI`      | Emoji button label      | `"Add emoji"`              |
| `COMPOSER_ATTACH_FILES`      | Attach button label     | `"Attach files"`           |
| `COMPOSER_REMOVE_ATTACHMENT` | Remove attachment label | `"Remove attachment"`      |
| `COMPOSER_PLACEHOLDER`       | Input placeholder       | `"Write a commentâ€¦"`       |
| `COMPOSER_SEND`              | Send button label       | `"Send"`                   |
| `COMPOSER_TOGGLE_MARK`       | Format toggle labels    | `"Bold"`, `"Italic"`, etc. |

##### Comment

Comment overrides can be set on both
[`Comment`](/docs/api-reference/liveblocks-react-ui#Comment) and
[`LiveblocksUiConfig`](/docs/api-reference/liveblocks-react-ui#LiveblocksUiConfig).

| Name                                | Description             | Default value                      |
| ----------------------------------- | ----------------------- | ---------------------------------- |
| `COMMENT_EDITED`                    | Edited indicator        | `"(edited)"`                       |
| `COMMENT_DELETED`                   | Deleted message         | `"This comment has been deleted."` |
| `COMMENT_MORE`                      | More actions label      | `"More"`                           |
| `COMMENT_EDIT`                      | Edit action label       | `"Edit comment"`                   |
| `COMMENT_EDIT_COMPOSER_PLACEHOLDER` | Edit placeholder        | `"Edit commentâ€¦"`                  |
| `COMMENT_EDIT_COMPOSER_CANCEL`      | Cancel edit label       | `"Cancel"`                         |
| `COMMENT_EDIT_COMPOSER_SAVE`        | Save edit label         | `"Save"`                           |
| `COMMENT_DELETE`                    | Delete action label     | `"Delete comment"`                 |
| `COMMENT_DELETE_ATTACHMENT`         | Delete attachment label | `"Delete attachment"`              |
| `COMMENT_ADD_REACTION`              | Add reaction label      | `"Add reaction"`                   |
| `COMMENT_REACTION_LIST`             | Reaction list text      | `"X reacted with Y"`               |
| `COMMENT_REACTION_DESCRIPTION`      | Reaction description    | `"X reactions, react with Y"`      |

##### Thread

Thread overrides can be set on both
[`Thread`](/docs/api-reference/liveblocks-react-ui#Thread) and
[`LiveblocksUiConfig`](/docs/api-reference/liveblocks-react-ui#LiveblocksUiConfig).

| Name                               | Description               | Default value               |
| ---------------------------------- | ------------------------- | --------------------------- |
| `THREAD_RESOLVE`                   | Resolve action label      | `"Resolve thread"`          |
| `THREAD_UNRESOLVE`                 | Unresolve action label    | `"Re-open thread"`          |
| `THREAD_SUBSCRIBE`                 | Subscribe action label    | `"Subscribe to thread"`     |
| `THREAD_UNSUBSCRIBE`               | Unsubscribe action label  | `"Unsubscribe from thread"` |
| `THREAD_NEW_INDICATOR`             | New indicator label       | `"New"`                     |
| `THREAD_NEW_INDICATOR_DESCRIPTION` | New indicator description | `"New comments"`            |
| `THREAD_SHOW_MORE_COMMENTS`        | Show more label           | `"Show X more replies"`     |
| `THREAD_COMPOSER_PLACEHOLDER`      | Reply placeholder         | `"Reply to threadâ€¦"`        |
| `THREAD_COMPOSER_SEND`             | Reply button label        | `"Reply"`                   |

##### Inbox notification

Inbox notification overrides can be set on both
[`InboxNotification`](/docs/api-reference/liveblocks-react-ui#InboxNotification)
and
[`LiveblocksUiConfig`](/docs/api-reference/liveblocks-react-ui#LiveblocksUiConfig).

| Name                                      | Description         | Default value            |
| ----------------------------------------- | ------------------- | ------------------------ |
| `INBOX_NOTIFICATION_MORE`                 | More actions label  | `"More"`                 |
| `INBOX_NOTIFICATION_MARK_AS_READ`         | Mark read label     | `"Mark as read"`         |
| `INBOX_NOTIFICATION_DELETE`               | Delete action label | `"Delete notification"`  |
| `INBOX_NOTIFICATION_THREAD_COMMENTS_LIST` | Comments list text  | `"X commented in Y"`     |
| `INBOX_NOTIFICATION_THREAD_MENTION`       | Thread mention text | `"X mentioned you in Y"` |
| `INBOX_NOTIFICATION_TEXT_MENTION`         | Text mention text   | `"X mentioned you in Y"` |

##### History version preview

History version preview overrides can be set on both
[`HistoryVersionSummary`](/docs/api-reference/liveblocks-react-ui#HistoryVersionSummary)
and
[`LiveblocksUiConfig`](/docs/api-reference/liveblocks-react-ui#LiveblocksUiConfig).

| Name                                   | Description          | Default value           |
| -------------------------------------- | -------------------- | ----------------------- |
| `HISTORY_VERSION_PREVIEW_AUTHORS_LIST` | Authors list text    | `"Edits from X"`        |
| `HISTORY_VERSION_PREVIEW_RESTORE`      | Restore button label | `"Restore"`             |
| `HISTORY_VERSION_PREVIEW_EMPTY`        | Empty state text     | `"No content."`         |
| `HISTORY_VERSION_PREVIEW_ERROR`        | Error message        | `"There was an errorâ€¦"` |

##### AI composer

AI composer overrides can be set on both
[`AiChat`](/docs/api-reference/liveblocks-react-ui#AiChat) and
[`LiveblocksUiConfig`](/docs/api-reference/liveblocks-react-ui#LiveblocksUiConfig).

| Name                      | Description        | Default value      |
| ------------------------- | ------------------ | ------------------ |
| `AI_COMPOSER_PLACEHOLDER` | Input placeholder  | `"Ask anythingâ€¦"`  |
| `AI_COMPOSER_SEND`        | Send button label  | `"Send"`           |
| `AI_COMPOSER_ABORT`       | Abort button label | `"Abort response"` |

##### AI chat message

AI chat message overrides can be set on both
[`AiChat`](/docs/api-reference/liveblocks-react-ui#AiChat) and
[`LiveblocksUiConfig`](/docs/api-reference/liveblocks-react-ui#LiveblocksUiConfig).

| Name                        | Description         | Default value                       |
| --------------------------- | ------------------- | ----------------------------------- |
| `AI_CHAT_MESSAGE_DELETED`   | Deleted message     | `"This message has been deleted."`  |
| `AI_CHAT_MESSAGE_THINKING`  | Thinking indicator  | `"Thinkingâ€¦"`                       |
| `AI_CHAT_MESSAGE_REASONING` | Reasoning indicator | `"Reasoningâ€¦"` / `"Reasoned for X"` |
| `AI_CHAT_MESSAGE_RETRIEVAL` | Retrieval indicator | `"Searching Xâ€¦"` / `"Searched X"`   |

##### AI chat

AI chat overrides can be set on both
[`AiChat`](/docs/api-reference/liveblocks-react-ui#AiChat) and
[`LiveblocksUiConfig`](/docs/api-reference/liveblocks-react-ui#LiveblocksUiConfig).

| Name                     | Description    | Default value           |
| ------------------------ | -------------- | ----------------------- |
| `AI_CHAT_MESSAGES_ERROR` | Messages error | `"There was an errorâ€¦"` |

##### AI tool confirmation

AI tool confirmation overrides can be set on both
[`AiTool`](/docs/api-reference/liveblocks-react-ui#AiTool) and
[`LiveblocksUiConfig`](/docs/api-reference/liveblocks-react-ui#LiveblocksUiConfig).

| Name                           | Description          | Default value |
| ------------------------------ | -------------------- | ------------- |
| `AI_TOOL_CONFIRMATION_CONFIRM` | Confirm button label | `"Confirm"`   |
| `AI_TOOL_CONFIRMATION_CANCEL`  | Cancel button label  | `"Cancel"`    |

---
meta:
  title: "@liveblocks/react"
  parentTitle: "API Reference"
  description: "API Reference for the @liveblocks/react package"
alwaysShowAllNavigationLevels: false
---

`@liveblocks/react` provides you with [React](https://react.dev/) bindings for
our realtime collaboration APIs, built on top of WebSockets. Read our
[getting started](/docs/get-started) guides to learn more.

## Suspense

All Liveblocks React components and hooks can be exported from two different
locations, `@liveblocks/react/suspense` and `@liveblocks/react`. This is because
Liveblocks provides two types of hooks; those that support
[React Suspense](https://react.dev/reference/react/Suspense), and those that
donâ€™t.

```tsx
// Import the Suspense hook
import { useThreads } from "@/liveblocks/react/suspense";

// Import the regular hook
import { useThreads } from "@/liveblocks/react";
```

We recommend importing from `@liveblocks/react/suspense` and using Suspense by
default, as it often makes it easier to build your collaborative application.

<Banner title="Enable Suspense with createRoomContext">

If youâ€™re using the non-standard [`createRoomContext`](#createRoomContext)
function to build your hooks, you must
[enable suspense differently](#createRoomContext-Suspense).

</Banner>

### Suspense hooks

Suspense hooks can be wrapped in [`ClientSideSuspense`][], which acts as a
loading spinner for any components below it. When using this, all components
below will only render once their hook contents have been loaded.

```tsx
import { ClientSideSuspense, useStorage } from "@liveblocks/react/suspense";

function App() {
  <ClientSideSuspense fallback={<div>Loadingâ€¦</div>}>
    <Component />
  </ClientSideSuspense>;
}

function Component() {
  // `animals` is always defined
  const animals = useStorage((root) => root.animals);

  // ...
}
```

Advanced hooks using the `{ ..., error, isLoading }` syntax, such as
[`useThreads`][], can also use
[`ErrorBoundary`](https://github.com/bvaughn/react-error-boundary) to render an
error if the hook runs into a problem.

```tsx
import { ClientSideSuspense, useThreads } from "@liveblocks/react/suspense";
import { ErrorBoundary } from "react-error-boundary";

function App() {
  return (
    <ErrorBoundary fallback={<div>Error</div>}>
      <ClientSideSuspense fallback={<div>Loadingâ€¦</div>}>
        <Component />
      </ClientSideSuspense>
    </ErrorBoundary>
  );
}

function Component() {
  // `threads` is always defined
  const { threads } = useThreads();

  // ...
}
```

An advantage of Suspense hooks is that you can have multiple different hooks in
your tree, and you only need a single `ClientSideSuspense` component to render a
loading spinner for all of them.

### Regular hooks

Regular hooks often return `null` whilst a component is loading, and you must
check for this to render a loading spinner.

```tsx
import { useStorage } from "@liveblocks/react";

function Component() {
  // `animals` is `null` when loading
  const animals = useStorage((root) => root.animals);

  if (!animals) {
    return <div>Loadingâ€¦</div>;
  }

  // ...
}
```

Advanced hooks using the `{ ..., error, isLoading }` syntax, such as
[`useThreads`][], require you to make sure there isnâ€™t a problem before using
the data.

```tsx
import { useThreads } from "@liveblocks/react";

function Component() {
  // Check for `error` and `isLoading` before `threads` is defined
  const { threads, error, isLoading } = useThreads();

  if (error) {
    return <div>Error</div>;
  }

  if (isLoading) {
    return <div>Loadingâ€¦</div>;
  }

  // ...
}
```

### ClientSideSuspense

Liveblocks provides a component named `ClientSideSuspense` which works as a
replacement for `Suspense`. This is helpful as our Suspense hooks will throw an
error when theyâ€™re run on the server, and this component avoids this issue by
always rendering the `fallback` on the server.

```tsx
import { ClientSideSuspense } from "@liveblocks/react/suspense";

function Page() {
  return (
    <LiveblocksProvider authEndpoint="/api/liveblocks-auth">
      <RoomProvider id="my-room-id">
        +++
        <ClientSideSuspense fallback={<div>Loadingâ€¦</div>}>
          <App />
        </ClientSideSuspense>
        +++
      </RoomProvider>
    </LiveblocksProvider>
  );
}
```

#### Loading spinners

Instead of wrapping your entire Liveblocks application inside a single
`ClientSideSuspense` component, you can use multiple of these components in
different parts of your application, and each will work as a loading fallback
for any components further down your tree.

```tsx
import { ClientSideSuspense } from "@liveblocks/react/suspense";

function Page() {
  return (
    <LiveblocksProvider authEndpoint="/api/liveblocks-auth">
      <RoomProvider id="my-room-id">
        <header>My title</header>

        <main>
          +++
          <ClientSideSuspense fallback={<div>Loadingâ€¦</div>}>
            <Canvas />
          </ClientSideSuspense>
          +++
        </main>

        <aside>
          +++
          <ClientSideSuspense fallback={<div>Loadingâ€¦</div>}>
            <LiveAvatars />
          </ClientSideSuspense>
          +++
        </aside>
      </RoomProvider>
    </LiveblocksProvider>
  );
}
```

This is a great way to build a static skeleton around your dynamic collaborative
application.

## Liveblocks

### LiveblocksProvider

Sets up a client for connecting to Liveblocks, and is the recommended way to do
this for React apps. You must define either `authEndpoint` or `publicApiKey`.
Resolver functions should be placed inside here, and a number of other options
are available, which correspond with those passed to [`createClient`][]. Unlike
[`RoomProvider`][], `LiveblocksProvider` doesnâ€™t call Liveblocks servers when
mounted, and it should be placed higher in your appâ€™s component tree.

```tsx
import { LiveblocksProvider } from "@liveblocks/react/suspense";

function App() {
  return (
    <LiveblocksProvider
    // publicApiKey=""
    // authEndpoint="/api/liveblocks-auth"
    >
      {/* children */}
    </LiveblocksProvider>
  );
}
```

```tsx title="All LiveblocksProvider props" isCollapsable isCollapsed
import { LiveblocksProvider } from "@liveblocks/react/suspense";

function App() {
  return (
    <LiveblocksProvider
      // Connect with authEndpoint
      authEndpoint="/api/liveblocks-auth"
      // ---
      // Alternatively, use an authEndpoint callback
      // authEndpoint={async (room) => {
      //   const response = await fetch("/api/liveblocks-auth", {
      //     method: "POST",
      //     headers: {
      //       Authentication: "<your own headers here>",
      //       "Content-Type": "application/json",
      //     },
      //     body: JSON.stringify({ room }),
      //   });
      //   return await response.json();
      // }}
      //
      // Alternatively, use a public key
      // publicApiKey="pk_..."
      //
      // Throttle time (ms) between WebSocket updates
      throttle={100}
      // ---
      // Prevent browser tab from closing while local changes arenâ€™t synchronized yet
      preventUnsavedChanges={false}
      // ---
      // Throw lost-connection event after 5 seconds offline
      lostConnectionTimeout={5000}
      // ---
      // Disconnect users after X (ms) of inactivity, disabled by default
      backgroundKeepAliveTimeout={undefined}
      // ---
      // Resolve user info for Comments, Text Editor, and Notifications
      resolveUsers={async ({ userIds }) => {
        const usersData = await __getUsersFromDB__(userIds);

        return usersData.map((userData) => ({
          name: userData.name,
          avatar: userData.avatar.src,
        }));
      }}
      // ---
      // Resolve room info for Notifications
      resolveRoomsInfo={async ({ roomIds }) => {
        const documentsData = await __getDocumentsFromDB__(roomIds);

        return documentsData.map((documentData) => ({
          name: documentData.name,
          // url: documentData.url,
        }));
      }}
      // ---
      // Resolve group info for Comments and Text Editor
      resolveGroupsInfo={async ({ groupIds }) => {
        const groupsData = await __getGroupsFromDB__(groupIds);

        return groupsData.map((groupData) => ({
          avatar: groupData.avatar.src,
          name: groupData.name,
          // description: groupData.description,
        }));
      }}
      // ---
      // Resolve mention suggestions for Comments and Text Editor
      resolveMentionSuggestions={async ({ text, roomId }) => {
        const workspaceUsers = await __getWorkspaceUsersFromDB__(roomId);

        if (!text) {
          // Show all workspace users by default
          return __getUserIds__(workspaceUsers);
        } else {
          const matchingUsers = __findUsers__(workspaceUsers, text);
          return __getUserIds__(matchingUsers);
        }
      }}
      // ---
      // Polyfill options for non-browser environments
      polyfills={
        {
          // atob,
          // fetch,
          // WebSocket,
        }
      }
      // ---
      // Set the location of the "Powered by Liveblocks" badge
      // "top-right", "bottom-right", "bottom-left", "top-left"
      badgeLocation="bottom-right"
    >
      {/* children */}
    </LiveblocksProvider>
  );
}
```

<PropertiesList title="Props">
  <PropertiesListItem
    name="authEndpoint"
    detailedType="string | async ((room?: string) => CustomAuthenticationResult)"
  >
    The URL of your back endâ€™s [authentication endpoint](/docs/authentication)
    as a string, or an async callback function that returns a Liveblocks token
    result. Either `authEndpoint` or `publicApiKey` are required. Learn more
    about [using a URL string](#LiveblocksProviderAuthEndpoint) and [using a
    callback](#LiveblocksProviderCallback).
  </PropertiesListItem>
  <PropertiesListItem name="publicApiKey" type="string">
    The public API key taken from your projectâ€™s
    [dashboard](/dashboard/apikeys). Generally not recommended for production
    use. Either `authEndpoint` or `publicApiKey` are required. [Learn
    more](#LiveblocksProviderPublicKey).
  </PropertiesListItem>
  <PropertiesListItem name="throttle" type="number" defaultValue="100">
    The throttle time between WebSocket messages in milliseconds, a number
    between `16` and `1000` is allowed. Using `16` means your app will update 60
    times per second. [Learn more](#LiveblocksProviderThrottle).
  </PropertiesListItem>
  <PropertiesListItem
    name="preventUnsavedChanges"
    type="boolean"
    defaultValue="false"
  >
    When set, navigating away from the current page is prevented while
    Liveblocks is still synchronizing local changes. [Learn
    more](#prevent-users-losing-unsaved-changes).
  </PropertiesListItem>
  <PropertiesListItem
    name="lostConnectionTimeout"
    type="number"
    defaultValue="5000"
  >
    After a user disconnects, the time in milliseconds before a
    [`"lost-connection"`](/docs/api-reference/liveblocks-client#Room.subscribe.lost-connection)
    event is fired. [Learn more](#LiveblocksProviderLostConnectionTimeout).
  </PropertiesListItem>
  <PropertiesListItem name="backgroundKeepAliveTimeout" type="number">
    The time before an inactive WebSocket connection is disconnected. This is
    disabled by default, but setting a number will activate it. [Learn
    more](#LiveblocksProviderBackgroundKeepAliveTimeout).
  </PropertiesListItem>
  <PropertiesListItem
    name="resolveUsers"
    detailedType='async? (args: ResolveUsersArgs) => (UserMeta["info"] | undefined)[] | undefined'
  >
    A function that resolves user information in
    [Comments](/docs/ready-made-features/comments), [Text Editor](/docs/ready-made-features/text-editor), and [Notifications](/docs/ready-made-features/notifications). Return an array of
    `UserMeta["info"]` objects in the same order they arrived. [Learn
    more](#LiveblocksProviderResolveUsers).
  </PropertiesListItem>
  <PropertiesListItem
    name="resolveRoomsInfo"
    detailedType="async? (args: ResolveRoomsInfoArgs) => (RoomInfo | undefined)[] | undefined"
  >
    A function that resolves room information in
    [Notifications](/docs/ready-made-features/notifications). Return an array of
    `RoomInfo` objects in the same order they arrived. [Learn
    more](#LiveblocksProviderResolveRoomsInfo).
  </PropertiesListItem>
  <PropertiesListItem
    name="resolveGroupsInfo"
    detailedType="async? (args: ResolveGroupsInfoArgs) => (GroupInfo | undefined)[] | undefined"
  >
    A function that resolves group information in
    [Comments](/docs/ready-made-features/comments) and [Text Editor](/docs/ready-made-features/text-editor). Return an array of
    `GroupInfo` objects in the same order they arrived. [Learn
    more](#LiveblocksProviderResolveGroupsInfo).
  </PropertiesListItem>
  <PropertiesListItem
    name="resolveMentionSuggestions"
    detailedType="async? (args: ResolveMentionSuggestionsArgs) => string[] | MentionData[]"
  >
    A function that resolves mention suggestions in
    [Comments](/docs/ready-made-features/comments) and [Text Editor](/docs/ready-made-features/text-editor). Return an array of user IDs or mention objects.
    [Learn more](#LiveblocksProviderResolveMentionSuggestions).
  </PropertiesListItem>
  <PropertiesListItem name="polyfills">
    Place polyfills for `atob`, `fetch`, and `WebSocket` inside here. Useful
    when using a non-browser environment, such as
    [Node.js](#LiveblocksProviderNode) or [React
    Native](#LiveblocksProviderReactNative).
  </PropertiesListItem>
  <PropertiesListItem
    name="largeMessageStrategy"
    detailedType='"default" | "split" | "experimental-fallback-to-http"'
    defaultValue={`"default"`}
  >
    <div className="-mb-3">
      How to handle WebSocket messages that are larger than the maximum message size. Can be set to one of these values:
    </div>

    - `"default"` Donâ€™t send anything, but log the error to the console and notify useErrorListener.
    - `"split"` Break the message up into chunks each of which is smaller than the maximum message size.
      Beware that using `"split"` will sacrifice atomicity of changes! Depending on your use case, this may or may not be problematic.
    - `"experimental-fallback-to-http"` Try sending the update over HTTP instead of WebSockets (experimental).

  </PropertiesListItem>
  <PropertiesListItem
    name="badgeLocation"
    detailedtype='"top-right" | "bottom-right" | "bottom-left" | "top-left"'
    defaultValue={`"bottom-right"`}
  >
    The location of the "Powered by Liveblocks" badge. Can be set to either `"top-right"`, `"bottom-right"`, `"bottom-left"`, or `"top-left"`.
    [Learn more](#Powered-by-Liveblocks-branding).
  </PropertiesListItem>
  <PropertiesListItem
    name="unstable_streamData"
    type="boolean"
    defaultValue="false"
  >
    Experimental. Stream the initial Storage content over HTTP, instead of
    waiting for a large initial WebSocket message to be sent from the server.
  </PropertiesListItem>
</PropertiesList>

#### LiveblocksProvider with public key [#LiveblocksProviderPublicKey]

When creating a client with a public key, you donâ€™t need to set up an
authorization endpoint. We only recommend using a public key when prototyping,
or on public landing pages, as it makes it possible for end users to access any
roomâ€™s data. You should instead use an
[auth endpoint](#LiveblocksProviderAuthEndpoint).

```tsx
import { LiveblocksProvider } from "@liveblocks/react/suspense";

function App() {
  return (
    <LiveblocksProvider publicApiKey={"{{PUBLIC_KEY}}"}>
      {/* children */}
    </LiveblocksProvider>
  );
}
```

#### LiveblocksProvider with auth endpoint [#LiveblocksProviderAuthEndpoint]

If you are not using a public key, you need to set up your own `authEndpoint`.
Please refer to our [Authentication guide](/docs/authentication).

```tsx
import { LiveblocksProvider } from "@liveblocks/react/suspense";

function App() {
  return (
    <LiveblocksProvider authEndpoint="/api/liveblocks-auth">
      {/* children */}
    </LiveblocksProvider>
  );
}
```

#### LiveblocksProvider with auth endpoint callback [#LiveblocksProviderCallback]

If you need to add additional headers or use your own function to call your
endpoint, `authEndpoint` can be provided as a custom callback. You should return
the token created with
[`Liveblocks.prepareSession`](/docs/api-reference/liveblocks-node#access-tokens)
or [`liveblocks.identifyUser`](/docs/api-reference/liveblocks-node#id-tokens),
learn more in [authentication guide](/docs/rooms/authentication).

```tsx
import { LiveblocksProvider } from "@liveblocks/react/suspense";

function App() {
  return (
    <LiveblocksProvider
      authEndpoint={async (room) => {
        // Fetch your authentication endpoint and retrieve your access or ID token
        // ...

        return { token: "..." };
      }}
    >
      {/* children */}
    </LiveblocksProvider>
  );
}
```

`room` is the room ID that the user is connecting to. When using
[Notifications](/docs/ready-made-features/comments/email-notifications), `room`
can be `undefined`, as the client is requesting a token that grants access to
multiple rooms, rather than a specific room.

##### Fetch your endpoint

Hereâ€™s an example of fetching your API endpoint at `/api/liveblocks-auth` within
the callback.

```tsx
import { LiveblocksProvider } from "@liveblocks/react/suspense";

function App() {
  return (
    <LiveblocksProvider
      authEndpoint={async (room) => {
        const response = await fetch("/api/liveblocks-auth", {
          method: "POST",
          headers: {
            Authentication: "<your own headers here>",
            "Content-Type": "application/json",
          },
          // Don't forget to pass `room` down. Note that it
          // can be undefined when using Notifications.
          body: JSON.stringify({ room }),
        });
        return await response.json();
      }}
    >
      {/* children */}
    </LiveblocksProvider>
  );
}
```

##### Token details

You should return the token created with
[`Liveblocks.prepareSession`](/docs/api-reference/liveblocks-node#access-tokens)
or [`liveblocks.identifyUser`](/docs/api-reference/liveblocks-node#id-tokens).
These are the values the functions can return.

1. A valid token, it returns a `{ "token": "..." }` shaped response.
1. A token that explicitly forbids access, it returns an
   `{ "error": "forbidden", "reason": "..." }` shaped response. If this is
   returned, the client will disconnect and won't keep trying to authorize.

Any other error will be treated as an unexpected error, after which the client
will retry the request until it receives either 1. or 2.

#### WebSocket throttle [#LiveblocksProviderThrottle]

By default, the client throttles the WebSocket messages sent to one every 100
milliseconds, which translates to 10 updates per second. Itâ€™s possible to
override that configuration with the `throttle` option with a value between `16`
and `1000` milliseconds.

```tsx
import { LiveblocksProvider } from "@liveblocks/react/suspense";

function App() {
  return (
    <LiveblocksProvider
      throttle={16}

      // Other options
      // ...
    >
      {/* children */}
    </LiveblocksProvider>
  );
}
```

This option is helpful for smoothing out realtime animations in your
application, as you can effectively increase the framerate without using any
interpolation. Here are some examples with their approximate frames per second
(FPS) values.

```ts
throttle:  16, // 60 FPS
throttle:  32, // 30 FPS
throttle: 200, //  5 FPS
```

#### Prevent users losing unsaved changes [#prevent-users-losing-unsaved-changes]

Liveblocks usually synchronizes milliseconds after a local change, but if a user
immediately closes their tab, or if they have a slow connection, it may take
longer for changes to synchronize. Enabling `preventUnsavedChanges` will stop
tabs with unsaved changes closing, by opening a dialog that warns users. In
usual circumstances, it will very rarely trigger.

```tsx
function Page() {
  return (
    <LiveblocksProvider
      // highlight-next-line
      preventUnsavedChanges

      // Other options
      // ...
    >
      ...
    </LiveblocksProvider>
  );
}
```

More specifically, this option triggers when:

- There are unsaved changes after calling any hooks or methods, in all of our
  products.
- There are unsaved changes in a
  [Text Editor](/docs/ready-made-features/text-editor).
- Thereâ€™s an unsubmitted comment in the
  [Composer](/docs/api-reference/liveblocks-react-ui#Composer).
- The user has made changes and is currently offline.

Internally, this option uses the
[beforeunload event](https://developer.mozilla.org/en-US/docs/Web/API/Window/beforeunload_event).

#### Lost connection timeout [#LiveblocksProviderLostConnectionTimeout]

If youâ€™re connected to a room and briefly lose connection, Liveblocks will
reconnect automatically and quickly. However, if reconnecting takes longer than
usual, for example if your network is offline, then the room will emit an event
informing you about this.

How quickly this event is triggered can be configured with the
`lostConnectionTimeout` setting, and it takes a number in milliseconds.
`lostConnectionTimeout` can be set between `1000` and `30000` milliseconds. The
default is `5000`, or 5 seconds.

```tsx
import { LiveblocksProvider } from "@liveblocks/react/suspense";

function App() {
  return (
    <LiveblocksProvider
      lostConnectionTimeout={5000}

      // Other props
      // ...
    >
      {/* children */}
    </LiveblocksProvider>
  );
}
```

You can listen to the event with [`useLostConnectionListener`][]. Note that this
also affects when `others` are reset to an empty array after a disconnection.
This helps prevent temporary flashes in your application as a user quickly
disconnects and reconnects. For a demonstration of this behavior, see our
[connection status example][].

#### Background keep-alive timeout [#LiveblocksProviderBackgroundKeepAliveTimeout]

By default, Liveblocks applications will maintain an active WebSocket connection
to the Liveblocks servers, even when running in a browser tab thatâ€™s in the
background. However, if youâ€™d prefer for background tabs to disconnect after a
period of inactivity, then you can use `backgroundKeepAliveTimeout`.

When `backgroundKeepAliveTimeout` is specified, the client will automatically
disconnect applications that have been in an unfocused background tab for _at
least_ the specified time. When the browser tab is refocused, the client will
immediately reconnect to the room and synchronize the document.

```tsx
import { LiveblocksProvider } from "@liveblocks/react/suspense";

function App() {
  return (
    <LiveblocksProvider
      // Disconnect users after 15 minutes of inactivity
      backgroundKeepAliveTimeout={15 * 60 * 1000}

      // Other props
      // ...
    >
      {/* children */}
    </LiveblocksProvider>
  );
}
```

`backgroundKeepAliveTimeout` accepts a number in millisecondsâ€”we advise using a
value of at least a few minutes, to avoid unnecessary disconnections.

#### resolveUsers [#LiveblocksProviderResolveUsers]

[Comments](/docs/ready-made-features/comments) and
[Text Editor](/docs/ready-made-features/text-editor) store user IDs in its
system, but no other user information. To display user information in Comments,
Text Editor, and Notifications components, such as a userâ€™s name or avatar, you
need to resolve these IDs into user objects. This function receives a list of
user IDs and you should return a list of user objects of the same size, in the
same order.

User IDs are automatically resolved in batches with a maximum of 50 users per
batch to optimize performance and prevent overwhelming your user resolution
function.

```tsx
import { LiveblocksProvider } from "@liveblocks/react/suspense";

function App() {
  return (
    <LiveblocksProvider
      resolveUsers={async ({ userIds }) => {
        const usersData = await __getUsersFromDB__(userIds);

        return usersData.map((userData) => ({
          name: userData.name,
          avatar: userData.avatar.src,
        }));
      }}

      // Other props
      // ...
    >
      {/* children */}
    </LiveblocksProvider>
  );
}
```

The name and avatar you return are rendered in
[`Thread`](/docs/api-reference/liveblocks-react-ui#Thread) components.

##### User objects

The user objects returned by the resolver function take the shape of
`UserMeta["info"]`, which contains `name` and `avatar` by default. These two
values are optional, though if youâ€™re using the
[Comments default components](/docs/api-reference/liveblocks-react-ui#Components),
they are necessary. Hereâ€™s an example of `userIds` and the exact values
returned.

```tsx
import { LiveblocksProvider } from "@liveblocks/react/suspense";

function App() {
  return (
    <LiveblocksProvider
      resolveUsers={async ({ userIds }) => {
        // ["marc@example.com", "nimesh@example.com"];
        console.log(userIds);

        return [
          { name: "Marc", avatar: "https://example.com/marc.png" },
          { name: "Nimesh", avatar: "https://example.com/nimesh.png" },
        ];
      }}

      // Other props
      // ...
    >
      {/* children */}
    </LiveblocksProvider>
  );
}
```

You can also return custom information, for example, a userâ€™s `color`:

```tsx
import { LiveblocksProvider } from "@liveblocks/react/suspense";

function App() {
  return (
    <LiveblocksProvider
      resolveUsers={async ({ userIds }) => {
        // ["marc@example.com"];
        console.log(userIds);

        return [
          {
            name: "Marc",
            avatar: "https://example.com/marc.png",
            // +++
            color: "purple",
            // +++
          },
        ];
      }}

      // Other props
      // ...
    >
      {/* children */}
    </LiveblocksProvider>
  );
}
```

##### Accessing user data

You can access any values set within `resolveUsers` with the
[`useUser`](/docs/api-reference/liveblocks-react#useUser) hook.

```tsx
import { useUser } from "@liveblocks/react/suspense";

function Component() {
  const user = useUser("marc@example.com");

  // { name: "Marc", avatar: "https://...", ... }
  console.log(user);
}
```

#### resolveRoomsInfo [#LiveblocksProviderResolveRoomsInfo]

When using
[Notifications](/docs/ready-made-features/comments/email-notifications) with
[Comments](/docs/ready-made-features/comments), room IDs will be used to
contextualize notifications (e.g. â€œChris mentioned you in _room-id_â€) in the
[`InboxNotification`](/docs/api-reference/liveblocks-react-ui#InboxNotification)
component. To replace room IDs with more fitting names (e.g. document names,
â€œChris mentioned you in _Document A_â€), you can provide a resolver function to
the `resolveRoomsInfo` option in [`LiveblocksProvider`](#LiveblocksProvider).

This resolver function will receive a list of room IDs and should return a list
of room info objects of the same size and in the same order.

```tsx
import { LiveblocksProvider } from "@liveblocks/react/suspense";

function App() {
  return (
    <LiveblocksProvider
      resolveRoomsInfo={async ({ roomIds }) => {
        const documentsData = await __getDocumentsFromDB__(roomIds);

        return documentsData.map((documentData) => ({
          name: documentData.name,
          // url: documentData.url,
        }));
      }}

      // Other props
      // ...
    >
      {/* children */}
    </LiveblocksProvider>
  );
}
```

In addition to the roomâ€™s name, you can also provide a roomâ€™s URL as the `url`
property. If you do so, the
[`InboxNotification`](/docs/api-reference/liveblocks-react-ui#InboxNotification)
component will automatically use it. Itâ€™s possible to use an inbox
notificationâ€™s `roomId` property to construct a roomâ€™s URL directly in React and
set it on
[`InboxNotification`](/docs/api-reference/liveblocks-react-ui#InboxNotification)
via `href`, but the room ID might not be enough for you to construct the URL,
you might need to call your backend for example. In that case, providing it via
`resolveRoomsInfo` is the preferred way.

#### resolveGroupsInfo [#LiveblocksProviderResolveGroupsInfo]

When using group mentions with [Comments](/docs/ready-made-features/comments)
and [Text Editor](/docs/ready-made-features/text-editor), group IDs will be used
instead of user IDs. Similarly to
[`resolveUsers`](#LiveblocksProviderResolveUsers), you can provide a resolver
function to the `resolveGroupsInfo` option in
[`LiveblocksProvider`](#LiveblocksProvider) to assign information like names and
avatars to group IDs.

```tsx
import { LiveblocksProvider } from "@liveblocks/react/suspense";

function App() {
  return (
    <LiveblocksProvider
      resolveGroupsInfo={async ({ groupIds }) => {
        const groupsData = await __getGroupsFromDB__(groupIds);

        return groupsData.map((groupData) => ({
          name: groupData.name,
          avatar: groupData.avatar.src,
          // description: groupData.description,
        }));
      }}

      // Other props
      // ...
    >
      {/* children */}
    </LiveblocksProvider>
  );
}
```

##### Accessing group info

You can access any values set within `resolveGroupsInfo` with the
[`useGroupInfo`](/docs/api-reference/liveblocks-react#useGroupInfo) hook.

```tsx
import { useGroupInfo } from "@liveblocks/react/suspense";

function Component() {
  const group = useGroupInfo("group-engineering");

  // { name: "Engineering", avatar: "https://...", ... }
  console.log(group);
}
```

#### resolveMentionSuggestions [#LiveblocksProviderResolveMentionSuggestions]

To enable creating mentions in [Comments](/docs/ready-made-features/comments)
and [Text Editor](/docs/ready-made-features/text-editor), you can provide a
resolver function to the `resolveMentionSuggestions` option in
[`LiveblocksProvider`](#LiveblocksProvider). These mentions will be displayed in
the [`Composer`](/docs/api-reference/liveblocks-react-ui#Composer) component and
in text editors.

This resolver function will receive the mention currently being typed (e.g. when
writing â€œ@janeâ€, `text` will be `jane`) and should return a list of user IDs
matching that text. This function will be called every time the text changes but
with some debouncing.

```tsx
import { LiveblocksProvider } from "@liveblocks/react/suspense";

function App() {
  return (
    <LiveblocksProvider
      resolveMentionSuggestions={async ({ text, roomId }) => {
        const workspaceUsers = await __getWorkspaceUsersFromDB__(roomId);

        if (!text) {
          // Show all workspace users by default
          return __getUserIds__(workspaceUsers);
        } else {
          const matchingUsers = __findUsers__(workspaceUsers, text);
          return __getUserIds__(matchingUsers);
        }
      }}

      // Other props
      // ...
    >
      {/* children */}
    </LiveblocksProvider>
  );
}
```

##### Group mentions

To support group mentions in [Comments](/docs/ready-made-features/comments) and
[Text Editor](/docs/ready-made-features/text-editor), you can return a list of
mention objects instead of user IDs to suggest a mix of user and group mentions.

```tsx
import { LiveblocksProvider } from "@liveblocks/react/suspense";

function App() {
  return (
    <LiveblocksProvider
      resolveMentionSuggestions={async ({ text, roomId }) => {
        const dbUsers = await __findUsersFromDB__(roomId);
        const dbGroups = await __findGroupsFromDB__(roomId);

        // Show groups and users matching the text being typed
        return [
          ...dbGroups.map((group) => ({
            kind: "group",
            id: group.id,
          })),
          ...dbUsers.map((user) => ({
            kind: "user",
            id: user.id,
          })),
        ];
      }}

      // Other props
      // ...
    >
      {/* children */}
    </LiveblocksProvider>
  );
}
```

The mention objects specify which kind of mention it is, the ID to mention (user
ID or group ID), etc.

```tsx
// A user mention suggestion
{
  kind: "user",
  id: "user-1",
}

// A group mention suggestion
{
  kind: "group",
  id: "group-1",
}

// A group mention suggestion with fixed group members
// When using fixed group members via `userIds`, they will take precedence
// if the group ID exists on Liveblocks.
{
  kind: "group",
  id: "here",
  userIds: ["user-1", "user-2"],
}
```

#### LiveblocksProvider for Node.js [#LiveblocksProviderNode]

To use `@liveblocks/client` in Node.js, you need to provide [`WebSocket`][] and
[`fetch`][] polyfills. As polyfills, we recommend installing [`ws`][] and
[`node-fetch`][].

```bash
npm install ws node-fetch
```

Then, pass them to the `LiveblocksProvider` polyfill option as below.

```tsx
import { LiveblocksProvider } from "@liveblocks/react/suspense";
import fetch from "node-fetch";
import WebSocket from "ws";

function App() {
  return (
    <LiveblocksProvider
      polyfills={{
        fetch,
        WebSocket,
      }}

      // Other props
      // ...
    >
      {/* children */}
    </LiveblocksProvider>
  );
}
```

Note that `node-fetch` v3+
[does not support CommonJS](https://github.com/node-fetch/node-fetch/blob/main/docs/v3-UPGRADE-GUIDE.md#converted-to-es-module).
If you are using CommonJS, downgrade `node-fetch` to v2.

#### LiveblocksProvider for React Native [#LiveblocksProviderReactNative]

To use `@liveblocks/client` with [React Native](https://reactnative.dev/), you
need to add an [`atob`][] polyfill. As a polyfill, we recommend installing
[`base-64`][].

```bash
npm install base-64
```

Then you can pass the `decode` function to our `atob` polyfill option when you
create the client.

```ts
import { LiveblocksProvider } from "@liveblocks/react/suspense";
import { decode } from "base-64";

function App() {
  return (
    <LiveblocksProvider
      polyfills={{
        atob: decode,
      }}

      // Other props
      // ...
    >
      {/* children */}
    </LiveblocksProvider>
  );
}
```

#### Powered by Liveblocks branding

By default, Liveblocks displays a "Powered by Liveblocks" badge in your
application. You can adjust the position of the badge by setting the
`badgeLocation` property on `LiveblocksProvider`.

```tsx title="Set badge location"
// "top-right", "bottom-right", "bottom-left", "top-left"
<LiveblocksProvider badgeLocation="bottom-right">
  <App />
</LiveblocksProvider>
```

If you wish to remove remove the badge entirely, you can do so by following
these steps:

1. In the Liveblocks dashboard, navigate to your
   [teamâ€™s settings](/dashboard/settings).
2. Under **General**, toggle on the remove "Powered by Liveblocks" branding
   option.

<Banner title='Removing the "Powered by Liveblocks" badge'>

Removing the "Powered by Liveblocks" badge on your projects requires a
[paid plan](/pricing/). See the [pricing page](/pricing/) for more information.

</Banner>

### createLiveblocksContext

<Banner title="Not recommended" type="warning">

This used to be the default way to start your app, but now itâ€™s recommended for
advanced usage only. We generally recommend using [`LiveblocksProvider`][] and
following [typing your data with the Liveblocks interface](#Typing-your-data),
unless you need to define multiple room types in your application.

</Banner>

Creates a [`LiveblocksProvider`][] and a set of typed hooks. Note that any
`LiveblocksProvider` created in this way takes no props, because it uses
settings from the `client` instead. We recommend using it in
`liveblocks.config.ts` and re-exporting your typed hooks like below.

While [`createRoomContext`](#createRoomContext) offers APIs for interacting with
rooms (e.g. Presence, Storage, and Comments),
[`createLiveblocksContext`](#createLiveblocksContext) offers APIs for
interacting with Liveblocks features that are not tied to a specific room (e.g.
Notifications).

```tsx file="liveblocks.config.ts"
import { createClient } from "@liveblocks/client";
import { createRoomContext, createLiveblocksContext } from "@liveblocks/react";

const client = createClient({
  // publicApiKey: "",
  // authEndpoint: "/api/liveblocks-auth",
  // throttle: 100,
});

// ...

export const { RoomProvider } = createRoomContext(client);

export const {
  LiveblocksProvider,
  useInboxNotifications,

  // Other hooks
  // ...
} = createLiveblocksContext(client);
```

### useClient [@badge=LiveblocksProvider]

Returns the [`client`](/docs/api-reference/liveblocks-client#createClient) of
the nearest [`LiveblocksProvider`][] above in the React component tree.

```ts
import { useClient } from "@liveblocks/react/suspense";

const client = useClient();
```

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

<PropertiesList title="Returns">
  <PropertiesListItem name="client" type="Client">
    The [Liveblocks client](/docs/api-reference/liveblocks-client#createClient)
    instance from the nearest [`LiveblocksProvider`][].
  </PropertiesListItem>
</PropertiesList>

### useErrorListener [@badge=LiveblocksProvider]

Listen to potential Liveblocks errors. Examples of errors include room
connection errors, errors creating threads, and errors deleting notifications.
Each error has a `message` string, and a `context` object which has different
values for each error type. `context` always contains an error `type` and
`roomId`.

```ts
import { useErrorListener } from "@liveblocks/react/suspense";

useErrorListener((error) => {
  // { message: "You don't have access to this room", context: { ... }}
  console.error(error);
});
```

There are many different errors, and each can be handled separately by checking
the value of `error.context.type`. Below weâ€™ve listed each error and the context
it provides.

```ts title="All error types" isCollapsable isCollapsed
import { useErrorListener } from "@liveblocks/react/suspense";

useErrorListener((error) => {
  switch (error.context.type) {
    // Can happen if you use Presence, Storage, or Yjs
    case "ROOM_CONNECTION_ERROR": {
      const { code } = error.context;
      // -1   = Authentication error
      // 4001 = You don't have access to this room
      // 4005 = Room was full
      // 4006 = Room ID has changed
      break;
    }

    // Can happen if you use Comments or Notifications
    case "CREATE_THREAD_ERROR":
      const { roomId, threadId, commentId, body, metadata } = error.context;
      break;

    case "DELETE_THREAD_ERROR":
      const { roomId, threadId } = error.context;
      break;

    case "EDIT_THREAD_METADATA_ERROR":
      const { roomId, threadId, metadata } = error.context;
      break;

    case "MARK_THREAD_AS_RESOLVED_ERROR":
    case "MARK_THREAD_AS_UNRESOLVED_ERROR":
      const { roomId, threadId } = error.context;
      break;

    case "CREATE_COMMENT_ERROR":
    case "EDIT_COMMENT_ERROR":
      const { roomId, threadId, commentId, body } = error.context;
      break;

    case "DELETE_COMMENT_ERROR":
      const { roomId, threadId, commentId } = error.context;
      break;

    case "ADD_REACTION_ERROR":
    case "REMOVE_REACTION_ERROR":
      const { roomId, threadId, commentId, emoji } = error.context;
      break;

    case "MARK_INBOX_NOTIFICATION_AS_READ_ERROR":
      const { inboxNotificationId, roomId } = error.context;
      break;

    case "DELETE_INBOX_NOTIFICATION_ERROR":
      const { roomId } = error.context;
      break;

    case "MARK_ALL_INBOX_NOTIFICATIONS_AS_READ_ERROR":
    case "DELETE_ALL_INBOX_NOTIFICATIONS_ERROR":
      break;

    case "UPDATE_ROOM_SUBSCRIPTION_SETTINGS_ERROR":
      const { roomId } = error.context;
      break;

    default:
      // Ignore any error from the future
      break;
  }
});
```

<PropertiesList title="Arguments">
  <PropertiesListItem name="callback" type="(error: LiveblocksError) => void">
    A callback function that will be called when a Liveblocks error occurs. The
    error object contains a message and context with error-specific information.
  </PropertiesListItem>
</PropertiesList>

## AI Copilots

### useAiChats [@badge=LiveblocksProvider]

Returns a paginated list of AI chats created by the current user. Initially
fetches the latest 50 chats.
[Suspense](/docs/api-reference/liveblocks-react#Suspense-hooks) and
[regular](/docs/api-reference/liveblocks-react#Regular-hooks) versions of this
hook are available.

```tsx
import { useAiChats } from "@liveblocks/react";

const { chats, error, isLoading } = useAiChats();
```

<PropertiesList title="Options">
  <PropertiesListItem name="query" type="AiChatsQuery">
    Optional query to filter chats by metadata values or absence of metadata
    keys. [Learn more](/docs/api-reference/liveblocks-react#useAiChats-query)
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Returns">
  <PropertiesListItem name="chats" type="AiChat[] | undefined">
    An array of AI chats created by the current user.
  </PropertiesListItem>
  <PropertiesListItem name="isLoading" type="boolean">
    Whether the chats are currently being loaded.
  </PropertiesListItem>
  <PropertiesListItem name="error" type="Error | undefined">
    Any error that occurred while loading the chats. [Learn
    more](/docs/api-reference/liveblocks-react#useAiChats-error-handling).
  </PropertiesListItem>
  <PropertiesListItem name="hasFetchedAll" type="boolean">
    Whether all available chats have been fetched. [Learn
    more](/docs/api-reference/liveblocks-react#useAiChats-pagination).
  </PropertiesListItem>
  <PropertiesListItem name="fetchMore" type="() => void">
    A function to fetch more chats. [Learn
    more](/docs/api-reference/liveblocks-react#useAiChats-pagination).
  </PropertiesListItem>
  <PropertiesListItem name="isFetchingMore" type="boolean">
    Whether more chats are currently being fetched. [Learn
    more](/docs/api-reference/liveblocks-react#useAiChats-pagination).
  </PropertiesListItem>
  <PropertiesListItem name="fetchMoreError" type="Error | undefined">
    Any error that occurred while fetching more chats. [Learn
    more](/docs/api-reference/liveblocks-react#useAiChats-pagination).
  </PropertiesListItem>
</PropertiesList>

##### List the user's chats and switch between them

You can use the [`AiChat`](/docs/api-reference/liveblocks-react-ui#AiChat)
component alongside the hook to create an AI chat switcher. Below, each button
displays the chat's automatically generated title, and chats can be deleted with
[`useDeleteAiChat`](#useDeleteAiChat).

```tsx
import { useState } from "react";
import { AiChat } from "@liveblocks/react-ui";
import { useAiChats } from "@liveblocks/react";

function Chats() {
  // +++
  const { chats, error, isLoading } = useAiChats();
  const [chatId, setChatId] = useState();
  const deleteChat = useDeleteAiChat();
  // +++

  if (isLoading) {
    return <div>Loading...</div>;
  }

  if (error) {
    return <div>Error: {error.message}</div>;
  }

  return (
    <div style={{ display: "flex" }}>
      <ul>
        // +++
        {chats.map((chat) => (
          <li key={chat.id}>
            <button onClick={() => setChatId(chat.id)}>
              {chat.title || "Untitled"}
            </button>
            <button onClick={() => deleteChat(chat.id)}>âŒ</button>
          </li>
        ))}
        // +++
      </ul>
      // +++
      <AiChat chatId={chatId} />
      // +++
    </div>
  );
}
```

#### Querying chats [#useAiChats-query]

Itâ€™s possible to return chats that match a certain query with the `query`
option. You can filter by metadata values, or by the absence of a metadata key.
Returned chats must match the entire query.

```tsx
import { useAiChats } from "@liveblocks/react";

// Filter by metadata values and by absence of a key
const { chats } = useAiChats({
  query: {
    metadata: {
      // Match chats that are of type 'temporary'
      type: "temporary",

      // Match chats that have all of these tags
      tag: ["urgent", "billing"],

      // Match chats where the "archived" key does not exist
      archived: null,
    },
  },
});
```

#### Pagination [#useAiChats-pagination]

By default, the `useAiChats` hook returns up to 50 chats. To fetch more, the
hook provides additional fields for pagination, similar to [`useThreads`][].

```tsx
import { useAiChats } from "@liveblocks/react";

const {
  chats,
  isLoading,
  error,

  +++
  hasFetchedAll,
  fetchMore,
  isFetchingMore,
  fetchMoreError,
  +++
} = useAiChats();
```

- `hasFetchedAll` indicates whether all available AI chats have been fetched.
- `fetchMore` loads up to 50 more AI chats, and is always safe to call.
- `isFetchingMore` indicates whether more AI chats are being fetched.
- `fetchMoreError` returns error statuses resulting from fetching more.

##### Pagination example [#useAiChats-pagination-example]

The following example demonstrates how to use the `fetchMore` function to
implement a â€œLoad Moreâ€ button, which fetches additional AI chats when clicked.
The button is disabled while fetching is in progress.

```tsx
import { AiChat } from "@liveblocks/react-ui";
import { useAiChats } from "@liveblocks/react";

function Inbox() {
  const { chats, hasFetchedAll, fetchMore, isFetchingMore } = useAiChats();

  return (
    <div>
      {chats.map((chat) => (
        <AiChat key={chat.id} chatId={chat.id} />
      ))}
      // +++
      {hasFetchedAll ? (
        <div>ðŸŽ‰ All chats loaded!</div>
      ) : (
        <button disabled={isFetchingMore} onClick={fetchMore}>
          Load more
        </button>
      )}
      // +++
    </div>
  );
}
```

#### Error handling [#useAiChats-error-handling]

Error handling is another important aspect to consider when using the
`useAiChats` hook. The `error` and `fetchMoreError` fields provide information
about any errors that occurred during the initial fetch or subsequent fetch
operations, respectively. You can use these fields to display appropriate error
messages to the user and implement retry mechanisms if needed.

The following example shows how to display error messages for both initial
loading errors and errors that occur when fetching more inbox notifications.

```tsx
import { AiChat } from "@liveblocks/react-ui";
import { useAiChats } from "@liveblocks/react";

function Inbox() {
  const { chats, error, fetchMore, fetchMoreError } = useAiChats();

  // Handle error if the initial load failed.
  // The `error` field is not returned by the Suspense hook as the error is thrown to nearest ErrorBoundary
  // +++
  if (error) {
    return (
      <div>
        <p>Error loading AI chats: {error.message}</p>
      </div>
    );
  }
  // +++

  return (
    <div>
      {chats.map((chat) => (
        <AiChat key={chat.id} chatId={chat.id} />
      ))}

      {fetchMoreError && (
        <div>
          <p>Error loading more AI chats: {fetchMoreError.message}</p>
          <button onClick={fetchMore}>Retry</button>
        </div>
      )}
    </div>
  );
}
```

### useAiChat

Returns information about an AI chat, for example its title and metadata. Titles
are automatically generated from the content of the first user message in a
chat, and the AIâ€™s response.
[Suspense](/docs/api-reference/liveblocks-react#Suspense-hooks) and
[regular](/docs/api-reference/liveblocks-react#Regular-hooks) versions of this
hook are available.

```tsx
import { useAiChat } from "@liveblocks/react";

const { chat, error, isLoading } = useAiChat("my-chat-id");
```

<PropertiesList title="Arguments">
  <PropertiesListItem name="chatId" type="string">
    The ID of the AI chat to retrieve information for.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Returns">
  <PropertiesListItem name="chat" type="AiChat | undefined">
    The AI chat object containing title, metadata, and other properties.
  </PropertiesListItem>
  <PropertiesListItem name="isLoading" type="boolean">
    Whether the chat information is currently being loaded.
  </PropertiesListItem>
  <PropertiesListItem name="error" type="Error | undefined">
    Any error that occurred while loading the chat information.
  </PropertiesListItem>
</PropertiesList>

#### Displaying a default title

If `chat.title` is `undefined` after an `isLoading` check, that means the title
has not been set yet. You can display a default title in this case, and the
title will be displayed once generated.

```tsx
import { useAiChat } from "@liveblocks/react";

function ChatTitle() {
  const { chat, error, isLoading } = useAiChat("my-chat-id");

  if (isLoading || error) {
    return null;
  }

  // +++
  return <div>{chat.title || "Untitled chat"}</div>;
  // +++
}
```

### useCreateAiChat

Returns a function that creates an AI chat.

```tsx
import { useCreateAiChat } from "@liveblocks/react/suspense";

const createAiChat = useCreateAiChat();
createAiChat("my-ai-chat");
```

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

<PropertiesList title="Returns">
  <PropertiesListItem
    name="createAiChat"
    type="(chatIdOrOptions: string | CreateAiChatOptions) => AiChat"
  >
    A function that creates an AI chat. Can be called with either a string ID or
    an options object containing `id`, optional `title`, and optional
    `metadata`.
  </PropertiesListItem>
</PropertiesList>

#### Create a chat with a custom title and metadata

You can optionally set a `title` with `useCreateAiChat`, which prevents the AI
auto-generating a title from the first messages. Additionally, you can choose to
set custom `metadata` for the chat, strings or arrays of strings.

```tsx
import { useCreateAiChat } from "@liveblocks/react/suspense";

const createAiChat = useCreateAiChat();
createAiChat({
  id: "my-ai-chat",
  // +++
  title: "My AI Chat",
  metadata: {
    color: "red",
    tags: ["product", "engineering"],
  },
  // +++
});
```

### useDeleteAiChat

Returns a function that deletes an AI chat by its ID. Use in conjunction with
[`useAiChats`](#useAiChats) to
[loop through each chat](/docs/api-reference/liveblocks-react#List-the-user's-chats-and-switch-between-them)
and add a delete button.

```tsx
import { useDeleteAiChat } from "@liveblocks/react/suspense";

const deleteAiChat = useDeleteAiChat();
deleteAiChat("my-chat-id");
```

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

<PropertiesList title="Returns">
  <PropertiesListItem name="deleteAiChat" type="(chatId: string) => void">
    A function that deletes an AI chat by its ID.
  </PropertiesListItem>
</PropertiesList>

### useSendAiMessage

Returns a function that sends a message to an AI chat, identified by its ID.
Useful for
[creating suggestions in empty inside chats](/docs/api-reference/liveblocks-react-ui#AiChat-placeholder)
and sending messages on behalf of the user.

```tsx
import { useSendAiMessage } from "@liveblocks/react";

const sendAiMessage = useSendAiMessage("my-chat-id");
sendAiMessage("Hello!");
```

Remember to [set your copilot ID]() otherwise the default copilot will be used.

```tsx
const sendAiMessage = useSendAiMessage("my-chat-id", {
  // +++
  copilotId: "co_h7GBa3...",
  // +++
});
```

<PropertiesList title="Arguments">
  <PropertiesListItem name="chatId" type="string">
    Optional. The ID of the AI chat to send messages to. Can also be provided
    when calling the returned function.
  </PropertiesListItem>
  <PropertiesListItem name="options" type="object">
    Optional configuration object.
  </PropertiesListItem>
  <PropertiesListItem name="options.copilotId" type="string">
    Optional. The ID of the copilot to use for sending the message.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Returns">
  <PropertiesListItem
    name="sendAiMessage"
    type="(messageOrOptions: string | SendAiMessageOptions) => AiChatMessage"
  >
    A function that sends a message to an AI chat. Can be called with either a
    string message or an options object containing `text`, optional `chatId`,
    and optional `copilotId`.
  </PropertiesListItem>
</PropertiesList>

#### Setting options when sending a message

Optionally you can set options when sending a message, instead of when creating
the hook. Alternatively, you can also override or complete the hookâ€™s options
when calling the function by passing an object to it.

```tsx
import { useSendAiMessage } from "@liveblocks/react";

// Setting a `chatId` and `copilotId`
const sendAiMessage = useSendAiMessage("my-chat-id", {
  copilotId: "co_shSm8f...",
});

// Sends to initial `chatId` and `copilotId`
sendAiMessage("Hello!");

// Overwrites the `copilotId` just for this message
sendAiMessage({
  text: "Hello world",
  // +++
  copilotId: "co_Xpksa9...",
  // +++
});

// Overwrites the `chatId` just for this message
sendAiMessage({
  text: "Hello world",
  // +++
  chatId: "my-other-chat-id",
  // +++
});
```

You can even skip setting the `chatId` and `copilotId` in the hook, and just
pass them in the function.

```tsx
// +++
const sendAiMessage = useSendAiMessage();
// +++

sendAiMessage({
  text: "Hello world",
  chatId: "my-other-chat-id",
});
```

#### Get the created message object

If necessary, you can also access the newly created message object.

```tsx
import { useSendAiMessage } from "@liveblocks/react";

const sendAiMessage = useSendAiMessage("my-chat-id");
const message = sendAiMessage("Hello world");

//  { id: "ms_gw1wEn...", chatId: "my-chat-id", content: [...], ...}
console.log(message);
```

### useAiChatMessages

Returns a list of every message in an AI chat, identified by its ID. Updates in
realtime using WebSockets.

```tsx
import { useAiChatMessages } from "@liveblocks/react";

const { messages, error, isLoading } = useAiChatMessages("my-chat-id");
```

<PropertiesList title="Arguments">
  <PropertiesListItem name="chatId" type="string">
    The ID of the AI chat to retrieve messages from.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Returns">
  <PropertiesListItem name="messages" type="AiChatMessage[] | undefined">
    An array of messages in the AI chat.

    <div className="-mt-1">
    ```tsx isCollapsable isCollapsed title="Example messages"
    [
      {
        "id": "ms_gw1wENvliU471QuojwVbO",
        "chatId": "my-chat-id",
        "parentId": null,
        "createdAt": "2025-09-30T15:37:01.000Z",
        "role": "user",
        "content": [
          {
            "type": "text",
            "text": "Hello"
          }
        ],
        "navigation": {
          "parent": null,
          "prev": null,
          "next": null
        }
      },
      {
        "id": "ms_dwoLgXARKgJT4zAjkktv6",
        "chatId": "my-chat-id",
        "parentId": "ms_gw1wENvliU471QuojwVbO",
        "createdAt": "2025-09-30T15:37:01.000Z",
        "copilotId": "co_lxYkxUdt08d01sJIBUZhg",
        "role": "assistant",
        "status": "completed",
        "content": [
          {
            "type": "text",
            "text": "Hi there! How can I help you today?\n",
            "t": 2783
          }
        ],
        "navigation": {
          "parent": "ms_gw1wENvliU471QuojwVbO",
          "prev": null,
          "next": null
        }
      }
    ]
    ```
    </div>

  </PropertiesListItem>
  <PropertiesListItem name="isLoading" type="boolean">
    Whether the messages are currently being loaded.
  </PropertiesListItem>
  <PropertiesListItem name="error" type="Error | undefined">
    Any error that occurred while loading the messages.
  </PropertiesListItem>
</PropertiesList>

### useAiChatStatus

Returns the status of an AI chat, indicating whether itâ€™s disconnected, loading,
idle or actively generating content. This is a convenience hook that derives its
state from the latest assistant message in the chat.

```tsx
import { useAiChatStatus } from "@liveblocks/react";

const { status, partType, toolName } = useAiChatStatus("my-chat-id");
```

<PropertiesList title="Arguments">
  <PropertiesListItem name="chatId" type="string">
    The ID of the AI chat.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Returns">
  <PropertiesListItem
    name="status"
    type={`"disconnected" | "loading" | "idle" | "generating"`}
  >
    The current synchronization status of the chat. When disconnected the AI
    service is not available.
  </PropertiesListItem>
  <PropertiesListItem name="partType" type={`"text" | "tool-invocation"`}>
    The type of content being generated.
  </PropertiesListItem>
  <PropertiesListItem name="toolName" type="string | undefined">
    The name of the tool being invoked. If no tool is currently being called,
    returns `undefined`.
  </PropertiesListItem>
</PropertiesList>

### RegisterAiKnowledge

Adds knowledge to all AI features on the page. AI will understand the
information you pass, and will answer questions or call tools based on it. This
is particularly helpful for passing user info, app state, and other small
contextual knowledge.

```tsx
<RegisterAiKnowledge
  description="The current user's payment plan"
  value="Enterprise"
/>
```

Each knowledge source has a `description` string, and a `value` which can be
either a string, object, array or JSON-serializable value that provides
meaningful context for your use case. The AI uses this data, along with the
accompanying description, to better understand and respond to user queries or
perform actions based on the supplied context. These components can be placed
anywhere in your app, so long as theyâ€™re under
[`LiveblocksProvider`](/docs/api-reference/liveblocks-react#LiveblocksProvider).

```tsx
import { AiChat } from "@liveblocks/react-ui";
import { RegisterAiKnowledge } from "@liveblocks/react";

function Chat() {
  return (
    <>
      // +++
      <RegisterAiKnowledge
        description="The current user's payment plan"
        value="Enterprise"
      />
      <RegisterAiKnowledge
        description="The current user's info"
        value={{
          name: "Jody Hekla",
          email: "jody@liveblocks.io",
          teams: ["Engineering", "Product"],
        }}
      />
      // +++
      <AiChat chatId="my-chat-id" />
    </>
  );
}
```

#### Pass in assorted context [#RegisterAiKnowledge-context]

Passing the AI context about the current datetime, the userâ€™s language, the page
the userâ€™s visiting, and navigable pages on your website, is an effective method
for improving your chatâ€™s replies.

```tsx
import { RegisterAiKnowledge } from "@liveblocks/react";

function Chat() {
  return (
    <>
      // +++
      <RegisterAiKnowledge
        description="The current date and time"
        value={new Date()}
      />
      <RegisterAiKnowledge
        description="The user's preferred language"
        value={navigator.language}
      />
      <RegisterAiKnowledge
        description="The current URL"
        value={window.location.href}
      />
      <RegisterAiKnowledge
        description="URLs on this website"
        value={["/dashboard", "/billing", "/settings"]}
      />
      // +++
    </>
  );
}
```

When building your app, itâ€™s worth considering which app-specific context will
be helpful, for example the userâ€™s payment plan, or a list of their projects.

#### Pass in user data from your auth provider [#RegisterAiKnowledge-user]

You can pass in knowledge from your auth provider, for example with
[`useUser`](https://clerk.com/docs/hooks/use-user) from
[Clerk](https://clerk.com). You can tell AI that the state is loading in a
simple string, and it will understand.

```tsx
import { RegisterAiKnowledge } from "@liveblocks/react";
import { useUser } from "@clerk/clerk-react";

function Chat() {
  // +++
  const { isSignedIn, user, isLoaded } = useUser();
  // +++

  return (
    // +++
    <RegisterAiKnowledge
      description="The current user's info"
      value={isLoaded ? (isSignedIn ? user : "Not signed in") : "Loading..."}
    />
    // +++
  );
}
```

#### Pass in assorted data from fetching hooks [#RegisterAiKnowledge-fetching]

You can pass in knowledge from data fetching hooks such as with
[`useSWR`](https://swr.vercel.app/docs/getting-started) from
[SWR](https://swr.vercel.app/). You can tell AI that the state is loading in a
simple string, and it will understand.

```tsx
import { RegisterAiKnowledge } from "@liveblocks/react";
import useSWR from "swr";

function Chat() {
  // +++
  const { data, error, isLoading } = useSWR(`/important-data`, fetcher);
  // +++

  return (
    // +++
    <RegisterAiKnowledge
      description="Important data"
      value={isLoading ? "Loading..." : error ? "Problem fetching data" : data}
    />
    // +++
  );
}

const fetcher = (...args) => fetch(...args).then((res) => res.json());
```

#### Pass in text editor document data [#RegisterAiKnowledge-text-editor]

You can pass in knowledge from your text editor, for example when using
[Liveblocks Tiptap](/docs/api-reference/liveblocks-react-tiptap).

```tsx
import { RegisterAiKnowledge } from "@liveblocks/react-ui";
import { useLiveblocksExtension } from "@liveblocks/react-tiptap";
import { useEditor, EditorContent } from "@tiptap/react";

function TextEditor() {
  const liveblocks = useLiveblocksExtension();

  // +++
  const editor = useEditor({
    extensions: [
      liveblocks,
      // ...
    ],
  });
  // +++

  return (
    <div>
      // +++
      <RegisterAiKnowledge
        description="The current document's Tiptap state"
        value={editor.getHTML()}
      />
      // +++
      <EditorContent editor={editor} />
    </div>
  );
}
```

As well as `editor.getHTML()`, `editor.getJSON()` and `editor.getText()` are
also available when using Tiptap. Its worth trying them all, in case your AI
model understands one of them better than the others.

{/* TODO how to make tools where you can write to the text editor */}

#### Pass in comment data [#RegisterAiKnowledge-storage]

You can also pass in knowledge from your custom Liveblocks Comments app with
[`useThreads`](/docs/api-reference/liveblocks-react#useThreads). This way, your
AI chat will understand the context in the current room.

```tsx
import { RegisterAiKnowledge, useThreads } from "@liveblocks/react";

function Comments() {
  // +++
  const { threads, isLoading, error } = useThreads();
  // +++

  return (
    <div>
      // +++
      <RegisterAiKnowledge
        description="The comment threads in the current document"
        value={
          isLoading
            ? "Loading..."
            : error
              ? "Problem fetching threads"
              : threads
        }
      />
      // +++
      {threads.map((thread) => (
        <Thread key={thread.id} thread={thread} />
      )}
    </div>
  );
}
```

#### Pass in storage data [#RegisterAiKnowledge-storage]

You can also pass in knowledge from your custom Liveblocks storage app with
[`useStorage`](/docs/api-reference/liveblocks-react#useStorage). This way, your
AI chat will understand the context in the current room.

```tsx
import { RegisterAiKnowledge, useStorage } from "@liveblocks/react/suspense";

function Whiteboard() {
  // +++
  const shapes = useStorage((root) => root.shapes);
  // +++

  return (
    <div>
      // +++
      <RegisterAiKnowledge
        description="The current shapes on the whiteboard"
        value={shapes}
      />
      // +++
      {shapes.map((shape) => (
        // ...
      )}
    </div>
  );
}
```

#### Props [#RegisterAiKnowledge-props]

<PropertiesList>
  <PropertiesListItem name="description" type="string" required>
    A clear description of what this knowledge represents. This helps the AI
    understand the context and relevance of the provided information.
  </PropertiesListItem>
  <PropertiesListItem name="value" type="Json" required>
    The actual data or information to share with the AI. Can be a string,
    object, array, or any JSON-serializable information that offers context
    relevant to your application or user.
  </PropertiesListItem>
  <PropertiesListItem name="id" type="string">
    Optional unique identifier for this knowledge source. If provided,
    subsequent updates with the same ID will replace the previous knowledge.
  </PropertiesListItem>
  <PropertiesListItem name="chatId" type="string">
    Optional chat ID to scope this tool to a specific chat. If provided, the
    tool will only be available to that chat.
  </PropertiesListItem>
</PropertiesList>

### RegisterAiTool

Registers a tool that can be used by
[AI chats](/docs/api-reference/liveblocks-react-ui#AiChat) on the page. Tools
allow AI to autonomously run actions, render custom components, and show
confirmation or human-in-the-loop UIs within the chat.

```tsx
import { RegisterAiTool } from "@liveblocks/react";
import { defineAiTool } from "@liveblocks/client";

<RegisterAiTool
  name="my-tool"
  tool={defineAiTool()({
    // Tool definition
    // ...
  })}
/>;
```

{/* TODO lots more info */}

[`defineAiTool`](/docs/api-reference/liveblocks-client#defineAiTool) is used to
create a tool definition, and you can supply `parameters` as a
[JSON Schema](https://json-schema.org/) that the AI can fill in. If you supply
an `execute` function the AI will call it. `render` is used to show UI inside
the chat. Below is an example of a tool that lets AI get the current weather in
a given location, then renders a component in the chat.

{/* TODO this all needs to be explained better */}

```tsx
function App() {
  return (
    <>
      // +++
      <RegisterAiTool
        name="get-weather"
        tool={defineAiTool()({
          description: "Get current weather information",
          parameters: {
            type: "object",
            properties: {
              location: { type: "string", description: "City name" },
            },
            required: ["location"],
            additionalProperties: false,
          },
          execute: async (args) => {
            const { temperature, condition } = await __getWeather__(
              args.location
            );
            return { data: { temperature, condition } };
          },
          render: ({ result }) => (
            <AiTool title="Weather Lookup" icon="ðŸŒ¤ï¸">
              {result.data ? (
                <div>
                  {result.data.temperature}Â°F - {result.data.condition}
                </div>
              ) : null}
            </AiTool>
          ),
        })}
      />
      // +++
      <AiChat chatId="my-chat" />
    </>
  );
}
```

#### Tool that sends a toast notification

The following snippet shows a tool that lets AI send a toast notification with
[Sonner](https://sonner.emilkowal.ski/), then adds a message in the chat with
[`AiTool`](/docs/api-reference/liveblocks-react-ui#AiTool), letting the user
know that a toast was sent.

```tsx
import { AiChat } from "@liveblocks/react-ui";
import { RegisterAiTool } from "@liveblocks/react";
import { defineAiTool } from "@liveblocks/client";
import { toast, Toaster } from "sonner";

function Chat() {
  return (
    <>
      <RegisterAiTool
        name="send-toast-notification"
        tool={defineAiTool()({
          description: "Send a toast notification",

          parameters: {
            type: "object",
            properties: {
              message: {
                type: "string",
                description: "The message to display in the toast",
              },
            },
            required: ["message"],
            additionalProperties: false,
          },

          execute: async ({ message }) => {
            toast(message);
            return {
              data: { message },
              description: "You sent a toast",
            };
          },

          render: () => <AiTool title="Toast sent" icon="ðŸž" />,
        })}
      />
      <AiChat chatId="my-chat-id" />
      <Toaster />
    </>
  );
}
```

#### Scoping a tool to a specific chat

Tools can be scoped to specific chats by providing a `chatId` prop. When scoped,
the tool will only be available to that specific chat.

```tsx
import { AiChat } from "@liveblocks/react-ui";
import { RegisterAiTool } from "@liveblocks/react";
import { defineAiTool } from "@liveblocks/client";

function Chat() {
  return (
    <>
      <RegisterAiTool
        name="private-tool"
        tool={defineAiTool()({
          // Tool definition
          // ...
        })}
        // +++
        chatId="my-chat"
        // +++
      />
      // +++
      <AiChat chatId="my-chat" />
      // +++
    </>
  );
}
```

#### Props [#RegisterAiTool-props]

<PropertiesList>
  <PropertiesListItem name="name" type="string" required>
    Unique name for the tool. This is used internally to identify and manage the
    tool.
  </PropertiesListItem>
  <PropertiesListItem name="tool" type="AiOpaqueToolDefinition" required>
    The tool definition created with
    [`defineAiTool`](/docs/api-reference/liveblocks-client#defineAiTool).
  </PropertiesListItem>
  <PropertiesListItem name="chatId" type="string">
    Optional chat ID to scope this tool to a specific chat. If provided, the
    tool will only be available to that chat.
  </PropertiesListItem>
  <PropertiesListItem name="enabled" type="boolean">
    Whether this tool should be enabled. When set to `false`, the tool will not
    be made available to the AI copilot for any new/future chat messages, but
    will still allow existing tool invocations to be rendered that are part of
    the historic chat record. When provided as a prop to `RegisterAiTool`, it
    will take precedence over the value of the toolâ€™s `enabled` value in
    `defineAiTool`.
  </PropertiesListItem>
</PropertiesList>

## Room

### RoomProvider

Makes a [`Room`][] available in the component hierarchy below. Joins the room
when the component is mounted, and automatically leaves the room when the
component is unmounted. When using
[Sync Datastore](/docs/platform/sync-datastore), initial Presence values for
each user, and Storage values for the room can be set.

```tsx
import { RoomProvider } from "@liveblocks/react/suspense";

function App() {
  return <RoomProvider id="my-room-id">{/* children */}</RoomProvider>;
}
```

<PropertiesList title="Props">
  <PropertiesListItem name="id" type="string" required>
    The unique ID for the current room. `RoomProvider` will join this room when
    it loads. If the room doesnâ€™t exist already it will automatically create the
    room first then join. After setting up
    [authentication](/docs/authentication) for your app, it can helpful to
    decide on a naming pattern for your room IDs.
  </PropertiesListItem>
  <PropertiesListItem name="initialPresence" type="JsonObject">
    The initial Presence of the user entering the room. Each user has their own
    presence, and this is readable for all other connected users. A userâ€™s
    Presence resets every time they disconnect. This object must be
    JSON-serializable. This value is ignored after the first render. [Learn
    more](#setting-initial-presence).
  </PropertiesListItem>
  <PropertiesListItem name="initialStorage" type="LsonObject">
    The initial Storage structure for the room when itâ€™s joined for the first
    time. This is only set a single time, when the room has not yet been
    populated. This object must contain [conflict-free live
    structures](/docs/api-reference/liveblocks-client#Storage). This value is
    ignored after the first render, and if Storage for the current room has
    already been created. [Learn more](#setting-initial-storage).
  </PropertiesListItem>
  <PropertiesListItem name="autoConnect" type="boolean" defaultValue="true">
    Whether the room immediately connects to Liveblocks servers. This value is
    ignored after the first render.
  </PropertiesListItem>
</PropertiesList>

#### Setting initial Presence [#setting-initial-presence]

Presence is used for storing temporary user-based values, such as a userâ€™s
cursor coordinates, or their current selection. Each user has their own
presence, and this is readable for all other connected users. Set your initial
Presence value by using `initialPresence`.

```tsx
import { RoomProvider } from "@liveblocks/react/suspense";

function App() {
  return (
    <RoomProvider
      id="my-room"
      // +++
      initialPresence={{
        cursor: null,
        colors: ["red", "purple"],
        selection: {
          id: 72426,
        },
      }}
      // +++
    >
      {/* children */}
    </RoomProvider>
  );
}
```

Each userâ€™s Presence resets every time they disconnect, as this is only meant
for temporary data. Any JSON-serializable object is allowed (the `JsonObject`
type).

#### Setting initial Storage [#setting-initial-storage]

Storage is used to store permanent data thatâ€™s used in your application, such as
shapes on a whiteboard, nodes on a flowchart, or text in a form. The first time
a room is entered, you can set an initial value by using `initialStorage`.
`initialStorage` is only read and set a single time, unless a new top-level
property is added.

```tsx
import { LiveList, LiveObject, LiveMap } from "@liveblocks/client";
import { RoomProvider } from "@liveblocks/react/suspense";

function App() {
  return (
    <RoomProvider
      id="my-room"
      initialPresence={}
      // +++
      initialStorage={{
        title: "Untitled",
        names: new LiveList(["Steven", "Guillaume"]),
        shapes: new LiveMap([
          ["g9shu0", new LiveObject({ type: "rectangle", color: "red" })],
          ["djs3g5", new LiveObject({ type: "circle", color: "yellow" })],
        ]),
      }}
      // +++
    >
      {/* children */}
    </RoomProvider>
  );
}
```

If a new top-level property is added to `initialStorage`, the next time a user
connects, the new property will be created. Other properties will be unaffected.
Any
[conflict-free live structures](/docs/api-reference/liveblocks-client#Storage)
and JSON-serializable objects are allowed (the `LsonObject` type).

#### Speed up connecting to a room [#speed-up-connecting-to-a-room]

To speed up connecting to a room, you can call
[`Liveblocks.prewarmRoom`](/docs/api-reference/liveblocks-node#get-rooms-roomId-prewarm)
on the server, which will warm up a room for the next 10 seconds. Triggering
this directly before a user navigates to a room is an easy to way use this API.
Hereâ€™s a Next.js server actions example, showing how to trigger prewarming with
`onPointerDown`.

```ts title="actions.ts"
"use server";

import { Liveblocks } from "@liveblocks/node";

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

export async function prewarmRoom(roomId: string) {
  // +++
  await liveblocks.prewarmRoom(roomId);
  // +++
}
```

```tsx title="RoomLink.tsx"
"use client";

import { prewarmRoom } from "../actions";
import Link from "next/link";

export function JoinButton({ roomId }: { roomId: string }) {
  return (
    // +++
    <Link href={`/rooms/${roomId}`} onPointerDown={() => prewarmRoom(roomId)}>
      // +++
      {roomId}
    </Link>
  );
}
```

`onPointerDown` is slightly quicker than `onClick` because it triggers before
the user releases their pointer.

### createRoomContext

<Banner>

This used to be the default way to start your app, but now itâ€™s recommend for
advanced usage only. We generally recommend using [`LiveblocksProvider`][] and
following [typing your data with the Liveblocks interface](#Typing-your-data),
unless you need to define multiple room types in your application.

</Banner>

Creates a [`RoomProvider`][] and a set of typed hooks to use in your app. Note
that any `RoomProvider` created in this way does not need to be nested in
[`LiveblocksProvider`][], as it already has access to the `client`. We generally
recommend typing your app using the newer method instead. When using
`createRoomContext` it can be helpful to use it in `liveblocks.config.ts` and
re-export your typed hooks as below.

```tsx file="liveblocks.config.ts"
import { createClient } from "@liveblocks/client";
import { createRoomContext } from "@liveblocks/react";

const client = createClient({
  // publicApiKey: "",
  // authEndpoint: "/api/liveblocks-auth",
});

type Presence = {};
type Storage = {};
type UserMeta = {};
type RoomEvent = {};
type ThreadMetadata = {};
type CommentMetadata = {};

// +++
export const {
  RoomProvider,
  useMyPresence,

  // Other hooks
  // ...
} = createRoomContext<
  Presence,
  Storage,
  UserMeta,
  RoomEvent,
  ThreadMetadata,
  CommentMetadata
>(client);
// +++
```

#### Suspense with createRoomContext [#createRoomContext-Suspense]

To use the React suspense version of our hooks with `createRoomContext`, you can
export from the `suspense` property instead.

```tsx file="liveblocks.config.ts"
import { createClient } from "@liveblocks/client";
import { createRoomContext } from "@liveblocks/react";

const client = createClient({
  // publicApiKey: "",
  // authEndpoint: "/api/liveblocks-auth",
});

type Presence = {};
type Storage = {};
type UserMeta = {};
type RoomEvent = {};
type ThreadMetadata = {};
type CommentMetadata = {};

export const {
  // +++
  suspense: {
    RoomProvider,
    useMyPresence,

    // Other suspense hooks
    // ...
  },
  // +++
} = createRoomContext<
  Presence,
  Storage,
  UserMeta,
  RoomEvent,
  ThreadMetadata,
  CommentMetadata
>(client);
```

#### Typing createRoomContext

To type your hooks, you can pass multiple different types to
`createRoomContext`. A full explanation is in the code snippet below.

```tsx file="liveblocks.config.ts" isCollapsable isCollapsed
import { createClient } from "@liveblocks/client";
import { createRoomContext } from "@liveblocks/react";

const client = createClient({
  // publicApiKey: "",
  // authEndpoint: "/api/liveblocks-auth",
});

// Presence represents the properties that exist on every user in the Room
// and that will automatically be kept in sync. Accessible through the
// `user.presence` property. Must be JSON-serializable.
type Presence = {
  // cursor: { x: number, y: number } | null,
  // ...
};

// Optionally, Storage represents the shared document that persists in the
// Room, even after all users leave. Fields under Storage typically are
// LiveList, LiveMap, LiveObject instances, for which updates are
// automatically persisted and synced to all connected clients.
type Storage = {
  // animals: LiveList<string>,
  // ...
};

// Optionally, UserMeta represents static/readonly metadata on each user, as
// provided by your own custom auth back end (if used). Useful for data that
// will not change during a session, like a userâ€™s name or avatar.
// type UserMeta = {
//   id?: string,  // Accessible through `user.id`
//   info?: Json,  // Accessible through `user.info`
// };

// Optionally, the type of custom events broadcast and listened to in this
// room. Use a union for multiple events. Must be JSON-serializable.
// type RoomEvent = {};

// Optionally, when using Comments, ThreadMetadata represents metadata on
// each thread. Can only contain booleans, strings, and numbers.
// export type ThreadMetadata = {
//   pinned: boolean;
//   quote: string;
//   time: number;
// };

export const {
  RoomProvider,
  useMyPresence,
  useStorage,

  // Other hooks
  // ...
} = createRoomContext<
  Presence,
  Storage
  /* UserMeta, RoomEvent, ThreadMetadata */
>(client);
```

### useRoom [@badge=RoomProvider]

Returns the [`Room`][] of the nearest [`RoomProvider`][] above in the React
component tree.

```ts
import { useRoom } from "@liveblocks/react/suspense";

const room = useRoom();
```

Will throw when used outside of a [`RoomProvider`][]. If you donâ€™t want this
hook to throw when used outside of a Room context (for example to write
components in a way that they can be used both inside and outside of a
Liveblocks room), you can use the `{ allowOutsideRoom }` option:

```ts
import { useRoom } from "@liveblocks/react/suspense";

const room = useRoom({ allowOutsideRoom: true }); // Possibly `null`
```

<PropertiesList title="Options">
  <PropertiesListItem
    name="allowOutsideRoom"
    type="boolean"
    defaultValue="false"
  >
    Whether the hook should return `null` instead of throwing when used outside
    of a [`RoomProvider`][] context.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Returns">
  <PropertiesListItem name="room" type="Room">
    The Room instance from the nearest [`RoomProvider`][]. Returns `null` if
    `allowOutsideRoom` is `true` and the hook is used outside of a room.
  </PropertiesListItem>
</PropertiesList>

### useIsInsideRoom [@badge=Both]

Returns a boolean, `true` if the hook was called inside a [`RoomProvider`][]
context, and `false` otherwise.

```ts
import { useIsInsideRoom } from "@liveblocks/react/suspense";

const isInsideRoom = useIsInsideRoom();
```

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

<PropertiesList title="Returns">
  <PropertiesListItem name="isInsideRoom" type="boolean">
    `true` if the hook was called inside a [`RoomProvider`][] context, `false`
    otherwise.
  </PropertiesListItem>
</PropertiesList>

#### Displaying different components inside rooms

`useIsInsideRoom` is helpful for rendering different components depending on
whether theyâ€™re inside a room, or not. One example is a header component that
only displays a live avatar stack when users are connected to the room.

```tsx
import { useIsInsideRoom, useOthers } from "@liveblocks/react/suspense";

function Header() {
  // +++
  const isInsideRoom = useIsInsideRoom();
  // +++

  return (
    <div>
      // +++
      {isInsideRoom ? <LiveAvatars /> : null}
      // +++
      <MyAvatar />
    </div>
  );
}

function LiveAvatars() {
  const others = useOthers();
  return others.map((other) => <img src={other.info.picture} />);
}
```

Hereâ€™s how the example above would render in three different
[`LiveblocksProvider`](/docs/api-reference/liveblocks-react#LiveblocksProvider)
and [`RoomProvider`](/docs/api-reference/liveblocks-react#RoomProvider)
contexts.

```tsx
// ðŸ‘¥ðŸ‘¤ Live avatar stack and your avatar
<LiveblocksProvider /* ... */>
  <RoomProvider /* ... */>
    <Header />
  </RoomProvider>
</LiveblocksProvider>


// ðŸ‘¤ Just your avatar
<LiveblocksProvider /* ... */>
  <Header />
</LiveblocksProvider>

// ðŸ‘¤ Just your avatar
<Header />
```

### useStatus [@badge=RoomProvider]

Returns the current WebSocket connection status of the room, and will re-render
your component whenever it changes.

```ts
import { useStatus } from "@liveblocks/react/suspense";

const status = useStatus();
```

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

<PropertiesList title="Returns">
  <PropertiesListItem
    name="status"
    type="'initial' | 'connecting' | 'connected' | 'reconnecting' | 'disconnected'"
  >
    The current WebSocket connection status of the room.
  </PropertiesListItem>
</PropertiesList>

### useSyncStatus [@badge=Both]

Returns the current synchronization status of Liveblocks, and will re-render
your component whenever it changes. This includes any part of Liveblocks that
may be synchronizing local changes to the server, including (any roomâ€™s)
Storage, text editors, threads, or notifications.

A `{ smooth: true }` option is also available, which prevents quick changes
between states, making it ideal for
[rendering a synchronization badge in your app](#display-synchronization-badge).
[Suspense](/docs/api-reference/liveblocks-react#Suspense-hooks) and
[regular](/docs/api-reference/liveblocks-react#Regular-hooks) versions of this
hook are available.

```ts
import { useSyncStatus } from "@liveblocks/react/suspense";

// "synchronizing" | "synchronized"
const syncStatus = useSyncStatus();
```

<PropertiesList title="Arguments">
  <PropertiesListItem name="options" type="object">
    Optional configuration object.
  </PropertiesListItem>
  <PropertiesListItem name="options.smooth" type="boolean" defaultValue="false">
    When `true`, prevents quick changes between states by delaying the
    transition from "synchronizing" to "synchronized" until 1 second has passed
    after the final change.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Returns">
  <PropertiesListItem name="syncStatus" type="'synchronizing' | 'synchronized'">
    The current synchronization status of Liveblocks.
  </PropertiesListItem>
</PropertiesList>

#### Display a synchronization badge [#display-synchronization-badge]

Passing `{ smooth: true }` prevents the status changing from `"synchronizing"`
to `"synchronized"` until 1 second has passed after the final change. This means
itâ€™s ideal for rendering a synchronization status badge, as it wonâ€™t flicker in
a distracting manner when changes are made in quick succession.

```tsx
import { useSyncStatus } from "@liveblocks/react/suspense";

function StorageStatusBadge() {
  const syncStatus = useSyncStatus({ smooth: true });

  return <div>{syncStatus === "synchronized" ? "âœ… Saved" : "ðŸ”„ Saving"}</div>;
}
```

#### Prevent users losing unsaved changes [#use-sync-status-prevent-users-losing-unsaved-changes]

Liveblocks usually synchronizes milliseconds after a local change, but if a user
immediately closes their tab, or if they have a slow connection, it may take
longer for changes to synchronize. Enabling `preventUnsavedChanges` will stop
tabs with unsaved changes closing, by opening a dialog that warns users. In
usual circumstances, it will very rarely trigger.

```tsx
function Page() {
  return (
    <LiveblocksProvider
      // highlight-next-line
      preventUnsavedChanges

      // Other options
      // ...
    >
      ...
    </LiveblocksProvider>
  );
}
```

More specifically, this option triggers when:

- There are unsaved changes after calling any hooks or methods, in all of our
  products.
- There are unsaved changes in a
  [Text Editor](/docs/ready-made-features/text-editor).
- Thereâ€™s an unsubmitted comment in the
  [Composer](/docs/api-reference/liveblocks-react-ui#Composer).
- The user has made changes and is currently offline.

Internally, this option uses the
[beforeunload event](https://developer.mozilla.org/en-US/docs/Web/API/Window/beforeunload_event).

### useOthersListener [@badge=RoomProvider]

Calls the given callback when an â€œothersâ€ event occurs, when a user enters,
leaves, or updates their presence.

```ts
function App() {
  useOthersListener(({ type, user, others }) => {
    switch (type) {
      case "enter":
        // `user` has entered the room
        break;

      case "leave":
        // `user` has left the room
        break;

      case "update":
        // Presence for `user` has updated
        break;

      case "reset":
        // Others list has been emptied
        break;
    }
  });
}
```

<PropertiesList title="Arguments">
  <PropertiesListItem name="callback" type="(event: OthersEvent) => void">
    A callback function that is called when an "others" event occurs. The event
    object contains the error `type`,  the `user` that triggered it, and the current
    `others` in the room. Possible event types are:

      - `enter` â€“ A user has entered the room.
      - `leave` â€“ A user has left the room.
      - `reset` â€“ The others list has been emptied. This is the first event that
        occurs when the room is entered. It also occurs when youâ€™ve lost connection to
        the room.
      - `update` â€“ A userâ€™s presence data has been updated.

    </PropertiesListItem>

</PropertiesList>

### useLostConnectionListener [@badge=RoomProvider]

Calls the given callback in the exceptional situation that a connection is lost
and reconnecting does not happen quickly enough.

This event allows you to build high-quality UIs by warning your users that the
app is still trying to re-establish the connection, for example through a toast
notification. You may want to take extra care in the mean time to ensure their
changes wonâ€™t go unsaved.

When this happens, this callback is called with the event `lost`. Then, once the
connection restores, the callback will be called with the value `restored`. If
the connection could definitively not be restored, it will be called with
`failed` (uncommon).

The [`lostConnectionTimeout`][] client option will determine how quickly this
event will fire after a connection loss (default: 5 seconds).

```ts
import { toast } from "my-preferred-toast-library";

function App() {
  useLostConnectionListener((event) => {
    switch (event) {
      case "lost":
        toast.warn("Still trying to reconnect...");
        break;

      case "restored":
        toast.success("Successfully reconnected again!");
        break;

      case "failed":
        toast.error("Could not restore the connection");
        break;
    }
  });
}
```

Automatically unsubscribes when the component is unmounted. For a demonstration
of this behavior, see our [connection status example][].

<PropertiesList title="Arguments">
  <PropertiesListItem
    name="callback"
    type="(event: 'lost' | 'restored' | 'failed') => void"
  >
    A callback function that is called when a connection loss event occurs. The
    event can be "lost", "restored", or "failed".
  </PropertiesListItem>
</PropertiesList>

## Presence

<Banner title="Need help troubleshooting presence?">

Try the [Liveblocks DevTools extension](/devtools) to visualize your
collaborative experiences as you build them, in realtime.

</Banner>

### useMyPresence [@badge=RoomProvider]

Return the presence of the current user, and a function to update it.
Automatically subscribes to updates to the current userâ€™s presence. Setting a
property will not replace the whole state, but will instead merge the property
into the existing state.

```ts
import { useMyPresence } from "@liveblocks/react/suspense";

const [myPresence, updateMyPresence] = useMyPresence();

updateMyPresence({ x: 0 });
updateMyPresence({ y: 0 });

// At the next render, "myPresence" will be equal to "{ x: 0, y: 0 }"
```

<PropertiesList title="Returns">
  <PropertiesListItem name="myPresence" type="TPresence">
    The current userâ€™s presence data.
  </PropertiesListItem>
  <PropertiesListItem
    name="updateMyPresence"
    type="(patch: Partial<Presence>, options?: { addToHistory?: boolean }) => void"
  >
    A function to update the current userâ€™s presence. Accepts a partial presence
    object and optional history options.
  </PropertiesListItem>
</PropertiesList>

#### Adding presence to history

`updateMyPresence` accepts an optional argument to add a new item to the
undo/redo stack. See [`room.history`][] for more information.

```ts
updateMyPresence({ selectedId: "xxx" }, { addToHistory: true });
```

#### Other ways to use presence

`useMyPresence` is a more convenient way to update and view presence, rather
than using [`useSelf`][] and [`useUpdateMyPresence`][] in combination.

```tsx
const myPresence = useSelf((me) => me.presence);
const updateMyPresence = useUpdateMyPresence();
```

### useUpdateMyPresence [@badge=RoomProvider]

Returns a setter function to update the current userâ€™s presence. Setting a
property will not replace the whole state, but will instead merge the property
into the existing state. Will trigger fewer renders than [`useMyPresence`][], as
it doesnâ€™t update when presence changes.

```ts
import { useUpdateMyPresence } from "@liveblocks/react/suspense";

const updateMyPresence = useUpdateMyPresence();

updateMyPresence({ y: 0 });
updateMyPresence({ x: 0 });

// Presence will be { x: 0, y: 0 }
```

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

<PropertiesList title="Returns">
  <PropertiesListItem
    name="updateMyPresence"
    type="(patch: Partial<Presence>, options?: { addToHistory?: boolean }) => void"
  >
    A function to update the current user's presence. Accepts a partial presence
    object and optional history options.
  </PropertiesListItem>
</PropertiesList>

#### Adding presence to history

`updateMyPresence` accepts an optional argument to add a new item to the
undo/redo stack. See [`room.history`][] for more information.

```ts
updateMyPresence({ selectedId: "xxx" }, { addToHistory: true });
```

### useSelf [@badge=RoomProvider]

Returns the current user once it is connected to the room, and automatically
subscribes to updates to the current user.
[Suspense](/docs/api-reference/liveblocks-react#Suspense-hooks) and
[regular](/docs/api-reference/liveblocks-react#Regular-hooks) versions of this
hook are available.

```ts
import { useSelf } from "@liveblocks/react/suspense";

const currentUser = useSelf();
// {
//   connectionId: 1,
//   presence: { cursor: { x: 27, y: -8 } },
// }

const currentUser = useSelf((me) => me.presence.cursor);
// { x: 27, y: -8 }
```

The benefit of using a selector is that it will only update your component if
that particular selection changes. For full details, see [how selectors work][].

<PropertiesList title="Arguments">
  <PropertiesListItem name="selector" type="(me: User) => T">
    Optional selector function to extract specific data from the current user.
    If not provided, returns the entire user object.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Returns">
  <PropertiesListItem name="currentUser" type="User | T | null">
    The current user object or the selected data from the user. Returns `null`
    if not connected to the room (in non-Suspense version).
  </PropertiesListItem>
</PropertiesList>

#### Checking user permissions

Itâ€™s possible to check if a user has a specific permission by using the
`canWrite` and `canComment` properties of the `User` object. This is set via
your [room permissions](/docs/authentication#Room-permissions).

```ts
import { useSelf } from "@liveblocks/react/suspense";

function PermissionBadge() {
  const canWrite = useSelf((me) => me.canWrite);

  if (canWrite) {
    return <div>âœï¸ Full access</div>;
  }

  return <div>ðŸ‘€ Read-only access</div>;
}
```

This is particularly helpful in combination with text editors, such as
[Tiptap](/docs/api-reference/liveblocks-react-tiptap) as you can prevent
read-only users from editing the document.

```tsx
import { useSelf } from "@liveblocks/react/suspense";
import { useLiveblocksExtension } from "@liveblocks/react-tiptap";
import { useEditor, EditorContent } from "@tiptap/react";

function TextEditor() {
  const liveblocks = useLiveblocksExtension();
  // +++
  const canWrite = useSelf((me) => me.canWrite);
  // +++

  const editor = useEditor({
    // +++
    editable: canWrite,
    // +++
    extensions: [
      liveblocks,
      // ...
    ],
  });

  return (
    <div>
      <EditorContent editor={editor} />
    </div>
  );
}
```

### useOthers [@badge=RoomProvider]

Extracts data from the list of other users currently in the same Room, and
automatically subscribes to updates on the selected data. For full details, see
[how selectors work][].
[Suspense](/docs/api-reference/liveblocks-react#Suspense-hooks) and
[regular](/docs/api-reference/liveblocks-react#Regular-hooks) versions of this
hook are available.

The `others` argument to the `useOthers` selector function is an _immutable_
array of Users.

```tsx
// âœ… Rerenders only if the number of users changes
const numOthers = useOthers((others) => others.length);

// âœ… Rerenders only if someone starts or stops typing
const isSomeoneTyping = useOthers((others) =>
  others.some((other) => other.presence.isTyping)
);

// âœ… Rerenders only if actively typing users are updated
const typingUsers = useOthers(
  (others) => others.filter((other) => other.presence.isTyping),
  shallow // ðŸ‘ˆ
);
```

One caveat with this API is that selecting a subset of data for each user
quickly becomes tricky. When you want to select and get updates for only a
particular subset of each userâ€™s data, we recommend using the
[`useOthersMapped`][] hook instead, which is optimized for this use case.

```tsx
// âŒ Mapping is hard to get right with this hook
const cursors = useOthers(
  (others) => others.map((other) => other.presence.cursor),
  shallow
);

// âœ… Better to use useOthersMapped
const cursors = useOthersMapped((other) => other.presence.cursor);
```

When called without arguments, returns the user list and updates your component
whenever _anything_ in it changes. This might be way more often than you want!

```tsx
const others = useOthers(); // âš ï¸ Caution, might rerender often!
// [
//   { connectionId: 2, presence: { cursor: { x: 27, y: -8 } } },
//   { connectionId: 3, presence: { cursor: { x: 0, y: 19 } } },
// ]
```

<Banner type="error" title="Caution">

In production-ready apps, you likely want to avoid calling `useOthers` without
arguments.

</Banner>

<PropertiesList title="Arguments">
  <PropertiesListItem name="selector" type="(others: readonly User[]) => T">
    Optional selector function to extract specific data from the others array.
    If not provided, returns the entire others array.
  </PropertiesListItem>
  <PropertiesListItem name="isEqual" type="(prev: T, curr: T) => boolean">
    Optional equality function to determine if the selected data has changed.
    Defaults to strict equality comparison.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Returns">
  <PropertiesListItem name="others" type="readonly TUser[] | null">
    The others array or the selected data from the others array. Returns `null`
    if not connected to the room (in non-Suspense version).
  </PropertiesListItem>
</PropertiesList>

### useOthersMapped [@badge=RoomProvider]

Extract data using a [selector][] for every user in the room, and subscribe to
all changes to the selected data. A [Suspense version][] of this hook is also
available. The key difference with [`useOthers`][] is that the selector (and the
optional comparison function) work at the _item_ level, like doing a `.map()`
over the others array.

```tsx
// Example 1
const others = useOthersMapped((other) => other.presence.cursor);
// [
//   [2, { x: 27, y: -8 }],
//   [3, { x: 0, y: 19 }],
// ]

// Example 2
const others = useOthersMapped(
  (other) => ({
    avatar: other.info.avatar,
    isTyping: other.presence.isTyping,
  }),
  shallow // ðŸ‘ˆ
);

// [
//   [2, { avatar: 'https://...', isTyping: true }],
//   [3, { avatar: null, isTyping: false }],
// ]
```

Returns an array where each item is a pair of `[connectionId, data]`. For
pragmatic reasons, the results are keyed by the `connectionId`, because in most
cases youâ€™ll want to iterate over the results and draw some UI for each, which
in React requires you to use a `key={connectionId}` prop.

```tsx
const others = useOthersMapped((other) => other.presence.cursor);

// In JSX
return (
  <>
    {others.map(([connectionId, cursor]) => (
      <Cursor key={connectionId} x={cursor.x} y={cursor.y} />
    ))}
  </>
);
```

<PropertiesList title="Arguments">
  <PropertiesListItem name="selector" type="(other: User) => T">
    A selector function to extract specific data from each user in the others
    array.
  </PropertiesListItem>
  <PropertiesListItem name="isEqual" type="(prev: T, curr: T) => boolean">
    Optional equality function to determine if the selected data for a user has
    changed. Defaults to strict equality comparison.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Returns">
  <PropertiesListItem
    name="others"
    type="readonly [connectionId: number, data: T][] | null"
  >
    An array of tuples where each item is a pair of `[connectionId,
    selectedData]`. Returns `null` if not connected to the room (in non-Suspense
    version).
  </PropertiesListItem>
</PropertiesList>

### useOthersConnectionIds [@badge=RoomProvider]

Returns an array of connection IDs (numbers), and rerenders automatically when
users join or leave. This hook is useful in particular in combination with the
[`useOther`][] (singular) hook, to implement high-frequency rerendering of
components for each user in the room, e.g. cursors. See the [`useOther`][]
(singular) documentation below for a full usage example.
[Suspense](/docs/api-reference/liveblocks-react#Suspense-hooks) and
[regular](/docs/api-reference/liveblocks-react#Regular-hooks) versions of this
hook are available.

```tsx
import { useOthersConnectionIds } from "@liveblocks/react/suspense";

// [2, 4, 7]
const connectionIds = useOthersConnectionIds();
```

<PropertiesList title="Returns">
  <PropertiesListItem name="connectionIds" type="readonly number[] | null">
    An array of connection IDs for all other users in the room. Returns `null`
    if not connected to the room (in non-Suspense version).
  </PropertiesListItem>
</PropertiesList>

#### Another way to fetch connection IDs

This hook is similar to using [`useOthers`][] and calling `.map()` on the
result.

```tsx
import { useOthers, shallow } from "@liveblocks/react/suspense";

// [2, 4, 7]
const connectionIds = useOthers(
  (others) => others.map((other) => other.connectionId),
  shallow
);
```

### useOther [@badge=RoomProvider]

Extract data using a [selector][] for one specific user in the room, and
subscribe to all changes to the selected data.
[Suspense](/docs/api-reference/liveblocks-react#Suspense-hooks) and
[regular](/docs/api-reference/liveblocks-react#Regular-hooks) versions of this
hook are available.

```tsx
import { useOther } from "@liveblocks/react/suspense";

// âœ… Rerenders when this specific userâ€™s isTyping changes (but not when their cursor changes)
const isTyping = useOther(
  3, // User with connectionId 3
  (user) => user.presence.isTyping
);
```

The reason this hook exists is to enable the most efficient rerendering model
for high-frequency updates to otherâ€™s presences, which is the following
structure:

```tsx file="Cursors.tsx"
const Cursors =
  // +++
  // (1) Wrap parent component in a memo and make sure it takes no props
  React.memo(function () {
    const othersConnectionIds = useOthersConnectionIds(); // (2)
    // +++
    return (
      <>
        {othersConnectionIds.map((connectionId) => (
          <Cursor
            // +++
            key={connectionId} // (3)
            // +++
            connectionId={connectionId}
          />
        ))}
      </>
    );
  });
```

```tsx file="Cursor.tsx"
function Cursor({ connectionId }) {
  // +++
  const { x, y } = useOther(connectionId, (other) => other.presence.cursor); // (4)
  // +++
  return <Cursor x={x} y={y} />;
}
```

1. Makes sure this whole component tree will never rerender beyond the first
   time.
2. Makes sure the parent component only rerenders when users join/leave.
3. Makes sure each cursor remains associated to the same connection.
4. Makes sure each cursor rerenders whenever _its_ data changes only.

ðŸ‘‰ A [Suspense version][] of this hook is also available, which will never
return `null`.

<PropertiesList title="Arguments">
  <PropertiesListItem name="connectionId" type="number">
    The connection ID of the specific user to extract data from.
  </PropertiesListItem>
  <PropertiesListItem name="selector" type="(other: User) => T">
    A selector function to extract specific data from the user.
  </PropertiesListItem>
  <PropertiesListItem name="isEqual" type="(prev: T, curr: T) => boolean">
    Optional equality function to determine if the selected data has changed.
    Defaults to strict equality comparison.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Returns">
  <PropertiesListItem name="data" type="T | null">
    The selected data from the specified user. Returns `null` if the user is not
    found or not connected to the room (in non-Suspense version).
  </PropertiesListItem>
</PropertiesList>

## Broadcast

### useBroadcastEvent [@badge=RoomProvider]

Returns a callback that lets you broadcast custom events to other users in the
room.

```ts
import { useBroadcastEvent } from "@liveblocks/react/suspense";

// +++
// On client A
const broadcast = useBroadcastEvent();
broadcast({ type: "EMOJI", emoji: "ðŸ”¥" });
// +++

// On client B
useEventListener(({ event, user, connectionId }) => {
  //                       ^^^^ Will be Client A
  if (event.type === "EMOJI") {
    // Do something
  }
});
```

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

<PropertiesList title="Returns">
  <PropertiesListItem name="broadcast" type="(event: TBroadcastEvent) => void">
    A function that broadcasts custom events to other users in the room.
  </PropertiesListItem>
</PropertiesList>

### useEventListener [@badge=RoomProvider]

Listen to custom events sent by other people in the room via
[`useBroadcastEvent`][]. Provides the `event` along with the `connectionId` of
the user that sent the message. If an event was sent from the
[Broadcast to a room](/docs/api-reference/rest-api-endpoints#post-broadcast-event)
REST API, `connectionId` will be `-1`.

```ts
import { useEventListener } from "@liveblocks/react/suspense";

// On client A
const broadcast = useBroadcastEvent();
broadcast({ type: "EMOJI", emoji: "ðŸ”¥" });

// +++
// On client B
useEventListener(({ event, user, connectionId }) => {
  //                       ^^^^ Will be Client A
  if (event.type === "EMOJI") {
    // Do something
  }
});
// +++
```

The `user` property will indicate which User instance sent the message. This
will typically be equal to one of the others in the room, but it can also be
`null` in case this event was broadcasted from the server, using the
[Broadcast Event API](https://liveblocks.io/docs/api-reference/rest-api-endpoints#post-broadcast-event).

Automatically unsubscribes when the component is unmounted.

<PropertiesList title="Arguments">
  <PropertiesListItem
    name="callback"
    type="(event: { event: TBroadcastEvent; user: User | null; connectionId: number }) => void"
  >
    A callback function that is called when a custom event is received. The
    callback receives an object with the event data, user information, and
    connection ID. Connection ID is always `-1` when receiving an event sent
    from the server.
  </PropertiesListItem>
</PropertiesList>

## Storage

Each room contains Storage, a conflict-free data store that multiple users can
edit at the same time. When users make edits simultaneously, conflicts are
resolved automatically, and each user will see the same state. Storage is ideal
for storing permanent document state, such as shapes on a canvas, notes on a
whiteboard, or cells in a spreadsheet.

### Data structures

Storage provides three different conflict-free data structures, which you can
use to build your application. All structures are permanent and persist when all
users have left the room, unlike [Presence](/docs/ready-made-features/presence)
which is temporary.

- [`LiveObject`][] - Similar to JavaScript object. Use this for storing records
  with fixed key names and where the values donâ€™t necessarily have the same
  types. For example, a `Person` with a `name: string` and an `age: number`
  field. If multiple clients update the same property simultaneously, the last
  modification received by the Liveblocks servers is the winner.

- [`LiveList`][] - An ordered collection of items synchronized across clients.
  Even if multiple users add/remove/move elements simultaneously, LiveList will
  solve the conflicts to ensure everyone sees the same collection of items.

- [`LiveMap`][] - Similar to a JavaScript Map. Use this for indexing values that
  all have the same structure. For example, to store an index of `Person` values
  by their name. If multiple users update the same property simultaneously, the
  last modification received by the Liveblocks servers is the winner.

### Typing Storage [#typing-storage]

To type the Storage values you receive, make sure to set your `Storage` type.

```ts
import { LiveList } from "@liveblocks/client";

declare global {
  interface Liveblocks {
    Storage: {
      animals: LiveList<string>;
    };
  }
}
```

You can then set an initial value in [`RoomProvider`][].

```tsx
import { LiveList } from "@liveblocks/client";
import { RoomProvider } from "@liveblocks/react/suspense";

function App() {
  return (
    <RoomProvider
      id="my-room-name"
      // +++
      initialStorage={{ animals: new LiveList(["Fido"]) }}
      // +++
    >
      {/* children */}
    </RoomProvider>
  );
}
```

The type received in your Storage will match the type passed. Learn more under
[typing your data](#typing-your-data).

```tsx
import { useMutation } from "@liveblocks/react/suspense";

function App() {
  const addAnimal = useMutation(({ storage }) => {
    const animals = storage.get("animals");

    // LiveList<["Fido"]>
    console.log(animals);

    animals.push("Felix");

    // LiveList<["Fido", "Felix"]>
    console.log(animals);
  });

  return <button onClick={addAnimal}>Add animal</button>;
}
```

[`useStorage`][] will return an immutable copy of the data, for example a
`LiveList` is converted to an `array`, which makes it easy to render.

```tsx
import { useStorage } from "@liveblocks/react/suspense";

function App() {
  const animals = useStorage((root) => root.animals);

  // ["Fido", "Felix"]
  console.log(animals);

  return (
    <ul>
      {animals.map((animal) => (
        <li key={animal}>{animal}</li>
      ))}
    </ul>
  );
}
```

### Nesting data structures

All Storage data structures can be nested, allowing you to create complex trees
of conflict-free data.

```ts
import { LiveObject, LiveList, LiveMap } from "@liveblocks/client";

type Person = LiveObject<{
  name: string;
  pets: LiveList<string>;
}>;

declare global {
  interface Liveblocks {
    Storage: {
      people: LiveMap<string, Person>;
    };
  }
}
```

Hereâ€™s an example of setting `initialStorage` for this type.

```tsx
import { LiveObject, LiveList, LiveMap } from "@liveblocks/client";
import { RoomProvider } from "@liveblocks/react/suspense";

function App() {
  return (
    <RoomProvider
      id="my-room-name"
      initialStorage={{
        // +++
        people: new LiveMap([
          [
            "alicia",
            new LiveObject({
              name: "Alicia",
              pets: new LiveList(["Fido", "Felix"]),
            }),
          ],
        ]),
        // +++
      }}
    >
      {/* children */}
    </RoomProvider>
  );
}
```

<Banner title="Need help troubleshooting Storage?">

Get the [Liveblocks DevTools extension](/devtools) to develop and debug your
application as you build it.

</Banner>

### useStorage [@badge=RoomProvider]

Extracts data from Liveblocks Storage state and automatically subscribes to
updates to that selected data. For full details, see [how selectors work][].

```tsx
// âœ… Rerenders if todos (or their children) change
const items = useStorage((root) => root.todos);

// âœ… Rerenders when todos are added or deleted
const numTodos = useStorage((root) => root.todos.length);

// âœ… Rerenders when the value of allDone changes
const allDone = useStorage((root) => root.todos.every((item) => item.done));

// âœ… Rerenders if any _unchecked_ todo items change
const uncheckedItems = useStorage(
  (root) => root.todos.filter((item) => !item.done),
  shallow // ðŸ‘ˆ
);
```

The `root` argument to the `useStorage` selector function is an _immutable_ copy
of your entire Liveblocks Storage tree. Think of it as the value you provided in
the `initialStorage` prop at the [`RoomProvider`][] level, but then
(recursively) converted to their â€œnormalâ€ JavaScript equivalents (objects,
arrays, maps) that are read-only.

From that immutable `root`, you can select or compute any value you like. Your
component will automatically get rerendered if the value you return differs from
the last rendered value.

This hook returns `null` while storage is still loading. To avoid that, use the
[Suspense version][].

<Banner type="success" title="Avoiding unnecessary rerenders">

Itâ€™s recommended to select only the subset of Storage data that your component
needs. This will avoid unnecessary rerenders that happen with overselection.

In order to select one item from a LiveMap within the storage tree with the
`useStorage` method, you can use the example below:

```ts
const key = "errands";
const myTodos = useStorage((root) => root.todoMap.get(key));
```

In order to query a LiveMap, and filter for specific values:

```ts
const myTodos = useStorage(
  root => Array.from(root.todoMap.values()).filter(...),
  shallow,
);
```

</Banner>

<PropertiesList title="Arguments">
  <PropertiesListItem name="selector" type="(root: ToImmutable<TStorage>) => T">
    A selector function to extract specific data from the storage root. The root
    is an immutable copy of your entire Liveblocks Storage tree.
  </PropertiesListItem>
  <PropertiesListItem name="isEqual" type="(prev: T, curr: T) => boolean">
    Optional equality function to determine if the selected data has changed.
    Defaults to strict equality comparison.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Returns">
  <PropertiesListItem name="data" type="T | null">
    The selected data from storage. Returns `null` while storage is still
    loading (in non-Suspense version).
  </PropertiesListItem>
</PropertiesList>

### useHistory [@badge=RoomProvider]

Returns the roomâ€™s history. See [`Room.history`][] for more information.

```ts
import { useHistory } from "@liveblocks/react/suspense";

const { undo, redo, pause, resume } = useHistory();
```

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

<PropertiesList title="Returns">
  <PropertiesListItem name="history" type="History">
    The room's history object containing methods for undo, redo, pause, and
    resume operations.
  </PropertiesListItem>
</PropertiesList>

### useUndo [@badge=RoomProvider]

Returns a function that undoes the last operation executed by the current
client. It does not impact operations made by other clients.

```ts
import { useUndo } from "@liveblocks/react/suspense";

const undo = useUndo();
```

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

<PropertiesList title="Returns">
  <PropertiesListItem name="undo" type="() => void">
    A function that undoes the last operation executed by the current client.
  </PropertiesListItem>
</PropertiesList>

### useRedo [@badge=RoomProvider]

Returns a function that redoes the last operation executed by the current
client. It does not impact operations made by other clients.

```ts
import { useRedo } from "@liveblocks/react/suspense";

const redo = useRedo();
```

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

<PropertiesList title="Returns">
  <PropertiesListItem name="redo" type="() => void">
    A function that redoes the last operation executed by the current client.
  </PropertiesListItem>
</PropertiesList>

### useCanUndo [@badge=RoomProvider]

Returns whether there are any operations to undo.

```ts
import { useCanUndo, useUpdateMyPresence } from "@liveblocks/react/suspense";

const updateMyPresence = useUpdateMyPresence();
const canUndo = useCanUndo();

updateMyPresence({ y: 0 });

// At the next render, "canUndo" will be true
```

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

<PropertiesList title="Returns">
  <PropertiesListItem name="canUndo" type="boolean">
    Whether there are any operations to undo.
  </PropertiesListItem>
</PropertiesList>

### useCanRedo [@badge=RoomProvider]

Returns whether there are any operations to redo.

```ts
import {
  useCanRedo,
  useUndo,
  useUpdateMyPresence,
} from "@liveblocks/react/suspense";

const updateMyPresence = useUpdateMyPresence();
const undo = useUndo();
const canRedo = useCanRedo();

updateMyPresence({ y: 0 });
undo();

// At the next render, "canRedo" will be true
```

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

<PropertiesList title="Returns">
  <PropertiesListItem name="canRedo" type="boolean">
    Whether there are any operations to redo.
  </PropertiesListItem>
</PropertiesList>

### useMutation [@badge=RoomProvider]

Creates a callback function that lets you mutate Liveblocks state.

```tsx
import { useMutation } from "@liveblocks/react/suspense";

const fillWithRed = useMutation(
  // Mutation context is passed as the first argument
  ({ storage, setMyPresence }) => {
    // Mutate Storage
    storage.get("shapes").get("circle1").set("fill", "red");
    //                                   ^^^

    // ...or Presence
    setMyPresence({ lastUsedColor: "red" });
  },
  []
);

// JSX
return <button onClick={fillWithRed} />;
```

To make the example above more flexible and work with _any_ color, you have two
options:

1. Close over a local variable and
   [adding it to the dependency array](#useMutation-dep-arrays), or
2. Have it take [an extra callback parameter](#useMutation-extra-params).

Both are equally fine, just a matter of preference.

<PropertiesList title="Arguments">
  <PropertiesListItem
    name="mutationFn"
    type="(context: MutationContext, ...args: TArgs) => void"
  >
    A function that performs mutations on Liveblocks state. The context provides
    access to `storage`, `setMyPresence`, `self`, and `others`.
  </PropertiesListItem>
  <PropertiesListItem name="deps" type="React.DependencyList">
    A dependency array that determines when the mutation function should be
    recreated, similar to `useCallback`.
  </PropertiesListItem>
</PropertiesList>

#### With dependency arrays [#useMutation-dep-arrays]

```tsx
// Local state maintained outside Liveblocks
const [currentColor, setCurrentColor] = useState("red");

const fillWithCurrentColor = useMutation(
  ({ storage, setMyPresence }) => {
    storage.get("shapes").get("circle1").set("fill", currentColor);
    setMyPresence({ lastUsedColor: currentColor });
  },
  // +++
  [currentColor] // Works just like it would in useCallback
  // +++
);

// JSX
return <button onClick={fillWithCurrentColor} />;
```

<Banner type="success" title="Tip! Let ESLint check your dependencies">

If you use ESLint, we recommend to
[configure it to enforce](/docs/api-reference/liveblocks-react#useMutation-lint-rule)
the correct use of your dependency arrays.

</Banner>

#### With extra callback parameters [#useMutation-extra-params]

Alternatively, you can add extra parameters to your callback function:

```tsx
const fill = useMutation(
  // +++
  // Note the second argument
  ({ storage, setMyPresence }, color: string) => {
    // +++
    storage.get("shapes").get("circle1").set("fill", color);
    setMyPresence({ lastUsedColor: color });
  },
  []
);

// JSX
// +++
return <button onClick={() => fill("red")} />;
//                            ^^^^^^^^^^^ Now fill takes a color argument
// +++
```

#### Depending on current presence [#useMutation-presence]

For convenience, the mutation context also receives `self` and `others`
arguments, which are _immutable_ values reflecting the current Presence state,
in case your mutation depends on it.

For example, hereâ€™s a mutation that will delete all the shapes selected by the
current user.

```tsx
const deleteSelectedShapes = useMutation(
  // You can use current "self" or "others" state in the mutation
  // +++
  ({ storage, self, others, setMyPresence }) => {
    // +++
    // Delete the selected shapes
    const shapes = storage.get("shapes");
    // +++
    for (const shapeId of self.presence.selectedShapeIds) {
      // +++
      shapes.delete(shapeId);
    }

    // Clear the current selection
    setMyPresence({ selectedShapeIds: [] });
  },
  []
);

// JSX
return <button onClick={deleteSelectedShapes} />;
```

Mutations are automatically batched, so when using `useMutation` thereâ€™s no need
to use `useBatch`, or call `room.batch()` manually.

#### ESLint rule [#useMutation-lint-rule] [@keywords=["exhaustive-deps", "additionalHooks", "eslint-plugin-react-hooks"]]

If you are using ESLint in your project, and are using
[the React hooks plugin](https://reactjs.org/docs/hooks-rules.html#eslint-plugin),
we recommend to add a check for "additional hooks", so that it will also check
the dependency arrays of your `useMutation` calls:

```js
{
  "rules": {
    // ...
    "react-hooks/exhaustive-deps": ["warn", {
      "additionalHooks": "useMutation"
    }]
  }
}
```

<PropertiesList title="Returns">
  <PropertiesListItem name="mutate" type="(...args: TArgs) => void">
    A memoized callback function that executes the mutation. Can accept
    additional arguments that are passed to the mutation function.
  </PropertiesListItem>
</PropertiesList>

## Comments

### useThreads [@badge=RoomProvider]

Returns a paginated list of threads within the current room. Initially fetches
the oldest 50 threads.
[Suspense](/docs/api-reference/liveblocks-react#Suspense-hooks) and
[regular](/docs/api-reference/liveblocks-react#Regular-hooks) versions of this
hook are available.

```tsx
import { useThreads } from "@liveblocks/react";

const { threads, error, isLoading } = useThreads();
```

Use the [`Thread`](/docs/api-reference/liveblocks-react-ui#Thread) component to
render the oldest 50 threads with our default UI.

```tsx
import { Thread } from "@liveblocks/react-ui";
import { useThreads } from "@liveblocks/react/suspense";

function Component() {
  // +++
  const { threads } = useThreads();
  // +++

  return (
    <div>
      // +++
      {threads.map((thread) => (
        <Thread key={thread.id} thread={thread} />
      ))}
      // +++
    </div>
  );
}
```

<PropertiesList title="Arguments">
  <PropertiesListItem name="options" type="object">
    Optional configuration object.
  </PropertiesListItem>
  <PropertiesListItem name="option.query" type="ThreadsQuery">
    Optional query to filter threads by resolved status and metadata values.
    [Learn more](/docs/api-reference/liveblocks-react#useThreads-query).
  </PropertiesListItem>
  <PropertiesListItem name="option.scrollOnLoad" type="boolean">
    Whether to scroll to a comment if the URL's hash is set to a comment ID.
    Defaults to `true`. [Learn
    more](/docs/api-reference/liveblocks-react#useThreads-scroll).
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Returns">
  <PropertiesListItem name="threads" type="ThreadData[] | undefined">
    An array of threads within the current room, or `undefined` if not yet
    loaded (in non-Suspense version).
  </PropertiesListItem>
  <PropertiesListItem name="isLoading" type="boolean">
    Whether the threads are currently being loaded.
  </PropertiesListItem>
  <PropertiesListItem name="error" type="Error | undefined">
    Any error that occurred while loading the threads.
  </PropertiesListItem>
  <PropertiesListItem name="hasFetchedAll" type="boolean">
    Whether all available threads have been fetched. [Learn
    more](/docs/api-reference/liveblocks-react#useThreads-pagination).
  </PropertiesListItem>
  <PropertiesListItem name="fetchMore" type="() => void">
    A function to fetch more threads. [Learn
    more](/docs/api-reference/liveblocks-react#useThreads-pagination).
  </PropertiesListItem>
  <PropertiesListItem name="isFetchingMore" type="boolean">
    Whether more threads are currently being fetched. [Learn
    more](/docs/api-reference/liveblocks-react#useThreads-pagination).
  </PropertiesListItem>
  <PropertiesListItem name="fetchMoreError" type="Error | undefined">
    Any error that occurred while fetching more threads. [Learn
    more](/docs/api-reference/liveblocks-react#useThreads-pagination).
  </PropertiesListItem>
</PropertiesList>

#### Querying threads [#useThreads-query]

Itâ€™s possible to return threads that match a certain query with the `query`
option. You can filter threads based on their resolved status, if the user is
subscribed to them, and metadata. Additionally, you can filter for metadata
strings that being with certain characters using `startsWith` and you can filter
for metadata numbers using `gt`, `lt`, `gte`, and `lte`. Returned threads match
the entire query.

```tsx
// Returns threads that match the entire `query`, e.g. { color: "blue", pinned: true, ... }
const { threads } = useThreads({
  query: {
    // Filter for unresolved threads
    resolved: false,

    // Filter for threads that the user is subscribed to
    subscribed: true,

    metadata: {
      // Filter for threads that contain specific string, boolean, and number data
      color: "blue",
      pinned: true,
      priority: 3,

      // Filter for threads with string metadata that starts with a certain value
      organization: {
        startsWith: "liveblocks:",
      },

      // Filter for threads with number metadata that is greater than 50 and lower than 100
      posX: {
        gt: 50,
        lt: 100,
      },

      // Filter for threads with number metadata that is greater than or equal to 5
      level: {
        gte: 5,
      },
    },
  },
});
```

#### Pagination [#useThreads-pagination]

By default, the `useThreads` hook returns up to 50 threads. To fetch more, the
hook provides additional fields for pagination, similar to
[`useInboxNotifications`][].

```tsx
import { useThreads } from "@liveblocks/react";

const {
  isLoading,
  error,
  threads,

  +++
  fetchMore,
  isFetchingMore,
  hasFetchedAll,
  fetchMoreError,
  +++
} = useThreads();
```

- `hasFetchedAll` indicates whether all available threads have been fetched.
- `fetchMore` loads up to 50 more threads, and is always safe to call.
- `isFetchingMore` indicates whether more threads are being fetched.
- `fetchMoreError` returns error statuses resulting from fetching more.

##### Pagination example [#useThreads-pagination-example]

The following example demonstrates how to use the `fetchMore` function to
implement a â€œLoad Moreâ€ button, which fetches additional threads when clicked.
The button is disabled while fetching is in progress.

```tsx
import { Thread } from "@liveblocks/react-ui";
import { useThreads } from "@liveblocks/react/suspense";

function Threads() {
  const { threads, hasFetchedAll, fetchMore, isFetchingMore } = useThreads();

  return (
    <div>
      {threads.map((thread) => (
        <Thread key={thread.id} thread={thread} />
      ))}
      // +++
      {hasFetchedAll ? (
        <div>ðŸŽ‰ You've loaded all threads!</div>
      ) : (
        <button disabled={isFetchingMore} onClick={fetchMore}>
          Load more
        </button>
      )}
      // +++
    </div>
  );
}
```

#### Error handling [#useThreads-error-handling]

Error handling is another important aspect to consider when using the
`useThreads` hook. The `error` and `fetchMoreError` fields provide information
about any errors that occurred during the initial fetch or subsequent fetch
operations, respectively. You can use these fields to display appropriate error
messages to the user and implement retry mechanisms if needed.

The following example shows how to display error messages for both initial
loading errors and errors that occur when fetching more threads.

```tsx
import { Thread } from "@liveblocks/react-ui";
import { useThreads } from "@liveblocks/react";

function Inbox() {
  const { threads, error, fetchMore, fetchMoreError } = useThreads();

  // Handle error if the initial load failed.
  // The `error` field is not returned by the Suspense hook as the error is thrown to nearest ErrorBoundary
  // +++
  if (error) {
    return (
      <div>
        <p>Error loading threads: {error.message}</p>
      </div>
    );
  }
  // +++

  return (
    <div>
      {threads.map((thread) => (
        <Thread key={thread.id} thread={thread} />
      ))}

      {fetchMoreError && (
        <div>
          <p>Error loading more threads: {fetchMoreError.message}</p>
          <button onClick={fetchMore}>Retry</button>
        </div>
      )}
    </div>
  );
}
```

#### Avoid scrolling to a comment [#useThreads-scroll]

By default, `scrollOnLoad`, is enabled. This options scrolls to a comment if the
URLâ€™s hash is set to a comment ID (e.g.
`https://example.com/my-room#cm_nNJs9sb...`), the page will scroll to that
comment once the threads are loaded. To avoid scrolling to a comment, set
`scrollOnLoad` to `false`.

```tsx
const { threads } = useThreads({ scrollOnLoad: false });
```

### useCreateThread [@badge=RoomProvider]

Returns a function that optimistically creates a thread with an initial comment,
and optionally some thread and comment metadata.

```tsx
import { useCreateThread } from "@liveblocks/react/suspense";

const createThread = useCreateThread();
const thread = createThread({
  body: {},
  attachments: [],
  metadata: {},
  commentMetadata: {},
});
```

<PropertiesList title="Returns">
  <PropertiesListItem
    name="createThread"
    type="(options: CreateThreadOptions) => ThreadData"
  >
    A function that creates a thread with an initial comment, and optionally
    thread and comment metadata. Returns the optimistic thread object.
  </PropertiesListItem>
</PropertiesList>

#### Error handling [#useCreateThread-error-handling]

`useCreateThread` creates threads optimistically, meaning that a thread object
is returned instantly, before Liveblocks has confirmed a successful thread
creation. To catch any errors that occur, add [`useErrorListener`][] and look
for the `CREATE_THREAD_ERROR` type.

```tsx
import { useErrorListener } from "@liveblocks/react/suspense";

useErrorListener((error) => {
  if (error.context.type === "CREATE_THREAD_ERROR") {
    const { roomId, threadId, commentId, body, metadata } = error.context;
    console.log(`Problem creating thread ${threadId}`);
  }
});
```

### useSearchComments [@badge=RoomProvider]

Search comments in the current room using semantic search and various filters.
Returns a list of results, including the ID and the plain text content of
matched comments, and the thread ID of the commentâ€™s parent. Use it to
[create a search bar](#create-a-comments-search-bar).

```tsx
import { useSearchComments } from "@liveblocks/react";

const { results, error, isLoading } = useSearchComments({
  query: { text: "fruit" },
});

// [{ content: "I like apples", threadId: "th_xxx", commentId: "cm_xxx"  }, ...]
console.log(results);
```

Its semantic search finds results based on meaning, so a query like â€œfruitâ€ also
brings up related items such as â€œapplesâ€ or â€œorangesâ€, even if the exact words
donâ€™t match.

<PropertiesList title="Arguments">
  <PropertiesListItem name="options" type="object">
    Configuration object.
  </PropertiesListItem>
  <PropertiesListItem name="options.query" type="SearchCommentsQuery">
    Optional query to filter comments by metadata and resolved status of the
    parent thread, and presence and absence of attachments and mentions in the
    comment.
  </PropertiesListItem>
  <PropertiesListItem name="options.query.text" type="string" required>
    Text to search within comment content. Uses rich text and vector search for
    relevance.
  </PropertiesListItem>
  <PropertiesListItem
    name="options.query.threadMetadata"
    type="Partial<QueryMetadata>"
  >
    Metadata to filter threads by.
  </PropertiesListItem>
  <PropertiesListItem name="options.query.threadResolved" type="boolean">
    Whether to only return comments from threads that have attachments.
  </PropertiesListItem>
  <PropertiesListItem name="options.query.hasAttachments" type="boolean">
    Whether to only return comments that have attachments.
  </PropertiesListItem>
  <PropertiesListItem name="options.query.hasMentions" type="boolean">
    Whether to only return comments that have mentions.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Returns">
  <PropertiesListItem name="results" type="ThreadData[] | undefined">
    An array of matched comments with the parent thread they belong to.
  </PropertiesListItem>
  <PropertiesListItem name="isLoading" type="boolean">
    Whether the results are currently being loaded.
  </PropertiesListItem>
  <PropertiesListItem name="error" type="Error | undefined">
    Any error that occurred while searching the threads.
  </PropertiesListItem>
</PropertiesList>

#### Create a comments search bar

`useSearchComments` allows you to create a search bar for comments that exist
within the current room. Linking to the `commentId` with a hash will highlight
the comment on the page.

```tsx
import { useSearchComments } from "@liveblocks/react";
import { useState } from "react";

function SearchBar() {
  const [search, setSearch] = useState("");

  // +++
  const { results, isLoading, error } = useSearchComments({
    query: { text: search },
  });
  // +++

  return (
    <>
      <input
        type="text"
        value={search}
        onChange={(e) => setSearch(e.target.value)}
      />
      {isLoading ? (
        <div>Loading...</div>
      ) : (
        results.map((result) => (
          // +++
          <a key={result.commentId} href={"#" + result.commentId}>
            {result.content}
          </a>
          // +++
        ))
      )}
    </>
  );
}
```

You could also add buttons that apply various filters, such as â€œResolvedâ€ and
â€œUnresolvedâ€.

```tsx title="Resolved/unresolved filter" isCollapsable isCollapsed
import { useSearchComments } from "@liveblocks/react";
import { useState } from "react";

type ThreadResolved = "all" | "resolved" | "unresolved";

function SearchBar() {
  const [search, setSearch] = useState("");
  // +++
  const [searchResolved, searchResolved] = useState<ThreadResolved>("all");
  // +++

  // +++
  const searchThreadResolved =
    searchResolved === "all" ? undefined : searchResolved === "resolved";
  // +++

  const { results, isLoading, error } = useSearchComments({
    query: {
      text: search,
      // +++
      threadResolved: searchThreadResolved,
      // +++
    },
  });

  return (
    <>
      <input
        type="text"
        value={search}
        onChange={(e) => setSearch(e.target.value)}
      />
      // +++
      <button
        data-active={searchResolved === "all"}
        onClick={() => setSearchResolved("all")}
      >
        All
      </button>
      <button
        data-active={searchResolved === "resolved"}
        onClick={() => setSearchResolved("resolved")}
      >
        Resolved
      </button>
      <button
        data-active={searchResolved === "unresolved"}
        onClick={() => setSearchResolved("unresolved")}
      >
        Resolved
      </button>
      // +++
      {isLoading ? (
        <div>Loading...</div>
      ) : (
        results.map((result) => (
          <a key={result.commentId} href={"#" + result.commentId}>
            {result.content}
          </a>
        ))
      )}
    </>
  );
}
```

### useDeleteThread [@badge=RoomProvider]

Returns a function that deletes a thread and all its associated comments by ID.
Only the thread creator can delete the thread.

```tsx
import { useDeleteThread } from "@liveblocks/react/suspense";

const deleteThread = useDeleteThread();
deleteThread("th_xxx");
```

<PropertiesList title="Returns">
  <PropertiesListItem name="deleteThread" type="(threadId: string) => void">
    A function that deletes a thread and all its associated comments by ID.
  </PropertiesListItem>
</PropertiesList>

#### Error handling [#useDeleteThread-error-handling]

`useDeleteThread` deletes threads optimistically, meaning that the thread
appears deleted instantly, before Liveblocks has confirmed a successful thread
deletion. To catch any errors that occur, add [`useErrorListener`][] and look
for the `DELETE_THREAD_ERROR` type.

```tsx
import { useErrorListener } from "@liveblocks/react/suspense";

useErrorListener((error) => {
  if (error.context.type === "DELETE_THREAD_ERROR") {
    const { roomId, threadId } = error.context;
    console.log(`Problem deleting thread ${threadId}`);
  }
});
```

### useEditThreadMetadata [@badge=RoomProvider]

Returns a function that edits a threadâ€™s metadata. To delete an existing
metadata property, set its value to `null`. Passing `undefined` for a metadata
property will ignore it.

```tsx
import { useEditThreadMetadata } from "@liveblocks/react/suspense";

const editThreadMetadata = useEditThreadMetadata();
editThreadMetadata({ threadId: "th_xxx", metadata: {} });
```

<PropertiesList title="Returns">
  <PropertiesListItem
    name="editThreadMetadata"
    type="(options: { threadId: string; metadata: ThreadMetadata }) => void"
  >
    A function that edits a threadâ€™s metadata. To delete an existing metadata
    property, set its value to `null`.
  </PropertiesListItem>
</PropertiesList>

#### Error handling [#useEditThreadMetadata-error-handling]

`useEditThreadMetadata` edits thread metadata optimistically, meaning that the
metadata appears updated instantly, before Liveblocks has confirmed a successful
metadata update. To catch any errors that occur, add [`useErrorListener`][] and
look for the `EDIT_THREAD_METADATA_ERROR` type.

```tsx
import { useErrorListener } from "@liveblocks/react/suspense";

useErrorListener((error) => {
  if (error.context.type === "EDIT_THREAD_METADATA_ERROR") {
    const { roomId, threadId, metadata } = error.context;
    console.log(`Problem editing thread metadata ${threadId}`);
  }
});
```

### useMarkThreadAsResolved [@badge=RoomProvider]

Returns a function that marks a thread as resolved.

```tsx
import { useMarkThreadAsResolved } from "@liveblocks/react/suspense";

const markThreadAsResolved = useMarkThreadAsResolved();
markThreadAsResolved("th_xxx");
```

<PropertiesList title="Returns">
  <PropertiesListItem
    name="markThreadAsResolved"
    type="(threadId: string) => void"
  >
    A function that marks a thread as resolved.
  </PropertiesListItem>
</PropertiesList>

#### Error handling [#useMarkThreadAsResolved-error-handling]

`useMarkThreadAsResolved` marks threads as resolved optimistically, meaning that
the thread appears resolved instantly, before Liveblocks has confirmed the
successful status change. To catch any errors that occur, add
[`useErrorListener`][] and look for the `MARK_THREAD_AS_RESOLVED_ERROR` type.

```tsx
import { useErrorListener } from "@liveblocks/react/suspense";

useErrorListener((error) => {
  if (error.context.type === "MARK_THREAD_AS_RESOLVED_ERROR") {
    const { roomId, threadId } = error.context;
    console.log(`Problem marking thread as resolved ${threadId}`);
  }
});
```

### useMarkThreadAsUnresolved [@badge=RoomProvider]

Returns a function that marks a thread as unresolved.

```tsx
import { useMarkThreadAsUnresolved } from "@liveblocks/react/suspense";

const markThreadAsUnresolved = useMarkThreadAsUnresolved();
markThreadAsUnresolved("th_xxx");
```

<PropertiesList title="Returns">
  <PropertiesListItem
    name="markThreadAsUnresolved"
    type="(threadId: string) => void"
  >
    A function that marks a thread as unresolved.
  </PropertiesListItem>
</PropertiesList>

#### Error handling [#useMarkThreadAsUnresolved-error-handling]

`useMarkThreadAsUnresolved` marks threads as unresolved optimistically, meaning
that the thread appears unresolved instantly, before Liveblocks has confirmed
the successful status change. To catch any errors that occur, add
[`useErrorListener`][] and look for the `MARK_THREAD_AS_UNRESOLVED_ERROR` type.

```tsx
import { useErrorListener } from "@liveblocks/react/suspense";

useErrorListener((error) => {
  if (error.context.type === "MARK_THREAD_AS_UNRESOLVED_ERROR") {
    const { roomId, threadId } = error.context;
    console.log(`Problem marking thread as unresolved ${threadId}`);
  }
});
```

### useMarkThreadAsRead [@badge=RoomProvider]

Returns a function that marks a thread as read.

```tsx
import { useMarkThreadAsRead } from "@liveblocks/react/suspense";

const markThreadAsRead = useMarkThreadAsRead();
markThreadAsRead("th_xxx");
```

<PropertiesList title="Returns">
  <PropertiesListItem name="markThreadAsRead" type="(threadId: string) => void">
    A function that marks a thread as read.
  </PropertiesListItem>
</PropertiesList>

### useThreadSubscription [@badge=RoomProvider]

Returns the subscription status of a thread, methods to update it, and when the
thread was last read. The subscription status affects whether the current user
receives inbox notifications when new comments are posted.

```tsx
import { useThreadSubscription } from "@liveblocks/react/suspense";

const { status, subscribe, unsubscribe, unreadSince } =
  useThreadSubscription("th_xxx");
```

`subscribe` and `unsubscribe` work similarly to
[`useSubscribeToThread`](#useSubscribeToThread) and
[`useUnsubscribeFromThread`](#useUnsubscribeFromThread), but they only affect
the current thread.

<PropertiesList title="Arguments">
  <PropertiesListItem name="threadId" type="string">
    The ID of the thread to get subscription status for.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Returns">
  <PropertiesListItem name="status" type="ThreadSubscriptionStatus">
    The subscription status of the thread ('subscribed', 'unsubscribed', or
    'not_subscribed').
  </PropertiesListItem>
  <PropertiesListItem name="subscribe" type="() => void">
    A function to subscribe to the thread.
  </PropertiesListItem>
  <PropertiesListItem name="unsubscribe" type="() => void">
    A function to unsubscribe from the thread.
  </PropertiesListItem>
  <PropertiesListItem name="unreadSince" type="Date | null">
    The date when the thread was last read, or null if it has been read.
  </PropertiesListItem>
</PropertiesList>

### useSubscribeToThread [@badge=RoomProvider]

Returns a function that subscribes the current user to a thread, meaning they
will receive inbox notifications when new comments are posted.

```tsx
import { useSubscribeToThread } from "@liveblocks/react/suspense";

const subscribeToThread = useSubscribeToThread();
subscribeToThread("th_xxx");
```

#### Error handling [#useSubscribeToThread-error-handling]

`useSubscribeToThread` subscribes to threads optimistically, meaning that the
subscription appears active instantly, before Liveblocks has confirmed a
successful subscription. To catch any errors that occur, add
[`useErrorListener`][] and look for the `SUBSCRIBE_TO_THREAD_ERROR` type.

```tsx
import { useErrorListener } from "@liveblocks/react/suspense";

useErrorListener((error) => {
  if (error.context.type === "SUBSCRIBE_TO_THREAD_ERROR") {
    const { roomId, threadId } = error.context;
    console.log(`Problem subscribing to thread ${threadId}`);
  }
});
```

Subscribing will replace any existing subscription for the current thread
[set at room-level](#useRoomSubscriptionSettings). This value can also be
overridden by a room-level call that is run afterwards.

```ts
const subscribeToThread = useSubscribeToThread();
const [{ settings }, updateSettings] = useRoomSubscriptionSettings();

// 1. Disables notifications for all threads
updateSettings({
  threads: "none",
});

// 2. Enables notifications just for this thread, "th_d75sF3..."
subscribeToThread("th_d75sF3...");

// 3. Disables notifications for all threads, including "th_d75sF3..."
updateSettings({
  threads: "none",
});
```

<PropertiesList title="Returns">
  <PropertiesListItem
    name="subscribeToThread"
    type="(threadId: string) => void"
  >
    A function that subscribes the current user to a thread for inbox
    notifications.
  </PropertiesListItem>
</PropertiesList>

### useUnsubscribeFromThread [@badge=RoomProvider]

Returns a function that unsubscribes the current user from a thread, meaning
they will no longer receive inbox notifications when new comments are posted.

```tsx
import { useUnsubscribeFromThread } from "@liveblocks/react/suspense";

const unsubscribeFromThread = useUnsubscribeFromThread();
unsubscribeFromThread("th_xxx");
```

Unsubscribing will replace any existing subscription for the current thread
[set at room-level](#useRoomSubscriptionSettings). This value can also be
overridden by a room-level call that is run afterwards.

```ts
const subscribeToThread = useSubscribeToThread();
const [{ settings }, updateSettings] = useRoomSubscriptionSettings();

// 1. Enables notifications for all threads
updateSettings({
  threads: "all",
});

// 2. Disables notifications just for this thread, "th_d75sF3..."
subscribeToThread("th_d75sF3...");

// 3. Enables notifications for all threads, including "th_d75sF3..."
updateSettings({
  threads: "all",
});
```

<PropertiesList title="Returns">
  <PropertiesListItem
    name="unsubscribeFromThread"
    type="(threadId: string) => void"
  >
    A function that unsubscribes the current user from a thread, stopping inbox
    notifications.
  </PropertiesListItem>
</PropertiesList>

#### Error handling [#useUnsubscribeFromThread-error-handling]

`useUnsubscribeFromThread` unsubscribes from threads optimistically, meaning
that the subscription appears inactive instantly, before Liveblocks has
confirmed a successful unsubscription. To catch any errors that occur, add
[`useErrorListener`][] and look for the `UNSUBSCRIBE_FROM_THREAD_ERROR` type.

```tsx
import { useErrorListener } from "@liveblocks/react/suspense";

useErrorListener((error) => {
  if (error.context.type === "UNSUBSCRIBE_FROM_THREAD_ERROR") {
    const { roomId, threadId } = error.context;
    console.log(`Problem unsubscribing from thread ${threadId}`);
  }
});
```

### useCreateComment [@badge=RoomProvider]

Returns a function that adds a comment to a thread.

```tsx
import { useCreateComment } from "@liveblocks/react/suspense";

const createComment = useCreateComment();
const comment = createComment({
  threadId: "th_xxx",
  body: {},
  attachments: [],
  metadata: {},
});
```

<PropertiesList title="Returns">
  <PropertiesListItem
    name="createComment"
    type="(options: CreateCommentOptions) => CommentData"
  >
    A function that adds a comment to a thread. Returns the optimistic comment
    object.
  </PropertiesListItem>
</PropertiesList>

#### Error handling [#useCreateComment-error-handling]

`useCreateComment` creates comments optimistically, meaning that a comment
object is returned instantly, before Liveblocks has confirmed a successful
comment creation. To catch any errors that occur, add [`useErrorListener`][] and
look for the `CREATE_COMMENT_ERROR` type.

```tsx
import { useErrorListener } from "@liveblocks/react/suspense";

useErrorListener((error) => {
  if (error.context.type === "CREATE_COMMENT_ERROR") {
    const { roomId, threadId, commentId, body } = error.context;
    console.log(`Problem creating comment ${commentId}`);
  }
});
```

### useEditComment[@badge=RoomProvider]

Returns a function that edits a commentâ€™s body, and optionally its attachments
and metadata.

```tsx
import { useEditComment } from "@liveblocks/react/suspense";

const editComment = useEditComment();
editComment({
  threadId: "th_xxx",
  commentId: "cm_xxx",
  body: {},
  attachments: [],
  metadata: {},
});
```

<PropertiesList title="Returns">
  <PropertiesListItem
    name="editComment"
    type="(options: EditCommentOptions) => void"
  >
    A function that edits a commentâ€™s body, and optionally its attachments and
    metadata.
  </PropertiesListItem>
</PropertiesList>

#### Error handling [#useEditComment-error-handling]

`useEditComment` edits comments optimistically, meaning that the comment appears
updated instantly, before Liveblocks has confirmed a successful comment edit. To
catch any errors that occur, add [`useErrorListener`][] and look for the
`EDIT_COMMENT_ERROR` type.

```tsx
import { useErrorListener } from "@liveblocks/react/suspense";

useErrorListener((error) => {
  if (error.context.type === "EDIT_COMMENT_ERROR") {
    const { roomId, threadId, commentId, body } = error.context;
    console.log(`Problem editing comment ${commentId}`);
  }
});
```

### useEditCommentMetadata [@badge=RoomProvider]

Returns a function that edits a commentâ€™s metadata. To delete an existing
metadata property, set its value to `null`. Passing `undefined` for a metadata
property will ignore it.

```tsx
import { useEditCommentMetadata } from "@liveblocks/react/suspense";

const editCommentMetadata = useEditCommentMetadata();
editCommentMetadata({
  threadId: "th_xxx",
  commentId: "cm_xxx",
  metadata: {},
});
```

<PropertiesList title="Returns">
  <PropertiesListItem
    name="editCommentMetadata"
    type="(options: { threadId: string; commentId: string; metadata: CommentMetadata }) => void"
  >
    A function that edits a commentâ€™s metadata. To delete an existing metadata
    property, set its value to `null`.
  </PropertiesListItem>
</PropertiesList>

#### Error handling [#useEditCommentMetadata-error-handling]

`useEditCommentMetadata` edits comment metadata optimistically, meaning that the
metadata appears updated instantly, before Liveblocks has confirmed a successful
metadata update. To catch any errors that occur, add [`useErrorListener`][] and
look for the `EDIT_COMMENT_METADATA_ERROR` type.

```tsx
import { useErrorListener } from "@liveblocks/react/suspense";

useErrorListener((error) => {
  if (error.context.type === "EDIT_COMMENT_METADATA_ERROR") {
    const { roomId, threadId, commentId, metadata } = error.context;
    console.log(`Problem editing comment metadata ${commentId}`);
  }
});
```

### useDeleteComment [@badge=RoomProvider]

Returns a function that deletes a comment. If it is the last non-deleted
comment, the thread also gets deleted.

```tsx
import { useDeleteComment } from "@liveblocks/react/suspense";

const deleteComment = useDeleteComment();
deleteComment({ threadId: "th_xxx", commentId: "cm_xxx" });
```

<PropertiesList title="Returns">
  <PropertiesListItem
    name="deleteComment"
    type="(options: { threadId: string; commentId: string }) => void"
  >
    A function that deletes a comment. If it is the last non-deleted comment,
    the thread also gets deleted.
  </PropertiesListItem>
</PropertiesList>

#### Error handling [#useDeleteComment-error-handling]

`useDeleteComment` deletes comments optimistically, meaning that the comment
appears deleted instantly, before Liveblocks has confirmed a successful comment
deletion. To catch any errors that occur, add [`useErrorListener`][] and look
for the `DELETE_COMMENT_ERROR` type.

```tsx
import { useErrorListener } from "@liveblocks/react/suspense";

useErrorListener((error) => {
  if (error.context.type === "DELETE_COMMENT_ERROR") {
    const { roomId, threadId, commentId } = error.context;
    console.log(`Problem deleting comment ${commentId}`);
  }
});
```

### useAddReaction [@badge=RoomProvider]

Returns a function that adds a reaction to a comment. Can be used to create an
[emoji picker](/docs/api-reference/liveblocks-react-ui#emoji-picker) or
[emoji reactions](/docs/api-reference/liveblocks-react-ui#emoji-reactions).

```tsx
import { useAddReaction } from "@liveblocks/react/suspense";

const addReaction = useAddReaction();
addReaction({ threadId: "th_xxx", commentId: "cm_xxx", emoji: "ðŸ‘" });
```

<PropertiesList title="Returns">
  <PropertiesListItem
    name="addReaction"
    type="(options: { threadId: string; commentId: string; emoji: string }) => void"
  >
    A function that adds a reaction to a comment.
  </PropertiesListItem>
</PropertiesList>

#### Error handling [#useAddReaction-error-handling]

`useAddReaction` adds reactions optimistically, meaning that the reaction
appears instantly, before Liveblocks has confirmed a successful reaction
addition. To catch any errors that occur, add [`useErrorListener`][] and look
for the `ADD_REACTION_ERROR` type.

```tsx
import { useErrorListener } from "@liveblocks/react/suspense";

useErrorListener((error) => {
  if (error.context.type === "ADD_REACTION_ERROR") {
    const { roomId, threadId, commentId, emoji } = error.context;
    console.log(`Problem adding reaction ${emoji} to comment ${commentId}`);
  }
});
```

### useRemoveReaction [@badge=RoomProvider]

Returns a function that removes a reaction from a comment. Can be used to create
an [emoji picker](/docs/api-reference/liveblocks-react-ui#emoji-picker) or
[emoji reactions](/docs/api-reference/liveblocks-react-ui#emoji-reactions)

```tsx
import { useRemoveReaction } from "@liveblocks/react/suspense";

const removeReaction = useRemoveReaction();
removeReaction({ threadId: "th_xxx", commentId: "cm_xxx", emoji: "ðŸ‘" });
```

<PropertiesList title="Returns">
  <PropertiesListItem
    name="removeReaction"
    type="(options: { threadId: string; commentId: string; emoji: string }) => void"
  >
    A function that removes a reaction from a comment.
  </PropertiesListItem>
</PropertiesList>

#### Error handling [#useRemoveReaction-error-handling]

`useRemoveReaction` removes reactions optimistically, meaning that the reaction
disappears instantly, before Liveblocks has confirmed a successful reaction
removal. To catch any errors that occur, add [`useErrorListener`][] and look for
the `REMOVE_REACTION_ERROR` type.

```tsx
import { useErrorListener } from "@liveblocks/react/suspense";

useErrorListener((error) => {
  if (error.context.type === "REMOVE_REACTION_ERROR") {
    const { roomId, threadId, commentId, emoji } = error.context;
    console.log(`Problem removing reaction ${emoji} from comment ${commentId}`);
  }
});
```

### useAttachmentUrl [@badge=RoomProvider]

Returns a presigned URL for an attachment by its ID.
[Suspense](/docs/api-reference/liveblocks-react#Suspense-hooks) and
[regular](/docs/api-reference/liveblocks-react#Regular-hooks) versions of this
hook are available.

```tsx
import { useAttachmentUrl } from "@liveblocks/react";

const { url, error, isLoading } = useAttachmentUrl("at_xxx");
```

<PropertiesList title="Arguments">
  <PropertiesListItem name="attachmentId" type="string">
    The ID of the attachment to get a presigned URL for.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Returns">
  <PropertiesListItem name="url" type="string | undefined">
    The presigned URL for the attachment, or `undefined` if not found or not yet
    loaded (in non-Suspense version).
  </PropertiesListItem>
  <PropertiesListItem name="isLoading" type="boolean">
    Whether the URL is currently being loaded.
  </PropertiesListItem>
  <PropertiesListItem name="error" type="Error | undefined">
    Any error that occurred while loading the URL.
  </PropertiesListItem>
</PropertiesList>

## Notifications

### useInboxNotifications [@badge=LiveblocksProvider]

Returns a paginated list of inbox notifications for the current user. Initially
fetches the latest 50 items. Inbox notifications are
[project-based](/docs/ready-made-features/notifications/concepts#Project-based),
meaning notifications from outside the current room are received.

```tsx
import { useInboxNotifications } from "@liveblocks/react";

const { inboxNotifications, error, isLoading } = useInboxNotifications();
```

Use the
[`InboxNotification`](/docs/api-reference/liveblocks-react-ui#InboxNotification)
component to render the latest 50 inbox notifications with our default UI.

```tsx
import { InboxNotification } from "@liveblocks/react-ui";
import { useInboxNotifications } from "@liveblocks/react/suspense";

function Inbox() {
  // +++
  const { inboxNotifications } = useInboxNotifications();
  // +++

  return (
    <div>
      // +++
      {inboxNotifications.map((notification) => (
        <InboxNotification
          key={notification.id}
          inboxNotification={notification}
        />
      ))}
      // +++
    </div>
  );
}
```

<PropertiesList title="Arguments">
  <PropertiesListItem name="options" type="object">
    Optional configuration object.
  </PropertiesListItem>
  <PropertiesListItem name="options.query" type="InboxNotificationsQuery">
    Optional query to filter notifications by room ID or kind. [Learn
    more](/docs/api-reference/liveblocks-react#useInboxNotifications-query).
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Returns">
  <PropertiesListItem
    name="inboxNotifications"
    type="InboxNotificationData[] | undefined"
  >
    An array of inbox notifications for the current user, or `undefined` if not
    yet loaded (in non-Suspense version).
  </PropertiesListItem>
  <PropertiesListItem name="isLoading" type="boolean">
    Whether the notifications are currently being loaded.
  </PropertiesListItem>
  <PropertiesListItem name="error" type="Error | undefined">
    Any error that occurred while loading the notifications.
  </PropertiesListItem>
  <PropertiesListItem name="hasFetchedAll" type="boolean">
    Whether all available notifications have been fetched. [Learn
    more](/docs/api-reference/liveblocks-react#useInboxNotifications-pagination).
  </PropertiesListItem>
  <PropertiesListItem name="fetchMore" type="() => void">
    A function to fetch more notifications. [Learn
    more](/docs/api-reference/liveblocks-react#useInboxNotifications-pagination).
  </PropertiesListItem>
  <PropertiesListItem name="isFetchingMore" type="boolean">
    Whether more notifications are currently being fetched. [Learn
    more](/docs/api-reference/liveblocks-react#useInboxNotifications-pagination).
  </PropertiesListItem>
  <PropertiesListItem name="fetchMoreError" type="Error | undefined">
    Any error that occurred while fetching more notifications. [Learn
    more](/docs/api-reference/liveblocks-react#useInboxNotifications-pagination).
  </PropertiesListItem>
</PropertiesList>

#### Querying inbox notifications [#useInboxNotifications-query]

Itâ€™s possible to return inbox notifications that match a certain query with the
`query` option. You can filter inbox notifications based on their associated
room ID or kind.

```tsx
// Returns inbox notifications that match the entire `query`, e.g. { roomId: "room1", ... }
const { inboxNotifications } = useInboxNotifications({
  query: {
    // Filter for roomId
    roomId: "room1",
    // Filter for kind
    kind: "thread",
  },
});
```

#### Pagination [#useInboxNotifications-pagination]

By default, the `useInboxNotifications` hook returns up to 50 notifications. To
fetch more, the hook provides additional fields for pagination, similar to
[`useThreads`][].

```tsx
import { useInboxNotifications } from "@liveblocks/react";

const {
  inboxNotifications,
  isLoading,
  error,

  +++
  hasFetchedAll,
  fetchMore,
  isFetchingMore,
  fetchMoreError,
  +++
} = useInboxNotifications();
```

- `hasFetchedAll` indicates whether all available inbox notifications have been
  fetched.
- `fetchMore` loads up to 50 more notifications, and is always safe to call.
- `isFetchingMore` indicates whether more notifications are being fetched.
- `fetchMoreError` returns error statuses resulting from fetching more.

##### Pagination example [#useInboxNotifications-pagination-example]

The following example demonstrates how to use the `fetchMore` function to
implement a â€œLoad Moreâ€ button, which fetches additional inbox notifications
when clicked. The button is disabled while fetching is in progress.

```tsx
import { InboxNotification } from "@liveblocks/react-ui";
import { useInboxNotifications } from "@liveblocks/react/suspense";

function Inbox() {
  const { inboxNotifications, hasFetchedAll, fetchMore, isFetchingMore } =
    useInboxNotifications();

  return (
    <div>
      {inboxNotifications.map((notification) => (
        <InboxNotification
          key={notification.id}
          inboxNotification={notification}
        />
      ))}
      // +++
      {hasFetchedAll ? (
        <div>ðŸŽ‰ You're all caught up!</div>
      ) : (
        <button disabled={isFetchingMore} onClick={fetchMore}>
          Load more
        </button>
      )}
      // +++
    </div>
  );
}
```

#### Error handling [#useInboxNotifications-error-handling]

Error handling is another important aspect to consider when using the
`useInboxNotifications` hook. The `error` and `fetchMoreError` fields provide
information about any errors that occurred during the initial fetch or
subsequent fetch operations, respectively. You can use these fields to display
appropriate error messages to the user and implement retry mechanisms if needed.

The following example shows how to display error messages for both initial
loading errors and errors that occur when fetching more inbox notifications.

```tsx
import { InboxNotification } from "@liveblocks/react-ui";
import { useInboxNotifications } from "@liveblocks/react";

function Inbox() {
  const { inboxNotifications, error, fetchMore, fetchMoreError } =
    useInboxNotifications();

  // Handle error if the initial load failed.
  // The `error` field is not returned by the Suspense hook as the error is thrown to nearest ErrorBoundary
  // +++
  if (error) {
    return (
      <div>
        <p>Error loading inbox notifications: {error.message}</p>
      </div>
    );
  }
  // +++

  return (
    <div>
      {inboxNotifications.map((notification) => (
        <InboxNotification
          key={notification.id}
          inboxNotification={notification}
        />
      ))}

      {fetchMoreError && (
        <div>
          <p>
            Error loading more inbox notifications: {fetchMoreError.message}
          </p>
          <button onClick={fetchMore}>Retry</button>
        </div>
      )}
    </div>
  );
}
```

#### Batched notifications [#useInboxNotifications-batched-notifications]

If youâ€™re
[batching custom notifications](/docs/api-reference/liveblocks-node#Batching-custom-notifications),
you can render each activity inside a single notification. The `activities`
array will contain multiple items.

```tsx
import { InboxNotification } from "@liveblocks/react-ui";
import { useInboxNotifications } from "@liveblocks/react/suspense";

function Inbox() {
  const { inboxNotifications } = useInboxNotifications();

  // If the last notification was batched, it will have multiple
  // items in the `activities` array
  // {
  //   id: "in_3dH7sF3...",
  //   kind: "$fileUploaded",
  // +++
  //   activities: [
  //     { status: "processing" },
  //     { status: "complete" },
  //   ],
  // +++
  //   ...
  // }
  console.log(inboxNotifications[0].activities);

  // ...
}
```

### useUnreadInboxNotificationsCount [@badge=LiveblocksProvider]

Returns the number of unread inbox notifications for the current user.
[Suspense](/docs/api-reference/liveblocks-react#Suspense-hooks) and
[regular](/docs/api-reference/liveblocks-react#Regular-hooks) versions of this
hook are available.

```tsx
import { useUnreadInboxNotificationsCount } from "@liveblocks/react";

const { count, error, isLoading } = useUnreadInboxNotificationsCount();
```

<PropertiesList title="Arguments">
  <PropertiesListItem
    name="options"
    type="UseUnreadInboxNotificationsCountOptions"
  >
    Optional configuration object.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Options">
  <PropertiesListItem name="query" type="InboxNotificationsQuery">
    Optional query to filter notifications count by room ID or kind.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Returns">
  <PropertiesListItem name="count" type="number | undefined">
    The number of unread inbox notifications for the current user, or
    `undefined` if not yet loaded (in non-Suspense version).
  </PropertiesListItem>
  <PropertiesListItem name="isLoading" type="boolean">
    Whether the number of unread inbox notifications is currently being loaded.
  </PropertiesListItem>
  <PropertiesListItem name="error" type="Error | undefined">
    Any error that occurred while loading the number of unread inbox
    notifications.
  </PropertiesListItem>
</PropertiesList>

#### Querying unread inbox notifications count

Itâ€™s possible to return the count of unread inbox notifications that match a
certain query with the `query` option. You can filter unread inbox notifications
count based on their associated room ID or kind.

```tsx
// Returns the count that match the entire `query`, e.g. { roomId: "room1", ... }
const { count } = useUnreadInboxNotificationsCount({
  query: {
    // Filter for roomId
    roomId: "room1",
    // Filter for kind
    kind: "thread",
  },
});
```

### useMarkInboxNotificationAsRead [@badge=LiveblocksProvider]

Returns a function that marks an inbox notification as read for the current
user.

```tsx
import { useMarkInboxNotificationAsRead } from "@liveblocks/react/suspense";

const markInboxNotificationAsRead = useMarkInboxNotificationAsRead();
markInboxNotificationAsRead("in_xxx");
```

<PropertiesList title="Returns">
  <PropertiesListItem
    name="markInboxNotificationAsRead"
    type="(inboxNotificationId: string) => void"
  >
    A function that marks an inbox notification as read for the current user.
  </PropertiesListItem>
</PropertiesList>

#### Error handling [#useMarkInboxNotificationAsRead-error-handling]

`useMarkInboxNotificationAsRead` marks notifications as read optimistically,
meaning that the notification appears read instantly, before Liveblocks has
confirmed a successful status change. To catch any errors that occur, add
[`useErrorListener`][] and look for the `MARK_INBOX_NOTIFICATION_AS_READ_ERROR`
type.

```tsx
import { useErrorListener } from "@liveblocks/react/suspense";

useErrorListener((error) => {
  if (error.context.type === "MARK_INBOX_NOTIFICATION_AS_READ_ERROR") {
    const { inboxNotificationId, roomId } = error.context;
    console.log(`Problem marking notification as read ${inboxNotificationId}`);
  }
});
```

### useMarkAllInboxNotificationsAsRead [@badge=LiveblocksProvider]

Returns a function that marks all of the current userâ€˜s inbox notifications as
read.

```tsx
import { useMarkAllInboxNotificationsAsRead } from "@liveblocks/react/suspense";

const markAllInboxNotificationsAsRead = useMarkAllInboxNotificationsAsRead();
markAllInboxNotificationsAsRead();
```

<PropertiesList title="Returns">
  <PropertiesListItem name="markAllInboxNotificationsAsRead" type="() => void">
    A function that marks all of the current user's inbox notifications as read.
  </PropertiesListItem>
</PropertiesList>

#### Error handling [#useMarkAllInboxNotificationsAsRead-error-handling]

`useMarkAllInboxNotificationsAsRead` marks all notifications as read
optimistically, meaning that the notifications appear read instantly, before
Liveblocks has confirmed a successful status change. To catch any errors that
occur, add [`useErrorListener`][] and look for the
`MARK_ALL_INBOX_NOTIFICATIONS_AS_READ_ERROR` type.

```tsx
import { useErrorListener } from "@liveblocks/react/suspense";

useErrorListener((error) => {
  if (error.context.type === "MARK_ALL_INBOX_NOTIFICATIONS_AS_READ_ERROR") {
    console.log("Problem marking all notifications as read");
  }
});
```

### useDeleteInboxNotification [@badge=LiveblocksProvider]

Returns a function that deletes an inbox notification for the current user.

```tsx
import { useDeleteInboxNotification } from "@liveblocks/react/suspense";

const deleteInboxNotification = useDeleteInboxNotification();
deleteInboxNotification("in_xxx");
```

<PropertiesList title="Returns">
  <PropertiesListItem
    name="deleteInboxNotification"
    type="(inboxNotificationId: string) => void"
  >
    A function that deletes an inbox notification for the current user.
  </PropertiesListItem>
</PropertiesList>

#### Error handling [#useDeleteInboxNotification-error-handling]

`useDeleteInboxNotification` deletes notifications optimistically, meaning that
the notification appears deleted instantly, before Liveblocks has confirmed a
successful deletion. To catch any errors that occur, add [`useErrorListener`][]
and look for the `DELETE_INBOX_NOTIFICATION_ERROR` type.

```tsx
import { useErrorListener } from "@liveblocks/react/suspense";

useErrorListener((error) => {
  if (error.context.type === "DELETE_INBOX_NOTIFICATION_ERROR") {
    const { inboxNotificationId } = error.context;
    console.log(`Problem deleting notification ${inboxNotificationId}`);
  }
});
```

### useDeleteAllInboxNotifications [@badge=LiveblocksProvider]

Returns a function that deletes all of the current userâ€˜s inbox notifications.

```tsx
import { useDeleteAllInboxNotifications } from "@liveblocks/react/suspense";

const deleteAllInboxNotifications = useDeleteAllInboxNotifications();
deleteAllInboxNotifications();
```

<PropertiesList title="Returns">
  <PropertiesListItem name="deleteAllInboxNotifications" type="() => void">
    A function that deletes all of the current userâ€™s inbox notifications.
  </PropertiesListItem>
</PropertiesList>

#### Error handling [#useDeleteAllInboxNotifications-error-handling]

`useDeleteAllInboxNotifications` deletes all notifications optimistically,
meaning that the notifications appear deleted instantly, before Liveblocks has
confirmed a successful deletion. To catch any errors that occur, add
[`useErrorListener`][] and look for the `DELETE_ALL_INBOX_NOTIFICATIONS_ERROR`
type.

```tsx
import { useErrorListener } from "@liveblocks/react/suspense";

useErrorListener((error) => {
  if (error.context.type === "DELETE_ALL_INBOX_NOTIFICATIONS_ERROR") {
    console.log("Problem deleting all notifications");
  }
});
```

### useInboxNotificationThread [@badge=LiveblocksProvider]

Returns the thread associated with a `"thread"` inbox notification.

```tsx
import { useInboxNotificationThread } from "@liveblocks/react/suspense";

const thread = useInboxNotificationThread("in_xxx");
```

It can **only** be called with IDs of `"thread"` inbox notifications, so we
recommend only using it
[when customizing the rendering](/docs/api-reference/liveblocks-react-ui#Rendering-notification-kinds-differently)
or in other situations where you can guarantee the kind of the notification.

<Banner type="info" title="No fetching and waterfalls">

When `useInboxNotifications` returns `"thread"` inbox notifications, it also
receives the associated threads and caches them behind the scenes. When you call
`useInboxNotificationThread`, it simply returns the cached thread for the inbox
notification ID you passed to it, without any fetching or waterfalls.

</Banner>

<PropertiesList title="Arguments">
  <PropertiesListItem name="inboxNotificationId" type="string">
    The ID of the inbox notification to get the associated thread for. Must be a
    "thread" type notification.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Returns">
  <PropertiesListItem name="thread" type="ThreadData | null">
    The thread associated with the inbox notification, or null if not found.
  </PropertiesListItem>
</PropertiesList>

### useRoomSubscriptionSettings [@badge=RoomProvider]

Returns the userâ€™s subscription settings for the current room and a function to
update them. Updating this setting will change which
[`inboxNotifications`](#useInboxNotifications) the current user receives in the
current room.

```tsx
import { useRoomSubscriptionSettings } from "@liveblocks/react/suspense";

const [{ settings }, updateSettings] = useRoomSubscriptionSettings();

// { threads: "replies_and_mentions", textMentions: "mine" }
console.log(settings);

// No longer receive thread subscriptions in this room
updateSettings({
  threads: "none",
});
```

For `"threads"`, these are the three possible values that can be set:

- `"all"` Receive notifications for every activity in every thread.
- `"replies_and_mentions"` Receive notifications for mentions and threads youâ€™re
  participating in.
- `"none"` No notifications are received.

For `"textMentions"`, these are the two possible values that can be set:

- `"mine"` Receive notifications for mentions of you.
- `"none"` No notifications are received.

<PropertiesList title="Returns">
  <PropertiesListItem name="settings" type="RoomSubscriptionSettings">
    The current subscription settings for the room.
  </PropertiesListItem>
  <PropertiesListItem
    name="updateSettings"
    type="(settings: Partial<RoomSubscriptionSettings>) => void"
  >
    A function to update the subscription settings.
  </PropertiesListItem>
</PropertiesList>

### useUpdateRoomSubscriptionSettings [@badge=RoomProvider]

Returns a function that updates the userâ€™s notification settings for the current
room. Updating this setting will change which
[`inboxNotifications`](#useInboxNotifications) the current user receives in the
current room.

```tsx
import { useUpdateRoomSubscriptionSettings } from "@liveblocks/react/suspense";

const updateRoomSubscriptionSettings = useUpdateRoomSubscriptionSettings();

// No longer receive thread notifications in this room
updateSettings({
  threads: "none",
});
```

#### Error handling [#useUpdateRoomSubscriptionSettings-error-handling]

`useUpdateRoomSubscriptionSettings` updates subscription settings
optimistically, meaning that the settings appear updated instantly, before
Liveblocks has confirmed a successful update. To catch any errors that occur,
add [`useErrorListener`][] and look for the
`UPDATE_ROOM_SUBSCRIPTION_SETTINGS_ERROR` type.

```tsx
import { useErrorListener } from "@liveblocks/react/suspense";

useErrorListener((error) => {
  if (error.context.type === "UPDATE_ROOM_SUBSCRIPTION_SETTINGS_ERROR") {
    const { roomId } = error.context;
    console.log(`Problem updating subscription settings for room ${roomId}`);
  }
});
```

For `"threads"`, these are the three possible values that can be set:

- `"all"` Receive notifications for every activity in every thread.
- `"replies_and_mentions"` Receive notifications for mentions and threads you're
  participating in.
- `"none"` No notifications are received.

For `"textMentions"`, these are the two possible values that can be set:

- `"mine"` Receive notifications for mentions of you.
- `"none"` No notifications are received.

Works the same as `updateSettings` in
[`useRoomSubscriptionSettings`](#useRoomSubscriptionSettings).

<PropertiesList title="Returns">
  <PropertiesListItem
    name="updateRoomSubscriptionSettings"
    type="(settings: Partial<RoomSubscriptionSettings>) => void"
  >
    A function that updates the user's notification settings for the current
    room.
  </PropertiesListItem>
</PropertiesList>

##### Replacing individual thread subscriptions

Subscribing will replace any
[existing thread subscriptions](#useSubscribeToThread) in the current room. This
value can also be overridden by a room-level call that is run afterwards.

```ts
const subscribeToThread = useSubscribeToThread();
const [{ settings }, updateSettings] = useRoomSubscriptionSettings();

// 1. Enables notifications just for this thread, "th_d75sF3..."
subscribeToThread("th_d75sF3...");

// 2. Disables notifications for all threads, including "th_d75sF3..."
updateSettings({
  threads: "none",
});
```

#### Error handling [#useUpdateRoomSubscriptionSettings-error-handling]

`useUpdateRoomSubscriptionSettings` updates subscription settings
optimistically, meaning that the settings appear updated instantly, before
Liveblocks has confirmed a successful update. To catch any errors that occur,
add [`useErrorListener`][] and look for the
`UPDATE_ROOM_SUBSCRIPTION_SETTINGS_ERROR` type.

```tsx
import { useErrorListener } from "@liveblocks/react/suspense";

useErrorListener((error) => {
  if (error.context.type === "UPDATE_ROOM_SUBSCRIPTION_SETTINGS_ERROR") {
    const { roomId } = error.context;
    console.log(`Problem updating subscription settings for room ${roomId}`);
  }
});
```

### useNotificationSettings [@badge=LiveblocksProvider]

<Banner>

Notification settings is currently in beta.

</Banner>

Returns the userâ€™s notification settings in the current project, in other words
which [notification webhook events](/docs/platform/webhooks#NotificationEvent)
will be sent for the current user. Notification settings are project-based,
which means that `settings` and `updateSettings` are for the current userâ€™s
settings in every room. Useful for creating a
[notification settings panel](/docs/guides/how-to-create-a-notification-settings-panel).

```tsx
import { useNotificationSettings } from "@liveblocks/react";

const [{ isLoading, error, settings }, updateSettings] =
  useNotificationSettings();

// Current user receives thread notifications on the email channel
// { email: { thread: true, ... }, ... }
console.log(settings);

// Disabling thread notifications on the email channel
updateSettings({
  email: {
    thread: false,
  },
});
```

A userâ€™s initial settings are set in the dashboard, and different kinds should
be enabled there. If no kind is enabled on the current channel, `null` will be
returned. For example, with the email channel:

```ts
const [{ isLoading, error, settings }, updateSettings] =
  useNotificationSettings();

// { email: null, ... }
console.log(settings);
```

#### Updating notification settings [#useNotificationSettings-updating-notification-settings]

The `updateSettings` function can be used to update the current userâ€™s
notification settings, changing their settings for every room in the project.
Each notification `kind` must first be enabled on your projectâ€™s notification
dashboard page before settings can be used.
[Suspense](/docs/api-reference/liveblocks-react#Suspense-hooks) and
[regular](/docs/api-reference/liveblocks-react#Regular-hooks) versions of this
hook are available.

```tsx
// You only need to pass partials
updateSettings({
  email: { thread: true },
});

// Enabling a custom notification on the slack channel
updateSettings({
  slack: { $myCustomNotification: true },
});

// Setting complex settings
updateSettings({
  email: {
    thread: true,
    textMention: false,
    $newDocument: true,
  },
  slack: {
    thread: false,
    $fileUpload: false,
  },
  teams: {
    thread: true,
  },
});
```

Subscribing will replace any
[existing thread subscriptions](#useSubscribeToThread) in the current room. This
value can also be overridden by a room-level call that is run afterwards.

```ts
const subscribeToThread = useSubscribeToThread();
const [{ settings }, updateSettings] = useRoomSubscriptionSettings();

// 1. Enables notifications just for this thread, "th_d75sF3..."
subscribeToThread("th_d75sF3...");

// 2. Disables notifications for all threads, including "th_d75sF3..."
updateSettings({
  threads: "none",
});
```

<PropertiesList title="Returns">
  <PropertiesListItem name="settings" type="NotificationSettings | null">
    The current notification settings for the user, or null if no settings are
    configured.
  </PropertiesListItem>
  <PropertiesListItem
    name="updateSettings"
    type="(settings: Partial<NotificationSettings>) => void"
  >
    A function to update the notification settings.
  </PropertiesListItem>
  <PropertiesListItem name="isLoading" type="boolean">
    Whether the notification settings are currently being loaded.
  </PropertiesListItem>
  <PropertiesListItem name="error" type="Error | null">
    Any error that occurred while loading the notification settings.
  </PropertiesListItem>
</PropertiesList>

#### Error handling [#useNotificationSettings-error-handling]

Error handling is an important aspect to consider when using the
`useNotificationSettings` hook. The `error` fields provides information about
any error that occurred during the fetch operation.

The following example shows how to display error messages for both initial
loading errors and errors that occur when fetching more inbox notifications.

```tsx
import { useNotificationSettings } from "@liveblocks/react";

const [{ isLoading, error, settings }, updateSettings] =
  useNotificationSettings();

if (error) {
  return (
    <div>
      <p>Error loading notification settings: {error.message}</p>
    </div>
  );
}
```

### useUpdateNotificationSettings [@badge=LiveblocksProvider]

<Banner>

Notification settings is currently in beta.

</Banner>

Returns a function that updates userâ€™s notification settings, which affects
which [notification webhook events](/docs/platform/webhooks#NotificationEvent)
will be sent for the current user. Notification settings are project-based,
which means that `updateSettings` modifies the current userâ€™s settings in every
room. Each notification `kind` must first be enabled on your projectâ€™s
notification dashboard page before settings can be used. Useful for creating a
[notification settings panel](/docs/guides/how-to-create-a-notification-settings-panel).

```tsx
import { useUpdateNotificationSettings } from "@liveblocks/react";

const updateSettings = useUpdateNotificationSettings();

// Disabling thread notifications on the email channel
updateSettings({
  email: { thread: false },
});
```

Works the same as `updateSettings` in
[`useNotificationSettings`](#useNotificationSettings). You can pass a partial
object, or many settings at once.

```tsx
// You only need to pass partials
updateSettings({
  email: { thread: true },
});

// Enabling a custom notification on the slack channel
updateSettings({
  slack: { $myCustomNotification: true },
});

// Setting complex settings
updateSettings({
  email: {
    thread: true,
    textMention: false,
    $newDocument: true,
  },
  slack: {
    thread: false,
    $fileUpload: false,
  },
  teams: {
    thread: true,
  },
});
```

<PropertiesList title="Returns">
  <PropertiesListItem
    name="updateNotificationSettings"
    type="(settings: Partial<NotificationSettings>) => void"
  >
    A function that updates the user's notification settings for the current
    project.
  </PropertiesListItem>
</PropertiesList>

## Version History

### useHistoryVersions [@badge=RoomProvider]

Returns the versions of the room. See
[Version History Components](/docs/api-reference/liveblocks-react-ui#Version-history-components)
for more information on how to display versions.

```tsx
import { useHistoryVersions } from "@liveblocks/react";

const { versions, error, isLoading } = useHistoryVersions();
```

<PropertiesList title="Returns">
  <PropertiesListItem name="versions" type="HistoryVersion[]">
    An array of history versions for the room.
  </PropertiesListItem>
</PropertiesList>

## Miscellaneous

### useUser [@badge=Both]

Returns user info from a given user ID. To use `useUser`, you should provide a
resolver function to the [`resolveUsers`][] option in [`createClient`][] or
[`LiveblocksProvider`][].
[Suspense](/docs/api-reference/liveblocks-react#Suspense-hooks) and
[regular](/docs/api-reference/liveblocks-react#Regular-hooks) versions of this
hook are available.

```tsx
import { useUser } from "@liveblocks/react";

const { user, error, isLoading } = useUser("user-id");
```

<PropertiesList title="Arguments">
  <PropertiesListItem name="userId" type="string">
    The ID of the user to get information for.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Returns">
  <PropertiesListItem name="user" type="User | undefined">
    The user information, or `undefined` if not found or not yet loaded (in
    non-Suspense version).
  </PropertiesListItem>
  <PropertiesListItem name="isLoading" type="boolean">
    Whether the user information is currently being loaded.
  </PropertiesListItem>
  <PropertiesListItem name="error" type="Error | undefined">
    Any error that occurred while loading the user information.
  </PropertiesListItem>
</PropertiesList>

### useRoomInfo [@badge=Both]

Returns room info from a given room ID. To use `useRoomInfo`, you should provide
a resolver function to the [`resolveRoomsInfo`][] option in [`createClient`][]
or [`LiveblocksProvider`][].
[Suspense](/docs/api-reference/liveblocks-react#Suspense-hooks) and
[regular](/docs/api-reference/liveblocks-react#Regular-hooks) versions of this
hook are available.

```tsx
import { useRoomInfo } from "@liveblocks/react";

const { info, error, isLoading } = useRoomInfo("room-id");
```

<PropertiesList title="Arguments">
  <PropertiesListItem name="roomId" type="string">
    The ID of the room to get information for.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Returns">
  <PropertiesListItem name="info" type="RoomInfo | undefined">
    The room information, or `undefined` if not found or not yet loaded (in
    non-Suspense version).
  </PropertiesListItem>
  <PropertiesListItem name="isLoading" type="boolean">
    Whether the room information is currently being loaded.
  </PropertiesListItem>
  <PropertiesListItem name="error" type="Error | undefined">
    Any error that occurred while loading the room information.
  </PropertiesListItem>
</PropertiesList>

### useGroupInfo [@badge=Both]

Returns group info from a given group ID. To use `useGroupInfo`, you should
provide a resolver function to the [`resolveGroupsInfo`][] option in
[`createClient`][] or [`LiveblocksProvider`][].
[Suspense](/docs/api-reference/liveblocks-react#Suspense-hooks) and
[regular](/docs/api-reference/liveblocks-react#Regular-hooks) versions of this
hook are available.

```tsx
import { useGroupInfo } from "@liveblocks/react";

const { info, error, isLoading } = useGroupInfo("group-id");
```

<PropertiesList title="Arguments">
  <PropertiesListItem name="groupId" type="string">
    The ID of the group to get information for.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Returns">
  <PropertiesListItem name="info" type="GroupInfo | undefined">
    The group information, or `undefined` if not found or not yet loaded (in
    non-Suspense version).
  </PropertiesListItem>
  <PropertiesListItem name="isLoading" type="boolean">
    Whether the group information is currently being loaded.
  </PropertiesListItem>
  <PropertiesListItem name="error" type="Error | undefined">
    Any error that occurred while loading the group information.
  </PropertiesListItem>
</PropertiesList>

### useUrlMetadata [@badge=Both]

Returns metadata for a given URL.
[Suspense](/docs/api-reference/liveblocks-react#Suspense-hooks) and
[regular](/docs/api-reference/liveblocks-react#Regular-hooks) versions of this
hook are available.

```tsx
import { useUrlMetadata } from "@liveblocks/react";

const { metadata, error, isLoading } = useUrlMetadata("https://liveblocks.io");

// metadata.title, metadata.description, metadata.image, metadata.icon, ...
```

<PropertiesList title="Arguments">
  <PropertiesListItem name="url" type="string">
    The URL to get metadata for.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Returns">
  <PropertiesListItem name="metadata" type="UrlMetadata | undefined">
    The metadata for the URL, or `undefined` if not yet loaded (in non-Suspense
    version).
  </PropertiesListItem>
  <PropertiesListItem name="isLoading" type="boolean">
    Whether the metadata is currently loading.
  </PropertiesListItem>
  <PropertiesListItem name="error" type="Error | undefined">
    Any error that occurred while loading the metadata.
  </PropertiesListItem>
</PropertiesList>

## TypeScript

### Typing your data

Itâ€™s possible to have automatic types flow through your application by defining
a global `Liveblocks` interface. We recommend doing this in a
`liveblocks.config.ts` file in the root of your app, so itâ€™s easy to keep track
of your types. Each type (`Presence`, `Storage`, etc.), is optional, but itâ€™s
recommended to make use of them.

```ts file="liveblocks.config.ts"
declare global {
  interface Liveblocks {
    // Each user's Presence, for useMyPresence, useOthers, etc.
    Presence: {};

    // The Storage tree for the room, for useMutation, useStorage, etc.
    Storage: {};

    UserMeta: {
      id: string;
      // Custom user info set when authenticating with a secret key
      info: {};
    };

    // Custom events, for useBroadcastEvent, useEventListener
    RoomEvent: {};

    // Custom metadata set on threads, for useThreads, useCreateThread, etc.
    ThreadMetadata: {};

    // Custom room info set with resolveRoomsInfo, for useRoomInfo
    RoomInfo: {};

    // Custom group info set with resolveGroupsInfo, for useGroupInfo
    GroupInfo: {};

    // Custom activities data for custom notification kinds
    ActivitiesData: {};
  }
}

// Necessary if you have no imports/exports
export {};
```

Here are some example values that might be used.

```ts file="liveblocks.config.ts"
import { LiveList } from "@liveblocks/client";

declare global {
  interface Liveblocks {
    // Each user's Presence, for useMyPresence, useOthers, etc.
    Presence: {
      // Example, real-time cursor coordinates
      cursor: { x: number; y: number };
    };

    // The Storage tree for the room, for useMutation, useStorage, etc.
    Storage: {
      // Example, a conflict-free list
      animals: LiveList<string>;
    };

    UserMeta: {
      id: string;
      // Custom user info set when authenticating with a secret key
      info: {
        // Example properties, for useSelf, useUser, useOthers, etc.
        name: string;
        avatar: string;
      };
    };

    // Custom events, for useBroadcastEvent, useEventListener
    // Example has two events, using a union
    RoomEvent: { type: "PLAY" } | { type: "REACTION"; emoji: "ðŸ”¥" };

    // Custom metadata set on threads, for useThreads, useCreateThread, etc.
    ThreadMetadata: {
      // Example, attaching coordinates to a thread
      x: number;
      y: number;
    };

    // Custom room info set with resolveRoomsInfo, for useRoomInfo
    RoomInfo: {
      // Example, rooms with a title and url
      title: string;
      url: string;
    };

    // Custom group info set with resolveGroupsInfo, for useGroupInfo
    GroupInfo: {
      // Example, groups with a name and a badge
      name: string;
      badge: string;
    };

    // Custom activities data for custom notification kinds
    ActivitiesData: {
      // Example, a custom $alert kind
      $alert: {
        title: string;
        message: string;
      };
    };
  }
}

// Necessary if you have no imports/exports
export {};
```

### Typing with createRoomContext

Before Liveblocks 2.0, it was recommended to create your hooks using
[`createRoomContext`][], and manually pass your types to this function. This is
no longer [the recommended method](#Typing-your-data) for setting up Liveblocks,
but it can still be helpful, for example you can use `createRoomContext`
multiple times to create different room types, each with their own correctly
typed hooks.

```tsx file="liveblocks.config.ts" isCollapsable isCollapsed
import { createClient } from "@liveblocks/client";
import { createRoomContext } from "@liveblocks/react";

const client = createClient({
  // publicApiKey: "",
  // authEndpoint: "/api/liveblocks-auth",
});

// Presence represents the properties that exist on every user in the Room
// and that will automatically be kept in sync. Accessible through the
// `user.presence` property. Must be JSON-serializable.
type Presence = {
  // cursor: { x: number, y: number } | null,
  // ...
};

// Optionally, Storage represents the shared document that persists in the
// Room, even after all users leave. Fields under Storage typically are
// LiveList, LiveMap, LiveObject instances, for which updates are
// automatically persisted and synced to all connected clients.
type Storage = {
  // animals: LiveList<string>,
  // ...
};

// Optionally, UserMeta represents static/readonly metadata on each user, as
// provided by your own custom auth back end (if used). Useful for data that
// will not change during a session, like a userâ€™s name or avatar.
// type UserMeta = {
//   id?: string,  // Accessible through `user.id`
//   info?: Json,  // Accessible through `user.info`
// };

// Optionally, the type of custom events broadcast and listened to in this
// room. Use a union for multiple events. Must be JSON-serializable.
// type RoomEvent = {};

// Optionally, when using Comments, ThreadMetadata represents metadata on
// each thread. Can only contain booleans, strings, and numbers.
// export type ThreadMetadata = {
//   pinned: boolean;
//   quote: string;
//   time: number;
// };

export const {
  RoomProvider,
  useMyPresence,
  useStorage,

  // Other hooks
  // ...
} = createRoomContext<
  Presence,
  Storage
  /* UserMeta, RoomEvent, ThreadMetadata */
>(client);
```

To upgrade to Liveblocks 2.0 and the new typing system, follow the
[2.0 migration guide](/docs/platform/upgrading/2.0).

### User [#user-type]

`User` is a type thatâ€™s returned by [`useSelf`][], [`useOthers`][], and other
functions. Some of its values are set when
[typing your room](#Typing-your-data), here are some example values:

```ts file="liveblocks.config.ts"
declare global {
  interface Liveblocks {
    // Each userâ€™s Presence
    // +++
    Presence: {
      cursor: { x: number; y: number };
    };
    // +++

    UserMeta: {
      id: string;
      // Custom user info set when authenticating with a secret key
      // +++
      info: {
        name: string;
        avatar: string;
      };
      // +++
    };
  }
}
```

```ts
const { room, leave } = client.enterRoom("my-room-id");

// {
//   connectionId: 52,
//   +++
//   presence: {
//     cursor: { x: 263, y: 786 },
//   },
//   +++
//   id: "mislav.abha@example.com",
//   +++
//   info: {
//     name: "Mislav Abha",
//     avatar: "/mislav.png",
//   },
//   +++
//   canWrite: true,
//   canComment: true,
// }
const user = room.getSelf();
```

<PropertiesList title="Properties">
  <PropertiesListItem name="connectionId" type="number">
    The connection ID of the User. It is unique and increments with every new
    connection.
  </PropertiesListItem>
  <PropertiesListItem name="id" type={`UserMeta["id"]`}>
    The ID of the User that has been set in the authentication endpoint. Useful
    to get additional information about the connected user.
  </PropertiesListItem>
  <PropertiesListItem name="info" type={`UserMeta["info"]`}>
    Additional user information that has been set in the authentication
    endpoint.
  </PropertiesListItem>
  <PropertiesListItem name="presence" type={`TPresence`}>
    The userâ€™s Presence data.
  </PropertiesListItem>
  <PropertiesListItem name="canWrite" type="boolean">
    `true` if the user can mutate the Roomâ€™s Storage and/or YDoc, `false` if
    they can only read but not mutate it. Set via your [room
    permissions](/docs/authentication#Room-permissions).
  </PropertiesListItem>
  <PropertiesListItem name="canComment" type="boolean">
    `true` if the user can leave a comment in the room, `false` if they can only
    read comments but not leave them. Set via your [room
    permissions](/docs/authentication#Room-permissions).
  </PropertiesListItem>
</PropertiesList>

## Helpers

### shallow

Compares two values shallowly. This can be used as the second argument to
selector based functions to loosen the equality check:

```tsx
const redShapes = useStorage(
  (root) => root.shapes.filter((shape) => shape.color === "red"),
  shallow // ðŸ‘ˆ here
);
```

The default way [selector results](#selectors-return-arbitrary-values) are
compared is by checking referential equality (`===`). If your selector returns
computed arrays (like in the example above) or objects, this will not work.

By passing `shallow` as the second argument, you can â€œloosenâ€ this check. This
is because `shallow` will shallowly compare the members of an array (or values
in an object):

```tsx
// Comparing arrays
shallow([1, 2, 3], [1, 2, 3]); // true

// Comparison objects
shallow({ a: 1 }, { a: 1 }); // true
```

Please note that this will only do a shallow (one level deep) check. Hence the
name. If you need to do an arbitrarily deep equality check, youâ€™ll have to write
a custom equality function or use a library like Lodash for that.

## How selectors work [#selectors] [@keywords=["useStorage", "useSelf", "useOthers", "useOther", "useOthersMapped", "useOthersConnectionIds", "selectors", "comparison"]]

The concepts and behaviors described in this section apply to all of our
selector hooks: [`useStorage`][] , [`useSelf`][] , [`useOthers`][] ,
[`useOthersMapped`][], and [`useOther`][] (singular).

```tsx file="Component.tsx"
const child = useStorage((root) => root.child);
const nested = useStorage((root) => root.child.nested);
const total = useStorage((root) => root.x + root.y);
const merged = useStorage((root) => [...root.items, ...root.more], shallow);
```

<Banner title="Examples are illustrated via useStorage">

In this section, `useStorage` is used as the canonical example. This is for
illustration purposes only. The described concepts and behaviors apply equally
to the other selector hooks.

</Banner>

In a nutshell, the key behaviors for all selector APIs are:

- They [receive immutable data](#selectors-receive-immutable-data)
- They [return arbitrary values](#selectors-return-arbitrary-values)
- They [auto-subscribe to updates](#selectors-subscribe-to-updates)

Letâ€™s go over these traits and responsibilities in the next few sections.

### Selectors receive immutable data [#selectors-receive-immutable-data]

The received input to all selector functions is a **read-only** and
**immutable** top level context value that differs for each hook:

- `useStorage((root) => ...)` receives the Storage root
- `useSelf((me) => ...)` receives the current user
- `useOthers((others) => ...)` receives a list of other users in the room
- `useOthersMapped((other) => ...)` receives each individual other user in the
  room
- `useOther(connectionId, (other) => ...)` receives a specific user in the room

For example, suppose you have set up Storage in the typical way by setting
`initialStorage` in your [`RoomProvider`][] to a tree that describes your appâ€™s
data model using `LiveList`, `LiveObject`, and `LiveMap`. The "root" argument
for your selector function, however, will receive **an immutable and read-only
representation** of that Storage tree, consisting of "normal" JavaScript
datastructures. This makes consumption much easier.

```tsx file="Component.tsx"
function Component() {
  useStorage((root) => ...);
  //          ^^^^
  //          Read-only. No mutable Live structures in here.
  //
  //          {
  //            animals: ["ðŸ¦", "ðŸ¦Š", "ðŸµ"],
  //            mathematician: { firstName: "Ada", lastName: "Lovelace" },
  //            fruitsByName: new Map([
  //              ["apple", "ðŸŽ"],
  //              ["banana", "ðŸŒ"],
  //              ["cherry", "ðŸ’"],
  //            ])
  //          }
  //
}
```

Internally, these read-only trees use a technique called **structural sharing**.
This means that between rerenders, if nodes in the tree did not change, they
will **guarantee** to return the same memory instance. Selecting and returning
these nodes directly is therefore safe and considered a good practice, because
they are stable references by design.

### Selectors return arbitrary values [#selectors-return-arbitrary-values] [@keywords=["shallow"]]

```tsx file="Component.tsx"
const animals = useStorage((root) => root.animals);
// ["ðŸ¦", "ðŸ¦Š", "ðŸµ"]

const ada = useStorage((root) => root.mathematician);
// { firstName: "Ada", lastName: "Lovelace" }

const fullname = useStorage(
  (root) => `${root.mathematician.firstName} ${root.mathematician.lastName}`
);
// "Ada Lovelace"

const fruits = useStorage((root) => [...root.fruitsByName.values()], shallow);
// ["ðŸŽ", "ðŸŒ", "ðŸ’"]
```

Selectors you write can return _any_ value. You can use it to â€œjustâ€ select
nodes from the root tree (first two examples above), but you can also return
computed values, like in the last two examples.

#### Selector functions must return a stable result

One important rule is that selector functions **must return a stable result** to
be efficient. This means calling the same selector twice with the same argument
should return two results that are _referentially equal_. Special care needs to
be taken when filtering or mapping over arrays, or when returning object
literals, because those operations create new array or object instances on every
call (the reason why is detailed
[in the next section](#selectors-subscribe-to-updates)).

#### Examples of stable results

<dl>
  <dt>âœ… `(root) => root.animals` is stable</dt>
  <dd>
    Liveblocks guarantees this. All nodes in the Storage tree are stable
    references as long as their contents donâ€™t change.
  </dd>
  <dt>ï¸ï¸âš ï¸ `(root) => root.animals.map(...)` is not stable</dt>
  <dd>
    Because `.map()` creates a new array instance every time. Youâ€™ll need to use
    [`shallow`][] here.
  </dd>
  <dt>âœ… `(root) => root.animals.map(...).join(", ")` is stable</dt>
  <dd>
    Because `.join()` ultimately returns a string and all primitive values are
    always stable.
  </dd>
</dl>

#### Use a shallow comparison if the result isnâ€™t stable

If your selector function doesnâ€™t return a stable result, it will lead to an
explosion of unnecessary rerenders. In most cases, you can use a [`shallow`][]
comparison function to loosen the check:

```tsx
import { shallow } from "@liveblocks/react";

// âŒ Bad - many unnecessary rerenders
const uncheckedItems = useStorage((root) =>
  root.todos.filter((item) => !item.done)
);

// âœ… Great
const uncheckedItems = useStorage(
  (root) => root.todos.filter((item) => !item.done),
  shallow // ðŸ‘ˆ The fix!
);
```

If your selector function constructs complex objects, then a [`shallow`][]
comparison may not suffice. In those advanced cases, you can provide your own
custom comparison function, or use `_.isEqual` from Lodash.

### Selectors auto-subscribe to updates [#selectors-subscribe-to-updates]

Selectors effectively automatically subscribe your components to updates to the
selected or computed values. This means that your component will **automatically
rerender** when the selected value changes.

Using **multiple selector hooks** within a single React component is perfectly
fine. Each such hook will individually listen for data changes. The component
will rerender if _at least one_ of the hooks requires it. If more than one
selector returns a new value, the component _still only rerenders once_.

Technically, deciding if a rerender is needed works by re-running your selector
function `(root) => root.child` every time something changes inside Liveblocks
storage. Anywhere. That happens often in a busy multiplayer app! The reason why
this is still no problem is that even though `root` will be a different value on
every change, `root.child` will not be if it didnâ€™t change (due to how
Liveblocks internally uses structural sharing).

Only once the returned value is different from the previously returned value,
the component will get rerendered. Otherwise, your component will just remain
idle.

Consider the case:

```tsx
function Component() {
  const animals = useStorage((root) => root.animals);
}
```

And the following timeline:

- First render, `root.animals` initially is `["ðŸ¦", "ðŸ¦Š", "ðŸµ"]`.
- Then, something unrelated elsewhere in Storage is changed. In response to the
  change, `root.animals` gets re-evaluated, but it still returns the same
  (unchanged) array instance.
- Since the value didnâ€™t change, no rerender is needed.
- Then, someone removes an animal from the list. In response to the change,
  `root.animals` gets re-evaluated, and now it returns `["ðŸ¦", "ðŸ¦Š"]`.
- Because the previous value and this value are different, the component will
  rerender, seeing the updated value.

[`createclient`]: /docs/api-reference/liveblocks-client#createClient
[`createroomcontext`]: /docs/api-reference/liveblocks-react#createRoomContext
[`livelist`]: /docs/api-reference/liveblocks-client#LiveList
[`livemap`]: /docs/api-reference/liveblocks-client#LiveMap
[`liveobject`]: /docs/api-reference/liveblocks-client#LiveObject
[`lostconnectiontimeout`]:
  /docs/api-reference/liveblocks-client#createClientLostConnectionTimeout
[`room.history`]: /docs/api-reference/liveblocks-client#Room.history
[`roomprovider`]: /docs/api-reference/liveblocks-react#RoomProvider
[`liveblocksprovider`]: /docs/api-reference/liveblocks-react#LiveblocksProvider
[`usemutation`]: /docs/api-reference/liveblocks-react#useMutation
[`usestorage`]: /docs/api-reference/liveblocks-react#useStorage
[`useself`]: /docs/api-reference/liveblocks-react#useSelf
[`useothers`]: /docs/api-reference/liveblocks-react#useOthers
[`useothersmapped`]: /docs/api-reference/liveblocks-react#useOthersMapped
[`useothersconnectionids`]:
  /docs/api-reference/liveblocks-react#useOthersConnectionIds
[`useother`]: /docs/api-reference/liveblocks-react#useOther
[`uselostconnectionlistener`]:
  /docs/api-reference/liveblocks-react#useLostConnectionListener
[`clientsidesuspense`]: /docs/api-reference/liveblocks-react#ClientSideSuspsnse
[`usebroadcastevent`]: /docs/api-reference/liveblocks-react#useBroadcastEvent
[`useupdatemypresence`]:
  /docs/api-reference/liveblocks-react#useUpdateMyPresence
[`usethreads`]: /docs/api-reference/liveblocks-react#useThreads
[`useinboxnotifications`]:
  /docs/api-reference/liveblocks-react#useInboxNotifications
[`usemypresence`]: /docs/api-reference/liveblocks-react#useMyPresence
[`usesyncstatus`]: /docs/api-reference/liveblocks-react#useSyncStatus
[`useerrorlistener`]: /docs/api-reference/liveblocks-react#useErrorListener
[`room`]: /docs/api-reference/liveblocks-client#Room
[`shallow`]: /docs/api-reference/liveblocks-react#shallow
[`resolveusers`]: /docs/api-reference/liveblocks-client#resolveUsers
[`resolveroomsinfo`]: /docs/api-reference/liveblocks-client#resolveRoomsInfo
[selector]: /docs/api-reference/liveblocks-react#selectors
[how selectors work]: /docs/api-reference/liveblocks-react#selectors
[suspense version]: /docs/api-reference/liveblocks-react#Suspense
[connection status example]:
  https://liveblocks.io/examples/connection-status/nextjs
[`atob`]: https://developer.mozilla.org/en-US/docs/Web/API/atob
[`base-64`]: https://www.npmjs.com/package/base-64
[`websocket`]: https://developer.mozilla.org/en-US/docs/Web/API/WebSocket
[`ws`]: https://www.npmjs.com/package/ws
[`fetch`]: https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API
[`node-fetch`]: https://npmjs.com/package/node-fetch

---
meta:
  title: "@liveblocks/redux"
  parentTitle: "API Reference"
  description: "API Reference for the @liveblocks/redux package"
alwaysShowAllNavigationLevels: false
---

`@liveblocks/redux` provides you with [Redux](https://react-redux.js.org/)
bindings for our realtime collaboration APIs, built on top of WebSockets. Read
our [getting started](/docs/get-started) guides to learn more.

## Enhancer

Enhancer that lets you connect a Redux state to Liveblocks Presence and Storage
features.

```js
import { liveblocksEnhancer } from "@liveblocks/redux";
import { configureStore } from "@reduxjs/toolkit";

const store = configureStore({
  reducer: /* reducer */,
  enhancers: (getDefaultEnhancers) =>
    getDefaultEnhancers().concat(
      liveblocksEnhancer({
      client,
      storageMapping: {},
      presenceMapping: {},
    })
  ),
});
```

<PropertiesList title="Options">
  <PropertiesListItem name="client" type="Client">
    The Liveblocks client instance created with `createClient()`.
  </PropertiesListItem>
  <PropertiesListItem name="presenceMapping" type="PresenceMapping">
    Optional mapping to synchronize Redux state with Liveblocks presence.
  </PropertiesListItem>
  <PropertiesListItem name="storageMapping" type="StorageMapping">
    Optional mapping to synchronize Redux state with Liveblocks storage.
  </PropertiesListItem>
</PropertiesList>

### client [#enhancer-option-client]

See different authentication methods in the [`createClient`][] method.

```js highlight="1,4-6,10-11"
import { createClient } from "@liveblocks/client";
import { liveblocksEnhancer } from "@liveblocks/redux";

const client = createClient({
  authEndpoint: "/api/liveblocks-auth",
});

const store = configureStore({
  reducer: /* reducer */,
  enhancers: (getDefaultEnhancers) =>
    getDefaultEnhancers().concat(liveblocksEnhancer({ client })),
});
```

### presenceMapping [#enhancer-option-presence-mapping]

Mapping used to synchronize a part of your Redux state with one Liveblocks room
presence.

```js highlight="21"
import { liveblocksEnhancer } from "@liveblocks/redux";

const initialState = {
  cursor: { x: 0, y: 0 },
};

const slice = createSlice({
  name: "state",
  initialState,
  reducers: {
    /* reducers */
  },
});

const store = configureStore({
  reducer: slice.reducer,
  enhancers: (getDefaultEnhancers) =>
    getDefaultEnhancers().concat(
      liveblocksEnhancer({
        client,
        presenceMapping: { cursor: true },
      })
    ),
});
```

### storageMapping [#enhancer-option-storage-mapping]

Mapping used to synchronize a part of your Redux state with one Liveblocks Room
storage.

```js highlight="21"
import { liveblocksEnhancer } from "@liveblocks/redux";

const initialState = {
  scientist: { name: "" },
};

const slice = createSlice({
  name: "state",
  initialState,
  reducers: {
    /* reducers */
  },
});

const store = configureStore({
  reducer: slice.reducer,
  enhancers: (getDefaultEnhancers) =>
    getDefaultEnhancers().concat(
      liveblocksEnhancer({
        client,
        storageMapping: { scientist: true },
      })
    ),
});
```

## Actions

### ENTER [#actions-enter]

Dispatch `enterRoom` action to enter a room and start syncing it with Redux
state.

- `roomId`: The roomâ€™s ID.

```js
import { actions } from "@liveblocks/redux";
import { useDispatch, useSelector } from "react-redux";

const dispatch = useDispatch();

dispatch(actions.enterRoom("roomId"));
```

<PropertiesList title="Arguments">
  <PropertiesListItem name="roomId" type="string">
    The ID of the room to enter.
  </PropertiesListItem>
</PropertiesList>

### LEAVE [#actions-leave]

Dispatch `leaveRoom` action to leave the current room and stop syncing it with
Redux state.

```js
import { actions } from "@liveblocks/redux";
import { useDispatch, useSelector } from "react-redux";

const dispatch = useDispatch();

dispatch(actions.leaveRoom());
```

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

## state.liveblocks [#liveblocks-state]

Liveblocks extra state attached by the enhancer.

### others [#liveblocks-state-others]

Other users in the room. Empty when no room is currently synced.

```js
const others = useSelector((state) => state.liveblocks.others);
```

### isStorageLoading [#liveblocks-state-is-storage-loading]

Whether the room storage is currently loading.

```js
const isStorageLoading = useSelector(
  (state) => state.liveblocks.isStorageLoading
);
```

### status [#liveblocks-state-status]

Gets the current WebSocket connection status of the room.

```js
const {
  liveblocks: { status },
} = useStore();
```

The possible values are: `initial`, `connecting`, `connected`, `reconnecting`,
or `disconnected`.

[`createclient`]: /docs/api-reference/liveblocks-client#createClient
[`status`]: /docs/api-reference/liveblocks-redux#liveblocks-state-status

---
meta:
  title: "@liveblocks/yjs"
  parentTitle: "API Reference"
  description: "API Reference for the @liveblocks/yjs package"
alwaysShowAllNavigationLevels: false
---

`@liveblocks/yjs` is a [Yjs](https://yjs.dev/) provider enabling you to use
Liveblocks as the hosted back end of your realtime collaborative application.
Read our [getting started](/docs/get-started) guides to learn more.

## Setup

To set up Yjs, itâ€™s recommended to use [`getYjsProviderForRoom`][]. Itâ€™s no
longer recommended to use [`LiveblocksYjsProvider`][] directly, as issues may
happen when dynamically switching between rooms.

### React

In React, pass your room object with [`useRoom`][]. Itâ€™s fine to use this
function in your React components. From here, you can access your `Y.Doc`.

```ts
import { useRoom } from "@liveblocks/react";
import { getYjsProviderForRoom } from "@liveblocks/yjs";

function App() {
  const room = useRoom();
  const yProvider = getYjsProviderForRoom(room);
  const yDoc = yProvider.getYDoc();

  // ...
}
```

### JavaScript

In JavaScript, pass the room retrieved with [`client.enterRoom`][].

```tsx
import { createClient } from "@liveblocks/client";
import { getYjsProviderForRoom } from "@liveblocks/yjs";

const client = createClient({
  // Options
  // ...
});

const { room, leave } = client.enterRoom("my-room-id", {
  // Options
  // ...
});

const yProvider = getYjsProviderForRoom(room);
const yDoc = yProvider.getYDoc();
```

## getYjsProviderForRoom [#getYjsProviderForRoom]

Gets the current or creates a new [`LiveblocksYjsProvider`][] for a roomâ€”this is
the recommended way to use Yjs. This provider will automatically be cleaned up
when the room is destroyed, so you donâ€™t need to destroy the provider manually.
The second argument is the [`LiveblocksYjsProvider`][] options.

```ts
import { getYjsProviderForRoom } from "@liveblocks/yjs";

const yProvider = getYjsProviderForRoom(room, {
  // Options
  // ...
});

const yDoc = yProvider.getYDoc();
```

<PropertiesList title="Returns">
  <PropertiesListItem name="yProvider" type="LiveblocksYjsProvider">
    The [`LiveblocksYjsProvider`][] for the room. The provider is automatically
    cleaned up and destroyed when necessary. Fetch your [`Y.Doc`][] with
    [`LiveblocksYjsProvider.getYDoc`](#LiveblocksYjsProvider.getYDoc).
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Arguments">
  <PropertiesListItem name="room" type="Room" required>
    The Liveblocks room, retrieved with [`useRoom`][] or [`client.enterRoom`][].
  </PropertiesListItem>
  <PropertiesListItem
    name="options.autoloadSubdocs"
    type="boolean"
    defaultValue="false"
  >
    This option will load subdocs automatically.
  </PropertiesListItem>
  <PropertiesListItem
    name="options.enablePermanentUserData"
    type="boolean"
    defaultValue="false"
  >
    This option enables Yjs permanent user data class used by some libraries for
    tracking changes by author.
  </PropertiesListItem>
  <PropertiesListItem
    name="options.offlineSupport_experimental"
    type="boolean"
    defaultValue="false"
  >
    Experimental. Enable offline support using IndexedDB. This means that after
    the first load, documents will be stored locally and load instantly.
  </PropertiesListItem>
  <PropertiesListItem
    name="options.useV2Encoding_experimental"
    type="boolean"
    defaultValue="false"
  >
    Experimental. Use V2 encoding.
  </PropertiesListItem>
</PropertiesList>

## LiveblocksYjsProvider [#LiveblocksYjsProvider]

`LiveblocksYjsProvider` is a
[Yjs provider](https://github.com/yjs/yjs#providers) that allows you to connect
a Yjs document to Liveblocks. Any changes you make to the document will be
stored on Liveblocks servers and synchronized with other clients in the room.

<Banner title="Not recommended to use directly" type="warning">

We generally recommend getting your Liveblocks Yjs provider with
[`getYjsProviderForRoom`][] as it overcomes problems caused when dynamically
switching between rooms.

</Banner>

You can connect by creating a Yjs document, then passing it to
`LiveblocksYjsProvider` along with the currently connected Liveblocks room.

```ts highlight="13-15"
import * as Y from "yjs";
import { createClient } from "@liveblocks/client";
import { LiveblocksYjsProvider } from "@liveblocks/yjs";

const client = createClient({
  publicApiKey: "{{PUBLIC_KEY}}",
});

const { room, leave } = client.enterRoom("your-room-id");

// Create Yjs document and provider
const yDoc = new Y.Doc();
const yProvider = new LiveblocksYjsProvider(room, yDoc, {
  // Options
  // ...
});
```

<PropertiesList title="Arguments">
  <PropertiesListItem name="room" type="Room" required>
    The Liveblocks room, retrieved with [`useRoom`][] or [`client.enterRoom`][].
  </PropertiesListItem>
  <PropertiesListItem name="yDoc" type="Y.Doc" required>
    The [`Y.Doc`][] for the document.
  </PropertiesListItem>
  <PropertiesListItem
    name="options.autoloadSubdocs"
    type="boolean"
    defaultValue="false"
  >
    This option will load subdocs automatically.
  </PropertiesListItem>
  <PropertiesListItem
    name="options.enablePermanentUserData"
    type="boolean"
    defaultValue="false"
  >
    This option enables Yjs permanent user data class used by some libraries for
    tracking changes by author.
  </PropertiesListItem>
  <PropertiesListItem
    name="options.offlineSupport_experimental"
    type="boolean"
    defaultValue="false"
  >
    Experimental. Enable offline support using IndexedDB. This means the after
    the first load, documents will be stored locally and load instantly.
  </PropertiesListItem>
  <PropertiesListItem
    name="options.useV2Encoding_experimental"
    type="boolean"
    defaultValue="false"
  >
    Experimental. Use V2 encoding.
  </PropertiesListItem>
</PropertiesList>

### LiveblocksYjsProvider.getYDoc

Returns the current roomâ€™s root [`Y.Doc`][].

```ts
// Root Y.Doc for the room
const yDoc = yProvider.getYDoc();
```

### LiveblocksYjsProvider.awareness [#LiveblocksYjsProvider.awareness]

The [awareness](#Awareness) instance attached to the provider.

```ts
// Yjs awareness
const awareness = yProvider.awareness;
```

### LiveblocksYjsProvider.destroy

Cleanup function. Destroys the [`LiveblocksYjsProvider`][] instance and removes
all resources.

```ts
// Clean up yProvider
yProvider.destroy();
```

### LiveblocksYjsProvider.on("sync") [#LiveblocksYjsProvider.on.sync]

Add an event listener for the `sync` event. The `sync` event is triggered when
the client has received content from the server. Can be used to fire events when
the document has loaded.

```ts
// Listen for the sync event
yProvider.on("sync", (isSynced: boolean) => {
  if (isSynced === true) {
    // Yjs content is synchronized and ready
  } else {
    // Yjs content is not synchronized
  }
});
```

Aliased by `LiveblocksYjsProvider.on("synced")`.

```ts
// "sync" and "synced" both listen to the same event
yProvider.on("sync", (sync: boolean) => /* ... */);
yProvider.on("synced", (sync: boolean) => /* ... */);
```

### LiveblocksYjsProvider.off("sync") [#LiveblocksYjsProvider.off.sync]

Remove an event listener for the `sync` event. The `sync` event is triggered
when the client has received content from the server. Used to clean up
[`LiveblocksYjsProvider.on("sync")`][].

```ts
const handleSync = (synced: boolean) => {};
yProvider.on("sync", handleSync);

// Clean up sync event
yProvider.off("sync", handleSync);
```

Aliased by `LiveblocksYjsProvider.on("synced")`.

```ts
// "sync" and "synced" both listen to the same event
yProvider.off("sync", (sync: boolean) => /* ... */);
yProvider.off("synced", (sync: boolean) => /* ... */);
```

### LiveblocksYjsProvider.once("sync") [#LiveblocksYjsProvider.once.sync]

Add a one-time event listener for the `sync` event. The `sync` event is
triggered when the client has received content from the server. Can be used to
fire events when the document has loaded.

```ts
// Listen for the sync event only once
yProvider.once("sync", (isSynced: boolean) => {
  if (isSynced === true) {
    // Yjs content is synchronized and ready
  } else {
    // Yjs content is not synchronized
  }
});
```

Aliased by `LiveblocksYjsProvider.once("synced")`.

```ts
// "sync" and "synced" both listen to the same event
yProvider.once("sync", (sync: boolean) => /* ... */);
yProvider.once("synced", (sync: boolean) => /* ... */);
```

### LiveblocksYjsProvider.emit("sync") [#LiveblocksYjsProvider.emit.sync]

Synchronously call each listener for the `sync` event in the order they were
registered, passing the supplied arguments to each.

```ts
// Call each listener and pass `true` as an argument
yProvider.emit("sync", true);
```

Aliased by `LiveblocksYjsProvider.emit("synced")`.

```ts
// "sync" and "synced" both listen to the same event
yProvider.emit("sync" /* , ... */);
yProvider.emit("synced" /* , ... */);
```

### LiveblocksYjsProvider.synced [#LiveblocksYjsProvider.synced]

Boolean. Returns whether the client is synchronized with the back end.

```ts
// Check if Yjs content is synchronized with the server
const isSynced: boolean = yProvider.synced;
```

### LiveblocksYjsProvider.connect [#LiveblocksYjsProvider.connect]

Does nothing, added for compatibility. Connections are handled by the
[Liveblocks client](https://liveblocks.io/docs/api-reference/liveblocks-client#createClient).

### LiveblocksYjsProvider.disconnect [#LiveblocksYjsProvider.disconnect]

Does nothing, added for compatibility. Connections are handled by the
[Liveblocks client](https://liveblocks.io/docs/api-reference/liveblocks-client#createClient).

## Awareness [#Awareness]

[`LiveblocksYjsProvider`][] instances have an `awareness` property, which is
powered by
[Liveblocks Presence](/docs/api-reference/liveblocks-client#Room.getPresence).
You can pass it to various bindings which implement awareness, for example
plugins that enable multiplayer cursors in text editors.

```ts
const yDoc = new Y.Doc();
const yProvider = new LiveblocksYjsProvider(room, yDoc);

// Yjs awareness
const awareness = yProvider.awareness;
```

Because awareness is part of presence, itâ€™s also accessible with
[`room.getPresence`][] and [`useMyPresence`][] under the `__yjs` property.

```ts
// Yjs awareness
const awareness = room.getPresence().__yjs;
```

### Awareness.doc [#Awareness.doc]

The Yjs document that the current awareness instance is attached to.

```ts
// The current Yjs document
const yDoc: Y.Doc = awareness.doc;
```

### Awareness.clientId [#Awareness.clientId]

A unique number identifying which client this awareness object is attached to.

```ts
// A unique number representing the current user
const clientId: number = awareness.clientId;
```

### Awareness.getLocalState [#Awareness.getLocalState]

Get the current userâ€™s awareness state.

```ts
// The current userâ€™s awareness
const localState: unknown = awareness.getLocalState();
```

### Awareness.setLocalState [#Awareness.setLocalState]

Set the current userâ€™s awareness state. Accepts JSON-compatible objects.

```ts
// Set the current userâ€™s awareness
awareness.setLocalState({
  user: {
    name: "Jonathan",
  },
});
```

### Awareness.setLocalStateField [#Awareness.setLocalStateField]

Set a single property in the current userâ€™s awareness state. Accepts
JSON-compatible objects, or `null` to remove a property.

```ts
// Set a single property on the current userâ€™s awareness
awareness.setLocalStateField("user", { name: "Jonathan" });
```

### Awareness.getStates [#Awareness.getStates]

Returns a `Map` of states for each client, with each userâ€™s unique `clientId` as
the key.

```ts
// A Map of each userâ€™s awareness state
const states: Map<number, unknown> = awareness.getStates();
```

### Awareness.states [#Awareness.states]

A `Map` of states for each client, with each userâ€™s unique `clientId` as the
key.

```ts
// A Map of each userâ€™s awareness state
const states: Map<number, unknown> = awareness.states;
```

### Awareness.meta [#Awareness.meta]

Provided for compatibility, but generally not necessary. This would be used for
handling user awareness timeouts, but internally awareness uses Liveblocks
Presence, and this handles it for you.

```ts
const meta: Map<number, { click: number; lastUpdated: number }> =
  awareness.meta;
```

### Awareness.destroy [#Awareness.destroy]

Provided for compatibility, but generally not necessary. Cleanup function.
Destroys the [`Awareness`][] instance and removes all resources. Used internally
by [`LiveblocksYjsProvider`][].

```ts
// Cleanup function
awareness.destroy();
```

### Awareness.on("destroyed") [#Awareness.on.destroyed]

Provided for compatibility, but generally not necessary. Add an event listener
for the `destroy` event. The `destroy` event is triggered when
[`awareness.destroy`][] has been called.

```ts
awareness.on("destroyed", () => {
  // Awareness has been cleaned up
});
```

### Awareness.off("destroyed") [#Awareness.off.destroyed]

Provided for compatibility, but generally not necessary. Remove an event
listener for the `destroy` event. The `destroy` event is triggered when
[`awareness.destroy`][] has been called. Used to clean up
[`Awareness.on("destroyed")`.]

```ts
const handleDestroy = () => {};
awareness.on("destroyed", handleDestroy);

// Clean up destroy event
awareness.off("destroyed", handleDestroy);
```

### Awareness.once("destroyed") [#Awareness.once.destroyed]

Provided for compatibility, but generally not necessary. Add a one-time event
listener for the `destroy` event. The `destroy` event is triggered when
[`awareness.destroy`][] has been called.

```ts
awareness.once("destroyed", () => {
  // Awareness has been cleaned up
});
```

### Awareness.emit("destroyed") [#Awareness.emit.destroyed]

Synchronously call each listener for the `destroy` event in the order they were
registered, passing the supplied arguments to each.

```ts
// Call each listener and pass `true` as an argument
awareness.emit("destroy", true);
```

[`@liveblocks/react`]: /docs/api-reference/liveblocks-react
[`useRoom`]: /docs/api-reference/liveblocks-react#useRoom
[`room.getPresence`]: /docs/api-reference/liveblocks-client#Room.getPresence
[`client.enterRoom`]: /docs/api-reference/liveblocks-client#Client.enterRoom
[`useMyPresence`]: /docs/api-reference/liveblocks-react#useMyPresence
[`getYjsProviderForRoom`]: #getYjsProviderForRoom
[`LiveblocksYjsProvider`]: #LiveblocksYjsProvider
[`LiveblocksYjsProvider.awareness]: #LiveblocksYjsProvider.awareness
[`LiveblocksYjsProvider.destroy]: #LiveblocksYjsProvider.destroy
[`LiveblocksYjsProvider.on("sync")`]: #LiveblocksYjsProvider.on.sync
[`LiveblocksYjsProvider.off("sync")`]: #LiveblocksYjsProvider.off.sync
[`LiveblocksYjsProvider.once("sync")`]: #LiveblocksYjsProvider.once.sync
[`LiveblocksYjsProvider.emit("sync")`]: #LiveblocksYjsProvider.emit.sync
[`LiveblocksYjsProvider.synced`]: #LiveblocksYjsProvider.synced
[`LiveblocksYjsProvider.connect`]: #LiveblocksYjsProvider.connect
[`LiveblocksYjsProvider.disconnect`]: #LiveblocksYjsProvider.disconnect
[`Awareness`]: #Awareness
[`Awareness.doc`]: #Awareness.doc
[`Awareness.clientId]: #Awareness.clientId
[`Awareness.getLocalState`]: #Awareness.getLocalState
[`Awareness.setLocalState`]: #Awareness.setLocalState
[`Awareness.setLocalStateField`]: #Awareness.setLocalStateField
[`Awareness.getStates`]: #Awareness.getStates
[`Awareness.states`]: #Awareness.states
[`Awareness.destroy`]: #Awareness.destroy
[`Awareness.meta`]: #Awareness.meta
[`Awareness.on("destroyed")`]: #Awareness.on.destroyed
[`Awareness.off("destroyed")`]: #Awareness.off.destroyed
[`Awareness.once("destroyed")`]: #Awareness.once.destroyed
[`Awareness.emit("destroyed")`]: #Awareness.emit.destroyed
[`Y.Doc`]: https://docs.yjs.dev/api/y.doc

---
meta:
  title: "@liveblocks/zustand"
  parentTitle: "API Reference"
  description: "API Reference for the @liveblocks/zustand package"
alwaysShowAllNavigationLevels: false
---

`@liveblocks/zustand` provides you with [Zustand](https://docs.pmnd.rs/zustand)
bindings for our realtime collaboration APIs, built on top of WebSockets. Read
our [getting started](/docs/get-started) guides to learn more.

## Middleware

The `liveblocks` middleware lets you connect a Zustand state to Liveblocks
Presence and Storage features.

```js highlight="2,5,9-13"
import create from "zustand";
import { liveblocks } from "@liveblocks/zustand";

const useStore = create(
  liveblocks(
    (set) => ({
      /* state and actions */
    }),
    {
      client,
      presenceMapping: {},
      storageMapping: {},
    }
  )
);
```

<PropertiesList title="Arguments">
  <PropertiesListItem name="stateCreator" type="StateCreator">
    The Zustand state creator function.
  </PropertiesListItem>
  <PropertiesListItem name="options" type="LiveblocksMiddlewareOptions">
    Configuration object for the Liveblocks middleware.
  </PropertiesListItem>
</PropertiesList>

<PropertiesList title="Options">
  <PropertiesListItem name="client" type="Client">
    The Liveblocks client instance created with `createClient()`.
  </PropertiesListItem>
  <PropertiesListItem name="presenceMapping" type="PresenceMapping">
    Optional mapping to synchronize Zustand state with Liveblocks presence.
  </PropertiesListItem>
  <PropertiesListItem name="storageMapping" type="StorageMapping">
    Optional mapping to synchronize Zustand state with Liveblocks storage.
  </PropertiesListItem>
</PropertiesList>

### client [#middleware-option-client]

See different authentication methods in the [`createClient`][] method.

```js
import { createClient } from "@liveblocks/client";
import { liveblocks } from "@liveblocks/zustand";

const client = createClient({
  authEndpoint: "/api/liveblocks-auth",
});

liveblocks(/* Zustand config */, { client })
```

### presenceMapping [#middleware-option-presence-mapping]

Mapping used to synchronize a part of your Zustand state with one Liveblocks
Room presence.

```js highlight="8"
const useStore = create(
  liveblocks(
    (set) => ({
      cursor: { x: 0, y: 0 },
    }),
    {
      client,
      presenceMapping: { cursor: true },
    }
  )
);
```

### storageMapping [#middleware-option-storage-mapping]

Mapping used to synchronize a part of your Zustand state with one Liveblocks
room storage.

```js highlight="8"
const useStore = create(
  liveblocks(
    (set) => ({
      scientist: { name: "" },
    }),
    {
      client,
      storageMapping: { scientist: true },
    }
  )
);
```

## state.liveblocks [#liveblocks-state]

Liveblocks extra state attached by the liveblocks.

### enterRoom [#liveblocks-state-enter-room]

Enters a room and starts syncing it with your Zustand state.

- `roomId`: The roomâ€™s ID.

```js
const {
  liveblocks: { enterRoom },
} = useStore();

enterRoom("roomId");
```

<PropertiesList title="Arguments">
  <PropertiesListItem name="roomId" type="string">
    The ID of the room to enter.
  </PropertiesListItem>
</PropertiesList>

If this is the first time you're entering the room, the room is initialized from
your local Zustand state (only for the keys mentioned in your `storageMapping`
configuration).

### leaveRoom [#liveblocks-state-leave-room]

Leaves the current room and stops syncing it with Zustand state.

```js
const {
  liveblocks: { leaveRoom },
} = useStore();

leaveRoom();
```

<PropertiesListEmpty title="Arguments">_None_</PropertiesListEmpty>

### room [#liveblocks-state-room]

The [`Room`][] currently synced to your Zustand state.

```js
const {
  liveblocks: { room },
} = useStore();
```

### others [#liveblocks-state-others]

Other users in the room. Empty when no room is currently synced.

```js
const {
  liveblocks: { others },
} = useStore();
```

### isStorageLoading [#liveblocks-state-is-storage-loading]

Whether or not the room storage is currently loading.

```js
const {
  liveblocks: { isStorageLoading },
} = useStore();
```

### status [#liveblocks-state-status]

Gets the current WebSocket connection status of the room.

```js
const {
  liveblocks: { status },
} = useStore();
```

The possible values are: `initial`, `connecting`, `connected`, `reconnecting`,
or `disconnected`.

[`createclient`]: /docs/api-reference/liveblocks-client#createClient
[`room`]: /docs/api-reference/liveblocks-client#room
[`status`]: /docs/api-reference/liveblocks-zustand#liveblocks-state-status

---
meta:
  title: "Troubleshooting"
  parentTitle: "Platform"
  description: "Troubleshoot common errors"
---

## Common issues [#common]

<Banner title="Need help troubleshooting?">

Try the [Liveblocks DevTools extension](/devtools) to visualize your
collaborative experiences as you build them, in realtime.

</Banner>

### ReferenceError: process is not defined [#process-not-defined]

When calling `client.enterRoom()`, you stumble upon the following error:

```text
ReferenceError: process is not defined
```

The `@liveblocks/client` package expects to be consumed by a JavaScript bundler,
like Webpack, Babel, ESbuild, Rollup, etc. If you see this error, you have most
likely directly loaded the `@liveblocks/client` source code through a `<script>`
tag.

#### Solution [#process-not-defined-solution] [@hidden]

If using a bundler isnâ€™t possible for you, there are two available solutions.

One solution is to load the source code from the
[Skypack CDN](https://www.skypack.dev/view/@liveblocks/client), which will
expose optimized production builds which have the `process` variable removed.

Another solution is to define the necessary `process.env.NODE_ENV` variable
manually, before loading the script, for example:

```ts
globalThis.process = { env: { NODE_ENV: "production" } };
```

### Why weâ€™re asking you to pass unstable_batchedUpdates [#stale-props-zombie-child]

<Banner title="The best solution is to upgrade to React 18">

The last version of Liveblocks that supports the old React 17 version is 2.14.0.
To upgrade Liveblocks to 2.15 or higher, first upgrade React to 18.

Passing in `unstable_batchedUpdates` is no longer necessary on the latest
version of Liveblocks.

</Banner>

If youâ€™re **on React 17 or lower**, there is a well-known problem that all state
management libraries need to deal with at some point, known as the
["Stale-props / zombie-child" problem](https://kaihao.dev/posts/Stale-props-and-zombie-children-in-Redux)â€”Liveblocks
is no exception.

This issue can cause catastrophic bugs, inconsistent renders, orâ€”in the best
caseâ€”performance issues. Sooner or later, as your app grows in complexity, you
will run into some manifestation of this bug, and we want to be ahead of that.

Just do either of the following to avoid it!

1. **Just upgrade to React 18** (recommended)
1. If you cannot upgrade just yet, we ask you to pass the
   `unstable_batchedUpdates` function to the RoomProvider in the mean time, so
   Liveblocks can circumvent the issue on your behalf!

```tsx highlight="1,7"
import { unstable_batchedUpdates } from "react-dom";
//                                      ^^^^^^^^^^^ ...or "react-native"!
<RoomProvider
  id="my-room"
  initialPresence={/* ... */}
  initialStorage={/* ... */}
  unstable_batchedUpdates={unstable_batchedUpdates}
>
  <App />
</RoomProvider>;
```

Starting with 0.18.3, this will be enforced in React 17 and lower, potentially
saving hours of debugging.

#### Whatâ€™s the problem, exactly? [#stale-props-zombie-child-details] [@hidden]

If youâ€™re on React 17 or lower, state updates from â€œexternalâ€ (non-DOM) events
will **not** get batched together automatically. If two or more of your
components subscribe to the same piece of state, and this state gets updated by
another user in the room, then both components will individually rerender,
separately.

In most cases this is just inefficient but not catastrophic. However, if you
happen to have a parent and child component that both rely on the same state,
this can lead to hard-to-debug bugs.

For example:

```tsx highlight="2,7"
function Parent() {
  const shapes = useStorage((root) => root.shapes);
  return shapes.map(({ id }) => <Child key={id} id={id} />);
}

function Child({ id }) {
  const shape = useStorage((root) => root.shapes.get(id));
  return <Shape x={shape.x} y={shape.y} />;
}
```

Both of these components need to get rerendered if, for example, some shape gets
deleted by another user in the room.

In React 17 (or lower), those rerenders will **not get batched together** and as
such they will not rerender together. Instead, they rerender individually,
separately. Which component rerenders first is undefined and often unpredictable
in larger apps. If youâ€™re unlucky, this can lead to the Child component to get
rerendered before its Parent has had the opportunity to unmount it, which should
of course never happen.

By providing `unstable_batchedUpdates` to the RoomProvider, Liveblocks will wrap
all state updates in this helper, which will make sure that both Parent and
Child get rerendered as part of the same render cycle. This way, React will
ensure that the Parent component will always get rerendered before the Child.

## TypeScript issues [#typescript]

### Type "MyInterface" does not satisfy the constraint "Lson" [#lson-constraint-and-interfaces] [@keywords=["TS2344", "Lson", "LsonObject", "index signature missing"]]

If you found this page, chances are you stumbled upon this TypeScript error:

```text
TS2344: Type 'MyInterface' does not satisfy the constraint 'Lson'.
  Type 'MyInterface' is not assignable to type 'JsonObject'.
    Index signature for type 'string' is missing in type 'MyInterface'.
```

Liveblocks data structures (like `LiveObject`, `LiveMap`, and `LiveList`)
require that their payloads are always JSON-serializable to be able to send them
over WebSocket connections reliably and without surprises. Starting with 0.16,
weâ€™re enforcing this with `Lson` type constraint. (LSON is a Liveblocks-specific
extension of JSON that also allows nesting more Live data structures.)

If you encounter this error above, TypeScript is trying to tell you that the
data type you are using in one of your Live structures is not (guaranteed to be)
a legal LSON (or JSON) value. But why?

```ts
interface Person {
  name: string;
  age: number;
}

const people = new LiveList<Person>();
//                          ~~~~~~
//                          TS2344: Type "Person" does not
//                          satisfy the constraint "Lson" â˜¹ï¸
```

Although this `Person` type seems perfectly JSON-serializable with only those
`string` and `number` fields, TypeScript still considers this a problem because
it cannot _guarantee_ that all of its subtypes will also be that. Interface
types are "open" and extensible by design. This means itâ€™s possible to define a
subtype that would still not be JSON-serializable.
[Example](https://www.typescriptlang.org/play?#code/JYOwLgpgTgZghgYwgAgArQM4HsTIN4BQyyIcAthAFzIZhSgDmA3EcnA1SQK5kBG0LAL4ECAelHIAanAA2XCBmRYYyAAYBRAG7AZ6KNhCrkZYAwAWYElkv9kAKQDKAeQByAWgzRgs4AC84vDIQADRiEgCeEJZwUCi0OjLImj4AJmp6BqoYBKCQsIgoWjoZOMgQAB6QICmKJbiExOLIgLwbgBB7rCDWDl4+-oGcXCAA1p0A7iBMjRIARIMjWOPTyDDAEDI1xqYWVjZxPTJ+AUEEwkA).

To fix this issue, there are roughly three available solutions.

#### Solution 1: Change your interface to a type [#lson-interface-solution1] [@hidden]

The simplest solution is to convert your `interface` to a `type`.

```ts highlight="1"
type Person = {
  name: string;
  age: number;
};

const people = new LiveList<Person>();
//                          ^^^^^^ âœ… All good now
```

Check this solution out in the TypeScript
[playground](https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbzgGWANwKaoM7wL5wBmUEIcA5AAIA26GARtRAMYDW2A9M7RgHYzkA3AChhMAJ5gMcAAoYo2CLzgBeRMLhxeAQxAYAXHFxRgvAOYjN2swa0BXEPXki8I4cyW44UiGGrS1XgwAdxQ6HBgAHjkFJQA+AAoAShEODk0MzKzs7IA9fIK4QFByOABBamo4MwgIABMtCGDhIA).

#### Solution 2: Extend your interface [#lson-interface-solution2] [@hidden]

You can also explicitly pledge that your interface will be JSON serializable by
having it extend from `JsonObject`.

```ts highlight="1,3"
import { JsonObject } from "@liveblocks/client";

interface Person extends JsonObject {
  name: string;
  age: number;
}

const people = new LiveList<Person>();
//                          ^^^^^^ âœ… All good now
```

Check this solution out in the TypeScript
[playground](https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbzgGWANwKaoM4wDRwBS2EAdgPIBGAVhgMbwC+cAZlBCHAOQACANugyU+EOgGtsAejoCMpGFwDcAKGXB5GKCwCGdDHAAKmkqTgYAHjDkATbERNVaDRMrhxS2kBgBccXFHUAcxU3bUCfdwBXEEpNFUYVZToyXDgwDAgwPn0AXncMAHcUQRwYAB4jKBMAPgAKAEoVSUk3Vrb2jo6APR7euEBQcjgAQT4+OECICGt3CALlIA).

#### Solution 3: Wrap the interface in a helper [#lson-interface-solution3] [@hidden]

This is the least preferred solution, but may be necessary if you donâ€™t own the
interface definition and itâ€™s coming from an external package.

```ts highlight="1,4"
import type { LiveList, EnsureJson } from "@liveblocks/client";
import { Person } from "some-external-package";

const people = new LiveList<EnsureJson<Person>>();
//                          ^^^^^^^^^^^^^^^^^^ âœ… All good now
```

Check this solution out in the TypeScript
[playground](https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbzgGWANwKaoM4wDRwCiAdtgK5QYBS2ExcAvnAGZQQhwDkAAgDboYARrwgBjANbYA9KP4ZiMTgG4AUKEixEcACoARAKrYMURizYceMXgBMoAQwDuUq7cfKVUqXG8+4APQDAuAAlO2JrdjhgBWNmO1EMOBgATzBE1kj7cMiMAA8YY2I7XjgwePE7AHMMFRVROlw4MiMobDgAXjhiDAcUARwYAB4SckoaOkG9Q2MAPhmACgBKVSA).

---
meta:
  title: "Authentication"
  description: "Authenticate your users in your application with ID tokens."
---

For production applications, we recommend using your secret API key to
authenticate users with **ID tokens**. Your public API key is only for
prototyping and public applications.

## Quickstart

<ListGrid columns={3}>
  <DocsCard
    title="Next.js"
    href="/docs/authentication/id-token/nextjs"
    visual={<DocsNextjsIcon />}
  />
  <DocsCard
    title="Remix"
    href="/docs/authentication/id-token/remix"
    visual={<DocsRemixIcon />}
  />
  <DocsCard
    title="SvelteKit"
    href="/docs/authentication/id-token/sveltekit"
    visual={<DocsSvelteIcon />}
  />
  <DocsCard
    title="Nuxt.js"
    href="/docs/authentication/id-token/nuxtjs"
    visual={<DocsNuxtjsIcon />}
  />
  <DocsCard
    title="Express"
    href="/docs/authentication/id-token/express"
    visual={<DocsExpressIcon />}
  />
  <DocsCard
    title="Firebase"
    href="/docs/authentication/id-token/firebase"
    visual={<DocsFirebaseIcon />}
  />
</ListGrid>

---

## How ID token authentication works

ID token authentication allows Liveblocks to handle permissions for you. This
means that when you create or modify a room, you can set a userâ€™s permissions on
the room itself. This means the room acts as a source of truth. Later, when a
user tries to enter a room, Liveblocks will automatically check if the user has
permission, and deny them access if the permissions arenâ€™t set.

Permissions arenâ€™t just for individual users, but can also be set for groups of
users, or for the whole room at once.

<Figure>
  <Image
    src="/assets/authentication/id-token-enter-room.png"
    alt="An ID token granting entry to a room"
    width={1494}
    height={840}
    quality={100}
  />
</Figure>

<Banner title="You prefer to handle permissions yourself?">

If you donâ€™t need fine-grained permissions, or if youâ€™d prefer storing
individual room permissions in your own system, you can use
[access tokens](/docs/authentication/access-token) instead.

</Banner>

## Authenticating

Authenticating with ID tokens means creating a
[JSON Web Token](https://en.wikipedia.org/wiki/JSON_Web_Token) (JWT) thatâ€™s used
to verify the identity of the current user when connecting to a Liveblocks room.
This token is created using
[`liveblocks.identifyUser`](/docs/api-reference/liveblocks-node#id-tokens) or
[`/identify-user`](/docs/api-reference/rest-api-endpoints#post-identify-user).

```ts
const { body, status } = await liveblocks.identifyUser({
  userId: "olivier@example.com",
});

// '{ token: "eyJga7..." }'
console.log(body);
```

## Workspace permissions [#permissions]

Using [tenants](/docs/authentication/tenants), you can create workspaces in your
application, compartmentalizing all resources such as inbox notifications and
rooms. This includes everything associated with rooms such as comment threads,
realtime data stored, and more. This allows you to add a workspace switcher to
your application, separating each of your customers/organizations.

<Figure>
  <Image
    src="/assets/authentication/org-switcher.png"
    alt="A workspace switcher"
    width={1600}
    height={1000}
    quality={90}
  />
</Figure>

### Set up workspace permissions

To set up workspace permissions, pass a `tenantId` when authenticating a user,
ensuring that the user will only have access to resources within this workspace.

```ts
const { body, status } = await liveblocks.identifyUser({
  userId: "olivier@example.com",
  // +++
  tenantId: "my-tenant-id",
  // +++
});

// '{ token: "eyJga7..." }'
console.log(body);
```

When creating a resource on the server, such as a room, pass the `tenantId` to
the resource, to allow the user access.

```ts
const room = await liveblocks.createRoom("my-room-id", {
  defaultAccesses: ["room:write"],
  // +++
  tenantId: "my-tenant-id",
  // +++
});

// { type: "room", id: "my-room-id", metadata: {...}, ... }
console.log(room);
```

## Room permissions

ID token authentication allows you to set different permission types on rooms,
assigned at three different levels: default, groups, and users. The system is
flexible enough to enable you to build a permission system thatâ€™s helpful for
building invite dialogs, private rooms, and more.

<Figure>
  <img
    src="/assets/managing-rooms/rooms-share-dialog.png"
    alt="Share dialog illustration"
  />
</Figure>

To set room permissions, you can
[create](/docs/api-reference/liveblocks-node#post-rooms) or
[update](/docs/api-reference/liveblocks-node#post-rooms-roomId) a room, passing
permission information in the options.

```ts
const room = await liveblocks.createRoom("a32wQXid4A9", {
  // This is a private room
  defaultAccesses: [],

  // But Olivier can enter
  usersAccesses: {
    "olivier@example.com": ["room:read"],
  },
});
```

### Permission types [#permission-types]

There are three permission values that you can set on rooms.

<dl>
  <dt>`["room:write"]`</dt>
  <dd>
    Full access. Enables people to view and edit the room. On the client,
    [`canWrite`](/docs/api-reference/liveblocks-react#Checking-user-permissions)
    is `true`.
  </dd>
  <dt>`["room:read", "room:presence:write"]`</dt>
  <dd>
    Read access with presence. Enables people to edit their presence, but only
    view the room&rsquo;s storage. On the client,
    [`canWrite`](/docs/api-reference/liveblocks-react#Checking-user-permissions)
    is `false`.
  </dd>
  <dt>`[]`</dt>
  <dd>Private. No one can enter the room.</dd>
</dl>

### Permission levels [#permission-types]

Permission types can be applied at three different levels, enabling complex
entry systems.

<dl>
  <dt>defaultAccesses</dt>
  <dd>The default permission types to apply to the entire room.</dd>
  <dt>groupsAccesses</dt>
  <dd>Permission types to apply to specific groups of users.</dd>
  <dt>usersAccesses</dt>
  <dd>Permission types to apply to specific users.</dd>
</dl>

Each level further down will override access levels defined above, for example a
room with private access will allow a user with `room:write` access to enter.

### Default room permissions

The `defaultAccesses` level is used to set the default permissions of the entire
room.

<Figure>
  <Image
    src="/assets/managing-rooms/rooms-access-denied.png"
    alt="Access denied illustration"
    width={820}
    height={412}
  />
</Figure>

When used in our APIs, this property takes an array, with an empty array `[]`
signifying no access. Add permission types to this array to define the default
access level to your room.

```ts
// Private - no one has access by default
"defaultAccesses": []

// Public - everyone can edit and view the room
"defaultAccesses": ["room:write"]

// Read-only - everyone can view the room, but only presence can be edited
"defaultAccesses": ["room:read", "room:presence:write"]
```

#### Setting room access

We can use the
[`liveblocks.createRoom`](/docs/api-reference/rest-api-endpoints#post-rooms) to
create a new room with public access levels:

```ts highlight="2"
const room = await liveblocks.createRoom("a32wQXid4A9", {
  defaultAccesses: ["room:write"],
});
```

The default permission types can later be modified with
[`liveblocks.updateRoom`](/docs/api-reference/liveblocks-node#post-rooms-roomId),
in this example turning the room private:

```ts highlight="2"
const room = await liveblocks.updateRoom("a32wQXid4A9", {
  defaultAccesses: [],
});
```

### Groups permissions

The `groupsAccesses` level is used to set the default permissions of any given
group within room.

<Figure>
  <video autoPlay loop muted playsInline>
    <source src="/assets/managing-rooms/rooms-groups.mp4" type="video/mp4" />
  </video>
</Figure>

Groups are represented by a `groupId`â€”a custom string that represents a
selection of users in your app. Groups can be attached to a user by passing an
array of `groupId` values in `groupIds`, during authentication.

```js highlight="10"
import { Liveblocks } from "@liveblocks/node";

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

export async function POST(request: Request) {
  const { status, body } = await liveblocks.identifyUser({
    userId: "marie@example.com",
    groupIds: ["engineering"],
  });

  return new Response(body, { status });
}
```

In our APIs you can then set group accesses by using the `groupId` as the key,
and an array of permissions as the value.

```ts
// "engineering" group has access to view and edit
"groupsAccesses": {
  "engineering": ["room:write"],
}
```

#### Modifying group access [#permissions-levels-groups-accesses-example]

To allow an â€œengineeringâ€ group access to view a room, and modify their
presence, we can use
[`liveblocks.updateRoom`](/docs/api-reference/liveblocks-node#post-rooms-roomId)
with `engineering` as a `groupId`:

```ts highlight="3"
const room = await liveblocks.updateRoom("a32wQXid4A9", {
  groupsAccesses: {
    engineering: ["room:read", "room:presence:write"],
  },
});
```

After calling this, every user in the â€œengineeringâ€ group will have read-only
access. To remove a groupâ€™s permissions, we can use
[`liveblocks.updateRoom`](/docs/api-reference/liveblocks-node#post-rooms-roomId)
again, and set the permission type to `null`:

```ts highlight="7"
const room = await liveblocks.updateRoom("a32wQXid4A9", {
  groupsAccesses: {
    engineering: null,
  },
});
```

### User permissions

The `usersAccesses` level is used to set permissions of any given user within a
room.

<Figure>
  <Image
    src="/assets/managing-rooms/rooms-share-dialog.png"
    alt="Share dialog illustration"
    width={820}
    height={412}
  />
</Figure>

To use this, first a user is given a `userId` during authentication.

```js highlight="9"
import { Liveblocks } from "@liveblocks/node";

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

export async function POST(request: Request) {
  const { status, body } = await liveblocks.identifyUser({
    userId: "ellen@acme.inc",
  });

  return new Response(body, { status });
}
```

Then, if you want the user with the `userId` id to make edits, set `userId` to
`["room:write"]` within `usersAccesses` when creating or updating a room.

```ts
// user with userId "ellen@acme.inc" has access to view and edit
"usersAccesses": {
  "ellen@acme.inc": ["room:write"]
}
```

#### Checking user access [#permissions-levels-users-accesses-example]

To give them room permission, we can use
[`liveblocks.updateRoom`](/docs/api-reference/liveblocks-node#post-rooms-roomId),
setting write access on their `userId`:

```ts highlight="3"
const room = await liveblocks.updateRoom("a32wQXid4A9", {
  usersAccesses: {
    "ellen@acme.inc": ["room:write"],
  },
});
```

To check a userâ€™s assigned permission types for this room, we can then use
[`liveblocks.updateRoom`](/docs/api-reference/liveblocks-node#get-rooms-roomId)
and check `usersAccesses`:

```ts
const room = await liveblocks.getRoom("a32wQXid4A9");

// { "ellen@acme.inc": ["room:write"] }
console.log(room.data.usersAccesses);
```

## Select your framework [#select-your-framework]

Select your framework for specific instructions on setting up ID token
authentication.

<ListGrid columns={3}>
  <DocsCard
    title="Next.js"
    href="/docs/authentication/id-token/nextjs"
    visual={<DocsNextjsIcon />}
  />
  <DocsCard
    title="Remix"
    href="/docs/authentication/id-token/remix"
    visual={<DocsRemixIcon />}
  />
  <DocsCard
    title="SvelteKit"
    href="/docs/authentication/id-token/sveltekit"
    visual={<DocsSvelteIcon />}
  />
  <DocsCard
    title="Nuxt.js"
    href="/docs/authentication/id-token/nuxtjs"
    visual={<DocsNuxtjsIcon />}
  />
  <DocsCard
    title="Express"
    href="/docs/authentication/id-token/express"
    visual={<DocsExpressIcon />}
  />
  <DocsCard
    title="Firebase"
    href="/docs/authentication/id-token/firebase"
    visual={<DocsFirebaseIcon />}
  />
</ListGrid>

---
meta:
  title: "Authenticate users with access tokens"
  parentTitle: "Authentication"
  description: "Authenticate your users in your application with access tokens."
---

Access token authentication is an _alternative_ method to authenticate your
users in your application. With access tokens, when a user authenticates, itâ€™s
up to you to let Liveblocks know which rooms they should be allowed inside. This
means that you need to manually keep track of which users should be allowed in
which rooms, and apply these permissions yourself each time a user connects.

<Banner title="We recommend ID tokens over access tokens" type="warning">

Access tokens have [limitations when granting nested permissions](#limitations).
If youâ€™re looking to build an application with permissions at organization,
group, and user levels, we recommend using [ID tokens](/docs/authentication)
instead.

</Banner>

<Figure>
  <Image
    src="/assets/authentication/access-token-enter-room.png"
    alt="An access token granting entry to a room"
    width={1494}
    height={840}
    quality={100}
  />
</Figure>

## Authenticating

Authenticating with access tokens means creating a
[JSON Web Token](https://en.wikipedia.org/wiki/JSON_Web_Token) (JWT) that grants
the current user permission to enter certain rooms when connecting to
Liveblocks. An access token is created by calling
[`liveblocks.prepareSession`](/docs/api-reference/liveblocks-node#access-tokens)
then by allowing access to certain rooms.

```ts
const session = liveblocks.prepareSession("olivier@example.com");

// Giving write access to one room, then read access to multiple rooms with a wildcard
session.allow("design:9Hdu73", session.FULL_ACCESS);
session.allow("product:*", session.READ_ACCESS);

const { body, status } = await session.authorize();

// '{ token: "j6Fga7..." }'
console.log(body);
```

**Before using access tokens, itâ€™s recommended to read through this entire
page**, as it explains helpful practices for granting access to rooms. However,
if youâ€™d like to get set up now, you can select your framework and read more
later.

<ListGrid columns={3}>
  <DocsCard
    title="Next.js"
    href="/docs/authentication/access-token/nextjs"
    visual={<DocsNextjsIcon />}
  />
  <DocsCard
    title="Remix"
    href="/docs/authentication/access-token/remix"
    visual={<DocsRemixIcon />}
  />
  <DocsCard
    title="SvelteKit"
    href="/docs/authentication/access-token/sveltekit"
    visual={<DocsSvelteIcon />}
  />
  <DocsCard
    title="Nuxt.js"
    href="/docs/authentication/access-token/nuxtjs"
    visual={<DocsNuxtjsIcon />}
  />
  <DocsCard
    title="Express"
    href="/docs/authentication/access-token/express"
    visual={<DocsExpressIcon />}
  />
  <DocsCard
    title="Firebase"
    href="/docs/authentication/access-token/firebase"
    visual={<DocsFirebaseIcon />}
  />
</ListGrid>

## Workspace permissions [#permissions]

Using [tenants](/docs/authentication/tenants), you can create workspaces in your
application, compartmentalizing all resources such as inbox notifications and
rooms. This includes everything associated with rooms such as comment threads,
realtime data stored, and more. This allows you to add a workspace switcher to
your application, separating each of your customers/organizations.

<Figure>
  <Image
    src="/assets/authentication/org-switcher.png"
    alt="A workspace switcher"
    width={1600}
    height={1000}
    quality={90}
  />
</Figure>

### Set up workspace permissions

To set up workspace permissions, pass a `tenantId` when authenticating a user,
ensuring that the user will only have access to resources within this workspace.

```ts
const session = liveblocks.prepareSession("olivier@example.com", {
  // +++
  tenantId: "acme",
  // +++
});
```

When creating a resource on the server, such as a room, pass the `tenantId` to
the resource, to allow the user access.

```ts
const room = await liveblocks.createRoom("my-room-id", {
  defaultAccesses: ["room:write"],
  // +++
  tenantId: "acme",
  // +++
});

// { type: "room", id: "my-room-id", metadata: {...}, ... }
console.log(room);
```

## Room permissions

When granting permissions using access tokens, itâ€™s recommended to use a naming
pattern for your room IDs. This makes it easy to use wildcard permissions,
allowing you to authenticate access to multiple rooms at once. One scenario
where this is helpful, is when rooms and users in your app are part of a team or
group, and you need to permit users entry to each room thatâ€™s part of this.

### Group hierarchy

Letâ€™s picture a tenant in your product, Acme, set up using
[workspace permissions](#permissions). This customer has a number of group, and
each group contains a number of documents.

<Figure>
  <Image
    src="/assets/authentication/room-organizations.png"
    srcDark="/assets/authentication/room-organizations-dark.png"
    alt="An organization with documents in different teams"
    width={1536}
    height={864}
    quality={100}
  />
</Figure>

In your application, each group and document has a unique ID, and we can use
these to create a naming pattern for your rooms. For example, in the diagram
above, the Acme organization has a Product group (`product`) with two documents
inside (`6Dsw12`, `L2hr8p`).

### Naming pattern

An example of a naming pattern would be to combine these IDs into a unique room
ID separating them with symbols, such as `<group_id>:<document_id>`. A room ID
following this pattern may look like `product:6Dsw1z`.

<Figure>
  <Image
    src="/assets/authentication/room-name-pattern.png"
    srcDark="/assets/authentication/room-name-pattern-dark.png"
    alt="Splitting a room ID into the pattern detailed above"
    width={1536}
    height={864}
    quality={100}
  />
</Figure>

<Banner title="Example pattern">

This example is not a strict naming pattern you must follow, and you can use any
pattern you like. Take care to avoid using your separator character in any other
part of the room ID.

</Banner>

### Wildcard permissions

Assuming youâ€™re using the naming pattern displayed above, you can then grant
access to multiple rooms at once using wildcards.

<Figure>
  <Image
    src="/assets/authentication/access-token-room-naming.png"
    alt="An access token using a wildcard to access multiple rooms"
    width={1494}
    height={840}
    quality={100}
  />
</Figure>

In the image above, you can see that _Olivier_ has access to multiple _product_
rooms, thanks to the `product:*` wildcard rule. This is how he was authorized:

```ts
const session = liveblocks.prepareSession("olivier@example.com");

// Giving full access to one room
session.allow("design:9Hdu73", session.FULL_ACCESS);

// Give full access to every room with an ID beginning with "product:"
session.allow("product:*", session.FULL_ACCESS);

const { body, status } = await session.authorize();
```

Note that you can only use a wildcard at the end of a room ID.

```jsx
// âŒ Wildcard must be at the end of the room ID
session.allow("*:product", session.FULL_ACCESS);

// âœ… Valid wildcard
session.allow("product:*", session.FULL_ACCESS);
```

### Read-only access

Should we wish to grant read-only access to each room, we then add another line
to enable this.

```ts highlight="9-10"
const session = liveblocks.prepareSession("olivier@example.com");

// Giving full access to one room
session.allow("design:9Hdu73", session.FULL_ACCESS);

// Give full access to every room with an ID beginning with "product:"
session.allow("product:*", session.FULL_ACCESS);

// Give read-only access to every room in the current tenant
session.allow("*", session.READ_ACCESS);

const { body, status } = await session.authorize();
```

### Limitations [#limitations]

Thereâ€™s a limitation with access tokens related to granting access to individual
rooms that are part of groups. Letâ€™s say a user has been given access to every
`product` room in their tenants.

```tsx
// Access to every `product` room
session.allow("product:*", session.FULL_ACCESS);
```

This user is able to enter `product` rooms, but has no access to any `design`
rooms.

<Figure>
  <Image
    src="/assets/authentication/access-token-product-access.png"
    alt="An access token using a wildcard to access product rooms"
    width={1494}
    height={840}
    quality={100}
  />
</Figure>

Letâ€™s say the user is invited to a `design` room via share menuâ€”how would we
grant them access?

<Figure>
  <Image
    src="/assets/authentication/access-token-room-invite.png"
    alt="Inviting Olivier to the `design:9Hdu73` room"
    width={1494}
    height={840}
    quality={100}
  />
</Figure>

We canâ€™t give them access to _every_ `design` room with a wildcard, as they
should only have permission for _one_.

```tsx
// âŒ Access to every `design` room
session.allow("design:*", session.FULL_ACCESS);
```

Instead, we would have to manually find the exact room ID without a wildcard,
and apply it ourselvesâ€”the naming pattern doesnâ€™t work for this room.

```tsx
// Access to just this `design` room, but not scalable
session.allow("design:9Hdu73", session.FULL_ACCESS);
```

To use access tokens youâ€™d have to manually keep track of every room ID where
the naming pattern doesnâ€™t apply. This isnâ€™t ideal, and it also doesnâ€™t scale,
as the token will need to be refreshed whenever access is granted to new rooms
for this to work correctly.

#### Building complex permissions

For this reason,
**[we recommend using ID tokens for complex permissions](/docs/authentication/id-token)**.
ID token authentication allows you to attach permissions to each room when itâ€™s
created or modified, which means you donâ€™t need to check permissions yourself,
and no naming pattern is required.

### Migrating your current rooms IDs

If your application already has rooms, itâ€™s possible to rename their IDs to be
compatible with a naming pattern. Learn more in our
[room ID migration guide](/docs/guides/how-to-rename-room-ids-and-successfully-migrate-users).

## Select your framework [#select-your-framework]

Select your framework for specific instructions on setting up access token
authentication.

<ListGrid columns={3}>
  <DocsCard
    title="Next.js"
    href="/docs/authentication/access-token/nextjs"
    visual={<DocsNextjsIcon />}
  />
  <DocsCard
    title="Remix"
    href="/docs/authentication/access-token/remix"
    visual={<DocsRemixIcon />}
  />
  <DocsCard
    title="SvelteKit"
    href="/docs/authentication/access-token/sveltekit"
    visual={<DocsSvelteIcon />}
  />
  <DocsCard
    title="Nuxt.js"
    href="/docs/authentication/access-token/nuxtjs"
    visual={<DocsNuxtjsIcon />}
  />
  <DocsCard
    title="Express"
    href="/docs/authentication/access-token/express"
    visual={<DocsExpressIcon />}
  />
  <DocsCard
    title="Firebase"
    href="/docs/authentication/access-token/firebase"
    visual={<DocsFirebaseIcon />}
  />
</ListGrid>

---
meta:
  title: "Set up access token permissions with Express"
  parentTitle: "Authentication"
  description: "Learn how to setup access token permissions with Express."
---

Follow the following steps to start configure your authentication endpoint where

## Quickstart

<Steps>
  <Step>
    <StepTitle>Install the `liveblocks/node` package</StepTitle>
    <StepContent>

      ```bash
      npm install @liveblocks/node
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Set up authentication endpoint</StepTitle>
    <StepContent>

      Users need permission to interact with rooms, and you can
      permit access in an `api/liveblocks-auth` endpoint by
      creating the `liveblocks-auth.ts` file with the
      following code. In here you can implement your security and define
      the rooms that your user can enter.

      With access tokens, you should always use a [naming pattern](/docs/authentication/access-token#permissions)
      for your room IDs, as this enables you to easily allow
      access to a range of rooms at once. In the code snippet below, weâ€™re using a naming pattern and wildcard `*`
      to give the user access to every room in their organization, and every room in their group.


      ```ts file="liveblocks-auth.ts"
      const express = require("express");
      import { Liveblocks } from "@liveblocks/node";

      const liveblocks = new Liveblocks({
        secret: "{{SECRET_KEY}}",
      });

      const app = express();
      app.use(express.json());

      app.post("/api/liveblocks-auth", (req, res) => {
        // Get the current user from your database
        const user = __getUserFromDB__(req);

        // Start an auth session inside your endpoint
        const session = liveblocks.prepareSession(
          user.id,
          { userInfo: user.metadata },  // Optional
        );

        // Use a naming pattern to allow access to rooms with wildcards
        // Giving the user read access on their org, and write access on their group
        session.allow(`${user.organization}:*`, session.READ_ACCESS);
        session.allow(`${user.organization}:${user.group}:*`, session.FULL_ACCESS);

        // Authorize the user and return the result
        const { status, body } = await session.authorize();
        return res.status(status).end(body);
      });
      ```

      Read
      [access token permission](/docs/authentication/access-token#permissions)
      to learn more about naming rooms and granting permissions with wildcards.
      Note that if a naming pattern doesnâ€™t work for every room in your application, you can
      [grant access to individual rooms too](/docs/guides/how-to-grant-access-to-individual-rooms-with-access-tokens).

    </StepContent>

  </Step>
  <Step lastStep>
    <StepTitle>Set up the client</StepTitle>
    <StepContent>
      On the front end, you can now replace the `publicApiKey`
      option with `authEndpoint` pointing to the endpoint you
      just created.

      ```ts file="liveblocks.config.ts"
      import { createClient } from "@liveblocks/client";

      const client = createClient({
        authEndpoint: "/api/liveblocks-auth",
      });
      ```

      If you need to pass custom headers or data to your endpoint, you can
      use
      [authEndpoint as a callback](/docs/api-reference/liveblocks-client#createClientCallback)
      instead.

      ```ts file="liveblocks.config.ts" isCollapsed isCollapsable
      import { createClient } from "@liveblocks/client";

      // Passing custom headers and body to your endpoint
      const client = createClient({
        authEndpoint: async (room) => {
          const headers = {
            // Custom headers
            // ...

            "Content-Type": "application/json",
          };

          const body = JSON.stringify({
            // Custom body
            // ...

            room,
          });

          const response = await fetch("/api/liveblocks-auth", {
            method: "POST",
            headers,
            body,
          });

          return await response.json();
        },
      });
      ```

    </StepContent>

  </Step>
</Steps>

## More information

Both `userId` and `userInfo` can then be used in your JavaScript application as
such:

```ts
const self = room.getSelf(); // or useSelf() in React
console.log(self.id);
console.log(self.info);
```

<Figure>
  <Image
    src="/assets/access-token-auth-diagram.png"
    alt="Auth diagram"
    width={768}
    height={576}
  />
</Figure>

---
meta:
  title: "Set up access token permissions with Firebase"
  parentTitle: "Authentication"
  description: "Learn how to setup access token permissions with Firebase."
---

Follow the following steps to start configure your authentication endpoint and
start building your own security logic.

## Quickstart

<Steps>
  <Step>
    <StepTitle>Install the `liveblocks/node` package</StepTitle>
    <StepContent>
      Letâ€™s first install the `@liveblocks/node` package in your
      Firebase functions project.

      ```bash
      npm install @liveblocks/node
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Set up authentication endpoint</StepTitle>
    <StepContent>

      Users need permission to interact with rooms, and you can
      permit access by creating a new Firebase [callable function](https://firebase.google.com/docs/functions/callable)
      as shown below. In here you can implement your security and define
      the rooms that your user can enter.

      With access tokens, you should always use a [naming pattern](/docs/authentication/access-token#permissions)
      for your room IDs, as this enables you to easily allow
      access to a range of rooms at once. In the code snippet below, weâ€™re using a naming pattern and wildcard `*`
      to give the user access to every room in their organization, and every room in their group.


      ```js
      const functions = require("firebase-functions");
      const { Liveblocks } = require("@liveblocks/node");

      const liveblocks = new Liveblocks({
        secret: "{{SECRET_KEY}}",
      });

      exports.auth = functions.https.onCall(async (data, context) => {
        // Get the current user from your database
        const user = __getUserFromDB__(data);

        // Start an auth session inside your endpoint
        const session = liveblocks.prepareSession(
          user.id,
          { userInfo: user.metadata },  // Optional
        );

        // Use a naming pattern to allow access to rooms with wildcards
        // Giving the user read access on their org, and write access on their group
        session.allow(`${user.organization}:*`, session.READ_ACCESS);
        session.allow(`${user.organization}:${user.group}:*`, session.FULL_ACCESS);

        // Authorize the user and return the result
        const { status, body } = await session.authorize();
        return JSON.parse(body);
      });
      ```

      Read
      [access token permission](/docs/authentication/access-token#permissions)
      to learn more about naming rooms and granting permissions with wildcards.
      Note that if a naming pattern doesnâ€™t work for every room in your application, you can
      [grant access to individual rooms too](/docs/guides/how-to-grant-access-to-individual-rooms-with-access-tokens).


    </StepContent>

  </Step>
  <Step lastStep>
    <StepTitle>Set up the client</StepTitle>
    <StepContent>
      On the front end, you can now replace the `publicApiKey`
      option with `authEndpoint` pointing to the endpoint you
      just created.

      ```js
      import { createClient } from "@liveblocks/client";
      import firebase from "firebase";
      import "firebase/functions";

      firebase.initializeApp({
        /* Firebase config */
      });

      const auth = firebase.functions().httpsCallable("liveblocks-auth");

      // Create a Liveblocks client
      const client = createClient({
        authEndpoint: async (room) => (await auth({ room })).data,
      });
      ```

    </StepContent>

  </Step>
</Steps>

## More information

Both `userId` and `userInfo` can then be used in your JavaScript application as
such:

```ts
const self = room.getSelf(); // or useSelf() in React
console.log(self.id);
console.log(self.info);
```

<Figure>
  <Image
    src="/assets/access-token-auth-diagram.png"
    alt="Auth diagram"
    width={768}
    height={576}
  />
</Figure>

---
meta:
  title: "Set up access token permissions with Next.js"
  parentTitle: "Authentication"
  description: "Learn how to setup access token permissions with Next.js."
---

Follow the following steps to start configure your authentication endpoint and
start building your own security logic in Next.jsâ€™ `/app` directory.

## Quickstart

<Steps>
  <Step>
    <StepTitle>Install the `liveblocks/node` package</StepTitle>
    <StepContent>

      ```bash
      npm install @liveblocks/node
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Add your projectâ€™s secret key</StepTitle>
    <StepContent>

      Create a new `.env.local` file and add your Liveblocks secret key from the [dashboard](/dashboard/apikeys).

      ```env file=".env.local"
      LIVEBLOCKS_SECRET_KEY="{{SECRET_KEY}}"
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Set up authentication endpoint</StepTitle>
    <StepContent>
      Users need permission to interact with rooms, and you can
      permit access in an `api/liveblocks-auth` endpoint by
      creating the following `app/api/liveblocks-auth/route.ts`
      file. In here you can implement your security and define
      the rooms that your user can enter.

      With access tokens, you should always use a [naming pattern](/docs/authentication/access-token#permissions)
      for your room IDs, as this enables you to easily allow
      access to a range of rooms at once. In the code snippet below, weâ€™re using a naming pattern and wildcard `*`
      to give the user access to every room in their organization, and every room in their group.

      ```ts file="app/api/liveblocks-auth/route.ts"
      import { Liveblocks } from "@liveblocks/node";

      const liveblocks = new Liveblocks({
        secret: process.env.LIVEBLOCKS_SECRET_KEY!,
      });

      export async function POST(request: Request) {
        // Get the current user from your database
        const user = __getUserFromDB__(request);

        // Start an auth session inside your endpoint
        const session = liveblocks.prepareSession(
          user.id,
          { userInfo: user.metadata } // Optional
        );

        // Use a naming pattern to allow access to rooms with wildcards
        // Giving the user read access on their org, and write access on their group
        session.allow(`${user.organization}:*`, session.READ_ACCESS);
        session.allow(`${user.organization}:${user.group}:*`, session.FULL_ACCESS);

        // Authorize the user and return the result
        const { status, body } = await session.authorize();
        return new Response(body, { status });
      }
      ```

      Read
      [access token permission](/docs/authentication/access-token#permissions)
      to learn more about naming rooms and granting permissions with wildcards.
      Note that if a naming pattern doesnâ€™t work for every room in your application, you can
      [grant access to individual rooms too](/docs/guides/how-to-grant-access-to-individual-rooms-with-access-tokens).

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Set up the client</StepTitle>
    <StepContent>
      On the front end, you can now replace the `publicApiKey`
      prop on [`LiveblocksProvider`](/docs/api-reference/liveblocks-react#LiveblocksProvider)
      with `authEndpoint` pointing to the endpoint you just created.

      ```tsx
      <LiveblocksProvider authEndpoint="/api/liveblocks-auth">
      ```

      If you need to pass custom headers or data to your endpoint, you can
      use
      [authEndpoint as a callback](/docs/api-reference/liveblocks-client#LiveblocksProviderCallback)
      instead.

      ```tsx title="Pass custom headers" isCollapsed isCollapsable
      <LiveblocksProvider
        authEndpoint={async (room) => {
          // Passing custom headers and body to your endpoint
          const headers = {
            // Custom headers
            // ...

            "Content-Type": "application/json",
          };

          const body = JSON.stringify({
            // Custom body
            // ...

            room,
          });

          const response = await fetch("/api/liveblocks-auth", {
            method: "POST",
            headers,
            body,
          });

          return await response.json();
        }}
      />
      ```

    </StepContent>

  </Step>
  <Step lastStep>
    <StepTitle>Attach metadata to users</StepTitle>
      <StepContent>
        Optionally, you can attach static metadata to each user, which will
        be accessible in your app. First you need to define the types in
        your config file, under `UserMeta["info"]`.

        ```ts file="liveblocks.config.ts" highlight="7-11"
        declare global
          interface Liveblocks {
            UserMeta: {
              id: string;

              // Example, use any JSON-compatible data in your metadata
              info: {
                name: string;
                avatar: string;
                colors: string[];
              }
            }

            // Other type definitions
            // ...
          }
        }
        ```

        When authenticating, you can then pass the userâ€™s metadata to
        `prepareSession` in the endpoint weâ€™ve just created.

        ```ts file="app/api/liveblocks-auth/route.ts" highlight="8-12"
        // Get the current user from your database
        const user = __getUserFromDB__(request);

        // Start an auth session inside your endpoint
        const session = liveblocks.prepareSession(
          user.id,
          {
            userInfo: {
              name: user.name,
              avatar: user.avatarUrl,
              colors: user.colorArray,
            }
          }
        );
        ```

        User metadata has now been set! You can access this information in your app through
        [`useSelf`](/docs/api-reference/liveblocks-react#useSelf).

        ```tsx highlight="4"
        export { useSelf } from "@liveblocks/react/suspense";

        function Component() {
          const { name, avatar, colors } = useSelf((me) => me.info);
        }
        ```

        Bear in mind that if youâ€™re using the [default Comments components](/docs/api-reference/liveblocks-react-ui#Components),
        you must specify a `name` and `avatar` in `userInfo`.
      </StepContent>

    </Step>

</Steps>

## More information

Both `userId` and `userInfo` can then be used in your React application as such:

```ts
const self = useSelf();
console.log(self.id);
console.log(self.info);
```

<Figure>
  <Image
    src="/assets/access-token-auth-diagram.png"
    alt="Auth diagram"
    width={768}
    height={576}
  />
</Figure>

---
meta:
  title: "Set up access token permissions with Nuxt.js"
  parentTitle: "Authentication"
  description: "Learn how to setup access token permissions with Nuxt.js."
---

Follow the following steps to start configure your authentication endpoint and
start building your own security logic.

## Quickstart

<Steps>
  <Step>
    <StepTitle>Install the `liveblocks/node` package</StepTitle>
    <StepContent>

      ```bash
      npm install @liveblocks/node
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Set up authentication endpoint</StepTitle>
    <StepContent>
      Users need permission to interact with rooms, and you can
      permit access in an `api/liveblocks-auth` endpoint by
      creating the `server/api/liveblocks-auth.ts` file with the
      following code. This is where you will implement your security and
      define the rooms that the user has access to.

      With access tokens, you should always use a [naming pattern](/docs/authentication/access-token#permissions)
      for your room IDs, as this enables you to easily allow
      access to a range of rooms at once. In the code snippet below, weâ€™re using a naming pattern and wildcard `*`
      to give the user access to every room in their organization, and every room in their group.

      ```ts file="server/api/liveblocks-auth.ts"
      import { Liveblocks } from "@liveblocks/node";

      const liveblocks = new Liveblocks({
        secret: "{{SECRET_KEY}}",
      });

      export default defineEventHandler(async (event) => {
      // Get the current user from your database
        const user = __getUserFromDB__(event);

        // Start an auth session inside your endpoint
        const session = liveblocks.prepareSession(
          user.id,
          { userInfo: user.metadata },  // Optional
        );

        // Use a naming pattern to allow access to rooms with wildcards
        // Giving the user read access on their org, and write access on their group
        session.allow(`${user.organization}:*`, session.READ_ACCESS);
        session.allow(`${user.organization}:${user.group}:*`, session.FULL_ACCESS);

        // Authorize the user and return the result
        const { status, body } = await session.authorize();
        return body;
      })
      ```

      Read
      [access token permission](/docs/authentication/access-token#permissions)
      to learn more about naming rooms and granting permissions with wildcards.
      Note that if a naming pattern doesnâ€™t work for every room in your application, you can
      [grant access to individual rooms too](/docs/guides/how-to-grant-access-to-individual-rooms-with-access-tokens).

    </StepContent>

  </Step>
  <Step lastStep>
    <StepTitle>Set up the client</StepTitle>
    <StepContent>
      On the front end, you can now replace the `publicApiKey`
      option with `authEndpoint` pointing to the endpoint you
      just created.

      ```ts file="liveblocks.config.ts"
      import { createClient } from "@liveblocks/client";

      const client = createClient({
        authEndpoint: "/api/liveblocks-auth",
      });
      ```

      If you need to pass custom headers or data to your endpoint, you can
      use
      [authEndpoint as a callback](/docs/api-reference/liveblocks-client#createClientCallback)
      instead.

      ```ts file="liveblocks.config.ts" isCollapsed isCollapsable
      import { createClient } from "@liveblocks/client";

      // Passing custom headers and body to your endpoint
      const client = createClient({
        authEndpoint: async (room) => {
          const headers = {
            // Custom headers
            // ...

            "Content-Type": "application/json",
          };

          const body = JSON.stringify({
            // Custom body
            // ...

            room,
          });

          const response = await fetch("/api/liveblocks-auth", {
            method: "POST",
            headers,
            body,
          });

          return await response.json();
        },
      });
      ```

    </StepContent>

  </Step>
</Steps>

## More information

Both `userId` and `userInfo` can then be used in your Vue.js application as
such:

```ts
const self = ref(room.getSelf());
console.log(self.id);
console.log(self.info);
```

<Figure>
  <Image
    src="/assets/access-token-auth-diagram.png"
    alt="Auth diagram"
    width={768}
    height={576}
  />
</Figure>

---
meta:
  title: "Set up access token permissions with Remix"
  parentTitle: "Authentication"
  description: "Learn how to setup access token permissions with Remix."
---

Follow the following steps to start configure your authentication endpoint and
start building your own security logic.

## Quickstart

<Steps>
  <Step>
    <StepTitle>Install the `liveblocks/node` package</StepTitle>
    <StepContent>

      ```bash
      npm install @liveblocks/node
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Set up authentication endpoint</StepTitle>
    <StepContent>
      Users need permission to interact with rooms, and you can
      permit access in an `api/liveblocks-auth` endpoint by
      creating the `app/routes/api/liveblocks-auth.ts` file with the
      following code. In here you can implement your security and define
      the rooms that your user can enter.

      With access tokens, you should always use a [naming pattern](/docs/authentication/access-token#permissions)
      for your room IDs, as this enables you to easily allow
      access to a range of rooms at once. In the code snippet below, weâ€™re using a naming pattern and wildcard `*`
      to give the user access to every room in their organization, and every room in their group.


      ```ts file="app/routes/api/liveblocks-auth.ts"
      import type { ActionFunction } from "@remix-run/node";
      import { Liveblocks } from "@liveblocks/node";

      const liveblocks = new Liveblocks({
        secret: "{{SECRET_KEY}}",
      });

      export const action: ActionFunction = async ({ request }) => {
        // Get the current user from your database
        const user = __getUserFromDB__(request);

        // Start an auth session inside your endpoint
        const session = liveblocks.prepareSession(
          user.id,
          { userInfo: user.metadata },  // Optional
        );

        // Use a naming pattern to allow access to rooms with wildcards
        // Giving the user read access on their org, and write access on their group
        session.allow(`${user.organization}:*`, session.READ_ACCESS);
        session.allow(`${user.organization}:${user.group}:*`, session.FULL_ACCESS);

        // Authorize the user and return the result
        const { status, body } = await session.authorize();
        return new Response(body, { status });
      }
      ```

      Read
      [access token permission](/docs/authentication/access-token#permissions)
      to learn more about naming rooms and granting permissions with wildcards.
      Note that if a naming pattern doesnâ€™t work for every room in your application, you can
      [grant access to individual rooms too](/docs/guides/how-to-grant-access-to-individual-rooms-with-access-tokens).

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Set up the client</StepTitle>
    <StepContent>
      On the front end, you can now replace the `publicApiKey`
      prop on [`LiveblocksProvider`](/docs/api-reference/liveblocks-react#LiveblocksProvider)
      with `authEndpoint` pointing to the endpoint you just created.

      ```tsx
      <LiveblocksProvider authEndpoint="/api/liveblocks-auth">
      ```

      If you need to pass custom headers or data to your endpoint, you can
      use
      [authEndpoint as a callback](/docs/api-reference/liveblocks-client#LiveblocksProviderCallback)
      instead.

      ```tsx title="Pass custom headers" isCollapsed isCollapsable
      <LiveblocksProvider
        authEndpoint={async (room) => {
          // Passing custom headers and body to your endpoint
          const headers = {
            // Custom headers
            // ...

            "Content-Type": "application/json",
          };

          const body = JSON.stringify({
            // Custom body
            // ...

            room,
          });

          const response = await fetch("/api/liveblocks-auth", {
            method: "POST",
            headers,
            body,
          });

          return await response.json();
        }}
      />
      ```

    </StepContent>

  </Step>
  <Step lastStep>
    <StepTitle>Attach metadata to users</StepTitle>
      <StepContent>
        Optionally, you can attach static metadata to each user, which will
        be accessible in your app. First you need to define the types in
        your config file, under `UserMeta["info"]`.

        ```ts file="liveblocks.config.ts" highlight="7-11"
        declare global
          interface Liveblocks {
            UserMeta: {
              id: string;

              // Example, use any JSON-compatible data in your metadata
              info: {
                name: string;
                avatar: string;
                colors: string[];
              }
            }

            // Other type definitions
            // ...
          }
        }
        ```

        When authenticating, you can then pass the userâ€™s metadata to
        `prepareSession` in the endpoint weâ€™ve just created.

        ```ts file="app/routes/api/liveblocks-auth.ts" highlight="8-12"
        // Get the current user from your database
        const user = __getUserFromDB__(request);

        // Start an auth session inside your endpoint
        const session = liveblocks.prepareSession(
          user.id,
          {
            userInfo: {
              name: user.name,
              avatar: user.avatarUrl,
              colors: user.colorArray,
            }
          }
        );
        ```

        User metadata has now been set! You can access this information in your app through
        [`useSelf`](/docs/api-reference/liveblocks-react#useSelf).

        ```tsx highlight="4"
        export { useSelf } from "../liveblocks.config.ts";

        function Component() {
          const { name, avatar, colors } = useSelf((me) => me.info);
        }
        ```

        Bear in mind that if youâ€™re using the [default Comments components](/docs/api-reference/liveblocks-react-ui#Components),
        you must specify a `name` and `avatar` in `userInfo`.
      </StepContent>

    </Step>

</Steps>

## More information

Both `userId` and `userInfo` can then be used in your React application as such:

```ts
const self = useSelf();
console.log(self.id);
console.log(self.info);
```

<Figure>
  <Image
    src="/assets/access-token-auth-diagram.png"
    alt="Auth diagram"
    width={768}
    height={576}
  />
</Figure>

---
meta:
  title: "Set up access token permissions with SvelteKit"
  parentTitle: "Authentication"
  description: "Learn how to setup access token permissions with SvelteKit."
---

Follow the following steps to start configure your authentication endpoint and
start building your own security logic.

## Quickstart

<Steps>
  <Step>
    <StepTitle>Install the `liveblocks/node` package</StepTitle>
    <StepContent>

      ```bash
      npm install @liveblocks/node
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Set up authentication endpoint</StepTitle>
    <StepContent>
      Users need permission to interact with rooms, and you can
      permit access in an `api/liveblocks-auth` endpoint by
      creating the `src/routes/api/liveblocks-auth/+server.ts` file with the
      following code. In here you can implement your security and define
      the rooms that your user can enter.

      With access tokens, you should always use a [naming pattern](/docs/authentication/access-token#permissions)
      for your room IDs, as this enables you to easily allow
      access to a range of rooms at once. In the code snippet below, weâ€™re using a naming pattern and wildcard `*`
      to give the user access to every room in their organization, and every room in their group.


      ```ts file="src/routes/api/liveblocks-auth/+server.ts"
      import { type RequestEvent } from "@sveltejs/kit";
      import { Liveblocks } from "@liveblocks/node";

      const liveblocks = new Liveblocks({
        secret: "{{SECRET_KEY}}",
      });

      export async function POST({ request }: RequestEvent) {
        // Get the current user from your database
        const user = __getUserFromDB__(request);

        // Start an auth session inside your endpoint
        const session = liveblocks.prepareSession(
          user.id,
          { userInfo: user.metadata },  // Optional
        );

        // Use a naming pattern to allow access to rooms with wildcards
        // Giving the user read access on their org, and write access on their group
        session.allow(`${user.organization}:*`, session.READ_ACCESS);
        session.allow(`${user.organization}:${user.group}:*`, session.FULL_ACCESS);

        // Authorize the user and return the result
        const { status, body } = await session.authorize();
        return new Response(body, { status });
      }
      ```

      Read
      [access token permission](/docs/authentication/access-token#permissions)
      to learn more about naming rooms and granting permissions with wildcards.
      Note that if a naming pattern doesnâ€™t work for every room in your application, you can
      [grant access to individual rooms too](/docs/guides/how-to-grant-access-to-individual-rooms-with-access-tokens).

    </StepContent>

  </Step>
  <Step lastStep>
    <StepTitle>Set up the client</StepTitle>
    <StepContent>
      On the front end, you can now replace the `publicApiKey`
      option with `authEndpoint` pointing to the endpoint you
      just created.

      ```ts file="liveblocks.config.ts"
      import { createClient } from "@liveblocks/client";

      const client = createClient({
        authEndpoint: "/api/liveblocks-auth",
      });
      ```

      If you need to pass custom headers or data to your endpoint, you can
      use
      [authEndpoint as a callback](/docs/api-reference/liveblocks-client#createClientCallback)
      instead.

      ```ts file="liveblocks.config.ts" isCollapsed isCollapsable
      import { createClient } from "@liveblocks/client";

      // Passing custom headers and body to your endpoint
      const client = createClient({
        authEndpoint: async (room) => {
          const headers = {
            // Custom headers
            // ...

            "Content-Type": "application/json",
          };

          const body = JSON.stringify({
            // Custom body
            // ...

            room,
          });

          const response = await fetch("/api/liveblocks-auth", {
            method: "POST",
            headers,
            body,
          });

          return await response.json();
        },
      });
      ```

    </StepContent>

  </Step>
</Steps>

## More information

Both `userId` and `userInfo` can then be used in your Svelte application as
such:

```ts
const self = room.getSelf();
console.log(self.id);
console.log(self.info.color);
```

<Figure>
  <Image
    src="/assets/access-token-auth-diagram.png"
    alt="Auth diagram"
    width={768}
    height={576}
  />
</Figure>

---
meta:
  title: "Set up ID token permissions with Express"
  parentTitle: "Authentication"
  description: "Learn how to setup ID token permissions with Express."
---

Follow the following steps to start configure your authentication endpoint where

## Quickstart

<Steps>
  <Step>
    <StepTitle>Install the `liveblocks/node` package</StepTitle>
    <StepContent>

      ```bash
      npm install @liveblocks/node
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Set up authentication endpoint</StepTitle>
    <StepContent>

      Users can only interact with rooms they have access to. You can
      configure permission access in an `api/liveblocks-auth` endpoint by
      creating the `liveblocks-auth.ts` file with the
      following code. This is where you will implement your security and
      define if the current user has access to a specific room.

      ```ts file="liveblocks-auth.ts"
      const express = require("express");
      import { Liveblocks } from "@liveblocks/node";

      const liveblocks = new Liveblocks({
        secret: "{{SECRET_KEY}}",
      });

      const app = express();
      app.use(express.json());

      app.post("/api/liveblocks-auth", (req, res) => {
        // Get the current user from your database
        const user = __getUserFromDB__(req);

        // Identify the user and return the result
        const { status, body } = await liveblocks.identifyUser(
          {
            userId: user.id,
            groupIds, // Optional
          },
          { userInfo: user.metadata },
        );

        return res.status(status).end(body);
      });
      ```
    </StepContent>

  </Step>
  <Step>
    <StepTitle>Set up the client</StepTitle>
    <StepContent>
      On the front end, you can now replace the `publicApiKey`
      option with `authEndpoint` pointing to the endpoint you
      just created.

      ```ts file="liveblocks.config.ts"
      import { createClient } from "@liveblocks/client";

      const client = createClient({
        authEndpoint: "/api/liveblocks-auth",
      });
      ```

      If you need to pass custom headers or data to your endpoint, you can
      use
      [authEndpoint as a callback](/docs/api-reference/liveblocks-client#createClientCallback)
      instead.

      ```ts file="liveblocks.config.ts" isCollapsed isCollapsable
      import { createClient } from "@liveblocks/client";

      // Passing custom headers and body to your endpoint
      const client = createClient({
        authEndpoint: async (room) => {
          const headers = {
            // Custom headers
            // ...

            "Content-Type": "application/json",
          };

          const body = JSON.stringify({
            // Custom body
            // ...

            room,
          });

          const response = await fetch("/api/liveblocks-auth", {
            method: "POST",
            headers,
            body,
          });

          return await response.json();
        },
      });
      ```

    </StepContent>

  </Step>
  <Step lastStep>
    <StepTitle>Set permission accesses to a room</StepTitle>
    <StepContent>
      A room can have `defaultAccesses`, `usersAccesses`, and `groupsAccesses` defined.
      Permissions are then checked when users try to connect to a room. For security purposes,
      [room permissions](/docs/authentication/id-token#permissions) can only be set on the back-end through `@liveblocks/node` or our REST API.
      For instance, you can use [`liveblocks.createRoom`](/docs/api-reference/liveblocks-node#post-rooms)
      to create a new room with read-only public access levels while giving write access to specific groups and users.

      ```ts highlight="7-15"
        import { Liveblocks } from "@liveblocks/node";

        const liveblocks = new Liveblocks({
          secret: "{{SECRET_KEY}}",
        });

        const room = await liveblocks.createRoom("my-room-id", {
          defaultAccesses: ["room:read", "room:presence:write"],
          groupsAccesses: {
            "my-group-id": ["room:write"],
          },
          usersAccesses: {
            "my-user-id": ["room:write"],
          },
        });
      ```

      For more information, make sure to read the section on [room permissions](/docs/authentication/id-token#permissions).

    </StepContent>

  </Step>
</Steps>

## More information

Both `userId` and `userInfo` can then be used in your JavaScript application as
such:

```ts
const self = room.getSelf(); // or useSelf() in React
console.log(self.id);
console.log(self.info);
```

<Figure>
  <Image
    src="/assets/id-token-auth-diagram.png"
    alt="Auth diagram"
    width={768}
    height={576}
  />
</Figure>

---
meta:
  title: "Set up ID token permissions with Firebase"
  parentTitle: "Authentication"
  description: "Learn how to setup ID token permissions with Firebase."
---

Follow the following steps to start configure your authentication endpoint and
start building your own security logic.

## Quickstart

<Steps>
  <Step>
    <StepTitle>Install the `liveblocks/node` package</StepTitle>
    <StepContent>
      Letâ€™s first install the `@liveblocks/node` package in your
      Firebase functions project.

      ```bash
      npm install @liveblocks/node
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Set up authentication endpoint</StepTitle>
    <StepContent>

      Create a new Firebase [callable function](https://firebase.google.com/docs/functions/callable)
      as shown below. This is where you will implement your security and
      define if the current user has access to a specific room.

      ```js
      const functions = require("firebase-functions");
      const { Liveblocks } = require("@liveblocks/node");

      const liveblocks = new Liveblocks({
        secret: "{{SECRET_KEY}}",
      });

      exports.auth = functions.https.onCall(async (data, context) => {
        // Get the current user from your database
        const user = __getUserFromDB__(data);

        // Identify the user and return the result
        const { status, body } = await liveblocks.identifyUser(
          {
            userId: user.id,
            groupIds, // Optional
          },
          { userInfo: user.metadata },
        );

        return JSON.parse(body);
      });
      ```
    </StepContent>

  </Step>
  <Step>
    <StepTitle>Set up the client</StepTitle>
    <StepContent>
      On the front end, you can now replace the `publicApiKey`
      option with `authEndpoint` pointing to the endpoint you
      just created.

      ```js
      import { createClient } from "@liveblocks/client";
      import firebase from "firebase";
      import "firebase/functions";

      firebase.initializeApp({
        /* Firebase config */
      });

      const auth = firebase.functions().httpsCallable("liveblocks-auth");

      // Create a Liveblocks client
      const client = createClient({
        authEndpoint: async (room) => (await auth({ room })).data,
      });
      ```

    </StepContent>

  </Step>
  <Step lastStep>
    <StepTitle>Set permission accesses to a room</StepTitle>
    <StepContent>
      A room can have `defaultAccesses`, `usersAccesses`, and `groupsAccesses` defined.
      Permissions are then checked when users try to connect to a room. For security purposes,
      [room permissions](/docs/authentication/id-token#permissions) can only be set on the back-end through `@liveblocks/node` or our REST API.
      For instance, you can use [`liveblocks.createRoom`](/docs/api-reference/liveblocks-node#post-rooms)
      to create a new room with read-only public access levels while giving write access to specific groups and users.

      ```ts highlight="7-15"
      import { Liveblocks } from "@liveblocks/node";

      const liveblocks = new Liveblocks({
        secret: "{{SECRET_KEY}}",
      });

      const room = await liveblocks.createRoom("my-room-id", {
        defaultAccesses: ["room:read", "room:presence:write"],
        groupsAccesses: {
          "my-group-id": ["room:write"],
        },
        usersAccesses: {
          "my-user-id": ["room:write"],
        },
      });
      ```

      For more information, make sure to read the section on [room permissions](/docs/authentication/id-token#permissions).

    </StepContent>

  </Step>
</Steps>

## More information

Both `userId` and `userInfo` can then be used in your JavaScript application as
such:

```ts
const self = room.getSelf(); // or useSelf() in React
console.log(self.id);
console.log(self.info);
```

<Figure>
  <Image
    src="/assets/id-token-auth-diagram.png"
    alt="Auth diagram"
    width={768}
    height={576}
  />
</Figure>

---
meta:
  title: "Set up ID token permissions with Next.js"
  parentTitle: "Authentication"
  description: "Learn how to setup ID token permissions with Next.js."
---

Follow the following steps to start configure your authentication endpoint and
start building your own security logic in Next.jsâ€™ `/app` directory.

## Quickstart

<Steps>
  <Step>
    <StepTitle>Install the `liveblocks/node` package</StepTitle>
    <StepContent>

      ```bash
      npm install @liveblocks/node
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Add your projectâ€™s secret key</StepTitle>
    <StepContent>

      Create a new `.env.local` file and add your Liveblocks secret key from the [dashboard](/dashboard/apikeys).

      ```env file=".env.local"
      LIVEBLOCKS_SECRET_KEY="{{SECRET_KEY}}"
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Set up authentication endpoint</StepTitle>
    <StepContent>
      Users can only interact with rooms they have access to. You can
      configure permission access in an `api/liveblocks-auth` endpoint by
      creating the `app/api/liveblocks-auth/route.ts` file with the
      following code. This is where you will implement your security and
      define if the current user has access to a specific room.

      ```ts file="app/api/liveblocks-auth/route.ts"
      import { Liveblocks } from "@liveblocks/node";

      const liveblocks = new Liveblocks({
        secret: process.env.LIVEBLOCKS_SECRET_KEY!,
      });

      export async function POST(request: Request) {
        // Get the current user from your database
        const user = __getUserFromDB__(request);

        // Identify the user and return the result
        const { status, body } = await liveblocks.identifyUser(
          {
            userId: user.id,
            groupIds, // Optional
          },
          { userInfo: user.metadata },
        );

        return new Response(body, { status });
      }
      ```

      Hereâ€™s an example using the older API routes format in `/pages`.

      ```ts file="pages/api/liveblocks-auth.ts" isCollapsed isCollapsable
      import { Liveblocks } from "@liveblocks/node";
      import type { NextApiRequest, NextApiResponse } from "next";

      const liveblocks = new Liveblocks({
        secret: process.env.LIVEBLOCKS_SECRET_KEY!,
      });

      export default async function handler(request: NextApiRequest, response: NextApiResponse) {
        // Get the current user from your database
        const user = __getUserFromDB__(request);

        // Identify the user and return the result
        const { status, body } = await liveblocks.identifyUser(
          {
            userId: user.id,
            groupIds, // Optional
          },
          { userInfo: user.metadata },
        );

        // Authorize the user and return the result
        const { status, body } = await session.authorize();
        response.status(status).send(body);
      }
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Set up the client</StepTitle>
    <StepContent>
      On the front end, you can now replace the `publicApiKey`
      prop on [`LiveblocksProvider`](/docs/api-reference/liveblocks-react#LiveblocksProvider)
      with `authEndpoint` pointing to the endpoint you just created.

      ```tsx
      <LiveblocksProvider authEndpoint="/api/liveblocks-auth">
      ```

      If you need to pass custom headers or data to your endpoint, you can
      use
      [authEndpoint as a callback](/docs/api-reference/liveblocks-client#LiveblocksProviderCallback)
      instead.

      ```tsx title="Pass custom headers" isCollapsed isCollapsable
      <LiveblocksProvider
        authEndpoint={async (room) => {
          // Passing custom headers and body to your endpoint
          const headers = {
            // Custom headers
            // ...

            "Content-Type": "application/json",
          };

          const body = JSON.stringify({
            // Custom body
            // ...

            room,
          });

          const response = await fetch("/api/liveblocks-auth", {
            method: "POST",
            headers,
            body,
          });

          return await response.json();
        }}
      />
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Set permission accesses to a room</StepTitle>
    <StepContent>
      A room can have `defaultAccesses`, `usersAccesses`, and `groupsAccesses` defined.
      Permissions are then checked when users try to connect to a room. For security purposes,
      [room permissions](/docs/authentication/id-token#permissions) can only be set on the back-end through `@liveblocks/node` or our REST API.
      For instance, you can use [`liveblocks.createRoom`](/docs/api-reference/liveblocks-node#post-rooms)
      to create a new room with read-only public access levels while giving write access to specific groups and users.

      ```ts highlight="7-15"
      import { Liveblocks } from "@liveblocks/node";

      const liveblocks = new Liveblocks({
        secret: process.env.LIVEBLOCKS_SECRET_KEY!,
      });

      const room = await liveblocks.createRoom("my-room-id", {
        defaultAccesses: ["room:read", "room:presence:write"],
        groupsAccesses: {
          "my-group-id": ["room:write"],
        },
        usersAccesses: {
          "my-user-id": ["room:write"],
        },
      });
      ```

      For more information, make sure to read the section on [room permissions](/docs/authentication/id-token#permissions).

    </StepContent>

  </Step>
  <Step lastStep>
    <StepTitle>Attach metadata to users</StepTitle>
      <StepContent>
        Optionally, you can attach static metadata to each user, which will
        be accessible in your app. First you need to define the types in
        your config file, under `UserMeta["info"]`.

        ```ts file="liveblocks.config.ts" highlight="7-11"
        declare global
          interface Liveblocks {
            UserMeta: {
              id: string;

              // Example, use any JSON-compatible data in your metadata
              info: {
                name: string;
                avatar: string;
                colors: string[];
              }
            }

            // Other type definitions
            // ...
          }
        }
        ```

        When authenticating, you can then pass the userâ€™s metadata to
        `prepareSession` in the endpoint weâ€™ve just created.

        ```ts file="app/api/liveblocks-auth/route.ts" highlight="11-15"
        // Get the current user from your database
        const user = __getUserFromDB__(request);

        // Identify the user and return the result
        const { status, body } = await liveblocks.identifyUser(
          {
            userId: user.id,
            groupIds, // Optional
          },
          {
            userInfo: {
              name: user.name,
              avatar: user.avatarUrl,
              colors: user.colorArray,
            }
          },
        );
        ```

        User metadata has now been set! You can access this information in your app through
        [`useSelf`](/docs/api-reference/liveblocks-react#useSelf).

        ```tsx highlight="4"
        export { useSelf } from "@liveblocks/react/suspense";

        function Component() {
          const { name, avatar, colors } = useSelf((me) => me.info);
        }
        ```

        Bear in mind that if youâ€™re using the [default Comments components](/docs/api-reference/liveblocks-react-ui#Components),
        you must specify a `name` and `avatar` in `userInfo`.
      </StepContent>

    </Step>

</Steps>

## More information

Both `userId` and `userInfo` can then be used in your React application as such:

```ts
const self = useSelf();
console.log(self.id);
console.log(self.info);
```

<Figure>
  <Image
    src="/assets/id-token-auth-diagram.png"
    alt="Auth diagram"
    width={768}
    height={576}
  />
</Figure>

---
meta:
  title: "Set up ID token permissions with Nuxt.js"
  parentTitle: "Authentication"
  description: "Learn how to setup ID token permissions with Nuxt.js."
---

Follow the following steps to start configure your authentication endpoint and
start building your own security logic.

## Quickstart

<Steps>
  <Step>
    <StepTitle>Install the `liveblocks/node` package</StepTitle>
    <StepContent>

      ```bash
      npm install @liveblocks/node
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Set up authentication endpoint</StepTitle>
    <StepContent>
      Users can only interact with rooms they have access to. You can
      configure permission access in an `api/liveblocks-auth` endpoint by
      creating the `server/api/liveblocks-auth.ts` file with the
      following code. This is where you will implement your security and
      define if the current user has access to a specific room.

      ```ts file="server/api/liveblocks-auth.ts"
      import { Liveblocks } from "@liveblocks/node";

      const liveblocks = new Liveblocks({
        secret: "{{SECRET_KEY}}",
      });

      export default defineEventHandler(async (event) => {
        // Get the current user from your database
        const user = __getUserFromDB__(event);

        // Identify the user and return the result
        const { status, body } = await liveblocks.identifyUser(
          {
            userId: user.id,
            groupIds, // Optional
          },
          { userInfo: user.metadata },
        );
        return body;
      })
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Set up the client</StepTitle>
    <StepContent>
      On the front end, you can now replace the `publicApiKey`
      option with `authEndpoint` pointing to the endpoint you
      just created.

      ```ts file="liveblocks.config.ts"
      import { createClient } from "@liveblocks/client";

      const client = createClient({
        authEndpoint: "/api/liveblocks-auth",
      });
      ```

      If you need to pass custom headers or data to your endpoint, you can
      use
      [authEndpoint as a callback](/docs/api-reference/liveblocks-client#createClientCallback)
      instead.

      ```ts file="liveblocks.config.ts" isCollapsed isCollapsable
      import { createClient } from "@liveblocks/client";

      // Passing custom headers and body to your endpoint
      const client = createClient({
        authEndpoint: async (room) => {
          const headers = {
            // Custom headers
            // ...

            "Content-Type": "application/json",
          };

          const body = JSON.stringify({
            // Custom body
            // ...

            room,
          });

          const response = await fetch("/api/liveblocks-auth", {
            method: "POST",
            headers,
            body,
          });

          return await response.json();
        },
      });
      ```

    </StepContent>

  </Step>
  <Step lastStep>
    <StepTitle>Set permission accesses to a room</StepTitle>
    <StepContent>
      A room can have `defaultAccesses`, `usersAccesses`, and `groupsAccesses` defined.
      Permissions are then checked when users try to connect to a room. For security purposes,
      [room permissions](/docs/authentication/id-token#permissions) can only be set on the back-end through `@liveblocks/node` or our REST API.
      For instance, you can use [`liveblocks.createRoom`](/docs/api-reference/liveblocks-node#post-rooms)
      to create a new room with read-only public access levels while giving write access to specific groups and users.

      ```ts highlight="7-15"
      import { Liveblocks } from "@liveblocks/node";

      const liveblocks = new Liveblocks({
        secret: "{{SECRET_KEY}}",
      });

      const room = await liveblocks.createRoom("my-room-id", {
        defaultAccesses: ["room:read", "room:presence:write"],
        groupsAccesses: {
          "my-group-id": ["room:write"],
        },
        usersAccesses: {
          "my-user-id": ["room:write"],
        },
      });
      ```

      For more information, make sure to read the section on [room permissions](/docs/authentication/id-token#permissions).

    </StepContent>

  </Step>
</Steps>

## More information

Both `userId` and `userInfo` can then be used in your Vue.js application as
such:

```ts
const self = ref(room.getSelf());
console.log(self.id);
console.log(self.info);
```

<Figure>
  <Image
    src="/assets/id-token-auth-diagram.png"
    alt="Auth diagram"
    width={768}
    height={576}
  />
</Figure>

---
meta:
  title: "Set up ID token permissions with Remix"
  parentTitle: "Authentication"
  description: "Learn how to setup ID token permissions with Remix."
---

Follow the following steps to start configure your authentication endpoint and
start building your own security logic.

## Quickstart

<Steps>
  <Step>
    <StepTitle>Install the `liveblocks/node` package</StepTitle>
    <StepContent>

      ```bash
      npm install @liveblocks/node
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Set up authentication endpoint</StepTitle>
    <StepContent>
      Users can only interact with rooms they have access to. You can
      configure permission access in an `api/liveblocks-auth` endpoint by
      creating the `app/routes/api/liveblocks-auth.ts` file with the
      following code. This is where you will implement your security and
      define if the current user has access to a specific room.

      ```ts file="app/routes/api/liveblocks-auth.ts"
      import type { ActionFunction } from "@remix-run/node";
      import { Liveblocks } from "@liveblocks/node";

      const liveblocks = new Liveblocks({
        secret: "{{SECRET_KEY}}",
      });

      export const action: ActionFunction = async ({ request }) => {
        // Get the current user from your database
        const user = __getUserFromDB__(request);

        // Identify the user and return the result
        const { status, body } = await liveblocks.identifyUser(
          {
            userId: user.id,
            groupIds, // Optional
          },
          { userInfo: user.metadata },
        );

        return new Response(body, { status });
      }
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Set up the client</StepTitle>
    <StepContent>
      On the front end, you can now replace the `publicApiKey`
      prop on [`LiveblocksProvider`](/docs/api-reference/liveblocks-react#LiveblocksProvider)
      with `authEndpoint` pointing to the endpoint you just created.

      ```tsx
      <LiveblocksProvider authEndpoint="/api/liveblocks-auth">
      ```

      If you need to pass custom headers or data to your endpoint, you can
      use
      [authEndpoint as a callback](/docs/api-reference/liveblocks-client#LiveblocksProviderCallback)
      instead.

      ```tsx title="Pass custom headers" isCollapsed isCollapsable
      <LiveblocksProvider
        authEndpoint={async (room) => {
          // Passing custom headers and body to your endpoint
          const headers = {
            // Custom headers
            // ...

            "Content-Type": "application/json",
          };

          const body = JSON.stringify({
            // Custom body
            // ...

            room,
          });

          const response = await fetch("/api/liveblocks-auth", {
            method: "POST",
            headers,
            body,
          });

          return await response.json();
        }}
      />
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Set permission accesses to a room</StepTitle>
    <StepContent>
      A room can have `defaultAccesses`, `usersAccesses`, and `groupsAccesses` defined.
      Permissions are then checked when users try to connect to a room. For security purposes,
      [room permissions](/docs/authentication/id-token#permissions) can only be set on the back-end through `@liveblocks/node` or our REST API.
      For instance, you can use [`liveblocks.createRoom`](/docs/api-reference/liveblocks-node#post-rooms)
      to create a new room with read-only public access levels while giving write access to specific groups and users.

      ```ts highlight="7-15"
      import { Liveblocks } from "@liveblocks/node";

      const liveblocks = new Liveblocks({
        secret: "{{SECRET_KEY}}",
      });

      const room = await liveblocks.createRoom("my-room-id", {
        defaultAccesses: ["room:read", "room:presence:write"],
        groupsAccesses: {
          "my-group-id": ["room:write"],
        },
        usersAccesses: {
          "my-user-id": ["room:write"],
        },
      });
      ```

      For more information, make sure to read the section on [room permissions](/docs/authentication/id-token#permissions).

    </StepContent>

  </Step>
  <Step lastStep>
    <StepTitle>Attach metadata to users</StepTitle>
      <StepContent>
        Optionally, you can attach static metadata to each user, which will
        be accessible in your app. First you need to define the types in
        your config file, under `UserMeta["info"]`.

        ```ts file="liveblocks.config.ts" highlight="7-11"
        declare global
          interface Liveblocks {
            UserMeta: {
              id: string;

              // Example, use any JSON-compatible data in your metadata
              info: {
                name: string;
                avatar: string;
                colors: string[];
              }
            }

            // Other type definitions
            // ...
          }
        }
        ```

        When authenticating, you can then pass the userâ€™s metadata to
        `prepareSession` in the endpoint weâ€™ve just created.

        ```ts file="app/routes/api/liveblocks-auth.ts" highlight="11-15"
        // Get the current user from your database
        const user = __getUserFromDB__(request);

        // Identify the user and return the result
        const { status, body } = await liveblocks.identifyUser(
          {
            userId: user.id,
            groupIds, // Optional
          },
          {
            userInfo: {
              name: user.name,
              avatar: user.avatarUrl,
              colors: user.colorArray,
            }
          },
        );
        ```

        User metadata has now been set! You can access this information in your app through
        [`useSelf`](/docs/api-reference/liveblocks-react#useSelf).

        ```tsx highlight="4"
        export { useSelf } from "@liveblocks/react/suspense";

        function Component() {
          const { name, avatar, colors } = useSelf((me) => me.info);
        }
        ```

        Bear in mind that if youâ€™re using the [default Comments components](/docs/api-reference/liveblocks-react-ui#Components),
        you must specify a `name` and `avatar` in `userInfo`.
      </StepContent>

    </Step>

</Steps>

## More information

Both `userId` and `userInfo` can then be used in your React application as such:

```ts
const self = useSelf();
console.log(self.id);
console.log(self.info);
```

<Figure>
  <Image
    src="/assets/id-token-auth-diagram.png"
    alt="Auth diagram"
    width={768}
    height={576}
  />
</Figure>

---
meta:
  title: "Set up ID token permissions with SvelteKit"
  parentTitle: "Authentication"
  description: "Learn how to setup ID token permissions with SvelteKit."
---

Follow the following steps to start configure your authentication endpoint and
start building your own security logic.

## Quickstart

<Steps>
  <Step>
    <StepTitle>Install the `liveblocks/node` package</StepTitle>
    <StepContent>

      ```bash
      npm install @liveblocks/node
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Set up authentication endpoint</StepTitle>
    <StepContent>
      Users can only interact with rooms they have access to. You can
      configure permission access in an `api/liveblocks-auth` endpoint by
      creating the `src/routes/api/liveblocks-auth/+server.ts` file with the
      following code. This is where you will implement your security and
      define if the current user has access to a specific room.

      ```ts file="src/routes/api/liveblocks-auth/+server.ts"
      import { type RequestEvent } from "@sveltejs/kit";
      import { Liveblocks } from "@liveblocks/node";

      const liveblocks = new Liveblocks({
        secret: "{{SECRET_KEY}}",
      });

      export async function POST({ request }: RequestEvent) {
        // Get the current user from your database
        const user = __getUserFromDB__(request);

        // Identify the user and return the result
        const { status, body } = await liveblocks.identifyUser(
          {
            userId: user.id,
            groupIds, // Optional
          },
          { userInfo: user.metadata },
        );

        return new Response(body, { status });
      }
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Set up the client</StepTitle>
    <StepContent>
      On the front end, you can now replace the `publicApiKey`
      option with `authEndpoint` pointing to the endpoint you
      just created.

      ```ts file="liveblocks.config.ts"
      import { createClient } from "@liveblocks/client";

      const client = createClient({
        authEndpoint: "/api/liveblocks-auth",
      });
      ```

      If you need to pass custom headers or data to your endpoint, you can
      use
      [authEndpoint as a callback](/docs/api-reference/liveblocks-client#createClientCallback)
      instead.

      ```ts file="liveblocks.config.ts" isCollapsed isCollapsable
      import { createClient } from "@liveblocks/client";

      // Passing custom headers and body to your endpoint
      const client = createClient({
        authEndpoint: async (room) => {
          const headers = {
            // Custom headers
            // ...

            "Content-Type": "application/json",
          };

          const body = JSON.stringify({
            // Custom body
            // ...

            room,
          });

          const response = await fetch("/api/liveblocks-auth", {
            method: "POST",
            headers,
            body,
          });

          return await response.json();
        },
      });
      ```

    </StepContent>

  </Step>
  <Step lastStep>
    <StepTitle>Set permission accesses to a room</StepTitle>
    <StepContent>
      A room can have `defaultAccesses`, `usersAccesses`, and `groupsAccesses` defined.
      Permissions are then checked when users try to connect to a room. For security purposes,
      [room permissions](/docs/authentication/id-token#permissions) can only be set on the back-end through `@liveblocks/node` or our REST API.
      For instance, you can use [`liveblocks.createRoom`](/docs/api-reference/liveblocks-node#post-rooms)
      to create a new room with read-only public access levels while giving write access to specific groups and users.

      ```ts highlight="7-15"
      import { Liveblocks } from "@liveblocks/node";

      const liveblocks = new Liveblocks({
        secret: "{{SECRET_KEY}}",
      });

      const room = await liveblocks.createRoom("my-room-id", {
        defaultAccesses: ["room:read", "room:presence:write"],
        groupsAccesses: {
          "my-group-id": ["room:write"],
        },
        usersAccesses: {
          "my-user-id": ["room:write"],
        },
      });
      ```

      For more information, make sure to read the section on [room permissions](/docs/authentication/id-token#permissions).

    </StepContent>

  </Step>
</Steps>

## More information

Both `userId` and `userInfo` can then be used in your Svelte application as
such:

```ts
const self = room.getSelf();
console.log(self.id);
console.log(self.info.color);
```

<Figure>
  <Image
    src="/assets/id-token-auth-diagram.png"
    alt="Auth diagram"
    width={768}
    height={576}
  />
</Figure>

---
meta:
  title: "Tenants"
  parentTitle: "Authentication"
  description: "Learn more about tenants"
---

Tenants allow you to compartmentalize Liveblocks resources, such as inbox
notifications, rooms, and everything associated with rooms such as comment
threads, realtime data stored, and more. Each tenant represents a separate
organization or customer in your system, meaning you can easily add a
workspace/org switcher to your application, with each workspace having its own
notification inbox.

<Banner title="Tenants is optional">

If you donâ€™t specify a tenant, no configuration is needed. By default, resources
belong to the `default` tenant ID.

</Banner>

<Figure>
  <Image
    src="/assets/tenants/concept-tenants.png"
    alt="Concept of tenants"
    width={1494}
    height={840}
    quality={100}
  />
</Figure>

### Setting up tenants

To set up Tenants, you just need to set a `tenantId` when creating a resource,
for example, when creating a room.

```ts
const room = await liveblocks.createRoom("my-room-id", {
  // +++
  tenantId: "my-tenant-id",
  // +++
});
```

<Banner title="You canâ€™t change a resourceâ€™s tenant" type="warning">

Itâ€™s not possible to change a resourceâ€™s `tenantId` after creation. You will
need to migrate the resource into a new room in the correct tenant.

</Banner>

#### Resources using tenants

A number of Liveblocks resources use tenants, such as rooms, comments, text
editors, Yjs, Storage, inbox notifications, mention groups.

```ts
const { data: rooms, nextCursor } = await liveblocks.getRooms({
  // +++
  tenantId: "my-tenant-id",
  // +++
});

await liveblocks.triggerInboxNotification({
  userId: "steven@example.com",
  kind: "$fileUploaded",
  subjectId: "my-file",
  activityData: {},
  // +++
  tenantId: "my-tenant-id",
  // +++
});

await liveblocks.deleteAllInboxNotifications({
  userId: "steven@example.com",
  // +++
  tenantId: "my-tenant-id",
  // +++
});

const { data, nextCursor } = await liveblocks.getUserRoomSubscriptionSettings({
  userId: "steven@example.com",
  // +++
  tenantId: "my-tenant-id",
  // +++
});
```

Above you can see [`getRooms`](/docs/api-reference/liveblocks-node#get-rooms),
[`triggerInboxNotification`](/docs/api-reference/liveblocks-node#post-inbox-notifications-trigger),
[`deleteAllInboxNotifications`](/docs/api-reference/liveblocks-node#delete-users-userId-inboxNotifications)
and
[`getUserRoomSubscriptionSettings`](/docs/api-reference/liveblocks-node#get-users-userId-room-subscription-settings)
using tenants. Tenants can also be used with the
[REST API](/docs/api-reference/rest-api-endpoints).

### Authentication

When authorizing a user with Liveblocks, you can specify the tenant they belong
to. Each user is only authorized for one tenant at a time, meaning they need to
re-authenticate to access resources in another tenant, such as notifications.
Tenants can be used with both [ID Token](/docs/authentication/id-token) and
[Access Token](/docs/authentication/access-token) authentication.

#### With ID tokens

When using ID tokens, you can set the `tenantId` when using `identifyUser`.
Tokens generated for a specific tenant, will only allow access to resources
inside this tenant, even if the user has access to rooms in other tenants.

```ts highlight="3"
const { body, status } = await liveblocks.identifyUser({
  userId: "olivier@example.com",
  tenantId: "tenant123",
});

// '{ token: "eyJga7..." }'
console.log(body);
```

Learn more about [ID tokens](/docs/authentication/id-token).

#### With access tokens

When using access tokens, you can set the `tenantId` when you prepare a session.
Tokens generated for a specific tenant, will only allow access to resources
inside this tenant, even if the token has permissions to rooms in other tenants.

```ts highlight="2"
const session = liveblocks.prepareSession("olivier@example.com", {
  tenantId: "tenant123",
});

// Giving full access to one room
session.allow("Vu78Rt:design:9Hdu73", session.FULL_ACCESS);

// Give full access to every room with an ID beginning with "Vu78Rt:product:"
session.allow("Vu78Rt:product:*", session.FULL_ACCESS);

const { body, status } = await session.authorize();
```

Learn more about [access tokens](/docs/authentication/access-token).

#### Switching tenants

The easiest way to switch tenants is to refresh the page, for example with
`location.reload()`, then pass a new `tenantId` to your chosen authentication
method.

---
meta:
  title: "Concepts"
  description:
    "Liveblocks is the collaboration layer for your product. This page
    introduces the core concepts behind Liveblocks so you understand how
    everything fits together."
---

Liveblocks is the collaboration layer for your product. It provides the
architecture, realtime backend, and ready-made features that let humans and AI
collaborate inside your appâ€”both in realtime and asynchronously. Think of
Liveblocks as the collaboration architecture your product never had. This page
introduces the core concepts behind Liveblocks so you understand how everything
fits together.

<Figure>
  <Image
    src="/assets/concepts/liveblocks-collaboration-infrastructure.png"
    alt="Liveblocks collaboration infrastructure"
    width={1344}
    height={1734}
    quality={100}
  />
</Figure>

## What is Liveblocks?

Liveblocks is the collaboration layer for your product. Itâ€™s built on a small
set of foundational concepts list below. These concepts work together to let
people and AI collaborate inside your app, without changing your existing
authentication, backend, or data model.

| Concept             | Description                                                                               |
| ------------------- | ----------------------------------------------------------------------------------------- |
| Projects            | Top-level container for your application                                                  |
| Tenants             | Compartmentalize rooms and notifications per organization                                 |
| Rooms               | Spaces in your product where collaboration happens, such as documents                     |
| Collaborators       | People (users) and AI agents doing work together                                          |
| Ready-made features | Collaboration building blocks like Comments, Multiplayer, Notifications, and AI Agents    |
| Platform            | The realtime backend, admin dashboard, and SDKs that make collaboration possible at scale |

<Figure>
  <Image
    src="/assets/concepts/liveblocks-structure.png"
    alt="Liveblocks structure"
    width={1344}
    height={760}
    quality={100}
  />
</Figure>

## Projects

A project is the top-level container in your Liveblocks team workspace that
usually maps to an application. Each project includes things like API keys,
rooms, AI agents, usage metrics, event logs, webhook settings, notification
settings, region and environment settings, and more.

### Regions

You can choose to locate a project in one of the following regions. The region
cannot be changed once the project has been created.

| Region | Data hosted                                           | Availability                |
| ------ | ----------------------------------------------------- | --------------------------- |
| Earth  | Globally on Cloudflare edge servers and AWS usâ€‘eastâ€‘1 | All plans                   |
| US     | US only with Cloudflare FedRAMP and AWS usâ€‘eastâ€‘1     | [Enterprise plan](/pricing) |
| EU     | EU only with Cloudflare EU and AWS euâ€‘centralâ€‘1       | [Enterprise plan](/pricing) |

### Environments

You can assign one of the following environment tags to a project. The
environment tag cannot be changed once the project has been created. Teams
typically create separate projects for production, staging, and development.
Encrypted keys and higher limits apply to production environment projects.

| Environment | Description                               |
| ----------- | ----------------------------------------- |
| Development | For development, testing, and prototyping |
| Production  | For production                            |

## Tenants

Tenants allow you to compartmentalize Liveblocks resources, such as inbox
notifications, rooms, and everything associated with rooms such as comment
threads, realtime data stored, and more. Each tenant represents a separate
organization or customer in your system, meaning you can easily add a
workspace/org switcher to your application, with each workspace having its own
notification inbox. Each project can have multiple tenants, though only one is
required.

## Rooms

A room is the space where people and AI collaborate together. Inside a room, you
can enable things like presence, shared state for multiplayer interactions,
contextual comment threads, @ mentions and actions that trigger notifications.

<Figure>
  <Image
    src="/assets/concepts/liveblocks-rooms.png"
    alt="Liveblocks rooms. The space where people and AI collaborate."
    width={1536}
    height={880}
    quality={100}
  />
</Figure>

Rooms typically map to artifacts people and AI can create inside your product,
such as text documents, workflow diagrams, spreadsheets, whiteboards, forms, 3D
files, video editors, design files, presentations, and more.

## Ready-made features

Liveblocks includes a set of collaboration building blocks you can use
individually or together. These ready-made features provide pre-built
components, hooks, and APIs that handle the complexity of realtime
collaboration, allowing you to focus on building your productâ€™s unique
experience.

<ListGrid columns={2}>
  <DocsCardFeature
    feature="comments"
    href="/docs/ready-made-features/comments"
  />
  <DocsCardFeature
    feature="multiplayer"
    href="/docs/ready-made-features/multiplayer"
  />
  <DocsCardFeature
    feature="ai-agents"
    href="/docs/ready-made-features/ai-agents"
  />
  <DocsCardFeature
    feature="notifications"
    href="/docs/ready-made-features/notifications"
  />
</ListGrid>

## Collaborators

Collaborators are the entities that do work together in your application.
Liveblocks provides the infrastructure and ready-made features they use to
collaborate. There are two types of collaborators: users (people) and AI agents.

### Users

Users are the authenticated people using your application. Liveblocks only needs
a `userId` to identify them. Users can:

- View and edit content.
- See presence and activity.
- Leave contextual comments.
- @ mention users, groups, and AI agents.
- Receive notifications.

### AI Agents

AI agents are AI-driven collaborators that can act inside your product.
Liveblocks supports two types of agents: Liveblocks AI Copilots and framework
agents (private beta).

#### Liveblocks AI Copilots

Configured directly in the dashboard. Ideal for chatbot-style assistive
behavior.

- Works with any LLM (OpenAI, Anthropic, Gemini, or custom).
- Supports RAG knowledge from PDFs, images, websites, and text.
- Fully compatible with the
  [`<AiChat />`](/docs/ready-made-features/ai-agents/liveblocks-ai-copilots/default-components#AiChat)
  component.
- Acts on behalf of a user to take actions inside your app.
- Accessed through chat (not via @ mentions).

#### Framework agents (private beta)

Use external agents powered by your own infrastructure or tools like
[n8n](https://n8n.io/), [LangChain](https://www.langchain.com/),
[Crew AI](https://crewai.com/), and more. Framework agents behave like true
collaborators.

- They appear in rooms with presence.
- Users can @mention them in comments or text documents.
- Room events (mentions, edits, messages) are sent to your webhook endpoint.
- Your agent returns actions that update UI, create comments, or drive
  workflows.

<Banner type="info" title="Private beta">

Framework agents are currently in private beta. If you would like access to the
beta, please [contact us](https://liveblocks.io/contact/sales). Weâ€™d love to
hear from you.

</Banner>

## Platform

The Liveblocks Platform powers collaboration at runtime through a realtime back
end, using WebSocket infrastructure to handle presence, connection management,
low-latency messaging, and room orchestration. Async pipelines manage
notification delivery, webhooks, and event batching and grouping. An admin
dashboard provides usage and monitoring, project and API keys management,
webhook management, notification channel management, hosting regions, and event
logs. The platform also includes a
[DevTools browser extension](/docs/platform/devtools) and a comprehensive set of
SDKs and packages.

### SDKs and packages

<ListGrid columns={2}>
  <DocsCard
    type="technology"
    title="JavaScript"
    href="/docs/api-reference/liveblocks-client"
    description="@liveblocks/client"
    visual={<DocsJavascriptIcon />}
  />
  <DocsCard
    type="technology"
    title="React"
    href="/docs/api-reference/liveblocks-react"
    description="@liveblocks/react"
    visual={<DocsReactIcon />}
  />
  <DocsCard
    type="technology"
    title="React UI"
    href="/docs/api-reference/liveblocks-react-ui"
    description="@liveblocks/react-ui"
    visual={<DocsReactIcon />}
  />
  <DocsCard
    type="technology"
    title="React Tiptap"
    href="/docs/api-reference/liveblocks-react-tiptap"
    description="@liveblocks/react-tiptap"
    visual={<DocsReactIcon />}
  />
  <DocsCard
    type="technology"
    title="React BlockNote"
    href="/docs/api-reference/liveblocks-react-blocknote"
    description="@liveblocks/react-blocknote"
    visual={<DocsReactIcon />}
  />
  <DocsCard
    type="technology"
    title="Node.js ProseMirror"
    href="/docs/api-reference/liveblocks-node-prosemirror"
    description="@liveblocks/node-prosemirror"
    visual={<DocsNodejsIcon />}
  />
  <DocsCard
    type="technology"
    title="React Lexical"
    href="/docs/api-reference/liveblocks-react-lexical"
    description="@liveblocks/react-lexical"
    visual={<DocsReactIcon />}
  />
  <DocsCard
    type="technology"
    title="Node.js Lexical"
    href="/docs/api-reference/liveblocks-node-lexical"
    description="@liveblocks/node-lexical"
    visual={<DocsNodejsIcon />}
  />
  <DocsCard
    type="technology"
    title="Redux"
    href="/docs/api-reference/liveblocks-redux"
    description="@liveblocks/redux"
    visual={<DocsReduxIcon />}
  />
  <DocsCard
    type="technology"
    title="Zustand"
    href="/docs/api-reference/liveblocks-zustand"
    description="@liveblocks/zustand"
    visual={
      <img
        alt=""
        src="/assets/zustand.png"
        width={24}
        height={24}
        loading="lazy"
      />
    }
  />
  <DocsCard
    type="technology"
    title="Yjs"
    href="/docs/api-reference/liveblocks-yjs"
    description="@liveblocks/yjs"
    visual={<DocsYjsIcon className="fill-product-icon-brand h-auto w-6" />}
  />
  <DocsCard
    type="technology"
    title="Node.js"
    href="/docs/api-reference/liveblocks-node"
    description="@liveblocks/node"
    visual={<DocsNodejsIcon />}
  />
  <DocsCard
    type="technology"
    title="Node.js Emails"
    href="/docs/api-reference/liveblocks-emails"
    description="@liveblocks/emails"
    visual={<DocsNodejsIcon />}
  />
  <DocsCard
    type="technology"
    title="REST API"
    href="/docs/api-reference/rest-api-endpoints"
    description="HTTP endpoints"
    visual={<DocsApiIcon className="fill-product-icon-brand h-auto w-6" />}
  />
</ListGrid>

---
meta:
  title:
    "At least one of the custom notification kinds you provided for
    'ActivitiesData' does not match its requirements"
  parentTitle: "Error"
  description: "Your 'ActivitiesData' type is incorrect and needs to be updated"
---

## Why this error occurred

You have provided a custom `ActivitiesData` type for your application, but the
type you provided isnâ€™t a (completely) valid definition.

```ts highlight="4-8"
declare global {
  interface Liveblocks {
    ActivitiesData: {
      // Your custom notification kinds go here...
      $error: {
        code: number;
        date: Date; // âŒ Values must simple
      };
      // âŒ Custom notification kinds must start with $
      success: {
        message: string;
      };
    };
  }
}
```

In the example above, there are two problems. Activities data may only contain
simple key/value pairs, where the values must always be assignable to
`string | number | boolean | undefined` and custom notification kinds must start
with `$`.

## How to fix it

Youâ€™ll need to figure out what part of your provided `ActivitiesData` type
definition isnâ€™t valid. The example above could be fixed as such:

```ts highlight="6-8"
declare global {
  interface Liveblocks {
    ActivitiesData: {
      // Your custom notification kinds go here...
      $error: {
        code: number;
        date: string;
      };
      $success: {
        message: string;
      };
    };
  }
}
```

## If you cannot find the root cause

Sometimes types can be complex and the root cause is still unclear. In those
cases, there is a small trick you can use. Try to assign your type to the
required base type, with this line:

```ts highlight="9-10"
import type { BaseActivitiesData } from "@liveblocks/client";

declare global {
  interface Liveblocks {
    ActivitiesData: MyActivitiesData;
  }
}

// Quick debugging snippet to find root cause
const xxx: BaseActivitiesData = {} as MyActivitiesData;
//    ^?
//    The error will appear here
```

Now TypeScript will explain why it thinks your type isnâ€™t valid:

```error showLineNumbers={false}
Type 'MyActivitiesData' is not assignable to type 'BaseActivitiesData'.
  Property 'date' is incompatible with index signature.
    Type 'Date' is not assignable to type 'string | number | boolean | undefined'.
```

---
meta:
  title:
    "The type you provided for 'CommentMetadata' does not match its requirements"
  parentTitle: "Error"
  description:
    "Your 'CommentMetadata' type is incorrect and needs to be updated"
---

## Why this error occurred

You have provided a custom `CommentMetadata` type for your application, but the
type you provided isnâ€™t a (completely) valid definition.

```ts highlight="4-8"
declare global {
  interface Liveblocks {
    CommentMetadata: {
      // Your custom fields go here...
      spoiler: boolean;
      userAgent: string | null; // âŒ Values may not be null
      slack: { channelId: string; messageId: string }; // âŒ Values must be simple
      priority?: number;
    };
  }
}
```

In the example above, there are two problems. Comment metadata may only contain
simple key/value pairs, where the values must always be assignable to
`string | number | boolean | undefined`.

## How to fix it

Youâ€™ll need to figure out what part of your provided `CommentMetadata` type
definition isnâ€™t valid. The example above could be fixed as such:

```ts highlight="6-8"
declare global {
  interface Liveblocks {
    CommentMetadata: {
      // Your custom fields go here...
      spoiler: boolean;
      userAgent?: string; // âœ…
      slackChannelId: string; // âœ…
      slackMessageId: string; // âœ…
      priority?: number;
    };
  }
}
```

## If you cannot find the root cause

Sometimes types can be complex and the root cause is still unclear. In those
cases, there is a small trick you can use. Try to assign your type to the
required base type, with this line:

```ts highlight="9-10"
import type { BaseMetadata } from "@liveblocks/client";

declare global {
  interface Liveblocks {
    CommentMetadata: MyCommentMetadata;
  }
}

// Quick debugging snippet to find root cause
const xxx: BaseMetadata = {} as MyCommentMetadata;
//    ^?
//    The error will appear here
```

Now TypeScript will explain why it thinks your type isnâ€™t valid metadata:

```error showLineNumbers={false}
Type 'MyCommentMetadata' is not assignable to type 'BaseMetadata'.
  Property 'userAgent' is incompatible with index signature.
    Type 'string | null' is not assignable to type 'string | number | boolean | undefined'.
      Type 'null' is not assignable to type 'string | number | boolean | undefined'.
```

---
meta:
  title: "The type you provided for 'Presence' is not a valid JSON object"
  parentTitle: "Error"
  description: "Your 'Presence' type is incorrect and needs to be updated"
---

## Why this error occurred

You have provided a custom `Presence` type for your application, but the type
you provided isnâ€™t a (completely) valid JSON object. Values like `Date`, `Map`,
`Set`, functions, classes, or `unknown` arenâ€™t valid JSON.

```ts highlight="4-7"
declare global {
  interface Liveblocks {
    Presence: {
      // Your own fields go here...
      cursor: { x: number; y: number } | null;
      selection: string[];
      lastActivity: Date; // âŒ The issue is here
    };
  }
}
```

In the example above, the problem is in the `Date` field, because a `Date` isnâ€™t
a valid JSON value.

## How to fix it

Youâ€™ll need to figure out what part of your provided `Presence` type definition
isnâ€™t valid JSON. Sometimes this is immediately obvious, like in the example
above.

Sometimes the issue may be a bit less obvious:

```ts highlight="6-7"
import type { Json } from "@liveblocks/client";

declare global {
  interface Liveblocks {
    Presence: {
      cursor: unknown; // âŒ Unknowns could contain non-JSON
      cursor: Json; // âœ… Prefer using Json
    };
  }
}
```

By using `Json`, you can still work with unknown or unspecified values, but
still ensure they will be valid JSON.

## If you cannot find the root cause

Sometimes types can be complex and the root cause is still unclear. In those
cases, there is a small trick you can use. Try to assign your type to the
required base type, with this line:

```ts highlight="9-10"
import type { JsonObject } from "@liveblocks/client";

declare global {
  interface Liveblocks {
    Presence: MyPresence;
  }
}

// Quick debugging snippet to find root cause
const xxx: JsonObject = {} as MyPresence;
//    ^?
//    The error will appear here
```

Now TypeScript will explain why it thinks your type isnâ€™t valid JSON:

```error showLineNumbers={false}
Type 'MyPresence' is not assignable to type 'JsonObject'.
 Property 'lastActivity' is incompatible with index signature.
   Type 'Date' is not assignable to type 'Json | undefined'.
     Type 'Date' is not assignable to type 'JsonObject'.
       Index signature for type 'string' is missing in type 'Date'.
```

---
meta:
  title: "The type you provided for 'RoomEvent' is not a valid JSON value"
  parentTitle: "Error"
  description: "Your 'RoomEvent' type is incorrect and needs to be updated"
---

## Why this error occurred

You have provided a custom `RoomEvent` type for your application, but the type
you provided isnâ€™t a (completely) valid JSON value. Values like `Date`, `Map`,
`Set`, functions, classes, or `unknown` arenâ€™t valid JSON.

For example, suppose you have defined three broadcastable events for your
application:

```ts highlight="4-7"
declare global {
  interface Liveblocks {
    RoomEvent:
      | { type: "beep" }
      | { type: "boop"; target: HtmlElement }
      //                        ^^^^^^^^^^^ âŒ The issue is here
      | { type: "buzz"; volume: number };
  }
}
```

In the example above, the problem is in the `HTMLElement` field, because a
`HTMLElement` isnâ€™t a valid JSON value.

## How to fix it

Youâ€™ll need to figure out what part of your provided `RoomEvent` type definition
isnâ€™t valid JSON. Sometimes this is immediately obvious, but sometimes the issue
may be a bit less obvious.

## If you cannot find the root cause

Sometimes types can be complex and the root cause is still unclear. In those
cases, there is a small trick you can use. Try to assign your type to the
required base type, with this line:

```ts highlight="9-10"
import type { Json } from "@liveblocks/client";

declare global {
  interface Liveblocks {
    RoomEvent: MyRoomEvent;
  }
}

// Quick debugging snippet to find root cause
const xxx: Json = {} as MyRoomEvent;
//    ^?
//    The error will appear here
```

Now TypeScript will explain why it thinks your type isnâ€™t valid JSON:

```error showLineNumbers={false}
Type 'MyRoomEvent' is not assignable to type 'Json'.
  Type '{ type: "boop"; target: HTMLElement; }' is not assignable to type 'Json'.
    Type '{ type: "boop"; target: HTMLElement; }' is not assignable to type 'JsonObject'.
      Property 'target' is incompatible with index signature.
        Type 'HTMLElement' is not assignable to type 'Json | undefined'.
          Type 'HTMLElement' is not assignable to type 'JsonObject'.
            Index signature for type 'string' is missing in type 'HTMLElement'.
```

---
meta:
  title: "The type you provided for 'RoomInfo' does not match its requirements"
  parentTitle: "Error"
  description: "Your 'RoomInfo' type is incorrect and needs to be updated"
---

## Why this error occurred

You have provided a custom `RoomInfo` type for your application, but the type
you provided isnâ€™t a (completely) valid definition.

```ts highlight="4-10"
declare global {
  interface Liveblocks {
    RoomInfo: {
      // Your custom fields go here...
      name: string;
      url: URL; // âŒ The issue is here
      geo: {
        city: string;
        country: string;
      };
    };
  }
}
```

In the example above, the problem is the `URL` field. Values like `Date`, `Map`,
`Set`, functions, classes (including `URL`), or `unknown` arenâ€™t valid JSON.

## The rules of the RoomInfo type

The following rules apply if you want to specify a custom `RoomInfo` type:

- You can provide any keys and values here, as long as the values are valid
  JSON.
- Two small constraints:
  - _If_ you specify `name`, it _must_ be assignable to `string | undefined`.
  - _If_ you specify `url`, then it _must_ be assignable to
    `string | undefined`.

The reason for these two restrictions is that some of our higher-level
components will pick these values up and use them to provide default UIs.

## How to fix it

Youâ€™ll need to figure out what part of your provided `RoomInfo` type definition
isnâ€™t valid. The example above can be fixed as follows:

```tsx
declare global {
  interface Liveblocks {
    RoomInfo: {
      // Your custom fields go here...
      name: string;
      url: string; // âœ… Valid
      geo: {
        city: string;
        country: string;
      };
    };
  }
}
```

## If you cannot find the root cause

Sometimes types can be complex and the root cause is still unclear. In those
cases, there is a small trick you can use. Try to assign your type to the
required base type, with this line:

```ts highlight="9-10"
import type { BaseRoomInfo } from "@liveblocks/client";

declare global {
  interface Liveblocks {
    RoomInfo: MyRoomInfo;
  }
}

// Quick debugging snippet to find root cause
const xxx: BaseRoomInfo = {} as MyRoomInfo;
//    ^?
//    The error will appear here
```

Now TypeScript will explain why it thinks your type isnâ€™t valid room info:

```error showLineNumbers={false}
Type 'MyRoomInfo' is not assignable to type 'BaseRoomInfo'.
  Types of property 'url' are incompatible.
    Type 'URL' is not assignable to type 'string'.
```

---
meta:
  title: "The type you provided for 'Storage' is not a valid LSON value"
  parentTitle: "Error"
  description: "Your 'Storage' type is incorrect and needs to be updated"
---

## Why this error occurred

You have provided a custom `Storage` type for your application, but the type you
provided isnâ€™t a (completely) valid LSON object. Values like `Date`, `Map`,
`Set`, functions, classes, or `unknown` arenâ€™t valid LSON.

<Banner type="success" title="What was LSON again?">

LSON is either a valid JSON value, or an instance of `LiveMap`, `LiveList`, or
`LiveObject`.

</Banner>

```ts highlight="6"
declare global {
  interface Liveblocks {
    Storage: {
      layers: LiveMap<string, LiveObject<Layer>>;
      layerIds: LiveList<string>;
      createdAt: Date; // âŒ The issue is here
    };
  }
}
```

In the example above, the problem is in the `Date` field, because a `Date` isnâ€™t
a valid LSON value.

## How to fix it

Youâ€™ll need to figure out what part of your provided `Storage` type definition
isnâ€™t valid LSON. Sometimes this is immediately obvious, like in the example
above.

Sometimes the issue may be a bit less obvious:

```ts highlight="7-8"
import type { Lson } from "@liveblocks/client";

declare global {
  interface Liveblocks {
    Storage: {
      layers: LiveMap<string, LiveObject<Layer>>;
      layerIds: LiveList<unknown>; // âŒ Unknowns could contain non-LSON
      layerIds: LiveList<Lson>; // âœ… Prefer using Lson
    };
  }
}
```

By using `Lson`, you can still work with unknown or unspecified values, but
still ensure they will be valid LSON.

## If you cannot find the root cause

Sometimes types can be complex and the root cause is still unclear. In those
cases, there is a small trick you can use. Try to assign your type to the
required base type, with this line:

```ts highlight="9-10"
import type { LsonObject } from "@liveblocks/client";

declare global {
  interface Liveblocks {
    Storage: MyStorage;
  }
}

// Quick debugging snippet to find root cause
const xxx: LsonObject = {} as MyStorage;
//    ^?
//    The error will appear here
```

Now TypeScript will explain why it thinks your type isnâ€™t valid LSON:

```error showLineNumbers={false}
Type 'MyStorage' is not assignable to type 'LsonObject'.
  Property 'layerIds' is incompatible with index signature.
    Type 'LiveList<unknown>' is not assignable to type 'Lson | undefined'.
      Type 'LiveList<unknown>' is not assignable to type 'LiveList<Lson>'.
        The types returned by 'toArray()' are incompatible between these types.
          Type 'unknown[]' is not assignable to type 'Lson[]'.
            Type 'unknown' is not assignable to type 'Lson'.
```

---
meta:
  title:
    "The type you provided for 'ThreadMetadata' does not match its requirements"
  parentTitle: "Error"
  description: "Your 'ThreadMetadata' type is incorrect and needs to be updated"
---

## Why this error occurred

You have provided a custom `ThreadMetadata` type for your application, but the
type you provided isnâ€™t a (completely) valid definition.

```ts highlight="4-8"
declare global {
  interface Liveblocks {
    ThreadMetadata: {
      // Your custom fields go here...
      pinned: boolean;
      color: string | null; // âŒ Values may not be null
      position: { x: number; y: number }; // âŒ Values must be simple
      zIndex?: number;
    };
  }
}
```

In the example above, there are two problems. Thread metadata may only contain
simple key/value pairs, where the values must always be assignable to
`string | number | boolean | undefined`.

## How to fix it

Youâ€™ll need to figure out what part of your provided `ThreadMetadata` type
definition isnâ€™t valid. The example above could be fixed as such:

```ts highlight="6-8"
declare global {
  interface Liveblocks {
    ThreadMetadata: {
      // Your custom fields go here...
      pinned: boolean;
      color?: string; // âœ…
      positionX: number; // âœ…
      positionY: number; // âœ…
      zIndex?: number;
    };
  }
}
```

## If you cannot find the root cause

Sometimes types can be complex and the root cause is still unclear. In those
cases, there is a small trick you can use. Try to assign your type to the
required base type, with this line:

```ts highlight="9-10"
import type { BaseMetadata } from "@liveblocks/client";

declare global {
  interface Liveblocks {
    ThreadMetadata: MyThreadMetadata;
  }
}

// Quick debugging snippet to find root cause
const xxx: BaseMetadata = {} as MyThreadMetadata;
//    ^?
//    The error will appear here
```

Now TypeScript will explain why it thinks your type isnâ€™t valid metadata:

```error showLineNumbers={false}
Type 'MyThreadMetadata' is not assignable to type 'BaseMetadata'.
  Property 'color' is incompatible with index signature.
    Type 'string | null' is not assignable to type 'string | number | boolean | undefined'.
      Type 'null' is not assignable to type 'string | number | boolean | undefined'.
```

---
meta:
  title: "The type you provided for 'UserMeta' does not match its requirements"
  parentTitle: "Error"
  description: "Your 'UserMeta' type is incorrect and needs to be updated"
---

## Why this error occurred

You have provided a custom `UserMeta` type for your application, but the type
you provided isnâ€™t a (completely) valid definition.

```ts highlight="4-10"
declare global {
  interface Liveblocks {
    UserMeta: {
      id: string;
      info: {
        name: string;
        color: string;
        picture: string;
        lastLogin: Date; // âŒ The issue is here
      };
    };
  }
}
```

In the example above, the problem is in the `Date` field. Values like `Date`,
`Map`, `Set`, functions, classes, or `unknown` arenâ€™t valid JSON.

## The rules of the UserMeta type

The following rules apply if you want to specify a custom `UserMeta` type:

- Top-level fields `id` and `info` are special. They are optional, but only
  these two fields can exist. Extra fields you specify will not have any effect
  and will be ignored.
- _If_ you specify `id`, it _must_ still be assignable to `string | undefined`.
- _If_ you specify `info`, then it _must_ be a valid JSON object value.
  Furthermore:
  - _If_ you specify a `name` field inside `info`, it _must_ still be assignable
    to `string | undefined`.
  - _If_ you specify a `avatar` field inside `info`, it _must_ still be
    assignable to `string | undefined`.

The reason for the last two restrictions is that some of our higher-level
components will pick these values up and use them to provide default UIs.

```tsx
declare global {
  interface Liveblocks {
    UserMeta: {
      id: string; // âœ… Valid
      id?: string; // âœ… Valid
      id?: number; // âŒ Invalid, not assignable to string | undefined

      info: {
        name: string; // âœ… Valid
        name?: string; // âœ… Valid
        name: number; // âŒ Invalid, not assignable to string | undefined

        avatar: string; // âœ… Valid
        avatar?: string; // âœ… Valid
        avatar: number; // âŒ Invalid, not assignable to string | undefined

        // Other field names are not special and are free-form
        custom: string; // âœ… Valid
        custom?: string; // âœ… Valid
        custom: number; // âœ… Valid
        custom: Json; // âœ… Valid, can take _any_ valid Json value

        // However, they still need to be valid JSON
        custom: unknown; // âŒ Invalid, not value JSON
      };
    };
  }
}
```

Also please note:

```tsx
declare global {
  interface Liveblocks {
    UserMeta: {
      id: string;
      info: { name: string };

      // Only `id` or `info` make sense inside `UserMeta`
      iWillBeIgnored: string;
    };
  }
}
```

## How to fix it

Youâ€™ll need to figure out what part of your provided `UserMeta` type definition
isnâ€™t valid. Sometimes this is immediately obvious, but sometimes the issue may
be a bit less obvious.

## If you cannot find the root cause

Sometimes types can be complex and the root cause is still unclear. In those
cases, there is a small trick you can use. Try to assign your type to the
required base type, with this line:

```ts highlight="9-10"
import type { BaseUserMeta } from "@liveblocks/client";

declare global {
  interface Liveblocks {
    UserMeta: MyUserMeta;
  }
}

// Quick debugging snippet to find root cause
const xxx: BaseUserMeta = {} as MyUserMeta;
//    ^?
//    The error will appear here
```

Now TypeScript will explain why it thinks your type isnâ€™t valid JSON:

```error showLineNumbers={false}
Type 'MyUserMeta' is not assignable to type 'BaseUserMeta'.
  Types of property 'info' are incompatible.
    Type '{ name: string; color: string; picture: string; lastLogin: Date; }' is not assignable to type 'IUserInfo'.
      Property 'lastLogin' is incompatible with index signature.
        Type 'Date' is not assignable to type 'Json | undefined'.
          Type 'Date' is not assignable to type 'JsonObject'.
            Index signature for type 'string' is missing in type 'Date'.
```

---
meta:
  title: "Cross-linked Liveblocks versions are found in your project"
  parentTitle: "Error"
  description:
    "Cross-linked Liveblocks versions are found in your project. This will cause
    issues!"
---

## Why this error occurred

Youâ€™re using multiple `@liveblocks/*` packages in your application bundle, but
theyâ€™re not all on the same version.

For example: youâ€™re using `@liveblocks/zustand` at 1.1.3, but
`@liveblocks/react` is on 1.1.4.

## How to find the culprit?

To find out if your project is affected, you can run

```bash
npm ls | grep @liveblocks
```

Please make sure that all of the versions listed there are on the same version.

## Possible ways to fix it

When you upgrade one Liveblocks package, make sure to also upgrade other
Liveblocks packages to the same version. The easiest way to upgrade all your
Liveblocks packages to the same version is:

- Upgrades to the latest version:
  ```bash
  npx create-liveblocks-app@latest --upgrade
  ```
- Upgrades to a specific version:
  ```bash
  npx create-liveblocks-app@latest --upgrade=3.13.3
  ```

---
meta:
  title: "Multiple copies of Liveblocks are being loaded in your project"
  parentTitle: "Error"
  description:
    "Multiple copies of Liveblocks are being loaded in your project. This will
    cause issues!"
---

## Why this error occurred

Multiple copies of some Liveblocks package ended up being bundled in your
application bundle.

This can happen because your production bundle includes two entire copies of two
different versions of Liveblocks. Or it can be the case that it includes the
same version of Liveblocks in the bundle twice because the ESM and the CJS
version got bundled separately.

Itâ€™s important that only a single copy of Liveblocks exists in your application
bundle at runtime, otherwise bugs will happen. Plus your bundle will be
unnecessarily large.

## Possible causes

- Your project is using
  [internal packages](#using-liveblocks-with-internal-packages) that also rely
  on Liveblocks, but maybe some are on different versions.
- Your project is using a non-standard bundler setup. If you believe this is an
  issue with the way Liveblocks is packaged, feel free to open a support
  request.

## Possible ways to fix it

To investigate your setup, run the following command to see if all your
Liveblocks dependencies are on the same version:

```bash
npm ls | grep @liveblocks
```

If they're not all on the same version, you can upgrade them by running:

```bash
npx create-liveblocks-app@latest --upgrade
```

If you're using shared internal packages that depend on Liveblocks, see
[Using Liveblocks with internal packages](#using-liveblocks-with-internal-packages)
below for the recommended setup.

If all your Liveblocks dependencies are on the same version already, and you're
still seeing this error, youâ€™re experiencing the
[dual-package hazard](https://nodejs.org/api/packages.html#dual-package-hazard)
problem, which means that both the ESM and the CJS version of Liveblocks end up
in your production bundle as two separate "instances". Of course, this isnâ€™t
supposed to happen. Please let us know about this by
[opening a GitHub issue](https://github.com/liveblocks/liveblocks/issues/new?template=bug_report.md),
or reaching out in our support channel on
[Discord](https://liveblocks.io/discord).

## Using Liveblocks with internal packages

Consider a setup where you have two applications that both depend on Liveblocks
directly, and on a shared internal package that also depends on Liveblocks.

If the shared package declares Liveblocks as a regular dependency, your package
manager will install the Liveblocks version specified by the shared package,
which may conflict with the version your application needs:

![Do not pin the Liveblocks dependency in your shared library as it can lead to conflicts](/assets/errors/dont-use-normal-dependencies.png)
<small style={{ display: "block", textAlign: "center" }}>The version numbers used here are just examples.</small>

The recommended approach is to declare Liveblocks as a "peer dependency" in your
shared package's `package.json`. This tells the package manager: "I'm compatible
with Liveblocks ^3, but the host application decides which version to use."
Then, only declare Liveblocks in the `"dependencies"` of your actual
applications.

```json
{
  "peerDependencies": {
    "@liveblocks/client": "^3",
    "@liveblocks/react": "^3"
  }
}
```

Use a major version range like `"^3"` to allow flexibility while ensuring
compatibility.

![Using a peer dependency on Liveblocks from your shared library helps to avoid version conflicts](/assets/errors/use-peer-dependencies.png)
<small style={{ display: "block", textAlign: "center" }}>The version numbers used here are just examples.</small>

---
meta:
  title: "In order to use this channel, please set up your project first"
  parentTitle: "Error"
  description:
    "A notification channel hasnâ€™t been set up, you need to enable it in your
    dashboard."
---

## Why this error occurred

You tried to access a notification channel, such as `settings.email`, but itâ€™s
disabled in your Liveblocks dashboard.

## How to fix it

You first need to navigate to your project in the [dashboard](/dashboard).

<Figure>
  <Image
    src="/assets/tutorials/webhooks/liveblocks-click-notifications.png"
    alt="Notifications dashboard page"
    width={712}
    height={445}
  />
</Figure>

Then, enable a notification kind on the channel youâ€™re trying to access. For
example, if youâ€™re trying to access `settings.email`, navigate to the _Email_
tab and enable a notification kind.

<Banner type="warning">

If youâ€™re working with a production app, make sure you
[read our guide on enabling notification kinds](/docs/guides/what-to-check-before-enabling-a-new-notification-kind)
before publishing your changes, as your app may be affected.

</Banner>

<Figure>
  <Image
    src="/assets/tutorials/webhooks/liveblocks-toggle-custom-notification.png"
    alt="Toggle a custom notification kind"
    width={712}
    height={445}
  />
</Figure>

Once a notification kind is enabled on the channel youâ€™re accessing, the error
will disappear.

## Learn more

Learn more in our documentation.

- [What to check before enabling a new notification kind](/docs/guides/what-to-check-before-enabling-a-new-notification-kind).
- [How to create a notification settings panel](/docs/guides/how-to-create-a-notification-settings-panel).
- [`useNotificationSettings`](/docs/api-reference/liveblocks-react#useNotificationSettings)
- [`client.getNotificationSettings`](/docs/api-reference/liveblocks-client#Client.getNotificationSettings)
- [`Liveblocks.getNotificationSettings`](/docs/api-reference/liveblocks-node#get-users-userId-notification-settings)

---
meta:
  title: "The issued access token doesn't grant enough permissions."
  parentTitle: "Error"
  description:
    "@liveblocks/client error: the issued access token doesn't grant enough
    permissions"
---

## Why this error occurred

The client may request an access token to access resources beyond a specific
room, like Notifications. In such cases, your auth endpoint should issue an
access token that grants access to multiple rooms using wildcards (`*`).

### 1.10 warning

If you saw this warning in your auth endpoint, it's because the version 1.10
allows you to create an access token with no permission, even though it's not
recommended. When doing so, Notifications will work with an access token without
permissions, and Liveblocks will return all the user's notifications (mentions
for example) even if the user doesn't have access to the room. You should move
to use wildcards or use ID tokens, and note that this will not be allowed in
later versions.

## Possible ways to fix it

In your auth endpoint, when the request's property `room` is undefined, you
should create a token that grants access to multiple rooms. Example:

```
session.allow("orga1*", session.FULL_ACCESS);
```

Learn more about
[`permissions with access tokens`](https://liveblocks.io/docs/authentication/access-token).

---
meta:
  title: "You need to polyfill atob to use the client in your environment"
  parentTitle: "Error"
  description:
    "@liveblocks/client error: atob polyfill is required in your environment."
---

## Why this error occurred

You are using `@liveblocks/client` within a JavaScript runtime which doesn't
implement [`atob`](https://developer.mozilla.org/en-US/docs/Web/API/atob).
(environments like React Native or Node < 16)

## Possible ways to fix it

As a polyfill, we recommend installing the package
[`base-64`](https://www.npmjs.com/package/base-64).

```bash
npm install base-64
```

Then you can pass the `decode` function to our `atob` polyfill option when you
create the client.

```ts highlight="1,5-7" file="src/index.js"
import { decode } from "base-64";

const client = createClient({
  /* ... your other client's options */
  polyfills: {
    atob: decode,
  },
});
```

---
meta:
  title: "RoomProvider id property is required"
  parentTitle: "Error"
  description: "@liveblocks/react error: RoomProvider id property is required."
---

## Why this error occurred

[`RoomProvider`][] `id` property is required in order to provide a [`Room`][] in
the tree below.

## Possible ways to fix it

```jsx highlight="5"
import { RoomProvider } from "@liveblocks/react";

function Component() {
  return (
    <RoomProvider id="your-room-id">
      <YourComponent />
    </RoomProvider>
  );
}
```

Sometimes, you donâ€™t have access to your room `id` right away. For example, if
youâ€™re using Next.js and the `id` is coming from the query string, itâ€™s easy to
forget that `useRouter().query.roomId` returns `undefined` on the first render.
Do not render the [`RoomProvider`][] if you donâ€™t have access to the room `id`
right away.

## Useful links

- [`RoomProvider`][]
- [`Room`][]

[`roomprovider`]: /docs/api-reference/liveblocks-react#RoomProvider
[`room`]: /docs/api-reference/liveblocks-client#Room

---
meta:
  title: "Get started with Liveblocks and JavaScript"
  parentTitle: "Quickstart"
  description: "Learn how to get started with Liveblocks and JavaScript"
---

Liveblocks is a realtime collaboration infrastructure for building performant
collaborative experiences. Follow the following steps to start adding
collaboration to your JavaScript application using the APIs from the
[`@liveblocks/client`](/docs/api-reference/liveblocks-client) package.

## Quickstart

<Steps>
  <Step>
    <StepTitle>Install Liveblocks</StepTitle>
    <StepContent>

      Every package should use the same version.

      ```bash trackEvent="install_liveblocks"
      npm install @liveblocks/client
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Initialize the `liveblocks.config.ts` file</StepTitle>
    <StepContent>

      We can use this file later to [define types for our application](/docs/api-reference/liveblocks-client#Typing-your-data).

      ```bash
      npx create-liveblocks-app@latest --init --framework javascript
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Set up the Liveblocks client</StepTitle>
    <StepContent>

      The first step in connecting to Liveblocks is creating a client which
      will be responsible for communicating with the back end.

      ```ts file="room.js"
      const client = createClient({
        publicApiKey: "{{PUBLIC_KEY}}",
      });
      ```

    </StepContent>

  </Step>

  <Step>
    <StepTitle>Join a Liveblocks room</StepTitle>
    <StepContent>

      Liveblocks uses the concept of rooms, separate virtual spaces where people collaborate.
      To create a realtime experience, multiple users must be connected to the same room.

      ```js file="room.js"
      const { room, leave } = client.enterRoom("my-room");
      ```

    </StepContent>

  </Step>

  <Step>
    <StepTitle>Use the Liveblocks methods</StepTitle>
    <StepContent>

      Now that weâ€™re connected to a room, we can start using Liveblocks subscriptions.
      The first weâ€™ll add is `others`, a subscription that provides information
      about which other users are connected to the room.

      ```js file="index.js" highlight="5-7"
      import { room } from "./room.js"

      const div = document.querySelector("div");

      room.subscribe("others", (others) => {
        div.innerText = `There are ${others.length} other user(s) online`;
      });
      ```

    </StepContent>

  </Step>

  <Step lastStep>
    <StepTitle>Next: set up authentication</StepTitle>
    <StepContent>

      By default, Liveblocks is configured to work without an authentication endpoint
      where everyone automatically has access to rooms. This approach is great for
      prototyping and marketing pages where setting up your own security isnâ€™t always
      required. If you want to limit access to a room for certain users, youâ€™ll need
      to set up an authentication endpoint to enable permissions.

      <Button asChild className="not-markdown">
        <a href="/docs/authentication">
          Set up authentication
        </a>
      </Button>
    </StepContent>

  </Step>
</Steps>

## What to read next

Congratulations! You now have set up the foundation to start building
collaborative experiences for your JavaScript application.

- [@liveblocks/client API Reference](/docs/api-reference/liveblocks-client)
- [JavaScript guides](/docs/guides?technologies=javascript)
- [Authentication](/docs/authentication)

---

## Examples using JavaScript

<ListGrid columns={2}>
  <ExampleCard
    example={{
      title: "Collaborative To-do List",
      slug: "collaborative-todo-list/javascript-todo-list",
      image: "/images/examples/thumbnails/collaborative-todo-list.jpg",
    }}
    technologies={["nextjs", "vuejs", "sveltekit", "solidjs", "javascript"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Live Cursors",
      slug: "live-cursors/javascript-live-cursors",
      image: "/images/examples/thumbnails/live-avatar-stack.jpg",
    }}
    technologies={["nextjs", "vuejs", "sveltekit", "solidjs", "javascript"]}
    openInNewWindow
  />
</ListGrid>

---
meta:
  title: "Get started with an AI chat using Liveblocks and Next.js"
  parentTitle: "Quickstart"
  description:
    "Learn how to get started with an AI chat using Liveblocks and Next.js"
---

Liveblocks is a realtime collaboration infrastructure for building performant
collaborative experiences. Follow the following steps to start adding an
advanced AI chat to your Next.js `/app` directory application using the hooks
from [`@liveblocks/react`](/docs/api-reference/liveblocks-react) and the
components from
[`@liveblocks/react-ui`](/docs/api-reference/liveblocks-react-ui).

## Quickstart

<Steps>
  <Step>
    <StepTitle>Install Liveblocks</StepTitle>
    <StepContent>

      Every package should use the same version.

      ```bash trackEvent="install_liveblocks"
      npm install @liveblocks/client @liveblocks/react @liveblocks/react-ui @liveblocks/node
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Add your projectâ€™s secret key</StepTitle>
    <StepContent>

      Create a new `.env.local` file and add your Liveblocks secret key from the [dashboard](/dashboard/apikeys).

      ```env file=".env.local"
      LIVEBLOCKS_SECRET_KEY="{{SECRET_KEY}}"
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Set up authentication</StepTitle>
    <StepContent>

      Create an [authentication](/docs/authentication) API route with [`prepareSession`](/docs/api-reference/liveblocks-node#prepareSession),
      passing a unique user ID.
      Each user has their own set of private chats, and this allows Liveblocks to identify who is connecting.

      ```tsx file="app/api/liveblocks-auth/route.ts"
      import { Liveblocks } from "@liveblocks/node";
      import { NextRequest } from "next/server";

      const liveblocks = new Liveblocks({
        secret: process.env.LIVEBLOCKS_SECRET_KEY!,
      });

      export async function POST(req: NextRequest) {
        // Get the current user from your database
        const user = {
          // +++
          id: "user-1",
          // +++
          info: {
            // Optional. `name`, `avatar`, `color`, custom info.
          },
        };

        // Create a session for the current user
        // +++
        const session = liveblocks.prepareSession(user.id, {
          userInfo: user.info,
        });
        // +++

        // Give the user access to AI chats
        session.allow(`*`, session.FULL_ACCESS);

        // Authorize the user and return the result
        const { status, body } = await session.authorize();
        return new Response(body, { status });
      }
      ```
    </StepContent>

  </Step>

  <Step>
    <StepTitle>Add your secret key</StepTitle>
    <StepContent>
      Create a project in the [dashboard](/dashboard) and add your secret key to `.env.local`:

    ```js file=".env.local"
    LIVEBLOCKS_SECRET_KEY="{{SECRET_KEY}}"
    ```
    </StepContent>

  </Step>

  <Step>
    <StepTitle>Create a Liveblocks provider</StepTitle>
    <StepContent>

      To connect the user to their chats, you must
      add [`LiveblocksProvider`](/docs/api-reference/liveblocks-react#LiveblocksProvider)
      to a client component in your app.

      ```tsx file="app/Providers.tsx" highlight="8-10"
      "use client";

      import { ReactNode } from "react";
      import { LiveblocksProvider } from "@liveblocks/react";

      export function Providers({ children }: { children: ReactNode }) {
        return (
          <LiveblocksProvider authEndpoint="/api/liveblocks-auth">
            {children}
          </LiveblocksProvider>
        );
      }
    ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Add the provider to your layout</StepTitle>
    <StepContent>

      After creating your provider file, itâ€™s time to use it. Import
      your room into your `layout.tsx` file.

      ```tsx file="app/layout.tsx"
      import { Providers } from "./Providers";

      export default function Layout({ children }) {
        return (
          <html>
            <body>
              // +++
              <Providers>
                {children}
              </Providers>
              // +++
            </body>
          </html>
        );
      }
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Add the AI chat component</StepTitle>
    <StepContent>

      Now you can add the [`AiChat`](/docs/api-reference/liveblocks-react-ui#AiChat)
      component to your application. This component renders a fully-featured AI
      chat interface with message history and a composer. You can add
      [tools](/docs/ready-made-features/ai-copilots/tools), [knowledge](/docs/ready-made-features/ai-copilots/knowledge),
      and use [hooks](/docs/ready-made-features/ai-copilots/hooks).

      ```tsx file="app/page.tsx"
      "use client";

      import { AiChat } from "@liveblocks/react-ui";
      import { RegisterAiTool, RegisterAiKnowledge } from "@liveblocks/react";

      export default function Page() {
        return (
          <div style={{ height: 500, width: 500 }}>
            // +++
            <AiChat
              chatId="my-first-chat"
              // copilotId="co_aH1j2..."
            />
            // +++
            {/* <RegisterAiTool ... /> and <RegisterAiKnowledge ... /> */}
          </div>
        );
      }
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Import default styles</StepTitle>
    <StepContent>

    The default components come with default styles, you can import them into the
    root layout of your app or directly into a CSS file with `@import`.

    ```tsx file="app/layout.tsx"
    import "@liveblocks/react-ui/styles.css";
    ```

    </StepContent>

  </Step>
  <Step lastStep>
    <StepTitle>Next: create a copilot</StepTitle>
    <StepContent>

      AI Copilots is set up and working, but itâ€™s using our default AI model
      and promptâ€”the next step is to create a custom copilot
      using your preferred AI provider and configuration.

      <Button asChild  className="not-markdown">
        <a href="/docs/ready-made-features/ai-copilots/copilots">
          Create a copilot
        </a>
      </Button>

    </StepContent>

  </Step>
</Steps>

## What to read next

Congratulations! Youâ€™ve set up the foundation to start building an AI copilot
experience for your Next.js application.

- [Overview of all features and where to start](/docs/ready-made-features/ai-copilots)
- [@liveblocks/react API reference](/docs/api-reference/liveblocks-react#AI-Copilots)
- [@liveblocks/react-ui API reference](/docs/api-reference/liveblocks-react-ui#AI-Copilots)
- [How to use a fallback AI model](/docs/guides/how-to-use-fallback-ai-models-in-ai-copilots)

---

## Examples using Next.js

<ListGrid columns={2}>
  <ExampleCard
    example={{
      title: "AI Chats",
      slug: "ai-chats/nextjs-ai-chats",
      image: "/images/examples/thumbnails/ai-chats.jpg",
    }}
    technologies={["nextjs", "react"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "AI Reports Dashboard",
      slug: "ai-dashboard-reports/nextjs-ai-dashboard-reports",
      image: "/images/examples/thumbnails/ai-reports-dashboard.jpg",
    }}
    technologies={["nextjs", "react"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "AI Support Chat",
      slug: "ai-support-chat/nextjs-ai-support-chat",
      image: "/images/examples/thumbnails/ai-support.jpg",
    }}
    technologies={["nextjs", "react"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "AI App Builder",
      slug: "ai-app-builder/nextjs-ai-app-builder",
      image: "/images/examples/thumbnails/ai-app-builder.png",
    }}
    technologies={["nextjs"]}
    openInNewWindow
  />
</ListGrid>

---
meta:
  title: "Get started with a BlockNote text editor using Liveblocks and Next.js"
  parentTitle: "Quickstart"
  description:
    "Learn how to get started with a BlockNote text editor using Liveblocks and
    Next.js."
---

Liveblocks is a realtime collaboration infrastructure for building performant
collaborative experiences. Follow the following steps to start adding
collaboration to your Next.js application using the APIs from the
[`@liveblocks/react-blocknote`](/docs/api-reference/liveblocks-react-blocknote)
package.

## Quickstart

<Steps>
  <Step>
    <StepTitle>Install Liveblocks and BlockNote</StepTitle>
    <StepContent>

      Every Liveblocks package should use the same version.

      ```bash trackEvent="install_liveblocks"
      npm install @liveblocks/client @liveblocks/react @liveblocks/react-ui @liveblocks/react-blocknote @blocknote/core @blocknote/react @blocknote/mantine
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Initialize the `liveblocks.config.ts` file</StepTitle>
    <StepContent>

      We can use this file later to [define types for our application](/docs/api-reference/liveblocks-react#Typing-your-data).

      ```bash
      npx create-liveblocks-app@latest --init --framework react
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Create a Liveblocks room</StepTitle>
    <StepContent>

      Liveblocks uses the concept of rooms, separate virtual spaces where people
      collaborate, and to create a realtime experience, multiple users must
      be connected to the same room. When using Next.jsâ€™ `/app` router,
      we recommend creating your room in a `Room.tsx` file in the same directory
      as your current route.

      Set up a Liveblocks client with
      [`LiveblocksProvider`](/docs/api-reference/liveblocks-react#LiveblocksProvider),
      join a room with [`RoomProvider`](/docs/api-reference/liveblocks-react#RoomProvider),
      and use [`ClientSideSuspense`](/docs/api-reference/liveblocks-react#ClientSideSuspense)
      to add a loading spinner to your app.

      ```tsx file="app/Room.tsx" highlight="12-18"
      "use client";

      import { ReactNode } from "react";
      import {
        LiveblocksProvider,
        RoomProvider,
        ClientSideSuspense,
      } from "@liveblocks/react/suspense";

      export function Room({ children }: { children: ReactNode }) {
        return (
          <LiveblocksProvider publicApiKey={"{{PUBLIC_KEY}}"}>
            <RoomProvider id="my-room">
              <ClientSideSuspense fallback={<div>Loadingâ€¦</div>}>
                {children}
              </ClientSideSuspense>
            </RoomProvider>
          </LiveblocksProvider>
        );
      }
      ```

  </StepContent>

</Step>
<Step>
  <StepTitle>Add the Liveblocks room to your page</StepTitle>
  <StepContent>

    After creating your room file, itâ€™s time to join it. Import
    your room into your `page.tsx` file, and place
    your collaborative app components inside it.

    ```tsx file="app/page.tsx" highlight="6-8"
    import { Room } from "./Room";
    import { Editor } from "./Editor";

    export default function Page() {
      return (
        <Room>
          <Editor/>
        </Room>
      );
    }
    ```

  </StepContent>

</Step>
<Step>
  <StepTitle>Set up the collaborative BlockNote text editor</StepTitle>
  <StepContent>

    Now that we set up Liveblocks, we can start integrating BlockNote and Liveblocks in the `Editor.tsx` file.
    To make the editor collaborative, we can add
    [`useCreateBlockNoteWithLiveblocks`](/docs/api-reference/liveblocks-react-blocknote#useCreateBlockNoteWithLiveblocks)
    from `@liveblocks/react-blocknote`.

    ```tsx file="app/Editor.tsx"
    "use client";

    import { useCreateBlockNoteWithLiveblocks } from "@liveblocks/react-blocknote";
    import { BlockNoteView } from "@blocknote/mantine";
    import { Threads } from "./Threads";

    export function Editor() {
      const editor = useCreateBlockNoteWithLiveblocks({});

      return (
        <div>
          <BlockNoteView editor={editor} className="editor" />
          <Threads editor={editor} />
        </div>
      );
    }
    ```

</StepContent>

</Step>
<Step>
  <StepTitle>Render threads and composer</StepTitle>
  <StepContent>

    To add [Comments](/docs/ready-made-features/comments) to your text editor, we need to import a thread composer
    and list each thread on the page. Create a `Threads.tsx` file that uses [`FloatingComposer`](/docs/api-reference/liveblocks-react-blocknote#FloatingComposer)
    for creating new threads, alongside [`AnchoredThreads`](/docs/api-reference/liveblocks-react-blocknote#AnchoredThreads) and [`FloatingThreads`](/docs/api-reference/liveblocks-react-blocknote#FloatingThreads) for displaying threads on desktop and mobile.

    ```tsx file="app/Threads.tsx"
    import { useThreads } from "@liveblocks/react/suspense";
    import {
      AnchoredThreads,
      FloatingComposer,
      FloatingThreads,
    } from "@liveblocks/react-blocknote";
    import { BlockNoteEditor } from "@blocknote/core";

    export function Threads({ editor }: { editor: BlockNoteEditor | null }) {
      const { threads } = useThreads({ query: { resolved: false } });

      if (!editor) {
        return null;
      }

      return (
        <>
          <div className="anchored-threads">
            <AnchoredThreads editor={editor} threads={threads} />
          </div>
          <FloatingThreads
            editor={editor}
            threads={threads}
            className="floating-threads"
          />
          <FloatingComposer editor={editor} className="floating-composer" />
        </>
      );
    }
    ```

</StepContent>

</Step>
<Step>
  <StepTitle>Style your editor</StepTitle>
  <StepContent>

    We can create some custom styles to position the editor and threadsâ€”import `globals.css`, alongside the default BlockNote and Liveblocks styles. You can import them into the
    root layout of your app or directly into a CSS file with `@import`.

    ```css file="app/globals.css" isCollapsed isCollapsable
    html {
      font-family: Inter, sans-serif;
      background: #f9f9f9;
    }

    @media (prefers-color-scheme: dark) {
      html {
        background: #0c0c0c;
      }
    }

    .editor {
      position: absolute;
      inset: 0;
      max-width: 1024px;
      margin: 0 auto;
      padding: 48px 0;
    }

    .bn-editor {
      padding: 36px 52px;
      min-height: 100%;
    }

    /* For mobile */
    .floating-threads {
      display: none;
    }

    /* For desktop */
    .anchored-threads {
      display: block;
      max-width: 300px;
      width: 100%;
      position: absolute;
      right: 12px;
    }

    @media (max-width: 640px) {
      .floating-threads {
        display: block;
      }

      .anchored-threads {
        display: none;
      }
    }
    ```

    ```tsx file="app/layout.tsx"
    import "@blocknote/core/fonts/inter.css";
    import "@blocknote/mantine/style.css";
    import "@liveblocks/react-ui/styles.css";
    import "@liveblocks/react-ui/styles/dark/media-query.css";
    import "@liveblocks/react-tiptap/styles.css";
    import "./globals.css";
    ```

  </StepContent>

</Step>
<Step>
  <StepTitle>Next: authenticate and add your users</StepTitle>
  <StepContent>
    Text Editor is set up and working now, but each user is anonymousâ€”the next step is to
    authenticate each user as they connect, and attach their name, color, and avatar, to their cursors and mentions.

    <Button asChild  className="not-markdown">
      <a href="/docs/guides/how-to-add-users-to-liveblocks-text-editor">
        Add your users to Text Editor
      </a>
    </Button>

  </StepContent>

</Step>
<Step lastStep>
  <StepTitle>Optional: add more features</StepTitle>
  <StepContent>
    BlockNote is easy to extend, and a number of extensions are already available, making it possible to quickly create complex rich-text applications. For example you can enable features
    such as tables, text highlights, embedded images, and more. This is all supported using Liveblocks.

    <Button asChild  className="not-markdown">
      <a href="https://tiptap.dev/docs/editor/extensions/overview">
        Find more extensions
      </a>
    </Button>

  </StepContent>

</Step>
</Steps>

## What to read next

Congratulations! You now have set up the foundation for your collaborative
BlockNote text editor inside your React application.

- [@liveblocks/react-blocknote API Reference](/docs/api-reference/liveblocks-react-blocknote)
- [BlockNote guides](/docs/guides?technologies=blocknote)
- [BlockNote website](https://www.blocknotejs.org/)

---

## Examples using BlockNote

<ListGrid columns={2}>
  <ExampleCard
    example={{
      title: "Collaborative Text Editor",
      slug: "collaborative-text-editor/nextjs-blocknote",
      image: "/images/examples/thumbnails/text-editor.jpg",
    }}
    technologies={["nextjs"]}
    openInNewWindow
  />
</ListGrid>

---
meta:
  title: "Get started with commenting using Liveblocks and Next.js"
  parentTitle: "Quickstart"
  description:
    "Learn how to get started with commenting using Liveblocks and Next.js"
---

Liveblocks is a realtime collaboration infrastructure for building performant
collaborative experiences. Follow the following steps to start adding a
commenting experience to your Next.js `/app` directory application using the
hooks from [`@liveblocks/react`](/docs/api-reference/liveblocks-react) and the
components from
[`@liveblocks/react-ui`](/docs/api-reference/liveblocks-react-ui).

## Quickstart

<Steps>
  <Step>
    <StepTitle>Install Liveblocks</StepTitle>
    <StepContent>

      Every package should use the same version.

      ```bash trackEvent="install_liveblocks"
      npm install @liveblocks/client @liveblocks/react @liveblocks/react-ui
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Initialize the `liveblocks.config.ts` file</StepTitle>
    <StepContent>

      We can use this file later to [define types for our application](/docs/api-reference/liveblocks-react#Typing-your-data).

      ```bash
      npx create-liveblocks-app@latest --init --framework react
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Create a Liveblocks room</StepTitle>
    <StepContent>

      Liveblocks uses the concept of rooms, separate virtual spaces where people
      collaborate, and to create a realtime experience, multiple users must
      be connected to the same room. When using Next.jsâ€™ `/app` router,
      we recommend creating your room in a `Room.tsx` file in the same directory
      as your current route.

      Set up a Liveblocks client with
      [`LiveblocksProvider`](/docs/api-reference/liveblocks-react#LiveblocksProvider),
      join a room with [`RoomProvider`](/docs/api-reference/liveblocks-react#RoomProvider),
      and use [`ClientSideSuspense`](/docs/api-reference/liveblocks-react#ClientSideSuspense)
      to add a loading spinner to your app.

      ```tsx file="app/Room.tsx" highlight="12-18"
      "use client";

      import { ReactNode } from "react";
      import {
        LiveblocksProvider,
        RoomProvider,
        ClientSideSuspense,
      } from "@liveblocks/react/suspense";

      export function Room({ children }: { children: ReactNode }) {
        return (
          <LiveblocksProvider publicApiKey={"{{PUBLIC_KEY}}"}>
            <RoomProvider id="my-room">
              <ClientSideSuspense fallback={<div>Loadingâ€¦</div>}>
                {children}
              </ClientSideSuspense>
            </RoomProvider>
          </LiveblocksProvider>
        );
      }
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Add the Liveblocks room to your page</StepTitle>
    <StepContent>

      After creating your room file, itâ€™s time to join it. Import
      your room into your `page.tsx` file, and place
      your collaborative app components inside it.

      ```tsx file="app/page.tsx" highlight="6-8"
      import { Room } from "./Room";
      import { CollaborativeApp } from "./CollaborativeApp";

      export default function Page() {
        return (
          <Room>
            <CollaborativeApp />
          </Room>
        );
      }
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Use the Liveblocks hooks and components</StepTitle>
    <StepContent>

      Now that weâ€™re connected to a room, we can start using the Liveblocks hooks and components.
      Weâ€™ll add [`useThreads`](/docs/api-reference/liveblocks-react#useThreads) to get the threads in the room, then weâ€™ll use the [`Thread`](/docs/api-reference/liveblocks-react-ui#Thread) component
      to render them. Finally, weâ€™ll add a way to create threads by adding a [`Composer`](/docs/api-reference/liveblocks-react-ui#Composer).

      ```tsx file="app/CollaborativeApp.tsx" highlight="7,11-14"
      "use client";

      import { useThreads } from "@liveblocks/react/suspense";
      import { Composer, Thread } from "@liveblocks/react-ui";

      export function CollaborativeApp() {
        const { threads } = useThreads();

        return (
          <div>
            {threads.map((thread) => (
              <Thread key={thread.id} thread={thread} />
            ))}
            <Composer />
          </div>
        );
      }
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Import default styles</StepTitle>
    <StepContent>

    The default components come with default styles, you can import them into the
    root layout of your app or directly into a CSS file with `@import`.

    ```tsx file="app/layout.tsx"
    import "@liveblocks/react-ui/styles.css";
    ```

    </StepContent>

  </Step>
  <Step lastStep>
    <StepTitle>Next: authenticate and add your users</StepTitle>
    <StepContent>

      Comments is set up and working now, but each user is anonymousâ€”the next step is to
      authenticate each user as they connect, and attach their name and avatar to their comments.

      <Button asChild  className="not-markdown">
        <a href="/docs/guides/how-to-add-users-to-liveblocks-comments">
          Add your users to Comments
        </a>
      </Button>
    </StepContent>

  </Step>
</Steps>

## What to read next

Congratulations! Youâ€™ve set up the foundation to start building a commenting
experience for your Next.js application.

- [API Reference](/docs/api-reference/liveblocks-react-ui)
- [How to send email notifications when comments are created](/docs/guides/how-to-send-email-notifications-when-comments-are-created)

---

## Examples using Next.js

<ListGrid columns={2}>
  <ExampleCard
    example={{
      title: "Comments",
      slug: "comments/nextjs-comments",
      image: "/images/examples/thumbnails/comments.jpg",
    }}
    technologies={["nextjs", "react"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Video Comments",
      slug: "video-comments/nextjs-comments-video",
      image: "/images/examples/thumbnails/comments-video.png",
    }}
    technologies={["nextjs"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Overlay Comments",
      slug: "overlay-comments/nextjs-comments-overlay",
      image: "/images/examples/thumbnails/comments-overlay.png",
    }}
    technologies={["nextjs"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Text Editor Comments",
      slug: "text-editor-comments/nextjs-comments-tiptap",
      image: "/images/examples/thumbnails/comments-text-editor.png",
    }}
    technologies={["nextjs"]}
    openInNewWindow
  />
</ListGrid>

---
meta:
  title: "Get started with a Lexical text editor using Liveblocks and Next.js"
  parentTitle: "Quickstart"
  description:
    "Learn how to get started with a Lexical text editor using Liveblocks and
    Next.js"
---

Liveblocks is a realtime collaboration infrastructure for building performant
collaborative experiences. Follow the following steps to start adding
collaboration to your Next.js application using the APIs from the
[`@liveblocks/react-lexical`](/docs/api-reference/liveblocks-react-lexical)
package.

## Quickstart

<Steps>
  <Step>
    <StepTitle>Install Liveblocks and Lexical</StepTitle>
    <StepContent>

      Every Liveblocks package should use the same version.

      ```bash trackEvent="install_liveblocks"
      npm install @liveblocks/client @liveblocks/react @liveblocks/react-ui @liveblocks/react-lexical lexical @lexical/react
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Initialize the `liveblocks.config.ts` file</StepTitle>
    <StepContent>

      We can use this file later to [define types for our application](/docs/api-reference/liveblocks-react#Typing-your-data).

      ```bash
      npx create-liveblocks-app@latest --init --framework react
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Create a Liveblocks room</StepTitle>
    <StepContent>

      Liveblocks uses the concept of rooms, separate virtual spaces where people
      collaborate, and to create a realtime experience, multiple users must
      be connected to the same room. When using Next.jsâ€™ `/app` router,
      we recommend creating your room in a `Room.tsx` file in the same directory
      as your current route.

      Set up a Liveblocks client with
      [`LiveblocksProvider`](/docs/api-reference/liveblocks-react#LiveblocksProvider),
      join a room with [`RoomProvider`](/docs/api-reference/liveblocks-react#RoomProvider),
      and use [`ClientSideSuspense`](/docs/api-reference/liveblocks-react#ClientSideSuspense)
      to add a loading spinner to your app.

      ```tsx file="app/Room.tsx" highlight="12-18"
      "use client";

      import { ReactNode } from "react";
      import {
        LiveblocksProvider,
        RoomProvider,
        ClientSideSuspense,
      } from "@liveblocks/react/suspense";

      export function Room({ children }: { children: ReactNode }) {
        return (
          <LiveblocksProvider publicApiKey={"{{PUBLIC_KEY}}"}>
            <RoomProvider id="my-room">
              <ClientSideSuspense fallback={<div>Loadingâ€¦</div>}>
                {children}
              </ClientSideSuspense>
            </RoomProvider>
          </LiveblocksProvider>
        );
      }
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Add the Liveblocks room to your page</StepTitle>
    <StepContent>

      After creating your room file, itâ€™s time to join it. Import
      your room into your `page.tsx` file, and place
      your collaborative app components inside it.

      ```tsx file="app/page.tsx" highlight="6-8"
      import { Room } from "./Room";
      import { Editor } from "./Editor";

      export default function Page() {
        return (
          <Room>
            <Editor/>
          </Room>
        );
      }
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Set up the collaborative Lexical text editor</StepTitle>
    <StepContent>

      Now that we set up Liveblocks, we can start integrating Lexical and Liveblocks in the `Editor.tsx` file.
      To make the editor collaborative, we can use
      [`LiveblocksPlugin`](/docs/api-reference/liveblocks-react-lexical#LiveblocksPlugin)
      from `@liveblocks/react-lexical`. [`FloatingToolbar`](/docs/api-reference/liveblocks-react-lexical#FloatingToolbar)
      adds a text selection toolbar.

      ```tsx file="app/Editor.tsx"
      "use client";

      import { LexicalComposer } from "@lexical/react/LexicalComposer";
      import { RichTextPlugin } from "@lexical/react/LexicalRichTextPlugin";
      import { ContentEditable } from "@lexical/react/LexicalContentEditable";
      import { LexicalErrorBoundary } from "@lexical/react/LexicalErrorBoundary";
      import {
        liveblocksConfig,
        LiveblocksPlugin,
        FloatingToolbar,
      } from "@liveblocks/react-lexical";
      import { Threads } from "./Threads";

      export function Editor() {
        // Wrap your Lexical config with `liveblocksConfig`
        const initialConfig = liveblocksConfig({
          namespace: "Demo",
          onError: (error: unknown) => {
            console.error(error);
            throw error;
          },
        });

        return (
          <LexicalComposer initialConfig={initialConfig}>
            <div className="editor">
              <RichTextPlugin
                contentEditable={<ContentEditable />}
                placeholder={<div className="placeholder">Start typing hereâ€¦</div>}
                ErrorBoundary={LexicalErrorBoundary}
              />
              <LiveblocksPlugin>
                <Threads />
                <FloatingToolbar />
              </LiveblocksPlugin>
            </div>
          </LexicalComposer>
        );
      }
      ```
    </StepContent>

  </Step>
  <Step>
    <StepTitle>Render threads and composer</StepTitle>
    <StepContent>

      To add [Comments](/docs/ready-made-features/comments) to your text editor, we need to import a thread composer
      and list each thread on the page. Create a `Threads.tsx` file that uses [`FloatingComposer`](/docs/api-reference/liveblocks-react-lexical#FloatingComposer)
      for creating new threads, alongside [`AnchoredThreads`](/docs/api-reference/liveblocks-react-lexical#AnchoredThreads) and [`FloatingThreads`](/docs/api-reference/liveblocks-react-lexical#FloatingThreads) for displaying threads on desktop and mobile.

      ```tsx file="app/Threads.tsx"
      "use client";

      import { useThreads } from "@liveblocks/react/suspense";
      import {
        AnchoredThreads,
        FloatingComposer,
        FloatingThreads,
      } from "@liveblocks/react-lexical";

      export function Threads() {
        const { threads } = useThreads();

        return (
          <>
            <div className="anchored-threads">
              <AnchoredThreads threads={threads} />
            </div>
            <FloatingThreads className="floating-threads" threads={threads} />
            <FloatingComposer className="floating-composer" />
          </>
        );
      }
      ```
    </StepContent>

  </Step>
  <Step>
    <StepTitle>Style your editor</StepTitle>
    <StepContent>

      Lexical text editor is unstyled by default, so we can create some custom styles for it in a `globals.css` file. Import `globals.css`, alongside the default Liveblocks styles. You can import them into the
      root layout of your app or directly into a CSS file with `@import`.

      ```css file="app/globals.css" isCollapsed isCollapsable
      .editor {
        position: relative;
        display: flex;
        width: 100%;
        height: 100%;
      }

      [data-lexical-editor] {
        padding: 2px 12px;
        outline: none;
      }

      [data-lexical-editor] p {
        margin: 0.8em 0;
      }

      /* For mobile */
      .floating-threads {
        display: none;
      }

      /* For desktop */
      .anchored-threads {
        display: block;
        max-width: 300px;
        width: 100%;
        position: absolute;
        right: 4px;
      }

      @media (max-width: 640px) {
        .floating-threads {
          display: block;
        }

        .anchored-threads {
          display: none;
        }
      }

      .placeholder {
        position: absolute;
        left: 12px;
        top: 16px;
        pointer-events: none;
        opacity: 0.5;
      }
      ```

      ```tsx file="app/layout.tsx"
      import "@liveblocks/react-ui/styles.css";
      import "@liveblocks/react-lexical/styles.css";
      import "./globals.css";
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Next: authenticate and add your users</StepTitle>
    <StepContent>
      Text Editor is set up and working now, but each user is anonymousâ€”the next step is to
      authenticate each user as they connect, and attach their name, color, and avatar, to their cursors and mentions.

      <Button asChild  className="not-markdown">
        <a href="/docs/guides/how-to-add-users-to-liveblocks-text-editor">
          Add your users to Text Editor
        </a>
      </Button>
    </StepContent>

  </Step>
  <Step lastStep>
    <StepTitle>Optional: add more features</StepTitle>
    <StepContent>
      Lexical is a highly extensible text editor and it's possible to create complex rich-text applications.
      A great example is in the [Lexical playground](https://playground.lexical.dev/) which enables features
      such as tables, text highlights, embedded images, and more. This is all supported using Liveblocks.

      <Button asChild  className="not-markdown">
        <a href="https://lexical.dev/docs/intro">
          Learn more about Lexical
        </a>
      </Button>
    </StepContent>

  </Step>
</Steps>

## What to read next

Congratulations! You now have set up the foundation for your collaborative
Lexical text editor inside your Next.js application.

- [Overview](/docs/ready-made-features/text-editor/lexical)
- [`@liveblocks/react-lexical` API Reference](/docs/api-reference/liveblocks-react-lexical)
- [`@liveblocks/node-lexical` API Reference](/docs/api-reference/liveblocks-node-lexical)
- [Lexical website](https://lexical.dev/)

---

## Examples using Lexical

<ListGrid columns={2}>
  <ExampleCard
    example={{
      title: "Collaborative Text Editor",
      slug: "collaborative-text-editor/nextjs-lexical",
      image: "/images/examples/thumbnails/text-editor.jpg",
    }}
    technologies={["nextjs"]}
    openInNewWindow
  />
</ListGrid>

---
meta:
  title:
    "Get started with emailing custom notifications using Liveblocks and Next.js"
  parentTitle: "Quickstart"
  description:
    "Learn how to email custom notifications using using Liveblocks Liveblocks
    and Next.js"
---

Liveblocks is a realtime collaboration infrastructure for building performant
collaborative experiences. Follow this guide to send
[custom notifications](/docs/ready-made-features/notifications/concepts#Custom-notifications)
to email using methods from
[`@liveblocks/node`](/docs/api-reference/liveblocks-node).

## Quickstart

<Steps>
  <Step>
    <StepTitle>Install Liveblocks Node</StepTitle>
    <StepContent>

      Every Liveblocks package should use the same version.

      ```bash trackEvent="install_liveblocks"
      npm install @liveblocks/node
      ```

    </StepContent>

  </Step>

   <Step>
    <StepTitle>Trigger a custom notification</StepTitle>
    <StepContent>

      Trigger a custom notification using
      [`triggerInboxNotification`](/docs/api-reference/liveblocks-node#post-inbox-notifications-trigger)
      from a server action or route handler. In this example, a custom `$fileUploaded` notification is sent.

      ```ts
      "use server";

      import { Liveblocks } from "@liveblocks/node";

      const liveblocks = new Liveblocks({
        secret: "{{SECRET_KEY}}",
      });

      // Call this in your app to create a custom notification
      export async function triggerCustomNotification() {
        // +++
        await liveblocks.triggerInboxNotification({
          // The user that will receive the notification
          userId: "steven@example.com",
          kind: "$fileUploaded",
          subjectId: "my-file",

          // Custom data for this notification
          activityData: {
            file: "https://example.com/my-file.zip",
            status: "pending",
          },
        });
        // +++
      }
      ```
    </StepContent>

  </Step>

  <Step lastStep>
    <StepTitle>Follow our guide</StepTitle>
    <StepContent>

      Follow our step-by-step guide to learn set up email notifications.

      <Button asChild className="not-markdown">
        <a href="/docs/guides/how-to-notify-users-about-unread-custom-notifications-outside-of-your-app">
          How to notify users with email
        </a>
      </Button>

    </StepContent>

  </Step>
</Steps>

## What to read next

Congratulations! You've set up Email notifications in your Next.js application.

- [Webhooks API reference](/docs/platform/webhooks)
- [Node.js API reference](/docs/api-reference/liveblocks-node)
- [How to test webhooks on localhost](/docs/guides/how-to-test-webhooks-on-localhost)

---

## Examples using Notifications

<ListGrid columns={2}>
  <ExampleCard
    example={{
      title: "Custom notifications",
      slug: "notifications-custom/nextjs-notifications-custom",
      image: "/images/examples/thumbnails/custom-notifications.png",
    }}
    technologies={["nextjs", "react"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Notification settings",
      slug: "notification-settings/nextjs-notification-settings",
      image: "/images/examples/thumbnails/notification-settings.png",
    }}
    technologies={["nextjs", "react"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Notion-like AI Editor",
      slug: "notion-like-ai-editor/nextjs-notion-like-ai-editor",
      image: "/images/examples/thumbnails/notion-like-ai-editor.png",
    }}
    technologies={["nextjs", "react"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Comments notifications",
      slug: "https://liveblocks.io/examples/comments-emails",
      image: "/images/examples/thumbnails/comments-notifications.png",
    }}
    technologies={["nextjs", "react"]}
    openInNewWindow
  />
</ListGrid>

---
meta:
  title:
    "Get started with an in-app custom notification inbox using Liveblocks and
    Next.js"
  parentTitle: "Quickstart"
  description:
    "Learn how to add an in-app custom notification inbox using using Liveblocks
    Liveblocks and Next.js"
---

Liveblocks is a realtime collaboration infrastructure for building performant
collaborative experiences. Follow this guide to start adding custom
notifications to your Next.js `/app` directory application using the hooks from
[`@liveblocks/react`](/docs/api-reference/liveblocks-react) and the components
from [`@liveblocks/react-ui`](/docs/api-reference/liveblocks-react-ui).

## Quickstart

<Steps>
  <Step>
    <StepTitle>Install Liveblocks</StepTitle>
    <StepContent>

      Every package should use the same version.

      ```bash trackEvent="install_liveblocks"
      npm install @liveblocks/client @liveblocks/react @liveblocks/react-ui @liveblocks/node
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Initialize the `liveblocks.config.ts` file</StepTitle>
    <StepContent>

      We can use this file later to [define types for our application](/docs/api-reference/liveblocks-react#Typing-your-data).

      ```bash
      npx create-liveblocks-app@latest --init --framework react
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Create a Liveblocks provider</StepTitle>
    <StepContent>

      Liveblocks Notifications uses the concept of projects, which relate to
      projects in [your dashboard](/dashboard). Notifications are sent between
      users in the same project. To connect and receive notifications, you must
      add [`LiveblocksProvider`](/docs/api-reference/liveblocks-react#LiveblocksProvider)
      to a client component in your app.

      ```tsx file="app/Providers.tsx" highlight="8-10"
      "use client";

      import { ReactNode } from "react";
      import { LiveblocksProvider } from "@liveblocks/react";

      export function Providers({ children }: { children: ReactNode }) {
        return (
          <LiveblocksProvider publicApiKey={"{{PUBLIC_KEY}}"}>
            {children}
          </LiveblocksProvider>
        );
      }
    ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Add the provider to your layout</StepTitle>
    <StepContent>

      After creating your provider file, itâ€™s time to use it. Import
      your room into your `layout.tsx` file.

      ```tsx file="app/layout.tsx"
      import { Providers } from "./Providers";

      export default function Layout({ children }) {
        return (
          <html>
            <body>
              // +++
              <Providers>
                {children}
              </Providers>
              // +++
            </body>
          </html>
        );
      }
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Use the Liveblocks hooks and components</StepTitle>
    <StepContent>

      Now that weâ€™ve set up the provider, we can start using the Liveblocks hooks and components.
      Weâ€™ll add [`useInboxNotifications`](/docs/api-reference/liveblocks-react#useInboxNotifications)
      to get the current projectâ€™s notifications, then weâ€™ll
      use [`InboxNotification`](/docs/api-reference/liveblocks-react-ui#InboxNotification) and [`InboxNotificationList`](/docs/api-reference/liveblocks-react-ui#InboxNotificationList) to render them.

      ```tsx file="app/page.tsx" highlight="10,13-20"
      "use client";

      import { useInboxNotifications } from "@liveblocks/react/suspense";
      import {
        InboxNotification,
        InboxNotificationList,
      } from "@liveblocks/react-ui";

      export default function Page() {
        const { inboxNotifications } = useInboxNotifications();

        return (
          <InboxNotificationList>
            {inboxNotifications.map((inboxNotification) => (
              <InboxNotification
                key={inboxNotification.id}
                inboxNotification={inboxNotification}
              />
            ))}
          </InboxNotificationList>
        );
      }
      ```

    </StepContent>

  </Step>
   <Step>
    <StepTitle>Import default styles</StepTitle>
    <StepContent>

    The default components come with default styles, you can import them into the
    root layout of your app or directly into a CSS file with `@import`.

    ```tsx file="app/layout.tsx"
    import "@liveblocks/react-ui/styles.css";
    ```

    </StepContent>

  </Step>

   <Step>
    <StepTitle>Trigger a custom notification</StepTitle>
    <StepContent>

      Trigger a custom notification using
      [`triggerInboxNotification`](/docs/api-reference/liveblocks-node#post-inbox-notifications-trigger)
      from a server action or route handler. In this example, a custom `$fileUploaded` notification is sent.

      ```ts
      "use server";

      import { Liveblocks } from "@liveblocks/node";

      const liveblocks = new Liveblocks({
        secret: "{{SECRET_KEY}}",
      });

      // Call this in your app to create a custom notification
      export async function triggerCustomNotification() {
        // +++
        await liveblocks.triggerInboxNotification({
          // The user that will receive the notification
          userId: "steven@example.com",
          kind: "$fileUploaded",
          subjectId: "my-file",

          // Custom data for this notification
          activityData: {
            file: "https://example.com/my-file.zip",
            status: "pending",
          },
        });
        // +++
      }
      ```
    </StepContent>

  </Step>

  <Step>

  <StepTitle>Render the custom notification</StepTitle>
  <StepContent>

    After triggering the custom notification, modify `InboxNotification` to
    [render it with custom UI](/docs/api-reference/liveblocks-react-ui#Rendering-notification-kinds-differently).

    ```tsx file="app/page.tsx"
    "use client";

    import { useInboxNotifications } from "@liveblocks/react/suspense";
    import {
      InboxNotification,
      InboxNotificationList,
    } from "@liveblocks/react-ui";

    export default function Page() {
      const { inboxNotifications } = useInboxNotifications();

      return (
        <InboxNotificationList>
          {inboxNotifications.map((inboxNotification) => (
            <InboxNotification
              key={inboxNotification.id}
              inboxNotification={inboxNotification}
              // +++
              kinds={{
                $fileUploaded: (props) => (
                  <InboxNotification.Custom
                    {...props}
                    title="File uploaded!"
                    aside={<InboxNotification.Icon>ðŸ“Ž</InboxNotification.Icon>}
                  >
                    A new file has been uploaded:
                    <b>{props.inboxNotification.activities[0].file}</b>
                  </InboxNotification.Custom>
                ),
              }}
              // +++
            />
          ))}
        </InboxNotificationList>
      );
    }
    ```

  </StepContent>

  </Step>

  <Step lastStep>
    <StepTitle>Next: authenticate and add your users</StepTitle>
    <StepContent>

      Notifications is set up and working now, but each user is anonymousâ€”the next step is to
      authenticate each user as they connect, and attach their name and avatar to their notifications.

      <Button asChild  className="not-markdown">
        <a href="/docs/guides/how-to-add-users-to-liveblocks-notifications">
          Add your users to Notifications
        </a>
      </Button>
    </StepContent>

  </Step>
</Steps>

## What to read next

Congratulations! Youâ€™ve set up the foundation to start building a notifications
experience for your React application.

- [API reference](/docs/api-reference/liveblocks-react#Notifications)
- [Component reference](/docs/api-reference/liveblocks-react-ui#Notifications)

---

## Examples using Notifications

<ListGrid columns={2}>
  <ExampleCard
    example={{
      title: "Comments notifications",
      slug: "comments-notifications/nextjs-comments-notifications",
      image: "/images/examples/thumbnails/comments-notifications.png",
    }}
    technologies={["nextjs", "react"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Custom notifications",
      slug: "notifications-custom/nextjs-notifications-custom",
      image: "/images/examples/thumbnails/custom-notifications.png",
    }}
    technologies={["nextjs", "react"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Notification settings",
      slug: "notification-settings/nextjs-notification-settings",
      image: "/images/examples/thumbnails/notification-settings.png",
    }}
    technologies={["nextjs", "react"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Notion-like AI Editor",
      slug: "notion-like-ai-editor/nextjs-notion-like-ai-editor",
      image: "/images/examples/thumbnails/notion-like-ai-editor.png",
    }}
    technologies={["nextjs", "react"]}
    openInNewWindow
  />
</ListGrid>

---
meta:
  title:
    "Get started with sending custom notifications to Microsoft Teams using
    Liveblocks and Next.js"
  parentTitle: "Quickstart"
  description:
    "Learn how to send custom notifications to Microsoft Teams using using
    Liveblocks Teams using Liveblocks and Next.js"
---

Liveblocks is a realtime collaboration infrastructure for building performant
collaborative experiences. Follow this guide to send
[custom notifications](/docs/ready-made-features/notifications/concepts#Custom-notifications)
to Microsoft Teams using methods from
[`@liveblocks/node`](/docs/api-reference/liveblocks-node).

## Quickstart

<Steps>
  <Step>
    <StepTitle>Install Liveblocks Node</StepTitle>
    <StepContent>

      Every Liveblocks package should use the same version.

      ```bash trackEvent="install_liveblocks"
      npm install @liveblocks/node
      ```

    </StepContent>

  </Step>

   <Step>
    <StepTitle>Trigger a custom notification</StepTitle>
    <StepContent>

      Trigger a custom notification using
      [`triggerInboxNotification`](/docs/api-reference/liveblocks-node#post-inbox-notifications-trigger)
      from a server action or route handler. In this example, a custom `$fileUploaded` notification is sent.

      ```ts
      "use server";

      import { Liveblocks } from "@liveblocks/node";

      const liveblocks = new Liveblocks({
        secret: "{{SECRET_KEY}}",
      });

      // Call this in your app to create a custom notification
      export async function triggerCustomNotification() {
        // +++
        await liveblocks.triggerInboxNotification({
          // The user that will receive the notification
          userId: "steven@example.com",
          kind: "$fileUploaded",
          subjectId: "my-file",

          // Custom data for this notification
          activityData: {
            file: "https://example.com/my-file.zip",
            status: "pending",
          },
        });
        // +++
      }
      ```
    </StepContent>

  </Step>

  <Step lastStep>
    <StepTitle>Follow our guide</StepTitle>
    <StepContent>

      Follow our step-by-step guide to learn set up MicrosoftTeams notifications.

      <Button asChild className="not-markdown">
        <a href="/docs/guides/how-to-notify-users-about-unread-custom-notifications-outside-of-your-app">
          How to notify users with MicrosoftTeams
        </a>
      </Button>

    </StepContent>

  </Step>
</Steps>

## What to read next

Congratulations! You've set up Microsoft Teams notifications in your Next.js
application.

- [Webhooks API reference](/docs/platform/webhooks)
- [Node.js API reference](/docs/api-reference/liveblocks-node)
- [How to test webhooks on localhost](/docs/guides/how-to-test-webhooks-on-localhost)

---

## Examples using Notifications

<ListGrid columns={2}>
  <ExampleCard
    example={{
      title: "Custom notifications",
      slug: "notifications-custom/nextjs-notifications-custom",
      image: "/images/examples/thumbnails/custom-notifications.png",
    }}
    technologies={["nextjs", "react"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Notification settings",
      slug: "notification-settings/nextjs-notification-settings",
      image: "/images/examples/thumbnails/notification-settings.png",
    }}
    technologies={["nextjs", "react"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Notion-like AI Editor",
      slug: "notion-like-ai-editor/nextjs-notion-like-ai-editor",
      image: "/images/examples/thumbnails/notion-like-ai-editor.png",
    }}
    technologies={["nextjs", "react"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Comments notifications",
      slug: "https://liveblocks.io/examples/comments-emails",
      image: "/images/examples/thumbnails/comments-notifications.png",
    }}
    technologies={["nextjs", "react"]}
    openInNewWindow
  />
</ListGrid>

---
meta:
  title:
    "Get started with sending custom notifications to Slack using Liveblocks and
    Next.js"
  parentTitle: "Quickstart"
  description:
    "Learn how to send custom notifications to Slack using using Liveblocks
    Liveblocks and Next.js"
---

Liveblocks is a realtime collaboration infrastructure for building performant
collaborative experiences. Follow this guide to send
[custom notifications](/docs/ready-made-features/notifications/concepts#Custom-notifications)
to Slack using methods from
[`@liveblocks/node`](/docs/api-reference/liveblocks-node).

## Quickstart

<Steps>
  <Step>
    <StepTitle>Install Liveblocks Node</StepTitle>
    <StepContent>

      Every Liveblocks package should use the same version.

      ```bash trackEvent="install_liveblocks"
      npm install @liveblocks/node
      ```

    </StepContent>

  </Step>

   <Step>
    <StepTitle>Trigger a custom notification</StepTitle>
    <StepContent>

      Trigger a custom notification using
      [`triggerInboxNotification`](/docs/api-reference/liveblocks-node#post-inbox-notifications-trigger)
      from a server action or route handler. In this example, a custom `$fileUploaded` notification is sent.

      ```ts
      "use server";

      import { Liveblocks } from "@liveblocks/node";

      const liveblocks = new Liveblocks({
        secret: "{{SECRET_KEY}}",
      });

      // Call this in your app to create a custom notification
      export async function triggerCustomNotification() {
        // +++
        await liveblocks.triggerInboxNotification({
          // The user that will receive the notification
          userId: "steven@example.com",
          kind: "$fileUploaded",
          subjectId: "my-file",

          // Custom data for this notification
          activityData: {
            file: "https://example.com/my-file.zip",
            status: "pending",
          },
        });
        // +++
      }
      ```
    </StepContent>

  </Step>

  <Step lastStep>
    <StepTitle>Follow our guide</StepTitle>
    <StepContent>

      Follow our step-by-step guide to learn set up Slack notifications.

      <Button asChild className="not-markdown">
        <a href="/docs/guides/how-to-notify-users-about-unread-custom-notifications-outside-of-your-app">
          How to notify users with Slack
        </a>
      </Button>

    </StepContent>

  </Step>
</Steps>

## What to read next

Congratulations! You've set up Slack notifications in your Next.js application.

- [Webhooks API reference](/docs/platform/webhooks)
- [Node.js API reference](/docs/api-reference/liveblocks-node)
- [How to test webhooks on localhost](/docs/guides/how-to-test-webhooks-on-localhost)

---

## Examples using Notifications

<ListGrid columns={2}>
  <ExampleCard
    example={{
      title: "Custom notifications",
      slug: "notifications-custom/nextjs-notifications-custom",
      image: "/images/examples/thumbnails/custom-notifications.png",
    }}
    technologies={["nextjs", "react"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Notification settings",
      slug: "notification-settings/nextjs-notification-settings",
      image: "/images/examples/thumbnails/notification-settings.png",
    }}
    technologies={["nextjs", "react"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Notion-like AI Editor",
      slug: "notion-like-ai-editor/nextjs-notion-like-ai-editor",
      image: "/images/examples/thumbnails/notion-like-ai-editor.png",
    }}
    technologies={["nextjs", "react"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Comments notifications",
      slug: "https://liveblocks.io/examples/comments-emails",
      image: "/images/examples/thumbnails/comments-notifications.png",
    }}
    technologies={["nextjs", "react"]}
    openInNewWindow
  />
</ListGrid>

---
meta:
  title:
    "Get started with sending custom notifications with Web Push using
    Liveblocks and Next.js"
  parentTitle: "Quickstart"
  description:
    "Learn how to send custom notifications with Web Push using using Liveblocks
    and Next.js"
---

Liveblocks is a realtime collaboration infrastructure for building performant
collaborative experiences. Follow this guide to send
[custom notifications](/docs/ready-made-features/notifications/concepts#Custom-notifications)
with Web Push using methods from
[`@liveblocks/node`](/docs/api-reference/liveblocks-node).

## Quickstart

<Steps>
  <Step>
    <StepTitle>Install Liveblocks Node</StepTitle>
    <StepContent>

      Every Liveblocks package should use the same version.

      ```bash trackEvent="install_liveblocks"
      npm install @liveblocks/node
      ```

    </StepContent>

  </Step>

  <Step>
    <StepTitle>Trigger a custom notification</StepTitle>
    <StepContent>

      Trigger a custom notification using
      [`triggerInboxNotification`](/docs/api-reference/liveblocks-node#post-inbox-notifications-trigger)
      from a server action or route handler. In this example, a custom `$fileUploaded` notification is sent.

      ```ts
      "use server";

      import { Liveblocks } from "@liveblocks/node";

      const liveblocks = new Liveblocks({
        secret: "{{SECRET_KEY}}",
      });

      // Call this in your app to create a custom notification
      export async function triggerCustomNotification() {
        // +++
        await liveblocks.triggerInboxNotification({
          // The user that will receive the notification
          userId: "steven@example.com",
          kind: "$fileUploaded",
          subjectId: "my-file",

          // Custom data for this notification
          activityData: {
            file: "https://example.com/my-file.zip",
            status: "pending",
          },
        });
        // +++
      }
      ```
    </StepContent>

  </Step>

  <Step lastStep>
    <StepTitle>Follow our guide</StepTitle>
    <StepContent>

      Follow our step-by-step guide to learn set up Web Push notifications.

      <Button asChild className="not-markdown">
        <a href="/docs/guides/how-to-notify-users-about-unread-custom-notifications-outside-of-your-app">
          How to notify users with Web Push
        </a>
      </Button>

    </StepContent>

  </Step>
</Steps>

## What to read next

Congratulations! You've set up Web Push notifications in your Next.js
application.

- [Webhooks API reference](/docs/platform/webhooks)
- [Node.js API reference](/docs/api-reference/liveblocks-node)
- [How to test webhooks on localhost](/docs/guides/how-to-test-webhooks-on-localhost)

---

## Examples using Notifications

<ListGrid columns={2}>
  <ExampleCard
    example={{
      title: "Custom notifications",
      slug: "notifications-custom/nextjs-notifications-custom",
      image: "/images/examples/thumbnails/custom-notifications.png",
    }}
    technologies={["nextjs", "react"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Notification settings",
      slug: "notification-settings/nextjs-notification-settings",
      image: "/images/examples/thumbnails/notification-settings.png",
    }}
    technologies={["nextjs", "react"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Notion-like AI Editor",
      slug: "notion-like-ai-editor/nextjs-notion-like-ai-editor",
      image: "/images/examples/thumbnails/notion-like-ai-editor.png",
    }}
    technologies={["nextjs", "react"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Comments notifications",
      slug: "https://liveblocks.io/examples/comments-emails",
      image: "/images/examples/thumbnails/comments-notifications.png",
    }}
    technologies={["nextjs", "react"]}
    openInNewWindow
  />
</ListGrid>

---
meta:
  title:
    "Get started with receiving custom notifications webhook events using
    Liveblocks and Next.js"
  parentTitle: "Quickstart"
  description:
    "Learn how to receive custom notifications webhook events using using
    Liveblocks and Next.js"
---

Liveblocks is a realtime collaboration infrastructure for building performant
collaborative experiences. Follow this guide to receive webhooks events for
[custom notifications](/docs/ready-made-features/notifications/concepts#Custom-notifications)
using methods from [`@liveblocks/node`](/docs/api-reference/liveblocks-node).

## Quickstart

<Steps>
  <Step>
    <StepTitle>Install Liveblocks Node</StepTitle>
    <StepContent>

      Every Liveblocks package should use the same version.

      ```bash trackEvent="install_liveblocks"
      npm install @liveblocks/node
      ```

    </StepContent>

  </Step>

   <Step>
    <StepTitle>Trigger a custom notification</StepTitle>
    <StepContent>

      Trigger a custom notification using
      [`triggerInboxNotification`](/docs/api-reference/liveblocks-node#post-inbox-notifications-trigger)
      from a server action or route handler. In this example, a custom `$fileUploaded` notification is sent.

      ```ts
      "use server";

      import { Liveblocks } from "@liveblocks/node";

      const liveblocks = new Liveblocks({
        secret: "{{SECRET_KEY}}",
      });

      // Call this in your app to create a custom notification
      export async function triggerCustomNotification() {
        // +++
        await liveblocks.triggerInboxNotification({
          // The user that will receive the notification
          userId: "steven@example.com",
          kind: "$fileUploaded",
          subjectId: "my-file",

          // Custom data for this notification
          activityData: {
            file: "https://example.com/my-file.zip",
            status: "pending",
          },
        });
        // +++
      }
      ```
    </StepContent>

  </Step>

  <Step lastStep>
    <StepTitle>Follow our guide</StepTitle>
    <StepContent>

      Follow our step-by-step guide to learn set up webhooks notifications.

      <Button asChild className="not-markdown">
        <a href="/docs/guides/how-to-notify-users-about-unread-custom-notifications-outside-of-your-app">
          How to notify users with webhooks
        </a>
      </Button>

    </StepContent>

  </Step>
</Steps>

## What to read next

Congratulations! You've set up webhooks notifications in your Next.js
application.

- [Webhooks API reference](/docs/platform/webhooks)
- [Node.js API reference](/docs/api-reference/liveblocks-node)
- [How to test webhooks on localhost](/docs/guides/how-to-test-webhooks-on-localhost)

---

## Examples using Notifications

<ListGrid columns={2}>
  <ExampleCard
    example={{
      title: "Custom notifications",
      slug: "notifications-custom/nextjs-notifications-custom",
      image: "/images/examples/thumbnails/custom-notifications.png",
    }}
    technologies={["nextjs", "react"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Notification settings",
      slug: "notification-settings/nextjs-notification-settings",
      image: "/images/examples/thumbnails/notification-settings.png",
    }}
    technologies={["nextjs", "react"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Notion-like AI Editor",
      slug: "notion-like-ai-editor/nextjs-notion-like-ai-editor",
      image: "/images/examples/thumbnails/notion-like-ai-editor.png",
    }}
    technologies={["nextjs", "react"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Comments notifications",
      slug: "https://liveblocks.io/examples/comments-emails",
      image: "/images/examples/thumbnails/comments-notifications.png",
    }}
    technologies={["nextjs", "react"]}
    openInNewWindow
  />
</ListGrid>

---
meta:
  title:
    "Get started with emailing collaborative notifications using Liveblocks and
    Next.js"
  parentTitle: "Quickstart"
  description:
    "Learn how to email collaborative notifications using Liveblocks and Next.js"
---

Liveblocks is a realtime collaboration infrastructure for building performant
collaborative experiences. Follow this guide to email
[collaboration notifications](/docs/ready-made-features/notifications/concepts#Collaboration-notifications)
using methods from [`@liveblocks/node`](/docs/api-reference/liveblocks-node).

## Quickstart

<Steps>

  <Step>
      <StepTitle>Have your Liveblocks app ready</StepTitle>
      <StepContent>

        To receive collaboration webhook events, they need to be triggered
        from your front-end application, for example when a new comment is
        added to a thread in your Liveblocks app. If you haven't set up an
        app yet, [get started with Comments](/docs/get-started/comments)
        before continuing.

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Install Liveblocks Node</StepTitle>
    <StepContent>

      Every Liveblocks package should use the same version.

      ```bash trackEvent="install_liveblocks"
      npm install @liveblocks/node
      ```

    </StepContent>

  </Step>
  <Step lastStep>
    <StepTitle>Follow our guide</StepTitle>
    <StepContent>

      Follow our step-by-step guide to learn set up email notifications.

      <Button asChild className="not-markdown">
        <a href="/docs/guides/how-to-send-email-notifications-of-unread-comments">
          How to send email notifications of unread comments
        </a>
      </Button>

    </StepContent>

  </Step>
</Steps>

## What to read next

Congratulations! You've set up email notifications in your Next.js application.

- [Webhooks API reference](/docs/platform/webhooks)
- [Node.js API reference](/docs/api-reference/liveblocks-node)
- [How to test webhooks on localhost](/docs/guides/how-to-test-webhooks-on-localhost)

---

## Examples using Notifications

<ListGrid columns={2}>
  <ExampleCard
    example={{
      title: "Comments notifications",
      slug: "https://liveblocks.io/examples/comments-emails",
      image: "/images/examples/thumbnails/comments-notifications.png",
    }}
    technologies={["nextjs", "react"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Custom notifications",
      slug: "notifications-custom/nextjs-notifications-custom",
      image: "/images/examples/thumbnails/custom-notifications.png",
    }}
    technologies={["nextjs", "react"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Notification settings",
      slug: "notification-settings/nextjs-notification-settings",
      image: "/images/examples/thumbnails/notification-settings.png",
    }}
    technologies={["nextjs", "react"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Notion-like AI Editor",
      slug: "notion-like-ai-editor/nextjs-notion-like-ai-editor",
      image: "/images/examples/thumbnails/notion-like-ai-editor.png",
    }}
    technologies={["nextjs", "react"]}
    openInNewWindow
  />
</ListGrid>

---
meta:
  title:
    "Get started with an in-app notification inbox using Liveblocks and Next.js"
  parentTitle: "Quickstart"
  description:
    "Learn how to add an in-app notification inbox using Liveblocks and Next.js"
---

Liveblocks is a realtime collaboration infrastructure for building performant
collaborative experiences. Follow this guide to start adding notifications to
your Next.js `/app` directory application using the hooks from
[`@liveblocks/react`](/docs/api-reference/liveblocks-react) and the components
from [`@liveblocks/react-ui`](/docs/api-reference/liveblocks-react-ui).

## Quickstart

<Steps>
  <Step>
    <StepTitle>Install Liveblocks</StepTitle>
    <StepContent>

      Every package should use the same version.

      ```bash trackEvent="install_liveblocks"
      npm install @liveblocks/client @liveblocks/react @liveblocks/react-ui
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Initialize the `liveblocks.config.ts` file</StepTitle>
    <StepContent>

      We can use this file later to [define types for our application](/docs/api-reference/liveblocks-react#Typing-your-data).

      ```bash
      npx create-liveblocks-app@latest --init --framework react
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Create a Liveblocks provider</StepTitle>
    <StepContent>

      Liveblocks Notifications uses the concept of projects, which relate to
      projects in [your dashboard](/dashboard). Notifications are sent between
      users in the same project. To connect and receive notifications, you must
      add [`LiveblocksProvider`](/docs/api-reference/liveblocks-react#LiveblocksProvider)
      to a client component in your app.

      ```tsx file="app/Providers.tsx" highlight="8-10"
      "use client";

      import { ReactNode } from "react";
      import { LiveblocksProvider } from "@liveblocks/react";

      export function Providers({ children }: { children: ReactNode }) {
        return (
          <LiveblocksProvider publicApiKey={"{{PUBLIC_KEY}}"}>
            {children}
          </LiveblocksProvider>
        );
      }
    ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Add the provider to your layout</StepTitle>
    <StepContent>

      After creating your provider file, itâ€™s time to use it. Import
      your room into your `layout.tsx` file.

      ```tsx file="app/layout.tsx"
      import { Providers } from "./Providers";

      export default function Layout({ children }) {
        return (
          <html>
            <body>
              // +++
              <Providers>
                {children}
              </Providers>
              // +++
            </body>
          </html>
        );
      }
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Use the Liveblocks hooks and components</StepTitle>
    <StepContent>

      Now that weâ€™ve set up the provider, we can start using the Liveblocks hooks and components.
      Weâ€™ll add [`useInboxNotifications`](/docs/api-reference/liveblocks-react#useInboxNotifications)
      to get the current projectâ€™s notifications, then weâ€™ll
      use [`InboxNotification`](/docs/api-reference/liveblocks-react-ui#InboxNotification) and [`InboxNotificationList`](/docs/api-reference/liveblocks-react-ui#InboxNotificationList) to render them.

      ```tsx file="app/page.tsx" highlight="10,13-20"
      "use client";

      import { useInboxNotifications } from "@liveblocks/react/suspense";
      import {
        InboxNotification,
        InboxNotificationList,
      } from "@liveblocks/react-ui";

      export default function Page() {
        const { inboxNotifications } = useInboxNotifications();

        return (
          <InboxNotificationList>
            {inboxNotifications.map((inboxNotification) => (
              <InboxNotification
                key={inboxNotification.id}
                inboxNotification={inboxNotification}
              />
            ))}
          </InboxNotificationList>
        );
      }
      ```

    </StepContent>

  </Step>
   <Step>
    <StepTitle>Import default styles</StepTitle>
    <StepContent>

    The default components come with default styles, you can import them into the
    root layout of your app or directly into a CSS file with `@import`.

    ```tsx file="app/layout.tsx"
    import "@liveblocks/react-ui/styles.css";
    ```

    </StepContent>

  </Step>
  <Step lastStep>
    <StepTitle>Next: authenticate and add your users</StepTitle>
    <StepContent>

      Notifications is set up and working now, but each user is anonymousâ€”the next step is to
      authenticate each user as they connect, and attach their name and avatar to their notifications.

      <Button asChild  className="not-markdown">
        <a href="/docs/guides/how-to-add-users-to-liveblocks-notifications">
          Add your users to Notifications
        </a>
      </Button>
    </StepContent>

  </Step>
</Steps>

## What to read next

Congratulations! Youâ€™ve set up the foundation to start building a notifications
experience for your React application.

- [API reference](/docs/api-reference/liveblocks-react#Notifications)
- [Component reference](/docs/api-reference/liveblocks-react-ui#Notifications)

---

## Examples using Notifications

<ListGrid columns={2}>
  <ExampleCard
    example={{
      title: "Comments notifications",
      slug: "comments-notifications/nextjs-comments-notifications",
      image: "/images/examples/thumbnails/comments-notifications.png",
    }}
    technologies={["nextjs", "react"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Custom notifications",
      slug: "notifications-custom/nextjs-notifications-custom",
      image: "/images/examples/thumbnails/custom-notifications.png",
    }}
    technologies={["nextjs", "react"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Notification settings",
      slug: "notification-settings/nextjs-notification-settings",
      image: "/images/examples/thumbnails/notification-settings.png",
    }}
    technologies={["nextjs", "react"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Notion-like AI Editor",
      slug: "notion-like-ai-editor/nextjs-notion-like-ai-editor",
      image: "/images/examples/thumbnails/notion-like-ai-editor.png",
    }}
    technologies={["nextjs", "react"]}
    openInNewWindow
  />
</ListGrid>

---
meta:
  title:
    "Get started with sending collaborative notifications to Microsoft Teams
    using Liveblocks and Next.js"
  parentTitle: "Quickstart"
  description:
    "Learn how to send collaborative notifications to Microsoft Teams using
    Microsoft Teams using Liveblocks and Next.js"
---

Liveblocks is a realtime collaboration infrastructure for building performant
collaborative experiences. Follow this guide to send
[collaboration notifications](/docs/ready-made-features/notifications/concepts#Collaboration-notifications)
to Microsoft Teams using methods from
[`@liveblocks/node`](/docs/api-reference/liveblocks-node).

## Quickstart

<Steps>

  <Step>
      <StepTitle>Have your Liveblocks app ready</StepTitle>
      <StepContent>

        To receive collaboration webhook events, they need to be triggered
        from your front-end application, for example when a new comment is
        added to a thread in your Liveblocks app. If you haven't set up an
        app yet, [get started with Comments](/docs/get-started/comments)
        before continuing.

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Install Liveblocks Node</StepTitle>
    <StepContent>

      Every Liveblocks package should use the same version.

      ```bash trackEvent="install_liveblocks"
      npm install @liveblocks/node
      ```

    </StepContent>

  </Step>
  <Step lastStep>
    <StepTitle>Follow our guide</StepTitle>
    <StepContent>

      Follow our step-by-step guide to learn set up Microsoft Teams notifications.

      <Button asChild className="not-markdown">
        <a href="/docs/guides/how-to-notify-users-about-unread-comments-outside-of-your-app">
          How to notify users with Microsoft Teams
        </a>
      </Button>

    </StepContent>

  </Step>
</Steps>

## What to read next

Congratulations! You've set up Microsoft Teams notifications in your Next.js
application.

- [Webhooks API reference](/docs/platform/webhooks)
- [Node.js API reference](/docs/api-reference/liveblocks-node)
- [How to test webhooks on localhost](/docs/guides/how-to-test-webhooks-on-localhost)

---

## Examples using Notifications

<ListGrid columns={2}>
  <ExampleCard
    example={{
      title: "Comments notifications",
      slug: "https://liveblocks.io/examples/comments-emails",
      image: "/images/examples/thumbnails/comments-notifications.png",
    }}
    technologies={["nextjs", "react"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Custom notifications",
      slug: "notifications-custom/nextjs-notifications-custom",
      image: "/images/examples/thumbnails/custom-notifications.png",
    }}
    technologies={["nextjs", "react"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Notification settings",
      slug: "notification-settings/nextjs-notification-settings",
      image: "/images/examples/thumbnails/notification-settings.png",
    }}
    technologies={["nextjs", "react"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Notion-like AI Editor",
      slug: "notion-like-ai-editor/nextjs-notion-like-ai-editor",
      image: "/images/examples/thumbnails/notion-like-ai-editor.png",
    }}
    technologies={["nextjs", "react"]}
    openInNewWindow
  />
</ListGrid>

---
meta:
  title:
    "Get started with sending collaborative notifications to Slack using
    Liveblocks and Next.js"
  parentTitle: "Quickstart"
  description:
    "Learn how to send collaborative notifications to Slack using using
    Liveblocks and Next.js"
---

Liveblocks is a realtime collaboration infrastructure for building performant
collaborative experiences. Follow this guide to send
[collaboration notifications](/docs/ready-made-features/notifications/concepts#Collaboration-notifications)
to Slack using methods from
[`@liveblocks/node`](/docs/api-reference/liveblocks-node).

## Quickstart

<Steps>

  <Step>
      <StepTitle>Have your Liveblocks app ready</StepTitle>
      <StepContent>

        To receive collaboration webhook events, they need to be triggered
        from your front-end application, for example when a new comment is
        added to a thread in your Liveblocks app. If you haven't set up an
        app yet, [get started with Comments](/docs/get-started/comments)
        before continuing.

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Install Liveblocks Node</StepTitle>
    <StepContent>

      Every Liveblocks package should use the same version.

      ```bash trackEvent="install_liveblocks"
      npm install @liveblocks/node
      ```

    </StepContent>

  </Step>
  <Step lastStep>
    <StepTitle>Follow our guide</StepTitle>
    <StepContent>

      Follow our step-by-step guide to learn set up Slack notifications.

      <Button asChild className="not-markdown">
        <a href="/docs/guides/how-to-notify-users-about-unread-comments-outside-of-your-app">
          How to notify users with Slack
        </a>
      </Button>

    </StepContent>

  </Step>
</Steps>

## What to read next

Congratulations! You've set up Slack notifications in your Next.js application.

- [Webhooks API reference](/docs/platform/webhooks)
- [Node.js API reference](/docs/api-reference/liveblocks-node)
- [How to test webhooks on localhost](/docs/guides/how-to-test-webhooks-on-localhost)

---

## Examples using Notifications

<ListGrid columns={2}>
  <ExampleCard
    example={{
      title: "Comments notifications",
      slug: "https://liveblocks.io/examples/comments-emails",
      image: "/images/examples/thumbnails/comments-notifications.png",
    }}
    technologies={["nextjs", "react"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Custom notifications",
      slug: "notifications-custom/nextjs-notifications-custom",
      image: "/images/examples/thumbnails/custom-notifications.png",
    }}
    technologies={["nextjs", "react"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Notification settings",
      slug: "notification-settings/nextjs-notification-settings",
      image: "/images/examples/thumbnails/notification-settings.png",
    }}
    technologies={["nextjs", "react"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Notion-like AI Editor",
      slug: "notion-like-ai-editor/nextjs-notion-like-ai-editor",
      image: "/images/examples/thumbnails/notion-like-ai-editor.png",
    }}
    technologies={["nextjs", "react"]}
    openInNewWindow
  />
</ListGrid>

---
meta:
  title:
    "Get started with sending collaborative notifications with Web Push using
    Liveblocks and Next.js"
  parentTitle: "Quickstart"
  description:
    "Learn how to send collaborative notifications with Web Push using
    Liveblocks and Next.js"
---

Liveblocks is a realtime collaboration infrastructure for building performant
collaborative experiences. Follow this guide to send
[collaboration notifications](/docs/ready-made-features/notifications/concepts#Collaboration-notifications)
to Web Push using methods from
[`@liveblocks/node`](/docs/api-reference/liveblocks-node).

## Quickstart

<Steps>

  <Step>
      <StepTitle>Have your Liveblocks app ready</StepTitle>
      <StepContent>

        To receive collaboration webhook events, they need to be triggered
        from your front-end application, for example when a new comment is
        added to a thread in your Liveblocks app. If you haven't set up an
        app yet, [get started with Comments](/docs/get-started/comments)
        before continuing.

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Install Liveblocks Node</StepTitle>
    <StepContent>

      Every Liveblocks package should use the same version.

      ```bash trackEvent="install_liveblocks"
      npm install @liveblocks/node
      ```

    </StepContent>

  </Step>
  <Step lastStep>
    <StepTitle>Follow our guide</StepTitle>
    <StepContent>

      Follow our step-by-step guide to learn set up Web Push notifications.

      <Button asChild className="not-markdown">
        <a href="/docs/guides/how-to-notify-users-about-unread-comments-outside-of-your-app">
          How to notify users with Web Push notifications
        </a>
      </Button>

    </StepContent>

  </Step>
</Steps>

## What to read next

Congratulations! You've set up Web Push notifications in your Next.js
application.

- [Webhooks API reference](/docs/platform/webhooks)
- [Node.js API reference](/docs/api-reference/liveblocks-node)
- [How to test webhooks on localhost](/docs/guides/how-to-test-webhooks-on-localhost)

---

## Examples using Notifications

<ListGrid columns={2}>
  <ExampleCard
    example={{
      title: "Comments notifications",
      slug: "https://liveblocks.io/examples/comments-emails",
      image: "/images/examples/thumbnails/comments-notifications.png",
    }}
    technologies={["nextjs", "react"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Custom notifications",
      slug: "notifications-custom/nextjs-notifications-custom",
      image: "/images/examples/thumbnails/custom-notifications.png",
    }}
    technologies={["nextjs", "react"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Notification settings",
      slug: "notification-settings/nextjs-notification-settings",
      image: "/images/examples/thumbnails/notification-settings.png",
    }}
    technologies={["nextjs", "react"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Notion-like AI Editor",
      slug: "notion-like-ai-editor/nextjs-notion-like-ai-editor",
      image: "/images/examples/thumbnails/notion-like-ai-editor.png",
    }}
    technologies={["nextjs", "react"]}
    openInNewWindow
  />
</ListGrid>

---
meta:
  title:
    "Get started with receiving collaborative notifications with webhooks using
    Liveblocks and Next.js"
  parentTitle: "Quickstart"
  description:
    "Learn how to receive collaborative notifications with webhooks using
    Liveblocks and Next.js"
---

Liveblocks is a realtime collaboration infrastructure for building performant
collaborative experiences. Follow this guide to receive webhooks events for
[collaboration notifications](/docs/ready-made-features/notifications/concepts#Collaboration-notifications)
using methods from [`@liveblocks/node`](/docs/api-reference/liveblocks-node).

## Quickstart

<Steps>

  <Step>
      <StepTitle>Have your Liveblocks app ready</StepTitle>
      <StepContent>

        To receive collaboration webhook events, they need to be triggered
        from your front-end application, for example when a new comment is
        added to a thread in your Liveblocks app. If you haven't set up an
        app yet, [get started with Comments](/docs/get-started/comments)
        before continuing.

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Install Liveblocks Node</StepTitle>
    <StepContent>

      Every Liveblocks package should use the same version.

      ```bash trackEvent="install_liveblocks"
      npm install @liveblocks/node
      ```

    </StepContent>

  </Step>
  <Step lastStep>
    <StepTitle>Follow our guide</StepTitle>
    <StepContent>

      Follow our step-by-step guide to learn set up webhooks for notifications.

      <Button asChild className="not-markdown">
        <a href="/docs/guides/how-to-notify-users-about-unread-comments-outside-of-your-app">
          How to notify users with webhooks
        </a>
      </Button>

    </StepContent>

  </Step>
</Steps>

## What to read next

Congratulations! Youâ€™ve set up external notifications in your Next.js
application.

- [Webhooks API reference](/docs/platform/webhooks)
- [Node.js API reference](/docs/api-reference/liveblocks-node)
- [How to test webhooks on localhost](/docs/guides/how-to-test-webhooks-on-localhost)

---

## Examples using Notifications

<ListGrid columns={2}>
  <ExampleCard
    example={{
      title: "Comments notifications",
      slug: "https://liveblocks.io/examples/comments-emails",
      image: "/images/examples/thumbnails/comments-notifications.png",
    }}
    technologies={["nextjs", "react"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Custom notifications",
      slug: "notifications-custom/nextjs-notifications-custom",
      image: "/images/examples/thumbnails/custom-notifications.png",
    }}
    technologies={["nextjs", "react"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Notification settings",
      slug: "notification-settings/nextjs-notification-settings",
      image: "/images/examples/thumbnails/notification-settings.png",
    }}
    technologies={["nextjs", "react"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Notion-like AI Editor",
      slug: "notion-like-ai-editor/nextjs-notion-like-ai-editor",
      image: "/images/examples/thumbnails/notion-like-ai-editor.png",
    }}
    technologies={["nextjs", "react"]}
    openInNewWindow
  />
</ListGrid>

---
meta:
  title: "Get started with a Tiptap text editor using Liveblocks and Next.js"
  parentTitle: "Quickstart"
  description:
    "Learn how to install a Tiptap text editor using Liveblocks and Next.js."
---

Liveblocks is a realtime collaboration infrastructure for building performant
collaborative experiences. Follow the following steps to start adding
collaboration to your Next.js application using the APIs from the
[`@liveblocks/react-tiptap`](/docs/api-reference/liveblocks-react-tiptap)
package.

## Quickstart

<Steps>
  <Step>
    <StepTitle>Install Liveblocks and Tiptap</StepTitle>
    <StepContent>

      Every Liveblocks package should use the same version.

      ```bash trackEvent="install_liveblocks"
      npm install @liveblocks/client @liveblocks/react @liveblocks/react-ui @liveblocks/react-tiptap @tiptap/react @tiptap/starter-kit
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Initialize the `liveblocks.config.ts` file</StepTitle>
    <StepContent>

      We can use this file later to [define types for our application](/docs/api-reference/liveblocks-react#Typing-your-data).

      ```bash
      npx create-liveblocks-app@latest --init --framework react
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Create a Liveblocks room</StepTitle>
    <StepContent>

      Liveblocks uses the concept of rooms, separate virtual spaces where people
      collaborate, and to create a realtime experience, multiple users must
      be connected to the same room. When using Next.jsâ€™ `/app` router,
      we recommend creating your room in a `Room.tsx` file in the same directory
      as your current route.

      Set up a Liveblocks client with
      [`LiveblocksProvider`](/docs/api-reference/liveblocks-react#LiveblocksProvider),
      join a room with [`RoomProvider`](/docs/api-reference/liveblocks-react#RoomProvider),
      and use [`ClientSideSuspense`](/docs/api-reference/liveblocks-react#ClientSideSuspense)
      to add a loading spinner to your app.

      ```tsx file="app/Room.tsx" highlight="12-18"
      "use client";

      import { ReactNode } from "react";
      import {
        LiveblocksProvider,
        RoomProvider,
        ClientSideSuspense,
      } from "@liveblocks/react/suspense";

      export function Room({ children }: { children: ReactNode }) {
        return (
          <LiveblocksProvider publicApiKey={"{{PUBLIC_KEY}}"}>
            <RoomProvider id="my-room">
              <ClientSideSuspense fallback={<div>Loadingâ€¦</div>}>
                {children}
              </ClientSideSuspense>
            </RoomProvider>
          </LiveblocksProvider>
        );
      }
      ```

  </StepContent>

</Step>
<Step>
  <StepTitle>Add the Liveblocks room to your page</StepTitle>
  <StepContent>

    After creating your room file, itâ€™s time to join it. Import
    your room into your `page.tsx` file, and place
    your collaborative app components inside it.

    ```tsx file="app/page.tsx" highlight="6-8"
    import { Room } from "./Room";
    import { Editor } from "./Editor";

    export default function Page() {
      return (
        <Room>
          <Editor/>
        </Room>
      );
    }
    ```

  </StepContent>

</Step>
<Step>
  <StepTitle>Set up the collaborative Tiptap text editor</StepTitle>
  <StepContent>

    Now that we set up Liveblocks, we can start integrating Tiptap and Liveblocks in the `Editor.tsx` file.
    To make the editor collaborative, we can add
    [`useLiveblocksExtension`](/docs/api-reference/liveblocks-react-tiptap#useLiveblocksExtension)
    from `@liveblocks/react-tiptap`. [`FloatingToolbar`](/docs/api-reference/liveblocks-react-tiptap#FloatingToolbar)
    adds a text selection toolbar.

    ```tsx file="app/Editor.tsx"
    "use client";

    import { useLiveblocksExtension, FloatingToolbar } from "@liveblocks/react-tiptap";
    import { useEditor, EditorContent } from "@tiptap/react";
    import StarterKit from "@tiptap/starter-kit";
    import { Threads } from "./Threads";

    export function Editor() {
      const liveblocks = useLiveblocksExtension();

      const editor = useEditor({
        extensions: [
          liveblocks,
          StarterKit.configure({
            // The Liveblocks extension comes with its own history handling
            undoRedo: false,
          }),
        ],
        immediatelyRender: false,
      });

      return (
        <div>
          <EditorContent editor={editor} className="editor" />
          <Threads editor={editor} />
          <FloatingToolbar editor={editor} />
        </div>
      );
    }
    ```

</StepContent>

</Step>
<Step>
  <StepTitle>Render threads and composer</StepTitle>
  <StepContent>

    To add [Comments](/docs/ready-made-features/comments) to your text editor, we need to import a thread composer
    and list each thread on the page. Create a `Threads.tsx` file that uses [`FloatingComposer`](/docs/api-reference/liveblocks-react-tiptap#FloatingComposer)
    for creating new threads, alongside [`AnchoredThreads`](/docs/api-reference/liveblocks-react-tiptap#AnchoredThreads) and [`FloatingThreads`](/docs/api-reference/liveblocks-react-tiptap#FloatingThreads) for displaying threads on desktop and mobile.

    ```tsx file="app/Threads.tsx"
    import { useThreads } from "@liveblocks/react/suspense";
    import {
      AnchoredThreads,
      FloatingComposer,
      FloatingThreads,
    } from "@liveblocks/react-tiptap";
    import { Editor } from "@tiptap/react";

    export function Threads({ editor }: { editor: Editor | null }) {
      const { threads } = useThreads({ query: { resolved: false } });

      return (
        <>
          <div className="anchored-threads">
            <AnchoredThreads editor={editor} threads={threads} />
          </div>
          <FloatingThreads
            editor={editor}
            threads={threads}
            className="floating-threads"
          />
          <FloatingComposer editor={editor} className="floating-composer" />
        </>
      );
    }
    ```

</StepContent>

</Step>
<Step>
  <StepTitle>Style your editor</StepTitle>
  <StepContent>

    Tiptap text editor is unstyled by default, so we can create some custom styles for it in a `globals.css` file. Import `globals.css`, alongside the default Liveblocks styles. You can import them into the
    root layout of your app or directly into a CSS file with `@import`.

    ```css file="app/globals.css" isCollapsed isCollapsable
    .editor {
      position: relative;
      display: flex;
      width: 100%;
      height: 100%;
    }

    .tiptap {
      padding: 2px 12px;
      outline: none;
      width: 100%;
    }

    /* For mobile */
    .floating-threads {
      display: none;
    }

    /* For desktop */
    .anchored-threads {
      display: block;
      max-width: 300px;
      width: 100%;
      position: absolute;
      right: 12px;
    }

    @media (max-width: 640px) {
      .floating-threads {
        display: block;
      }

      .anchored-threads {
        display: none;
      }
    }
    ```

    ```tsx file="app/layout.tsx"
    import "@liveblocks/react-ui/styles.css";
    import "@liveblocks/react-tiptap/styles.css";
    import "./globals.css";
    ```

  </StepContent>

</Step>
<Step>
  <StepTitle>Next: authenticate and add your users</StepTitle>
  <StepContent>
    Text Editor is set up and working now, but each user is anonymousâ€”the next step is to
    authenticate each user as they connect, and attach their name, color, and avatar, to their cursors and mentions.

    <Button asChild  className="not-markdown">
      <a href="/docs/guides/how-to-add-users-to-liveblocks-text-editor">
        Add your users to Text Editor
      </a>
    </Button>

  </StepContent>

</Step>
<Step lastStep>
  <StepTitle>Optional: add more features</StepTitle>
  <StepContent>
   Tiptap is easy to extend, and a number of extensions are already available, making it possible to quickly create complex rich-text applications. For example you can enable features
    such as tables, text highlights, embedded images, and more. This is all supported using Liveblocks.

    <Button asChild  className="not-markdown">
      <a href="https://tiptap.dev/docs/editor/extensions/overview">
        Find more extensions
      </a>
    </Button>

  </StepContent>

</Step>
</Steps>

## What to read next

Congratulations! You now have set up the foundation for your collaborative
Tiptap text editor inside your React application.

- [@liveblocks/react-tiptap API Reference](/docs/api-reference/liveblocks-react-tiptap)
- [Tiptap guides](/docs/guides?technologies=tiptap)
- [Tiptap website](https://tiptap.dev)

---

## Examples using Tiptap

<ListGrid columns={2}>
  <ExampleCard
    example={{
      title: "Collaborative Text Editor",
      slug: "collaborative-text-editor/nextjs-tiptap",
      image: "/images/examples/thumbnails/text-editor.jpg",
    }}
    technologies={["nextjs"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Advanced Collaborative Text Editor",
      slug: "collaborative-text-editor-advanced/nextjs-tiptap-advanced",
      image: "/images/examples/thumbnails/text-editor-advanced.jpg",
    }}
    technologies={["nextjs"]}
    openInNewWindow
  />
</ListGrid>

---
meta:
  title:
    "Get started with a collaborative Tldraw whiteboard using Liveblocks and
    Next.js"
  parentTitle: "Quickstart"
  description:
    "Learn how to add a collaborative Tldraw whiteboard using Liveblocks and
    Next.js"
---

Liveblocks is a realtime collaboration infrastructure for building performant
collaborative experiences. Follow the following steps to start adding
collaboration to your Next.js and Tldraw app using hooks from
[`@liveblocks/react`](/docs/api-reference/liveblocks-react).

## Quickstart

<Steps>

  <Step>
    <StepTitle>Install Liveblocks</StepTitle>
    <StepContent>

      Every package should use the same version.

      ```bash trackEvent="install_liveblocks"
      npm install @liveblocks/client @liveblocks/react tldraw
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Initialize the `liveblocks.config.ts` file</StepTitle>
    <StepContent>

      We can use this file later to [define types for our application](/docs/api-reference/liveblocks-react#Typing-your-data).

      ```bash
      npx create-liveblocks-app@latest --init --framework react
      ```

    </StepContent>

  </Step>

<Step>
    <StepTitle>Add Tldraw types to `liveblocks.config.ts`</StepTitle>
    <StepContent>

    Edit your new `liveblocks.config.ts` file to include the following types for Tldraw.

      ```ts file="liveblocks.config.ts"
      declare global {
        interface Liveblocks {
          Presence: {
            presence: any;
          };

          Storage: {
            records: LiveMap<string, any>;
          };

          UserMeta: {
            id: string;
            info: {
              name: string;
              color: string;
              avatar: string;
            };
          };
        }
      }
      ```

    </StepContent>

  </Step>

  <Step>
    <StepTitle>Create a Liveblocks room</StepTitle>
    <StepContent>

      Liveblocks uses the concept of rooms, separate virtual spaces where people
      collaborate, and to create a realtime experience, multiple users must
      be connected to the same room. When using Next.jsâ€™ `/app` router,
      we recommend creating your room in a `Room.tsx` file in the same directory
      as your current route.

      Set up a Liveblocks client with
      [`LiveblocksProvider`](/docs/api-reference/liveblocks-react#LiveblocksProvider),
      join a room with [`RoomProvider`](/docs/api-reference/liveblocks-react#RoomProvider),
      and use [`ClientSideSuspense`](/docs/api-reference/liveblocks-react#ClientSideSuspense)
      to add a loading spinner to your app.

      ```tsx file="app/Room.tsx" highlight="12-18"
      "use client";

      import { ReactNode } from "react";
      import {
        LiveblocksProvider,
        RoomProvider,
        ClientSideSuspense,
      } from "@liveblocks/react/suspense";

      export function Room({ children }: { children: ReactNode }) {
        return (
          <LiveblocksProvider publicApiKey={"{{PUBLIC_KEY}}"}>
            <RoomProvider id="my-room">
              <ClientSideSuspense fallback={<div>Loadingâ€¦</div>}>
                {children}
              </ClientSideSuspense>
            </RoomProvider>
          </LiveblocksProvider>
        );
      }
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Add the Liveblocks room to your page</StepTitle>
    <StepContent>

      After creating your room file, itâ€™s time to join it. Import
      your room into your `page.tsx` file, and place
      your collaborative app components inside it.

      ```tsx file="app/page.tsx" highlight="6-8"
      import { Room } from "./Room";
      import { TldrawApp } from "./TldrawApp";

      export default function Page() {
        return (
          <Room>
            <TldrawApp />
          </Room>
        );
      }
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Add the Tldraw component</StepTitle>
    <StepContent>

      Now that weâ€™re connected to a room, add the `Tldraw` component, importing a custom `useStorageStore` hook.

      ```tsx file="app/TldrawApp.tsx"
      "use client";

      import { useStorageStore } from "./useStorageStore";

      function StorageTldraw() {
        const id = useSelf((me) => me.id);
        const info = useSelf((me) => me.info);

        const store = useStorageStore({
          user: { id, color: info?.color || "red", name: info?.name || "Guest" },
        });

        return (
          <div style={{ height: "100%", width: "100vw" }}>
            <Tldraw store={store} autoFocus />
          </div>
        );
      }
      ```

    </StepContent>

  </Step>

<Step>
    <StepTitle>Synchronize Tldraw with Liveblocks</StepTitle>
    <StepContent>

      Create the `useStorageStore` hook to synchronize Tldraw state with
      Liveblocks Storage, and your whiteboard should be synchronized.

      ```tsx file="app/useStorageStore.ts" isCollapsable isCollapsed
      import { useEffect, useState } from "react";
      import { useRoom } from "@liveblocks/react/suspense";
      import {
        computed,
        createPresenceStateDerivation,
        createTLStore,
        react,
        defaultShapeUtils,
        DocumentRecordType,
        InstancePresenceRecordType,
        PageRecordType,
        IndexKey,
        TLAnyShapeUtilConstructor,
        TLDocument,
        TLInstancePresence,
        TLPageId,
        TLRecord,
        TLStoreEventInfo,
        TLStoreWithStatus,
      } from "tldraw";

      export function useStorageStore({
        shapeUtils = [],
        user,
      }: Partial<{
        hostUrl: string;
        version: number;
        shapeUtils: TLAnyShapeUtilConstructor[];
        user: {
          id: string;
          color: string;
          name: string;
        };
      }>) {
        // Get Liveblocks room
        const room = useRoom();

        // Set up tldraw store and status
        const [store] = useState(() => {
          const store = createTLStore({
            shapeUtils: [...defaultShapeUtils, ...shapeUtils],
          });
          return store;
        });

        const [storeWithStatus, setStoreWithStatus] = useState<TLStoreWithStatus>({
          status: "loading",
        });

        useEffect(() => {
          const unsubs: (() => void)[] = [];
          // State is already initialized to "loading", no need to set it again

          async function setup() {
            // Get Liveblocks Storage values
            const { root } = await room.getStorage();
            const liveRecords = root.get("records");

            // Initialize tldraw with records from Storage
            store.clear();
            store.put(
              [
                DocumentRecordType.create({
                  id: "document:document" as TLDocument["id"],
                }),
                PageRecordType.create({
                  id: "page:page" as TLPageId,
                  name: "Page 1",
                  index: "a1" as IndexKey,
                }),
                ...[...liveRecords.values()],
              ],
              "initialize"
            );

            // Sync tldraw changes with Storage
            unsubs.push(
              store.listen(
                ({ changes }: TLStoreEventInfo) => {
                  room.batch(() => {
                    Object.values(changes.added).forEach((record) => {
                      liveRecords.set(record.id, record);
                    });

                    Object.values(changes.updated).forEach(([_, record]) => {
                      liveRecords.set(record.id, record);
                    });

                    Object.values(changes.removed).forEach((record) => {
                      liveRecords.delete(record.id);
                    });
                  });
                },
                { source: "user", scope: "document" }
              )
            );

            // Sync tldraw changes with Presence
            function syncStoreWithPresence({ changes }: TLStoreEventInfo) {
              room.batch(() => {
                Object.values(changes.added).forEach((record) => {
                  room.updatePresence({ [record.id]: record });
                });

                Object.values(changes.updated).forEach(([_, record]) => {
                  room.updatePresence({ [record.id]: record });
                });

                Object.values(changes.removed).forEach((record) => {
                  room.updatePresence({ [record.id]: null });
                });
              });
            }

            unsubs.push(
              store.listen(syncStoreWithPresence, {
                source: "user",
                scope: "session",
              })
            );

            unsubs.push(
              store.listen(syncStoreWithPresence, {
                source: "user",
                scope: "presence",
              })
            );

            // Update tldraw when Storage changes
            unsubs.push(
              room.subscribe(
                liveRecords,
                (storageChanges) => {
                  const toRemove: TLRecord["id"][] = [];
                  const toPut: TLRecord[] = [];

                  for (const update of storageChanges) {
                    if (update.type !== "LiveMap") {
                      return;
                    }

                    for (const [id, { type }] of Object.entries(update.updates)) {
                      switch (type) {
                        // Object deleted from Liveblocks, remove from tldraw
                        case "delete": {
                          toRemove.push(id as TLRecord["id"]);
                          break;
                        }

                        // Object updated on Liveblocks, update tldraw
                        case "update": {
                          const curr = update.node.get(id);
                          if (curr) {
                            toPut.push(curr as any as TLRecord);
                          }
                          break;
                        }
                      }
                    }
                  }

                  // Update tldraw with changes
                  store.mergeRemoteChanges(() => {
                    if (toRemove.length) {
                      store.remove(toRemove);
                    }
                    if (toPut.length) {
                      store.put(toPut);
                    }
                  });
                },
                { isDeep: true }
              )
            );

            // Set user's info
            const userPreferences = computed<{
              id: string;
              color: string;
              name: string;
            }>("userPreferences", () => {
              if (!user) {
                throw new Error("Failed to get user");
              }
              return {
                id: user.id,
                color: user.color,
                name: user.name,
              };
            });

            // Unique ID for this session is their connectionId
            const connectionIdString = "" + (room.getSelf()?.connectionId || 0);

            // Set both
            const presenceDerivation = createPresenceStateDerivation(
              userPreferences,
              InstancePresenceRecordType.createId(connectionIdString)
            )(store);

            // Update presence with tldraw values
            room.updatePresence({
              presence: presenceDerivation.get() ?? null,
            });

            // Update Liveblocks when tldraw presence changes
            unsubs.push(
              react("when presence changes", () => {
                const presence = presenceDerivation.get() ?? null;
                requestAnimationFrame(() => {
                  room.updatePresence({ presence });
                });
              })
            );

            // Sync Liveblocks presence with tldraw
            unsubs.push(
              room.subscribe("others", (others, event) => {
                const toRemove: TLInstancePresence["id"][] = [];
                const toPut: TLInstancePresence[] = [];

                switch (event.type) {
                  // A user disconnected from Liveblocks
                  case "leave": {
                    if (event.user.connectionId) {
                      toRemove.push(
                        InstancePresenceRecordType.createId(
                          `${event.user.connectionId}`
                        )
                      );
                    }
                    break;
                  }

                  // Others was reset, e.g. after losing connection and returning
                  case "reset": {
                    others.forEach((other) => {
                      toRemove.push(
                        InstancePresenceRecordType.createId(`${other.connectionId}`)
                      );
                    });
                    break;
                  }

                  // A user entered or their presence updated
                  case "enter":
                  case "update": {
                    const presence = event?.user?.presence;
                    if (presence?.presence) {
                      toPut.push(event.user.presence.presence);
                    }
                  }
                }

                // Update tldraw with changes
                store.mergeRemoteChanges(() => {
                  if (toRemove.length) {
                    store.remove(toRemove);
                  }
                  if (toPut.length) {
                    store.put(toPut);
                  }
                });
              })
            );

            setStoreWithStatus({
              store,
              status: "synced-remote",
              connectionStatus: "online",
            });
          }

          setup();

          return () => {
            unsubs.forEach((fn) => fn());
            unsubs.length = 0;
          };
        }, [room, store, user]);

        return storeWithStatus;
      }
      ```
    </StepContent>

  </Step>

  <Step lastStep>
    <StepTitle>Next: set up authentication</StepTitle>
    <StepContent>

      By default, Liveblocks is configured to work without an authentication endpoint
      where everyone automatically has access to rooms. This approach is great for
      prototyping and marketing pages where setting up your own security isnâ€™t always
      required. If you want to limit access to a room for certain users, youâ€™ll need
      to set up an authentication endpoint to enable permissions.

      <Button asChild className="not-markdown">
        <a href="/docs/authentication">
          Set up authentication
        </a>
      </Button>
    </StepContent>

  </Step>
</Steps>

## What to read next

Congratulations! You now have set up the foundation to start building
collaborative experiences for your React application.

- [@liveblocks/react API Reference](/docs/api-reference/liveblocks-react)
- [Next.js and React guides](/docs/guides?technologies=nextjs%2Creact)
- [How to use Liveblocks Presence with React](/docs/guides/how-to-use-liveblocks-presence-with-react)
- [How to use Liveblocks Storage with React](/docs/guides/how-to-use-liveblocks-storage-with-react)

---

## Examples using Next.js

<ListGrid columns={2}>
  <ExampleCard
    example={{
      title: "Collaborative To-do List",
      slug: "collaborative-todo-list/nextjs-todo-list",
      image: "/images/examples/thumbnails/collaborative-todo-list.jpg",
    }}
    technologies={["nextjs", "vuejs", "sveltekit", "solidjs", "javascript"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Live Avatar Stack",
      slug: "live-avatar-stack/nextjs-live-avatars",
      image: "/images/examples/thumbnails/live-avatar-stack.jpg",
    }}
    technologies={["nextjs", "nuxtjs", "vuejs", "sveltekit", "solidjs"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Collaborative Spreadsheet",
      slug: "collaborative-spreadsheet-advanced/nextjs-spreadsheet-advanced",
      image:
        "/images/examples/thumbnails/collaborative-spreadsheet-advanced.jpg",
      advanced: true,
    }}
    technologies={["nextjs"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Collaborative Whiteboard",
      slug: "collaborative-whiteboard-advanced/nextjs-whiteboard-advanced",
      image:
        "/images/examples/thumbnails/collaborative-whiteboard-advanced.jpg",
      advanced: true,
    }}
    technologies={["nextjs"]}
    openInNewWindow
  />
</ListGrid>

---
meta:
  title: "Get started with Liveblocks and Next.js"
  parentTitle: "Quickstart"
  description: "Learn how to get started with Liveblocks and Next.js"
---

Liveblocks is a realtime collaboration infrastructure for building performant
collaborative experiences. Follow the following steps to start adding
collaboration to your Next.js `/app` directory application using the hooks from
the [`@liveblocks/react`](/docs/api-reference/liveblocks-react) package.

## Quickstart

<Steps>

  <Step>
    <StepTitle>Install Liveblocks</StepTitle>
    <StepContent>

      Every package should use the same version.

      ```bash trackEvent="install_liveblocks"
      npm install @liveblocks/client @liveblocks/react
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Initialize the `liveblocks.config.ts` file</StepTitle>
    <StepContent>

      We can use this file later to [define types for our application](/docs/api-reference/liveblocks-react#Typing-your-data).

      ```bash
      npx create-liveblocks-app@latest --init --framework react
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Create a Liveblocks room</StepTitle>
    <StepContent>

      Liveblocks uses the concept of rooms, separate virtual spaces where people
      collaborate, and to create a realtime experience, multiple users must
      be connected to the same room. When using Next.jsâ€™ `/app` router,
      we recommend creating your room in a `Room.tsx` file in the same directory
      as your current route.

      Set up a Liveblocks client with
      [`LiveblocksProvider`](/docs/api-reference/liveblocks-react#LiveblocksProvider),
      join a room with [`RoomProvider`](/docs/api-reference/liveblocks-react#RoomProvider),
      and use [`ClientSideSuspense`](/docs/api-reference/liveblocks-react#ClientSideSuspense)
      to add a loading spinner to your app.

      ```tsx file="app/Room.tsx" highlight="12-18"
      "use client";

      import { ReactNode } from "react";
      import {
        LiveblocksProvider,
        RoomProvider,
        ClientSideSuspense,
      } from "@liveblocks/react/suspense";

      export function Room({ children }: { children: ReactNode }) {
        return (
          <LiveblocksProvider publicApiKey={"{{PUBLIC_KEY}}"}>
            <RoomProvider id="my-room">
              <ClientSideSuspense fallback={<div>Loadingâ€¦</div>}>
                {children}
              </ClientSideSuspense>
            </RoomProvider>
          </LiveblocksProvider>
        );
      }
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Add the Liveblocks room to your page</StepTitle>
    <StepContent>

      After creating your room file, itâ€™s time to join it. Import
      your room into your `page.tsx` file, and place
      your collaborative app components inside it.

      ```tsx file="app/page.tsx" highlight="6-8"
      import { Room } from "./Room";
      import { CollaborativeApp } from "./CollaborativeApp";

      export default function Page() {
        return (
          <Room>
            <CollaborativeApp />
          </Room>
        );
      }
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Use the Liveblocks hooks</StepTitle>
    <StepContent>

      Now that weâ€™re connected to a room, we can start using the Liveblocks hooks.
      The first weâ€™ll add is [`useOthers`](/docs/api-reference/liveblocks-react#useOthers), a hook that provides information
      about which other users are connected to the room.

      ```tsx file="app/CollaborativeApp.tsx" highlight="6"
      "use client";

      import { useOthers } from "@liveblocks/react/suspense";

      export function CollaborativeApp() {
        const others = useOthers();
        const userCount = others.length;
        return <div>There are {userCount} other user(s) online</div>;
      }
      ```

    </StepContent>

  </Step>
  <Step lastStep>
    <StepTitle>Next: set up authentication</StepTitle>
    <StepContent>

      By default, Liveblocks is configured to work without an authentication endpoint
      where everyone automatically has access to rooms. This approach is great for
      prototyping and marketing pages where setting up your own security isnâ€™t always
      required. If you want to limit access to a room for certain users, youâ€™ll need
      to set up an authentication endpoint to enable permissions.

      <Button asChild className="not-markdown">
        <a href="/docs/authentication">
          Set up authentication
        </a>
      </Button>
    </StepContent>

  </Step>
</Steps>

## What to read next

Congratulations! You now have set up the foundation to start building
collaborative experiences for your React application.

- [@liveblocks/react API Reference](/docs/api-reference/liveblocks-react)
- [Next.js and React guides](/docs/guides?technologies=nextjs%2Creact)
- [How to use Liveblocks Presence with React](/docs/guides/how-to-use-liveblocks-presence-with-react)
- [How to use Liveblocks Storage with React](/docs/guides/how-to-use-liveblocks-storage-with-react)

---

## Examples using Next.js

<ListGrid columns={2}>
  <ExampleCard
    example={{
      title: "Collaborative To-do List",
      slug: "collaborative-todo-list/nextjs-todo-list",
      image: "/images/examples/thumbnails/collaborative-todo-list.jpg",
    }}
    technologies={["nextjs", "vuejs", "sveltekit", "solidjs", "javascript"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Live Avatar Stack",
      slug: "live-avatar-stack/nextjs-live-avatars",
      image: "/images/examples/thumbnails/live-avatar-stack.jpg",
    }}
    technologies={["nextjs", "nuxtjs", "vuejs", "sveltekit", "solidjs"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Collaborative Spreadsheet",
      slug: "collaborative-spreadsheet-advanced/nextjs-spreadsheet-advanced",
      image:
        "/images/examples/thumbnails/collaborative-spreadsheet-advanced.jpg",
      advanced: true,
    }}
    technologies={["nextjs"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Collaborative Whiteboard",
      slug: "collaborative-whiteboard-advanced/nextjs-whiteboard-advanced",
      image:
        "/images/examples/thumbnails/collaborative-whiteboard-advanced.jpg",
      advanced: true,
    }}
    technologies={["nextjs"]}
    openInNewWindow
  />
</ListGrid>

---
meta:
  title: "Get started with an AI chat using Liveblocks and React"
  parentTitle: "Quickstart"
  description:
    "Learn how to get started with an AI chat using Liveblocks and React"
---

Liveblocks is a realtime collaboration infrastructure for building performant
collaborative experiences. Follow the following steps to start adding an
advanced AI chat to your React application using the hooks from
[`@liveblocks/react`](/docs/api-reference/liveblocks-react) and the components
from [`@liveblocks/react-ui`](/docs/api-reference/liveblocks-react-ui).

## Quickstart

<Steps>
  <Step>
    <StepTitle>Install Liveblocks</StepTitle>
    <StepContent>

      Every package should use the same version.

      ```bash trackEvent="install_liveblocks"
      npm install @liveblocks/client @liveblocks/react @liveblocks/react-ui @liveblocks/node
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Set up an authentication route</StepTitle>
    <StepContent>

      Create an [authentication](/docs/authentication) endpoint at `/api/liveblocks-auth`,
      passing a unique user ID to [`prepareSession`](/docs/api-reference/liveblocks-node#prepareSession).
      Each user has their own set of private chats, and this allows Liveblocks to identify who is connecting.
      Add your secret key from the [dashboard](/dashboard).

      ```tsx file="Your endpoint at /api/liveblocks-auth"
      import { Liveblocks } from "@liveblocks/node";

      const liveblocks = new Liveblocks({
        secret: "{{SECRET_KEY}}",
      });

      export async function POST() {
        // Get the current user from your database
        const user = {
          // +++
          id: "user-1",
          // +++
          info: {
            // Optional. `name`, `avatar`, `color`, custom info.
          },
        };

        // Create a session for the current user
        // +++
        const session = liveblocks.prepareSession(user.id, {
          userInfo: user.info,
        });
        // +++

        // Give the user access to AI chats
        session.allow(`*`, session.FULL_ACCESS);

        // Authorize the user and return the result
        const { status, body } = await session.authorize();
        return new Response(body, { status });
      }
      ```
    </StepContent>

  </Step>
  <Step>
    <StepTitle>Set up the Liveblocks client</StepTitle>
    <StepContent>

      To connect the user to their chats, you must
      add [`LiveblocksProvider`](/docs/api-reference/liveblocks-react#LiveblocksProvider)
      to a client component in your app.

      ```tsx file="App.tsx"
      "use client";

      import { LiveblocksProvider } from "@liveblocks/react/suspense";
      import { MyApp } from "./MyApp";

      export default function App() {
        return (
          // +++
          <LiveblocksProvider authEndpoint="/api/liveblocks-auth">
            <MyApp />
          </LiveblocksProvider>
          // +++
        );
      }
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Add the AI chat component</StepTitle>
    <StepContent>

      Now you can add the [`AiChat`](/docs/api-reference/liveblocks-react-ui#AiChat)
      component to your application. This component renders a fully-featured AI
      chat interface with message history and a composer. You can add
      [tools](/docs/ready-made-features/ai-copilots/tools), [knowledge](/docs/ready-made-features/ai-copilots/knowledge),
      and use [hooks](/docs/ready-made-features/ai-copilots/hooks).

      ```tsx file="MyApp.tsx"
      "use client";

      import { AiChat } from "@liveblocks/react-ui";
      import { RegisterAiTool, RegisterAiKnowledge } from "@liveblocks/react";

      export function MyApp() {
        return (
          <div style={{ height: 500, width: 500 }}>
            // +++
            <AiChat
              chatId="my-first-chat"
              // copilotId="co_aH1j2..."
            />
            // +++
            {/* <RegisterAiTool ... /> and <RegisterAiKnowledge ... /> */}
          </div>
        );
      }
      ```

    </StepContent>

  </Step>
   <Step>
    <StepTitle>Import default styles</StepTitle>
    <StepContent>

    The default components come with default styles, you can import them into the
    root of your app or directly into a CSS file with `@import`.

    ```tsx
    import "@liveblocks/react-ui/styles.css";
    ```

    </StepContent>

  </Step>
  <Step lastStep>
    <StepTitle>Next: create a copilot</StepTitle>
    <StepContent>

      AI Copilots is set up and working, but itâ€™s using our default AI model
      and promptâ€”the next step is to create a custom copilot
      using your preferred AI provider and configuration.

      <Button asChild  className="not-markdown">
        <a href="/docs/ready-made-features/ai-copilots/copilots">
          Create a copilot
        </a>
      </Button>
    </StepContent>

  </Step>
</Steps>

## What to read next

Congratulations! Youâ€™ve set up the foundation to start building an AI copilot
experience for your React application.

- [Overview of all features and where to start](/docs/ready-made-features/ai-copilots)
- [@liveblocks/react API reference](/docs/api-reference/liveblocks-react#AI-Copilots)
- [@liveblocks/react-ui API reference](/docs/api-reference/liveblocks-react-ui#AI-Copilots)
- [How to use a fallback AI model](/docs/guides/how-to-use-fallback-ai-models-in-ai-copilots)

---

## Examples using React

<ListGrid columns={2}>
  <ExampleCard
    example={{
      title: "AI Chats",
      slug: "ai-chats/nextjs-ai-chats",
      image: "/images/examples/thumbnails/ai-chats.jpg",
    }}
    technologies={["nextjs", "react"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "AI Reports Dashboard",
      slug: "ai-dashboard-reports/nextjs-ai-dashboard-reports",
      image: "/images/examples/thumbnails/ai-reports-dashboard.jpg",
    }}
    technologies={["nextjs", "react"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "AI Support Chat",
      slug: "ai-support-chat/nextjs-ai-support-chat",
      image: "/images/examples/thumbnails/ai-support.jpg",
    }}
    technologies={["nextjs", "react"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "AI App Builder",
      slug: "ai-app-builder/nextjs-ai-app-builder",
      image: "/images/examples/thumbnails/ai-app-builder.png",
    }}
    technologies={["nextjs"]}
    openInNewWindow
  />
</ListGrid>

---
meta:
  title: "Get started a BlockNote text editor using Liveblocks and React"
  parentTitle: "Quickstart"
  description:
    "Learn how to install a BlockNote text editor using Liveblocks and React"
---

Liveblocks is a realtime collaboration infrastructure for building performant
collaborative experiences. Follow the following steps to start adding
collaboration to your React application using the APIs from the
[`@liveblocks/react-blocknote`](/docs/api-reference/liveblocks-react-blocknote)
package.

## Quickstart

<Steps>
  <Step>
    <StepTitle>Install Liveblocks and BlockNote</StepTitle>
    <StepContent>

      Every Liveblocks package should use the same version.

      ```bash trackEvent="install_liveblocks"
      npm install @liveblocks/client @liveblocks/react @liveblocks/react-ui @liveblocks/react-blocknote @blocknote/core @blocknote/react @blocknote/mantine
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Initialize the `liveblocks.config.ts` file</StepTitle>
    <StepContent>

      We can use this file later to [define types for our application](/docs/api-reference/liveblocks-react#Typing-your-data).

      ```bash
      npx create-liveblocks-app@latest --init --framework react
      ```

    </StepContent>

  </Step>

  <Step>
    <StepTitle>Set up the Liveblocks client</StepTitle>
    <StepContent>

      Liveblocks uses the concept of rooms, separate virtual spaces where people
      collaborate, and to create a realtime experience, multiple users must
      be connected to the same room. Set up a Liveblocks client with [`LiveblocksProvider`](/docs/api-reference/liveblocks-react#LiveblocksProvider), and join a room with [`RoomProvider`](/docs/api-reference/liveblocks-react#RoomProvider).

      ```tsx file="App.tsx" highlight="11-15"
      "use client";

      import {
        LiveblocksProvider,
        RoomProvider,
      } from "@liveblocks/react/suspense";
      import { Editor } from "./Editor";

      export default function App() {
        return (
          <LiveblocksProvider publicApiKey={"{{PUBLIC_KEY}}"}>
            <RoomProvider id="my-room">
              {/* ... */}
            </RoomProvider>
          </LiveblocksProvider>
        );
      }
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Join a Liveblocks room</StepTitle>
    <StepContent>

      After setting up the room, you can add collaborative components inside it, using
      [`ClientSideSuspense`](/docs/api-reference/liveblocks-react#ClientSideSuspense) to add loading spinners to your app.

      ```tsx file="App.tsx" highlight="14-16"
      "use client";

      import {
        LiveblocksProvider,
        RoomProvider,
        ClientSideSuspense,
      } from "@liveblocks/react/suspense";
      import { Editor } from "./Editor";

      export default function App() {
        return (
          <LiveblocksProvider publicApiKey={"{{PUBLIC_KEY}}"}>
            <RoomProvider id="my-room">
              <ClientSideSuspense fallback={<div>Loadingâ€¦</div>}>
                <Editor />
              </ClientSideSuspense>
            </RoomProvider>
          </LiveblocksProvider>
        );
      }
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Set up the collaborative BlockNote text editor</StepTitle>
    <StepContent>

      Now that we set up Liveblocks, we can start integrating BlockNote and Liveblocks in the `Editor.tsx` file.
    To make the editor collaborative, we can add
    [`useCreateBlockNoteWithLiveblocks`](/docs/api-reference/liveblocks-react-blocknote#useCreateBlockNoteWithLiveblocks)
    from `@liveblocks/react-blocknote`.

    ```tsx file="Editor.tsx"
    "use client";

    import { useCreateBlockNoteWithLiveblocks } from "@liveblocks/react-blocknote";
    import { BlockNoteView } from "@blocknote/mantine";
    import { Threads } from "./Threads";

    export function Editor() {
      const editor = useCreateBlockNoteWithLiveblocks({});

      return (
        <div>
          <BlockNoteView editor={editor} className="editor" />
          <Threads editor={editor} />
        </div>
      );
    }
    ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Render threads and composer</StepTitle>
    <StepContent>

     To add [Comments](/docs/ready-made-features/comments) to your text editor, we need to import a thread composer
    and list each thread on the page. Create a `Threads.tsx` file that uses [`FloatingComposer`](/docs/api-reference/liveblocks-react-blocknote#FloatingComposer)
    for creating new threads, alongside [`AnchoredThreads`](/docs/api-reference/liveblocks-react-blocknote#AnchoredThreads) and [`FloatingThreads`](/docs/api-reference/liveblocks-react-blocknote#FloatingThreads) for displaying threads on desktop and mobile.

    ```tsx file="Threads.tsx"
    import { useThreads } from "@liveblocks/react/suspense";
    import {
      AnchoredThreads,
      FloatingComposer,
      FloatingThreads,
    } from "@liveblocks/react-blocknote";
    import { BlockNoteEditor } from "@blocknote/core";

    export function Threads({ editor }: { editor: BlockNoteEditor | null }) {
      const { threads } = useThreads({ query: { resolved: false } });

      if (!editor) {
        return null;
      }

      return (
        <>
          <div className="anchored-threads">
            <AnchoredThreads editor={editor} threads={threads} />
          </div>
          <FloatingThreads
            editor={editor}
            threads={threads}
            className="floating-threads"
          />
          <FloatingComposer editor={editor} className="floating-composer" />
        </>
      );
    }
    ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Style your editor</StepTitle>
    <StepContent>

      We can create some custom styles to position the editor and threadsâ€”import `globals.css`, alongside the default Liveblocks styles. You can import them into the
    root layout of your app or directly into a CSS file with `@import`.

    ```css file="app/globals.css" isCollapsed isCollapsable
    html {
      font-family: Inter, sans-serif;
      background: #f9f9f9;
    }

    @media (prefers-color-scheme: dark) {
      html {
        background: #0c0c0c;
      }
    }

    .editor {
      position: absolute;
      inset: 0;
      max-width: 1024px;
      margin: 0 auto;
      padding: 48px 0;
    }

    .bn-editor {
      padding: 36px 52px;
      min-height: 100%;
    }

    /* For mobile */
    .floating-threads {
      display: none;
    }

    /* For desktop */
    .anchored-threads {
      display: block;
      max-width: 300px;
      width: 100%;
      position: absolute;
      right: 12px;
    }

    @media (max-width: 640px) {
      .floating-threads {
        display: block;
      }

      .anchored-threads {
        display: none;
      }
    }
    ```

    ```tsx file="app/layout.tsx"
    import "@blocknote/core/fonts/inter.css";
    import "@blocknote/mantine/style.css";
    import "@liveblocks/react-ui/styles.css";
    import "@liveblocks/react-ui/styles/dark/media-query.css";
    import "@liveblocks/react-tiptap/styles.css";
    import "./globals.css";
    ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Next: authenticate and add your users</StepTitle>
    <StepContent>
      Text Editor is set up and working now, but each user is anonymousâ€”the next step is to
      authenticate each user as they connect, and attach their name, color, and avatar, to their cursors and mentions.

      <Button asChild  className="not-markdown">
        <a href="/docs/guides/how-to-add-users-to-liveblocks-text-editor">
          Add your users to Text Editor
        </a>
      </Button>
    </StepContent>

  </Step>
   <Step lastStep>
    <StepTitle>Optional: add more features</StepTitle>
    <StepContent>
    BlockNote is easy to extend, and a number of extensions are already available, making it possible to quickly create complex rich-text applications. Any additional features you add will be supported using Liveblocks.

    <Button asChild  className="not-markdown">
      <a href="https://www.blocknotejs.org/docs">
        Read the BlockNote docs
      </a>
    </Button>

  </StepContent>

  </Step>

</Steps>

## What to read next

Congratulations! You now have set up the foundation for your collaborative
BlockNote text editor inside your React application.

- [@liveblocks/react-blocknote API Reference](/docs/api-reference/liveblocks-react-blocknote)
- [BlockNote guides](/docs/guides?technologies=blocknote)
- [BlockNote website](https://www.blocknotejs.org/)

---

## Examples using BlockNote

<ListGrid columns={2}>
  <ExampleCard
    example={{
      title: "Collaborative Text Editor",
      slug: "collaborative-text-editor/nextjs-blocknote",
      image: "/images/examples/thumbnails/text-editor.jpg",
    }}
    technologies={["nextjs"]}
    openInNewWindow
  />
</ListGrid>

---
meta:
  title: "Get started with commenting using Liveblocks and React"
  parentTitle: "Quickstart"
  description:
    "Learn how to add a commenting experience to your application using
    Liveblocks and React"
---

Liveblocks is a realtime collaboration infrastructure for building performant
collaborative experiences. Follow the following steps to start adding a
commenting experience to your React application using the hooks from
[`@liveblocks/react`](/docs/api-reference/liveblocks-react) and the components
from [`@liveblocks/react-ui`](/docs/api-reference/liveblocks-react-ui).

## Quickstart

<Steps>
  <Step>
    <StepTitle>Install Liveblocks</StepTitle>
    <StepContent>

      Every package should use the same version.

      ```bash trackEvent="install_liveblocks"
      npm install @liveblocks/client @liveblocks/react @liveblocks/react-ui
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Initialize the `liveblocks.config.ts` file</StepTitle>
    <StepContent>

      We can use this file later to [define types for our application](/docs/api-reference/liveblocks-react#Typing-your-data).

      ```bash
      npx create-liveblocks-app@latest --init --framework react
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Set up the Liveblocks client</StepTitle>
    <StepContent>

      Liveblocks uses the concept of rooms, separate virtual spaces where people
      collaborate, and to create a realtime experience, multiple users must
      be connected to the same room. Set up a Liveblocks client with [`LiveblocksProvider`](/docs/api-reference/liveblocks-react#LiveblocksProvider), and join a room with [`RoomProvider`](/docs/api-reference/liveblocks-react#RoomProvider).

      ```tsx file="App.tsx" highlight="11-15"
      "use client";

      import {
        LiveblocksProvider,
        RoomProvider,
      } from "@liveblocks/react/suspense";
      import { Room } from "./Room";

      export default function App() {
        return (
          <LiveblocksProvider publicApiKey={"{{PUBLIC_KEY}}"}>
            <RoomProvider id="my-room">
              {/* ... */}
            </RoomProvider>
          </LiveblocksProvider>
        );
      }
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Join a Liveblocks room</StepTitle>
    <StepContent>

      After setting up the room, you can add collaborative components inside it, using
      [`ClientSideSuspense`](/docs/api-reference/liveblocks-react#ClientSideSuspense) to add loading spinners to your app.

      ```tsx file="App.tsx" highlight="14-16"
      "use client";

      import {
        LiveblocksProvider,
        RoomProvider,
        ClientSideSuspense,
      } from "@liveblocks/react/suspense";
      import { Room } from "./Room";

      export default function App() {
        return (
          <LiveblocksProvider publicApiKey={"{{PUBLIC_KEY}}"}>
            <RoomProvider id="my-room">
              <ClientSideSuspense fallback={<div>Loadingâ€¦</div>}>
                <Room />
              </ClientSideSuspense>
            </RoomProvider>
          </LiveblocksProvider>
        );
      }
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Use the Liveblocks hooks and components</StepTitle>
    <StepContent>

      Now that weâ€™re connected to a room, we can start using the Liveblocks hooks and components.
      Weâ€™ll add [`useThreads`](/docs/api-reference/liveblocks-react#useThreads) to get the threads in the room, then weâ€™ll use the [`Thread`](/docs/api-reference/liveblocks-react-ui#Thread) component
      to render them. Finally, weâ€™ll add a way to create threads by adding a [`Composer`](/docs/api-reference/liveblocks-react-ui#Composer).

      ```tsx file="Room.tsx" highlight="7,11-14"
      "use client";

      import { useThreads } from "@liveblocks/react/suspense";
      import { Composer, Thread } from "@liveblocks/react-ui";

      export function Room() {
        const { threads } = useThreads();

        return (
          <div>
            {threads.map((thread) => (
              <Thread key={thread.id} thread={thread} />
            ))}
            <Composer />
          </div>
        );
      }
      ```

    </StepContent>

  </Step>
   <Step>
    <StepTitle>Import default styles</StepTitle>
    <StepContent>

    The default components come with default styles, you can import them into the
    root of your app or directly into a CSS file with `@import`.

    ```tsx
    import "@liveblocks/react-ui/styles.css";
    ```

    </StepContent>

  </Step>
  <Step lastStep>
    <StepTitle>Next: authenticate and add your users</StepTitle>
    <StepContent>

      Comments is set up and working now, but each user is anonymousâ€”the next step is to
      authenticate each user as they connect, and attach their name and avatar to their comments.

      <Button asChild className="not-markdown">
        <a href="/docs/guides/how-to-add-users-to-liveblocks-comments">
          Add your users to Comments
        </a>
      </Button>
    </StepContent>

  </Step>
</Steps>

## What to read next

Congratulations! Youâ€™ve set up the foundation to start building a commenting
experience for your React application.

- [API Reference](/docs/api-reference/liveblocks-react-ui)
- [How to send email notifications when comments are created](/docs/guides/how-to-send-email-notifications-when-comments-are-created)

---

## Examples using React

<ListGrid columns={2}>
  <ExampleCard
    example={{
      title: "Comments",
      slug: "comments/react-comments",
      image: "/images/examples/thumbnails/comments.jpg",
    }}
    technologies={["nextjs", "react"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Video Comments",
      slug: "video-comments/nextjs-comments-video",
      image: "/images/examples/thumbnails/comments-video.png",
    }}
    technologies={["nextjs"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Overlay Comments",
      slug: "overlay-comments/nextjs-comments-overlay",
      image: "/images/examples/thumbnails/comments-overlay.png",
    }}
    technologies={["nextjs"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Text Editor Comments",
      slug: "text-editor-comments/nextjs-comments-tiptap",
      image: "/images/examples/thumbnails/comments-text-editor.png",
    }}
    technologies={["nextjs"]}
    openInNewWindow
  />
</ListGrid>

---
meta:
  title: "Get started with a Lexical text editor using Liveblocks and React"
  parentTitle: "Quickstart"
  description:
    "Learn how to install a Lexical text editor using Liveblocks and React"
---

Liveblocks is a realtime collaboration infrastructure for building performant
collaborative experiences. Follow the following steps to start adding
collaboration to your React application using the APIs from the
[`@liveblocks/react-lexical`](/docs/api-reference/liveblocks-react-lexical)
package.

## Quickstart

<Steps>
  <Step>
    <StepTitle>Install Liveblocks and Lexical</StepTitle>
    <StepContent>

      Every Liveblocks package should use the same version.

      ```bash trackEvent="install_liveblocks"
      npm install @liveblocks/client @liveblocks/react @liveblocks/react-ui @liveblocks/react-lexical lexical @lexical/react
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Initialize the `liveblocks.config.ts` file</StepTitle>
    <StepContent>

      We can use this file later to [define types for our application](/docs/api-reference/liveblocks-react#Typing-your-data).

      ```bash
      npx create-liveblocks-app@latest --init --framework react
      ```

    </StepContent>

  </Step>

  <Step>
    <StepTitle>Set up the Liveblocks client</StepTitle>
    <StepContent>

      Liveblocks uses the concept of rooms, separate virtual spaces where people
      collaborate, and to create a realtime experience, multiple users must
      be connected to the same room. Set up a Liveblocks client with [`LiveblocksProvider`](/docs/api-reference/liveblocks-react#LiveblocksProvider), and join a room with [`RoomProvider`](/docs/api-reference/liveblocks-react#RoomProvider).

      ```tsx file="App.tsx" highlight="11-15"
      "use client";

      import {
        LiveblocksProvider,
        RoomProvider,
      } from "@liveblocks/react/suspense";
      import { Editor } from "./Editor";

      export default function App() {
        return (
          <LiveblocksProvider publicApiKey={"{{PUBLIC_KEY}}"}>
            <RoomProvider id="my-room">
              {/* ... */}
            </RoomProvider>
          </LiveblocksProvider>
        );
      }
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Join a Liveblocks room</StepTitle>
    <StepContent>

      After setting up the room, you can add collaborative components inside it, using
      [`ClientSideSuspense`](/docs/api-reference/liveblocks-react#ClientSideSuspense) to add loading spinners to your app.

      ```tsx file="App.tsx" highlight="14-16"
      "use client";

      import {
        LiveblocksProvider,
        RoomProvider,
        ClientSideSuspense,
      } from "@liveblocks/react/suspense";
      import { Editor } from "./Editor";

      export default function App() {
        return (
          <LiveblocksProvider publicApiKey={"{{PUBLIC_KEY}}"}>
            <RoomProvider id="my-room">
              <ClientSideSuspense fallback={<div>Loadingâ€¦</div>}>
                <Editor />
              </ClientSideSuspense>
            </RoomProvider>
          </LiveblocksProvider>
        );
      }
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Set up the collaborative Lexical text editor</StepTitle>
    <StepContent>

      Now that we set up Liveblocks, we can start integrating Lexical and Liveblocks in the `Editor.tsx` file.
      To make the editor collaborative, we can use
      [`LiveblocksPlugin`](/docs/api-reference/liveblocks-react-lexical#LiveblocksPlugin)
      from `@liveblocks/react-lexical`. [`FloatingToolbar`](/docs/api-reference/liveblocks-react-lexical#FloatingToolbar)
      adds a text selection toolbar.


      ```tsx file="Editor.tsx"
      "use client";

      import { LexicalComposer } from "@lexical/react/LexicalComposer";
      import { RichTextPlugin } from "@lexical/react/LexicalRichTextPlugin";
      import { ContentEditable } from "@lexical/react/LexicalContentEditable";
      import { LexicalErrorBoundary } from "@lexical/react/LexicalErrorBoundary";
      import {
        liveblocksConfig,
        LiveblocksPlugin,
        FloatingToolbar,
      } from "@liveblocks/react-lexical";
      import { Threads } from "./Threads";

      export function Editor() {
        // Wrap your Lexical config with `liveblocksConfig`
        const initialConfig = liveblocksConfig({
          namespace: "Demo",
          onError: (error: unknown) => {
            console.error(error);
            throw error;
          },
        });

        return (
          <LexicalComposer initialConfig={initialConfig}>
            <div className="editor">
              <RichTextPlugin
                contentEditable={<ContentEditable />}
                placeholder={<div className="placeholder">Start typing hereâ€¦</div>}
                ErrorBoundary={LexicalErrorBoundary}
              />
              <LiveblocksPlugin>
                <Threads />
                <FloatingToolbar />
              </LiveblocksPlugin>
            </div>
          </LexicalComposer>
        );
      }
      ```
    </StepContent>

  </Step>
  <Step>
    <StepTitle>Render threads and composer</StepTitle>
    <StepContent>

      To add [Comments](/docs/ready-made-features/comments) to your text editor, we need to import a thread composer
      and list each thread on the page. Create a `Threads.tsx` file that uses [`FloatingComposer`](/docs/api-reference/liveblocks-react-lexical#FloatingComposer)
      for creating new threads, alongside [`AnchoredThreads`](/docs/api-reference/liveblocks-react-lexical#AnchoredThreads) and [`FloatingThreads`](/docs/api-reference/liveblocks-react-lexical#FloatingThreads) for displaying threads on desktop and mobile.

      ```tsx file="Threads.tsx"
      "use client";

      import { useThreads } from "@liveblocks/react/suspense";
      import {
        AnchoredThreads,
        FloatingComposer,
        FloatingThreads,
      } from "@liveblocks/react-lexical";

      export function Threads() {
        const { threads } = useThreads();

        return (
          <>
            <div className="anchored-threads">
              <AnchoredThreads threads={threads} />
            </div>
            <FloatingThreads className="floating-threads" threads={threads} />
            <FloatingComposer className="floating-composer" />
          </>
        );
      }
      ```
    </StepContent>

  </Step>
  <Step>
    <StepTitle>Style your editor</StepTitle>
    <StepContent>

      Lexical text editor is unstyled by default, so we can create some custom styles for it in a `globals.css` file. Import `globals.css`, alongside the default Liveblocks styles. You can import them into the
      root layout of your app or directly into a CSS file with `@import`.

      ```css file="globals.css" isCollapsed isCollapsable
      .editor {
        position: relative;
        display: flex;
        width: 100%;
        height: 100%;
      }

      [data-lexical-editor] {
        padding: 2px 12px;
        outline: none;
      }

      [data-lexical-editor] p {
        margin: 0.8em 0;
      }

      /* For mobile */
      .floating-threads {
        display: none;
      }

      /* For desktop */
      .anchored-threads {
        display: block;
        max-width: 300px;
        width: 100%;
        position: absolute;
        right: 4px;
      }

      @media (max-width: 640px) {
        .floating-threads {
          display: block;
        }

        .anchored-threads {
          display: none;
        }
      }

      .placeholder {
        position: absolute;
        left: 12px;
        top: 16px;
        pointer-events: none;
        opacity: 0.5;
      }
      ```

      ```tsx
      import "@liveblocks/react-ui/styles.css";
      import "@liveblocks/react-lexical/styles.css";
      import "./globals.css";
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Next: authenticate and add your users</StepTitle>
    <StepContent>
      Text Editor is set up and working now, but each user is anonymousâ€”the next step is to
      authenticate each user as they connect, and attach their name, color, and avatar, to their cursors and mentions.

      <Button asChild  className="not-markdown">
        <a href="/docs/guides/how-to-add-users-to-liveblocks-text-editor">
          Add your users to Text Editor
        </a>
      </Button>
    </StepContent>

  </Step>
   <Step lastStep>
    <StepTitle>Optional: add more features</StepTitle>
    <StepContent>
      Lexical is a highly extensible text editor and it's possible to create complex rich-text applications.
      A great example is in the [Lexical playground](https://playground.lexical.dev/) which enables features
      such as tables, text highlights, embedded images, and more. This is all supported using Liveblocks.

      <Button asChild  className="not-markdown">
        <a href="https://lexical.dev/docs/intro">
          Learn more about Lexical
        </a>
      </Button>
    </StepContent>

  </Step>

</Steps>

## What to read next

Congratulations! You now have set up the foundation for your collaborative
Lexical text editor inside your React application.

- [Overview](/docs/ready-made-features/text-editor/lexical)
- [`@liveblocks/react-lexical` API Reference](/docs/api-reference/liveblocks-react-lexical)
- [`@liveblocks/node-lexical` API Reference](/docs/api-reference/liveblocks-node-lexical)
- [Lexical website](https://lexical.dev/)

---

## Examples using Lexical

<ListGrid columns={2}>
  <ExampleCard
    example={{
      title: "Collaborative Text Editor",
      slug: "collaborative-text-editor/nextjs-lexical",
      image: "/images/examples/thumbnails/text-editor.jpg",
    }}
    technologies={["nextjs"]}
    openInNewWindow
  />
</ListGrid>

---
meta:
  title:
    "Get started with an in-app notification inbox using Liveblocks and React"
  parentTitle: "Quickstart"
  description:
    "Learn how to add an in-app notification inbox using Liveblocks and React"
---

Liveblocks is a realtime collaboration infrastructure for building performant
collaborative experiences. Follow the following steps to start adding
notifications to your application using the hooks from
[`@liveblocks/react`](/docs/api-reference/liveblocks-react) and the components
from [`@liveblocks/react-ui`](/docs/api-reference/liveblocks-react-ui).

## Quickstart

<Steps>
  <Step>
    <StepTitle>Install Liveblocks</StepTitle>
    <StepContent>

      Every package should use the same version.

      ```bash trackEvent="install_liveblocks"
      npm install @liveblocks/client @liveblocks/react @liveblocks/react-ui
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Initialize the `liveblocks.config.ts` file</StepTitle>
    <StepContent>

      We can use this file later to [define types for our application](/docs/api-reference/liveblocks-react#Typing-your-data).

      ```bash
      npx create-liveblocks-app@latest --init --framework react
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Set up the Liveblocks client</StepTitle>
    <StepContent>

      Liveblocks Notifications uses the concept of projects, which relate to
      projects in [your dashboard](/dashboard). Notifications are sent between
      users in the same project. To connect and receive notifications, you must
      add [`LiveblocksProvider`](/docs/api-reference/liveblocks-react#LiveblocksProvider)
      to a client component in your app.

      ```tsx file="App.tsx"
      "use client";

      import { LiveblocksProvider } from "@liveblocks/react/suspense";
      import { MyApp } from "./MyApp";

      export default function App() {
        return (
          // +++
          <LiveblocksProvider publicApiKey={"{{PUBLIC_KEY}}"}>
            <MyApp />
          </LiveblocksProvider>
          // +++
        );
      }
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Use the Liveblocks hooks and components</StepTitle>
    <StepContent>

      Now that weâ€™ve set up the provider, we can start using the Liveblocks hooks and components.
      Weâ€™ll add [`useInboxNotifications`](/docs/api-reference/liveblocks-react#useInboxNotifications)
      to get the current projectâ€™s notifications, then weâ€™ll
      use [`InboxNotification`](/docs/api-reference/liveblocks-react-ui#InboxNotification) and [`InboxNotificationList`](/docs/api-reference/liveblocks-react-ui#InboxNotificationList) to render them.

      ```tsx file="app/MyApp.tsx"
      "use client";

      import { useInboxNotifications } from "@liveblocks/react/suspense";
      import {
        InboxNotification,
        InboxNotificationList,
      } from "@liveblocks/react-ui";

      export function MyApp() {
        // +++
        const { inboxNotifications } = useInboxNotifications();
        // +++

        return (
          // +++
          <InboxNotificationList>
            {inboxNotifications.map((inboxNotification) => (
              <InboxNotification
                key={inboxNotification.id}
                inboxNotification={inboxNotification}
              />
            ))}
          </InboxNotificationList>
          // +++
        );
      }
      ```

    </StepContent>

  </Step>
   <Step>
    <StepTitle>Import default styles</StepTitle>
    <StepContent>

    The default components come with default styles, you can import them into the
    root of your app or directly into a CSS file with `@import`.

    ```tsx
    import "@liveblocks/react-ui/styles.css";
    ```

    </StepContent>

  </Step>
  <Step lastStep>
    <StepTitle>Next: authenticate and add your users</StepTitle>
    <StepContent>

      Notifications is set up and working now, but each user is anonymousâ€”the next step is to
      authenticate each user as they connect, and attach their name and avatar to their notifications.

      <Button asChild className="not-markdown">
        <a href="/docs/guides/how-to-add-users-to-liveblocks-notifications">
          Add your users to Notifications
        </a>
      </Button>
    </StepContent>

  </Step>
</Steps>

## What to read next

Congratulations! Youâ€™ve set up the foundation to start building a notifications
experience for your React application.

- [API reference](/docs/api-reference/liveblocks-react#Notifications)
- [Component reference](/docs/api-reference/liveblocks-react-ui#Notifications)

---

## Examples using Notifications

<ListGrid columns={2}>
  <ExampleCard
    example={{
      title: "Comments notifications",
      slug: "comments-notifications/nextjs-comments-notifications",
      image: "/images/examples/thumbnails/comments-notifications.png",
    }}
    technologies={["nextjs", "react"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Custom notifications",
      slug: "notifications-custom/nextjs-notifications-custom",
      image: "/images/examples/thumbnails/custom-notifications.png",
    }}
    technologies={["nextjs", "react"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Notification settings",
      slug: "notification-settings/nextjs-notification-settings",
      image: "/images/examples/thumbnails/notification-settings.png",
    }}
    technologies={["nextjs", "react"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Notion-like AI Editor",
      slug: "notion-like-ai-editor/nextjs-notion-like-ai-editor",
      image: "/images/examples/thumbnails/notion-like-ai-editor.png",
    }}
    technologies={["nextjs", "react"]}
    openInNewWindow
  />
</ListGrid>

---
meta:
  title: "Get started with a Tiptap text editor using Liveblocks and React"
  parentTitle: "Quickstart"
  description:
    "Learn how to install a Tiptap text editor using Liveblocks and React"
---

Liveblocks is a realtime collaboration infrastructure for building performant
collaborative experiences. Follow the following steps to start adding
collaboration to your React application using the APIs from the
[`@liveblocks/react-tiptap`](/docs/api-reference/liveblocks-react-tiptap)
package.

## Quickstart

<Steps>
  <Step>
    <StepTitle>Install Liveblocks and Tiptap</StepTitle>
    <StepContent>

      Every Liveblocks package should use the same version.

      ```bash trackEvent="install_liveblocks"
      npm install @liveblocks/client @liveblocks/react @liveblocks/react-ui @liveblocks/react-tiptap @tiptap/react @tiptap/starter-kit
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Initialize the `liveblocks.config.ts` file</StepTitle>
    <StepContent>

      We can use this file later to [define types for our application](/docs/api-reference/liveblocks-react#Typing-your-data).

      ```bash
      npx create-liveblocks-app@latest --init --framework react
      ```

    </StepContent>

  </Step>

  <Step>
    <StepTitle>Set up the Liveblocks client</StepTitle>
    <StepContent>

      Liveblocks uses the concept of rooms, separate virtual spaces where people
      collaborate, and to create a realtime experience, multiple users must
      be connected to the same room. Set up a Liveblocks client with [`LiveblocksProvider`](/docs/api-reference/liveblocks-react#LiveblocksProvider), and join a room with [`RoomProvider`](/docs/api-reference/liveblocks-react#RoomProvider).

      ```tsx file="App.tsx" highlight="11-15"
      "use client";

      import {
        LiveblocksProvider,
        RoomProvider,
      } from "@liveblocks/react/suspense";
      import { Editor } from "./Editor";

      export default function App() {
        return (
          <LiveblocksProvider publicApiKey={"{{PUBLIC_KEY}}"}>
            <RoomProvider id="my-room">
              {/* ... */}
            </RoomProvider>
          </LiveblocksProvider>
        );
      }
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Join a Liveblocks room</StepTitle>
    <StepContent>

      After setting up the room, you can add collaborative components inside it, using
      [`ClientSideSuspense`](/docs/api-reference/liveblocks-react#ClientSideSuspense) to add loading spinners to your app.

      ```tsx file="App.tsx" highlight="14-16"
      "use client";

      import {
        LiveblocksProvider,
        RoomProvider,
        ClientSideSuspense,
      } from "@liveblocks/react/suspense";
      import { Editor } from "./Editor";

      export default function App() {
        return (
          <LiveblocksProvider publicApiKey={"{{PUBLIC_KEY}}"}>
            <RoomProvider id="my-room">
              <ClientSideSuspense fallback={<div>Loadingâ€¦</div>}>
                <Editor />
              </ClientSideSuspense>
            </RoomProvider>
          </LiveblocksProvider>
        );
      }
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Set up the collaborative Tiptap text editor</StepTitle>
    <StepContent>

      Now that we set up Liveblocks, we can start integrating Tiptap and Liveblocks in the `Editor.tsx` file.
    To make the editor collaborative, we can add
    [`useLiveblocksExtension`](/docs/api-reference/liveblocks-react-tiptap#useLiveblocksExtension)
    from `@liveblocks/react-tiptap`. [`FloatingToolbar`](/docs/api-reference/liveblocks-react-tiptap#FloatingToolbar)
      adds a text selection toolbar.

    ```tsx file="Editor.tsx"
    "use client";

    import { useLiveblocksExtension, FloatingToolbar } from "@liveblocks/react-tiptap";
    import { useEditor, EditorContent } from "@tiptap/react";
    import StarterKit from "@tiptap/starter-kit";
    import { Threads } from "./Threads";

    export function Editor() {
      const liveblocks = useLiveblocksExtension();

      const editor = useEditor({
        extensions: [
          liveblocks,
          StarterKit.configure({
            // The Liveblocks extension comes with its own history handling
            undoRedo: false,
          }),
        ],
      });

      return (
        <div>
          <EditorContent editor={editor} className="editor" />
          <Threads editor={editor} />
          <FloatingToolbar editor={editor} />
        </div>
      );
    }
    ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Render threads and composer</StepTitle>
    <StepContent>

     To add [Comments](/docs/ready-made-features/comments) to your text editor, we need to import a thread composer
    and list each thread on the page. Create a `Threads.tsx` file that uses [`FloatingComposer`](/docs/api-reference/liveblocks-react-tiptap#FloatingComposer)
    for creating new threads, alongside [`AnchoredThreads`](/docs/api-reference/liveblocks-react-tiptap#AnchoredThreads) and [`FloatingThreads`](/docs/api-reference/liveblocks-react-tiptap#FloatingThreads) for displaying threads on desktop and mobile.

    ```tsx file="Threads.tsx"
    import { useThreads } from "@liveblocks/react/suspense";
    import {
      AnchoredThreads,
      FloatingComposer,
      FloatingThreads,
    } from "@liveblocks/react-tiptap";
    import { Editor } from "@tiptap/react";

    export function Threads({ editor }: { editor: Editor | null }) {
      const { threads } = useThreads({ query: { resolved: false } });

      return (
        <>
          <div className="anchored-threads">
            <AnchoredThreads editor={editor} threads={threads} />
          </div>
          <FloatingThreads
            editor={editor}
            threads={threads}
            className="floating-threads"
          />
          <FloatingComposer editor={editor} className="floating-composer" />
        </>
      );
    }
    ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Style your editor</StepTitle>
    <StepContent>

      Tiptap text editor is unstyled by default, so we can create some custom styles for it in a `globals.css` file. Import `globals.css`, alongside the default Liveblocks styles. You can import them into the
    root layout of your app or directly into a CSS file with `@import`.

    ```css file="app/globals.css" isCollapsed isCollapsable
    .editor {
      position: relative;
      display: flex;
      width: 100%;
      height: 100%;
    }

    .tiptap {
      padding: 2px 12px;
      outline: none;
      width: 100%;
    }

    /* For mobile */
    .floating-threads {
      display: none;
    }

    /* For desktop */
    .anchored-threads {
      display: block;
      max-width: 300px;
      width: 100%;
      position: absolute;
      right: 12px;
    }

    @media (max-width: 640px) {
      .floating-threads {
        display: block;
      }

      .anchored-threads {
        display: none;
      }
    }
    ```

    ```tsx file="app/layout.tsx"
    import "@liveblocks/react-ui/styles.css";
    import "@liveblocks/react-tiptap/styles.css";
    import "./globals.css";
    ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Next: authenticate and add your users</StepTitle>
    <StepContent>
      Text Editor is set up and working now, but each user is anonymousâ€”the next step is to
      authenticate each user as they connect, and attach their name, color, and avatar, to their cursors and mentions.

      <Button asChild  className="not-markdown">
        <a href="/docs/guides/how-to-add-users-to-liveblocks-text-editor">
          Add your users to Text Editor
        </a>
      </Button>
    </StepContent>

  </Step>
   <Step lastStep>
    <StepTitle>Optional: add more features</StepTitle>
    <StepContent>
      Tiptap is easy to extend, and a number of extensions are already available, making it possible to quickly create complex rich-text applications. For example you can enable features
    such as tables, text highlights, embedded images, and more. This is all supported using Liveblocks.

    <Button asChild  className="not-markdown">
      <a href="https://tiptap.dev/docs/editor/extensions/overview">
        Find more extensions
      </a>
    </Button>

    </StepContent>

  </Step>

</Steps>

## What to read next

Congratulations! You now have set up the foundation for your collaborative
Tiptap text editor inside your React application.

- [@liveblocks/react-tiptap API Reference](/docs/api-reference/liveblocks-react-tiptap)
- [Tiptap guides](/docs/guides?technologies=tiptap)
- [Tiptap website](https://tiptap.dev)

---

## Examples using Tiptap

<ListGrid columns={2}>
  <ExampleCard
    example={{
      title: "Collaborative Text Editor",
      slug: "collaborative-text-editor/nextjs-tiptap",
      image: "/images/examples/thumbnails/text-editor.jpg",
    }}
    technologies={["nextjs"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Advanced Collaborative Text Editor",
      slug: "collaborative-text-editor-advanced/nextjs-tiptap-advanced",
      image: "/images/examples/thumbnails/text-editor-advanced.jpg",
    }}
    technologies={["nextjs"]}
    openInNewWindow
  />
</ListGrid>

---
meta:
  title: "Get started with Liveblocks and React"
  parentTitle: "Quickstart"
  description: "Learn how to get started with Liveblocks and React"
---

Liveblocks is a realtime collaboration infrastructure for building performant
collaborative experiences. Follow the following steps to start adding
collaboration to your React application using the hooks from the
[`@liveblocks/react`](/docs/api-reference/liveblocks-react) package.

## Quickstart

<Steps>
  <Step>
    <StepTitle>Install Liveblocks</StepTitle>
    <StepContent>

      Every package should use the same version.

      ```bash trackEvent="install_liveblocks"
      npm install @liveblocks/client @liveblocks/react
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Initialize the `liveblocks.config.ts` file</StepTitle>
    <StepContent>

      We can use this file later to [define types for our application](/docs/api-reference/liveblocks-react#Typing-your-data).

      ```bash
      npx create-liveblocks-app@latest --init --framework react
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Set up the Liveblocks client</StepTitle>
    <StepContent>

      Liveblocks uses the concept of rooms, separate virtual spaces where people
      collaborate, and to create a realtime experience, multiple users must
      be connected to the same room. Set up a Liveblocks client with [`LiveblocksProvider`](/docs/api-reference/liveblocks-react#LiveblocksProvider), and join a room with [`RoomProvider`](/docs/api-reference/liveblocks-react#RoomProvider).

      ```tsx file="App.tsx" highlight="11-15"
      "use client";

      import {
        LiveblocksProvider,
        RoomProvider,
      } from "@liveblocks/react/suspense";
      import { Room } from "./Room";

      export default function App() {
        return (
          <LiveblocksProvider publicApiKey={"{{PUBLIC_KEY}}"}>
            <RoomProvider id="my-room">
              {/* ... */}
            </RoomProvider>
          </LiveblocksProvider>
        );
      }
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Join a Liveblocks room</StepTitle>
    <StepContent>

      After setting up the room, you can add collaborative components inside it, using
      [`ClientSideSuspense`](/docs/api-reference/liveblocks-react#ClientSideSuspense) to add loading spinners to your app.

      ```tsx file="App.tsx" highlight="14-16"
      "use client";

      import {
        LiveblocksProvider,
        RoomProvider,
        ClientSideSuspense,
      } from "@liveblocks/react/suspense";
      import { Room } from "./Room";

      export default function App() {
        return (
          <LiveblocksProvider publicApiKey={"{{PUBLIC_KEY}}"}>
            <RoomProvider id="my-room">
              <ClientSideSuspense fallback={<div>Loadingâ€¦</div>}>
                <Room />
              </ClientSideSuspense>
            </RoomProvider>
          </LiveblocksProvider>
        );
      }
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Use the Liveblocks hooks</StepTitle>
    <StepContent>

      Now that weâ€™re connected to a room, we can start using the Liveblocks hooks.
      The first weâ€™ll add is [`useOthers`](/docs/api-reference/liveblocks-react#useOthers), a hook that provides information about
      which other users are connected to the room.

      ```tsx file="Room.tsx" highlight="6"
      "use client";

      import { useOthers } from "./liveblocks.config";

      export function Room() {
        const others = useOthers();
        const userCount = others.length;

        return <div>There are {userCount} other user(s) online</div>;
      }
      ```

    </StepContent>

  </Step>
  <Step lastStep>
    <StepTitle>Next: set up authentication</StepTitle>
    <StepContent>

      By default, Liveblocks is configured to work without an authentication endpoint
      where everyone automatically has access to rooms. This approach is great for
      prototyping and marketing pages where setting up your own security isnâ€™t always
      required. If you want to limit access to a room for certain users, youâ€™ll need
      to set up an authentication endpoint to enable permissions.

      <Button asChild className="not-markdown">
        <a href="/docs/authentication">
          Set up authentication
        </a>
      </Button>
    </StepContent>

  </Step>
</Steps>

## What to read next

Congratulations! You now have set up the foundation to start building
collaborative experiences for your React application.

- [@liveblocks/react API Reference](/docs/api-reference/liveblocks-react)
- [React guides](/docs/guides?technologies=react)
- [How to use Liveblocks Presence with React](/docs/guides/how-to-use-liveblocks-presence-with-react)
- [How to use Liveblocks Storage with React](/docs/guides/how-to-use-liveblocks-storage-with-react)

---

## Examples using React

<ListGrid columns={2}>
  <ExampleCard
    example={{
      title: "Collaborative To-do List",
      slug: "collaborative-todo-list/nextjs-todo-list",
      image: "/images/examples/thumbnails/collaborative-todo-list.jpg",
    }}
    technologies={["nextjs", "vuejs", "sveltekit", "solidjs", "javascript"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Live Avatar Stack",
      slug: "live-avatar-stack/nextjs-live-avatars",
      image: "/images/examples/thumbnails/live-avatar-stack.jpg",
    }}
    technologies={["nextjs", "nuxtjs", "vuejs", "sveltekit", "solidjs"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Collaborative Spreadsheet",
      slug: "collaborative-spreadsheet-advanced/nextjs-spreadsheet-advanced",
      image:
        "/images/examples/thumbnails/collaborative-spreadsheet-advanced.jpg",
      advanced: true,
    }}
    technologies={["nextjs"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Collaborative Whiteboard",
      slug: "collaborative-whiteboard-advanced/nextjs-whiteboard-advanced",
      image:
        "/images/examples/thumbnails/collaborative-whiteboard-advanced.jpg",
      advanced: true,
    }}
    technologies={["nextjs"]}
    openInNewWindow
  />
</ListGrid>

---
meta:
  title: "Get started with Liveblocks and Redux"
  parentTitle: "Quickstart"
  description: "Learn how to get started with Liveblocks and Redux"
---

Liveblocks is a realtime collaboration infrastructure for building performant
collaborative experiences. Follow the following steps to start making your Redux
state multiplayer by using the
[store enhancer](https://redux.js.org/understanding/thinking-in-redux/glossary#store-enhancer)
from the [`@liveblocks/redux`](/docs/api-reference/liveblocks-redux) package.

## Quickstart

<Steps>
  <Step>
    <StepTitle>Install Liveblocks</StepTitle>
    <StepContent>

      Every package should use the same version.

      ```bash trackEvent="install_liveblocks"
      npm install @liveblocks/client @liveblocks/redux
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Initialize the `liveblocks.config.ts` file</StepTitle>
    <StepContent>

      We can use this file later to [define types for our application](/docs/api-reference/liveblocks-react#Typing-your-data).

      ```bash
      npx create-liveblocks-app@latest --init --framework react
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Connect your Redux store to Liveblocks</StepTitle>
    <StepContent>

      Create the Liveblocks client and use the
      `liveblocksEnhancer` in your Redux store setup. This will
      add a new state called `liveblocks` to your store, enabling
      you to interact with our Presence and Storage APIs.

      ```ts file="store.ts" highlight="7-9,24-25"
      "use client";

      import { createClient } from "@liveblocks/client";
      import { liveblocksEnhancer } from "@liveblocks/redux";
      import { configureStore, createSlice } from "@reduxjs/toolkit";

      const client = createClient({
        publicApiKey: "pk_prod_xxxxxxxxxxxxxxxxxxxxxxxx",
      });

      const initialState = {};

      const slice = createSlice({
        name: "state",
        initialState,
        reducers: {
          /* logic will be added here */
        },
      });

      function makeStore() {
        return configureStore({
          reducer: slice.reducer,
          enhancers: (getDefaultEnhancers) =>
            getDefaultEnhancers().concat(liveblocksEnhancer({ client })),
        });
      }

      const store = makeStore();

      export default store;
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Join a Liveblocks room</StepTitle>
    <StepContent>

      Liveblocks uses the concept of rooms, separate virtual spaces where people collaborate.
      To create a realtime experience, multiple users must be connected to the same room.

      ```tsx file="App.tsx" highlight="5,11,14"
      "use client";

      import { useEffect } from "react";
      import { useDispatch } from "react-redux";
      import { actions } from "@liveblocks/redux";

      export default function App() {
        const dispatch = useDispatch();

        useEffect(() => {
          dispatch(actions.enterRoom("room-id"));

          return () => {
            dispatch(actions.leaveRoom("room-id"));
          };
        }, [dispatch]);

        return <Room />;
      }
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Use the Liveblocks data from the store</StepTitle>
    <StepContent>

      Now that weâ€™re connected to a room, we can start using the Liveblocks data from the Redux store.

      ```tsx file="Room.tsx" highlight="6"
      "use client";

      import { useSelector } from "react-redux";

      export function Room() {
        const others = useSelector((state) => state.liveblocks.others);
        const userCount = others.length;
        return <div>There are {userCount} other user(s) online</div>;
      }
      ```

    </StepContent>

  </Step>
  <Step lastStep>
    <StepTitle>Next: set up authentication</StepTitle>
    <StepContent>

      By default, Liveblocks is configured to work without an authentication endpoint
      where everyone automatically has access to rooms. This approach is great for
      prototyping and marketing pages where setting up your own security isnâ€™t always
      required. If you want to limit access to a room for certain users, youâ€™ll need
      to set up an authentication endpoint to enable permissions.

      <Button asChild className="not-markdown">
        <a href="/docs/authentication">
          Set up authentication
        </a>
      </Button>
    </StepContent>

  </Step>
</Steps>

## What to read next

Congratulations! You now have set up the foundation to start building
collaborative experiences for your Redux store.

- [@liveblocks/redux API Reference](/docs/api-reference/liveblocks-redux)
- [Redux guides](/docs/guides?technologies=redux)
- [How to create a collaborative online whiteboard with Redux](/docs/guides/how-to-create-a-collaborative-online-whiteboard-with-react-redux-and-liveblocks)
- [How to create a collaborative to-do list with Redux](/docs/guides/how-to-create-a-collaborative-to-do-list-with-react-redux-and-liveblocks)

---

## Examples using Redux

<ListGrid columns={2}>
  <ExampleCard
    example={{
      title: "Collaborative To-do List",
      slug: "collaborative-todo-list/redux-todo-list",
      image: "/images/examples/thumbnails/collaborative-todo-list.jpg",
    }}
    technologies={["nextjs", "vuejs", "sveltekit", "solidjs", "javascript"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Collaborative Whiteboard",
      slug: "collaborative-whiteboard/redux-whiteboard",
      image: "/images/examples/thumbnails/collaborative-whiteboard.jpg",
      advanced: true,
    }}
    technologies={["nextjs", "redux", "zustand"]}
    openInNewWindow
  />
</ListGrid>

---
meta:
  title: "Get started with Liveblocks and SolidJS"
  parentTitle: "Quickstart"
  description: "Learn how to get started with Liveblocks and SolidJS"
---

Liveblocks is a realtime collaboration infrastructure for building performant
collaborative experiences. Follow the following steps to start adding
collaboration to your SolidJS application using the APIs from the
[`@liveblocks/client`](/docs/api-reference/liveblocks-client) package.

<Banner title="Official package">

Liveblocks does not have a package for SolidJS. If you would like to have one,
or even better if you have ideas about what kind of API you would like to use,
please let us know about it on this
[GitHub issue](https://github.com/liveblocks/liveblocks/issues/672).

</Banner>

## Quickstart

<Steps>
  <Step>
    <StepTitle>Install Liveblocks</StepTitle>
    <StepContent>

      Every package should use the same version.

      ```bash trackEvent="install_liveblocks"
      npm install @liveblocks/client
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Initialize the `liveblocks.config.ts` file</StepTitle>
    <StepContent>

      We can use this file later to [define types for our application](/docs/api-reference/liveblocks-client#Typing-your-data).

      ```bash
      npx create-liveblocks-app@latest --init --framework javascript
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Set up the Liveblocks client</StepTitle>
    <StepContent>

      The first step in connecting to Liveblocks is creating a client which
      will be responsible for communicating with the back end.

      ```ts file="room.js"
      const client = createClient({
        publicApiKey: "{{PUBLIC_KEY}}",
      });
      ```

    </StepContent>

  </Step>

  <Step>
    <StepTitle>Join a Liveblocks room</StepTitle>
    <StepContent>

      Liveblocks uses the concept of rooms, separate virtual spaces where people collaborate.
      To create a realtime experience, multiple users must be connected to the same room.

      ```js
      const { room, leave } = client.enterRoom("my-room");
      ```

    </StepContent>

  </Step>

  <Step>
    <StepTitle>Use the Liveblocks methods</StepTitle>
    <StepContent>

      Now that weâ€™re connected to a room, we can start using Liveblocks subscriptions.
      The first weâ€™ll add is `others`, a subscription that provides information
      about which other users are connected to the room.

      ```js highlight="8-10"
      import { createSignal, onCleanup, onMount } from "solid-js";
      import { room } from "./room.js";

      export function Room() {
        const [others, setOthers] = createSignal(room.getOthers());

        onMount(() => {
          const unsubscribeOthers = room.subscribe("others", (updatedOthers) => {
            setOthers(updatedOthers);
          });

          onCleanup(() => {
            unsubscribeOthers();
          });
        });

        return (
          <div>There are {others.length} other user(s) online</div>
        );
      }
      ```

    </StepContent>

  </Step>

  <Step lastStep>
    <StepTitle>Next: set up authentication</StepTitle>
    <StepContent>

      By default, Liveblocks is configured to work without an authentication endpoint
      where everyone automatically has access to rooms. This approach is great for
      prototyping and marketing pages where setting up your own security isnâ€™t always
      required. If you want to limit access to a room for certain users, youâ€™ll need
      to set up an authentication endpoint to enable permissions.

      <Button asChild className="not-markdown">
        <a href="/docs/authentication">
          Set up authentication
        </a>
      </Button>
    </StepContent>

  </Step>
</Steps>

## What to read next

Congratulations! You now have set up the foundation to start building
collaborative experiences for your SolidJS application.

- [@liveblocks/client API Reference](/docs/api-reference/liveblocks-client)

---

## Examples using SolidJS

<ListGrid columns={2}>
  <ExampleCard
    example={{
      title: "Live Avatar Stack",
      slug: "live-avatar-stack/solidjs-live-avatars",
      image: "/images/examples/thumbnails/live-avatar-stack.jpg",
    }}
    technologies={["nextjs", "nuxtjs", "vuejs", "sveltekit", "solidjs"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Live Cursors",
      slug: "live-cursors/solidjs-live-cursors",
      image: "/images/examples/thumbnails/live-cursors.jpg",
    }}
    technologies={["nextjs", "nuxtjs", "vuejs", "sveltekit", "solidjs"]}
    openInNewWindow
  />
</ListGrid>

---
meta:
  title: "Get started with Liveblocks and Svelte"
  parentTitle: "Quickstart"
  description: "Learn how to get started with Liveblocks and Svelte"
---

Liveblocks is a realtime collaboration infrastructure for building performant
collaborative experiences. Follow the following steps to start adding
collaboration to your Svelte application using the APIs from the
[`@liveblocks/client`](/docs/api-reference/liveblocks-client) package.

<Banner title="Official package">

Liveblocks does not have a package for Svelte. If you would like to have one, or
even better if you have ideas about what kind of API you would like to use,
please let us know on
[GitHub](https://github.com/liveblocks/liveblocks/issues/1).

</Banner>

## Quickstart

<Steps>
  <Step>
    <StepTitle>Install Liveblocks</StepTitle>
    <StepContent>

      Every package should use the same version.

      ```bash trackEvent="install_liveblocks"
      npm install @liveblocks/client
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Initialize the `liveblocks.config.ts` file</StepTitle>
    <StepContent>

      We can use this file later to [define types for our application](/docs/api-reference/liveblocks-client#Typing-your-data).

      ```bash
      npx create-liveblocks-app@latest --init --framework javascript
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Set up the Liveblocks client</StepTitle>
    <StepContent>

      The first step in connecting to Liveblocks is creating a client which
      will be responsible for communicating with the back end.

      ```ts file="room.js"
      const client = createClient({
        publicApiKey: "{{PUBLIC_KEY}}",
      });
      ```

    </StepContent>

  </Step>

  <Step>
    <StepTitle>Join a Liveblocks room</StepTitle>
    <StepContent>

      Liveblocks uses the concept of rooms, separate virtual spaces where people collaborate.
      To create a realtime experience, multiple users must be connected to the same room.

      ```js
      const { room, leave } = client.enterRoom("my-room");
      ```

    </StepContent>

  </Step>

  <Step>
    <StepTitle>Use the Liveblocks methods</StepTitle>
    <StepContent>

      Now that weâ€™re connected to a room, we can start using Liveblocks subscriptions.
      The first weâ€™ll add is `others`, a subscription that provides information
      about which other users are connected to the room.

      ```js highlight="7-9"
      <script>
        import { onDestroy } from "svelte";
        import { room } from "./room.js";

        let others = room.getOthers();

        const unsubscribeOthers = room.subscribe("others", (updatedOthers) => {
          others = updatedOthers;
        });

        onDestroy(() => {
          unsubscribeOthers();
        });
      </script>

      <div>There are {others.length} other user(s) online</div>
      ```

    </StepContent>

  </Step>

  <Step lastStep>
    <StepTitle>Next: set up authentication</StepTitle>
    <StepContent>

      By default, Liveblocks is configured to work without an authentication endpoint
      where everyone automatically has access to rooms. This approach is great for
      prototyping and marketing pages where setting up your own security isnâ€™t always
      required. If you want to limit access to a room for certain users, youâ€™ll need
      to set up an authentication endpoint to enable permissions.

      <Button asChild className="not-markdown">
        <a href="/docs/authentication">
          Set up authentication
        </a>
      </Button>
    </StepContent>

  </Step>
</Steps>

## What to read next

Congratulations! You now have set up the foundation to start building
collaborative experiences for your Svelte application.

- [@liveblocks/client API Reference](/docs/api-reference/liveblocks-client)

---

## Examples using Svelte

<ListGrid columns={2}>
  <ExampleCard
    example={{
      title: "Live Cursors",
      slug: "live-cursors/sveltekit-live-cursors",
      image: "/images/examples/thumbnails/live-cursors.jpg",
    }}
    technologies={["nextjs", "vuejs", "sveltekit", "solidjs", "javascript"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Live Avatar Stack",
      slug: "live-avatar-stack/sveltekit-live-avatars",
      image: "/images/examples/thumbnails/live-avatar-stack.jpg",
    }}
    technologies={["nextjs", "nuxtjs", "vuejs", "sveltekit", "solidjs"]}
    openInNewWindow
  />
</ListGrid>

---
meta:
  title: "Get started with Liveblocks and Vue.js"
  parentTitle: "Quickstart"
  description: "Learn how to get started with Liveblocks and Vue.js"
---

Liveblocks is a realtime collaboration infrastructure for building performant
collaborative experiences. Follow the following steps to start adding
collaboration to your Vue.js application using the APIs from the
[`@liveblocks/client`](/docs/api-reference/liveblocks-client) package.

<Banner title="Official package">

Liveblocks does not have a package for Vue.js. If you would like to have one, or
even better if you have ideas about what kind of API you would like to use,
please let us know about it on this
[GitHub issue](https://github.com/liveblocks/liveblocks/issues/1).

</Banner>

## Quickstart

<Steps>
  <Step>
    <StepTitle>Install Liveblocks</StepTitle>
    <StepContent>

      Every package should use the same version.

      ```bash trackEvent="install_liveblocks"
      npm install @liveblocks/client
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Initialize the `liveblocks.config.ts` file</StepTitle>
    <StepContent>

      We can use this file later to [define types for our application](/docs/api-reference/liveblocks-client#Typing-your-data).

      ```bash
      npx create-liveblocks-app@latest --init --framework javascript
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Set up the Liveblocks client</StepTitle>
    <StepContent>

      The first step in connecting to Liveblocks is creating a client which
      will be responsible for communicating with the back end.

      ```ts file="room.js"
      const client = createClient({
        publicApiKey: "{{PUBLIC_KEY}}",
      });
      ```

    </StepContent>

  </Step>

  <Step>
    <StepTitle>Join a Liveblocks room</StepTitle>
    <StepContent>

      Liveblocks uses the concept of rooms, separate virtual spaces where people collaborate.
      To create a realtime experience, multiple users must be connected to the same room.

      ```js
      const { room, leave } = client.enterRoom("my-room");
      ```

    </StepContent>

  </Step>

  <Step>
    <StepTitle>Use the Liveblocks methods</StepTitle>
    <StepContent>

      Now that weâ€™re connected to a room, we can start using Liveblocks subscriptions.
      The first weâ€™ll add is `others`, a subscription that provides information
      about which other users are connected to the room.

      ```js highlight="7-9"
      <script setup>
        import { onUnmounted, ref } from "vue";
        import { room } from "./room.js";

        const others = ref(room.getOthers());

        const unsubscribeOthers = room.subscribe("others", (updatedOthers) => {
          others.current = updatedOthers;
        });

        onUnmounted(() => {
          unsubscribeOthers();
        });
      </script>

      <template>
        <div>There are {{ others.length }} other user(s) online</div>
      </template>
      ```

    </StepContent>

  </Step>

  <Step lastStep>
    <StepTitle>Next: set up authentication</StepTitle>
    <StepContent>

      By default, Liveblocks is configured to work without an authentication endpoint
      where everyone automatically has access to rooms. This approach is great for
      prototyping and marketing pages where setting up your own security isnâ€™t always
      required. If you want to limit access to a room for certain users, youâ€™ll need
      to set up an authentication endpoint to enable permissions.

      <Button asChild className="not-markdown">
        <a href="/docs/authentication">
          Set up authentication
        </a>
      </Button>
    </StepContent>

  </Step>
</Steps>

## What to read next

Congratulations! You now have set up the foundation to start building
collaborative experiences for your Vue.js application.

- [@liveblocks/client API Reference](/docs/api-reference/liveblocks-client)

---

## Examples using Vue.js

<ListGrid columns={2}>
  <ExampleCard
    example={{
      title: "Live Avatar Stack",
      slug: "live-avatar-stack/vuejs-live-avatars",
      image: "/images/examples/thumbnails/live-avatar-stack.jpg",
    }}
    technologies={["nextjs", "nuxtjs", "vuejs", "sveltekit", "solidjs"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Live Cursors",
      slug: "live-cursors/vuejs-live-cursors",
      image: "/images/examples/thumbnails/live-cursors.jpg",
    }}
    technologies={["nextjs", "nuxtjs", "vuejs", "sveltekit", "solidjs"]}
    openInNewWindow
  />
</ListGrid>

---
meta:
  title:
    "Get started with a CodeMirror code editor using Liveblocks and JavaScript"
  parentTitle: "Quickstart"
  description:
    "Learn how to install a CodeMirror code editor using Liveblocks and
    JavaScript"
---

Liveblocks is a realtime collaboration infrastructure for building performant
collaborative experiences. Follow the following steps to start adding
collaboration to your JavaScript application using the APIs from the
[`@liveblocks/yjs`](/docs/api-reference/liveblocks-yjs) package.

## Quickstart

<Steps>
  <Step>
    <StepTitle>Install Liveblocks, Yjs, and CodeMirror</StepTitle>
    <StepContent>

      Every Liveblocks package should use the same version.

      ```bash trackEvent="install_liveblocks"
      npm install @liveblocks/client @liveblocks/yjs yjs codemirror @codemirror/lang-javascript y-codemirror.next
      ```
    </StepContent>

  </Step>

  <Step>
    <StepTitle>Initialize the `liveblocks.config.ts` file</StepTitle>
    <StepContent>

      We can use this file later to [define types for our application](/docs/api-reference/liveblocks-client#Typing-your-data).

      ```bash
      npx create-liveblocks-app@latest --init --framework javascript
      ```

    </StepContent>

  </Step>

  <Step>
    <StepTitle>Create an HTML element</StepTitle>
    <StepContent>

      ```html
      <div id="editor"></div>
      ```

    </StepContent>

  </Step>

  <Step>
    <StepTitle>Set up your collaborative CodeMirror code editor</StepTitle>
    <StepContent>

      ```js file="app.js"
      import { createClient } from "@liveblocks/client";
      import { getYjsProviderForRoom } from "@liveblocks/yjs";
      import * as Y from "yjs";
      import { yCollab } from "y-codemirror.next";
      import { EditorView, basicSetup } from "codemirror";
      import { EditorState } from "@codemirror/state";
      import { javascript } from "@codemirror/lang-javascript";

      // Set up Liveblocks client
      const client = createClient({
        publicApiKey: "{{PUBLIC_KEY}}",
      });

      // Enter a multiplayer room
      const { room, leave } = client.enterRoom("my-room");

      // Set up Yjs document, shared text, and Liveblocks Yjs provider
      const yProvider = getYjsProviderForRoom(room);
      const yDoc = yProvider.getYDoc()
      const yText = yDoc.getText("codemirror");

      // Set up CodeMirror and extensions
      const state = EditorState.create({
        doc: yText.toString(),
        extensions: [
          basicSetup,
          javascript(),
          yCollab(yText, yProvider.awareness, { undoManager }),
        ],
      });

      // Attach CodeMirror to element
      const parent = document.querySelector("#editor");
      view = new EditorView({
        state,
        parent,
      });
      ```
    </StepContent>

  </Step>

  <Step lastStep>
    <StepTitle>Next: set up authentication</StepTitle>
    <StepContent>
      By default, Liveblocks is configured to work without an authentication endpoint
      where everyone automatically has access to rooms. This approach is great for
      prototyping and marketing pages where setting up your own security isnâ€™t always
      required. If you want to limit access to a room for certain users, youâ€™ll need
      to set up an authentication endpoint to enable permissions.

      <Button asChild className="not-markdown">
        <a href="/docs/authentication">
          Set up authentication
        </a>
      </Button>
    </StepContent>

  </Step>
</Steps>

## What to read next

Congratulations! You now have set up the foundation for your collaborative
CodeMirror code editor inside your JavaScript application.

- [@liveblocks/yjs API Reference](/docs/api-reference/liveblocks-yjs)
- [@liveblocks/client API Reference](/docs/api-reference/liveblocks-client)
- [CodeMirror website](https://codemirror.net)

---
meta:
  title: "Get started with a CodeMirror code editor using Liveblocks and React"
  parentTitle: "Quickstart"
  description:
    "Learn how to install a CodeMirror code editor using Liveblocks and React"
---

Liveblocks is a realtime collaboration infrastructure for building performant
collaborative experiences. Follow the following steps to start adding
collaboration to your React application using the APIs from the
[`@liveblocks/yjs`](/docs/api-reference/liveblocks-yjs) package.

## Quickstart

<Steps>
  <Step>
    <StepTitle>Install Liveblocks, Yjs, and CodeMirror</StepTitle>
    <StepContent>

      Every Liveblocks package should use the same version.

      ```bash trackEvent="install_liveblocks"
      npm install @liveblocks/client @liveblocks/react @liveblocks/yjs yjs codemirror @codemirror/lang-javascript y-codemirror.next
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Initialize the `liveblocks.config.ts` file</StepTitle>
    <StepContent>

      We can use this file later to [define types for our application](/docs/api-reference/liveblocks-react#Typing-your-data).

      ```bash
      npx create-liveblocks-app@latest --init --framework react
      ```

    </StepContent>

  </Step>

  <Step>
    <StepTitle>Set up the Liveblocks client</StepTitle>
    <StepContent>

      Liveblocks uses the concept of rooms, separate virtual spaces where people
      collaborate, and to create a realtime experience, multiple users must
      be connected to the same room. Set up a Liveblocks client with [`LiveblocksProvider`](/docs/api-reference/liveblocks-react#LiveblocksProvider), and join a room with [`RoomProvider`](/docs/api-reference/liveblocks-react#RoomProvider).

      ```tsx file="App.tsx" highlight="11-15"
      "use client";

      import {
        LiveblocksProvider,
        RoomProvider,
      } from "@liveblocks/react/suspense";
      import { Editor } from "./Editor";

      export default function App() {
        return (
          <LiveblocksProvider publicApiKey={"{{PUBLIC_KEY}}"}>
            <RoomProvider id="my-room">
              {/* ... */}
            </RoomProvider>
          </LiveblocksProvider>
        );
      }
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Join a Liveblocks room</StepTitle>
    <StepContent>

      After setting up the room, you can add collaborative components inside it, using
      [`ClientSideSuspense`](/docs/api-reference/liveblocks-react#ClientSideSuspense) to add loading spinners to your app.

      ```tsx file="App.tsx" highlight="14-16"
      "use client";

      import {
        LiveblocksProvider,
        RoomProvider,
        ClientSideSuspense,
      } from "@liveblocks/react/suspense";
      import { Editor } from "./Editor";

      export default function App() {
        return (
          <LiveblocksProvider publicApiKey={"{{PUBLIC_KEY}}"}>
            <RoomProvider id="my-room">
              <ClientSideSuspense fallback={<div>Loadingâ€¦</div>}>
                <Editor />
              </ClientSideSuspense>
            </RoomProvider>
          </LiveblocksProvider>
        );
      }
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Set up the collaborative CodeMirror editor</StepTitle>
    <StepContent>

      Now that we set up Liveblocks, we can start integrating CodeMirror and Yjs in the `Editor.tsx` file.
      To make the editor collaborative, we can rely on the `yCollab` from `y-codemirror.next`.

      ```tsx
      "use client";

      import * as Y from "yjs";
      import { yCollab } from "y-codemirror.next";
      import { EditorView, basicSetup } from "codemirror";
      import { EditorState } from "@codemirror/state";
      import { javascript } from "@codemirror/lang-javascript";
      import { useCallback, useEffect, useState } from "react";
      import { getYjsProviderForRoom } from "@liveblocks/yjs";
      import { useRoom } from "@/liveblocks.config";
      import styles from "./Editor.module.css";

      export default function Editor() {
        const room = useRoom();
        const yProvider = getYjsProviderForRoom(room);
        const [element, setElement] = useState<HTMLElement>();

        const ref = useCallback((node: HTMLElement | null) => {
          if (!node) return;

          setElement(node);
        }, []);

        // Set up Liveblocks Yjs provider and attach CodeMirror editor
        useEffect(() => {
          let view: EditorView;

          if (!element || !room) {
            return;
          }

          // Get document
          const yDoc = yProvider.getYDoc();
          const yText = yDoc.getText("codemirror");
          const undoManager = new Y.UndoManager(yText);

          // Set up CodeMirror and extensions
          const state = EditorState.create({
            doc: yText.toString(),
            extensions: [
              basicSetup,
              javascript(),
              yCollab(yText, yProvider.awareness, { undoManager }),
            ],
          });

          // Attach CodeMirror to element
          view = new EditorView({
            state,
            parent: element,
          });

          return () => {
            view?.destroy();
          };
        }, [element, room]);

        return <div ref={ref} className={styles.editor} />;
      }
      ```
    </StepContent>

  </Step>
  <Step lastStep>
    <StepTitle>Next: set up authentication</StepTitle>
    <StepContent>

      By default, Liveblocks is configured to work without an authentication endpoint
      where everyone automatically has access to rooms. This approach is great for
      prototyping and marketing pages where setting up your own security isnâ€™t always
      required. If you want to limit access to a room for certain users, youâ€™ll need
      to set up an authentication endpoint to enable permissions.

      <Button asChild className="not-markdown">
        <a href="/docs/authentication">
          Set up authentication
        </a>
      </Button>
    </StepContent>

  </Step>
</Steps>

## What to read next

Congratulations! You now have set up the foundation for your collaborative
CodeMirror editor inside your React application.

- [Yjs and CodeMirror guides](/docs/guides?technologies=yjs%2Ccodemirror)
- [How to create a collaborative code editor with CodeMirror, Yjs, Next.js, and Liveblocks](/docs/guides/how-to-create-a-collaborative-code-editor-with-codemirror-yjs-nextjs-and-liveblocks)
- [@liveblocks/yjs API Reference](/docs/api-reference/liveblocks-yjs)
- [CodeMirror website](https://codemirror.net)

---

## Examples using CodeMirror

<ListGrid columns={2}>
  <ExampleCard
    example={{
      title: "Collaborative Code Editor",
      slug: "collaborative-code-editor/nextjs-yjs-codemirror",
      image: "/images/examples/thumbnails/code-editor.jpg",
    }}
    technologies={["nextjs"]}
    openInNewWindow
  />
</ListGrid>

---
meta:
  title: "Get started with a CodeMirror code editor using Liveblocks and Svelte"
  parentTitle: "Quickstart"
  description:
    "Learn how to install a CodeMirror code editor using Liveblocks and Svelte"
---

Liveblocks is a realtime collaboration infrastructure for building performant
collaborative experiences. Follow the following steps to start adding
collaboration to your Svelte application using the APIs from the
[`@liveblocks/yjs`](/docs/api-reference/liveblocks-yjs) package.

## Quickstart

<Steps>
  <Step>
    <StepTitle>Install Liveblocks, Yjs, and CodeMirror</StepTitle>
    <StepContent>

      Every Liveblocks package should use the same version.

      ```bash trackEvent="install_liveblocks"
      npm install @liveblocks/client @liveblocks/yjs yjs codemirror @codemirror/lang-javascript y-codemirror.next
      ```
    </StepContent>

  </Step>

  <Step>
    <StepTitle>Initialize the `liveblocks.config.ts` file</StepTitle>
    <StepContent>

      We can use this file later to [define types for our application](/docs/api-reference/liveblocks-client#Typing-your-data).

      ```bash
      npx create-liveblocks-app@latest --init --framework javascript
      ```

    </StepContent>

  </Step>

  <Step>
    <StepTitle>Set up your collaborative CodeMirror code editor</StepTitle>
    <StepContent>

      ```html file="Editor.svelte"
      <script>
      import { onMount, onDestroy } from "svelte";
      import { createClient } from "@liveblocks/client";
      import { getYjsProviderForRoom } from "@liveblocks/yjs";
      import * as Y from "yjs";
      import { yCollab } from "y-codemirror.next";
      import { EditorView, basicSetup } from "codemirror";
      import { EditorState } from "@codemirror/state";
      import { javascript } from "@codemirror/lang-javascript";

      let parent;

      // Set up Liveblocks client
      const client = createClient({
        publicApiKey: "{{PUBLIC_KEY}}",
      });

      onMount(() => {
        // Enter a multiplayer room
        const { room, leave } = client.enterRoom("my-room");

        // Set up Yjs document, shared text, undo manager, and Liveblocks Yjs provider
        const yProvider = getYjsProviderForRoom(room);
        const yDoc = yProvider.getYDoc();
        const yText = yDoc.getText("codemirror");
        const undoManager = new Y.UndoManager(yText);

        // Set up CodeMirror and extensions
        const state = EditorState.create({
          doc: yText.toString(),
          extensions: [
            basicSetup,
            javascript(),
            yCollab(yText, yProvider.awareness, { undoManager }),
          ],
        });

        // Attach CodeMirror to element
        const view = new EditorView({
          state,
          parent,
        });

        return () => {
          view.destroy();
          leave();
        };
      });
      </script>

      <div bind:this={parent}></div>
      ```
    </StepContent>

  </Step>

  <Step lastStep>
    <StepTitle>Next: set up authentication</StepTitle>
    <StepContent>
      By default, Liveblocks is configured to work without an authentication endpoint
      where everyone automatically has access to rooms. This approach is great for
      prototyping and marketing pages where setting up your own security isnâ€™t always
      required. If you want to limit access to a room for certain users, youâ€™ll need
      to set up an authentication endpoint to enable permissions.

      <Button asChild className="not-markdown">
        <a href="/docs/authentication">
          Set up authentication
        </a>
      </Button>
    </StepContent>

  </Step>
</Steps>

## What to read next

Congratulations! You now have set up the foundation for your collaborative
CodeMirror code editor inside your Svelte application.

- [@liveblocks/yjs API Reference](/docs/api-reference/liveblocks-yjs)
- [@liveblocks/client API Reference](/docs/api-reference/liveblocks-client)
- [CodeMirror website](https://codemirror.net)

---
meta:
  title: "Get started with a CodeMirror code editor using Liveblocks and Vue.js"
  parentTitle: "Quickstart"
  description:
    "Learn how to install a CodeMirror code editor using Liveblocks and Vue.js"
---

Liveblocks is a realtime collaboration infrastructure for building performant
collaborative experiences. Follow the following steps to start adding
collaboration to your Vue.js application using the APIs from the
[`@liveblocks/yjs`](/docs/api-reference/liveblocks-yjs) package.

## Quickstart

<Steps>
  <Step>
    <StepTitle>Install Liveblocks, Yjs, and CodeMirror</StepTitle>
    <StepContent>

      Every Liveblocks package should use the same version.

      ```bash trackEvent="install_liveblocks"
      npm install @liveblocks/client @liveblocks/yjs yjs codemirror @codemirror/lang-javascript y-codemirror.next
      ```
    </StepContent>

  </Step>

  <Step>
    <StepTitle>Initialize the `liveblocks.config.ts` file</StepTitle>
    <StepContent>

      We can use this file later to [define types for our application](/docs/api-reference/liveblocks-client#Typing-your-data).

      ```bash
      npx create-liveblocks-app@latest --init --framework javascript
      ```

    </StepContent>

  </Step>

  <Step>
    <StepTitle>Set up your collaborative CodeMirror code editor</StepTitle>
    <StepContent>

      ```html file="Editor.vue"
      <script setup>
      import { ref, onMounted, onUnmounted } from "vue";
      import { createClient } from "@liveblocks/client";
      import { getYjsProviderForRoom } from "@liveblocks/yjs";
      import * as Y from "yjs";
      import { yCollab } from "y-codemirror.next";
      import { EditorView, basicSetup } from "codemirror";
      import { EditorState } from "@codemirror/state";
      import { javascript } from "@codemirror/lang-javascript";

      const parent = ref(null);
      const leave = ref(null);
      const view = ref(null);

      // Set up Liveblocks client
      const client = createClient({
        publicApiKey: "{{PUBLIC_KEY}}",
      });

      // Enter a multiplayer room
      const info = client.enterRoom("my-room");
      const room = info.room;
      leave.value = info.leave;

      // Set up Yjs document, shared text, and Liveblocks Yjs provider
      const yProvider = getYjsProviderForRoom(room);
      const yDoc = yProvider.getYDoc();
      const yText = yDoc.getText("codemirror");

      onMounted(() => {
        // Set up CodeMirror and extensions
        const state = EditorState.create({
          doc: yText.toString(),
          extensions: [
            basicSetup,
            javascript(),
            yCollab(yText, yProvider.awareness, { undoManager }),
          ],
        });

        // Attach CodeMirror to element
        view.current = new EditorView({
          state,
          parent: parent.value,
        });
      });

      onUnmounted(() => {
        view?.destroy();
        leave.value?.();
      });
      </script>

      <template>
        <div ref="parent" />
      </template>
      ```
    </StepContent>

  </Step>

  <Step lastStep>
    <StepTitle>Next: set up authentication</StepTitle>
    <StepContent>
      By default, Liveblocks is configured to work without an authentication endpoint
      where everyone automatically has access to rooms. This approach is great for
      prototyping and marketing pages where setting up your own security isnâ€™t always
      required. If you want to limit access to a room for certain users, youâ€™ll need
      to set up an authentication endpoint to enable permissions.

      <Button asChild className="not-markdown">
        <a href="/docs/authentication">
          Set up authentication
        </a>
      </Button>
    </StepContent>

  </Step>
</Steps>

## What to read next

Congratulations! You now have set up the foundation for your collaborative
CodeMirror code editor inside your Vue.js application.

- [@liveblocks/yjs API Reference](/docs/api-reference/liveblocks-yjs)
- [@liveblocks/client API Reference](/docs/api-reference/liveblocks-client)
- [CodeMirror website](https://codemirror.net)

---
meta:
  title: "Get started with a Monaco code editor using Liveblocks and JavaScript"
  parentTitle: "Quickstart"
  description:
    "Learn how to install a Monaco code editor using Liveblocks and JavaScript"
---

Liveblocks is a realtime collaboration infrastructure for building performant
collaborative experiences. Follow the following steps to start adding
collaboration to your JavaScript application using the APIs from the
[`@liveblocks/yjs`](/docs/api-reference/liveblocks-yjs) package.

## Quickstart

<Steps>
  <Step>
    <StepTitle>Install Liveblocks, Yjs, and Monaco</StepTitle>
    <StepContent>

      Every Liveblocks package should use the same version.

      ```bash trackEvent="install_liveblocks"
      npm install @liveblocks/client @liveblocks/yjs yjs monaco-editor y-monaco
      ```
    </StepContent>

  </Step>

  <Step>
    <StepTitle>Initialize the `liveblocks.config.ts` file</StepTitle>
    <StepContent>

      We can use this file later to [define types for our application](/docs/api-reference/liveblocks-client#Typing-your-data).

      ```bash
      npx create-liveblocks-app@latest --init --framework javascript
      ```

    </StepContent>

  </Step>

  <Step>
    <StepTitle>Create an HTML element</StepTitle>
    <StepContent>

      ```html
      <div id="editor"></div>
      ```

    </StepContent>

  </Step>

  <Step>
    <StepTitle>Set up your collaborative Monaco code editor</StepTitle>
    <StepContent>

      ```js file="app.js"
      import { createClient } from "@liveblocks/client";
      import { getYjsProviderForRoom } from "@liveblocks/yjs";
      import * as Y from "yjs";
      import * as monaco from "monaco-editor";
      import { MonacoBinding } from "y-monaco";

      // Set up Liveblocks client
      const client = createClient({
        publicApiKey: "{{PUBLIC_KEY}}",
      });

      // Enter a multiplayer room
      const { room, leave } = client.enterRoom("my-room");

      // Set up Yjs document, shared text, and Liveblocks Yjs provider
      const yProvider = getYjsProviderForRoom(room);
      const yDoc = yProvider.getYDoc();
      const yText = yDoc.getText("monaco");

      // Set up the Monaco editor
      const parent = document.querySelector("#editor");
      const editor = monaco.editor.create(parent, {
        value: "",
        language: "javascript"
      });

      // Attach Yjs to Monaco
      const monacoBinding = new MonacoBinding(
        yText,
        editor.getModel(),
        new Set([editor]),
        yProvider.awareness
      );
      ```
    </StepContent>

  </Step>

  <Step lastStep>
    <StepTitle>Next: set up authentication</StepTitle>
    <StepContent>
      By default, Liveblocks is configured to work without an authentication endpoint
      where everyone automatically has access to rooms. This approach is great for
      prototyping and marketing pages where setting up your own security isnâ€™t always
      required. If you want to limit access to a room for certain users, youâ€™ll need
      to set up an authentication endpoint to enable permissions.

      <Button asChild className="not-markdown">
        <a href="/docs/authentication">
          Set up authentication
        </a>
      </Button>
    </StepContent>

  </Step>
</Steps>

## What to read next

Congratulations! You now have set up the foundation for your collaborative
Monaco code editor inside your JavaScript application.

- [@liveblocks/yjs API Reference](/docs/api-reference/liveblocks-yjs)
- [@liveblocks/client API Reference](/docs/api-reference/liveblocks-client)
- [Monaco website](https://microsoft.github.io/monaco-editor/)

---
meta:
  title: "Get started with a Monaco code editor using Liveblocks and React"
  parentTitle: "Quickstart"
  description:
    "Learn how to install a Monaco code editor using Liveblocks and React"
---

Liveblocks is a realtime collaboration infrastructure for building performant
collaborative experiences. Follow the following steps to start adding
collaboration to your React application using the APIs from the
[`@liveblocks/yjs`](/docs/api-reference/liveblocks-yjs) package.

## Quickstart

<Steps>
  <Step>
    <StepTitle>Install Liveblocks, Yjs, and Monaco</StepTitle>
    <StepContent>

      Every Liveblocks package should use the same version.

      ```bash trackEvent="install_liveblocks"
      npm install @liveblocks/client @liveblocks/react @liveblocks/yjs yjs @monaco-editor/react y-monaco y-protocols
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Initialize the `liveblocks.config.ts` file</StepTitle>
    <StepContent>

      We can use this file later to [define types for our application](/docs/api-reference/liveblocks-react#Typing-your-data).

      ```bash
      npx create-liveblocks-app@latest --init --framework react
      ```

    </StepContent>

  </Step>

  <Step>
    <StepTitle>Set up the Liveblocks client</StepTitle>
    <StepContent>

      Liveblocks uses the concept of rooms, separate virtual spaces where people
      collaborate, and to create a realtime experience, multiple users must
      be connected to the same room. Set up a Liveblocks client with [`LiveblocksProvider`](/docs/api-reference/liveblocks-react#LiveblocksProvider), and join a room with [`RoomProvider`](/docs/api-reference/liveblocks-react#RoomProvider).

      ```tsx file="App.tsx"
      "use client";

      import {
        LiveblocksProvider,
        RoomProvider,
      } from "@liveblocks/react/suspense";
      import { Editor } from "./Editor";

      export default function App() {
        return (
          // +++
          <LiveblocksProvider publicApiKey={"{{PUBLIC_KEY}}"}>
            <RoomProvider id="my-room">
              {/* ... */}
            </RoomProvider>
          </LiveblocksProvider>
          // +++
        );
      }
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Join a Liveblocks room</StepTitle>
    <StepContent>

      After setting up the room, you can add collaborative components inside it, using
      [`ClientSideSuspense`](/docs/api-reference/liveblocks-react#ClientSideSuspense) to add loading spinners to your app.

      ```tsx file="App.tsx" highlight="14-16"
      "use client";

      import {
        LiveblocksProvider,
        RoomProvider,
        ClientSideSuspense,
      } from "@liveblocks/react/suspense";
      import { CollaborativeEditor } from "./CollaborativeEditor";

      export default function App() {
        return (
          <LiveblocksProvider publicApiKey={"{{PUBLIC_KEY}}"}>
            <RoomProvider id="my-room">
              <ClientSideSuspense fallback={<div>Loadingâ€¦</div>}>
                <CollaborativeEditor />
              </ClientSideSuspense>
            </RoomProvider>
          </LiveblocksProvider>
        );
      }
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Set up the collaborative Monaco code editor</StepTitle>
    <StepContent>

      Now that we set up Liveblocks, we can start integrating Monaco and Yjs in the `Editor.tsx` file.
      To make the editor collaborative, we can rely on `MonacoBinding` from `y-monaco`.

      ```tsx file="CollaborativeEditor.tsx"
      "use client";

      import * as Y from "yjs";
      import { getYjsProviderForRoom } from "@liveblocks/yjs";
      import { useRoom } from "@/liveblocks.config";
      import { useCallback, useEffect, useState } from "react";
      import { Editor } from "@monaco-editor/react";
      import { editor } from "monaco-editor";
      import { MonacoBinding } from "y-monaco";
      import { Awareness } from "y-protocols/awareness";

      // Collaborative text editor with simple rich text, live cursors, and live avatars
      export function CollaborativeEditor() {
        const [editorRef, setEditorRef] = useState<editor.IStandaloneCodeEditor>();
        const room = useRoom();
        const yProvider = getYjsProviderForRoom(room);

        // Set up Liveblocks Yjs provider and attach Monaco editor
        useEffect(() => {
          let binding: MonacoBinding;

          if (editorRef) {
            const yDoc = yProvider.getYDoc();
            const yText = yDoc.getText("monaco");

            // Attach Yjs to Monaco
            binding = new MonacoBinding(
              yText,
              editorRef.getModel() as editor.ITextModel,
              new Set([editorRef]),
              yProvider.awareness as Awareness
            );
          }

          return () => {
            binding?.destroy();
          };
        }, [editorRef, room]);

        const handleOnMount = useCallback((e: editor.IStandaloneCodeEditor) => {
          setEditorRef(e);
        }, []);

        return (
          <Editor
            onMount={handleOnMount}
            height="100vh"
            width="100%"
            theme="vs-light"
            defaultLanguage="typescript"
            defaultValue=""
            options={{
              tabSize: 2,
            }}
          />
        );
      }
      ```

    </StepContent>

  </Step>

  <Step lastStep>
    <StepTitle>Next: set up authentication</StepTitle>
    <StepContent>
      By default, Liveblocks is configured to work without an authentication endpoint
      where everyone automatically has access to rooms. This approach is great for
      prototyping and marketing pages where setting up your own security isnâ€™t always
      required. If you want to limit access to a room for certain users, youâ€™ll need
      to set up an authentication endpoint to enable permissions.

      <Button asChild className="not-markdown">
        <a href="/docs/authentication">
          Set up authentication
        </a>
      </Button>
    </StepContent>

  </Step>

</Steps>

## What to read next

Congratulations! You now have set up the foundation for your collaborative
Monaco code editor inside your React application.

- [Yjs and Monaco guides](/docs/guides?technologies=yjs%2Cmonaco)
- [How to create a collaborative code editor with Monaco, Yjs, Next.js, and Liveblocks](/docs/guides/how-to-create-a-collaborative-code-editor-with-monaco-yjs-nextjs-and-liveblocks)
- [@liveblocks/yjs API Reference](/docs/api-reference/liveblocks-yjs)
- [Monaco website](https://microsoft.github.io/monaco-editor/)

---

## Examples using Monaco

<ListGrid columns={2}>
  <ExampleCard
    example={{
      title: "Collaborative Code Editor",
      slug: "collaborative-code-editor/nextjs-yjs-monaco",
      image: "/images/examples/thumbnails/code-editor.jpg",
    }}
    technologies={["nextjs"]}
    openInNewWindow
  />
</ListGrid>

---
meta:
  title: "Get started with a Monaco code editor using Liveblocks and Svelte"
  parentTitle: "Quickstart"
  description:
    "Learn how to install a Monaco code editor using Liveblocks and Svelte"
---

Liveblocks is a realtime collaboration infrastructure for building performant
collaborative experiences. Follow the following steps to start adding
collaboration to your Svelte application using the APIs from the
[`@liveblocks/yjs`](/docs/api-reference/liveblocks-yjs) package.

## Quickstart

<Steps>
  <Step>
    <StepTitle>Install Liveblocks, Yjs, and Monaco</StepTitle>
    <StepContent>

      Every Liveblocks package should use the same version.

      ```bash trackEvent="install_liveblocks"
      npm install @liveblocks/client @liveblocks/yjs yjs monaco-editor y-monaco
      ```
    </StepContent>

  </Step>

  <Step>
    <StepTitle>Initialize the `liveblocks.config.ts` file</StepTitle>
    <StepContent>

      We can use this file later to [define types for our application](/docs/api-reference/liveblocks-client#Typing-your-data).

      ```bash
      npx create-liveblocks-app@latest --init --framework javascript
      ```

    </StepContent>

  </Step>

  <Step>
    <StepTitle>Set up your collaborative Monaco code editor</StepTitle>
    <StepContent>

      ```html file="Editor.svelte"
      <script>
      import { onMount, onDestroy } from "svelte";
      import { createClient } from "@liveblocks/client";
      import { getYjsProviderForRoom } from "@liveblocks/yjs";
      import * as Y from "yjs";
      import * as monaco from "monaco-editor";
      import { MonacoBinding } from "y-monaco";

      let element;
      const roomId = "my-room";

      // Set up Liveblocks client
      const client = createClient({
        publicApiKey: "{{PUBLIC_KEY}}",
      });

      onMount(() => {
        // Enter a multiplayer room
        const { room, leave } = client.enterRoom(roomId);

        // Set up Yjs document, shared text, and Liveblocks Yjs provider
        const yProvider = getYjsProviderForRoom(room);
        const yDoc = yProvider.getYDoc();
        const yText = yDoc.getText("monaco");

        // Set up the Monaco editor
        const editor = monaco.editor.create(element, {
          value: "",
          language: "javascript"
        });

        // Attach Yjs to Monaco
        const binding = new MonacoBinding(
          yText,
          editor.getModel(),
          new Set([editor]),
          yProvider.awareness
        );

        return () => {
          binding.destroy();
          editor.dispose();
          leave();
        };
      });

      </script>

      <div bind:this={element}></div>
      ```
    </StepContent>

  </Step>

  <Step lastStep>
    <StepTitle>Next: set up authentication</StepTitle>
    <StepContent>
      By default, Liveblocks is configured to work without an authentication endpoint
      where everyone automatically has access to rooms. This approach is great for
      prototyping and marketing pages where setting up your own security isnâ€™t always
      required. If you want to limit access to a room for certain users, youâ€™ll need
      to set up an authentication endpoint to enable permissions.

      <Button asChild className="not-markdown">
        <a href="/docs/authentication">
          Set up authentication
        </a>
      </Button>
    </StepContent>

  </Step>
</Steps>

## What to read next

Congratulations! You now have set up the foundation for your collaborative
Monaco code editor inside your Svelte application.

- [@liveblocks/yjs API Reference](/docs/api-reference/liveblocks-yjs)
- [@liveblocks/client API Reference](/docs/api-reference/liveblocks-client)
- [Monaco website](https://microsoft.github.io/monaco-editor/)

---
meta:
  title: "Get started with a Monaco code editor using Liveblocks and Vue.js"
  parentTitle: "Quickstart"
  description:
    "Learn how to install a Monaco code editor using Liveblocks and Vue.js"
---

Liveblocks is a realtime collaboration infrastructure for building performant
collaborative experiences. Follow the following steps to start adding
collaboration to your Vue.js application using the APIs from the
[`@liveblocks/yjs`](/docs/api-reference/liveblocks-yjs) package.

## Quickstart

<Steps>
  <Step>
    <StepTitle>Install Liveblocks, Yjs, and Monaco</StepTitle>
    <StepContent>

      Every Liveblocks package should use the same version.

      ```bash trackEvent="install_liveblocks"
      npm install @liveblocks/client @liveblocks/yjs yjs monaco-editor y-monaco
      ```
    </StepContent>

  </Step>

  <Step>
    <StepTitle>Initialize the `liveblocks.config.ts` file</StepTitle>
    <StepContent>

      We can use this file later to [define types for our application](/docs/api-reference/liveblocks-client#Typing-your-data).

      ```bash
      npx create-liveblocks-app@latest --init --framework javascript
      ```

    </StepContent>

  </Step>

  <Step>
    <StepTitle>Set up your collaborative Monaco code editor</StepTitle>
    <StepContent>

      ```html file="Editor.vue"
      <script setup>
      import { ref, onMounted, onUnmounted } from "vue";
      import { createClient } from "@liveblocks/client";
      import { getYjsProviderForRoom } from "@liveblocks/yjs";
      import * as Y from "yjs";
      import * as monaco from "monaco-editor";
      import { MonacoBinding } from "y-monaco";

      const element = ref(null);
      const editor = ref(null);
      const binding = ref(null);
      const leave = ref(null);

      // Set up Liveblocks client
      const client = createClient({
        publicApiKey: "{{PUBLIC_KEY}}",
      });

      // Enter a multiplayer room
      const info = client.enterRoom("my-room");
      const room = info.room;
      leave.value = info.leave;

      // Set up Yjs document, shared text, and Liveblocks Yjs provider
      const yProvider = getYjsProviderForRoom(room);
      const yDoc = yProvider.getYDoc();
      const yText = yDoc.getText("monaco");

      onMounted(() => {
        // Set up the Monaco editor
        editor.value = monaco.editor.create(element.value, {
          value: "",
          language: "javascript"
        })

        // Attach Yjs to Monaco
        binding.value = new MonacoBinding(
          yText,
          editor.value.getModel(),
          new Set([editor]),
          yProvider.awareness
        );
      });

      onUnmounted(() => {
        binding?.destroy();
        editor.value?.dispose();
        leave?.();
      });
      </script>

      <template>
        <div ref="element" />
      </template>
      ```
    </StepContent>

  </Step>

  <Step lastStep>
    <StepTitle>Next: set up authentication</StepTitle>
    <StepContent>
      By default, Liveblocks is configured to work without an authentication endpoint
      where everyone automatically has access to rooms. This approach is great for
      prototyping and marketing pages where setting up your own security isnâ€™t always
      required. If you want to limit access to a room for certain users, youâ€™ll need
      to set up an authentication endpoint to enable permissions.

      <Button asChild className="not-markdown">
        <a href="/docs/authentication">
          Set up authentication
        </a>
      </Button>
    </StepContent>

  </Step>
</Steps>

## What to read next

Congratulations! You now have set up the foundation for your collaborative
Monaco code editor inside your Vue.js application.

- [@liveblocks/yjs API Reference](/docs/api-reference/liveblocks-yjs)
- [@liveblocks/client API Reference](/docs/api-reference/liveblocks-client)
- [Monaco website](https://microsoft.github.io/monaco-editor/)

---
meta:
  title: "Get started with a Quill text editor using Liveblocks and JavaScript"
  parentTitle: "Quickstart"
  description:
    "Learn how to install a Quill text editor using Liveblocks and JavaScript"
---

Liveblocks is a realtime collaboration infrastructure for building performant
collaborative experiences. Follow the following steps to start adding
collaboration to your JavaScript application using the APIs from the
[`@liveblocks/yjs`](/docs/api-reference/liveblocks-yjs) package.

## Quickstart

<Steps>
  <Step>
    <StepTitle>Install Liveblocks, Yjs, and Quill</StepTitle>
    <StepContent>

      Every Liveblocks package should use the same version.

      ```bash trackEvent="install_liveblocks"
      npm install @liveblocks/client @liveblocks/yjs yjs quill quill-cursors y-quill
      ```
    </StepContent>

  </Step>

  <Step>
    <StepTitle>Initialize the `liveblocks.config.ts` file</StepTitle>
    <StepContent>

      We can use this file later to [define types for our application](/docs/api-reference/liveblocks-client#Typing-your-data).

      ```bash
      npx create-liveblocks-app@latest --init --framework javascript
      ```

    </StepContent>

  </Step>

  <Step>
    <StepTitle>Create an HTML element</StepTitle>
    <StepContent>

      ```html
      <div id="editor"></div>
      ```

    </StepContent>

  </Step>

  <Step>
    <StepTitle>Set up your collaborative Quill text editor</StepTitle>
    <StepContent>

      ```js file="app.js"
      import { createClient } from "@liveblocks/client";
      import { getYjsProviderForRoom } from "@liveblocks/yjs";
      import * as Y from "yjs";
      import Quill from "quill";
      import { QuillBinding } from "y-quill";
      import QuillCursors from "quill-cursors";

      // Set up Liveblocks client
      const client = createClient({
        publicApiKey: "{{PUBLIC_KEY}}",
      });

      // Enter a multiplayer room
      const { room, leave } = client.enterRoom("my-room");

      // Set up Yjs document, shared text, and Liveblocks Yjs provider
      const yProvider = getYjsProviderForRoom(room);
      const yDoc = yProvider.getYDoc();
      const yText = yDoc.getText("quill");

      // Attach cursors plugin
      Quill.register("modules/cursors", QuillCursors);

      // Set up Quill editor and modules
      const parent = document.querySelector("#editor");
      const quill = new Quill(parent, {
        placeholder: "Start collaboratingâ€¦",
        theme: "snow",
        modules: {
          cursors: true,
          toolbar: [
            [{ header: [1, 2, false] }],
            ["bold", "italic", "underline"],
            ["code-block"],
          ],
          history: {
            // Local undo shouldnâ€™t undo changes made by other users
            userOnly: true,
          },
        },
      });

      // Attach Yjs to Quill
      const binding = new QuillBinding(yText, quill, yProvider.awareness);
      ```
    </StepContent>

  </Step>

  <Step lastStep>
    <StepTitle>Next: set up authentication</StepTitle>
    <StepContent>
      By default, Liveblocks is configured to work without an authentication endpoint
      where everyone automatically has access to rooms. This approach is great for
      prototyping and marketing pages where setting up your own security isnâ€™t always
      required. If you want to limit access to a room for certain users, youâ€™ll need
      to set up an authentication endpoint to enable permissions.

      <Button asChild className="not-markdown">
        <a href="/docs/authentication">
          Set up authentication
        </a>
      </Button>
    </StepContent>

  </Step>
</Steps>

## What to read next

Congratulations! You now have set up the foundation for your collaborative Quill
text editor inside your JavaScript application.

- [Yjs and Quill guides](/docs/guides?technologies=yjs%2Cquill)
- [@liveblocks/yjs API Reference](/docs/api-reference/liveblocks-yjs)
- [@liveblocks/client API Reference](/docs/api-reference/liveblocks-client)
- [Quill website](https://quilljs.com)

---
meta:
  title: "Get started with a Quill text editor using Liveblocks and React"
  parentTitle: "Quickstart"
  description:
    "Learn how to install a Quill text editor using Liveblocks and React"
---

Liveblocks is a realtime collaboration infrastructure for building performant
collaborative experiences. Follow the following steps to start adding
collaboration to your React application using the APIs from the
[`@liveblocks/yjs`](/docs/api-reference/liveblocks-yjs) package.

## Quickstart

<Steps>
  <Step>
    <StepTitle>Install Liveblocks, Yjs, and Quill</StepTitle>
    <StepContent>

      Every Liveblocks package should use the same version.

      ```bash trackEvent="install_liveblocks"
      npm install @liveblocks/client @liveblocks/react @liveblocks/yjs yjs quill quill-cursors react-quill y-quill
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Initialize the `liveblocks.config.ts` file</StepTitle>
    <StepContent>

      We can use this file later to [define types for our application](/docs/api-reference/liveblocks-react#Typing-your-data).

      ```bash
      npx create-liveblocks-app@latest --init --framework react
      ```

    </StepContent>

  </Step>

  <Step>
    <StepTitle>Set up the Liveblocks client</StepTitle>
    <StepContent>

      Liveblocks uses the concept of rooms, separate virtual spaces where people
      collaborate, and to create a realtime experience, multiple users must
      be connected to the same room. Set up a Liveblocks client with [`LiveblocksProvider`](/docs/api-reference/liveblocks-react#LiveblocksProvider), and join a room with [`RoomProvider`](/docs/api-reference/liveblocks-react#RoomProvider).

      ```tsx file="App.tsx" highlight="11-15"
      "use client";

      import {
        LiveblocksProvider,
        RoomProvider,
      } from "@liveblocks/react/suspense";
      import { Editor } from "./Editor";

      export default function App() {
        return (
          <LiveblocksProvider publicApiKey={"{{PUBLIC_KEY}}"}>
            <RoomProvider id="my-room">
              {/* ... */}
            </RoomProvider>
          </LiveblocksProvider>
        );
      }
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Join a Liveblocks room</StepTitle>
    <StepContent>

      After setting up the room, you can add collaborative components inside it, using
      [`ClientSideSuspense`](/docs/api-reference/liveblocks-react#ClientSideSuspense) to add loading spinners to your app.

      ```tsx file="App.tsx" highlight="14-16"
      "use client";

      import {
        LiveblocksProvider,
        RoomProvider,
        ClientSideSuspense,
      } from "@liveblocks/react/suspense";
      import { Editor } from "./Editor";

      export default function App() {
        return (
          <LiveblocksProvider publicApiKey={"{{PUBLIC_KEY}}"}>
            <RoomProvider id="my-room">
              <ClientSideSuspense fallback={<div>Loadingâ€¦</div>}>
                <Editor />
              </ClientSideSuspense>
            </RoomProvider>
          </LiveblocksProvider>
        );
      }
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Set up the collaborative Quill text editor</StepTitle>
    <StepContent>

      Now that we set up Liveblocks, we can start integrating Quill and Yjs in the `Editor.tsx` file.
      To make the editor collaborative, we can rely on `QuillBinding` and `QuillCursors`
      from `y-quill` and `quill-cursors`.

      ```tsx file="Editor.tsx"
      "use client";

      import Quill from "quill";
      import ReactQuill from "react-quill";
      import QuillCursors from "quill-cursors";
      import { QuillBinding } from "y-quill";
      import * as Y from "yjs";
      import { getYjsProviderForRoom } from "@liveblocks/yjs";
      import { useRoom } from "@/liveblocks.config";
      import { useCallback, useEffect, useRef, useState } from "react";

      Quill.register("modules/cursors", QuillCursors);

      // Collaborative text editor with simple rich text, live cursors, and live avatars
      export function CollaborativeEditor() {
        const room = useRoom();
        const yProvider = getYjsProviderForRoom(room);
        const yDoc = yProvider.getYDoc();
        const yText = yDoc.getText("quill");

        return <QuillEditor yText={yText} provider={yProvider} />;
      }

      type EditorProps = {
        yText: Y.Text;
        provider: any;
      };

      function QuillEditor({ yText, provider }: EditorProps) {
        const reactQuillRef = useRef<ReactQuill>(null);

        // Set up Yjs and Quill
        useEffect(() => {
          let quill;
          let binding: QuillBinding;

          if (!reactQuillRef.current) {
            return;
          }

          quill = reactQuillRef.current.getEditor();
          binding = new QuillBinding(yText, quill, provider.awareness);
          return () => {
            binding?.destroy?.();
          };
        }, [yText, provider]);

        return (
          <ReactQuill
            placeholder="Start typing hereâ€¦"
            ref={reactQuillRef}
            theme="snow"
            modules={{
              cursors: true,
              history: {
                // Local undo shouldn't undo changes from remote users
                userOnly: true,
              },
            }}
          />
        );
      }
      ```

    </StepContent>

  </Step>

  <Step lastStep>
    <StepTitle>Next: set up authentication</StepTitle>
    <StepContent>
      By default, Liveblocks is configured to work without an authentication endpoint
      where everyone automatically has access to rooms. This approach is great for
      prototyping and marketing pages where setting up your own security isnâ€™t always
      required. If you want to limit access to a room for certain users, youâ€™ll need
      to set up an authentication endpoint to enable permissions.

      <Button asChild className="not-markdown">
        <a href="/docs/authentication">
          Set up authentication
        </a>
      </Button>
    </StepContent>

  </Step>

</Steps>

## What to read next

Congratulations! You now have set up the foundation for your collaborative Quill
text editor inside your React application.

- [Yjs and Quill guides](/docs/guides?technologies=yjs%2Cquill)
- [How to create a collaborative text editor with Quill, Yjs, Next.js, and Liveblocks](/docs/guides/how-to-create-a-collaborative-text-editor-with-quill-yjs-nextjs-and-liveblocks)
- [@liveblocks/yjs API Reference](/docs/api-reference/liveblocks-yjs)
- [Quill website](https://quilljs.com)

---

## Examples using Quill

<ListGrid columns={2}>
  <ExampleCard
    example={{
      title: "Collaborative Text Editor",
      slug: "collaborative-text-editor/nextjs-yjs-quill",
      image: "/images/examples/thumbnails/text-editor.jpg",
    }}
    technologies={["nextjs"]}
    openInNewWindow
  />
</ListGrid>

---
meta:
  title: "Get started with a Quill text editor using Liveblocks and Svelte"
  parentTitle: "Quickstart"
  description:
    "Learn how to install a Quill text editor using Liveblocks and Svelte"
---

Liveblocks is a realtime collaboration infrastructure for building performant
collaborative experiences. Follow the following steps to start adding
collaboration to your Svelte application using the APIs from the
[`@liveblocks/yjs`](/docs/api-reference/liveblocks-yjs) package.

## Quickstart

<Steps>
  <Step>
    <StepTitle>Install Liveblocks, Yjs, and Quill</StepTitle>
    <StepContent>

      Every Liveblocks package should use the same version.

      ```bash trackEvent="install_liveblocks"
      npm install @liveblocks/client @liveblocks/yjs yjs quill quill-cursors y-quill
      ```
    </StepContent>

  </Step>

  <Step>
    <StepTitle>Initialize the `liveblocks.config.ts` file</StepTitle>
    <StepContent>

      We can use this file later to [define types for our application](/docs/api-reference/liveblocks-client#Typing-your-data).

      ```bash
      npx create-liveblocks-app@latest --init --framework javascript
      ```

    </StepContent>

  </Step>

  <Step>
    <StepTitle>Set up your collaborative Quill text editor</StepTitle>
    <StepContent>

      ```html file="Editor.svelte"
      <script>
      import { onMount, onDestroy } from "svelte";
      import { createClient } from "@liveblocks/client";
      import { getYjsProviderForRoom } from "@liveblocks/yjs";
      import * as Y from "yjs";
      import Quill from "quill";
      import { QuillBinding } from "y-quill";
      import QuillCursors from "quill-cursors";

      let element;

      // Set up Liveblocks client
      const client = createClient({
        publicApiKey: "{{PUBLIC_KEY}}",
      });

      onMount(() => {
        // Enter a multiplayer room
        const { room, leave } = client.enterRoom("my-room");

        // Set up Yjs document, shared text, and Liveblocks Yjs provider
        const yProvider = getYjsProviderForRoom(room);
        const yDoc = yProvider.getYDoc();
        const yText = yDoc.getText("quill");

        // Attach cursors plugin
        Quill.register("modules/cursors", QuillCursors);

        // Set up Quill editor and modules
        const quill = new Quill(element, {
          placeholder: "Start collaboratingâ€¦",
          theme: "snow",
          modules: {
            cursors: true,
            toolbar: [
              [{ header: [1, 2, false] }],
              ["bold", "italic", "underline"],
              ["code-block"],
            ],
            history: {
              // Local undo shouldnâ€™t undo changes made by other users
              userOnly: true,
            },
          },
        });

        // Attach Yjs to Quill
        const binding = new QuillBinding(yText, quill, yProvider.awareness);

        return () => {
          binding.destroy();
          leave();
        };
      });
      </script>

      <div bind:this={element}></div>
      ```
    </StepContent>

  </Step>

  <Step lastStep>
    <StepTitle>Next: set up authentication</StepTitle>
    <StepContent>
      By default, Liveblocks is configured to work without an authentication endpoint
      where everyone automatically has access to rooms. This approach is great for
      prototyping and marketing pages where setting up your own security isnâ€™t always
      required. If you want to limit access to a room for certain users, youâ€™ll need
      to set up an authentication endpoint to enable permissions.

      <Button asChild className="not-markdown">
        <a href="/docs/authentication">
          Set up authentication
        </a>
      </Button>
    </StepContent>

  </Step>
</Steps>

## What to read next

Congratulations! You now have set up the foundation for your collaborative Quill
text editor inside your Svelte application.

- [@liveblocks/yjs API Reference](/docs/api-reference/liveblocks-yjs)
- [@liveblocks/client API Reference](/docs/api-reference/liveblocks-client)
- [Quill website](https://quilljs.com)

---
meta:
  title: "Get started with a Quill text editor using Liveblocks and Vue.js"
  parentTitle: "Quickstart"
  description:
    "Learn how to install a Quill text editor using Liveblocks and Vue.js"
---

Liveblocks is a realtime collaboration infrastructure for building performant
collaborative experiences. Follow the following steps to start adding
collaboration to your Vue.js application using the APIs from the
[`@liveblocks/yjs`](/docs/api-reference/liveblocks-yjs) package.

## Quickstart

<Steps>
  <Step>
    <StepTitle>Install Liveblocks, Yjs, and Quill</StepTitle>
    <StepContent>

      Every Liveblocks package should use the same version.

      ```bash trackEvent="install_liveblocks"
      npm install @liveblocks/client @liveblocks/yjs yjs quill quill-cursors y-quill
      ```
    </StepContent>

  </Step>

  <Step>
    <StepTitle>Initialize the `liveblocks.config.ts` file</StepTitle>
    <StepContent>

      We can use this file later to [define types for our application](/docs/api-reference/liveblocks-client#Typing-your-data).

      ```bash
      npx create-liveblocks-app@latest --init --framework javascript
      ```

    </StepContent>

  </Step>

  <Step>
    <StepTitle>Set up your collaborative Quill text editor</StepTitle>
    <StepContent>

      ```html file="Editor.vue"
      <script setup>
      import { ref, onMounted, onUnmounted } from "vue";
      import { createClient } from "@liveblocks/client";
      import { getYjsProviderForRoom } from "@liveblocks/yjs";
      import * as Y from "yjs";
      import Quill from "quill";
      import { QuillBinding } from "y-quill";
      import QuillCursors from "quill-cursors";

      const element = ref(null);
      const binding = ref(null);
      const leave = ref(null);

      // Set up Liveblocks client
      const client = createClient({
        publicApiKey: "{{PUBLIC_KEY}}",
      });

      // Enter a multiplayer room
      const info = client.enterRoom("my-room");
      const room = info.room;
      leave.value = info.leave;

      // Set up Yjs document, shared text, and Liveblocks Yjs provider
      const yProvider = getYjsProviderForRoom(room);
      const yDoc = yProvider.getYDoc();
      const yText = yDoc.getText("quill");

      // Attach cursors plugin
      Quill.register("modules/cursors", QuillCursors);

      onMounted(() => {
        // Set up Quill editor and modules
        const quill = new Quill(element.value, {
          placeholder: "Start collaboratingâ€¦",
          theme: "snow",
          modules: {
            cursors: true,
            toolbar: [
              [{ header: [1, 2, false] }],
              ["bold", "italic", "underline"],
              ["code-block"],
            ],
            history: {
              // Local undo shouldnâ€™t undo changes made by other users
              userOnly: true,
            },
          },
        });

        // Attach Yjs to Quill
        binding.value = new QuillBinding(yText, quill, yProvider.awareness);
      });

      onUnmounted(() => {
        binding?.destroy?.();
        leave?.();
      });
      </script>

      <template>
        <div ref="element" />
      </template>
      ```
    </StepContent>

  </Step>

  <Step lastStep>
    <StepTitle>Next: set up authentication</StepTitle>
    <StepContent>
      By default, Liveblocks is configured to work without an authentication endpoint
      where everyone automatically has access to rooms. This approach is great for
      prototyping and marketing pages where setting up your own security isnâ€™t always
      required. If you want to limit access to a room for certain users, youâ€™ll need
      to set up an authentication endpoint to enable permissions.

      <Button asChild className="not-markdown">
        <a href="/docs/authentication">
          Set up authentication
        </a>
      </Button>
    </StepContent>

  </Step>
</Steps>

## What to read next

Congratulations! You now have set up the foundation for your collaborative Quill
text editor inside your Vue.js application.

- [@liveblocks/yjs API Reference](/docs/api-reference/liveblocks-yjs)
- [@liveblocks/client API Reference](/docs/api-reference/liveblocks-client)
- [Quill website](https://quilljs.com)

---
meta:
  title: "Get started with a Slate text editor using Liveblocks and React"
  parentTitle: "Quickstart"
  description:
    "Learn how to install a Slate text editor using Liveblocks and React"
---

Liveblocks is a realtime collaboration infrastructure for building performant
collaborative experiences. Follow the following steps to start adding
collaboration to your React application using the APIs from the
[`@liveblocks/yjs`](/docs/api-reference/liveblocks-yjs) package.

## Quickstart

<Steps>
  <Step>
    <StepTitle>Install Liveblocks, Yjs, and Slate</StepTitle>
    <StepContent>

      Every Liveblocks package should use the same version.

      ```bash trackEvent="install_liveblocks"
      npm install @liveblocks/client @liveblocks/react @liveblocks/yjs yjs slate slate-react @slate-yjs/core
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Initialize the `liveblocks.config.ts` file</StepTitle>
    <StepContent>

      We can use this file later to [define types for our application](/docs/api-reference/liveblocks-react#Typing-your-data).

      ```bash
      npx create-liveblocks-app@latest --init --framework react
      ```

    </StepContent>

  </Step>

  <Step>
    <StepTitle>Set up the Liveblocks client</StepTitle>
    <StepContent>

      Liveblocks uses the concept of rooms, separate virtual spaces where people
      collaborate, and to create a realtime experience, multiple users must
      be connected to the same room. Set up a Liveblocks client with [`LiveblocksProvider`](/docs/api-reference/liveblocks-react#LiveblocksProvider), and join a room with [`RoomProvider`](/docs/api-reference/liveblocks-react#RoomProvider).

      ```tsx file="App.tsx" highlight="11-15"
      "use client";

      import {
        LiveblocksProvider,
        RoomProvider,
      } from "@liveblocks/react/suspense";
      import { Editor } from "./Editor";

      export default function App() {
        return (
          <LiveblocksProvider publicApiKey={"{{PUBLIC_KEY}}"}>
            <RoomProvider id="my-room">
              {/* ... */}
            </RoomProvider>
          </LiveblocksProvider>
        );
      }
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Join a Liveblocks room</StepTitle>
    <StepContent>

      After setting up the room, you can add collaborative components inside it, using
      [`ClientSideSuspense`](/docs/api-reference/liveblocks-react#ClientSideSuspense) to add loading spinners to your app.

      ```tsx file="App.tsx" highlight="14-16"
      "use client";

      import {
        LiveblocksProvider,
        RoomProvider,
        ClientSideSuspense,
      } from "@liveblocks/react/suspense";
      import { CollaborativeEditor } from "./CollaborativeEditor";

      export default function App() {
        return (
          <LiveblocksProvider publicApiKey={"{{PUBLIC_KEY}}"}>
            <RoomProvider id="my-room">
              <ClientSideSuspense fallback={<div>Loadingâ€¦</div>}>
                <CollaborativeEditor />
              </ClientSideSuspense>
            </RoomProvider>
          </LiveblocksProvider>
        );
      }
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Set up the collaborative Slate text editor</StepTitle>
    <StepContent>

      Now that we set up Liveblocks, we can start integrating Slate and Yjs in the `CollaborativeEditor.tsx` file.
      To make the editor collaborative, we can rely on `withYjs` from `@slate-yjs/core`.

      ```tsx file="CollaborativeEditor.tsx"
      "use client";

      import { getYjsProviderForRoom } from "@liveblocks/yjs";
      import { useEffect, useMemo, useState } from "react";
      import { createEditor, Editor, Transforms } from "slate";
      import { Editable, Slate, withReact } from "slate-react";
      import { withYjs, YjsEditor } from "@slate-yjs/core";
      import * as Y from "yjs";
      import { useRoom } from "../liveblocks.config";
      import styles from "./CollaborativeEditor.module.css";

      export function CollaborativeEditor() {
        const room = useRoom();
        const [connected, setConnected] = useState(false);

        // Set up Yjs
        const yProvider = getYjsProviderForRoom(room);
        const yDoc = yProvider.getYDoc();
        const sharedType = yDoc.get("slate", Y.XmlText) as Y.XmlText;

        useEffect(() => {
          yProvider.on("sync", setConnected);

          return () => {
            yProvider?.off("sync", setConnected);
          };
        }, [room]);

        if (!connected || !sharedType) {
          return <div>Loadingâ€¦</div>;
        }

        return <SlateEditor sharedType={sharedType} />;
      }

      const emptyNode = {
        children: [{ text: "" }],
      };

      function SlateEditor({ sharedType }: { sharedType: Y.XmlText }) {
        const editor = useMemo(() => {
          const e = withReact(withYjs(createEditor(), sharedType));

          // Ensure editor always has at least 1 valid child
          const { normalizeNode } = e;
          e.normalizeNode = (entry) => {
            const [node] = entry;

            if (!Editor.isEditor(node) || node.children.length > 0) {
              return normalizeNode(entry);
            }

            Transforms.insertNodes(editor, emptyNode, { at: [0] });
          };

          return e;
        }, []);

        useEffect(() => {
          YjsEditor.connect(editor);
          return () => YjsEditor.disconnect(editor);
        }, [editor]);

        return (
          <div className={styles.container}>
            <div className={styles.editorContainer}>
              <Slate editor={editor} initialValue={[emptyNode]}>
                <Editable className={styles.editor} placeholder="Start typing hereâ€¦" />
              </Slate>
            </div>
          </div>
        );
      }
      ```

      And here is the `Editor.module.css` file to make sure your multiplayer text editor looks nice and tidy.

      ```css file="CollaborativeEditor.module.css" isCollapsed isCollapsable
      .container {
        display: flex;
        flex-direction: column;
        position: relative;
        border-radius: 12px;
        background: #fff;
        width: 100%;
        height: 100%;
        color: #111827;
      }

      .editor {
        border-radius: inherit;
        flex-grow: 1;
        width: 100%;
        height: 100%;
      }

      .editor:focus {
        outline: none;
      }

      .editorContainer {
        position: relative;
        padding: 1em;
        height: 100%;
      }

      .editor p {
        margin: 1em 0;
      }
      ```
    </StepContent>

  </Step>

  <Step lastStep>
    <StepTitle>Next: set up authentication</StepTitle>
    <StepContent>
      By default, Liveblocks is configured to work without an authentication
      endpoint. This approach is great for prototyping and marketing pages
      where defining your own security isnâ€™t always required. If you want to
      implement your own security logic to define if certain users should
      have access to a given room, youâ€™ll need to implement an
      authentication endpoint.

      <Button asChild className="not-markdown">
        <a href="/docs/authentication">
          Set up authentication
        </a>
      </Button>
    </StepContent>

  </Step>

</Steps>

## What to read next

Congratulations! You now have set up the foundation for your collaborative Slate
text editor inside your React application.

- [Yjs and Slate guides](/docs/guides?technologies=yjs%2Cslate)
- [How to create a collaborative text editor with Slate, Yjs, Next.js, and Liveblocks](/docs/guides/how-to-create-a-collaborative-text-editor-with-slate-yjs-nextjs-and-liveblocks)
- [@liveblocks/yjs API Reference](/docs/api-reference/liveblocks-yjs)
- [Slate website](https://docs.slatejs.org/)

---

## Examples using Slate

<ListGrid columns={2}>
  <ExampleCard
    example={{
      title: "Collaborative Text Editor",
      slug: "collaborative-text-editor/nextjs-yjs-slate",
      image: "/images/examples/thumbnails/text-editor.jpg",
    }}
    technologies={["nextjs"]}
    openInNewWindow
  />
</ListGrid>

---
meta:
  title: "Get started with a Tiptap text editor using Liveblocks and JavaScript"
  parentTitle: "Quickstart"
  description:
    "Learn how to install a Tiptap text editor using Liveblocks and JavaScript"
---

Liveblocks is a realtime collaboration infrastructure for building performant
collaborative experiences. Follow the following steps to start adding
collaboration to your JavaScript application using the APIs from the
[`@liveblocks/yjs`](/docs/api-reference/liveblocks-yjs) package.

## Quickstart

<Steps>
  <Step>
    <StepTitle>Install Liveblocks, Yjs, and Tiptap</StepTitle>
    <StepContent>

      Every Liveblocks package should use the same version.

      ```bash trackEvent="install_liveblocks"
      npm install @liveblocks/client @liveblocks/yjs yjs @tiptap/core @tiptap/pm @tiptap/starter-kit @tiptap/extension-collaboration @tiptap/extension-collaboration-cursor y-prosemirror
      ```
    </StepContent>

  </Step>

  <Step>
    <StepTitle>Initialize the `liveblocks.config.ts` file</StepTitle>
    <StepContent>

      We can use this file later to [define types for our application](/docs/api-reference/liveblocks-client#Typing-your-data).

      ```bash
      npx create-liveblocks-app@latest --init --framework javascript
      ```

    </StepContent>

  </Step>

  <Step>
    <StepTitle>Create an HTML element</StepTitle>
    <StepContent>

      ```html
      <div id="editor"></div>
      ```

    </StepContent>

  </Step>

  <Step>
    <StepTitle>Set up your collaborative Tiptap text editor</StepTitle>
    <StepContent>

      ```js file="app.js"
      import { createClient } from "@liveblocks/client";
      import { getYjsProviderForRoom } from "@liveblocks/yjs";
      import * as Y from "yjs";
      import { Editor } from "@tiptap/core";
      import StarterKit from "@tiptap/starter-kit";
      import Collaboration from "@tiptap/extension-collaboration";
      import CollaborationCursor from "@tiptap/extension-collaboration-cursor";

      // Set up Liveblocks client
      const client = createClient({
        publicApiKey: "{{PUBLIC_KEY}}",
      });

      // Enter a multiplayer room
      const { room, leave } = client.enterRoom("my-room");

      // Set up Yjs document and Liveblocks Yjs provider
      const yProvider = getYjsProviderForRoom(room);
      const yDoc = yProvider.getYDoc();

      // Set up the Tiptap editor
      const element = document.querySelector("#editor");
      const editor = new Editor({
        element,
        extensions: [
          StarterKit.configure({
            // The Collaboration extension comes with its own history handling
            undoRedo: false,
          }),
          // Register the Yjs document with Tiptap
          Collaboration.configure({
            document: yDoc,
          }),
          CollaborationCursor.configure({
            provider: yProvider,
          }),
        ],
      });
      ```
    </StepContent>

  </Step>

  <Step lastStep>
    <StepTitle>Next: set up authentication</StepTitle>
    <StepContent>
      By default, Liveblocks is configured to work without an authentication endpoint
      where everyone automatically has access to rooms. This approach is great for
      prototyping and marketing pages where setting up your own security isnâ€™t always
      required. If you want to limit access to a room for certain users, youâ€™ll need
      to set up an authentication endpoint to enable permissions.

      <Button asChild className="not-markdown">
        <a href="/docs/authentication">
          Set up authentication
        </a>
      </Button>
    </StepContent>

  </Step>
</Steps>

## What to read next

Congratulations! You now have set up the foundation for your collaborative
Tiptap text editor inside your JavaScript application.

- [@liveblocks/yjs API Reference](/docs/api-reference/liveblocks-yjs)
- [@liveblocks/client API Reference](/docs/api-reference/liveblocks-client)
- [Tiptap website](https://tiptap.dev)

---
meta:
  title: "Get started with a Tiptap text editor using Liveblocks and Svelte"
  parentTitle: "Quickstart"
  description:
    "Learn how to install a Tiptap text editor using Liveblocks and Svelte"
---

Liveblocks is a realtime collaboration infrastructure for building performant
collaborative experiences. Follow the following steps to start adding
collaboration to your Svelte application using the APIs from the
[`@liveblocks/yjs`](/docs/api-reference/liveblocks-yjs) package.

## Quickstart

<Steps>
  <Step>
    <StepTitle>Install Liveblocks, Yjs, and Tiptap</StepTitle>
    <StepContent>

      Every Liveblocks package should use the same version.

      ```bash trackEvent="install_liveblocks"
      npm install @liveblocks/client @liveblocks/yjs yjs @tiptap/core @tiptap/pm @tiptap/starter-kit @tiptap/extension-collaboration @tiptap/extension-collaboration-cursor y-prosemirror
      ```
    </StepContent>

  </Step>

  <Step>
    <StepTitle>Initialize the `liveblocks.config.ts` file</StepTitle>
    <StepContent>

      We can use this file later to [define types for our application](/docs/api-reference/liveblocks-client#Typing-your-data).

      ```bash
      npx create-liveblocks-app@latest --init --framework javascript
      ```

    </StepContent>

  </Step>

  <Step>
    <StepTitle>Set up your collaborative Tiptap text editor</StepTitle>
    <StepContent>

      ```html file="Editor.svelte"
      <script>
      import { onMount, onDestroy } from "svelte";
      import { createClient } from "@liveblocks/client";
      import { getYjsProviderForRoom } from "@liveblocks/yjs";
      import * as Y from "yjs";
      import { Editor } from "@tiptap/core";
      import StarterKit from "@tiptap/starter-kit";
      import Collaboration from "@tiptap/extension-collaboration";
      import CollaborationCursor from "@tiptap/extension-collaboration-cursor";

      let element;

      // Set up Liveblocks client
      const client = createClient({
        publicApiKey: "{{PUBLIC_KEY}}",
      });

      onMount(() => {
        // Enter a multiplayer room
        const { room, leave } = client.enterRoom("my-room");

        // Set up Yjs document and Liveblocks Yjs provider
        const yProvider = getYjsProviderForRoom(room);
        const yDoc = yProvider.getYDoc();

        // Set up the Tiptap editor
        editor = new Editor({
          element,
          extensions: [
            StarterKit.configure({
              // The Collaboration extension comes with its own history handling
              undoRedo: false,
            }),
            // Register the Yjs document with Tiptap
            Collaboration.configure({
              document: yDoc,
            }),
            CollaborationCursor.configure({
              provider: yProvider,
            }),
          ],
          onTransaction: () => {
            // Force re-render so `editor.isActive` works as expected
            editor = editor
          },
        });

        return () => {
          editor.destroy();
          leave();
        };
      });
      </script>

      <div bind:this={element}></div>
      ```
    </StepContent>

  </Step>

  <Step lastStep>
    <StepTitle>Next: set up authentication</StepTitle>
    <StepContent>
      By default, Liveblocks is configured to work without an authentication endpoint
      where everyone automatically has access to rooms. This approach is great for
      prototyping and marketing pages where setting up your own security isnâ€™t always
      required. If you want to limit access to a room for certain users, youâ€™ll need
      to set up an authentication endpoint to enable permissions.

      <Button asChild className="not-markdown">
        <a href="/docs/authentication">
          Set up authentication
        </a>
      </Button>
    </StepContent>

  </Step>
</Steps>

## What to read next

Congratulations! You now have set up the foundation for your collaborative
Tiptap text editor inside your Svelte application.

- [@liveblocks/yjs API Reference](/docs/api-reference/liveblocks-yjs)
- [@liveblocks/client API Reference](/docs/api-reference/liveblocks-client)
- [Tiptap website](https://tiptap.dev)

---
meta:
  title: "Get started with a Tiptap text editor using Liveblocks and Vue.js"
  parentTitle: "Quickstart"
  description:
    "Learn how to install a Tiptap text editor using Liveblocks and Vue.js"
---

Liveblocks is a realtime collaboration infrastructure for building performant
collaborative experiences. Follow the following steps to start adding
collaboration to your Vue.js application using the APIs from the
[`@liveblocks/yjs`](/docs/api-reference/liveblocks-yjs) package.

## Quickstart

<Steps>
  <Step>
    <StepTitle>Install Liveblocks, Yjs, and Tiptap</StepTitle>
    <StepContent>

      Every Liveblocks package should use the same version.

      ```bash trackEvent="install_liveblocks"
      npm install @liveblocks/client @liveblocks/yjs yjs @tiptap/vue-3 @tiptap/pm @tiptap/starter-kit @tiptap/extension-collaboration @tiptap/extension-collaboration-cursor y-prosemirror
      ```
    </StepContent>

  </Step>

  <Step>
    <StepTitle>Initialize the `liveblocks.config.ts` file</StepTitle>
    <StepContent>

      We can use this file later to [define types for our application](/docs/api-reference/liveblocks-client#Typing-your-data).

      ```bash
      npx create-liveblocks-app@latest --init --framework javascript
      ```

    </StepContent>

  </Step>

  <Step>
    <StepTitle>Set up your collaborative Tiptap text editor</StepTitle>
    <StepContent>

      ```html file="Editor.vue"
      <script setup>
      import { onUnmounted } from "vue";
      import { createClient } from "@liveblocks/client";
      import { getYjsProviderForRoom } from "@liveblocks/yjs";
      import * as Y from "yjs";
      import { useEditor, EditorContent } from "@tiptap/vue-3";
      import StarterKit from "@tiptap/starter-kit";
      import Collaboration from "@tiptap/extension-collaboration";
      import CollaborationCursor from "@tiptap/extension-collaboration-cursor";

      const leave = ref(null);

      // Set up Liveblocks client
      const client = createClient({
        publicApiKey: "{{PUBLIC_KEY}}",
      });

      // Enter a multiplayer room
      const info = client.enterRoom("my-room");
      const room = info.room;
      leave.value = info.leave;

      // Set up Yjs document and Liveblocks Yjs provider
      const yProvider = getYjsProviderForRoom(room);
      const yDoc = yProvider.getYDoc();

      // Set up the Tiptap editor
      const editor = useEditor({
        element,
        extensions: [
          StarterKit.configure({
            // The Collaboration extension comes with its own history handling
            undoRedo: false,
          }),
          // Register the Yjs document with Tiptap
          Collaboration.configure({
            document: yDoc,
          }),
          CollaborationCursor.configure({
            provider: yProvider,
          }),
        ],
      });

      onUnmounted(() => {
        leave?.();
      });
      </script>

      <template>
        <editor-content :editor="editor" />
      </template>
      ```
    </StepContent>

  </Step>

  <Step lastStep>
    <StepTitle>Next: set up authentication</StepTitle>
    <StepContent>
      By default, Liveblocks is configured to work without an authentication endpoint
      where everyone automatically has access to rooms. This approach is great for
      prototyping and marketing pages where setting up your own security isnâ€™t always
      required. If you want to limit access to a room for certain users, youâ€™ll need
      to set up an authentication endpoint to enable permissions.

      <Button asChild className="not-markdown">
        <a href="/docs/authentication">
          Set up authentication
        </a>
      </Button>
    </StepContent>

  </Step>
</Steps>

## What to read next

Congratulations! You now have set up the foundation for your collaborative
Tiptap text editor inside your Vue.js application.

- [@liveblocks/yjs API Reference](/docs/api-reference/liveblocks-yjs)
- [@liveblocks/client API Reference](/docs/api-reference/liveblocks-client)
- [Tiptap website](https://tiptap.dev)

---
meta:
  title: "Get started with Liveblocks and Zustand"
  parentTitle: "Quickstart"
  description: "Learn how to get started with Liveblocks and Zustand"
---

Liveblocks is a realtime collaboration infrastructure for building performant
collaborative experiences. Follow the following steps to start making your
Zustand store multiplayer by using the middleware from the
[`@liveblocks/zustand`](/docs/api-reference/liveblocks-zustand) package.

## Quickstart

<Steps>
  <Step>
    <StepTitle>Install Liveblocks</StepTitle>
    <StepContent>

      Every Liveblocks package should use the same version.

      ```bash
      npm install @liveblocks/client @liveblocks/zustand
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Initialize the `liveblocks.config.ts` file</StepTitle>
    <StepContent>

      We can use this file later to [define types for our application](/docs/api-reference/liveblocks-react#Typing-your-data).

      ```bash
      npx create-liveblocks-app@latest --init --framework react
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Connect your Zustand store to Liveblocks</StepTitle>
    <StepContent>

      Create the Liveblocks client and use the `middleware` in your
      Zustand store setup. This will add a new state called{" "}
      `liveblocks` to your store, enabling you to interact with
      our Presence and Storage APIs.

      ```ts file="store.ts" highlight="12-14,17-22"
      "use client";

      import create from "zustand";
      import { createClient } from "@liveblocks/client";
      import { liveblocks } from "@liveblocks/zustand";
      import type { WithLiveblocks } from "@liveblocks/zustand";

      type State = {
        // Your Zustand state type will be defined here
      };

      const client = createClient({
        publicApiKey: "pk_prod_xxxxxxxxxxxxxxxxxxxxxxxx",
      });

      const useStore = create<WithLiveblocks<State>>()(
        liveblocks(
          (set) => ({
            // Your state and actions will go here
          }),
          { client }
        )
      );

      export default useStore;
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Join a Liveblocks room</StepTitle>
    <StepContent>

      Liveblocks uses the concept of rooms, separate virtual spaces where people collaborate.
      To create a realtime experience, multiple users must be connected to the same room.

      ```tsx file="App.tsx" highlight="13,15"
      "use client";

      import React, { useEffect } from "react";
      import useStore from "./store";
      import "./App.css";

      const App = () => {
        const {
          liveblocks: { enterRoom, leaveRoom },
        } = useStore();

        useEffect(() => {
          enterRoom("room-id");
          return () => {
            leaveRoom("room-id");
          };
        }, [enterRoom, leaveRoom]);

        return <Room />;
      };

      export default App;
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Use the Liveblocks data from the store</StepTitle>
    <StepContent>

      Now that weâ€™re connected to a room, we can start using the Liveblocks data from the Zustand store.

      ```tsx file="Room.tsx" highlight="6"
      "use client";

      import useStore from "./store";

      export function Room() {
        const others = useStore((state) => state.liveblocks.others);
        const userCount = others.length;
        return <div>There are {userCount} other user(s) online</div>;
      }
      ```

    </StepContent>

  </Step>
  <Step lastStep>
    <StepTitle>Next: set up authentication</StepTitle>
    <StepContent>
      By default, Liveblocks is configured to work without an authentication endpoint
      where everyone automatically has access to rooms. This approach is great for
      prototyping and marketing pages where setting up your own security isnâ€™t always
      required. If you want to limit access to a room for certain users, youâ€™ll need
      to set up an authentication endpoint to enable permissions.

      <Button asChild className="not-markdown">
        <a href="/docs/authentication">
          Set up authentication
        </a>
      </Button>
    </StepContent>

  </Step>
</Steps>

## What to read next

Congratulations! You now have set up the foundation to start building
collaborative experiences for your Zustand store.

- [@liveblocks/zustand API Reference](/docs/api-reference/liveblocks-zustand)
- [Zustand guides](/docs/guides?technologies=zustand)
- [How to use Liveblocks Presence with Zustand](/docs/guides/how-to-use-liveblocks-presence-with-zustand)
- [How to use Liveblocks Storage with Zustand](/docs/guides/how-to-use-liveblocks-storage-with-zustand)

---

## Examples using Zustand

<ListGrid columns={2}>
  <ExampleCard
    example={{
      title: "Collaborative To-do List",
      slug: "collaborative-todo-list/zustand-todo-list",
      image: "/images/examples/thumbnails/collaborative-todo-list.jpg",
    }}
    technologies={["nextjs", "vuejs", "sveltekit", "solidjs", "javascript"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Collaborative Whiteboard",
      slug: "collaborative-whiteboard/zustand-whiteboard",
      image: "/images/examples/thumbnails/collaborative-whiteboard.jpg",
      advanced: true,
    }}
    technologies={["nextjs", "redux", "zustand"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Collaborative Flowchart",
      slug: "collaborative-flowchart/zustand-flowchart",
      image: "/images/examples/thumbnails/collaborative-flowchart.jpg",
      advanced: true,
    }}
    technologies={["zustand"]}
    openInNewWindow
  />
</ListGrid>

---
meta:
  title: "Documentation"
  description:
    "Explore the documentation to learn how to build collaborative experiences
    with Liveblocks."
showTitle: false
---

<DocsHomepageHero
  title="Documentation"
  description="Liveblocks gives you the building blocks and infrastructure to enable people and AI to work together inside your app."
  actions={[
    {
      title: "Get started",
      href: "/docs/get-started",
      appearance: "primary",
    },
    {
      title: "Browse examples",
      href: "/examples",
    },
  ]}
/>

<DocsHomepageGrid />

## Ready-made features

<ListGrid columns={2}>
  <DocsCardFeature
    feature="comments"
    href="/docs/ready-made-features/comments"
  />
  <DocsCardFeature
    feature="multiplayer"
    href="/docs/ready-made-features/multiplayer"
  />
  <DocsCardFeature
    feature="ai-agents"
    href="/docs/ready-made-features/ai-agents"
  />
  <DocsCardFeature
    feature="notifications"
    href="/docs/ready-made-features/notifications"
  />
</ListGrid>

## SDKs and packages

<ListGrid columns={2}>
  <DocsCard
    type="technology"
    title="JavaScript"
    href="/docs/api-reference/liveblocks-client"
    description="@liveblocks/client"
    visual={<DocsJavascriptIcon />}
  />
  <DocsCard
    type="technology"
    title="React"
    href="/docs/api-reference/liveblocks-react"
    description="@liveblocks/react"
    visual={<DocsReactIcon />}
  />
  <DocsCard
    type="technology"
    title="React UI"
    href="/docs/api-reference/liveblocks-react-ui"
    description="@liveblocks/react-ui"
    visual={<DocsReactIcon />}
  />
  <DocsCard
    type="technology"
    title="React Tiptap"
    href="/docs/api-reference/liveblocks-react-tiptap"
    description="@liveblocks/react-tiptap"
    visual={<DocsReactIcon />}
  />
  <DocsCard
    type="technology"
    title="React BlockNote"
    href="/docs/api-reference/liveblocks-react-blocknote"
    description="@liveblocks/react-blocknote"
    visual={<DocsReactIcon />}
  />
  <DocsCard
    type="technology"
    title="Node.js ProseMirror"
    href="/docs/api-reference/liveblocks-node-prosemirror"
    description="@liveblocks/node-prosemirror"
    visual={<DocsNodejsIcon />}
  />
  <DocsCard
    type="technology"
    title="React Lexical"
    href="/docs/api-reference/liveblocks-react-lexical"
    description="@liveblocks/react-lexical"
    visual={<DocsReactIcon />}
  />
  <DocsCard
    type="technology"
    title="Node.js Lexical"
    href="/docs/api-reference/liveblocks-node-lexical"
    description="@liveblocks/node-lexical"
    visual={<DocsNodejsIcon />}
  />
  <DocsCard
    type="technology"
    title="Redux"
    href="/docs/api-reference/liveblocks-redux"
    description="@liveblocks/redux"
    visual={<DocsReduxIcon />}
  />
  <DocsCard
    type="technology"
    title="Zustand"
    href="/docs/api-reference/liveblocks-zustand"
    description="@liveblocks/zustand"
    visual={
      <img
        alt=""
        src="/assets/zustand.png"
        width={24}
        height={24}
        loading="lazy"
      />
    }
  />
  <DocsCard
    type="technology"
    title="Yjs"
    href="/docs/api-reference/liveblocks-yjs"
    description="@liveblocks/yjs"
    visual={<DocsYjsIcon className="fill-product-icon-brand h-auto w-6" />}
  />
  <DocsCard
    type="technology"
    title="Node.js"
    href="/docs/api-reference/liveblocks-node"
    description="@liveblocks/node"
    visual={<DocsNodejsIcon />}
  />
  <DocsCard
    type="technology"
    title="Node.js Emails"
    href="/docs/api-reference/liveblocks-emails"
    description="@liveblocks/emails"
    visual={<DocsNodejsIcon />}
  />
  <DocsCard
    type="technology"
    title="REST API"
    href="/docs/api-reference/rest-api-endpoints"
    description="HTTP endpoints"
    visual={<DocsApiIcon className="fill-product-icon-brand h-auto w-6" />}
  />
</ListGrid>

## Examples

<ListGrid columns={2}>
  <ExampleCard
    example={{
      title: "AI Popup Chat",
      slug: "ai-popup/nextjs-ai-popup",
      image: "/images/examples/thumbnails/ai-popup.jpg",
    }}
    technologies={["nextjs", "react"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "AI Chats",
      slug: "ai-chats/nextjs-ai-chats",
      image: "/images/examples/thumbnails/ai-chats.jpg",
    }}
    technologies={["nextjs", "react"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Advanced Collaborative Text Editor",
      slug: "collaborative-text-editor-advanced/nextjs-tiptap-advanced",
      image: "/images/examples/thumbnails/text-editor-advanced.jpg",
    }}
    technologies={["nextjs"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Comments Notifications",
      slug: "comments-notifications",
      image: "/images/examples/thumbnails/comments-notifications.png",
    }}
    technologies={["nextjs"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Live Cursors",
      slug: "live-cursors",
      image: "/images/examples/thumbnails/live-cursors.jpg",
    }}
    technologies={["nextjs", "vuejs", "sveltekit", "solidjs", "javascript"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Collaborative Whiteboard",
      slug: "collaborative-whiteboard-advanced",
      image:
        "/images/examples/thumbnails/collaborative-whiteboard-advanced.jpg",
      advanced: true,
    }}
    technologies={["nextjs"]}
    openInNewWindow
  />
</ListGrid>

## Community

<ListGrid columns={3}>
  <DocsCard
    title="X"
    href="https://x.com/liveblocks"
    description="Follow us on X for the latest news and updates."
    visual={<DocsXIcon />}
    openInNewWindow
  />
  <DocsCard
    title="Discord"
    href="https://liveblocks.io/discord"
    description="Join hundreds of developers building with Liveblocks."
    visual={<DocsDiscordIcon />}
    openInNewWindow
  />
  <DocsCard
    title="GitHub"
    href="https://github.com/liveblocks/liveblocks"
    description="Follow progress and contribute to the codebase."
    visual={<DocsGithubIcon />}
    openInNewWindow
  />
</ListGrid>

---
meta:
  title: "Account management"
  parentTitle: "Platform"
  description: "Learn how to manage your Liveblocks account and team members."
---

In this section, you'll learn everything you need to manage your Liveblocks
accounts and teams.

<ListGrid columns={2}>
  <DocsCard
    title="Create an account"
    href="/docs/platform/account-management/create-an-account"
    description="Set up your Liveblocks account and get started"
  />
  <DocsCard
    title="Manage team members"
    href="/docs/platform/account-management/manage-team-members"
    description="Manage team members in your workspace"
  />
  <DocsCard
    title="Configure SSO"
    href="/docs/platform/account-management/saml"
    description="Set up SAML Single Sign-on for your organization"
  />
  <DocsCard
    title="Configure directory sync"
    href="/docs/platform/account-management/directory-sync"
    description="Sync users and groups from your directory service"
  />
  <DocsCard
    title="Delete an account"
    href="/docs/platform/account-management/delete-an-account"
    description="Permanently delete your Liveblocks account"
  />
</ListGrid>

---
meta:
  title: "Create an account"
  parentTitle: "Platform"
  description: "Learn how to create a Liveblocks account."
---

When you create a new account with Liveblocks, youâ€™re automatically creating a
team account on a Starter plan. This plan is free to use (subject to the
[Fair Use Policy](/docs/platform/limits/fair-use-policy)) forever. You cannot
invite others to collaborate on your Liveblocks team account until you upgrade
to a paid plan.

To create a new account, visit [liveblocks.io/signup](/auth/signup). You can
choose to sign up with your email address, or with a GitHub or Google provider.

<Figure>
  <Image
    src="/assets/account-management/sign-up.png"
    alt="Create a Liveblocks account"
    width={768}
    height={406}
  />
</Figure>

### Sign up with email

If you choose to sign up with your email address, youâ€™ll be prompted to enter it
in a form. After signing up, you can then verify your new account by clicking a
link in an email Liveblocks sends you. In future, when signing in with your
email, youâ€™ll be asked to verify your account every time you log in.

### Sign up with a provider

If you choose to sign up with Google or GitHub provider, you will be asked to
authorize Liveblocks to access your provider account. This connection will then
become the default login connection on your account.

---
meta:
  title: "Delete an account"
  parentTitle: "Platform"
  description: "Learn how to delete your Liveblocks account and data."
---

<Banner type="warning">

Please note that this action is **irreversible**. All data associated with your
account will be permanently deleted, and any applications running on Liveblocks
will stop working.

</Banner>

To delete your account, click on the user dropdown in the Liveblocks dashboard
and go to **Personal settings**. Once there, click **Delete account** and follow
the on-screen instructions to confirm deletion.

<Figure>
  <Image
    src="/assets/account-management/delete-account.png"
    alt="Delete your Liveblocks account"
    width={768}
    height={406}
  />
</Figure>

## Getting help

If you need further assistance with account deletion or have questions about
what data will be removed, contact us at
[support@liveblocks.io](mailto:support@liveblocks.io).

---
meta:
  title: "Directory sync"
  parentTitle: "Platform"
  description: "Learn how to set up directory sync on your Liveblocks account."
---

<Banner>
  This feature is available as an add-on to Enterprise customers. Reach out to
  [sales@liveblocks.io](mailto:sales@liveblocks.io) to enable it on your
  account.
</Banner>

_Directory sync_ helps teams manage their organization membership from a
third-party identity provider like Google Directory or Okta. To use directory
sync, [SSO must be configured first](/docs/platform/account-management/saml) as
it requires an active SSO connection.

## How it works

When directory sync is configured, changes to your directory provider will
automatically be synced with your team members. The previously existing
permissions/roles will be overwritten by directory sync, including current user
performing the sync.

<Banner type="warning">

Make sure youâ€™re a member of the groups from the directory provider that youâ€™re
syncing with Liveblocks. Otherwise, you may lock yourself out.

</Banner>

You can configure a mapping between your directory providerâ€™s groups and a
Liveblocks team role. For example, your _engineers_ group on Okta can be
configured with the _member_ role on Liveblocks, and your _admin_ group can use
the _owner_ role.

<Figure>
  <Image
    src="/assets/account-management/team-security-settings.png"
    alt="Liveblocks team security settings"
    width={768}
    height={406}
  />
</Figure>

### Configuring directory sync

1. To configure directory sync for your team, you must be an owner of the team
   (see
   [how to manage team members](/docs/platform/account-management/manage-team-members)).
2. From your dashboard, ensure your team is selected in the scope selector.
3. Navigate to the â€œSettingsâ€ tab and select â€œSecurity & Privacyâ€.
4. Navigate to the â€œDirectory syncâ€ section.
5. Click â€œConfigureâ€ and follow the walkthrough to configure directory sync for
   your team with your directory provider of choice.
6. Map your directory groups to appropriate Liveblocks team roles.

<Figure>
  <Image
    src="/assets/account-management/dsync-setup.png"
    alt="Liveblocks team security settings"
    width={768}
    height={406}
  />
</Figure>

---
meta:
  title: "Manage team members"
  parentTitle: "Platform"
  description: "Learn how to manage team members on your Liveblocks account."
---

Teams are made up of members, and each member can be assigned a role. These
roles define what you can and cannot do within a team on Liveblocks.

As your project scales, and you add more team members, you can assign each
member a role to ensure that they have the right permissions to work on your
projects.

## Inviting team members

To invite new members to your team, select the team from the scope selector,
then open the **Settings** tab and navigate to **Members**.

<Figure>
  <Image
    src="/assets/account-management/team-members.png"
    alt="Liveblocks team members"
    width={768}
    height={406}
  />
</Figure>

Enter the email address of the person youâ€™d like to add, select their role, and
press the **Invite** button.

<Figure>
  <Image
    src="/assets/account-management/team-members-invite-dialog.png"
    alt="Invite team member to Liveblocks"
    width={768}
    height={406}
  />
</Figure>

## Access roles

Liveblocks offers two types of roles for team members, each providing different
levels of access and permissions.

### Owner role

As a team owner, you have full administrative control over your team. This
includes the ability to manage all aspects of account & project settings,
security, and billing.

Team owners can manage API keys in all projects and also change the roles of
other team members, including promoting members to owners. However, the only way
an owner can renounce their role is by either choosing to leave, or by deleting
the team altogether.

Teams can have more than one owner. For continuity, we recommend that at least
two individuals have owner permissions. Additional owners can be added without
any impact on existing ownership. Keep in mind that role changes, including
assignment and revocation of team member roles, are an exclusive capability of
those with the owner role.

### Member role

Those with the member role have the ability to create and manage projects. They
are also granted permissions to manage API keys for all projects.

However, there are certain team-level settings that are off-limits to members.
These include editing team settings, such as billing information, the ability
to invite new users to the team, and the ability to delete projects. This
restriction is in place to maintain the division of responsibilities and
control between members and owners.

---
meta:
  title: "Multi-factor authentication"
  parentTitle: "Platform"
  description:
    "Learn how to enable multi-factor authentication on your Liveblocks account."
---

<Banner>
  This feature is available as an add-on to Enterprise customers. Reach out to
  [sales@liveblocks.io](mailto:sales@liveblocks.io) to enable it on your
  account.
</Banner>

_Multi-factor authentication_ (MFA) adds an additional layer of security to
teams to manage their members by enforcing them to have an authenticator app.
Does not apply to Single Sign-On members.

## How it works

When MFA is enabled, all team members will be required to have an authenticator
app installed on their device. They will be prompted to enter a code from the
app when they log in to the dashboard.

<Figure>
  <Image
    src="/assets/account-management/team-mfa-setup.png"
    alt="Liveblocks team setup MFA"
    width={768}
    height={406}
  />
</Figure>

## How to enable MFA

MFA is available as an add-on to Enterprise customers, reach out to
[sales@liveblocks.io](mailto:sales@liveblocks.io) to enable it on your account.
After itâ€™s enabled, it will work without configuration.

---
meta:
  title: "SAML Single Sign-on"
  parentTitle: "Platform"
  description: "Learn how to set up SSO on your Liveblocks account."
---

<Banner>
  This feature is available as a paid add-on on the Pro and Enterprise plans.
  Reach out to [sales@liveblocks.io](mailto:sales@liveblocks.io) to enable it on
  your account.
</Banner>

SSO enables teams to enforce authentication via identity providers like Okta,
Azure AD, Google Workspace, or OneLogin using SAML. This simplifies account
management, and helps organizations meet internal security requirements. Paired
with Directory Sync, teams can manage organization membership directly from
their identity provider, reducing manual overhead and aligning with standard
enterprise access control practices.

Once enabled, all team members will be able to log in to the dashboard using
your selected identity provider. Youâ€™ll still need to invite users to your team
for them to have access. If you would like all users signing up with SSO to be
automatically added to your team, please contact us.

You can also use
[Directory Sync](/docs/platform/account-management/directory-sync) to
automatically assign users to your team with a specific role.

<Figure>
  <Image
    src="/assets/account-management/team-security-settings.png"
    alt="Liveblocks team security settings"
    width={768}
    height={406}
  />
</Figure>

## Configuring SSO

After SSO is enabled on your account, you can configure it for your team.

1. To configure SSO, you must be an owner of the team (see
   [how to manage team members](/docs/platform/account-management/manage-team-members)).
2. From your dashboard, ensure your team is selected in the scope selector.
3. Navigate to the â€œSettingsâ€ tab and select â€œSecurity & Privacyâ€.
4. Navigate to the â€œSSOâ€ section.
5. Click â€œConfigureâ€ and follow the walkthrough to configure SSO for your team
   with the identity provider of your choice.

<Figure>
  <Image
    src="/assets/account-management/sso-setup.png"
    alt="Liveblocks team security settings"
    width={768}
    height={406}
  />
</Figure>

## Enforcing SSO

For additional security, SSO can be enforced for a team so that all team members
cannot access any team information unless their current session is authenticated
with SSO. If you want to activate this setting, please contact us at
[support@liveblocks.io](mailto:support@liveblocks.io).

### Automatic provisioning

By default, you still need to manually invite users to your team for them to
have access to it. If you would like all users signing up with SSO to be
automatically added to your team, please contact us at
[support@liveblocks.io](mailto:support@liveblocks.io).

## Authenticating with SSO

Once you have configured SSO, your team members can use it to log in or sign up
to Liveblocks. They only have to enter their email, and they will be redirected
to the third-party authentication provider that you configured.

## Supported providers

Liveblocks supports the following third-party identity providers:

- Okta
- Entra ID (Azure AD)
- Google SAML
- ADP OpenID Connect
- Auth0 SAML
- CAS SAML
- ClassLink SAML
- Cloudflare SAML
- CyberArk SAML
- Duo SAML
- Entra ID OpenID Connect
- Google OpenID Connect
- JumpCloud SAML
- Keycloak SAML
- LastPass SAML
- Microsoft AD FS
- NetIQ SAML
- Okta OpenID Connect
- OneLogin
- Oracle
- PingFederate
- PingOne
- Rippling
- Salesforce
- SimpleSAMLphp SAML
- VMware Workspace One

If your identity provider is not listed or if you'd like to use an OIDC (OpenID
Connect) SSO provider, please reach out to us at
[support@liveblocks.io](mailto:support@liveblocks.io).

## Domain verification

Liveblocks supports self-serve domain verification for SSO. This allows you to
verify domains and sign in through your organizationâ€™s SSO connection without
needing to verify your team membersâ€™ emails.

After SSO is enabled on your account you can verify domains from the dashboard.

1. From your dashboard, ensure your team is selected in the scope selector.
2. Navigate to the â€œSettingsâ€ tab and select â€œSecurity & Privacyâ€.
3. Navigate to the â€œSSOâ€ section.
4. Click "Add domainâ€ and follow the walkthrough to verify domains for your
   team.

<Figure>
  <Image
    src="/assets/account-management/sso-domain-verification.png"
    alt="Liveblocks team security settings"
    width={768}
    height={406}
  />
</Figure>

---
meta:
  title: "Analytics"
  parentTitle: "Platform"
  description:
    "With analytics, youâ€™re able to gather insights into collaborative
    experiences for a given project with metrics like daily active users,
    monthly active users, connections, active rooms, and more."
---

With analytics, youâ€™re able to gather insights into collaborative experiences
for a given project with metrics such as daily active users, monthly active
users, connections, active rooms, and more.

<Figure>
  <Image
    src="/assets/analytics/analytics.jpg"
    alt="Liveblocks analytics"
    width={768}
    height={406}
  />
</Figure>

You can adjust the period through the timeframe selector by picking between 1
hour, 1 day, 1 week, and 1 month.

<Figure>
  <Image
    src="/assets/analytics/analytics-timeframe.jpg"
    alt="Liveblocks analytics timeframe selector"
    width={768}
    height={406}
  />
</Figure>

---
meta:
  title: "Data storage"
  parentTitle: "Platform"
  description:
    "Learn about Liveblocks data storage, retention policies, and deletion
    procedures."
---

Liveblocks is designed to support realtime collaboration and AI features with a
focus on performance, reliability, and privacy. While many aspects of data
handling are managed by the platform, enterprise customers can configure certain
behaviors related to data storage, retention, and region enforcement. This
document outlines what data Liveblocks stores, where it is stored, and how
deletion is handled.

<Banner title="Trust center">

Visit our [trust center](https://liveblocks.safebase.us/) to download security
and compliance reports, such as SOC 2 Type II and HIPAA.

</Banner>

## Data stored

In most cases, sensitive or personal information can be excluded from what's
sent to Liveblocks. Additionally, expanded storage configuration and data
control features are under active development for enterprise customers.

### Comments

- **Data stored**: Comment body, author ID, timestamps, mentions, tags, and
  metadata.
- **Retention**: Persists until the room or thread is explicitly deleted.
  Additionally, if all comments in a thread are removed, the thread is deleted.

### Multiplayer

#### Realtime data storage

- **Data stored**: Collaborative state written in text editor and sync engine
  integrations. This includes Tiptap, BlockNote, Lexical, Storage (e.g.
  `LiveObject`), and Yjs (e.g. `Y.Doc`).
- **Retention**: Persists until the room is explicitly deleted. Storage (e.g.
  `LiveObject`) data can be deleted without deleting the room.

#### Presence

- **Data stored**: Room ID, user ID, and approximate geolocation (based on IP
  address). This is used to display session events in the Liveblocks Dashboard.
- **Retention**: Persists until a deletion request is submitted.

### AI Agents

#### Liveblocks AI Copilots

- **Data stored**: Prompt configuration, LLM connection parameters (including
  API keys), message history, tool results, token usage, model usage, chat
  names, and metadata. Back-end knowledge is an optional add-on that requires
  saving text and vectors to support knowledge recall.
- **Retention**: Persists until the user or client deletes a chat.

### Notifications

- **Data stored**: Notification message, delivery state, and recipient user ID.
- **Retention**: Persists until each notification is explicitly deleted.

### Webhooks

- **Data stored**:
  [Webhook event data](/docs/platform/webhooks#Liveblocks-events), such as
  project ID, room ID, and the event type.
- **Retention**: Automatically deleted after 90 days.

## Storage locations

### AWS

AWS is used to store various data with `us-east-1` being used as the default
region. Enterprise customers can choose to
[region lock data](/docs/platform/projects#Project-location) in `us-east-1` or
`eu-central-1`, per project.

#### Stored in AWS

- Room metadata (ID, accesses, metadata).
- Comments.
- Notifications.
- Project usage analytics.
- Dashboard members.
- User events.
- AI Copilot configuration.
- AI Copilot uploaded/crawled knowledge.

#### Encryption

Postgres and MongoDB data is encrypted at rest, including backups, replicas, and
snapshots.

### Cloudflare

Realtime collaboration data used in Multiplayer and Presence is handled by
Cloudflareâ€™s global edge network. This data is handled on the edge, as close to
the user as possible, to ensure low-latency performance. Because Cloudflare
manages routing dynamically across its global edge network, data processed in
WebSocket sessions is not guaranteed to remain within a specific geographic
region, apart from when region-locking is enabled.

Enterprise customers can choose to
[region lock data](/docs/platform/projects#Project-location) to `Cloudflare EU`
or `Cloudflare FedRAMP`, per project.

#### Stored in Cloudflare

- Multiplayer data for text editor and sync engine integrations.
- AI Copilot message, tool, chat, and usage history.

#### Encryption

DurableObject data is encrypted at rest.

### Svix

Svix is used to deliver webhook messages.

#### Stored in Svix

- Webhook message data.

## Data deletion

### Comments

Comment data persists until the room is deleted with
[`deleteRoom`](/docs/api-reference/liveblocks-node#delete-rooms-roomId) or
[Delete Room REST API](/docs/api-reference/rest-api-endpoints#delete-rooms-roomId).
Additionally, individual threads and their comments can be deleted explicitly
with [`useDeleteThread`](/docs/api-reference/liveblocks-react#useDeleteThread),
[`deleteThread`](/docs/api-reference/liveblocks-node#delete-rooms-roomId-threads-threadId)
or
[Delete Thread REST API](/docs/api-reference/rest-api-endpoints#delete-rooms-roomId-threads-threadId).

Comments can also be deleted by their authorsâ€”when a single comment is deleted,
its body is cleared and marked with a `deletedAt` timestamp. When all comments
in a thread are deleted, the thread is deleted too.

### Multiplayer

#### Realtime data storage

Multiplayer data is deleted when the associated room is removed with
[`deleteRoom`](/docs/api-reference/liveblocks-node#delete-rooms-roomId) or
[Delete Room REST API](/docs/api-reference/rest-api-endpoints#delete-rooms-roomId).
Additionally, Storage data can be explicitly deleted with
[`deleteStorageDocument`](/docs/api-reference/liveblocks-node#delete-rooms-roomId-storage)
or
[Delete Storage Document REST API](/docs/api-reference/rest-api-endpoints#delete-rooms-roomId-storage).

#### Presence

Presence data persists until a deletion request is submitted.

### AI Agents

#### Liveblocks AI Copilots

Chat data is deleted by the user or client calling
[`useDeleteAiChat`](/docs/api-reference/liveblocks-react#useDeleteAiChat).

### Notifications

Notifications are persisted until explicitly deleted with
[`deleteInboxNotification`](/docs/api-reference/liveblocks-node#delete-users-userId-inboxNotifications-inboxNotificationId)
or
[Delete Inbox Notification REST API](/docs/api-reference/rest-api-endpoints#delete-users-userId-inboxNotifications-inboxNotificationId).

### Webhooks

Webhook messages data is automatically deleted after 90 days.

## Data security

To learn more about data security, visit our trust center to find detailed
information and downloadable compliance reports, including SOC 2 Type II and
HIPAA.

<Button asChild className="not-markdown">
  <a href="https://liveblocks.safebase.us/">Open trust center</a>
</Button>

---
meta:
  title: "Limits"
  parentTitle: "Platform"
  description:
    "A list of all the limits and limitations that apply on Liveblocks."
---

## General limits

There are three plans: Free, Pro, Team, and Enterprise. Each plan has its own
set of limits.

|                                                                                                                                                                                                                                                                                                        | Free                                              | Pro                                                                                                                                                   | Team                                                                                                                                                    | Enterprise                                                                                                                                            |
| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------- |
| <a href="#What-is-a-monthly-active-room">Monthly active rooms</a>                                                                                                                                                                                                                                      | <Limits.FreeMaxMonthlyActiveRooms />              | <Limits.ProMonthlyActiveRoomsIncluded /> included<br /><span className="text-xs text-product-subtlest"><Limits.ProMonthlyActiveRoomsOverage /></span> | <Limits.TeamMonthlyActiveRoomsIncluded /> included<br /><span className="text-xs text-product-subtlest"><Limits.TeamMonthlyActiveRoomsOverage /></span> | <Limits.EnterpriseMonthlyActiveRoomsIncluded /> <InfoTooltip>Up to <Limits.EnterpriseMaxMonthlyActiveRooms /></InfoTooltip>                           |
| <a href="#What-is-a-monthly-active-user">Monthly active users</a>                                                                                                                                                                                                                                      | <Limits.FreeMaxMau />                             | <Limits.ProMaxMau />                                                                                                                                  | <Limits.TeamMaxMau />                                                                                                                                   | <Limits.EnterpriseMaxMau />                                                                                                                           |
| <a href="/docs/platform/projects">Projects</a>                                                                                                                                                                                                                                                         | <Limits.FreeMaxProjects />                        | <Limits.ProMaxProjects />                                                                                                                             | <Limits.TeamMaxProjects />                                                                                                                              | <Limits.EnterpriseProjectsIncluded /> <InfoTooltip>Up to <Limits.EnterpriseMaxProjects /></InfoTooltip>                                               |
| <a href="/docs/platform/account-management/manage-team-members">Team members</a>                                                                                                                                                                                                                       | <Limits.FreeMaxTeamMembersPerAccount />           | <Limits.ProTeamMembersPerAccount /> included<br /><span className="text-xs text-product-subtlest"><Limits.ProTeamMembersPerAccountOverage /></span>   | <Limits.TeamTeamMembersPerAccount /> included<br /><span className="text-xs text-product-subtlest"><Limits.TeamTeamMembersPerAccountOverage /></span>   | <Limits.EnterpriseTeamMembersPerAccount /> <InfoTooltip>Up to <Limits.EnterpriseMaxTeamMembersPerAccount /></InfoTooltip>                             |
| <a href="#What's-a-simultaneous-connection-per-room" title="Learn more">Simultaneous connections per room</a>                                                                                                                                                                                          | <Limits.FreeMaxConnectionsPerRoom />              | <Limits.ProMaxConnectionsPerRoom />                                                                                                                   | <Limits.TeamMaxConnectionsPerRoom />                                                                                                                    | <Limits.EnterpriseMaxConnectionsPerRoom />                                                                                                            |
| <a href="#What's-a-simultaneous-connection-per-project">Simultaneous connections per project</a>                                                                                                                                                                                                       | <Limits.FreeMaxConnectionsPerProject />           | <Limits.ProMaxConnectionsPerProject />                                                                                                                | <Limits.TeamMaxConnectionsPerProject />                                                                                                                 | <Limits.EnterpriseMaxConnectionsPerProject />                                                                                                         |
| Monthly anonymous connections <InfoTooltip>Public key only recommended for prototyping. <a href="/docs/authentication" className="font-medium">Set up authentication</a>.</InfoTooltip>                                                                                                                | <Limits.FreeMaxAnonymousConnections />            | <Limits.ProMaxAnonymousConnections />                                                                                                                 | <Limits.TeamMaxAnonymousConnections />                                                                                                                  | <Limits.EnterpriseMaxAnonymousConnections />                                                                                                          |
| Realtime data storage <InfoTooltip>This is a cumulative calculation that represents all data that is currently stored. It does not reset monthly, and the total usage will continue to accrue over time as you add more content and data.</InfoTooltip>                                                | <Limits.FreeMaxRealtimeDataStorage />             | <Limits.ProRealtimeDataStorage /> included<br /><span className="text-xs text-product-subtlest"><Limits.ProRealtimeDataStorageOverage /></span>       | <Limits.TeamRealtimeDataStorage /> included<br /><span className="text-xs text-product-subtlest"><Limits.TeamRealtimeDataStorageOverage /></span>       | <Limits.EnterpriseRealtimeDataStorage /> <InfoTooltip>Up to <Limits.EnterpriseMaxRealtimeDataStorage /></InfoTooltip>                                 |
| Realtime data stored per room                                                                                                                                                                                                                                                                          | <Limits.FreeMaxStorageSizePerRoom />              | <Limits.ProMaxStorageSizePerRoom />                                                                                                                   | <Limits.TeamMaxStorageSizePerRoom />                                                                                                                    | <Limits.EnterpriseMaxStorageSizePerRoom />                                                                                                            |
| File storage <InfoTooltip>This is a cumulative calculation that represents all files that are stored with Liveblocks. It does not reset monthly, and the total usage will continue to accrue over time as you add more files. Files can be uploaded as comment attachments for instance.</InfoTooltip> | <Limits.FreeMaxFileStorage />                     | <Limits.ProFileStorage /> included<br /><span className="text-xs text-product-subtlest"><Limits.ProFileStorageOverage /></span>                       | <Limits.TeamFileStorage /> included<br /><span className="text-xs text-product-subtlest"><Limits.TeamFileStorageOverage /></span>                       | <Limits.EnterpriseMaxFileStorage />                                                                                                                   |
| Max file upload size                                                                                                                                                                                                                                                                                   | <Limits.FreeMaxFileUploadSize />                  | <Limits.ProMaxFileUploadSize />                                                                                                                       | <Limits.TeamMaxFileUploadSize />                                                                                                                        | <Limits.EnterpriseFileUploadSize /> <InfoTooltip>Up to <Limits.EnterpriseMaxFileUploadSize /></InfoTooltip>                                           |
| Comments stored                                                                                                                                                                                                                                                                                        | <Limits.FreeMaxComments />                        | <Limits.ProMaxComments />                                                                                                                             | <Limits.TeamMaxComments />                                                                                                                              | <Limits.EnterpriseMaxComments />                                                                                                                      |
| Monthly collaboration notifications <InfoTooltip>Notifications automatically triggered from collaborative features like comment thread updates and @ mentions.</InfoTooltip>                                                                                                                           | <Limits.FreeMaxCollaborationNotifications />      | <Limits.ProMaxCollaborationNotifications />                                                                                                           | <Limits.TeamMaxCollaborationNotifications />                                                                                                            | <Limits.EnterpriseMaxCollaborationNotifications />                                                                                                    |
| Monthly custom notifications <InfoTooltip>Non-collaborative notifications that can be triggered from your own code.</InfoTooltip>                                                                                                                                                                      | <Limits.FreeMaxCustomNotifications />             | <Limits.ProCustomNotifications /> included<br /><span className="text-xs text-product-subtlest"><Limits.ProCustomNotificationsOverage /></span>       | <Limits.TeamCustomNotifications /> included<br /><span className="text-xs text-product-subtlest"><Limits.TeamCustomNotificationsOverage /></span>       | <Limits.EnterpriseCustomNotifications /> <InfoTooltip>Up to <Limits.EnterpriseMaxCustomNotifications /></InfoTooltip>                                 |
| Webhook event frequency <InfoTooltip>The frequency at which `yDocUpdated` (Yjs) and `storageUpdated` (Liveblocks Storage) events are sent to your webhook endpoint. <a href="/docs/platform/webhooks#StorageUpdatedEvent" className="font-medium">Learn more</a></InfoTooltip>                         | <Limits.FreeStorageUpdatedWebhookEventThrottle /> | <Limits.ProStorageUpdatedWebhookEventThrottle />                                                                                                      | <Limits.TeamStorageUpdatedWebhookEventThrottle />                                                                                                       | <Limits.EnterpriseStorageUpdatedWebhookEventThrottle /> <InfoTooltip>Down to <Limits.EnterpriseMaxStorageUpdatedWebhookEventThrottle /></InfoTooltip> |
| Version history <InfoTooltip>APIs, hooks, and pre-built components to access the previous versions of the realtime data stored in rooms.</InfoTooltip>                                                                                                                                                 | <Limits.FreeVersionHistory />                     | <Limits.ProVersionHistory /> <InfoTooltip>Unlimited with Version History Plus addâ€‘on</InfoTooltip>                                                    | <Limits.TeamVersionHistory /> <InfoTooltip>Unlimited with Version History Plus addâ€‘on</InfoTooltip>                                                     | <Limits.EnterpriseVersionHistory />                                                                                                                   |
| Event log retention                                                                                                                                                                                                                                                                                    | <Limits.FreeEventLogRetention />                  | <Limits.ProEventLogRetention />                                                                                                                       | <Limits.TeamEventLogRetention />                                                                                                                        | <Limits.EnterpriseEventLogRetention /> <InfoTooltip>Up to <Limits.EnterpriseMaxEventLogRetention /></InfoTooltip>                                     |

## Other limits

| Item                                                                                                                                                                                                  | Limit                                                              |
| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------ |
| `roomId` <InfoTooltip>The unique identifier for a room. <a href="#What's-a-room" className="font-medium">What's a room?</a></InfoTooltip>                                                             | 128 characters                                                     |
| `userId` <InfoTooltip>The unique identifier for a user. Each `userId` must be used to represent a single user.</InfoTooltip>                                                                          | 128 characters                                                     |
| `userInfo` <InfoTooltip>User information sent from the authentication endpoint.</InfoTooltip>                                                                                                         | 1024 characters once serialized to JSON                            |
| Broadcast event message <InfoTooltip>Messages sent via the broadcast API for real-time communication between clients.</InfoTooltip>                                                                   | 1 MB                                                               |
| Thread metadata <InfoTooltip>Custom metadata attached to a thread.</InfoTooltip>                                                                                                                      | 50 properties, 4000 characters each                                |
| Comment metadata <InfoTooltip>Custom metadata attached to a comment.</InfoTooltip>                                                                                                                    | 50 properties, 4000 characters each                                |
| `LiveObject` <InfoTooltip>A realtime data structure that stores key-value pairs. <a href="/docs/api-reference/liveblocks-client#LiveObject" className="font-medium">Learn more</a></InfoTooltip>      | 128 kB when totalling the size of the keys and values              |
| `LiveMap` <InfoTooltip>A realtime data structure that stores key-value pairs in a map. <a href="/docs/api-reference/liveblocks-client#LiveMap" className="font-medium">Learn more</a></InfoTooltip>   | Unlimited, so long as each individual value does not exceed 128 kB |
| `LiveList` <InfoTooltip>A realtime data structure that stores an ordered list of items. <a href="/docs/api-reference/liveblocks-client#LiveList" className="font-medium">Learn more</a></InfoTooltip> | Unlimited, so long as each individual value does not exceed 128 kB |

Note that when one realtime data structure is nested inside another, it does not
count towards the limit. Only the JSON leaves of your data structure count
towards the limit. For example, if a `LiveList` is nested inside a `LiveObject`,
the `LiveList` and its contents do not count towards the `LiveObject`'s data
limit.

## FAQs

### What is a monthly active room?

Monthly active rooms represents the number of rooms that have been used within a
given month. Rooms are identified by their `roomId`.

Specifically, a room counts as active when any of these occur:

- A user connects on the front-end.
- A comment is added or modified.
- A document is updated. Any of the following: Storage, Tiptap, BlockNote,
  Lexical, Yjs.
- An attachment is uploaded.

If a room contains content from the previous month, it is not active until it is
used in the current month. For example, if a text document is created in
January, it is not active in February until a user connects to the document or
updates its content.

### What is a monthly active user?

Monthly active users represents the number of users that have used any
Liveblocks features within a given month. Users are identified by the `userId`
property provided in your [authentication endpoint](/docs/authentication). This
`userId` generally comes from your database or your authentication provider.

One unique `userId` corresponds to one user, no matter how long they connect
for. For example, a user that connects for 5 minutes on 2 different days is
counted as 1 MAU, and a user that connects 8 hours a day for a month is also
counted as 1 MAU. This applies so long as usage falls under our
[Fair Use Policy](/docs/platform/limits/fair-use-policy).

### Whatâ€™s a connection?

A connection occurs when a user opens a web page containing a Liveblocks room.
Each tab counts as one connection, which means that a user with two open tabs
has two connections. A room is joined when using{" "}
[`RoomProvider`](/docs/api-reference/liveblocks-react#RoomProvider) in React or
[`enterRoom`](/docs/api-reference/liveblocks-client#Client.enterRoom) in
JavaScript. Liveblocks connections are analogous to WebSocket connections,
representing a realtime link to our server.

### Whatâ€™s a room?

A room is the virtual space where people collaborate. For most products, a room
corresponds to a document.

### Whatâ€™s a simultaneous connection per room?

A simultaneous connection per room is when a user or multiple users are
connected to the same Liveblocks room at the same time. Learn more about
handling simultaneous room connection limits in our guide about
[joining rooms at maximum capacity](/docs/guides/what-happens-when-a-user-joins-a-room-at-maximum-capacity).

### Whatâ€™s a simultaneous connection per project?

A simultaneous connection per project is when a user or multiple users are
connected to the same project at the same time.

### How is realtime data storage calculated?

Realtime data storage is a cumulative calculation that represents all realtime
data that is currently stored in your rooms. It does not reset monthly, and the
total usage will continue to accrue over time as you add more content and data.
You can monitor your usage at any time in the [dashboard](/dashboard).

### What happens when limits are reached?

Liveblocks returns a different error for each limit that a user might reach.
That way, you can decide how to best handle those cases in your product.

### Do you count monthly active rooms during testing?

Yes, if test users connect to a room during automated testing, the room will be
counted as a monthly active room. To prevet hitting limits during testing, you
may want to provide a set of reusable `roomId`s.

---
meta:
  title: "Fair use guidelines"
  parentTitle: "Limits"
  description: "Learn about Liveblocksâ€™ fair use guidelines."
---

All subscription plans include usage that is subject to these fair use
guidelines. These guidelines define acceptable usage and how we evaluate usage
patterns over time to ensure stable performance for all customers.

## Examples of fair use

<StyledList>
  <StyledListItem type="check">A collaborative SaaS product</StyledListItem>
  <StyledListItem type="check">An AI chatbot</StyledListItem>
  <StyledListItem type="check">A multiplayer game</StyledListItem>
  <StyledListItem type="check">
    An interactive multiplayer landing page
  </StyledListItem>
</StyledList>

## Never fair use

<StyledList>
  <StyledListItem type="cross">
    Using a single `userId` for multiple users
  </StyledListItem>
  <StyledListItem type="cross">Abusing free REST API endpoints</StyledListItem>
  <StyledListItem type="cross">
    Load testing without authorization
  </StyledListItem>
  <StyledListItem type="cross">
    Not using Liveblocks for collaboration
  </StyledListItem>
  <StyledListItem type="cross">
    Sharing logins or using group accounts for the admin dashboard
  </StyledListItem>
</StyledList>

## Usage guidelines

As a guideline for our community, we expect most projects to fall within the
ranges outlined below for each plan. If your usage significantly exceeds these
guidelines, weâ€™ll contact you to discuss your needs and determine whether
changes to your plan or implementation are required. We aim to accommodate
legitimate usage while ensuring our platform remains stable and performant for
all users.

If your usage patterns are abnormal and materially impact platform performance,
as determined at Liveblocksâ€™ discretion based on platform-wide considerations,
we may require changes to your implementation or a plan change to support the
load. We will notify you if changes are required to your account before taking
any action that impacts your account.

### Typical monthly usage guidelines

|                                   | Free                                         | Pro and Team                                |
| --------------------------------- | -------------------------------------------- | ------------------------------------------- |
| Average connections per month     | Up to <Limits.FreeAvgConnectionsPerMau />    | Up to <Limits.ProAvgConnectionsPerMau />    |
| Total active room hours per month | Up to <Limits.FreeActiveRoomHoursPerMonth /> | Up to <Limits.ProActiveRoomHoursPerMonth /> |

Usage is measured at the team workspace level. For teams on the Pro and Team
plans, you can pay for [additional usage](/docs/platform/limits) as you go.

### Additional usage

For members of our Pro and Team plans, we offer a pay-as-you-go model for
additional usage, giving you greater flexibility and control over your usage.
The typical monthly usage guidelines above are still applicable, while extra
usage will be automatically charged at the following rates:

| Item                                                                             | Included                                 | Pay-as-you-go                              |
| -------------------------------------------------------------------------------- | ---------------------------------------- | ------------------------------------------ |
| <a href="#What-is-a-monthly-active-room">Monthly active rooms</a>                | <Limits.ProMonthlyActiveRoomsIncluded /> | <Limits.ProMonthlyActiveRoomsOverage />    |
| <a href="/docs/platform/account-management/manage-team-members">Team members</a> | <Limits.ProTeamMembersPerAccount />      | <Limits.ProTeamMembersPerAccountOverage /> |
| Realtime data storage                                                            | <Limits.ProRealtimeDataStorage />        | <Limits.ProRealtimeDataStorageOverage />   |
| File storage                                                                     | <Limits.ProFileStorage />                | <Limits.ProFileStorageOverage />           |
| Monthly custom notifications                                                     | <Limits.ProCustomNotifications />        | <Limits.ProCustomNotificationsOverage />   |

Usage beyond included amounts will continue to be billed at pay-as-you-go rates
unless another arrangement is put in place.

### Commercial usage

The Free plan is limited to non-commercial, personal projects only. Any
commercial use of Liveblocks requires a Pro, Team or Enterprise subscription.

We consider usage to be commercial when a project generates revenue or financial
benefit for anyone involved in its development, operation, or maintenance. This
includes projects built by paid employees, contractors, or consultants. Internal
use within a company qualifies as commercial usage, regardless of whether users
pay directly. Common examples of commercial usage include:

- Applications that accept payments or process transactions
- Products or services offered for sale
- Projects developed or maintained for compensation
- Sites primarily focused on affiliate marketing
- Applications displaying advertisements or sponsored content

If youâ€™re uncertain whether your project qualifies as commercial usage, please
reach out to our support team for clarification.

### General Limits

Take a look at our [Limits](/docs/platform/limits) documentation for the limits
we apply to all accounts.

### Learn more

Circumventing or attempting to bypass Liveblocksâ€™ limits or usage guidelines is
a violation of our fair use guidelines. For further information regarding these
guidelines and acceptable use of our services, refer to our
[Terms of Service](/terms) or your Enterprise Service Agreement. In case of
conflict, contractual terms supersede these guidelines. These guidelines may be
updated over time as Liveblocks releases new features or changes platform
capacity.

---
meta:
  title: "Projects"
  parentTitle: "Platform"
  description:
    "To use Liveblocks, you need to create a project, a place to group your
    collaborative rooms. Learn how to set up and configure projects in this
    guide."
---

To use Liveblocks, you need to create a project, a place to group your
collaborative rooms. Learn how to set up and configure projects in this guide.

## Creating a project

You can create a new project from the [Liveblocks dashboard](/dashboard) by
clicking on the **Create projectâ€¦** button.

<Figure>
  <Image
    src="/assets/projects/create-project.jpg"
    alt="Start creating a project from the Liveblocks dashboard"
    width={768}
    height={209}
  />
</Figure>

### Project environment

A projectâ€™s environment can either be set to **Development** or **Production**,
helping you map projects to your deployment model. We recommend setting up a new
project for each different environment your collaborative application uses.

<Figure>
  <Image
    src="/assets/projects/create-project-dialog.jpg"
    alt="Creating a project from the Liveblocks dashboard"
    width={768}
    height={499}
  />
</Figure>

Secret [API keys](#project-api-keys) are treated slightly differently depending
on the environment:

- **Development** environments allow you to read your secret key any time after
  generation. Itâ€™s recommended to use this setting in development, preview, and
  staging environments.
- **Production** environments encrypt your secret key, meaning it can only be
  read when itâ€™s first generated. If you forget your secret key, you must roll a
  new one. Itâ€™s recommended to use this environment in your production
  application.

<Banner>

A projectâ€™s environment cannot be changed later.

</Banner>

### Project location

When creating a new project in the dashboard, teams on the
[Enterprise plan](https://liveblocks.io/pricing) can specify which region the
project data will be stored and processed. There are three options:

1. N/A (No preference)
2. EU (AWS eu-central-1, Cloudflare EU)
3. US (AWS us-east-1, Cloudflare FedRAMP)

<Banner>

A projectâ€™s location cannot be changed later.

</Banner>

## Managing a project

Each Liveblocks project has a separate dashboard to monitor usage, configure
settings, manage API keys, and more.

### Project overview

The **Overview** tab displays an overview of your project usage, providing
information on active rooms, users, and connections.

<Figure>
  <Image
    src="/assets/projects/project-overview.jpg"
    alt="Liveblocks project overview"
    width={768}
    height={499}
  />
</Figure>

### Project rooms

The **Rooms** tab displays all the rooms in your project. Use the search bar
next to the page title to find rooms. By default, rooms are sorted by the last
connection date (most recently active rooms). You can also sort them by room ID,
number of threads, document size, or creation date by clicking on the column
labels.

<Figure>
  <Image
    src="/assets/projects/project-rooms.jpg"
    alt="Liveblocks project rooms"
    width={768}
    height={499}
  />
</Figure>

You can learn more about any given room by clicking on it. On the room detail
view, youâ€™re able to view the stored documentâ€™s data and common actions you can
take on it, such as deleting the documentâ€™s data.

<Figure>
  <Image
    src="/assets/projects/project-rooms-detail.jpg"
    alt="Liveblocks project rooms detail"
    width={768}
    height={499}
  />
</Figure>

### Project API keys [#project-api-keys]

The **API keys** tab enables you to manage, view, and roll your **public** and
**secret** API keys.

<Figure>
  <Image
    src="/assets/projects/project-api-keys.jpg"
    alt="Liveblocks project API keys"
    width={768}
    height={499}
  />
</Figure>

### Project webhooks

The **Webhooks** tab enables you to configure your webhook endpoints allowing
you to respond to Liveblocks events, such as a user entering a room, or storage
being updated. See our [webhooks](/docs/platform/webhooks) docs to learn more.

### Project settings

The **Settings** tab enables you to rename your project. Team owners can also
delete projects from this tab.

---
meta:
  title: "Liveblocks REST API"
  parentTitle: "Platform"
  description:
    "Liveblocks REST API allows developers to interact programmatically with
    their Liveblocks account and services using HTTP requests. With the API,
    developers can retrieve, set, and update room-related data, permissions,
    schemas, and more."
---

Liveblocks REST API allows developers to interact programmatically with their
Liveblocks account and services using HTTP requests. With the API, developers
can retrieve, set, and update room-related data, users, permissions, schemas,
and more.

The Liveblocks API is organized around REST. The API has predictable
resource-oriented URLs, accepts form-encoded request bodies, returns
JSON-encoded responses, and uses standard HTTP response codes, authentication,
and verbs. See the [API reference](api-reference/rest-api-endpoints) for more
information.

```
https://api.liveblocks.io/v2
```

---
meta:
  title: "Webhooks"
  parentTitle: "Platform"
  description: "Learn Liveblocks webhooks concepts and implementation."
---

Webhooks enable developers to extend the Liveblocks platform. From your system,
you can listen to events that get automatically triggered as users interact with
collaborative rooms.

## Configuring webhooks

To set up webhooks for your project, youâ€™ll need to create an endpoint,
subscribe to events, and secure your endpoint.

- [Creating an endpoint](#creating-an-endpoint)
- [Edit endpoint events](#edit-endpoint-events)
- [Security verification](#security-verification)
- [Replaying events](#replaying-events)
- [Testing locally](#testing-locally)

### Creating an endpoint [#creating-an-endpoint]

If you would like to create an endpoint to receive webhook events, you will do
so from within the webhooks dashboard for your project.

<Steps>
  <StepCompact>

    From the <a href="/dashboard" target="_blank">dashboard</a> overview, navigate
    to the project youâ€™d like to add webhooks to.

  </StepCompact>

  <StepCompact>

    Click on the webhooks tab from the left-hand menu.

  </StepCompact>

  <StepCompact>

    Click the **â€œCreate endpointâ€¦â€** button.

  </StepCompact>

  <StepCompact>

    Enter the URL of the endpoint you would like to use. Configure with your own
    endpoint or generate a
    <a href="https://www.svix.com/play/" target="_blank">Svix playground</a> link
    by clicking on **"use Svix play"**.

  </StepCompact>

  <StepCompact>

    Select the events you would like to subscribe to.

  </StepCompact>

  <StepCompact lastStep>

    Click **â€œCreate endpointâ€**.

  </StepCompact>

</Steps>

<Figure>
  <video width={1512} height={982} autoPlay loop muted playsInline>
    <source src="/assets/webhooks/create-endpoint.mp4" type="video/mp4" />
  </video>
</Figure>

Your endpoint must return a `2xx` (status code `200-299`) to indicate that the
event was successfully received. If your endpoint returns anything else, the
event will be retried, see [replaying events](#replaying-events) for more
details.

If all events fail to be delivered to your endpoint for 5 consecutive days, your
endpoint will automatically be disabled. You can always re-enable it from the
dashboard.

### Edit endpoint events [#edit-endpoint-events]

You can easily edit the events you want to subscribe to after creating an
endpoint.

<Steps>
  <StepCompact>

    Select the endpoint you would like to edit from the list of webhooks in the
    dashboard.

  </StepCompact>

  <StepCompact>

    Select **â€œEdit endpointâ€¦â€** from the top right dropdown.

  </StepCompact>

  <StepCompact lastStep>

    Update event selections and click **â€œSave changesâ€**.

  </StepCompact>

</Steps>

<Figure>
  <video width={1512} height={982} autoPlay loop muted playsInline>
    <source src="/assets/webhooks/edit-events.mp4" type="video/mp4" />
  </video>
</Figure>

### Replaying events [#replaying-events]

If your service is unreachable, message retries are automatically re-attempted.
If your service incurs considerable downtime (over 8 hours), you can replay
individual messages from the Endpoints portion of the dashboard by clicking the
kebab menu on an individual message, or you can opt to bulk replay events by
clicking the top right dropdown and selecting **â€œRecover failed messagesâ€¦â€**.

<Figure>
  <video autoPlay loop muted playsInline>
    <source src="/assets/webhooks/replay-events.mp4" type="video/mp4" />
  </video>
</Figure>

Each message is attempted based on a schedule that follows the failure of the
preceding attempt. If an endpoint is removed or disabled, delivery attempts will
also be disabled. The schedule for retries is as follows:

- Immediately
- 5 seconds
- 5 minutes
- 30 minutes
- 2 hours
- 5 hours
- 10 hours
- 10 hours (in addition to the previous)

For example, an attempt that fails three times before eventually succeeding will
be delivered roughly 35 minutes and 5 seconds following the first attempt.

## Security verification [#security-verification]

Verifying webhooks prevents security vulnerabilities by safeguarding against
man-in-the-middle, CSRF, and replay attacks. Because of this, it is essential to
prioritize verification in your integration. We recommend using the
`@liveblocks/node` package to verify and return fully typed events.

<Steps>

  <Step>
    <StepTitle>Install the package</StepTitle>
    <StepContent>

      ```bash
      npm install @liveblocks/node
      ```

    </StepContent>

  </Step>

  <Step>
    <StepTitle>Set up the webhook handler</StepTitle>
    <StepContent>

      Set up your webhook handler, inserting your secret key from the webhooks dashboard you
      set up earlier into [`WebhookHandler`](/docs/api-reference/liveblocks-node#WebhookHandler).

      ```ts
      import { WebhookHandler } from "@liveblocks/node";

      // Insert your webhook secret key
      const webhookHandler = new WebhookHandler("whsec_...");
      ```

    </StepContent>

  </Step>

  <Step>
    <StepTitle>Verify an event request</StepTitle>
    <StepContent>

      We can verify a genuine webhook request with
      [`WebhookHandler.verifyRequest`](/docs/api-reference/liveblocks-node#verifyRequest)

      ```ts
      const event = webhookHandler.verifyRequest({
        headers: req.headers,
        rawBody: req.body,
      });
      ```

      <Banner title="rawBody takes a string" type="warning">

        Note that some frameworks parse request bodies into objects, so you may need to
        use `rawBody: JSON.stringify(req.body)` instead.

      </Banner>

      The method will return a `WebhookEvent` object that is fully typed. You can then
      use the event to perform actions based on the event type. If the request is not valid, an error will be thrown.

    </StepContent>

  </Step>

  <Step lastStep>
    <StepTitle>

      Full example

    </StepTitle>

    <StepContent>

      Hereâ€™s an example from start to finish.

      ```ts
      import { WebhookHandler } from "@liveblocks/node";

      // Will fail if not properly initialized with a secret
      const webhookHandler = new WebhookHandler("whsec_...");

      export default function webhookRequestHandler(req, res) {
        try {
          const event = webhookHandler.verifyRequest({
            headers: req.headers,
            rawBody: req.body,
          });

          // Use the event, for example...
          if (event.type === "storageUpdated") {
            // { roomId: "my-room-name", projectId: "8sfhs5s...", ... }
            console.log(event.data);
          }
        } catch (error) {
          console.error(error);
          return res.status(400).end();
        }

        res.status(200).end();
      }
      ```

    </StepContent>

  </Step>

</Steps>

### Manually verify in Node.js

Itâ€™s also possible to manually verify your webhooks in Node.js, though itâ€™s
unlikely thisâ€™ll be necessary.

<details>

<summary>How to manually verify webhook events in Node.js</summary>

<Steps>

  <Step>
    <StepTitle>Construct the signed content</StepTitle>
    <StepContent>

      The content to sign is composed by concatenating the requestâ€™s id, timestamp,
      and payload, separated by the full-stop character (`.`). In code, it will look
      something like:

      ```ts
      const crypto = require("crypto");

      // webhookId comes from the `webhook-id` header
      // webhookTimestamp comes from the `webhook-timestamp` header
      // body is the request body
      signedContent = `${webhookId}.${webhookTimestamp}.${body}`;
      ```

    </StepContent>

  </Step>

  <Step>
    <StepTitle>Generate the signature</StepTitle>
    <StepContent>

      Liveblocks uses an HMAC with SHA-256 to sign its webhooks.

      So to calculate the expected signature, you should HMAC the `signedContent` from
      above using the base64 portion of your webhook secret key (this is the part
      after the `whsec_` prefix) as the key. For example, given the secret
      `whsec_MfKQ9r8GKYqrTwjUPD8ILPZIo2LaLaSw` you will want to use
      `MfKQ9r8GKYqrTwjUPD8ILPZIo2LaLaSw`.

      For example, this is how you can calculate the signature in Node.js:

      ```ts
      // Your endpointâ€™s secret key
      const secret = "whsec_MfKQ9r8GKYqrTwjUPD8ILPZIo2LaLaSw";

      // Need to base64 decode the secret
      const secretBytes = new Buffer(secret.split("_")[1], "base64");
      // This is the signature you will compare against the signature header
      const signature = crypto
      .createHmac("sha256", secretBytes)
      .update(signedContent)
      .digest("base64");
      ```

    </StepContent>

  </Step>

  <Step>
    <StepTitle>Validate the signature</StepTitle>
    <StepContent>

      The generated signature should match one of the signatures sent in the
      `webhook-signature` header.

      The `webhook-signature` header comprises a list of space-delimited signatures
      and their corresponding version identifiers. The signature list is most commonly
      of length one. Though there could be any number of signatures. For example:

      ```
      v1,g0hM9SsE+OTPJTGt/tmIKtSyZlE3uFJELVlNIOLJ1OE= v1,bm9ldHUjKzFob2VudXRob2VodWUzMjRvdWVvdW9ldQo= v2,MzJsNDk4MzI0K2VvdSMjMTEjQEBAQDEyMzMzMzEyMwo=
      ```

      Make sure to remove the version prefix and delimiter (e.g., `v1`) before
      verifying the signature.

    </StepContent>

  </Step>

  <Step lastStep>
    <StepTitle>Verify the timestamp</StepTitle>
    <StepContent>

      As mentioned above, Liveblocks also sends the timestamp of the attempt in the
      `webhook-timestamp` header. You should compare this timestamp against your
      system timestamp and make sure itâ€™s within your tolerance to prevent timestamp
      attacks.

      <Banner title="Comparing signatures">

        We recommend implementing a constant-time string comparison method when
        comparing signatures to prevent timing attacks.

      </Banner>

    </StepContent>

  </Step>

</Steps>

</details>

### Manually verify in Elixir

Itâ€™s also possible to manually verify your webhooks in Elixir using
Plug/Phoenix, especially if you want to validate Liveblocks webhooks before
parsing the request body.

<details>

<summary>How to manually verify webhook events in Elixir</summary>

<Steps>

<Step>
<StepTitle>Construct the signed content</StepTitle>
<StepContent>

The signed content is composed by concatenating the webhook ID, timestamp, and
request body, separated by dots (`.`). In Elixir, it looks like this:

```elixir
signed_content = "#{webhook_id}.#{webhook_timestamp}.#{body}"
```

- `webhook_id` comes from the `"webhook-id"` header.
- `webhook_timestamp` comes from the `"webhook-timestamp"` header.
- `body` is the raw request body.

</StepContent>
</Step>

<Step>
<StepTitle>Generate the signature</StepTitle>
<StepContent>

Liveblocks signs webhooks using HMAC with SHA-256. You need to use the
base64-decoded portion of your secret (after the `whsec_` prefix) as the key.

Example in Elixir:

```elixir
secret = "whsec_MfKQ9r8GKYqrTwjUPD8ILPZIo2LaLaSw"

# Extract and decode the base64 part of the secret
secret_bytes =
  secret
  |> String.split("_")
  |> Enum.at(1)
  |> Base.decode64!()

# Compute the signature
signature =
  :crypto.mac(:hmac, :sha256, secret_bytes, signed_content)
  |> Base.encode64()
```

</StepContent>
</Step>

<Step>
<StepTitle>Validate the signature</StepTitle>
<StepContent>

The signature you just generated should match one of the signatures from the
`webhook-signature` header. That header contains space-separated values like:

```
v1,abc123= v1,def456= v2,ghi789=
```

You should extract just the Base64-encoded signature (the part after the comma):

```elixir
signature_header = get_req_header(conn, "webhook-signature") |> List.first()

webhook_signatures =
  signature_header
  |> String.split(" ")
  |> Enum.map(fn entry ->
    entry |> String.split(",") |> Enum.at(1)
  end)
```

Then check if your generated signature is in the list:

```elixir
if signature in webhook_signatures do
  # Valid signature
end
```

</StepContent>
</Step>

<Step>
<StepTitle>Verify the timestamp</StepTitle>
<StepContent>

Liveblocks includes a `webhook-timestamp` header to help prevent replay attacks.
You should check that the timestamp is within a reasonable window (e.g., 5
minutes):

```elixir
tolerance = 5 * 60
now = :os.system_time(:second)

case Integer.parse(webhook_timestamp) do
  {ts, _} when abs(now - ts) <= tolerance -> true
  _ -> false
end
```

</StepContent>
</Step>

<Step>
<StepTitle>Full example</StepTitle>
<StepContent>

Hereâ€™s the full code, as detailed so far.

```elixir title="Plug example" isCollapsed isCollapsable
defmodule App.Plugs.RequestValidator do
  require Logger

  def init(_), do: []

  def call(%Plug.Conn{request_path: "/webhook/liveblocks"} = conn, _opts) do
    webhook_secret = Application.get_env(:api, :liveblocks)[:webhook_secret]
    webhook_id = conn |> Plug.Conn.get_req_header("webhook-id") |> List.first()
    webhook_timestamp = conn |> Plug.Conn.get_req_header("webhook-timestamp") |> List.first()

    webhook_signatures =
      conn
      |> Plug.Conn.get_req_header("webhook-signature")
      |> List.first()
      |> String.split(" ")
      |> Enum.map(&(&1 |> String.split(",") |> Enum.at(1)))

    {:ok, body, conn} = Plug.Conn.read_body(conn)

    signed_content = "#{webhook_id}.#{webhook_timestamp}.#{body}"

    secret_bytes =
      webhook_secret
      |> String.split("_")
      |> Enum.at(1)
      |> Base.decode64!()

    signature =
      :hmac
      |> :crypto.mac(:sha256, secret_bytes, signed_content)
      |> Base.encode64()

    if signature in webhook_signatures do
      if liveblocks_timestamp_valid?(webhook_timestamp) do
        params = Jason.decode!(body)

        conn
        |> Plug.Conn.assign(:request_validated, true)
        |> struct(%{body_params: params})
      else
        Logger.warning("[RequestValidator] Liveblocks webhook timestamp is not valid", %{
          timestamp: webhook_timestamp
        })

        conn
        |> Plug.Conn.put_status(:unauthorized)
        |> Phoenix.Controller.text("Incorrect timestamp")
        |> Plug.Conn.halt()
      end
    else
      Logger.warning("[RequestValidator] Liveblocks webhook signatures don't match", %{
        header_signature: webhook_signatures,
        calculated_signature: signature
      })

      conn
      |> Plug.Conn.put_status(:unauthorized)
      |> Phoenix.Controller.text("Incorrect signature")
      |> Plug.Conn.halt()
    end
  end

  def call(conn, _), do: conn

  defp liveblocks_timestamp_valid?(timestamp) do
    allowed_age = Application.get_env(:api, :liveblocks)[:webhook_timestamp_tolerance] || 5 * 60
    now = :os.system_time(:second)

    case Integer.parse(timestamp) do
      {ts, _} ->
        age = abs(now - ts)
        age <= allowed_age

      _ ->
        false
    end
  end
end
```

</StepContent>
</Step>

<Step lastStep>
<StepTitle>Add to your endpoint module</StepTitle>
<StepContent>

Finally, to use the validator to your endpoint module, place it before
`Plug.parsers`.

```elixir
plug(App.Plugs.RequestValidator)
plug(Plug.Parsers, ...)
```

</StepContent>
</Step>

</Steps>

</details>

## Testing locally [#testing-locally]

Running webhooks locally can be difficult, but there are several tools that
allow you to temporarily host your localhost server online.

### Using svix-cli

The [`svix-cli`](https://github.com/svix/svix-webhooks/tree/main/svix-cli)
provides a `listen` command that creates a publicly accessible URL for testing
webhooks without requiring any account setup or network configuration changes.

If your project is running on `localhost:3000`, you can run the following
command to generate a temporary URL:

```bash
svix listen http://localhost:3000/api/liveblocks-webhook
```

This will output a unique URL that forwards all POST requests to your local
endpoint:

```
Webhook Relay is now listening at:
https://play.svix.com/in/c_tSdQhb4Q5PTF5m2juiWu8qFREqE/

All requests on this endpoint will be forwarded to your local URL:
http://localhost:3000/api/liveblocks-webhook

View logs and debug information at:
https://play.svix.com/view/c_tSdQhb4Q5PTF5m2juiWu8qFREqE/
```

The generated URL can be placed directly into the Liveblocks webhooks dashboard
for testing. This approach is particularly useful in enterprise environments
where tools like `localtunnel` or `ngrok` may be blocked by security policies.

### Using localtunnel or ngrok

Alternatively, you can use tools such as
[`localtunnel`](https://www.npmjs.com/package/localtunnel) or
[`ngrok`](https://www.npmjs.com/package/ngrok) which also allow you to
temporarily host your localhost server online.

If your project is running on `localhost:3000`, you can run the following
command to generate a temporary URL thatâ€™s available while your localhost server
is running:

```bash
npx localtunnel --port 3000
```

If you visit the page `localtunnel` links you to, and correctly input your IP
address, the URL it generates can be placed into the Liveblocks webhooks
dashboard for quick testing.

For a full step-by-step guide on testing with `localtunnel` and `ngrok`, read
the guide on
[how to test webhooks on localhost](/docs/guides/how-to-test-webhooks-on-localhost#Use-your-webhook-event).

## Source IP Addresses [#source-ips]

In case your webhook receiving endpoint is behind a firewall or NAT, you may
need to allow traffic from the following IP addresses.

### Global and US

```
44.228.126.217
50.112.21.217
52.24.126.164
54.148.139.208
2600:1f24:64:8000::/56
```

### EU

```
52.215.16.239
54.216.8.72
63.33.109.123
2a05:d028:17:8000::/56
```

## Liveblocks events

An event occurs when a change is made to Liveblocks data. Each endpoint you
provide in the webhooks dashboard listens to all events by default but can be
easily configured to only listen to a subset by updating the Message Filtering
section.

The Event Catalog in the webhooks dashboard provides a list of events available
for subscription, along with their schema.

Events available for use include:

- `StorageUpdated`
- `UserEntered/UserLeft`
- `RoomCreated/RoomDeleted`
- `YDocUpdated`
- `CommentCreated/CommentEdited/CommentDeleted/CommentMetadataUpdated`
- `CommentReactionAdded/CommentReactionRemoved`
- `ThreadCreated/ThreadDeleted/ThreadMetadataUpdated`
- `Notification`

More events will come later, such as:

- `MaxConnectionsReached`

#### UserEnteredEvent

When a user connects to a room, an event is triggered, indicating that the user
has entered. The `numActiveUsers` field shows the number of users in the room
after the user has joined. This event is not throttled.

```ts
// Schema
type UserEnteredEvent = {
  type: "userEntered";
  data: {
    projectId: string;
    roomId: string;
    connectionId: number;
    userId: string | null;
    userInfo: Record<string, any> | null;
    enteredAt: string;
    numActiveUsers: number;
  };
};

// Example
const userEnteredEvent = {
  type: "userEntered",
  data: {
    projectId: "my-project-id",
    roomId: "my-room-id",
    connectionId: 4,
    userId: "a-user-id",
    userInfo: null,
    enteredAt: "2021-10-06T01:45:56.558Z",
    numActiveUsers: 8,
  },
};
```

#### UserLeftEvent

A user leaves a room when they disconnect from a room, which is when this event
is triggered. The `numActiveUsers` field represents the number of users in the
room after the user has left. This event, like `UserEntered`, is not throttled.

```ts
// Schema
type UserLeftEvent = {
  type: "userLeft";
  data: {
    projectId: string;
    roomId: string;
    connectionId: number;
    userId: string | null;
    userInfo: Record<string, any> | null;
    leftAt: string;
    numActiveUsers: number;
  };
};

// Example
const userLeftEvent = {
  type: "userLeft",
  data: {
    projectId: "my-project-id",
    roomId: "my-room-id",
    connectionId: 4,
    userId: "a-user-id",
    userInfo: {
      name: "John Doe",
    },
    leftAt: "2021-10-06T01:45:56.558Z",
    numActiveUsers: 7,
  },
};
```

#### StorageUpdatedEvent

Storage is updated when a user writes to storage. This event is throttled at 60
seconds and, as such, may not be triggered for every write.

For example, if a user writes to storage at 1:00 pm sharp, the
`StorageUpdatedEvent` event will be triggered shortly after. If the user writes
to Storage again at 1:00 pm and 2 seconds, the `StorageUpdatedEvent` event will
be triggered 60 seconds after the first event was sent, around 1:01 pm.

On [Enterprise plans](/pricing) we can increase the throttle rate.

```ts
// Schema
type StorageUpdatedEvent = {
  type: "storageUpdated";
  data: {
    roomId: string;
    projectId: string;
    updatedAt: string;
  };
};

// Example
const storageUpdatedEvent = {
  type: "storageUpdated",
  data: {
    projectId: "my-project-id",
    roomId: "my-room-id",
    updatedAt: "2021-10-06T01:45:56.558Z", // ðŸ‘ˆ time of the last write
  },
};
```

#### RoomCreatedEvent

An event is triggered when a room is created. This event is not throttled. There
are two ways for rooms to be created:

- By calling the
  [create room API](/docs/api-reference/rest-api-endpoints#post-rooms)
- When a user connects to a room that does not exist

```ts
// Schema
type RoomCreatedEvent = {
  type: "roomCreated";
  data: {
    projectId: string;
    roomId: string;
    createdAt: string;
  };
};

// Example
const roomCreatedEvent = {
  type: "roomCreated",
  data: {
    projectId: "my-project-id",
    roomId: "my-room-id",
    createdAt: "2021-10-06T01:45:56.558Z",
  },
};
```

#### RoomDeletedEvent

An event is triggered when a room is deleted. This event is not throttled.

```ts
// Schema
type RoomDeletedEvent = {
  type: "roomDeleted";
  data: {
    projectId: string;
    roomId: string;
    deletedAt: string;
  };
};

// Example
const roomDeletedEvent = {
  type: "roomDeleted",
  data: {
    projectId: "my-project-id",
    roomId: "my-room-id",
    deletedAt: "2021-10-06T01:45:56.558Z",
  },
};
```

#### YDocUpdatedEvent

Yjs document is updated when a user makes a change to a Yjs doc connected to a
room. This event is throttled at sixty seconds and, as such, may not be
triggered for every write.

For example, if a user updates a Yjs document at 1:00 pm sharp, the
`YDocUpdatedEvent` event will be triggered shortly after. If the user writes to
the Yjs document again at 1:00 pm and 2 seconds, the `YDocUpdatedEvent` event
will be triggered 60 seconds after the first event was sent, around 1:01 pm

On [Enterprise plans](/pricing) we can increase the throttle rate.

```ts
// Schema
type YDocUpdatedEvent = {
  type: "ydocUpdated";
  data: {
    projectId: string;
    roomId: string;
    updatedAt: string;
  };
};

// Example
const ydocUpdatedEvent = {
  type: "ydocUpdated",
  data: {
    projectId: "my-project-id",
    roomId: "my-room-id",
    updatedAt: "2013-06-26T19:10:19Z",
  },
};
```

#### CommentCreatedEvent

An event is triggered when a comment is created. This event is not throttled.

```ts
// Schema
type CommentCreatedEvent = {
  type: "commentCreated";
  data: {
    projectId: string;
    roomId: string;
    threadId: string;
    commentId: string;
    createdAt: string;
    createdBy: string;
  };
};

// Example
const commentCreatedEvent = {
  type: "commentCreated",
  data: {
    projectId: "my-project-id",
    roomId: "my-room-id",
    threadId: "my-thread-id",
    commentId: "my-comment-id",
    createdAt: "2021-10-06T01:45:56.558Z",
    createdBy: "my-user-id",
  },
};
```

#### CommentEditedEvent

An event is triggered when a comment is edited. This event is not throttled.

```ts
// Schema
type CommentEditedEvent = {
  type: "commentEdited";
  data: {
    projectId: string;
    roomId: string;
    threadId: string;
    commentId: string;
    editedAt: string;
  };
};

// Example
const commentEditedEvent = {
  type: "commentEdited",
  data: {
    projectId: "my-project-id",
    roomId: "my-room-id",
    threadId: "my-thread-id",
    commentId: "my-comment-id",
    editedAt: "2021-10-06T01:45:56.558Z",
  },
};
```

#### CommentDeletedEvent

An event is triggered when a comment is deleted. This event is not throttled.

```ts
// Schema
type CommentDeletedEvent = {
  type: "commentDeleted";
  data: {
    projectId: string;
    roomId: string;
    threadId: string;
    commentId: string;
    deletedAt: string;
  };
};

// Example
const commentDeletedEvent = {
  type: "commentDeleted",
  data: {
    projectId: "my-project-id",
    roomId: "my-room-id",
    threadId: "my-thread-id",
    commentId: "my-comment-id",
    deletedAt: "2021-10-06T01:45:56.558Z",
  },
};
```

#### CommentReactionAddedEvent

An event is triggered when a reaction is added to a comment. This event is not
throttled.

```ts
// Schema
type CommentReactionAddedEvent = {
  type: "commentReactionAdded";
  data: {
    projectId: string;
    roomId: string;
    threadId: string;
    commentId: string;
    emoji: string;
    addedAt: string;
    addedBy: string;
  };
};

// Example
const commentReactionAddedEvent = {
  type: "commentReactionAdded",
  data: {
    projectId: "my-project-id",
    roomId: "my-room-id",
    threadId: "my-thread-id",
    commentId: "my-comment-id",
    emoji: "ðŸ‘",
    addedAt: "2021-10-06T01:45:56.558Z",
    addedBy: "my-user-id",
  },
};
```

#### CommentReactionRemovedEvent

An event is triggered when a reaction is removed from a comment. This event is
not throttled.

```ts
// Schema
type CommentReactionRemovedEvent = {
  type: "commentReactionRemoved";
  data: {
    projectId: string;
    roomId: string;
    threadId: string;
    commentId: string;
    emoji: string;
    removedAt: string;
    removedBy: string;
  };
};

// Example
const commentReactionRemovedEvent = {
  type: "commentReactionRemoved",
  data: {
    projectId: "my-project-id",
    roomId: "my-room-id",
    threadId: "my-thread-id",
    commentId: "my-comment-id",
    emoji: "ðŸ‘",
    removedAt: "2021-10-06T01:45:56.558Z",
    removedBy: "my-user-id",
  },
};
```

#### ThreadCreatedEvent

An event is triggered when a thread is created. This event is not throttled.

```ts
// Schema
type ThreadCreatedEvent = {
  type: "threadCreated";
  data: {
    projectId: string;
    roomId: string;
    threadId: string;
    createdAt: string;
    createdBy: string;
  };
};

// Example
const threadCreatedEvent = {
  type: "threadCreated",
  data: {
    projectId: "my-project-id",
    roomId: "my-room-id",
    threadId: "my-thread-id",
    createdAt: "2021-10-06T01:45:56.558Z",
    createdBy: "my-user-id",
  },
};
```

#### ThreadDeletedEvent

An event is triggered when a thread is deleted. This event is not throttled. A
thread is deleted when all comments in the thread are deleted or when the thread
is manually deleted.

```ts
// Schema
type ThreadDeletedEvent = {
  type: "threadDeleted";
  data: {
    projectId: string;
    roomId: string;
    threadId: string;
    deletedAt: string;
  };
};

// Example
const threadDeletedEvent = {
  type: "threadDeleted",
  data: {
    projectId: "my-project-id",
    roomId: "my-room-id",
    threadId: "my-thread-id",
    deletedAt: "2021-10-06T01:45:56.558Z",
  },
};
```

#### ThreadMetadataUpdatedEvent

An event is triggered when a thread metadata is updated. This event is not
throttled.

```ts
// Schema
type ThreadMetadataUpdatedEvent = {
  type: "threadMetadataUpdated";
  data: {
    projectId: string;
    roomId: string;
    threadId: string;
    updatedAt: string;
    updatedBy: string;
  };
};

// Example
const threadMetadataUpdatedEvent = {
  type: "threadMetadataUpdated",
  data: {
    projectId: "my-project-id",
    roomId: "my-room-id",
    threadId: "my-thread-id",
    updatedAt: "2021-10-06T01:45:56.558Z",
    updatedBy: "my-user-id",
  },
};
```

#### CommentMetadataUpdatedEvent

An event is triggered when a commentâ€™s metadata is updated. This event is not
throttled.

```ts
// Schema
type CommentMetadataUpdatedEvent = {
  type: "commentMetadataUpdated";
  data: {
    projectId: string;
    roomId: string;
    threadId: string;
    commentId: string;
    updatedAt: string;
    updatedBy: string;
  };
};

// Example
const commentMetadataUpdatedEvent = {
  type: "commentMetadataUpdated",
  data: {
    projectId: "my-project-id",
    roomId: "my-room-id",
    threadId: "my-thread-id",
    commentId: "my-comment-id",
    updatedAt: "2021-10-06T01:45:56.558Z",
    updatedBy: "my-user-id",
  },
};
```

#### ThreadMarkedAsResolvedEvent

An event is triggered when a thread is marked as resolved. This event is not
throttled.

```ts
// Schema
type ThreadMarkedAsResolvedEvent = {
  type: "threadMarkedAsResolved";
  data: {
    projectId: string;
    roomId: string;
    threadId: string;
    updatedAt: string;
    updatedBy: string;
  };
};

// Example
const threadMarkedAsResolvedEvent = {
  type: "threadMarkedAsResolved",
  data: {
    projectId: "my-project-id",
    roomId: "my-room-id",
    threadId: "my-thread-id",
    updatedAt: "2021-10-06T01:45:56.558Z",
    updatedBy: "my-user-id",
  },
};
```

#### ThreadMarkedAsUnresolvedEvent

An event is triggered when a thread is marked as unresolved. This event is not
throttled.

```ts
// Schema
type ThreadMarkedAsUnresolvedEvent = {
  type: "threadMarkedAsUnresolved";
  data: {
    projectId: string;
    roomId: string;
    threadId: string;
    updatedAt: string;
    updatedBy: string;
  };
};

// Example
const threadMarkedAsUnresolvedEvent = {
  type: "threadMarkedAsUnresolved",
  data: {
    projectId: "my-project-id",
    roomId: "my-room-id",
    threadId: "my-thread-id",
    updatedAt: "2021-10-06T01:45:56.558Z",
    updatedBy: "my-user-id",
  },
};
```

#### NotificationEvent

Notification events are designed to help you create notification emails for your
users. By default, theyâ€™re triggered 30 minutes after an activity occurs, but
this number can be modified in your [dashboard](/dashboard) inside a projectâ€™s
settings.

This webhook event is triggered by both Liveblocks and custom notification
`kinds`, as detailed below.

##### Thread notification

When using [Comments](/docs/ready-made-features/comments), an event is triggered
30 minutes after a user has been mentioned or replied to in a thread, and has
not seen the thread. It will also be triggered if the user has subscribed to the
thread and has not seen the thread. The event wonâ€™t be triggered if the user has
seen the thread or unsubscribed from the roomâ€™s thread notifications. This is
the Liveblocks `thread` notification kind.

```ts
// Schema
type ThreadNotificationEvent = {
  type: "notification";
  data: {
    channel: "email";
    kind: "thread";
    projectId: string;
    roomId: string;
    userId: string;
    threadId: string;
    inboxNotificationId: string;
    // Date representing the time when the webhook event was created.
    createdAt: string;
    // Date representing the time when the notification itself was created.
    triggeredAt: string;
  };
};

// Example
const threadNotificationEvent = {
  type: "notification",
  data: {
    channel: "email",
    kind: "thread",
    projectId: "my-project-id",
    roomId: "my-room-id",
    userId: "my-user-id",
    threadId: "my-thread-id",
    inboxNotificationId: "my-inbox-notification-id",
    createdAt: "2021-10-06T01:45:56.558Z",
    triggeredAt: "2021-10-06T01:50:56.558Z",
  },
};
```

If you want to easily identify this event in your code then you can use the type
guard
[`isThreadNotificationEvent`](/docs/api-reference/liveblocks-node#isThreadNotificationEvent).

##### TextMention notification

When using [Text editor](/docs/ready-made-features/text-editor), an event is
triggered 30 minutes after a user has been mentioned in a text and has not seen
the text mention. This is the Liveblocks `textMention` notification kind.

```ts
// Schema
type TextMentionNotificationEvent = {
  type: "notification";
  data: {
    channel: "email";
    kind: "textMention";
    projectId: string;
    roomId: string;
    userId: string;
    mentionId: string;
    inboxNotificationId: string;
    // Date representing the time when the webhook event was created.
    createdAt: string;
    // Date representing the time when the notification itself was created.
    triggeredAt: string;
  };
};

// Example
const textMentionNotificationEvent = {
  type: "notification",
  data: {
    channel: "email",
    kind: "textMention",
    projectId: "my-project-id",
    roomId: "my-room-id",
    userId: "my-user-id",
    mentionId: "my-mention-id",
    inboxNotificationId: "my-inbox-notification-id",
    createdAt: "2021-10-06T01:45:56.558Z",
    triggeredAt: "2021-10-06T01:50:56.558Z",
  },
};
```

If you want to easily identify this event in your code then you can use the type
guard
[`isTextMentionNotificationEvent`](/docs/api-reference/liveblocks-node#isTextMentionNotificationEvent).

##### Custom notification

An event is triggered 30 minutes after the user has been notified of a custom
event and has not seen the notification. All custom notification `kinds` are
prefixed with `$` and are manually by you on the server. Learn more about
[triggering custom notifications](/docs/api-reference/rest-api-endpoints#post-inbox-notifications-trigger).

```ts
// Schema
type CustomNotificationEvent = {
  type: "notification";
  data: {
    channel: "email";
    kind: "$yourKind"; // Can be any string starting with "$" as defined by the user
    projectId: string;
    roomId: string | null;
    userId: string;
    inboxNotificationId: string;
    // Date representing the time when the webhook event was created.
    createdAt: string;
    // Date representing the time when the notification itself was created.
    triggeredAt: string;
  };
};

// Example
const customNotificationEvent = {
  type: "notification",
  data: {
    channel: "email",
    kind: "$fileUpload",
    projectId: "my-project-id",
    roomId: "my-room-id",
    userId: "my-user-id",
    inboxNotificationId: "my-inbox-notification-id",
    createdAt: "2021-10-06T01:45:56.558Z",
    triggeredAt: "2021-10-06T01:50:56.558Z",
  },
};
```

If you want to easily identify this event in your code then you can use the type
guard
[`isCustomNotificationEvent`](/docs/api-reference/liveblocks-node#isCustomNotificationEvent).

## Use Cases

With webhooks, you can subscribe to the events you are interested in, and be
alerted of the change when it happens. Powerful ways to leverage webhooks with
Liveblocks include:

- Storage synchronization between room(s) and an internal database
- Monitoring user activity in a room
- Notifying the client if maximum concurrency has been reached

Webhooks are an excellent way to reduce development time and the need for
polling. By following the steps outlined in this guide, youâ€™ll be able to
configure, subscribe to, secure, and replay webhook events with Liveblocks.

If you have any questions or need help using webhooks, please let us know
[by email](mailto:support@liveblocks.io) or by joining our
[Discord community](/discord)! Weâ€™re here to help!

---
meta:
  title: "WebSocket infrastructure"
  parentTitle: "Platform"
  description: "Learn about the Liveblocks WebSocket infrastructure."
---

## WebSocket edge network

The Liveblocks WebSocket edge network enables you to automatically create
collaborative rooms in regions close to your users, reducing latency and
improving end-user performance while enabling you to scale effortlessly.

<Figure highlight>
  <Image
    src="/assets/websocket-infrastructure/edge-network.png"
    alt="Liveblocks WebSocket edge network"
    width={768}
    height={440}
  />
</Figure>

The Liveblocks WebSocket edge network primarily uses the
[Cloudflare Workers](https://workers.cloudflare.com/) global network, spanning
300 cities and 100+ countries, enabling a ~50ms connection to 95% of the worldâ€™s
internet-connected population.

## WebSocket connection engine

The Liveblocks WebSocket connection engine ensures a reliable realtime
experience for users. It handles offline, reconnections, and all sorts of
edge-cases automatically so you donâ€™t have to. See
[API reference](/docs/api-reference/liveblocks-client#Room.getStatus) to learn
more.

<Figure highlight>
  <Image
    src="/assets/websocket-infrastructure/connection-engine.png"
    alt="Liveblocks WebSocket connection engine"
    width={820}
    height={482}
  />
</Figure>

---
meta:
  title: "Plans"
  parentTitle: "Pricing"
  description: "Learn about the different plans available on Liveblocks."
---

Liveblocks offers three plans: Free, Pro, and Enterprise. Each plan is designed
to meet the needs of different types of developers, from personal projects to
large enterprises.

## Free

The Free plan is ideal for personal projects, prototyping, and testing. It
includes access to Liveblocksâ€™ collaboration infrastructure, ready-made features
(Comments, Multiplayer, AI Agents, Notifications), and pre-built components,
with up to <Limits.FreeMaxMonthlyActiveRooms /> monthly active rooms included.
When you exceed your free limits, users wonâ€™t be able to join rooms.

[Learn more about the Free plan](/docs/pricing/plans/free)

## Pro

The Pro plan is designed for developers shipping collaborative experiences in
production. It includes everything in Free, but enables you to remove the
"Powered by Liveblocks" badge, and allows you to go beyond the
included{/* prettier-ignore */} <Limits.ProMonthlyActiveRoomsIncluded /> monthly active rooms via pay-as-you-go overage. You can also buy the Unlimited Version History add-on.

[Learn more about the Pro plan](/docs/pricing/plans/pro)

## Team

The Team plan is designed for teams shipping collaborative experiences in
production with the ability to scale. It includes everything in Pro, plus SAML
Single Sign-on (SSO), SOC 2, and a private Slack channel. You can also request a
HIPAA Business Associate Agreement (BAA) as a paid add-on.

[Learn more about the Team plan](/docs/pricing/plans/team)

### Add-ons

| Add-on                    | Price                                                     |
| ------------------------- | --------------------------------------------------------- |
| Unlimited Version History | $100 per month <InfoTooltip>Billed annually</InfoTooltip> |
| HIPAA BAA                 | $350 per month <InfoTooltip>Billed annually</InfoTooltip> |

## Enterprise

The Enterprise plan is tailored for organizations with advanced security,
compliance, and scalability requirements. It includes everything in Team, plus
multi-region hosting, a management API, SCIM/directory sync, advanced
permissions, custom usage allocations, and higher-touch support options such as
SLAs and solution engineering.

[Learn more about the Enterprise plan](/docs/pricing/plans/enterprise)

## General billing information

### Where do I understand my usage?

You can monitor usage for your projects on the [usage page](/dashboard/usage) of
your dashboard.

### What happens when I reach 100% usage?

All plans receive notifications by email when they are approaching and exceed
their [usage limits](/docs/platform/limits).

Free plans will be paused when they exceed the included free tier usage.

For Pro and Enterprise plans, when you reach 100% usage your projects are not
automatically stopped. Rather, Liveblocks enables you to incur on-demand usage
as your application grows. Itâ€™s important to be aware of
[the usage page](/dashboard/usage) of your dashboard to see if you are
approaching your limit.

## Powered by Liveblocks branding

By default, Liveblocks displays a "Powered by Liveblocks" badge in your
application. You can adjust the position of the badge by setting the
`badgeLocation` property on
[`LiveblocksProvider`](/docs/api-reference/liveblocks-react#LiveblocksProvider).

```tsx title="Set badge location"
// "top-right", "bottom-right", "bottom-left", "top-left"
<LiveblocksProvider badgeLocation="bottom-right">
  <App />
</LiveblocksProvider>
```

If you wish to remove remove the badge entirely, you can do so by following
these steps:

1. In the Liveblocks dashboard, navigate to your
   [teamâ€™s settings](/dashboard/settings).
2. Under **General**, toggle on the remove "Powered by Liveblocks" branding
   option.

<Banner title='Removing the "Powered by Liveblocks" badge'>

Removing the "Powered by Liveblocks" badge on your projects requires a
[paid plan](/pricing/). See the [pricing page](/pricing/) for more information.

</Banner>

---
meta:
  title: "Liveblocks Enterprise plan"
  parentTitle: "Plans"
  description: "Learn about the Liveblocks Enterprise plan."
---

The Enterprise plan is tailored for organizations with advanced security,
compliance, and scalability requirements. It includes everything in Team, plus
multi-region hosting, a management API, SCIM/directory sync, advanced
permissions, custom usage allocations, and higher-touch support options with
SLAs and solution engineering.

## Security and compliance

Built-in support for global security and data protection standards, including:

- [Multi-factor authentication enforcement](/docs/platform/account-management/mfa)
- [SAML SSO](/docs/platform/account-management/saml)
- [Directory sync (SCIM)](/docs/platform/account-management/directory-sync)
- SOC 2 Report
- HIPAA BAA
- Custom security reviews
- 99.99% uptime SLA

## Observability and reporting

Gain actionable insights with enhanced observability & logging:

- Extended event log retention
- External observability integrations (soon)

## Administration and support

The Enterprise plan allows for streamlined team collaboration and offers robust
support with:

- Role-Based Access Control (RBAC)
- A dedicated solution engineer
- SLAs, including response time

---
meta:
  title: "Liveblocks Free plan"
  parentTitle: "Plans"
  description: "Learn about the Liveblocks Free plan."
---

The Free plan is aimed at developers with personal projects, and small-scale
applications. It offers a generous set of features for individual users on a per
month basis.

|                                                                                                                                                                                                                                                                                                        | Free included usage                               |
| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------- |
| <a href="/docs/platform/limits#What-is-a-monthly-active-room">Monthly active rooms</a>                                                                                                                                                                                                                 | <Limits.FreeMaxMonthlyActiveRooms />              |
| <a href="/docs/platform/limits#What-is-a-monthly-active-user">Monthly active users</a>                                                                                                                                                                                                                 | <Limits.FreeMaxMau />                             |
| <a href="/docs/platform/projects">Projects</a>                                                                                                                                                                                                                                                         | <Limits.FreeMaxProjects />                        |
| <a href="/docs/platform/account-management/manage-team-members">Team members</a>                                                                                                                                                                                                                       | <Limits.FreeMaxTeamMembersPerAccount />           |
| <a href="/docs/platform/limits#What's-a-simultaneous-connection-per-room" title="Learn more">Simultaneous connections per room</a>                                                                                                                                                                     | <Limits.FreeMaxConnectionsPerRoom />              |
| <a href="/docs/platform/limits#What's-a-simultaneous-connection-per-project">Simultaneous connections per project</a>                                                                                                                                                                                  | <Limits.FreeMaxConnectionsPerProject />           |
| Monthly anonymous connections <InfoTooltip>Public key only recommended for prototyping. <a href="/docs/authentication" className="font-medium">Set up authentication</a>.</InfoTooltip>                                                                                                                | <Limits.FreeMaxAnonymousConnections />            |
| Realtime data storage <InfoTooltip>This is a cumulative calculation that represents all data that is currently stored. It does not reset monthly, and the total usage will continue to accrue over time as you add more content and data.</InfoTooltip>                                                | <Limits.FreeMaxRealtimeDataStorage />             |
| Realtime data stored per room                                                                                                                                                                                                                                                                          | <Limits.FreeMaxStorageSizePerRoom />              |
| File storage <InfoTooltip>This is a cumulative calculation that represents all files that are stored with Liveblocks. It does not reset monthly, and the total usage will continue to accrue over time as you add more files. Files can be uploaded as comment attachments for instance.</InfoTooltip> | <Limits.FreeMaxFileStorage />                     |
| Max file upload size                                                                                                                                                                                                                                                                                   | <Limits.FreeMaxFileUploadSize />                  |
| Comments stored                                                                                                                                                                                                                                                                                        | <Limits.FreeMaxComments />                        |
| Monthly collaboration notifications <InfoTooltip>Notifications automatically triggered from collaborative features like comment thread updates and @ mentions.</InfoTooltip>                                                                                                                           | <Limits.FreeMaxCollaborationNotifications />      |
| Monthly custom notifications <InfoTooltip>Non-collaborative notifications that can be triggered from your own code.</InfoTooltip>                                                                                                                                                                      | <Limits.FreeMaxCustomNotifications />             |
| Webhook event frequency <InfoTooltip>The frequency at which `yDocUpdated` (Yjs) and `storageUpdated` (Liveblocks Storage) events are sent to your webhook endpoint. <a href="/docs/platform/webhooks#StorageUpdatedEvent" className="font-medium">Learn more</a></InfoTooltip>                         | <Limits.FreeStorageUpdatedWebhookEventThrottle /> |
| Version history <InfoTooltip>APIs, hooks, and pre-built components to access the previous versions of the realtime data stored in rooms.</InfoTooltip>                                                                                                                                                 | <Limits.FreeVersionHistory />                     |
| Event log retention                                                                                                                                                                                                                                                                                    | <Limits.FreeEventLogRetention />                  |

## Billing cycle

Even though the Free plan has no cost, usage limits follow a monthly billing
cycle that starts on the 1st of each month and ends on the last day of the
month. If you exceed your usage limits, youâ€™ll need to wait until the next
calendar month for limits to reset. Alternatively, you can upgrade to
[Pro](/dashboard/billing?plan=pro) or [Team](/dashboard/billing?plan=team) to
access pay-as-you-go overage and avoid waiting for the next billing cycle.

---
meta:
  title: "Liveblocks Pro plan"
  parentTitle: "Plans"
  description: "Learn about the Liveblocks Pro plan."
---

The Pro plan is designed for developers shipping collaborative experiences in
production. It includes everything in Free, but enables you to remove the
"Powered by Liveblocks" badge, and allows you to go beyond the
included{/* prettier-ignore */} <Limits.ProMonthlyActiveRoomsIncluded /> monthly active rooms via pay-as-you-go overage. You can also buy the Unlimited Version History add-on.

| Item                                                                                                                                                                                                                                                                                                   | Pro included usage                                                                                                                                    |
| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------- |
| <a href="/docs/platform/limits#What-is-a-monthly-active-room">Monthly active rooms</a>                                                                                                                                                                                                                 | <Limits.ProMonthlyActiveRoomsIncluded /> included<br /><span className="text-xs text-product-subtlest"><Limits.ProMonthlyActiveRoomsOverage /></span> |
| <a href="/docs/platform/limits#What-is-a-monthly-active-user">Monthly active users</a>                                                                                                                                                                                                                 | <Limits.ProMaxMau />                                                                                                                                  |
| <a href="/docs/platform/projects">Projects</a>                                                                                                                                                                                                                                                         | <Limits.ProMaxProjects />                                                                                                                             |
| <a href="/docs/platform/account-management/manage-team-members">Team members</a>                                                                                                                                                                                                                       | <Limits.ProTeamMembersPerAccount /> included<br /><span className="text-xs text-product-subtlest"><Limits.ProTeamMembersPerAccountOverage /></span>   |
| <a href="/docs/platform/limits#What's-a-simultaneous-connection-per-room" title="Learn more">Simultaneous connections per room</a>                                                                                                                                                                     | <Limits.ProMaxConnectionsPerRoom />                                                                                                                   |
| <a href="/docs/platform/limits#What's-a-simultaneous-connection-per-project">Simultaneous connections per project</a>                                                                                                                                                                                  | <Limits.ProMaxConnectionsPerProject />                                                                                                                |
| Monthly anonymous connections <InfoTooltip>Public key only recommended for prototyping. <a href="/docs/authentication" className="font-medium">Set up authentication</a>.</InfoTooltip>                                                                                                                | <Limits.ProMaxAnonymousConnections />                                                                                                                 |
| Realtime data storage <InfoTooltip>This is a cumulative calculation that represents all data that is currently stored. It does not reset monthly, and the total usage will continue to accrue over time as you add more content and data.</InfoTooltip>                                                | <Limits.ProRealtimeDataStorage /> included<br /><span className="text-xs text-product-subtlest"><Limits.ProRealtimeDataStorageOverage /></span>       |
| Realtime data stored per room                                                                                                                                                                                                                                                                          | <Limits.ProMaxStorageSizePerRoom />                                                                                                                   |
| File storage <InfoTooltip>This is a cumulative calculation that represents all files that are stored with Liveblocks. It does not reset monthly, and the total usage will continue to accrue over time as you add more files. Files can be uploaded as comment attachments for instance.</InfoTooltip> | <Limits.ProFileStorage /> included<br /><span className="text-xs text-product-subtlest"><Limits.ProFileStorageOverage /></span>                       |
| Max file upload size                                                                                                                                                                                                                                                                                   | <Limits.ProMaxFileUploadSize />                                                                                                                       |
| Comments stored                                                                                                                                                                                                                                                                                        | <Limits.ProMaxComments />                                                                                                                             |
| Monthly collaboration notifications <InfoTooltip>Notifications automatically triggered from collaborative features like comment thread updates and @ mentions.</InfoTooltip>                                                                                                                           | <Limits.ProMaxCollaborationNotifications />                                                                                                           |
| Monthly custom notifications <InfoTooltip>Non-collaborative notifications that can be triggered from your own code.</InfoTooltip>                                                                                                                                                                      | <Limits.ProCustomNotifications /> included<br /><span className="text-xs text-product-subtlest"><Limits.ProCustomNotificationsOverage /></span>       |
| Webhook event frequency <InfoTooltip>The frequency at which `yDocUpdated` (Yjs) and `storageUpdated` (Liveblocks Storage) events are sent to your webhook endpoint. <a href="/docs/platform/webhooks#StorageUpdatedEvent" className="font-medium">Learn more</a></InfoTooltip>                         | <Limits.ProStorageUpdatedWebhookEventThrottle />                                                                                                      |
| Version history <InfoTooltip>APIs, hooks, and pre-built components to access the previous versions of the realtime data stored in rooms.</InfoTooltip>                                                                                                                                                 | <Limits.ProVersionHistory /> <InfoTooltip>Unlimited with Version History Plus addâ€‘on</InfoTooltip>                                                    |
| Event log retention                                                                                                                                                                                                                                                                                    | <Limits.ProEventLogRetention />                                                                                                                       |

## Billing cycle

The Pro plan follows a monthly billing cycle that starts on the 1st of each
month and ends on the last day of the month. Included usage resets at the
beginning of each billing cycle. Any usage beyond the included amounts is
charged on a pay-as-you-go basis and appears on your monthly invoice.

## Add-ons

| Add-on                    | Price                                                     |
| ------------------------- | --------------------------------------------------------- |
| Unlimited Version History | $100 per month <InfoTooltip>Billed annually</InfoTooltip> |

---
meta:
  title: "Liveblocks Team plan"
  parentTitle: "Plans"
  description: "Learn about the Liveblocks Team plan."
---

The Team plan is designed for teams shipping collaborative experiences in
production with the ability to scale. It includes everything in Pro, plus SAML
Single Sign-on (SSO), SOC 2, and a private Slack channel. You can also request a
HIPAA Business Associate Agreement (BAA) as a paid add-on.

| Item                                                                                                                                                                                                                                                                                                   | Team included usage                                                                                                                                     |
| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------- |
| <a href="/docs/platform/limits#What-is-a-monthly-active-room">Monthly active rooms</a>                                                                                                                                                                                                                 | <Limits.TeamMonthlyActiveRoomsIncluded /> included<br /><span className="text-xs text-product-subtlest"><Limits.TeamMonthlyActiveRoomsOverage /></span> |
| <a href="/docs/platform/limits#What-is-a-monthly-active-user">Monthly active users</a>                                                                                                                                                                                                                 | <Limits.TeamMaxMau />                                                                                                                                   |
| <a href="/docs/platform/projects">Projects</a>                                                                                                                                                                                                                                                         | <Limits.TeamMaxProjects />                                                                                                                              |
| <a href="/docs/platform/account-management/manage-team-members">Team members</a>                                                                                                                                                                                                                       | <Limits.TeamTeamMembersPerAccount /> included<br /><span className="text-xs text-product-subtlest"><Limits.TeamTeamMembersPerAccountOverage /></span>   |
| <a href="/docs/platform/limits#What's-a-simultaneous-connection-per-room" title="Learn more">Simultaneous connections per room</a>                                                                                                                                                                     | <Limits.TeamMaxConnectionsPerRoom />                                                                                                                    |
| <a href="/docs/platform/limits#What's-a-simultaneous-connection-per-project">Simultaneous connections per project</a>                                                                                                                                                                                  | <Limits.TeamMaxConnectionsPerProject />                                                                                                                 |
| Monthly anonymous connections <InfoTooltip>Public key only recommended for prototyping. <a href="/docs/authentication" className="font-medium">Set up authentication</a>.</InfoTooltip>                                                                                                                | <Limits.TeamMaxAnonymousConnections />                                                                                                                  |
| Realtime data storage <InfoTooltip>This is a cumulative calculation that represents all data that is currently stored. It does not reset monthly, and the total usage will continue to accrue over time as you add more content and data.</InfoTooltip>                                                | <Limits.TeamRealtimeDataStorage /> included<br /><span className="text-xs text-product-subtlest"><Limits.TeamRealtimeDataStorageOverage /></span>       |
| Realtime data stored per room                                                                                                                                                                                                                                                                          | <Limits.TeamMaxStorageSizePerRoom />                                                                                                                    |
| File storage <InfoTooltip>This is a cumulative calculation that represents all files that are stored with Liveblocks. It does not reset monthly, and the total usage will continue to accrue over time as you add more files. Files can be uploaded as comment attachments for instance.</InfoTooltip> | <Limits.TeamFileStorage /> included<br /><span className="text-xs text-product-subtlest"><Limits.TeamFileStorageOverage /></span>                       |
| Max file upload size                                                                                                                                                                                                                                                                                   | <Limits.TeamMaxFileUploadSize />                                                                                                                        |
| Comments stored                                                                                                                                                                                                                                                                                        | <Limits.TeamMaxComments />                                                                                                                              |
| Monthly collaboration notifications <InfoTooltip>Notifications automatically triggered from collaborative features like comment thread updates and @ mentions.</InfoTooltip>                                                                                                                           | <Limits.TeamMaxCollaborationNotifications />                                                                                                            |
| Monthly custom notifications <InfoTooltip>Non-collaborative notifications that can be triggered from your own code.</InfoTooltip>                                                                                                                                                                      | <Limits.TeamCustomNotifications /> included<br /><span className="text-xs text-product-subtlest"><Limits.TeamCustomNotificationsOverage /></span>       |
| Webhook event frequency <InfoTooltip>The frequency at which `yDocUpdated` (Yjs) and `storageUpdated` (Liveblocks Storage) events are sent to your webhook endpoint. <a href="/docs/platform/webhooks#StorageUpdatedEvent" className="font-medium">Learn more</a></InfoTooltip>                         | <Limits.TeamStorageUpdatedWebhookEventThrottle />                                                                                                       |
| Version history <InfoTooltip>APIs, hooks, and pre-built components to access the previous versions of the realtime data stored in rooms.</InfoTooltip>                                                                                                                                                 | <Limits.TeamVersionHistory /> <InfoTooltip>Unlimited with Version History Plus addâ€‘on</InfoTooltip>                                                     |
| Event log retention                                                                                                                                                                                                                                                                                    | <Limits.TeamEventLogRetention />                                                                                                                        |

## Billing cycle

The Team plan follows a monthly billing cycle that starts on the 1st of each
month and ends on the last day of the month. Included usage resets at the
beginning of each billing cycle. Any usage beyond the included amounts is
charged on a pay-as-you-go basis and appears on your monthly invoice.

## Add-ons

| Add-on                    | Price                                                     |
| ------------------------- | --------------------------------------------------------- |
| Unlimited Version History | $100 per month <InfoTooltip>Billed annually</InfoTooltip> |
| HIPAA BAA                 | $350 per month <InfoTooltip>Billed annually</InfoTooltip> |

---
meta:
  title: "AI Agents"
  parentTitle: "Ready-made features"
  description: "The fastest way to add AI collaborators to your product"
---

AI Agents let you embed AI teammates directly into your app. Agents can respond
to messages, handle @mentions, perform actions, and collaborate inside your
productâ€”just like human users. Use a simple built-in copilot powered by any LLM,
or connect your own agent framework such as n8n or LangChain.

## Key features

### Liveblocks AI Copilots

Built-in agents you can configure directly in Liveblocks.

- Works with popular LLMs (OpenAI, Anthropic, Gemini).
- Add domain knowledge from text, PDFs, websites, or images (RAG).
- Fully compatible with the `<AiChat />` React component.
- Define behavior through simple prompts and settings.
- No backend requiredâ€”everything runs via the client SDK.

<Button asChild>
  <a href="/docs/ready-made-features/ai-agents/liveblocks-ai-copilots">
    Learn more about Liveblocks AI Copilots
  </a>
</Button>

### Framework agents (private beta)

Bring your own multi-agent logic or external workflows.

- Connect n8n, LangChain, Crew AI, or your own agent system.
- Receive room events (mentions, messages, actions) via webhooks.
- Return actions that update UI, add comments, respond to users, or trigger
  workflows.
- Ideal for multi-agent orchestration, automation, and complex pipelines.
- Works with any server-side runtime or architecture.

<Banner type="info" title="Private beta">

Framework agents are currently in private beta. If you would like access to the
beta, please [contact us](https://liveblocks.io/contact/sales). Weâ€™d love to
hear from you.

</Banner>

---
meta:
  title: "Liveblocks AI Copilots"
  parentTitle: "AI Agents"
  description: "Easily integrate customizable AI copilots into your product"
---

Embed customizable AI copilots into your product, enabling your users to
collaborate with AI. Features include contextual chat, and AI toolbars, which
can understand and modify your application state.

## Overview

{/* TODO make more icons */}

<ListGrid columns={2}>
  <DocsCard
    type="technology"
    title="Features"
    href="/docs/ready-made-features/ai-copilots/features"
    description="Learn about chats, actions, integrations"
    visual={<DocsFeaturesIcon className="fill-product-icon-brand h-auto w-6" />}
  />
  <DocsCard
    type="technology"
    title="Copilots"
    href="/docs/ready-made-features/ai-copilots/copilots"
    description="Choose an AI model and configure your copilot"
    visual={<DocsRobotIcon className="fill-product-icon-brand h-auto w-6" />}
  />
  <DocsCard
    type="technology"
    title="Default components"
    href="/docs/ready-made-features/ai-copilots/default-components"
    description="Ready-to-use customizable components"
    visual={
      <DocsDefaultComponentsIcon className="fill-product-icon-brand h-auto w-6" />
    }
  />
  <DocsCard
    type="technology"
    title="Hooks"
    href="/docs/ready-made-features/ai-copilots/hooks"
    description="Fetch, create, & modify AI chats"
    visual={<DocsHooksIcon className="fill-product-icon-brand h-auto w-6" />}
  />
  <DocsCard
    type="technology"
    title="Knowledge"
    href="/docs/ready-made-features/ai-copilots/knowledge"
    description="Provide AI with a knowledge base & context"
    visual={
      <DocsKnowledgeIcon className="fill-product-icon-brand h-auto w-6" />
    }
  />
  <DocsCard
    type="technology"
    title="Tools"
    href="/docs/ready-made-features/ai-copilots/tools"
    description="Allow AI to interact with your application"
    visual={<DocsToolIcon className="fill-product-icon-brand h-auto w-6" />}
  />
  <DocsCard
    type="technology"
    title="Styling and customization"
    href="/docs/ready-made-features/ai-copilots/styling-and-customization"
    description="CSS variables, dark mode, localization"
    visual={<DocsStylingIcon className="fill-product-icon-brand h-auto w-6" />}
  />
  <DocsCard
    type="technology"
    title="Troubleshooting"
    href="/docs/ready-made-features/ai-copilots/troubleshooting"
    description="Troubleshoot common issues"
    visual={
      <DocsTroubleshootingIcon className="fill-product-icon-brand h-auto w-6" />
    }
  />
</ListGrid>

## AI Copilots API Reference

<ListGrid columns={2}>
  <DocsCard
    type="technology"
    title="React"
    href="/docs/api-reference/liveblocks-react#AI-Copilots"
    description="@liveblocks/react"
    visual={<DocsReactIcon />}
  />
  <DocsCard
    type="technology"
    title="React UI"
    href="/docs/api-reference/liveblocks-react-ui#AI-Copilots"
    description="@liveblocks/react-ui"
    visual={<DocsReactIcon />}
  />
  <DocsCard
    type="technology"
    title="JavaScript"
    href="/docs/api-reference/liveblocks-client#AI-Copilots"
    description="@liveblocks/client"
    visual={<DocsJavascriptIcon />}
  />
  <DocsCard
    type="technology"
    title="Node.js"
    href="/docs/api-reference/liveblocks-node#AI-Copilots"
    description="@liveblocks/node"
    visual={<DocsNodejsIcon className="fill-product-icon-brand h-auto w-6" />}
  />
  <DocsCard
    type="technology"
    title="REST API"
    href="/docs/api-reference/rest-api-endpoints#AI"
    description="HTTP endpoints"
    visual={<DocsApiIcon className="fill-product-icon-brand h-auto w-6" />}
  />
</ListGrid>

## Examples

<ListGrid columns={2}>
  <ExampleCard
    example={{
      title: "AI Popup Chat",
      slug: "ai-popup/nextjs-ai-popup",
      image: "/images/examples/thumbnails/ai-popup.jpg",
    }}
    technologies={["nextjs", "react"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "AI Reports Dashboard",
      slug: "ai-dashboard-reports/nextjs-ai-dashboard-reports",
      image: "/images/examples/thumbnails/ai-reports-dashboard.jpg",
    }}
    technologies={["nextjs", "react"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "AI Chats",
      slug: "ai-chats/nextjs-ai-chats",
      image: "/images/examples/thumbnails/ai-chats.jpg",
    }}
    technologies={["nextjs", "react"]}
    openInNewWindow
  />
</ListGrid>

## Try AI Copilots

If youâ€™d like to try AI Copilots, [book a demo with our team](/contact/sales),
and weâ€™ll reach out to you and enable it on your account.

---
meta:
  title: "Copilots"
  parentTitle: "AI Copilots"
  description: "Customizable AI copilots"
---

AI Copilots provides a default copilot for testing, but you should define a
custom copilot in the [Liveblocks dashboard](/dashboard) for further development
and production. This allows you to configure your AI model, system prompt,
back-end knowledge, and more.

## Creating a copilot

To create a copilot, open the [Liveblocks dashboard](/dashboard), select a
project and click on the â€œAI Copilotsâ€ page. Click on the â€œCreate copilotâ€
button, and fill in the required fields.

<Figure>
  <Image
    src="/assets/ai-copilots/create-copilot.png"
    alt="Screenshot of the Liveblocks dashboard with the AI Copilots page and the Create copilot button"
    width={720}
    height={409}
    quality={100}
  />
</Figure>

### Get your API key

Copilots use API keys provided by your AI provider, which can be created and
copied on their respective websites. Out of the box, we support
[OpenAI](https://platform.openai.com/api-keys),
[Anthropic](https://console.anthropic.com/settings/keys), and
[Google](https://aistudio.google.com/app/api-keys), but, you can use other
OpenAI-compatible APIs, such as [Groq](https://groq.com/api-keys) and
[OpenRouter](https://openrouter.ai/settings/keys).

## Add the copilot to your application

To use the new copilot in your application, copy your copilot ID from the
dashboard.

<Figure>
  <video autoPlay loop muted playsInline>
    <source src="/assets/ai-copilots/create-copilot-2.mp4" type="video/mp4" />
  </video>
</Figure>

Paste the copilot ID into
[`AiChat`](/docs/api-reference/liveblocks-react-ui#AiChat) and
[`useSendAiMessage`](/docs/api-reference/liveblocks-react#useSendAiMessage) to
start using it.

```tsx
import { AiChat } from "@liveblocks/react-ui";

function Chat() {
  return (
    <AiChat
      chatId="my-chat-id"
      // +++
      copilotId="co_tUYtNctLAtUIAAIZBc1Zk"
      // +++
    />
  );
}
```

```tsx
import { useSendAiMessage } from "@liveblocks/react";

function SendMessage() {
  const sendAiMessage = useSendAiMessage("my-chat-id", {
    // +++
    copilotId: "co_tUYtNctLAtUIAAIZBc1Zk",
    // +++
  });

  return (
    <button onClick={() => sendAiMessage("What's new?")}>What's new?</button>
  );
}
```

## Configuring your copilot

Within the â€œGeneralâ€ tab you can configure a number of settings for your
copilot. Settings slightly differ between providers.

### Name

The name of your AI Copilot, which will be displayed in the dashboard.

```text title="Name"
My AI Copilot
```

### Provider

This is the AI provider you want to use for your copilot. You can choose from
[OpenAI](https://platform.openai.com/api-keys),
[Anthropic](https://console.anthropic.com/settings/keys), and
[Google](https://aistudio.google.com/app/api-keys), and other OpenAI-compatible
APIs, such as [Groq](https://groq.com/api-keys). Using an OpenAI-compatible tool
like OpenRouter allows you to
[define fallback models](/docs/guides/how-to-use-fallback-ai-models-in-ai-copilots).

```text title="Provider"
OpenAI
```

### Model

The AI model you want to use for your copilot, such as `GPT-4.1` or
`Claude 4 Sonnet`. You can choose from the models supported by your provider.
With third-party tools you can
[define fallback models](/docs/guides/how-to-use-fallback-ai-models-in-ai-copilots).

```text title="Model"
GPT-4.1
```

### Custom provider name

If youâ€™re using an OpenAI-compatible provider, you can define a custom provider
name, which you may find on your providerâ€™s website. If a custom provider name
isnâ€™t needed by your provider, you can use any string.

```text title="Custom provider name"
custom-provider
```

### Base URL

If youâ€™re using an OpenAI-compatible provider, you must define a base URL, which
you can find on your providerâ€™s website.

```text title="Base URL"
https://openrouter.ai/api/v1/
```

### Reasoning effort, extended thinking, thinking budget

Reasoning is supported by some models, allowing AI show its thought processes,
and come up with more accurate answers. Some models allow you to select a
reasoning effort, such as `low`, `medium`, or `high`, or a token budget for
extended thinking.

```text title="Reasoning effort"
low
```

### Web search

Toggle web searching, allowing your AI to query the internet for information.

```text title="Web search"
on
```

### Limit web search to specific domains

When web search is enabled, limit the domains that the AI can search. Will
search both `http://` and `https://` URLs. Subdomains are allowed.

```text title="Limit web search to specific domains"
encyclopedia.com
en.wikipedia.org
```

### API key

The API key for your provider. You can find keys on each providerâ€™s website:
[OpenAI](https://platform.openai.com),
[Anthropic](https://console.anthropic.com), and
[Google](https://aistudio.google.com). Also supports OpenAI-compatible APIs,
such as [Groq](https://groq.com/) and [OpenRouter](https://openrouter.ai). All
API keys are encrypted at rest, and never stored in plain text.

```text title="API key"
sk-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
```

### System prompt

The system prompt defines the behavior of the copilot, for example:

```text title="System prompt"
You're a helpful assistant that can answer questions and help with tasks.
```

You can create more complex system prompts by using
[Markdown formatting](https://www.markdownguide.org/basic-syntax/).

```text title="System prompt"
# Role and objective

You're a helpful assistant that can answer questions and help with tasks.

## Instructions

- Always help the user as best you can.
- Always use markdown formatting in your responses.
- If you don't know the answer, tell the user to contact support.

## Examples

User: How do I log in?
Assistant: Navigate to the [login page](/login) and enter your email.

User: What's the weather in Tokyo?
Assistant: I don't know the answer to that question, please contact support.
```

### When should AI use knowledge?

This setting determines when AI will search back-end knowledge before
responding.

```text title="When should AI use knowledge?"
Whenever the user asks a question about code.
```

You can also write a more complex prompt, giving knowledge a name, which then
allows you to refer to it in your system prompt. This can help reinforce AI
behavior.

```text title="When should AI use knowledge?"
Whenever the user asks a question about code.

// +++
This is your **knowledge base**.
// +++
```

```text title="System prompt"
## Instructions

// +++
- When a user asks about React, searching your **knowledge base** is required.
// +++
...
```

## Adding back-end knowledge

Under the â€œKnowledgeâ€ tab you can add back-end knowledge to your copilot.
Knowledge can be submitted as web pages or files, and your AI chat can query
this knowledge when responding, allowing it to intelligently answer questions or
perform tasks.

<Figure>
  <Image
    src="/assets/ai-copilots/copilot-knowledge.png"
    alt="Screenshot of the Liveblocks dashboard, adding knowledge to a copilot"
    width={720}
    height={409}
    quality={100}
  />
</Figure>

You can submit a whole website/sitemap for crawling, a single page, or PDF/image
files. Crawled knowledge is not updated, and to update it, it must be
resubmitted programmatically or via the dashboard.

## Configuring advanced settings

Under the â€œAdvancedâ€ tab you can configure a number of advanced settings for
your copilot. By default, Liveblocks does not pass default values to your
provider, and leaves the options blank.

| Setting                                                                                                                                                                                                                                                     | Description                                           | Example value          |
| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------- | ---------------------- |
| Max tokens <InfoTooltip>The maximum number of tokens that the copilot can use per response.</InfoTooltip>                                                                                                                                                   | Controls response length                              | `1024`                 |
| Temperature <InfoTooltip>Temperature setting. The value is passed through to the provider. The range depends on the provider and model. It is recommended to set either `temperature` or `topP`, but not both.</InfoTooltip>                                | Controls randomness in responses                      | `0.2`                  |
| Top P <InfoTooltip>Nucleus sampling. The value is passed through to the provider. The range depends on the provider and model. It is recommended to set either `temperature` or `topP`, but not both.</InfoTooltip>                                         | Alternative to temperature for controlling randomness | `0.9`                  |
| Top K <InfoTooltip>Only sample from the top K options for each subsequent token. Used to remove "long tail" low probability responses. Recommended for advanced use cases only. You usually only need to use temperature.</InfoTooltip>                     | Advanced sampling control                             | `200`                  |
| Presence penalty <InfoTooltip>Presence penalty setting. It affects the likelihood of the model to repeat information that is already in the prompt. The value is passed through to the provider. The range depends on the provider and model.</InfoTooltip> | Controls repetition of existing content               | `0.3`                  |
| Frequency penalty <InfoTooltip>Frequency penalty setting. It affects the likelihood of the model to repeatedly use the same words or phrases. The value is passed through to the provider. The range depends on the provider and model.</InfoTooltip>       | Controls repetition of words and phrases              | `0.3`                  |
| Stop sequences <InfoTooltip>Sequences that will stop the generation of the text. If the model generates any of these sequences, it will stop generating further text.</InfoTooltip>                                                                         | Controls when text generation stops                   | `["\\n\\n", "Human:"]` |
| Seed <InfoTooltip>The seed (integer) to use for random sampling. If set and supported by the model, calls will generate deterministic results.</InfoTooltip>                                                                                                | Controls randomness for reproducible results          | `42`                   |
| Max retries <InfoTooltip>Maximum number of retries. Set to 0 to disable retries. Default: 2.</InfoTooltip>                                                                                                                                                  | Controls how many times to retry failed requests      | `2`                    |

## Modifying copilots programmatically

You arenâ€™t limited to creating copilots from the dashboardâ€”you can also create
and modify copilots programmatically, allowing users or teams in your app to
have their own individual copilots.

```ts
import { Liveblocks } from "@liveblocks/node";

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

// +++
const copilot = await liveblocks.createAiCopilot({
  name: "My AI Assistant",
  systemPrompt: "You're a helpful assistant that can answer questions.",
  provider: "openai",
  providerModel: "gpt-4",
  providerApiKey: "sk-...",
});
// +++
```

This is made possible using the
[Liveblocks Node.js client](/docs/api-reference/liveblocks-node#AI-Copilots) and
[REST API](/docs/api-reference/rest-api-endpoints#AI), where a number of APIs
are available for managing copilots.

- [`getAiCopilots`](/docs/api-reference/liveblocks-node#get-ai-copilots)
- [`createAiCopilot`](/docs/api-reference/liveblocks-node#create-ai-copilot)
- [`getAiCopilot`](/docs/api-reference/liveblocks-node#get-ai-copilot)
- [`updateAiCopilot`](/docs/api-reference/liveblocks-node#update-ai-copilot)
- [`deleteAiCopilot`](/docs/api-reference/liveblocks-node#delete-ai-copilot)

You can also manage each copilotâ€™s knowledge sources.

- [`createWebKnowledgeSource`](/docs/api-reference/liveblocks-node#create-web-knowledge-source)
- [`createFileKnowledgeSource`](/docs/api-reference/liveblocks-node#create-file-knowledge-source)
- [`getKnowledgeSources`](/docs/api-reference/liveblocks-node#get-knowledge-sources)
- [`getKnowledgeSource`](/docs/api-reference/liveblocks-node#get-knowledge-source)
- [`getFileKnowledgeSourceMarkdown`](/docs/api-reference/liveblocks-node#get-file-knowledge-source-markdown)
- [`getWebKnowledgeSourceLinks`](/docs/api-reference/liveblocks-node#get-web-knowledge-source-links)
- [`deleteWebKnowledgeSource`](/docs/api-reference/liveblocks-node#delete-web-knowledge-source)
- [`deleteFileKnowledgeSource`](/docs/api-reference/liveblocks-node#delete-file-knowledge-source)

---
meta:
  title: "Default components"
  parentTitle: "AI Copilots"
  description: "Ready-to-use customizable components"
---

The default components included in AI Copilots are a great way to start building
AI into your application. With these components you can render advanced AI
chats, that understand your application state, modify it with actions, and
render custom in-chat components.

- Fully styled AI chat components, with an optional dark mode.
- Pass in knowledge, add actions, and render custom components.
- Customize through CSS variables and class names.
- Localize and modify strings with overrides.

## AiChat

The [`AiChat`][] component renders an AI chat, with a chat history and a
composer for adding new messages.

<Figure>
  <Image
    src="/assets/ai-copilots/ai-chat.jpg"
    alt="AiChat"
    width={768}
    height={446}
  />
</Figure>

### Usage

Get started by importing the component, and passing in a unique chat ID.

```tsx
import { AiChat } from "@liveblocks/react-ui";

function Component() {
  return <AiChat chatId="my-chat-id" />;
}
```

This will render an AI chat on the page, with a chat history, and a composer for
adding new messages. Each chat is stored permanently, and can be accessed again
later.

{/* TODO list everything you can do with it */}

## AiTool

When
[registering a tool](/docs/ready-made-features/ai-copilots/tools#Registering-a-tool),
the [`AiTool`][] component can be used to
[show tool progress and results](/docs/ready-made-features/ai-copilots/tools)
within AI chats. It shows the toolâ€™s name, its stage (e.g. a spinner when
executing, a checkmark when successful, etc.), and optionally an icon and custom
content inside it.

{/* TODO AiTool image */}

### Usage

```tsx
import { defineAiTool } from "@liveblocks/client";
import { RegisterAiTool, AiTool, AiChat } from "@liveblocks/react-ui";

function App() {
  return (
    <>
      <RegisterAiTool
        name="get-weather"
        tool={defineAiTool()({
          description: "Get current weather information",
          parameters: {
            type: "object",
            properties: {
              location: { type: "string", description: "City name" },
            },
            required: ["location"],
            additionalProperties: false,
          },
          execute: async (args) => {
            const { temperature, condition } = await __getWeather__(
              args.location
            );
            return { data: { temperature, condition } };
          },
          render: ({ result }) => {
            return (
              // +++
              <AiTool title="Weather" icon="ðŸŒ¤ï¸">
                {result.data ? (
                  <div>
                    {result.data.temperature}Â°F - {result.data.condition}
                  </div>
                ) : null}
              </AiTool>
              // +++
            );
          },
        })}
      />
      <AiChat chatId="my-chat" />
    </>
  );
}
```

## AiTool.Confirmation

Inside of tools, the [`AiTool.Confirmation`][] component is a sub-component of
[`AiTool`][] that renders confirm/deny buttons as part of a
[human-in-the-loop tool action](/docs/ready-made-features/ai-copilots/tools#Default-confirmation-component).
â€œConfirmâ€ and Cancelâ€ buttons are displayed to the user.

{/* TODO AiTool.Confirmation image */}

### Usage

```tsx
<RegisterAiTool
  name="delete-document"
  tool={defineAiTool()({
    description: "Delete a document by its ID",
    parameters: {
      type: "object",
      properties: {
        documentId: { type: "string" },
      },
      required: ["documentId"],
      additionalProperties: false,
    },
    render: ({ stage, args, result, types }) => {
      return (
        <AiTool title="Delete document" variant="minimal">
          // +++
          <AiTool.Confirmation
            types={types}
            confirm={async ({ documentId }) => {
              await __deleteDocument__(documentId);
              return {
                data: { documentId },
                description: "The user chose to delete the document",
              };
            }}
            cancel={() => {
              return {
                data: { documentId },
                description: "The user cancelled deleting the document",
              };
            }}
          />
          // +++
        </AiTool>
      );
    },
  })}
/>
```

## Customization

Itâ€™s possible to style and localize the default components:

- Import dark mode styles.
- Modify the style with CSS variables and class names.
- Use overrides to change default text used in the components.

Learn more under
[styling and customization](/docs/ready-made-features/ai-copilots/styling-and-customization):

[`aichat`]: /docs/api-reference/liveblocks-react-ui#AiChat
[`aitool`]: /docs/api-reference/liveblocks-react-ui#AiTool
[`aitool.confirmation`]:
  /docs/api-reference/liveblocks-react-ui#AiTool.Confirmation

---
meta:
  title: "Features"
  parentTitle: "AI Copilots"
  description: "Learn about AI Copilots"
---

Liveblocks AI Copilots provides customizable UI components that let your users
interact with AI in a way that feels native to your product. Unlike basic chat
widgets, Copilots are context-aware, collaborative, and capable of performing
real tasksâ€”such as editing content, navigating your app, or answering
product-specific questions. Theyâ€™re built for React developers, work with your
chosen LLM, and integrate directly into your existing UI using flexible APIs and
fully themeable components.

<Figure>
  <video width={1592} height={1080} autoPlay loop muted playsInline>
    <source
      src="/assets/ai-copilots/ai-copilots-features.mp4"
      type="video/mp4"
    />
  </video>
</Figure>

<Banner type="info" title="Try AI Copilots">

If youâ€™d like to try AI Copilots, [book a demo with our team](/contact/sales),
and weâ€™ll reach out to you and enable it on your account.

</Banner>
 
## Features

- **[Persistent chats](#persistent-chats)**: No database is required, each
  userâ€™s chats are stored permanently.
- **[Tools](#tools)**: Easily allow AI to interact with your application and
  modify its state.
- **[Knowledge](#knowledge)**: Feed text and files into the AI so it understands
  the current context.
- **[Ready-made UI](#ready-made-ui)**: Polished, easily customizable React
  components to add to your app.
- **[Custom chat components](#custom-chat-components)**: Register React
  components that the AI can choose to render in-chat.
- **[Text editor toolbar](#text-editor-toolbar)**: AI suggestions toolbar for
  your collaborative Tiptap text editor.
- **[Manage AI copilots](#manage-ai-copilots)**: Configure AI providers and
  system prompts from our dashboard.
- **[Supported AI providers](#supported-ai-providers)**: Anthropic, OpenAI,
  Google Gemini, and more.
- **[Coming soon](#coming-soon)**: One-off prompts, attachments, MCP servers.

## Persistent chats [#persistent-chats]

When building a chat interface, itâ€™s important to save the chat history so that
the user can continue the conversation from where they left off. All chats and
messages are stored automatically by Liveblocks, and each user has
[their own set of chats](/docs/ready-made-features/ai-copilots/hooks#List-a-user's-chats).
No database is required, and messages are streamed into the chat in realtime
using WebSockets.

<Figure>
  <Image
    src="/assets/ai-copilots/multiple-chats.png"
    alt="An example showing a list of different chats, each with custom metadata, and a create new chat button."
    width={768}
    height={512}
  />
</Figure>

Each page of your application can have multiple different chats, and itâ€™s easy
to switch between them, much like in ChatGPT. Each chat has a unique name, and
can be given custom metadata, for example a custom title, description, tags, or
anything you like.

### Automatic synchronization

When the page refreshes, each userâ€™s previous chats will load for them, and can
be continued. If a user has your app open in multiple browser tabs, each tab
will correctly display chats, and update in real-time.

## Tools [#tools]

[Tools](/docs/ready-made-features/ai-copilots/tools) are a way to allow AI to
make actions, modify your application state, interact with your front end, or
render custom content with your own components. You can use them to extend the
capabilities of AI Copilots beyond simple text-based interactions. For example,
you may have tools that create new documents in your app, automatically fill in
form data, invite members to a project, or anything else you like.

<Figure>
  <Image
    src="/assets/ai-copilots/document-changes.png"
    alt="An example of a document with a chat app in the corner. The chat has run a tool, and has edited the document."
    width={768}
    height={512}
  />
</Figure>

Tools are defined in your code, and are executed and/or rendered when the AI
requests to use them.

### Tools work with our other products

Through tools, you can integrate AI Copilots into our other products, such as
[Comments](/docs/ready-made-features/comments),
[Notifications](/docs/ready-made-features/notifications), and
[Sync Datastore](/docs/platform/sync-datastore). For example, you can allow AI
to add comments to your application, send notifications to other users, or add
shapes to a collaborative drawing app.

## Knowledge [#knowledge]

Itâ€™s simple to
[add knowledge and context to your AI](/docs/ready-made-features/ai-copilots/knowledge),
so that it understands the current document or page. You can submit webpages and
files, such as documentation, that the copilot will deeply internalize, allowing
it to reply intelligently. Additionally, certain models can also search the
web.

<Figure>
  <Image
    src="/assets/ai-copilots/context.png"
    alt="An example of a document containing numbers. The AI chat in the corner has been asked about the numbers, and understands the context of the document."
    width={768}
    height={512}
  />
</Figure>

## Ready-made UI [#ready-made-ui]

Liveblocks AI Copilots includes a set of styled UI components that can be used
to add an AI chat interface to your application. Messages are streamed in
realtime.

<Figure>
  <Image
    src="/assets/ai-copilots/floating-chat.png"
    alt="A screenshot of the ready-made chat component, with messages and AI suggestion buttons."
    width={768}
    height={512}
  />
</Figure>

We also provide [a number of hooks](/docs/ready-made-features/ai-copilots/hooks)
that allow you to extend your chat, or create fully custom chat interfaces.

## Custom chat components [#custom-chat-components]

Inside your chat, you can register custom React components that the AI can
choose to render as a response. For example, if your app contains charts, AI can
choose to render a custom chart component instead of a message. If you have
multiple components, AI can choose which one to render.

<Figure>
  <Image
    src="/assets/ai-copilots/custom-component.png"
    alt="An example of the AI rendering a custom chat component instead of a message. It's a graph component."
    width={768}
    height={512}
  />
</Figure>

These components can be fully interactive, for example this chart component
could have a button that lets you save it, and add it to a project.

## Text editor toolbar

Using our
[Text Editor integration for Tiptap](/docs/ready-made-features/text-editor/tiptap),
we provide an AI toolbar that can be added to your collaborative text editor.
This toolbar allows you to select text, and ask AI to make changes for you, for
example fixing typos, and creating new paragraphs.

<Figure>
  <Image
    src="/assets/ai-copilots/ai-toolbar.png"
    alt="An example of the AI toolbar in a text editor, with an 'Ask Copilot' button."
    width={768}
    height={512}
  />
</Figure>

Learn more about this React component under
[`AiToolbar`](/docs/api-reference/liveblocks-react-tiptap#AiToolbar)

## Manage AI copilots [#manage-ai-copilots]

The [Liveblocks dashboard](/dashboard) allows you to create, configure, and
manage your AI copilots, each of which can be used in different parts of your
application. You can select your [AI provider](#supported-ai-providers) (e.g.
OpenAI, Anthropic), specify a system prompt, and pass in your secret key to get
it working.

<Figure>
  <Image
    src="/assets/ai-copilots/dashboard-manage-copilot.png"
    alt="A screenshot of our dashboard, showing the settings for an AI copilot."
    width={768}
    height={512}
  />
</Figure>

You can also fine-tune how each copilot interacts with users by adjusting each
modelâ€™s settings, which are passed through directly to the AI provider. These
can influence its creativity, consistency, and the safety of generated content.
Each copilot can be configured independently, and tested live in the dashboard.

## Supported AI providers [#supported-ai-providers]

<Figure>
  <Image
    src="/assets/ai-copilots/providers.png"
    alt="We support different AI providers"
    width={768}
    height={512}
  />
</Figure>

In our dashboard, you can create, configure, and manage copilots powered by
different AI providers, each with different settings. The following providers
are supported out-of-the-box:

- Anthropic
- OpenAI
- Other OpenAI-compatible APIs
- Google Gemini

### Reasoning models

Reasoning models are supported by our built-in components, allowing models to
show their thought processes.

---

## Coming soon [#coming-soon]

## One-off prompts [#one-off-prompts]

One-off prompts are a way to add assorted AI features to your app, specifically
features that donâ€™t require a chat, such as an AI button on a page.
[Tools](#tools) and [context](#knowledge) are supported, allowing AI to interact
with your application, and understand its state. An example use case for a
one-off prompt is a button that uses AI to fill in a form.

<Figure>
  <Image
    src="/assets/ai-copilots/one-off-prompts.png"
    alt="An example use for a one-off prompt, an AI button that fills in a table for you."
    width={768}
    height={512}
  />
</Figure>

### Chat attachments

Upload files into the chat, which AI can modify, or use for extra context. These
files can be images, PDFs, text documents, or any file type your AI provider can
understand. Files are automatically stored by Liveblocks.

<Figure>
  <Image
    src="/assets/ai-copilots/attachment.png"
    alt="A zoomed-in screenshot of a chat with an uploaded attachment, ready to send."
    width={768}
    height={512}
  />
</Figure>

### MCP server integration

MCP is a protocol for running AI agents on a server, allowing you to make
various back ends calls to different services. In future, AI Copilots will
support this.

### Additional providers

We will be investigating additional providers, such as LangGraph, Crew AI,
Bedrock, and Vertex AI. If there is a specific provider youâ€™d like us to
support, please [book a demo with our team](/contact/sales) and let us know more
information in the text box.

---
meta:
  title: "Hooks"
  parentTitle: "AI Copilots"
  description: "React hooks for building custom AI interfaces"
---

The AI Copilots React hooks allow you to fetch, create, and modify AI chats,
enabling you to build custom AI interfaces, even beyond our
[default components](/docs/ready-made-features/ai-copilots/default-components).
Chats are stored permanently and the infrastructure is handled for you. All
hooks work optimistically, meaning they update immediately, before the server
has synched.

## List a userâ€™s chats

Each [authenticated user](/docs/authentication) has their own private set of
chats, and the [`useAiChats`](/docs/api-reference/liveblocks-react#useAiChats)
hook fetches all AI chats created by the current user. Itâ€™s easy to
[create a list of chats](/docs/api-reference/liveblocks-react#List-the-user's-chats-and-switch-between-them),
with links or buttons that take you to each.

```tsx
import { useAiChats } from "@liveblocks/react/suspense";

function ListChats() {
  // +++
  const { chats } = useAiChats();
  // +++

  return (
    <nav>
      // +++
      {chats.map((chat) => (
        <a key={chat.id} href={`/chats/${chat.id}`}>
          {chat.title || "Untitled"}
        </a>
      ))}
      // +++
    </nav>
  );
}
```

Chats are
[paginated](/docs/api-reference/liveblocks-react#useAiChats-pagination),
returning 50 at a time, and you can
[filter chats by metadata](/docs/api-reference/liveblocks-react#useAiChats-query).
There are also ways to
[handle errors](/docs/api-reference/liveblocks-react#useAiChats-error-handling).

## Create & delete chats

The [`useCreateAiChat`](/docs/api-reference/liveblocks-react#useCreateAiChat)
and [`useDeleteAiChat`](/docs/api-reference/liveblocks-react#useDeleteAiChat)
hooks allow you to create and delete AI chats. When used in combination with the
[`useAiChats`](/docs/api-reference/liveblocks-react#useAiChats) hook, you can
add â€œNew Chatâ€ and â€œDelete Chatâ€ buttons to your listing.

```tsx
import {
  useAiChats,
  useCreateAiChat,
  useDeleteAiChat,
} from "@liveblocks/react/suspense";

function ListChats() {
  const { chats } = useAiChats();
  // +++
  const createAiChat = useCreateAiChat();
  const deleteAiChat = useDeleteAiChat();
  // +++

  return (
    <nav>
      // +++
      <button onClick={() => createAiChat("my-ai-chat")}>ðŸ’¬ New Chat</button>
      // +++
      {chats.map((chat) => (
        <a key={chat.id} href={`/chats/${chat.id}`}>
          {chat.title || "Untitled"}
          // +++
          <button onClick={() => deleteAiChat(chat.id)}>âŒ Delete chat</button>
          // +++
        </a>
      ))}
    </nav>
  );
}
```

When an AI chat is created, a title is automatically generated from the first
messages. You can optionally set this title, and add custom metadata to the
chat.

```tsx
createAiChat({
  id: "my-ai-chat",
  // +++
  title: "My AI Chat",
  metadata: {
    color: "red",
    tags: ["product", "engineering"],
  },
  // +++
});
```

{/* prettier-ignore */}
{/* TODO add back later when we enable it

## List a chatâ€™s messages

The
[`useAiChatMessages`](/docs/api-reference/liveblocks-react#useAiChatMessages)
hook allows you to fetch all messages in a specific chat. Use this to display
the main content of a chat. User and assistant messages can be rendered
differently, and below weâ€™re returning different UI for each. Other types of
messages can be rendered separately too, for example tool calls, knowledge
calls, custom components.

```tsx
import { useAiChatMessages } from "@liveblocks/react/suspense";

function ChatMessages({ chatId }: { chatId: string }) {
  // +++
  const { messages } = useAiChatMessages(chatId);
  // +++

  return (
    <div>
      {messages.map((message) => {
        // +++
        if (message.role === "user") {
          // +++
          return (
            // +++
            <div key={message.id}>
              {message.content.map((part) => (
                <p>ðŸ‘¤ You: {part.text}</p>
              ))}
            </div>
            // +++
          );
        }

        return (
          // +++
          <div key={message.id}>
            {(message.contentSoFar ?? message.content).map((part) => (
              <p>ðŸ¤– Assistant: {part.text}</p>
            ))}
          </div>
          // +++
        );
      })}
    </div>
  );
}
```

Note that if youâ€™re using our default
[`AiChat`](/docs/api-reference/liveblocks-react-ui#AiChat) component, you donâ€™t
need to `useAiChatMessages`, as the messages are fetched for you. This hook is
only required for building custom chat interfaces.

\*/}

## Send messages to a chat

The [`useSendAiMessage`](/docs/api-reference/liveblocks-react#useSendAiMessage)
hook allows you to send messages directly to a chat, as if from a user. This
works really well in combination with buttons in your UI, for example you may
have a â€œExplain with AIâ€ button.

```tsx
import { useSendAiMessage } from "@liveblocks/react/suspense";

function ExplainWithAi() {
  // +++
  const sendAiMessage = useSendAiMessage("my-chat-id", {
    copilotId: "co_h7GBa3...",
  });
  // +++

  return (
    // +++
    <button onClick={() => sendAiMessage("Explain how this page works")}>
      Explain with AI
    </button>
    // +++
  );
}
```

Additionally, when using
[`AiChat`](/docs/api-reference/liveblocks-react-ui#AiChat) you can use the hook
to display suggestion buttons in the
[empty state](/docs/api-reference/liveblocks-react-ui#AiChat-placeholder).

```tsx
import { useSendAiMessage } from "@liveblocks/react/suspense";
import { AiChat } from "@liveblocks/react-ui";

function Chat() {
  // +++
  const sendAiMessage = useSendAiMessage("my-chat-id", {
    copilotId: "co_h7GBa3...",
  });
  // +++

  return (
    <AiChat
      chatId="my-chat-id"
      copilotId="co_h7GBa3..."
      components={{
        Empty: (
          <div>
            <div>How can I help you?</div>
            // +++
            <button onClick={() => sendAiMessage("What's new?")}>
              Update me
            </button>
            <button onClick={() => sendAiMessage("Create a new document")}>
              Draft a document
            </button>
            // +++
          </div>
        ),
      }}
    />
  );
}
```

## Get a chatâ€™s information

The [`useAiChat`](/docs/api-reference/liveblocks-react#useAiChat) hook allows
you to fetch a
[chatâ€™s title](/docs/api-reference/liveblocks-react#Displaying-a-default-title)
and
[custom metadata](/docs/api-reference/liveblocks-react#Create-a-chat-with-a-custom-title-and-metadata).

```tsx
import { useAiChat } from "@liveblocks/react/suspense";

function ChatTitle({ chatId }: { chatId: string }) {
  // +++
  const { chat } = useAiChat(chatId);
  // +++

  // +++
  return <h1>{chat.title || "Untitled chat"}</h1>;
  // +++
}
```

## Get a chatâ€™s status

The [`useAiChatStatus`](/docs/api-reference/liveblocks-react#useAiChatStatus)
hook allows you to fetch the status of an AI chat, indicating whether itâ€™s idle
or currently generating content. This is helpful for displaying a loading state
or freezing part of your app while content is generating.

```tsx
import { useAiChatStatus } from "@liveblocks/react/suspense";

function ChatStatus({ chatId }: { chatId: string }) {
  // +++
  const { status } = useAiChatStatus(chatId);
  // +++

  // +++
  return status === "idle" ? <div>ðŸŸ¢ Ready</div> : <div>ðŸŸ¡ Generatingâ€¦</div>;
  // +++
}
```

## Hook types [#hook-types]

There are two different ways to use many Liveblocks hooks; with
[React Suspense](https://react.dev/reference/react/Suspense), and without it. We
recommend using the Suspense versions, as they often result in simpler code.

### Suspense hooks [#suspense-hooks]

Using Suspense hooks means that any data retrieved, for example `chats` from
`useAiChats`, will never be `undefined`, and your component will never see an
error.

```tsx
import { useAiChats } from "@liveblocks/react/suspense";

// Suspense: `chats` is always defined
function MyAiChats() {
  const { chats } = useAiChats();

  // [{ id: "th_sf8s6sh...", title: "...", ... }, ...]
  console.log(chats);
}
```

To catch errors and display a loading screen, you can use
[`ErrorBoundary`](https://www.npmjs.com/package/react-error-boundary) and
[`ClientSideSuspense`](/docs/api-reference/liveblocks-react#suspense-avoid-ssr).

```tsx highlight="7-11"
import { ClientSideSuspense } from "@liveblocks/react/suspense";
import { ErrorBoundary } from "react-error-boundary";

// Handle errors and loading state in the component above
function Component() {
  return (
    <ErrorBoundary fallback={<div>Error</div>}>
      <ClientSideSuspense fallback={<div>Loading...</div>}>
        <MyAiChats />
      </ClientSideSuspense>
    </ErrorBoundary>
  );
}
```

To use Suspense, make sure youâ€™re exporting your hooks from
`@liveblocks/react/suspense`.

```tsx
// Suspense version of hooks
import { useAiChats, useAiChatMessages } from "@liveblocks/react/suspense";
//                                                               ^^^^^^^^
```

### Regular hooks [#regular-hooks]

The regular versions of Liveblocks hooks require you to check for `error` and
`isLoading` properties. You can then handle these states in the same component.

```tsx
import { useAiChats } from "@liveblocks/react";

// Handle errors and loading state in the same component
function MyAiChats() {
  const { chats, error, isLoading } = useAiChats();

  if (error) {
    return <div>Error</div>;
  }

  if (isLoading) {
    return <div>Loading...</div>;
  }

  // Non-Suspense: `chats` is only defined AFTER the `if` checks
  // [{ id: "th_sf8s6sh...", title: "...", ... }, ...]
  console.log(chats);
}
```

To use the regular hooks, make sure youâ€™re exporting from `@liveblocks/react`.

```tsx
// Regular version of hooks
import { useAiChats, useAiChatMessages } from "@liveblocks/react";
//                                             ^^^^^^^^^^^^^^^^^
```

---
meta:
  title: "Knowledge"
  parentTitle: "AI Copilots"
  description: "Add context and files to your AI copilots"
---

Knowledge allows you to provide information to your AI so it can understand your
applicationâ€™s state, content, and domain-specific information, making responses
more relevant and accurate. There are two different knowledge typesâ€”_front-end
knowledge_, ideal for adding small pieces of contextual information, and
_back-end knowledge_, designed for larger datasets such as entire websites and
lengthy PDFs. Additionally, you can enable web search, allowing your AI to query
the internet for information.

## Front-end knowledge

Front-end knowledge is data thatâ€™s passed to your AI from the browser through
[React](/docs/api-reference/liveblocks-react#RegisterAiKnowledge). This is most
useful for passing contextual, user-specific, information, for example:

- **User info**: The userâ€™s local time, date, location, and language.
- **Account info**: The userâ€™s projects and which payment plan theyâ€™re on.
- **Page info**: Which URL the user is viewing and the content of the current
  document.

### How it works [#front-end-knowledge-how-it-works]

Front-end knowledge is string or JSON-serializable data that is passed to the AI
with every message the user sends. The AI reads all front-end knowledge before
responding. Itâ€™s easy to reach AI provider token limits with this approach, so
limit your front-end knowledge to relatively small amounts of data, not multiple
pages of text.

Because front-end knowledge is simply passed along with every message, and is
never specifically queried, no messages are displayed in the UI when itâ€™s used.

### Adding front-end knowledge

You can add front-end knowledge to your chat by using the
[`RegisterAiKnowledge`](/docs/api-reference/liveblocks-react#RegisterAiKnowledge)
component anywhere in your application.

```tsx
import { RegisterAiKnowledge } from "@liveblocks/react";
import { AiChat } from "@liveblocks/react-ui";

function Chat() {
  return (
    <>
      <AiChat chatId="my-chat-id" />
      // +++
      <RegisterAiKnowledge
        description="The current user's payment plan"
        value={{ name: "Advanced Plan", expires: "2026-01-01" }}
      />
      // +++
    </>
  );
}
```

After adding this, the AI will understand that the user is on the Advanced Plan
and be able to answer questions on it, for example:

> User: _What's my current plan?_
>
> Assistant: _You're on the Advanced Plan, it expires on January 1st, 2026._

### Combine front-end knowledge with tools

You can combine front-end knowledge with
[tools](/docs/ready-made-features/ai-copilots/tools) to create an AI assistant
that can take actions. For example, say you have a document on the current page.
You can use knowledge to share the document content with the AI, then create a
tool that allows AI to edit the document.

```tsx
import { RegisterAiKnowledge } from "@liveblocks/react";
import { AiChat } from "@liveblocks/react-ui";
import { RegisterAiTool } from "@liveblocks/react";
import { defineAiTool } from "@liveblocks/client";
import { useState } from "react";

function Document() {
  // +++
  const [document, setDocument] = useState("Hello world");
  // +++

  return (
    <>
      <AiChat chatId="my-chat-id" />
      <RegisterAiKnowledge
        description="The current document"
        // +++
        value={document}
        // +++
      />
      <RegisterAiTool
        name="edit-document"
        tool={defineAiTool()({
          description: "Edit the document's text",
          parameters: {
            type: "object",
            properties: {
              text: { type: "string" },
            },
          },
          execute: ({ args }) => {
            // +++
            setDocument(args.text);
            // +++
            return { data: {}, description: "Document updated" };
          },
        })}
      />
    </>
  );
}
```

Learn about more ways to use it in our documentation under
[`RegisterAiKnowledge`](/docs/api-reference/liveblocks-react#RegisterAiKnowledge).

## Back-end knowledge

Back-end knowledge is data thatâ€™s passed to your AI from the server, through
your
[copilot](/docs/ready-made-features/ai-copilots/copilots#Adding-back-end-knowledge).
You can submit PDF/image files, web pages, or entire websites which will be
crawled and indexed. This is most useful for passing large amounts of
information, for example:

- **Knowledge bases**: Documentation, FAQs, and support tickets.
- **Domain-specific data**: Detailed information that your AI must understand.
- **Documents**: Submit PDF or image scans of reports, contracts, and invoices.

### How it works [#back-end-knowledge-how-it-works]

Back-end knowledge uses Retrieval-Augmented Generation (RAG) search, and is
triggered by a hidden tool call, meaning the AI will search through its back-end
knowledge when it feels its relevant. You can define
[when AI should use back-end knowledge](/docs/ready-made-features/ai-copilots/copilots#When-should-AI-use-knowledge)
in your copilot settings, and AI will understand what should trigger a back-end
knowledge query.

The AI will rewrite your query, and may even run multiple queries in a row, each
of which will be displayed in the
[`AiChat`](/docs/api-reference/liveblocks-react-ui#AiChat) UI as a search.

### Adding back-end knowledge through the dashboard

After
[creating a copilot](/docs/ready-made-features/ai-copilots/copilots#Creating-a-copilot)
in the [dashboard](/dashboard), you can navigate to the â€œKnowledgeâ€ tab to add
back-end knowledge. Select which type of knowledge youâ€™d like to submit, and
enter your URLs or upload your files.

<Figure>
  <Image
    src="/assets/ai-copilots/copilot-knowledge.png"
    alt="Screenshot of the Liveblocks dashboard, adding knowledge to a copilot"
    width={720}
    height={409}
    quality={100}
  />
</Figure>

Make sure to use your copilot ID in
[`AiChat`](/docs/api-reference/liveblocks-react-ui#AiChat) and
[`useSendAiMessage`](/docs/api-reference/liveblocks-react#useSendAiMessage) to
use the knowledge in your application.

### Adding back-end knowledge programmatically

You arenâ€™t limited to modifying knowledge through the dashboardâ€”you can also add
copilot knowledge programmatically, allowing users or teams in your app to have
their own individual knowledge bases.

```ts
import { Liveblocks } from "@liveblocks/node";

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

// +++
const { id } = await liveblocks.createWebKnowledgeSource({
  copilotId: "co_abc123...",
  url: "https://example.com",
  type: "crawl",
});
// +++
```

This is made possible using the
[Liveblocks Node.js client](/docs/api-reference/liveblocks-node#AI-Copilots) and
[REST API](/docs/api-reference/rest-api-endpoints#AI), where a number of APIs
are available for managing copilots and knowledge sources.

- [`createWebKnowledgeSource`](/docs/api-reference/liveblocks-node#create-web-knowledge-source)
- [`createFileKnowledgeSource`](/docs/api-reference/liveblocks-node#create-file-knowledge-source)
- [`getKnowledgeSources`](/docs/api-reference/liveblocks-node#get-knowledge-sources)
- [`getKnowledgeSource`](/docs/api-reference/liveblocks-node#get-knowledge-source)
- [`getFileKnowledgeSourceMarkdown`](/docs/api-reference/liveblocks-node#get-file-knowledge-source-markdown)
- [`getWebKnowledgeSourceLinks`](/docs/api-reference/liveblocks-node#get-web-knowledge-source-links)
- [`deleteWebKnowledgeSource`](/docs/api-reference/liveblocks-node#delete-web-knowledge-source)
- [`deleteFileKnowledgeSource`](/docs/api-reference/liveblocks-node#delete-file-knowledge-source)

## Web search

Web search is a feature that allows your AI to search the internet for
information. It is disabled by default, and can be enabled by toggling the
`webSearch` option in
[your copilot settings](/docs/ready-made-features/ai-copilots/copilots#Web-search).

```text title="Web search"
on
```

You can also
[limit the domains that the AI can search](/docs/ready-made-features/ai-copilots/copilots#Limit-web-search-to-specific-domains)
by setting an option on your copilot.

```text title="Limit web search to specific domains"
encyclopedia.com
en.wikipedia.org
```

Itâ€™s also possible to enable web search through the back-end with
`allowedDomains`, for example using
[`liveblocks.createAiCopilot`](/docs/api-reference/liveblocks-node#create-ai-copilot).

```ts
const copilot = await liveblocks.createAiCopilot({
  name: "My AI Assistant",
  systemPrompt: "You are a helpful AI assistant for our team.",
  provider: "openai",
  providerModel: "gpt-4",
  providerApiKey: "sk-...",
  providerOptions: {
    openai: {
      // Optional, restrict web search to specific domains
      // +++
      webSearch: {
        allowedDomains: ["encyclopedia.com", "en.wikipedia.org"],
      },
      // +++
    },
  },
});
```

Not all models support web search, but most OpenAI and Anthropic models do.

---
meta:
  title: "Styling and customization"
  parentTitle: "AI Copilots"
  description: "Customize the appearance and behavior of AI Copilots"
---

Styling
[default components](/docs/ready-made-features/ai-copilots/default-components)
is enabled through a range of means, such as CSS variables, class names, and
more. Itâ€™s also possible to use [overrides](#Overrides-and-localization) to
modify any strings used in the default components, which is especially helpful
for localization.

## Default components

To add the default componentsâ€™ theme, import the
[default styles](/docs/api-reference/liveblocks-react-ui#Default-styles) CSS
file.

```ts
import "@liveblocks/react-ui/styles.css";
```

You can also import one of two CSS files to enable
[dark mode](/docs/api-reference/liveblocks-react-ui#Dark-mode), depending on how
youâ€™d like to enable it.

```ts
// Dark mode using the system theme with `prefers-color-scheme`
import "@liveblocks/react-ui/styles/dark/media-query.css";
```

```ts
// Dark mode using `className="dark"`, `data-theme="dark"`, or `data-dark="true"`
import "@liveblocks/react-ui/styles/dark/attributes.css";
```

### CSS variables

A number of
[CSS variables](/docs/api-reference/liveblocks-react-ui#CSS-variables) can be
used to customize colors, spacing, and more. This is our recommended path for
styling the default components, as you can quickly and easily modify all
components with just a few variables.

```css
/* Styles all default components */
.lb-root {
  --lb-accent: purple;
  --lb-spacing: 1em;
  --lb-radius: 0;
}
```

### Class names

Should you need deeper customization,
[class names](/docs/api-reference/liveblocks-react-ui#Class-names) can be
styled, some of which provide contextual data attributes.

```css
.lb-ai-chat {
  /* Customize AI chat */
}

.lb-ai-composer {
  /* Customize message composer */
}
```

### Overrides and localization

Itâ€™s possible to
[override strings](/docs/api-reference/liveblocks-react-ui#Overrides) used in
the default components, which has a couple of different uses, the first being
localization. In this example, weâ€™re globally setting the AI composerâ€™s
placeholder from â€œAsk anythingâ€¦â€ to â€œPosez une questionâ€ for French users.

```tsx
import { LiveblocksUiConfig } from "@liveblocks/react-ui";

export function App() {
  return (
    <LiveblocksUiConfig
      overrides={{
        // +++
        locale: "fr",
        AI_COMPOSER_PLACEHOLDER: "Posez une question",
        // +++
      }}
    >
      {/* ... */}
    </LiveblocksUiConfig>
  );
}
```

You can also override strings on a component basis, for example if youâ€™d like to
change the â€œSendâ€ button tooltip to â€œPost messageâ€ in the chatâ€™s message
composer.

```tsx
import { Composer } from "@liveblocks/react-ui";

function Component() {
  return (
    <AiChat
      chatId="my-chat-id"
      copilotId="co_a7Gd3x..."
      overrides={{
        // +++
        AI_COMPOSER_PLACEHOLDER: "Post message",
        // +++
      }}
    />
  );
}
```

{/* prettier-ignore */}
{/* TODO add back later when we enable it

## Custom interfaces

You can bypass the default components and build completely custom UI for your AI
copilots, for example using
[`useAiChatMessages`](/docs/api-reference/liveblocks-react#useAiChatMessages)
and [`useSendAiMessage`](/docs/api-reference/liveblocks-react#useSendAiMessage)
to build your own chat history and composer.

```tsx
import {
  useAiChatMessages,
  useSendAiMessage,
} from "@liveblocks/react/suspense";

function ChatMessages({ chatId }: { chatId: string }) {
  // +++
  const { messages } = useAiChatMessages(chatId);
  const sendAiMessage = useSendAiMessage(chatId, { copilotId: "co_a7Gd3x..." });
  // +++

  return (
    <div>
      // +++
      {messages.map((message) => {
        // +++
        if (message.role === "user") {
          return (
            <div key={message.id}>
              {message.content.map((part) => (
                <p>ðŸ‘¤ You: {part.text}</p>
              ))}
            </div>
          );
        }

        return (
          <div key={message.id}>
            {(message.contentSoFar ?? message.content).map((part) => (
              <p>ðŸ¤– Assistant: {part.text}</p>
            ))}
          </div>
        );
      })}
      <form
        onSubmit={(e) => {
          e.preventDefault();
          // +++
          sendAiMessage({ text: e.target.message.value });
          // +++
          e.target.reset();
        }}
      >
        <input type="text" name="message" />
        <button type="submit">Send</button>
      </form>
    </div>
  );
}
```

Learn more about what you can build under
[hooks](/docs/ready-made-features/ai-copilots/hooks).

\*/}

---
meta:
  title: "Tools"
  parentTitle: "AI Copilots"
  description: "Allow AI to interact with your application"
---

Tools allow AI to make actions, modify your application state, interact with
your front-end, and render custom components within your AI chat. Use tools to
extend the capabilities of AI Copilots beyond simple text, allowing autonomous
and human-in-the-loop interactions.

## Tool use cases

Tools can be used to create various different interactions inside of your AI
chat, such as:

- **Actions**: Autonomously perform actions like editing documents, redirecting
  users, sending emails.
- **Custom components**: Render custom React components like forms, graphs,
  videos, callouts.
- **Query actions**: AI can query your app, search documents, find pages, check
  invoices.
- **Human-in-the-loop actions**: Show confirm/deny buttons before taking
  destructive actions.
- **AI presence**: Tool results can be streamed in, allowing AI to show live
  updates in your app.

### How tools work

You can define a list of tools in your application, and your AI can choose to
use them whenever it decides theyâ€™re needed. Within each tool you can set
certain parameters which AI will fill in for you. For example, a weather tool
may have a `location` parameter, and AI may enter `"Paris"` as the value. Hereâ€™s
an example of a tool call interaction:

<Steps>
  <StepCompact>
    <StepTitle>In your weather tool, `location` is defined as a `string`</StepTitle>
    <StepContent>
    ```json
    { "location": { type: "string" } }
    ```
    </StepContent>
  </StepCompact>

{" "}

<StepCompact>
  <StepTitle>User asks about the weather in Paris</StepTitle>
  <StepContent>

    ```js
    User: "What's the weather in Paris?"
    ```

  </StepContent>
</StepCompact>

  <StepCompact>
    <StepTitle>AI calls the weather tool with `Paris` as the `location`</StepTitle>
    <StepContent>
    ```js
    { "location": "Paris" }
    ```
    </StepContent>
  </StepCompact>

{" "}

<StepCompact>
  <StepTitle>You write code to fetch the weather for the `location`</StepTitle>
  <StepContent>

    ```js
    execute: async ({ location }) => {
      // { "temperature": 20, "condition": "sunny" };
      const weather = await __fetchWeather__(location);
      return { data: { weather }};
    }
    ```

  </StepContent>
</StepCompact>

  <StepCompact lastStep>
    <StepTitle>AI answers the user</StepTitle>
    <StepContent>
    ```js
    AI: "It's sunny in Paris, with a temperature of 20Â°C."
    ```
    </StepContent>
  </StepCompact>
</Steps>

When writing your
[system prompt](/docs/ready-made-features/ai-copilots/copilots#System-prompt)
you can suggest when certain tools should be used, helping AI respond as you
like. This is just an example of a simple tool, but below weâ€™ll detail how to
create more complex tools that have confirm/deny dialogs, render custom
components, query data, and more.

## Defining tools

You can define a tool with
[`defineAiTool`](/docs/api-reference/liveblocks-client#defineAiTool) and
[`RegisterAiTool`](/docs/api-reference/liveblocks-react#RegisterAiTool). First,
you first need to give your tool a unique name, and a description, which helps
AI understand when to call it. You can place the component anywhere in your app.

```tsx
import { RegisterAiTool } from "@liveblocks/react";
import { defineAiTool } from "@liveblocks/client";
import { AiChat } from "@liveblocks/react-ui";

function Chat() {
  return (
    <>
      <AiChat chatId="my-chat-id" />
      // +++
      <RegisterAiTool
        name="weather-tool"
        tool={defineAiTool()({
          description: "Get the weather for a location",
          // ...
        })}
      />
      // +++
    </>
  );
}
```

For AI to use your tools intelligently, parameters must be defined, which AI
will fill in for you. Tools use
[JSON schema](/docs/ready-made-features/ai-copilots/tools#Advanced-JSON-schema)
to define these. For example, you can define `location` parameter as a `string`.

```tsx
<RegisterAiTool
  name="weather-tool"
  tool={defineAiTool()({
    description: "Get the weather for a location",
    // +++
    parameters: {
      type: "object",
      properties: {
        location: { type: "string" },
      },
      required: ["location"],
      additionalProperties: false,
    },
    // +++
    // ...
  })}
/>
```

To add functionality to your tool, a combination of `execute` and `render`
functions are used.

```tsx
<RegisterAiTool
  name="weather-tool"
  tool={defineAiTool()({
    description: "Get the weather for a location",
    parameters: {
      type: "object",
      properties: {
        location: { type: "string" },
      },
      required: ["location"],
      additionalProperties: false,
    },
    // +++
    execute: async ({ location }) => {
      // ...
    },
    render: ({ stage, partialArgs, args, result, respond }) => {
      // ...
    },
    // +++
  })}
/>
```

In each of the following sections, different ways to implement `execute` and
`render` are detailed.

## Actions

If youâ€™d like your AI to perform an action when the tool is called, you can use
`execute` to define what should happen. The arguments passed to `execute` are
the parameters defined in your tool, filled in by AI. After the tool has run,
return any `data` youâ€™d like to pass back to AI.

```tsx
<RegisterAiTool
  name="weather-tool"
  tool={defineAiTool()({
    description: "Get the weather for a location",
    parameters: {
      type: "object",
      properties: {
        location: { type: "string" },
      },
      required: ["location"],
      additionalProperties: false,
    },
    // +++
    execute: async ({ location }) => {
      const weather = await __fetchWeather__(location);
      return { data: { weather } };
    },
    // +++
  })}
/>
```

After running `execute`, AI will read the `data` object, and choose how to
respond. Additionally, you can define a `description` to pass back to AI. This
is a way to inform AI what has just taken place, so it can understand the
context of the result, and what it should do next. This text will never be shown
to the user.

```ts
execute: async ({ location }) => {
  const weather = await __fetchWeather__(location);
  return {
    data: { weather },
    // +++
    description: "You've just fetched the weather, share the temperature in Â°C."
    // +++
  };
},
```

<Banner title="Actions example">

The [AI Calendar](/examples/ai-calendar/nextjs-ai-calendar) example contains an
action that allows AI to create new calendar events.

</Banner>

### Display a loading message

You can easily display a loading message while an action takes place using
`render` and [`AiTool`](/docs/api-reference/liveblocks-react-ui#AiTool). You can
also choose to display a message after the action has finished, as in the
example below.

```tsx
import { AiChat, AiTool } from "@liveblocks/react-ui";
import { RegisterAiTool } from "@liveblocks/react";

function Chat() {
  <>
    <AiChat chatId="my-chat-id" />
    <RegisterAiTool
      name="weather-tool"
      tool={defineAiTool()({
        description: "Get the weather for a location",
        parameters: {
          type: "object",
          properties: {
            location: { type: "string" },
          },
          required: ["location"],
          additionalProperties: false,
        },
        execute: async ({ location }) => {
          const weather = await __fetchWeather__(location);
          return {
            data: { weather },
            description: "You've just fetched the weather.",
          };
        },
        // +++
        render: ({ stage }) => {
          // `execute` is still running
          if (stage !== "executed") {
            return <AiTool title="Fetching weatherâ€¦" variant="minimal" />;
          }

          // `execute` has finished
          return <AiTool title="Weather fetched" variant="minimal" />;
        },
        // +++
      })}
    />
  </>;
}
```

[`AiTool`](/docs/api-reference/liveblocks-react-ui#AiTool) isnâ€™t required here,
as you can return any JSX, but itâ€™s an easy way to match the styling of the
default chat. Returning `null` will display nothing.

### Combine actions with front-end knowledge

You can combine actions with
[front-end knowledge](/docs/ready-made-features/ai-copilots/knowledge) to create
an AI assistant that can take actions. For example, say you have a document on
the current page. You can use knowledge to pass the documentâ€™s text to the AI,
then create a tool that allows AI to edit the document.

```tsx
import { RegisterAiKnowledge } from "@liveblocks/react";
import { AiChat } from "@liveblocks/react-ui";
import { RegisterAiTool } from "@liveblocks/react";
import { defineAiTool } from "@liveblocks/client";
import { useState } from "react";

function Document() {
  // +++
  const [document, setDocument] = useState("Hello world");
  // +++

  return (
    <>
      <AiChat chatId="my-chat-id" />
      <RegisterAiKnowledge
        description="The document's text"
        // +++
        value={document}
        // +++
      />
      <RegisterAiTool
        name="edit-document"
        tool={defineAiTool()({
          description: "Edit the document's text",
          parameters: {
            type: "object",
            properties: {
              text: { type: "string" },
            },
          },
          execute: ({ args }) => {
            // +++
            setDocument(args.text);
            // +++
            return { data: {}, description: "Document updated" };
          },
          render: ({ stage }) => {
            if (stage !== "executed") {
              return <AiTool title="Updating documentâ€¦" variant="minimal" />;
            }

            return <AiTool title="Document updated" variant="minimal" />;
          },
        })}
      />
    </>
  );
}
```

## Custom components

You can use tools to display custom components inside the chat with the `render`
function. These donâ€™t have to be simple components, but can be complex, like
forms, graphs, videos, callouts. When displaying a simple component, include an
`execute` function, even if itâ€™s empty, otherwise the chat will assume itâ€™s a
[human-in-the-loop action](#Human-in-the-loop-actions).

```tsx
<RegisterAiTool
  name="graph-tool"
  tool={defineAiTool()({
    description: "Display a graph in the chat",
    parameters: {},
    execute: () => {},
    // +++
    render: () => {
      return <MyGraph x={50} y={100} />;
    },
    // +++
  })}
/>
```

You can go further than this, and allow AI to
[create parameters](#Advanced-JSON-schema) which you can use in your custom
component, for example `x` and `y` values on a graph.

```tsx
<RegisterAiTool
  name="graph-tool"
  tool={defineAiTool()({
    description: "Display a graph in the chat",
    parameters: {
      type: "object",
      properties: {
        // +++
        x: { type: "number" },
        y: { type: "number" },
        // +++
      },
      required: ["x", "y"],
      additionalProperties: false,
    },
    execute: () => {},
    render: ({ args, stage }) => {
      if (stage !== "executed") {
        return <div>Loading...</div>;
      }

      // +++
      return <MyGraph x={args.x} y={args.y} />;
      // +++
    },
  })}
/>
```

AI will most likely write a response after using your tool, but you can prompt
the AI to not respond by adding a `description` to `execute`.

```tsx
<RegisterAiTool
  name="graph-tool"
  tool={defineAiTool()({
    description: "Display a graph in the chat",
    parameters: {
      type: "object",
      properties: {
        x: { type: "number" },
        y: { type: "number" },
      },
      required: ["x", "y"],
      additionalProperties: false,
    },
    execute: () => {
      return {
        data: {},
        // +++
        description: "Youâ€™re displaying a graph. Do not respond further.",
        // +++
      };
    },
    render: ({ args, stage }) => {
      if (stage !== "executed") {
        return <div>Loading...</div>;
      }

      // +++
      return <MyGraph x={args.x} y={args.y} />;
      // +++
    },
  })}
/>
```

<Banner title="Custom components example">

The [AI Support Chat](/examples/ai-support/nextjs-ai-support) example uses
custom components in its support ticket tool to display a contact form.

</Banner>

### Fetching data for custom components

You can take custom components a step further by combining them with
[actions](#Actions), and then showing the results inside the custom component.
The `result` property contains the data returned from the action.

```tsx
<RegisterAiTool
  name="weather-tool"
  tool={defineAiTool()({
    description: "Get the weather for a location",
    parameters: {
      type: "object",
      properties: {
        location: { type: "string" },
      },
      required: ["location"],
      additionalProperties: false,
    },
    execute: async ({ location }) => {
      // { "temperature": 20, "condition": "sunny" };
      const weather = await __fetchWeather__(location);
      return { data: { weather } };
    },
    // +++
    render: ({ stage, args, result }) => {
      if (stage !== "executed") {
        return <div>Fetching weatherâ€¦</div>;
      }

      return (
        <MyWeatherComponent
          location={args.location}
          condition={result.data.weather.condition}
          temperature={result.data.weather.temperature}
        />
      );
    },
    // +++
  })}
/>
```

`args` contains the arguments passed to the tool from AI, and `result` contains
the data returned from the tool.

## Query actions

A helpful way to use tools is to allow AI to query data from your application,
such as documents, pages, or other data sources. If your application already
contains a search function, you can easily plug it into your tool to create a
powerful AI assistant. For example, this tool can search through documents by
title, folder, and category.

```tsx
<RegisterAiTool
  name="find-documents"
  tool={defineAiTool()({
    // +++
    description: "Find documents by title, folder, and category",
    // +++
    parameters: {
      type: "object",
      properties: {
        // +++
        title: { type: "string" },
        folder: { type: "string" },
        category: { type: "string" },
        // +++
      },
      required: ["title", "folder", "category"],
    },
    additionalProperties: false,
  },
  // +++
  execute: async ({ title, folder, category }) => {
    const documents = await __queryDocuments__({ title, folder, category });
    return {
      data: { documents },
      description: documents.length > 0 ? `${documents.length} results` : "No results"
    };
  },
  // +++
  render: ({ stage, args, result }) => {
    if (stage !== "executed") {
      return <AiTool title="Fetching documentsâ€¦" variant="minimal" />;
    }

    return null;
  },
  })}
/>
```

Since the query is happening on the front-end, you donâ€™t need to implement
separate authentication for your AI toolâ€”it can leverage the same APIs that your
users are already authorized to access.

<Banner title="Query actions example">

The
[AI Reports Dashboard](/examples/ai-dashboard-reports/nextjs-ai-dashboard-reports)
example has a query transactions tool allowing for complex searching.

</Banner>

## Human-in-the-loop actions

Human-in-the-loop actions allow the user to confirm or deny an action before
itâ€™s executed. This is particularly useful when it comes to destructive and
stateful actions, such as deleting a document, or sending an email. Confirmable
actions like these will freeze the chat until the user responds, either by
confirming or cancelling the action.

<Steps>
<StepCompact>
  <StepTitle>User asks to delete a document</StepTitle>
  <StepContent>

    ```js
    User: "Can you delete my-document.txt?"
    ```

  </StepContent>
</StepCompact>
  <StepCompact>
    <StepTitle>AI calls the delete document tool, â€œConfirmâ€ and â€œdenyâ€ buttons are displayed</StepTitle>
    <StepContent>
    _The chat waits for the user to respond._
    </StepContent>
  </StepCompact>
  <StepCompact>
    <StepTitle>The user clicks â€œConfirmâ€</StepTitle>
    <StepContent>
    _The document is deleted._
    </StepContent>
  </StepCompact>
<StepCompact lastStep>
  <StepTitle>The chat unfreezes and is ready to continue</StepTitle>
  <StepContent>

    ```js
    AI: "I've deleted it! How else can I help you?"
    ```

  </StepContent>
</StepCompact>
</Steps>

To create confirmable actions, you must skip using the `execute` function, and
instead move your logic to `render`, as we detail below. This will always freeze
the chat until the user responds.

<Banner title="Human-in-the-loop actions example">

The
[AI Reports Dashboard](/examples/ai-dashboard-reports/nextjs-ai-dashboard-reports)
example demonstrates human-in-the-loop actions with its invite member tool.

</Banner>

### Default confirmation component

The easiest way to create confirmable actions, is to return the ready-made
[`AiTool.Confirmation`](/docs/api-reference/liveblocks-react-ui#AiTool.Confirmation)
component in `render`. The `confirm` and `cancel` callbacks work very similarly
to `execute`, and are triggered when the user clicks â€œConfirmâ€ or â€œCancelâ€.

```tsx
<RegisterAiTool
  name="delete-document"
  tool={defineAiTool()({
    description: "Delete a document by its ID",
    parameters: {
      type: "object",
      properties: {
        documentId: { type: "string" },
      },
      required: ["documentId"],
      additionalProperties: false,
    },
    render: ({ stage, args, result, types }) => {
      return (
        <AiTool title="Delete document" variant="minimal">
          // +++
          <AiTool.Confirmation
            types={types}
            confirm={async ({ documentId }) => {
              await __deleteDocument__(documentId);
              return {
                data: { documentId },
                description: "The user chose to delete the document",
              };
            }}
            cancel={() => {
              return {
                data: { documentId },
                description: "The user cancelled deleting the document",
              };
            }}
          />
          // +++
        </AiTool>
      );
    },
  })}
/>
```

In the `cancel` callback itâ€™s important to let the AI know that the user
cancelled the action, otherwise it may assume the action failed and try to run
it again.

```js
description: "The user cancelled deleting the document",
```

### Building a custom confirmation component

By utilizing the `respond` argument in `render`, and the different stages of a
toolâ€™s lifecycle, you can build a fully custom confirmation component. These are
the different stages:

1. `receiving` - Displayed when AI is streaming in the parameters.
2. `executing` - Displayed when the chat is frozen, and is waiting for a
   response.
3. `executed` - Displayed after a response has been recorded.

Hereâ€™s how to leverage the different stages to create a custom â€œsend emailâ€
toolâ€”note how `respond` is used similarly to `execute`.

```tsx
<RegisterAiTool
  name="send-email"
  tool={defineAiTool()({
    description: "Send an email",
    parameters: {
      type: "object",
      properties: {
        emailAddress: { type: "string" },
      },
      required: ["emailAddress"],
      additionalProperties: false,
    },
    render: ({ stage, args, respond, result }) => {
      // `emailAddress` param is still streaming in, wait
      // +++
      if (stage === "receiving") {
        return <div>Loading...</div>;
      }
      // +++

      // The tool is waiting for `respond` to be called
      // +++
      if (stage === "executing") {
        return (
          <form
            onSubmit={async (e) => {
              e.preventDefault();
              const message = e.target.message.value;
              await __sendEmail__(args.emailAddress, message);

              // Similar to `execute`/`confirm`, let AI know it succeeded
              respond({
                data: { emailAddress: args.emailAddress, message },
                description: "You sent an email for the user",
              });
            }}
          >
            <textarea name="message" />
            <button type="submit">Send</button>
            <button
              type="button"
              onClick={() =>
                // Similar to `execute`/`cancel`, let AI know the user cancelled
                respond({
                  data: { emailAddress: args.emailAddress, message },
                  description: "The user cancelled sending an email",
                })
              }
            >
              Cancel
            </button>
          </form>
        );
      }
      // +++

      // `respond` has already been called, show the result
      // +++
      return (
        <div>
          You sent an email to {args.emailAddress}: "{result.data.message}".
        </div>
      );
      // +++
    },
  })}
/>
```

A toolâ€™s stages never reset, which means that once an email has been sent, the
tool will remain in the `executed` stage showing â€œYou sent an email toâ€¦â€, even
after refreshing the page. This enables stateful interaction.

## AI presence & streaming

You can stream in tool results as they arrive, allowing you to show live updates
and AI presence in your application. An example would be a tool that generates
documentsâ€”you can display the partially generated document as each chunk
arrives, for example:

<Steps>

<StepCompact>
```json
{ "content": "Hereâ€™s" }
```
</StepCompact>

<StepCompact>
```json
{ "content": "Hereâ€™s my suggestions" }
```
</StepCompact>

<StepCompact>
```json
{ "content": "Hereâ€™s my suggestions for a" }
```
</StepCompact>

<StepCompact lastStep>
```json
{ "content": "Hereâ€™s my suggestions for a marketing email!" }
```
</StepCompact>

</Steps>

To show this inside the tool, you can use `render`. While youâ€™d normally access
AI-generated arguments via `args`, but to access streaming results, you can use
`partialArgs` to get the whole stream up to this point. This all occurs during
the `receiving` stage, and as each chunk is received, `render` will re-render
and update the UI.

```tsx
<RegisterAiTool
  name="create-document"
  tool={defineAiTool()({
    description: "Create a document",
    parameters: {
      type: "object",
      properties: {
        content: { type: "string" },
      },
      required: ["content"],
      additionalProperties: false,
    },
    execute: () => {},
    render: ({ stage, partialArgs, args }) => {
      // Document is streaming in
      // +++
      if (stage === "receiving") {
        return <div>Document: {partialArgs.content}</div>;
      }
      // +++

      // Document has fully streamed in
      // +++
      return <div>Document: {args.content}</div>;
      // +++
    },
  })}
/>
```

[`RegisterAiTool`](/docs/api-reference/liveblocks-react#RegisterAiTool) allows
you to stream in strings, objects, and arrays, and you can use them in `render`
as they arrive.

<Banner title="AI presence & streaming example">

The [AI App Builder](/examples/ai-app-builder/nextjs-ai-app-builder) example
demonstrates AI presence and streaming in a code editor.

</Banner>

### Streaming into a document with AI presence

To stream results outside of the chat window, and show AI presence, you can call
functions inside `render`. In this case, weâ€™re updating a document outside of
the chat window, and inside the chat, weâ€™re showing a simple
[`AiTool`](/docs/api-reference/liveblocks-react-ui#AiTool) message.

```tsx
<RegisterAiTool
  name="create-document"
  tool={defineAiTool()({
    description: "Create a document",
    parameters: {
      type: "object",
      properties: {
        content: { type: "string" },
      },
      required: ["content"],
      additionalProperties: false,
    },
    execute: () => {},
    render: ({ stage, partialArgs }) => {
      // Document is streaming in, update document and presence
      // +++
      if (stage === "receiving") {
        __updateDocument__(partialArgs.content);
        __renderPresenceAtPosition__(partialArgs.content.length);
        return <AiTool title="Creating documentâ€¦" />;
      }
      // +++

      // Final chunk of stream is here, update document and end presence
      // +++
      if (stage === "executing") {
        __updateDocument__(args.content);
        __renderPresenceAtPosition__(null);
        return <AiTool title="Creating documentâ€¦" />;
      }
      // +++

      // Document has fully streamed in
      // +++
      return <AiTool title="Document complete!" />;
      // +++
    },
  })}
/>
```

## Advanced JSON schema

Up to this point, weâ€™ve only covered generating objects and strings with AI, but
[JSON schema](https://json-schema.org/learn/getting-started-step-by-step) allows
for more complex data types, such as numbers, arrays, enums, as well as
constraints, and hints for AI.

<Banner type="warning" title="Model compatibility">
  Some AI models donâ€™t allow certain JSON schema types, but weâ€™ve found these
  types work with most models. Many models enforce using the `required` array,
  and setting `additionalProperties: "false"`, which is why we recommend this.
</Banner>

```js
parameters: {
  type: "object",

  properties: {
    // String
    name: { type: "string" },

    // Number
    age: { type: "number" },

    // Boolean
    sendEmail: { type: "boolean" },

    // Union
    count: { type: ["string", "number", "null"] },

    // Array
    pets: { type: "array", items: { type: "string" } },

    // Description, helps AI understand the type
    job: { type: "string", description: "A job title, 1-2 words" },

    // String constraints
    fullName: {
      type: "string",
      minLength: 1,
      maxLength: 100,
      pattern: "^[A-Z][a-zA-Z'-]+(?: [A-Z][a-zA-Z'-]+)+$",
    },

    // Number constraints
    ageInYears: { type: "number", minimum: 18, maximum: 100 },

    // Combination of all
    people: {
      type: "array",
      description: "A list of all people",
      items: {
        type: "object",
        properties: {
          sendEmail: { type: "boolean", description: "Notify them by?" },
          name: { type: "string", description: "First and last names" },
          age: { type: "number", minimum: 18, description: "Age in years" },
          job: { type: ["string", "null"], description: "`null` for unemployed" },
        }
      },
    },
  },

  // Recommended to always set the following, passing all properties to `required`
  additionalProperties: false,
  required: ["name", "age", "sendEmail", "job", "fullName", "ageInYears", "pets", "people"],
}
```

## Updating tools

After a tool has been used in the chat, its AI-filled parameters are permanently
set. This leaves us with a problemâ€”if we remove or change the toolâ€™s parameters,
old versions of the tool will display an empty space in the chat (or in
development mode, an error box).

```diff
// âŒ Will render `null` in the chat instead of a tool
â€Ž<RegisterAiTool
  name="send-email"
  tool={defineAiTool()({
    description: "Send an email",
    parameters: {
      type: "object",
      properties: {
-       email: { type: "string" },
+       emailAddress: { type: "string" },
      },
-     required: ["email"],
+     required: ["emailAddress"],
      additionalProperties: false,
    },
  })}
  // ...
/>
```

Care needs to be taken when creating a new version of each tool if you wish for
old chats to display fully working components. For this reason, we recommend
versioning your tools, and disabling the old tool until youâ€™re sure the old
tools arenâ€™t needed anymore. This will ensure the tool wonâ€™t be used in new
chats, but the old component will still render correctly.

```tsx
import { RegisterAiTool } from "@liveblocks/react";
import { defineAiTool } from "@liveblocks/client";
import { AiChat } from "@liveblocks/react-ui";

function Chat() {
  return (
    <>
      <AiChat chatId="my-chat-id" />
      <RegisterAiTool
        name="send-email"
        // +++
        // Disabling the old tool so it won't be used in new chats
        enabled={false}
        // +++
        tool={defineAiTool()({
          description: "Send an email",
          parameters: {
            type: "object",
            properties: {
              // +++
              email: { type: "string" },
              // +++
            },
            required: ["email"],
            additionalProperties: false,
          },
        })}
        // ...
      />
      <RegisterAiTool
        // +++
        // Version 2, which will be used in new chats
        name="send-email-v2"
        // +++
        tool={defineAiTool()({
          description: "Send an email",
          parameters: {
            type: "object",
            properties: {
              // +++
              emailAddress: { type: "string" },
              // +++
            },
            required: ["emailAddress"],
            additionalProperties: false,
          },
        })}
        // ...
      />
    </>
  );
}
```

---
meta:
  title: "Troubleshooting"
  parentTitle: "AI Copilots"
  description: "Troubleshoot common issues"
---

AI models are often unreliable and tricky to debug. Here are some common issues
you may encounter, and how to troubleshoot them.

## Common issues

Hereâ€™s a list of common issues you may encounter, and how to fix them.

### The AI provider is currently overloaded or unavailable

This means that the AI provider youâ€™re using is currently not available. You can
check the status of your provider by visiting their status pages:
[OpenAI](https://status.openai.com/), [Anthropic](https://status.claude.com/),
[Google](https://aistudio.google.com/status). To avoid this issue, you can
[set up fallback models](/docs/guides/how-to-use-fallback-ai-models-in-ai-copilots)
that use other providers.

### The AI provider's rate limit or quota exceeded

This means that youâ€™ve hit token limits defined by your AI provider (e.g.
OpenAI, Anthropic, Google). You can reach out to your provider to increase your
limits, use a model with lower limits, or consider
[setting up fallback models](/docs/guides/how-to-use-fallback-ai-models-in-ai-copilots)
for busy times.

### For this AI provider, 'additionalProperties: false' is required to be set in the properties [#additionalproperties-false-is-required]

This means that your provider requires the `additionalProperties` field to be
set to `false` in tool `parameters`. Fix this by adding the following line to
your tool definition:

```tsx
<RegisterAiTool
  name="weather-tool"
  tool={defineAiTool()({
    description: "Get the weather for a location",
    parameters: {
      type: "object",
      properties: {
        location: { type: "string" },
      },
      required: ["location"],
      // +++
      additionalProperties: false,
      // +++
    },
    // ...
  })}
/>
```

### A model is ignoring my back-end knowledge

If an AI model doesnâ€™t seem to be using your
[back-end knowledge](/docs/ready-made-features/ai-copilots/knowledge#Back-end-knowledge)
correctly, there are a few things you can check:

#### Check youâ€™re using the correct copilot ID in all APIs

Check youâ€™re using the copilot ID throughout your application, specifically in
every use of [`AiChat`](/docs/api-reference/liveblocks-react-ui#AiChat) and
[`useSendAiMessage`](/docs/api-reference/liveblocks-react#useSendAiMessage).

```tsx
import { AiChat } from "@liveblocks/react-ui";

function Chat() {
  return (
    <AiChat
      chatId="my-chat-id"
      // +++
      copilotId="co_tUYtNctLAtUIAAIZBc1Zk"
      // +++
    />
  );
}
```

```tsx
import { useSendAiMessage } from "@liveblocks/react";

function SendMessage() {
  const sendAiMessage = useSendAiMessage("my-chat-id", {
    // +++
    copilotId: "co_tUYtNctLAtUIAAIZBc1Zk",
    // +++
  });

  return (
    <button onClick={() => sendAiMessage("What's new?")}>What's new?</button>
  );
}
```

#### Make sure youâ€™re letting AI know when to use knowledge

Make sure youâ€™re defining
[when AI should use knowledge](/docs/ready-made-features/ai-copilots/copilots#When-should-AI-use-knowledge)
in your copilot settings. When defining copilots from the server, this is the
`knowledgePrompt` field. If it doesnâ€™t seem to be working, try experimenting
with your prompt to be more specific, authoritative, and use examples.

```diff title="When should AI use knowledge?"
- When the user asks a question about code.
+ It's required to do this whenever the user mentions React code, e.g. `useOthers`.
```

Itâ€™s worth checking if thereâ€™s an official guide for your specific model, which
details how to talk to it. For example the
[official prompting guide for GPT-4.1](https://cookbook.openai.com/examples/gpt4-1_prompting_guide).

### The AI provider response exceeded the maximum token limit

This means that the response from the AI provider exceeded the maximum token
limit.

This error is usually caused:

- When the modelâ€™s generated output would exceed the `max tokens` you set in the
  dashboard for a copilot.
- When the request would exceed the model/providerâ€™s token limits (e.g.,
  combined prompt + expected completion), leading the provider to return a
  token-limit error

Check first in your dashboard if the max tokens limit is set correctly.

## Error table

Every error you may encounter is listed in the table below, along with a
suggestion.

| Error                                                                                        | Info                                                                                                                                                                                              |
| -------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| The AI provider is currently overloaded or unavailable                                       | Your provider is down, check its status. [Learn more](#The-AI-provider-is-currently-overloaded-or-unavailable)                                                                                    |
| The AI provider's rate limit or quota exceeded                                               | Youâ€™ve breached the rate limit or quota for your model. [Learn more](#The-AI-provider's-rate-limit-or-quota-exceeded)                                                                             |
| A technical error happened while invoking the AI provider.                                   | A internal technical error happened. [Contact support](https://liveblocks.io/contact/support) if the problem persists.                                                                            |
| For this AI provider, 'additionalProperties: false' is required to be set in the properties` | You need to add `additionalProperties: false` to your tool `parameters` object. [Learn more](#additionalproperties-false-is-required)                                                             |
| Error from AI provider: ...                                                                  | Generic error received from the AI Provider. [Contact support](https://liveblocks.io/contact/support) if the problem persists.                                                                    |
| The AI copilotâ€™s model does not exist or you have insufficient access to it                  | Most likely the wrong `copilotId` is set. Potentially the current user has no permissions to view it.                                                                                             |
| Invalid credentials or insufficient permissions                                              | The API key used in the copilot is invalid or it not has the required permissions to use the model defined in the copilot.                                                                        |
| The AI copilot could not make the request because it is too large                            | Usually the token limit for the model to process is exceeded.                                                                                                                                     |
| The AI provider blocked the request due to a content filter                                  | The request was blocked by the AI provider own content filter.                                                                                                                                    |
| The AI provider response exceeded the maximum token limit                                    | The response from the AI provider exceeded the maximum token limit. Check your max tokens limit in the copilot settings. [Learn more](#The-AI-provider-response-exceeded-the-maximum-token-limit) |
| An unexpected database error happened.                                                       | An internal database error happened. [Contact support](https://liveblocks.io/contact/support) if the problem persists.                                                                            |
| Timeout error.                                                                               | The request timed out. [Contact support](https://liveblocks.io/contact/support) if the problem persists.                                                                                          |
| Abort error.                                                                                 | The request was aborted by the user but the operation did not succeed to abort. [Contact support](https://liveblocks.io/contact/support) if the problem persists.                                 |
| Aborted by user.                                                                             | The current request was aborted by the user.                                                                                                                                                      |
| Messages deleted by user.                                                                    | A message in the chat no longer exists because it was deleted by a user.                                                                                                                          |
| Chat deleted by user.                                                                        | A chat was deleted by a user and our infra cannot proceed the request.                                                                                                                            |

---
meta:
  title: "Comments"
  parentTitle: "Ready-made features"
  description:
    "Embed a customizable commenting experience into your product to enable
    people to collaborate."
---

Embed a customizable commenting experience into your product, enabling
collaboration between your users. Liveblocks Comments is fully customizable,
allowing you to create a range of commenting experiences that look and feel like
your product. It enables you to build mentions, thread resolution, text
annotations, video annotations, and more.

## Overview

<ListGrid columns={2}>
  <DocsCard
    type="technology"
    title="Concepts"
    href="/docs/ready-made-features/comments/concepts"
    description="Learn about threads and comments"
    visual={<DocsIdeaIcon className="fill-product-icon-brand h-auto w-6" />}
  />
  <DocsCard
    type="technology"
    title="Users and mentions"
    href="/docs/ready-made-features/comments/users-and-mentions"
    description="Add users to comments and mentions"
    visual={<DocsMentionIcon className="fill-product-icon-brand h-auto w-6" />}
  />
  <DocsCard
    type="technology"
    title="Default components"
    href="/docs/ready-made-features/comments/default-components"
    description="Ready-to-use customizable components"
    visual={
      <DocsDefaultComponentsIcon className="fill-product-icon-brand h-auto w-6" />
    }
  />
  <DocsCard
    type="technology"
    title="Hooks"
    href="/docs/ready-made-features/comments/hooks"
    description="Get users, threads, & modify comments"
    visual={<DocsHooksIcon className="fill-product-icon-brand h-auto w-6" />}
  />
  <DocsCard
    type="technology"
    title="Metadata"
    href="/docs/ready-made-features/comments/metadata"
    description="Add custom metadata to threads"
    visual={<DocsMetadataIcon className="fill-product-icon-brand h-auto w-6" />}
  />
  <DocsCard
    type="technology"
    title="Primitives"
    href="/docs/ready-made-features/comments/primitives"
    description="Construct fully custom components"
    visual={
      <DocsPrimitivesIcon className="fill-product-icon-brand h-auto w-6" />
    }
  />
  <DocsCard
    type="technology"
    title="Styling and customization"
    href="/docs/ready-made-features/comments/styling-and-customization"
    description="CSS variables, dark mode, localization"
    visual={<DocsStylingIcon className="fill-product-icon-brand h-auto w-6" />}
  />
  <DocsCard
    type="technology"
    title="Email notifications"
    href="/docs/ready-made-features/comments/email-notifications"
    description="Send notifications with webhooks"
    visual={<DocsEmailIcon className="fill-product-icon-brand h-auto w-6" />}
  />
</ListGrid>

## Comments API Reference

<ListGrid columns={2}>
  <DocsCard
    type="technology"
    title="React"
    href="/docs/api-reference/liveblocks-react#Comments"
    description="@liveblocks/react"
    visual={<DocsReactIcon />}
  />
  <DocsCard
    type="technology"
    title="React UI"
    href="/docs/api-reference/liveblocks-react-ui#Comments"
    description="@liveblocks/react-ui"
    visual={<DocsReactIcon />}
  />
  <DocsCard
    type="technology"
    title="JavaScript"
    href="/docs/api-reference/liveblocks-client#Comments"
    description="@liveblocks/client"
    visual={<DocsJavascriptIcon />}
  />
  <DocsCard
    type="technology"
    title="Node.js"
    href="/docs/api-reference/liveblocks-node#Comments"
    description="@liveblocks/node"
    visual={<DocsNodejsIcon className="fill-product-icon-brand h-auto w-6" />}
  />
  <DocsCard
    type="technology"
    title="REST API"
    href="/docs/api-reference/rest-api-endpoints#Comments"
    description="HTTP endpoints"
    visual={<DocsApiIcon className="fill-product-icon-brand h-auto w-6" />}
  />
</ListGrid>

## Examples using Comments

<ListGrid columns={2}>
  <ExampleCard
    example={{
      title: "Comments",
      slug: "comments/nextjs-comments",
      image: "/images/examples/thumbnails/comments.jpg",
    }}
    technologies={["nextjs", "react"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Video Comments",
      slug: "video-comments/nextjs-comments-video",
      image: "/images/examples/thumbnails/comments-video.png",
    }}
    technologies={["nextjs"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Overlay Comments",
      slug: "overlay-comments/nextjs-comments-overlay",
      image: "/images/examples/thumbnails/comments-overlay.png",
    }}
    technologies={["nextjs"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Text Editor Comments",
      slug: "text-editor-comments/nextjs-comments-tiptap",
      image: "/images/examples/thumbnails/comments-text-editor.png",
    }}
    technologies={["nextjs"]}
    openInNewWindow
  />
</ListGrid>

---
meta:
  title: "Concepts"
  parentTitle: "Comments"
  description: "Learn about threads and comments"
---

A quick overview of the concepts used in Liveblocks Comments.

## Threads

In Liveblocks Comments, everything revolves around _threads_. In each
[multiplayer room](/docs/concepts/how-liveblocks-works#Rooms) you can create a
number of threads. Each individual thread contains a list of _comments_ written
by your users.

<Figure>
  <Image
    src="/assets/comments/comment-thread-room-relation.jpg"
    srcDark="/assets/comments/comment-thread-room-relation-dark.jpg"
    alt="Diagram showing a comment, inside a thread, inside a room"
    width={768}
    height={480}
    quality={100}
  />
</Figure>

Threads can be retrieved by
[a React hook](/docs/ready-made-features/comments/hooks#threads-hook) or
[on your server](/docs/api-reference/liveblocks-node#get-rooms-roomId-threads).
Hereâ€™s an example of a thread object.

```ts
{
  type: "thread",
  id: "th_sf8s6sh...",
  roomId: "my-room-id",
  createdAt: Date <Fri Dec 15 2023 14:15:22 GMT+0000 (Greenwich Mean Time)>,
  resolved: false,
  comments: [
    // A list of comments in the thread
    // ...
  ],
  metadata: {
    // Your custom thread metadata
    // ...
  },
}
```

Threads can store
[custom metadata](/docs/ready-made-features/comments/metadata), which is helpful
for integrating them into your product.

## Comments

Each comment is created by a user, referenced by their
[user ID](/docs/ready-made-features/comments/users-and-mentions), and is part of
a thread. The first comment in a thread is displayed at the top.

<Figure>
  <Image
    src="/assets/comments/first-comment-in-thread.jpg"
    srcDark="/assets/comments/first-comment-in-thread-dark.jpg"
    alt="thread.comments[0] is the first comment in a thread"
    width={768}
    height={480}
    quality={100}
  />
</Figure>

Hereâ€™s an example of a single comment inside a thread object.

```ts highlight="8-24"
{
  type: "thread",
  id: "th_sf8s6sh...",
  roomId: "my-room-id",
  createdAt: Date <Fri Dec 15 2023 14:15:22 GMT+0000 (Greenwich Mean Time)>,
  resolved: false,
  comments: [
    {
      type: "comment",
      threadId: "th_sf8s6sh...",
      id: "cm_agH76a...",
      roomId: "my-room-id",
      userId: "alicia@example.com",
      createdAt: Date <Fri Dec 15 2023 14:15:22 GMT+0000 (Greenwich Mean Time)>,
      editedAt: Date <Fri Dec 15 2023 15:07:19 GMT+0000 (Greenwich Mean Time)>,
      body: {
        // The comment's text in `CommentBody` format
        // ...
      },
      metadata: {
        // Your custom comment metadata
        // ...
      },
    },

    // Other comments in the thread
    // ...
  ],
  metadata: {
    // Your custom thread metadata
    // ...
  },
}
```

A commentâ€™s `body` is in a custom `CommentBody` format, though you most likely
wonâ€™t need to use this, as we render it in React for you. We also provide a
number of functions that allow you to easily
[convert a commentâ€™s body into Markdown, HTML, or plain text](/docs/api-reference/liveblocks-node#stringify-comment-body),
which is especially helpful for creating email notifications.

Similarly to threads, comments can also store
[custom metadata](/docs/ready-made-features/comments/metadata), which is helpful
for integrating them into your product.

### Deleted comments

Deleting a comment doesnâ€™t remove the comment object from the thread, instead
the `comment.body` property is removed, and a `comment.deletedAt` property is
added, which contains the deletion time. This allows you to handle the deleted
comment in whichever way you see fit, for example you may like to create a
â€œmessage deletedâ€ placeholder for the comment. Alternatively, the comment can be
hidden completely.

<Figure>
  <Image
    src="/assets/comments/comment-deleted.jpg"
    srcDark="/assets/comments/comment-deleted-dark.jpg"
    alt="Image of a thread with one comment highlighting a deleted comment"
    width={768}
    height={480}
    quality={100}
  />
</Figure>

A thread is only deleted after all its comments have been deleted.

---
meta:
  title: "Default components"
  parentTitle: "Comments"
  description: "Ready-to-use customizable components"
---

The default components included in Comments are a great way to start building
your application. With these components you can render entire threads, along
with a comment composer.

- Fully styled commenting components, with an optional dark mode.
- Customize through CSS variables and class names.
- Localize and modify strings with overrides.
- Can be used alongside
  [primitives](/docs/ready-made-features/comments/primitives).

## Thread

The [`Thread`][] component renders a thread and its contained comments, as well
a composer for adding new comments to thread.

<Figure>
  <Image
    src="/assets/comments/thread.png"
    alt="Thread"
    width={768}
    height={446}
  />
</Figure>

### Usage

The best way to get started is to import the [`useThreads`][] hook, and loop
through each thread in the current room.

```tsx highlight="5,9-11"
import { Thread } from "@liveblocks/react-ui";
import { useThreads } from "../liveblocks.config";

function Component() {
  const { threads } = useThreads();

  return (
    <>
      {threads.map((thread) => (
        <Thread key={thread.id} thread={thread} />
      ))}
    </>
  );
}
```

This will render a list containing every thread in the room, each with its own
composer for adding new comments.

## Composer

The [`Composer`][] component renders a rich-text composer thatâ€™s used to create
new threads. It can also be used to add comments to an existing thread, or to
edit comments.

<Figure>
  <Image
    src="/assets/comments/composer.png"
    alt="Composer"
    width={768}
    height={446}
  />
</Figure>

### Usage

Get started by importing the component. By default, itâ€™ll create a new thread
when the formâ€™s submitted.

```tsx
import { Composer } from "@liveblocks/react-ui";

// Creates a new thread
function Component() {
  return <Composer />;
}
```

[`Composer`][] can also be used in other ways:

- [Adding metadata to a new thread](/docs/api-reference/liveblocks-react-ui#Adding-thread-metadata)
- [Replying to a thread](/docs/api-reference/liveblocks-react-ui#Replying-to-a-thread)
- [Adding metadata to a reply](/docs/api-reference/liveblocks-react-ui#Adding-comment-metadata)
- [Modifying a comment](/docs/api-reference/liveblocks-react-ui#Modifying-a-comment)
- [Custom behavior](/docs/api-reference/liveblocks-react-ui#Custom-behavior)

## Comment

The [`Comment`][] component renders a single comment. Itâ€™s useful if youâ€™re
building a custom [Thread](#Thread) component, or if youâ€™re displaying a
standalone comment.

<Figure>
  <Image
    src="/assets/comments/comment.png"
    alt="Comment"
    width={768}
    height={446}
  />
</Figure>

### Usage

Start by importing the component, and passing the comment to it.

```tsx highlight="9"
import { Comment } from "@liveblocks/react-ui";
import { ThreadData } from "@liveblocks/client";

// Renders a list of comments attached to the specified `thread`
function MyComment({ thread }: { thread: ThreadData }) {
  return (
    <>
      {thread.comments.map((comment) => (
        <Comment key={comment.id} comment={comment} />
      ))}
    </>
  );
}
```

[`Composer`]: /docs/api-reference/liveblocks-react-ui#Composer
[`Comment`]: /docs/api-reference/liveblocks-react-ui#Comment
[`Thread`]: /docs/api-reference/liveblocks-react-ui#Thread
[`useThreads`]: /docs/api-reference/liveblocks-react#useThreads

## Customization

Itâ€™s possible to style and localize the default components:

- Import dark mode styles.
- Modify the style with CSS variables and class names.
- Use overrides to change default text used in the components.

Learn more under
[styling and customization](/docs/ready-made-features/comments/styling-and-customization).

---
meta:
  title: "Email notifications"
  parentTitle: "Comments"
  description: "Send notifications with webhooks"
---

Using Liveblocks webhooks, itâ€™s possible to trigger your API endpoints when
certain events occur, such as a thread being created, or a comment being
modified. One use for these events is sending unread comment notifications, for
example via email or Slack.

<Figure>
  <Image
    src="/assets/comments/email-notification.png"
    alt="An email titled 'New notifications' showing two comments and a link to the thread"
    width={1500}
    height={1000}
  />
</Figure>

<Banner title="Step-by-step tutorial">

This page is an overview of creating email notifications for Comments. If youâ€™d
prefer a full step-by-step tutorial, make sure to read
[how to send email notifications of unread comments](/docs/guides/how-to-send-email-notifications-of-unread-comments).

</Banner>

## Inbox notifications

Email notifications are built around the concept of inbox notifications, which
are different from â€œnormalâ€ notifications in the sense that they can group
multiple activities together and evolve over time, which makes more sense when
sending email notifications because it helps to avoid sending too many emails.
In the case of Comments, inbox notifications are grouped per thread, which means
that if there are 4 new comments in a thread youâ€™re participating in, you will
have a single inbox notification for it, instead of 4 â€œnormalâ€ notifications.

Learn more about Notifications for Comments in the
[overview page](/docs/ready-made-features/comments/email-notifications).

## Sending email notifications with webhooks

Using [Liveblocks webhooks](/docs/platform/webhooks#Liveblocks-events) you can
listen to a range of events such as comments being deleted, or comment reactions
being added. On [your dashboard](https://liveblocks.io/dashboard) you can create
a webhook for a project, and select which events youâ€™d like to listen to. You
only need to select the `"notification"` webhook event for our recommended
solution.

<Figure>
  <video width={1512} height={982} autoPlay loop muted playsInline>
    <source src="/assets/webhooks/edit-events.mp4" type="video/mp4" />
  </video>
</Figure>

The endpoint URL you pass will receive request with relevant data when the event
occurs. The webhook event built for creating these unread notification emails is
called `"notification"`, and by default is sent up to every 30 minutes to each
user, though this can be customized in the webhooks dashboard.

`"notification"` webhooks can be enabled and disabled on certain channels.
Channels are used to represent different places your users may receive
notifications, such as on `email`, `slack`, `teams`, and `webPush`.

<Figure>
  <video width={1512} height={982} autoPlay loop muted playsInline>
    <source src="/assets/webhooks/notification-settings.mp4" type="video/mp4" />
  </video>
</Figure>

Hereâ€™s an example of an event object thatâ€™s sent when a user receives a new (or
updated) inbox notification.

```ts
const event = {
  type: "notification",
  data: {
    channel: "email",
    kind: "thread",
    projectId: "my-project-id",
    roomId: "my-room-id",
    threadId: "th_d75sF3...",
    inboxNotificationId: "in_xt3p7ak...",
    userId: "my-user-id",
    createdAt: "2021-10-06T01:45:56.558Z",
  },
};
```

### Your endpoint

In your endpoint, you can use this `event` object to get information on unread
mentions and replies, and start rendering emails with
[HTML](/docs/api-reference/liveblocks-emails#prepare-thread-notification-email-as-html)
or
[React](/docs/api-reference/liveblocks-emails#prepare-thread-notification-email-as-react).

```tsx
// Get email data as React JSX
const emailData = await prepareThreadNotificationEmailAsReact(
  liveblocks,
  event
);

let email;
switch (emailData.type) {
  // The user has an unread mention
  case "unreadMention": {
    email = (
      // +++
      <div>
        <div>
          @{emailData.comment.author.id} at {emailData.comment.createdAt}
        </div>
        <div>{emailData.comment.body}</div>
      </div>
      // +++
    );
    break;
  }

  // The user has multiple unread replies
  case "unreadReplies": {
    email = (
      // +++
      <div>
        {emailData.comments.map((comment) => (
          <div key={comment.id}>
            <div>
              @{comment.author.id} at {comment.createdAt}
            </div>
            <div>{comment.body}</div>
          </div>
        ))}
      </div>
      // +++
    );
  }
}
```

You can customize this further, resolving user and room IDs into data, allowing
you to render names instead of IDs. You can also add custom React components to
the comment bodies, helpful for custom stying.

```tsx
// Get email data as React JSX
const emailData = await prepareThreadNotificationEmailAsReact(
  liveblocks,
  event,
  {
    // +++
    resolveUsers: async ({ userIds }) => {
      const usersData = await __getUsersFromDB__(userIds);

      return usersData.map((userData) => ({
        name: userData.name,
        avatar: userData.avatar.src,
      }));
    },
    // +++
    // ...
    components: {
      // `user` is the optional data returned from `resolveUsers`
      // +++
      Mention: ({ element, user }) => (
        <span style={{ color: "red" }}>@{user.name}</span>
      ),
      // +++

      // ...
    },
  }
);
```

You can then send an email containing the comment to the owner of `userId`
received in `event`.

```ts
const emailAddress = __getUserEmail__(userId);

// Send email to the user that received the inbox notification
__sendEmail__({
  from: "hello@my-company.com",
  to: emailAddress,
  title: "Unread comment",
  react: `
    <h1>Unread comment</h1>
    ${commentHtml}
  `,
});
```

Hereâ€™s an example with every step linked together, along with the code necessary
to verify a webhook request is valid, and using [Resend](https://resend.com) to
send an email.

```ts title="Full example" isCollapsable isCollapsed
import {
  Liveblocks,
  WebhookHandler,
  isThreadNotificationEvent,
} from "@liveblocks/node";
import { prepareThreadNotificationEmailAsReact } from "@liveblocks/emails";
import { Resend } from "resend";

// Create Resend client (add your API key)
const resend = new Resend("re_123456789");

// Add your webhook secret key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_WEBHOOK_SECRET_KEY";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

// Add your secret key from a project's API keys dashboard
const API_SECRET = "sk_prod_xxxxxxxxxxxxxxxxxxxxxxxx";
const liveblocks = new Liveblocks({ secret: API_SECRET });

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // When an inbox notification has been created
  if (isThreadNotificationEvent(event)) {
    // Check if user has access to room
    if (!__hasRoomAccess__(event.userId, event.roomId)) {
      return new Response(null, { status: 200 });
    }

    // The user to send the email to
    const emailAddress = __getEmailAddressFromDB__(event.userId);

    let emailData;

    try {
      emailData = await prepareThreadNotificationEmailAsReact(
        liveblocks,
        event,
        {
          resolveUsers: async ({ userIds }) => {
            const usersData = await __getUsersFromDB__(userIds);

            return usersData.map((userData) => ({
              name: userData.name, // "Steven"
              avatar: userData.avatar.src, // "https://example.com/steven.jpg"
            }));
          },
          resolveRoomInfo: async ({ roomId }) => {
            const roomData = await __getRoomFromDB__(roomId);

            return {
              name: roomData.name, // "Untitled document"
              url: roomData.url, //`https://example.com/my-room-id`
            };
          },
          components: {
            Paragraph: ({ children }) => (
              <p style={{ margin: "12px 0" }}>{children}</p>
            ),

            // `user` is the optional data returned from `resolveUsers`
            Mention: ({ element, user }) => (
              <span style={{ color: "red" }}>@{user?.name ?? element.id}</span>
            ),

            // If the link is rich-text render it, otherwise use the URL
            Link: ({ element, href }) => (
              <a href={href} style={{ textDecoration: "underline" }}>
                {element?.text ?? href}
              </a>
            ),
          },
        }
      );
    } catch (err) {
      console.log(err);
      return new Response("Could not fetch thread notification data", {
        status: 500,
      });
    }

    // All comments have already been read
    if (!emailData) {
      return new Response(null, { status: 200 });
    }

    let email;
    switch (emailData.type) {
      case "unreadMention": {
        email = (
          <div>
            <div>
              @{emailData.comment.author.id} at {emailData.comment.createdAt}
            </div>
            <div>{emailData.comment.body}</div>
          </div>
        );
        break;
      }

      case "unreadReplies": {
        email = (
          <div>
            {emailData.comments.map((comment) => (
              <div key={comment.id}>
                <div>
                  @{comment.author.id} at {comment.createdAt}
                </div>
                <div>{comment.body}</div>
              </div>
            ))}
          </div>
        );
        break;
      }
    }

    // Send email to the user's email address
    try {
      const data = await resend.emails.send({
        from: "My company <hello@my-company.com>",
        to: emailAddress,
        subject: "New comment",
        react: email,
      });
    } catch (err) {
      console.error(err);
    }
  }

  return new Response(null, { status: 200 });
}
```

If youâ€™re planning on building this, we recommend learning more in our
[how to send email notifications](/docs/guides/how-to-send-email-notifications-of-unread-comments)
guide, as itâ€™s possible to create much more complex emails than this simple
example.

### Permissions

When you receive a `notification` webhook event, it's essential to verify if the
user has access to the room before sending an email. Liveblocks lacks the
necessary information to determine if a user has access to a room. For instance,
we create an inbox notification when a user is mentioned in a comment. In this
user's client context, we can determine if they have access to the notification
thanks to the token generated for that user. However, when we send a
`notification` webhook event, we lack this information.

#### Access token authentication

If you are using access tokens, this will always be true, Liveblocks will never
have the information.

#### ID token authentication

If you are using ID tokens, Liveblocks already possesses certain information
about the permissions you have configured for each room, specifying which users
and groups have access. However, what we currently lack is the relationship
between a user and a group. At present, you need to verify user access before
sending an email. We do, however, plan to include full permissions info in
Liveblocks in our future updates. If you're interested in learning more about
this feature, please feel free to reach out to us.

## Webhook events

There are more webhook events than just the `NotificationEvent` event used
aboveâ€”a number related to Comments are available to use.

- [`CommentCreatedEvent`](/docs/platform/webhooks#CommentCreatedEvent)
- [`CommentEditedEvent`](/docs/platform/webhooks#CommentEditedEvent)
- [`CommentDeletedEvent`](/docs/platform/webhooks#CommentDeletedEvent)
- [`CommentReactionAddedEvent`](/docs/platform/webhooks#CommentReactionAddedEvent)
- [`CommentReactionRemovedEvent`](/docs/platform/webhooks#CommentReactionRemovedEvent)
- [`CommentMetadataUpdatedEvent`](/docs/platform/webhooks#CommentMetadataUpdatedEvent)
- [`ThreadCreatedEvent`](/docs/platform/webhooks#ThreadCreatedEvent)
- [`ThreadMetadataUpdatedEvent`](/docs/platform/webhooks#ThreadMetadataUpdatedEvent)
- [`ThreadMarkedAsResolvedEvent`](/docs/platform/webhooks#ThreadMarkedAsResolvedEvent)
- [`ThreadMarkedAsUnresolvedEvent`](/docs/platform/webhooks#ThreadMarkedAsUnresolvedEvent)

There are also more events, for example you can trigger events when users enter
or leave rooms. We recommend reading our guide on
[testing webhooks locally](/docs/guides/how-to-test-webhooks-on-localhost) to
get started.

## Retrieving and modifying Comments data

Hereâ€™s every Comments-related
[`@liveblocks/node`](/docs/api-reference/liveblocks-node) function. Each also
has a corresponding REST API, you can find more info by following the links.

- [`getThreads`](/docs/api-reference/liveblocks-node#get-rooms-roomId-threads)
- [`createThread`](/docs/api-reference/liveblocks-node#post-rooms-roomId-threads)
- [`getThread`](/docs/api-reference/liveblocks-node#get-rooms-roomId-threads-threadId)
- [`getThreadParticipants`](/docs/api-reference/liveblocks-node#get-thread-participants)
- [`editThreadMetadata`](/docs/api-reference/liveblocks-node#post-rooms-roomId-threads-threadId-metadata)
- [`createComment`](/docs/api-reference/liveblocks-node#post-rooms-roomId-threads-threadId-comments)
- [`getComment`](/docs/api-reference/liveblocks-node#get-rooms-roomId-threads-threadId-comments-commentId)
- [`editComment`](/docs/api-reference/liveblocks-node#post-rooms-roomId-threads-threadId-comments-commentId)
- [`editCommentMetadata`](/docs/api-reference/liveblocks-node#post-rooms-roomId-threads-threadId-comments-commentId-metadata)
- [`deleteComment`](/docs/api-reference/liveblocks-node#delete-rooms-roomId-threads-threadId-comments-commentId)
- [`addCommentReaction`](/docs/api-reference/liveblocks-node#post-rooms-roomId-threads-threadId-comments-commentId-add-reaction)
- [`removeCommentReaction`](/docs/api-reference/liveblocks-node#post-rooms-roomId-threads-threadId-comments-commentId-remove-reaction)
- [`getInboxNotification`](/docs/api-reference/liveblocks-node#get-users-userId-inboxNotifications-inboxNotificationId)
- [`getRoomSubscriptionSettings`](/docs/api-reference/liveblocks-node#get-rooms-roomId-users-userId-subscription-settings)
- [`updateRoomSubscriptionSettings`](/docs/api-reference/liveblocks-node#post-rooms-roomId-users-userId-subscription-settings)
- [`deleteRoomSubscriptionSettings`](/docs/api-reference/liveblocks-node#delete-rooms-roomId-users-userId-subscription-settings)

---
meta:
  title: "Hooks"
  parentTitle: "Comments"
  description: "Get users, threads, and modify comments"
---

The Comments React hooks can be used to fetch, create, and modify threads on the
client.

## List a roomâ€™s threads [#threads-hook]

The most important Comments hook is
[`useThreads`](/docs/api-reference/liveblocks-react#useThreads), which retrieves
a list of each thread in the current room. This can be used to render a list of
threads, either using the
[default components](/docs/ready-made-features/comments/default-components), or
[primitives](/docs/ready-made-features/comments/primitives). Hereâ€™s an example
of it used with the default
[`Thread`](/docs/api-reference/liveblocks-react-ui#Thread) component.

```tsx
import { useThreads } from "../liveblocks.config";

function Component() {
  const { threads } = useThreads();

  // [{ type: "thread", id: "th_sf8s6sh...", ... }, ...]
  console.log(threads);

  return (
    <>
      {threads.map((thread) => (
        <Thread key={thread.id} thread={thread} />
      ))}
    </>
  );
}
```

There are two versions of the
[`useThreads`](/docs/api-reference/liveblocks-react#useThreads) hook, the
[Suspense version](#suspense-hooks), which we recommend by default, and the
[regular version](#regular-hooks).

## Fetch a userâ€™s information [#user-hook]

The only information Liveblocks stores about users is their user ID, which is
set when [authenticating with Liveblocks](/docs/authentication). With the
[`useUser`](/docs/api-reference/liveblocks-react#useUser) hook, you can fetch a
userâ€™s information from their ID. This is particularly helpful when building
primitive components, as this allows you fetch their name, avatar, and any other
custom data youâ€™ve set.

```tsx
import { useUser } from "../liveblocks.config";

function Component() {
  const { user } = useUser("olivier@example.com");

  // { name: "Olivier", avatar: "https://...", color: "red" }
  console.log(user);

  return <img src={user.avatar} alt={user.name} />;
}
```

The user data retrieved is set within the
[`resolveUsers`](/docs/api-reference/liveblocks-client#resolveUsers) function in
your `liveblocks.config.ts` file.

```ts
async function resolveUsers({ userIds }) {
  // ["olivier@example.com"]
  console.log(userIds);

  return [
    {
      name: "Olivier",
      avatar: "https://example.com/olivier.png",
      color: "red",
    },
  ];
}
```

There are two versions of the
[`useUser`](/docs/api-reference/liveblocks-client#useUser) hook,
[Suspense](#suspense-hooks), which we recommend by default, and
[regular](#regular-hooks).

## Fetch a groupâ€™s information [#group-hook]

Similar to users, Liveblocks only stores group IDs for groups. With the
[`useGroupInfo`](/docs/api-reference/liveblocks-react#useGroupInfo) hook, you
can fetch a groupâ€™s information from their ID. This is particularly helpful when
building primitive components, as this allows you to fetch their name, avatar,
and any other custom data youâ€™ve set.

```tsx
import { useGroupInfo } from "../liveblocks.config";

function Component() {
  const { group } = useGroupInfo("engineering");

  // { name: "Engineering", avatar: "https://...", color: "blue" }
  console.log(group);

  return <img src={group.avatar} alt={group.name} />;
}
```

The group data retrieved is set within the
[`resolveGroupsInfo`](/docs/api-reference/liveblocks-client#resolveGroupsInfo)
function in your `liveblocks.config.ts` file.

```ts
async function resolveGroupsInfo({ groupIds }) {
  // ["engineering"]
  console.log(groupIds);

  return [
    {
      name: "Engineering",
      avatar: "https://example.com/engineering.png",
      color: "blue",
    },
  ];
}
```

There are two versions of the
[`useGroupInfo`](/docs/api-reference/liveblocks-client#useGroupInfo) hook,
[Suspense](#suspense-hooks), which we recommend by default, and
[regular](#regular-hooks).

## Create and modify threads and comments [#mutation-hooks]

A number of hooks can be used to mutate comment and thread data, for example:

- Creating threads
- Deleting comments
- Adding emoji reactions

Some of these hooks are quite simple, such as
[`useAddReaction`](/docs/api-reference/liveblocks-react#useAddReaction) which
adds a reaction to a specified comment.

```tsx highlight="6,9-13"
import { CommentData } from "@liveblocks/client";
import { useAddReaction } from "../liveblocks.config.ts";

// A button that adds a "â­" reaction to a comment
function Component({ comment }: { CommentData }) {
  const addReaction = useAddReaction();

  function handleClick() {
    addReaction({
      threadId: comment.threadId,
      commentId: comment.commentId,
      emoji: "â­",
    });
  }

  return <button onClick={handleClick}>Star â­</button>;
}
```

Whereas others, such as
[`useCreateThread`](/docs/api-reference/liveblocks-react#useCreateThread), have
more complex behaviour and are designed to work alongside
[primitives](/docs/ready-made-features/comments/primitives).

```tsx highlight="10,18-21"
import {
  Composer,
  ComposerSubmitComment,
} from "@liveblocks/react-ui/primitives";
import { useCreateThread } from "../liveblocks.config.ts";
import { FormEvent } from "react";

// A custom composer that creates a thread on submit
function MyComposer() {
  const createThread = useCreateThread();

  function handleComposerSubmit(
    { body }: ComposerSubmitComment,
    event: FormEvent<HTMLFormElement>
  ) {
    event.preventDefault();

    const thread = createThread({
      body,
      metadata: {},
    });
  }

  return (
    <Composer.Form onComposerSubmit={handleComposerSubmit}>
      <Composer.Editor />
      <Composer.Submit>Create thread</Composer.Submit>
    </Composer.Form>
  );
}
```

You can find more information on each mutation hook in our API reference pages:

- [`useCreateThread`](/docs/api-reference/liveblocks-react#useCreateThread)
- [`useDeleteThread`](/docs/api-reference/liveblocks-react#useDeleteThread)
- [`useEditThreadMetadata`](/docs/api-reference/liveblocks-react#useEditThreadMetadata)
- [`useMarkThreadAsResolved`](/docs/api-reference/liveblocks-react#useMarkThreadAsResolved)
- [`useMarkThreadAsUnresolved`](/docs/api-reference/liveblocks-react#useMarkThreadAsUnresolved)
- [`useCreateComment`](/docs/api-reference/liveblocks-react#useCreateComment)
- [`useEditComment`](/docs/api-reference/liveblocks-react#useEditComment)
- [`useEditCommentMetadata`](/docs/api-reference/liveblocks-react#useEditCommentMetadata)
- [`useDeleteComment`](/docs/api-reference/liveblocks-react#useDeleteComment)
- [`useAddReaction`](/docs/api-reference/liveblocks-react#useAddReaction)
- [`useRemoveReaction`](/docs/api-reference/liveblocks-react#useRemoveReaction)

Thereâ€™s only one version of these hooks, so it doesnâ€™t make a difference if you
export them from `suspense` in your config file or not.

## Hook types [#hook-types]

There are two different ways to use the [threads](#threads-hook) and
[user](#user-hook) hooks; with
[React Suspense](https://react.dev/reference/react/Suspense), and without it. We
recommend using the Suspense versions, as they often result in simpler code.

### Suspense hooks [#suspense-hooks]

Using Suspense hooks means that any data retrieved, for example `threads` from
`useThreads`, will never be `undefined`, and your component will never see an
error.

```tsx
import { useThreads } from "@liveblocks/react/suspense";

// Suspense: `threads` is always defined
function MyThreads() {
  const { threads } = useThreads();

  // [{ type: "thread", id: "th_sf8s6sh...", ... }, ...]
  console.log(threads);
}
```

To catch errors and display a loading screen, you can use
[`ErrorBoundary`](https://www.npmjs.com/package/react-error-boundary) and
[`ClientSideSuspense`](/docs/api-reference/liveblocks-react#suspense-avoid-ssr).

```tsx highlight="7-11"
import { ClientSideSuspense } from "@liveblocks/react/suspense";
import { ErrorBoundary } from "react-error-boundary";

// Handle errors and loading state in the component above
function Component() {
  return (
    <ErrorBoundary fallback={<div>Error</div>}>
      <ClientSideSuspense fallback={<div>Loading...</div>}>
        <MyThreads />
      </ClientSideSuspense>
    </ErrorBoundary>
  );
}
```

To use Suspense, make sure youâ€™re exporting your hooks from
`@liveblocks/react/suspense`.

```tsx
// Suspense version of hooks
import { useThreads, useUser, useGroupInfo } from "@liveblocks/react/suspense";
//                                                                   ^^^^^^^^
```

### Regular hooks [#regular-hooks]

The regular versions of Liveblocks hooks require you to check for `error` and
`isLoading` properties. You can then handle these states in the same component.

```tsx
import { useThreads } from "@liveblocks/react";

// Handle errors and loading state in the same component
function MyThreads() {
  const { threads, error, isLoading } = useThreads();

  if (error) {
    return <div>Error</div>;
  }

  if (isLoading) {
    return <div>Loading...</div>;
  }

  // Non-Suspense: `threads` is only defined AFTER the `if` checks
  // [{ type: "thread", id: "th_sf8s6sh...", ... }, ...]
  console.log(threads);
}
```

To use the regular hooks, make sure youâ€™re exporting from `@liveblocks/react`.

```tsx
// Regular version of hooks
import { useThreads, useUser, useGroupInfo } from "@liveblocks/react";
//                                                 ^^^^^^^^^^^^^^^^^
```

---
meta:
  title: "Metadata"
  parentTitle: "Comments"
  description: "Add custom metadata to threads and comments"
---

In Comments, each thread and comment can be given custom metadata. This is
helpful for integrating Comments into various applications, for example it can
be used to store:

- The priority, status, or category of a thread.
- Coordinates or timestamps related to the thread.
- Quoted text in a text editor.
- Tags, context, or flags on a comment.
- External IDs like Slack message IDs on comments to build two-way integrations.

## Valid metadata

You can store any `string`, `boolean`, or `number` in metadata, for example:

```ts
metadata: {
  priority: "URGENT",
  pinned: false,
  timestamp: 1703073188013,
}
```

Setting a property to `null` will remove it.

```ts
metadata: {
  timestamp: null,
}
```

You can store up to 50 metadata properties per thread or comment, and each
property can be 4000 characters long.

## Setting metadata

Metadata can be set using the default components, React hooks, or by editing
threads and comments using the REST APIs. But before making any changes, itâ€™s
recommended to set your metadata types in your config file.

```ts file="liveblocks.config.ts"
declare global {
  interface Liveblocks {
    // +++
    ThreadMetadata: {
      priority: string;
      pinned: boolean;
      timestamp: number;
    };
    CommentMetadata: {
      slackMessageTs: string;
      spam: boolean;
      upvotes: number;
    };
    // +++

    // ...
  }
}
```

Learn more about
[typing your data](/docs/api-reference/liveblocks-react#Typing-your-data).

### Composer component

The [`<Composer />`](/docs/api-reference/liveblocks-react-ui#Composer) component
is used to create threads and comments, and by default itâ€™ll create a new
thread, with optional metadata, when its form is submitted.

<Figure>
  <Image
    src="/assets/comments/composer.png"
    alt="Composer"
    width={768}
    height={446}
  />
</Figure>

When using it to create a thread, you can
[pass custom metadata](/docs/api-reference/liveblocks-react-ui#Adding-thread-metadata),
which will be attached to the thread.

```tsx
import { Composer } from "@liveblocks/react-ui";

// Creates a new thread with custom metadata
function Component() {
  return (
    <Composer
      // +++
      metadata={{
        // Custom metadata here
        priority: "URGENT",
        pinned: false,
        timestamp: 1703073188013,
      }}
      // +++
    />
  );
}
```

When using it to reply to a thread, you can also
[pass custom metadata](/docs/api-reference/liveblocks-react-ui#Adding-comment-metadata),
which will be attached to the comment.

```tsx
import { Composer } from "@liveblocks/react-ui";

// Creates a new reply to an existing thread with custom metadata
function Component({ threadId }) {
  return (
    <Composer
      // +++
      threadId={threadId}
      commentMetadata={{
        // Custom metadata here
        tag: "engineering",
        reviewed: false,
      }}
      // +++
    />
  );
}
```

### Mutation hooks

Several
[mutation hooks](/docs/ready-made-features/comments/hooks#mutation-hooks) allow
you to edit thread and comment metadata:
[`useEditThreadMetadata`](/docs/api-reference/liveblocks-react#useEditThreadMetadata),
[`useEditCommentMetadata`](/docs/api-reference/liveblocks-react#useEditCommentMetadata),
and [`useCreateThread`](/docs/api-reference/liveblocks-react#useCreateThread).
Hereâ€™s one way to create a button that sets the `pinned` metadata property to
`true` on a thread.

```tsx highlight="5,10-13"
import { useEditThreadMetadata } from "@liveblocks/react/suspense";

// Button that sets `pinned` metadata to `true`
function Component() {
  const editThreadMetadata = useEditThreadMetadata();

  return (
    <button
      onClick={() =>
        editThreadMetadata({
          threadId: "th_d75sF3...",
          metadata: { pinned: true },
        })
      }
    >
      Pin thread
    </button>
  );
}
```

Hereâ€™s an example of editing comment metadata:

```tsx highlight="5,10-15"
import { useEditCommentMetadata } from "@liveblocks/react/suspense";

// Button that sets `spam` metadata to `true` on a comment
function Component() {
  const editCommentMetadata = useEditCommentMetadata();

  return (
    <button
      onClick={() =>
        editCommentMetadata({
          threadId: "th_d75sF3...",
          commentId: "cm_agH76a...",
          metadata: { spam: true },
        })
      }
    >
      Mark as spam
    </button>
  );
}
```

### REST APIs

Itâ€™s possible to modify metadata from our REST APIs using the
[`@liveblocks/node`](/docs/api-reference/liveblocks-node) package. Hereâ€™s an
example using
[`liveblocks.editThreadMetadata`](/docs/api-reference/liveblocks-node#post-rooms-roomId-threads-threadId-metadata)
for threads.

```ts highlight="12-14"
import { Liveblocks } from "@liveblocks/node";

// Create a Node.js client
const liveblocks = new Liveblocks({ secret: "{{SECRET_KEY}}" });

// Edit a thread's `priority` metadata, passing the user ID that made the change
await liveblocks.editThreadMetadata({
  roomId: "my-room-id",
  threadId: "th_d75sF3...",

  data: {
    metadata: {
      priority: "IMPORTANT",
    },
    userId: "florent@example.com",
  },
});
```

And hereâ€™s an example using
[`liveblocks.editCommentMetadata`](/docs/api-reference/liveblocks-node#post-rooms-roomId-threads-threadId-comments-commentId-metadata)
for comments.

```ts highlight="12-14"
import { Liveblocks } from "@liveblocks/node";

// Create a Node.js client
const liveblocks = new Liveblocks({ secret: "{{SECRET_KEY}}" });

// Edit a comment's `tag` metadata, passing the user ID that made the change
await liveblocks.editCommentMetadata({
  roomId: "my-room-id",
  threadId: "th_d75sF3...",
  commentId: "cm_agH76a...",

  data: {
    metadata: {
      tag: "engineering",
    },
    userId: "florent@example.com",
  },
});
```

The same result can also be achieved directly through our
[edit thread metadata](/docs/api-reference/rest-api-endpoints#post-rooms-roomId-threads-threadId-metadata)
REST API.

```bash
curl -X POST https://api.liveblocks.io/v2/rooms/my-room-id/threads/th_d75sF3.../metadata \
  -H "Authorization: Bearer YOUR_SECRET_KEY" \
  -H "Content-Type: application/json" \
  -d '{"metadata": {"priority": "IMPORTANT"}, "userId": "florent@example.com"}'
```

And our
[edit comment metadata](/docs/api-reference/rest-api-endpoints#post-rooms-roomId-threads-threadId-comments-commentId-metadata)
REST API.

```bash
curl -X POST https://api.liveblocks.io/v2/rooms/my-room-id/threads/th_d75sF3.../comments/cm_agH76a.../metadata \
  -H "Authorization: Bearer YOUR_SECRET_KEY" \
  -H "Content-Type: application/json" \
  -d '{"metadata": {"tag": "engineering"}, "userId": "olivier@example.com"}'
```

---
meta:
  title: "Primitives"
  parentTitle: "Comments"
  description: "Construct fully custom components"
---

The primitive components included in Comments are a great way to build complex,
completely custom components. These are headless and unstyled, and can be used
to construct a fully styled comment body and rich-text comment composer.

- Liveblocks functionality, but your own fully custom styles.
- Build custom components for mentions, suggestions, links, and more.
- Composable components that work similarly to
  [Radix UI](https://www.radix-ui.com/) and
  [Headless UI](https://headlessui.com/).
- Can be used alongside the
  [default components](/docs/ready-made-features/comments/default-components).

## Concepts

Each primitive is made up of one or more components, for example
[`Comment`](/docs/api-reference/liveblocks-react-ui#primitives-Comment) only
needs `Comment.Body`. This component takes a commentâ€™s body, and turns it into
readable text, with links and mentions.

```tsx highlight="6"
import { CommentData } from "@liveblocks/client";
import { Comment } from "@liveblocks/react-ui/primitives";

// Render a custom comment body
function MyComment({ comment }: { comment: CommentData }) {
  return <Comment.Body body={comment.body} />;
}
```

### Use regular props

Each primitive accepts regular HTML props, and passes them down to itâ€™s root
component. For example a `style` prop on `Comment.Body` will be passed down to
its root `div` component. This means you can use regular `div` properties with
your component.

```tsx highlight="9-11"
import { CommentData } from "@liveblocks/client";
import { Comment } from "@liveblocks/react-ui/primitives";

// Render a custom comment body
function MyComment({ comment }: { comment: CommentData }) {
  return (
    <Comment.Body
      body={comment.body}
      className="text-gray-500"
      style={{ width: "300px" }}
      onPointerEnter={() => {}}
    />
  );
}
```

By default, each component uses an appropriate root element, for example
`Composer.Submit` is a `button`, and `Composer.Form` is a `form`. You can use a
custom component with
[`asChild`](/docs/ready-made-features/comments/primitives#Merge-with-your-design-system-components).

### Use custom component parts

Many primitives allow you to customize their parts by passing a `components`
property. In this example, weâ€™re modifying links in the comment, so that theyâ€™re
purple and bold.

```tsx
import { CommentData } from "@liveblocks/client";
import { Comment, CommentBodyLinkProps } from "@liveblocks/react-ui/primitives";

// Render a custom comment body
function MyComment({ comment }: { comment: CommentData }) {
  return (
    <div>
      <Comment.Body
        body={comment.body}
        // +++
        components={{
          Link,
        }}
        // +++
      />
    </div>
  );
}

// +++
// Render a purple link in the comment, e.g. "https://liveblocks.io"
function Link({ href, children }: CommentBodyLinkProps) {
  return (
    <Comment.Link href={href} style={{ color: "purple", fontWeight: 700 }}>
      {children}
    </Comment.Link>
  );
}
// +++
```

### Merge with your design system components

You can also add components directly from your design system. Letâ€™s say you have
a `DesignSystemLink` that looks like this.

```tsx
function DesignSystemLink({ url, children }) {
  return (
    <a href={url} target="_blank">
      {children}
    </a>
  );
}
```

If you were to place this inside `<Comment.Link>`, youâ€™d render two `<a>`
elements, which is not valid HTML. This occurs because both `<Comment.Link>` and
`<DesignSystemLink>` render `<a>` elements.

```tsx
<Comment.Link href={href} style={{ color: "purple " }}>
  <DesignSystemLink url={href}>{children}</DesignSystemLink>
</Comment.Link>

// ===================================================================

// âŒ Renders two separate <a> tags
 <a href="https://liveblocks.io" style="color: purple">
   <a href="https://liveblocks.io" target="_blank">https://liveblocks.io</a>
 </a>
```

However, if you add the `asChild` property to `Comment.Link` it wonâ€™t render any
component, and will instead merge into the child element. This means you can use
a link element from your design system, and only render a single `<a>` element.

```tsx highlight="1"
<Comment.Link href={href} style={{ color: "purple " }} asChild>
  <DesignSystemLink url={href}>{children}</DesignSystemLink>
</Comment.Link>

// ===================================================================

// âœ… Renders one combined <a> tag
<a href="https://liveblocks.io" style="color: purple" target="_blank">
  https://liveblocks.io
</a>
```

This is called composability, and virtually all Comments primitives are
composable with `asChild`; they forward their props and refs, merge their
classes and styles, and chain their event handlers with the child element.

```tsx
import { Button } from "@/my-design-system";

// Use the default <button> element
<Composer.Submit disabled>Send</Composer.Submit>;

// Use an existing custom <Button> component
<Composer.Submit disabled asChild>
  <Button variant="primary">Send</Button>
</Composer.Submit>;
```

## Composer

The [`Composer`](/docs/api-reference/liveblocks-react-ui#primitives-Composer)
primitive allows you to build a custom rich-text composer, which can be used for
creating, or editing, threads and comments. Hereâ€™s an example of a composer that
creates a new thread when itâ€™s submitted.

```tsx
import { Composer } from "@liveblocks/react-ui/primitives";
import { useCreateThread } from "../liveblocks.config.ts";

// Render a custom composer that creates a thread on submit
function MyComposer() {
  const createThread = useCreateThread();

  return (
    <Composer.Form
      onComposerSubmit={({ body }, event) => {
        event.preventDefault();
        const thread = createThread({
          body,
          metadata: {},
        });
      }}
    >
      <Composer.Editor components={/* Your custom component parts */} />
      <Composer.Submit>Create thread</Composer.Submit>
    </Composer.Form>
  );
}
```

Custom component parts can be used to render custom
[mentions](/docs/api-reference/liveblocks-react-ui#primitives-Composer.Editor-Mention),
[links](/docs/api-reference/liveblocks-react-ui#primitives-Composer.Link), and a
[suggestions selection popover](/docs/api-reference/liveblocks-react-ui#primitives-Composer.Suggestions).

### useComposer

The [`useComposer`](/docs/api-reference/liveblocks-react-ui#useComposer) hook
can be placed within `<Composer.Form>` to check if the composer input is empty,
or to submit the form, helpful for creating your own button, or styling the UI.

```tsx highlight="14,17-19"
import { Composer, useComposer } from "@liveblocks/react-ui/primitives";

function MyComposer() {
  return (
    <Composer.Form onComposerSubmit={/* handle submit */}>
      <Composer.Editor components={/* Your custom component parts */} />
      <MyComposerButton />
    </Composer.Form>
  );
}

// Button that submits the form, and is disabled when the input is empty
function MyComposerButton() {
  const { isEmpty, submit } = useComposer();

  return (
    <button onClick={submit} disabled={isEmpty}>
      Create thread
    </button>
  );
}
```

## Comment

The [`Comment`](/docs/api-reference/liveblocks-react-ui#primitives-Comment)
primitive is used to render a `comment.body` object as text, mentions, and
links.

```tsx
import { Comment } from "@liveblocks/react-ui/primitives";
import { CommentData } from "@liveblocks/client";

// Render custom comments in a thread.
function MyComments({ comments }: { comments: CommentData[] }) {
  return (
    <>
      {comments.map((comment) => (
        <div key={comment.id}>
          <Comment.Body
            body={comment.body}
            components={/* Your custom component parts */}
          />
        </div>
      ))}
    </>
  );
}
```

The component above would typically be combined with
[`useThreads`](/docs/api-reference/liveblocks-react#useThreads).

```tsx
import { useThreads } from "../liveblocks.config";

function MyThreads() {
  const { threads } = useThreads();

  return (
    <>
      {threads.map((thread) => (
        <MyComments key={thread.id} comments={thread.comments} />
      ))}
    </>
  );
}
```

Custom component parts can be used to render
[mentions](/docs/api-reference/liveblocks-react-ui#primitives-Comment.Mention)
and [links](/docs/api-reference/liveblocks-react-ui#primitives-Comment.Link).

## Timestamp

The [`Timestamp`](/docs/api-reference/liveblocks-react-ui#primitives-Timestamp)
primitive is a quick helper that will convert a date object, or timestamp, into
a friendly format. For example, itâ€™ll render a format similar to â€œ5 minutes agoâ€
for a recent comment, and â€œ22 Decâ€ for an older comment.

```tsx highlight="12"
import { Timestamp } from "@liveblocks/react-ui";
import { useThreads } from "../liveblocks.config";

// Render threads with friendly datetime messages above
function Component() {
  const { threads } = useThreads();

  return (
    <>
      {threads.map((thread) => (
        <div key={thread.id}>
          Thread posted at: <Timestamp date={thread.createdAt} />
          {/* Render `thread` ... */}
        </div>
      ))}
    </>
  );
}
```

---
meta:
  title: "Styling and customization"
  parentTitle: "Comments"
  description: "CSS variables, dark mode, localization, and more"
---

Styling
[default components](/docs/ready-made-features/comments/default-components) and
[primitives](/docs/ready-made-features/comments/primitives) is enabled through a
range of means, such as CSS variables, class names, and more. Itâ€™s also possible
to use
[overrides](/docs/ready-made-features/comments/styling-and-customization#Overrides-and-localization)
to modify any strings used in the default components, which is especially
helpful for localization.

## Default components

To add the default componentsâ€™ theme, import the
[default styles](/docs/api-reference/liveblocks-react-ui#Default-styles) CSS
file.

```ts
import "@liveblocks/react-ui/styles.css";
```

You can also import one of two CSS files to enable
[dark mode](/docs/api-reference/liveblocks-react-ui#Dark-mode), depending on how
youâ€™d like to enable it.

```ts
// Dark mode using the system theme with `prefers-color-scheme`
import "@liveblocks/react-ui/styles/dark/media-query.css";
```

```ts
// Dark mode using `className="dark"`, `data-theme="dark"`, or `data-dark="true"`
import "@liveblocks/react-ui/styles/dark/attributes.css";
```

### CSS variables

A number of
[CSS variables](/docs/api-reference/liveblocks-react-ui#CSS-variables) can be
used to customize colors, spacing, and more. This is our recommended path for
styling the default components, as you can quickly and easily modify all
components with just a few variables.

```css
/* Styles all default components */
.lb-root {
  --lb-accent: purple;
  --lb-spacing: 1em;
  --lb-radius: 0;
}
```

### Class names

Should you need deeper customization,
[class names](/docs/api-reference/liveblocks-react-ui#Class-names) can be
styled, some of which provide contextual data attributes.

```css
.lb-thread {
  /* Customize thread */
}

.lb-avatar[data-loading] {
  /* Customize avatar loading state */
}
```

### Overrides and localization

Itâ€™s possible to
[override strings](/docs/api-reference/liveblocks-react-ui#Overrides) used in
the default components, which has a couple of different uses, the first being
localization. In this example, weâ€™re globally switching the word â€œAnonymousâ€ to
â€œAnonymeâ€ for French users.

```tsx
import { LiveblocksUiConfig } from "@liveblocks/react-ui";

export function App() {
  return (
    <LiveblocksUiConfig
      overrides={{ locale: "fr", USER_UNKNOWN: "Anonyme" /* ... */ }}
    >
      {/* ... */}
    </LiveblocksUiConfig>
  );
}
```

You can also override strings on a component basis, for example if youâ€™d like to
change the placeholder text in the
[`Composer`](/docs/api-reference/liveblocks-react-ui#Composer).

```tsx
import { Composer } from "@liveblocks/react-ui";

function Component() {
  return (
    <Composer
      overrides={{
        COMPOSER_PLACEHOLDER: "Reply to threadâ€¦",
      }}
    />
  );
}
```

## Primitives

Primitives
[can be styled like any other element](/docs/ready-made-features/comments/primitives#Use-regular-props)
in your React applicationâ€”each component passes down props to its root element,
meaning you can use regular HTML props.

```tsx
import { Composer } from "@liveblocks/react-ui/primitives";

function Component() {
  return (
    <Composer.Submit className="btn-primary" style={{ color: "#ffffff" }}>
      Reply
    </Composer.Submit>
  );
}
```

You can use your custom design system components with primitives by using the
`asChild` property, which will
[merge the primitiveâ€™s props](/docs/ready-made-features/comments/primitives#Merge-with-your-design-system-components)
into your componentâ€™s.

```tsx highlight="6"
import { Composer } from "@liveblocks/react-ui/primitives";
import { Button } from "@/my-design-system";

function Component() {
  return (
    <Composer.Submit asChild>
      <Button variant="primary">Reply</Button>
    </Composer.Submit>
  );
}
```

### Tailwind

Style primitives with [Tailwind](https://tailwindcss.com) by adding class names.

```tsx
import { Composer } from "@liveblocks/react-ui/primitives";

function Component() {
  return (
    <Composer.Submit className="bg-black text-white">Reply</Composer.Submit>
  );
}
```

### CSS modules

Style primitives with [CSS modules](https://github.com/css-modules/css-modules)
as you would any other component.

```tsx
import { Composer } from "@liveblocks/react-ui";
import styles from "./Component.module.css";

function Component() {
  return <Composer.Submit className={styles.submit}>Reply</Composer.Submit>;
}
```

---
meta:
  title: "Users and mentions"
  parentTitle: "Comments"
  description: "Add users and groups to comments and mentions"
---

When a comment is posted, Liveblocks doesnâ€™t store any user metadata, for
example their avatar or name. Instead, it only saves their user ID, which you
manually set when authenticating. To fetch user metadata, we provide functions
that allow you to return the correct data.

<Figure>
  <Image
    src="/assets/tutorials/comments/thread.png"
    alt="Thread with resolved users"
    width={1291}
    height={892}
  />
</Figure>

<Banner title="Step-by-step tutorial">

This page explains the concepts behind adding users and mentions to Comments. If
youâ€™d prefer a full step-by-step tutorial, make sure to read
[how to add users to Liveblocks Comments](/docs/guides/how-to-add-users-to-liveblocks-comments).

</Banner>

## Authenticate your users

You can set a userâ€™s ID when authenticating your application, for example with
[`liveblocks.prepareSession`](/docs/api-reference/liveblocks-node#access-tokens).
This ID is then used inside Comments to represent the current user, for example
weâ€™re using an email address as a user ID below.

```ts highlight="1"
const session = liveblocks.prepareSession("charlie.layne@example.com", {
  userInfo: {
    // Custom user info to be used in Presence
    // This is NOT used in Comments
    // ...
  },
});
```

There are two different authentication methodsâ€”make sure to follow an
[authentication guide for your framework](/docs/authentication) to get started.

## Adding user information

To add names and avatars to Comments, you need to convert user IDs into user
objects. For example, hereâ€™s a `userIds` array and the information you need to
return. You should return the same number of users as the number of user IDs, in
the same order.

```shell
# If this is `userIds`
["marc@example.com", "pierre@example.com"]

# Return `users`
[{ name: "Marc", avatar: "https://example.com/marc.png" }, { name: "Pierre", avatar: "https://example.com/pierre.png" }]
```

To do this, add a property named
[`resolveUsers`](/docs/api-reference/liveblocks-react#LiveblocksProviderResolveUsers)
to your
[`LiveblocksProvider`](/docs/api-reference/liveblocks-react#LiveblocksProvider)
where you can return this information.

```tsx
<LiveblocksProvider
  authEndpoint="/api/liveblocks-auth"
  // +++
  resolveUsers={async ({ userIds }) => {
    // ["marc@example.com", ...]
    console.log(userIds);

    // Get users from your back-end
    const users = await __fetchUsers__(userIds);

    // [{ name: "Marc", avatar: "https://example.com/marc.png" }, ...]
    console.log(users);

    // Return a list of users
    return users;
  }}
  // +++
>
```

### Custom user information

The `name`, and `avatar` are handled by the default components, but you can also
return custom metadata here. For example, each user may have a `color` property.
You can retrieve these properties in your app with
[`useUser`](/docs/api-reference/liveblocks-react#useUser).

```tsx
function Component() {
  // +++
  const { user } = useUser("marc@example.com");
  // +++

  // { color: "red", name: "Marc", avatar: "https://example.com/marc.png" }
  console.log(user);

  // ...
}
```

## Mentions

Comments allows you to use mentions/tag users by typing the `@` character. You
can also tag groups, for example `@everyone`. After a userâ€™s mentioned in a
thread, theyâ€™ll receive an
[inbox notification](/docs/ready-made-features/notifications/concepts#Inbox-Notifications).

<Figure>
  <Image
    src="/assets/tutorials/comments/mentions.png"
    alt="Working Comments mentions"
    width={1297}
    height={781}
  />
</Figure>

### Resolving mention suggestions

To define which mentions appear in the suggestion pop-up, you need to return a
list of users that are being searched for. When a user types `@` Comments passes
you a `text` property, the text that the user has typed so far, which you can
use to find and return matching user IDs.

```shell
# If "@mar" has been typed, this is `text`
"mar"

# Return matching `userIds` and `groupIds`
["marc@example.com", "marissa@example.com"]
```

You can resolve these search results by adding a
[`resolveMentionSuggestions`](/docs/api-reference/liveblocks-react#LiveblocksProviderResolveMentionSuggestions)
property to your
[`LiveblocksProvider`](/docs/api-reference/liveblocks-react#LiveblocksProvider).
Hereâ€™s what the function might look like if the user has typed `"@mar"` into the
input.

```tsx
<LiveblocksProvider
  authEndpoint="/api/liveblocks-auth"
  resolveUsers={async ({ userIds }) => {
    // ...
  }}
  // +++
  resolveMentionSuggestions={async ({ text, roomId }) => {
    // "mar"
    console.log(text);

    // Return an array of user IDs for the query "mar"
    let userIds;

    if (text) {
      // If there's a query, get user IDs from your back-end that match
      userIds = await __queryUserIds__(text);
    } else {
      // If there's no query, get all of the room's user IDs
      userIds = await __getAllUserIds__();
    }

    // ["marc@example.com", "marissa@example.com"]
    console.log(userIds);
    return userIds;
  }}
  // +++
>
```

You can also resolve group mentions in here, though that requires you to
structure the function differently.

## Group mentions

Alongside user mentions, you can also mention groups by typing the `@`
character, for example `@everyone` or `@engineering`.

<Figure>
  <Image
    src="/assets/comments/group-mentions.png"
    alt="Working Comments group mentions"
    width={1297}
    height={781}
  />
</Figure>

There are two different ways to set up group mentions:

1. Passing group members on the front-end, particularly helpful for global
   mentions like `@everyone` and `@here`.
2. Using managed groups of users on the back-end, helpful for handling specific
   groups of users like `@engineering` or `@design`.

### Return a different format

When using group mentions, you must return a list of mention objects with a
`kind` property, instead of a list user ID strings, like below.

```diff
- return ["marc@example.com"];
+ return [
+  {
+    kind: "user",
+    id: "marc@example.com",
+  },
+ ];
```

Users have a `user` kind and groups have `group` kind.

```tsx
return [
  {
    // +++
    kind: "user",
    // +++
    id: "marc@example.com",
  },
  {
    // +++
    kind: "group",
    // +++
    id: "engineering",
  },
];
```

### Passing group members on the front-end

The easiest way to create a group mention is to pass a list of group members to
the
[`resolveMentionSuggestions`](/docs/api-reference/liveblocks-react#LiveblocksProviderResolveMentionSuggestions)
function. This allows you to suggest a list of users that are part of the group,
and requires no back-end code, simply return a list of user IDs. In the example
below, a `@everyone` suggestion is added, which will tag all users in the app.

```tsx
resolveMentionSuggestions={async ({ text, roomId }) => {
  const allUserIds = await __getAllUserIds__();
  const queryUserIds = await __queryUserIds__(text);

  // `@everyone`, `@here`, etc.
  // +++
  const globalMentions: MentionData[] = [];
  // +++

  // Create `@everyone` suggestion, for all users in app
  // +++
  globalMentions.push({
    kind: "group",
    id: "everyone",
    userIds: allUserIds, // Array of all user IDs
  });
  // +++

  return [
    // +++
    ...globalMentions,
    // +++
    ...queryUserIds.map((user) => ({
      kind: "user",
      id: user.id,
    })),
  ];
}}
```

In the example above, `@everyone` will _always_ be displayed in the suggestions
list. Make sure to filter using the search text if youâ€™d like to only show it
when the user is typing `"@everyone"`.

```tsx
import type { MentionData } from "@liveblocks/client";

resolveMentionSuggestions={async ({ text, roomId }) => {
  const allUserIds = await __getAllUserIds__();
  const queryUserIds = await __queryUserIds__(text);

  // `@everyone`, `@here`, etc.
  const globalMentions: MentionData[] = [];

  // Show `@everyone` suggestion when users search for it
  // +++
  if ("everyone".includes(text.toLowerCase())) {
  // +++
    globalMentions.push({
      kind: "group",
      id: "everyone",
      userIds: allUserIds, // Array of all user IDs
    });
  // +++
  }
  // +++

  return [
    ...globalMentions,
    ...queryUserIds.map((user) => ({
      kind: "user",
      id: user.id,
    })),
  ];
}}
```

This method is generally most useful for dynamically fetching group mentions,
for example with `@everyone`, `@here`, `@online`, but you can use it to create
fixed group mentions as well.

### Managed groups on the back-end

You can create mention groups on the back-end using the Node.js SDK or REST API,
and theyâ€™ll be saved permanently. You can add new members, create new groups,
list groups, and more. If your app has teams or groups of users, it makes sense
to synchronize them with Liveblocks whenever thereâ€™s a change.

To get started, create a group using
[`liveblocks.createGroup`](/docs/api-reference/liveblocks-node#create-group),
defining each member by their user ID.

```ts
const group = await liveblocks.createGroup({
  groupId: "engineering-team",
  memberIds: ["marc@example.com", "florent@example.com"],
});
```

In your
[`resolveMentionSuggestions`](/docs/api-reference/liveblocks-react#LiveblocksProviderResolveMentionSuggestions)
function, you can then query all the groups youâ€™ve created for the current
search text, and return them.

```tsx
resolveMentionSuggestions={async ({ text, roomId }) => {
  // +++
  const groupIds = await queryGroupIds(text);
  // +++
  const userIds = await __queryUserIds__(text);

  return [
    // +++
    ...groupIds.map((group) => ({
      kind: "group",
      id: group.id,
    })),
    // +++
    ...userIds.map((user) => ({
      kind: "user",
      id: user.id,
    })),
  ];
}}
```

Hereâ€™s how your `queryGroupIds` function can use
[`liveblocks.getGroups`](/docs/api-reference/liveblocks-node#get-groups) to
query all groups and filter them by the search text.

```ts file="queryGroupIds.ts"
"use server";

export async function queryGroupIds(text: string) {
  // +++
  const { data: groups } = await liveblocks.getGroups();
  // +++

  // +++
  return groups
    .filter((group) => group.id.includes(text))
    .map((group) => group.id);
  // +++
}
```

If your app has multi-tenancy, make sure you handle permissions correctly, and
filter out any groups that the user doesnâ€™t have access to.

#### First-party multi-tenancy

Using the Liveblocks [tenants](/docs/authentication/tenants) feature, you can
create groups with the same ID in different tenants. This is an easy way to
compartmentalize resources in your app for each organization. In the snippet
below, both organizations have an engineering team, but because separate tenants
are used, they are different groups.

```ts
const group = await liveblocks.createGroup({
  groupId: "engineering-team",
  memberIds: ["marc@example.com", "florent@example.com"],
  // +++
  tenantId: "apple-corp",
  // +++
});

const group = await liveblocks.createGroup({
  groupId: "engineering-team",
  memberIds: ["chris@example.com", "olivier@example.com"],
  // +++
  tenantId: "banana-inc",
  // +++
});
```

## Adding group information

Similar to when
[displaying user information](/docs/ready-made-features/comments/users-and-mentions#adding-user-information),

You can also add groups to Comments, allowing you to tag a team of people with
one mention. Similar to users, group information is retrieved from a list of
group IDs. You should return the same number of groups as the number of group
IDs, in the same order.

```shell
# If this is `groupIds`
["engineering", "design"]

# Return `groups`
[{ name: "Engineering", avatar: "https://example.com/engineering.png" }, { name: "Design", avatar: "https://example.com/design.png" }]
```

Add a property named
[`resolveGroupsInfo`](/docs/api-reference/liveblocks-react#LiveblocksProviderResolveGroupsInfo)
to your
[`LiveblocksProvider`](/docs/api-reference/liveblocks-react#LiveblocksProvider)
where you can return this information.

```tsx
<LiveblocksProvider
  authEndpoint="/api/liveblocks-auth"
  // +++
  resolveGroupsInfo={async ({ groupIds }) => {
    // ["engineering", ...]
    console.log(groupIds);

    // Get groups from your back-end
    const groups = await __fetchGroups__(groupIds);

    // [{ name: "Engineering", avatar: "https://example.com/engineering.png" }, ...]
    console.log(groups);

    // Return a list of groups
    return groups;
  }}
  // +++
>
```

The `name` and `avatar` are handled by the default components, but you can also
return custom metadata here. For example, each group may have a `color`
property. You can retrieve these properties in your app with
[`useGroupInfo`](/docs/api-reference/liveblocks-react#useGroupInfo).

```tsx
function Component() {
  const { group } = useGroupInfo("engineering");

  // { color: "blue", name: "Engineering", avatar: "https://example.com/engineering.png" }
  console.log(group);

  // ...
}
```

---
meta:
  title: "Multiplayer"
  parentTitle: "Ready-made features"
  description:
    "Add realtime collaboration to any surface in your productâ€”from text editors
    to whiteboards, forms, and beyond."
---

Enable realtime collaboration across any surface in your productâ€”just like in
Figma, Notion, or Linear. With Liveblocks Multiplayer, you can make anything
multiplayer: rich text editors, whiteboards, flowcharts, forms, spreadsheets, or
fully custom interfaces.

Liveblocks provides a permanent, realtime data store for your collaborative
stateâ€”so you donâ€™t need to synchronize, scale, or maintain any infrastructure
yourself. All the hard parts of multiplayerâ€”conflict resolution, presence,
history, and storageâ€”are handled for you.

Depending on what youâ€™re building, you can use purpose-built SDKs for rich text
editors (like Tiptap, Lexical, or BlockNote), or more general packages like
`@liveblocks/client`, `@liveblocks/react`, `@liveblocks/zustand`, or
`@liveblocks/redux`.

## Text editor integrations

<ListGrid columns={2}>
  <DocsCard
    type="technology"
    title="Tiptap"
    href="/docs/ready-made-features/multiplayer/text-editor/tiptap"
    description="Add multiplayer editing to Tiptap"
    visual={<DocsTiptapIcon className="fill-product-icon-brand h-auto w-6" />}
  />
  <DocsCard
    type="technology"
    title="BlockNote"
    href="/docs/ready-made-features/multiplayer/text-editor/blocknote"
    description="Add multiplayer editing to BlockNote"
    visual={
      <DocsBlocknotejsIcon className="fill-product-icon-brand h-auto w-6" />
    }
  />
  <DocsCard
    type="technology"
    title="Lexical"
    href="/docs/ready-made-features/multiplayer/text-editor/lexical"
    description="Add multiplayer editing to Lexical"
    visual={<DocsLexicalIcon className="fill-product-icon-brand h-auto w-6" />}
  />
</ListGrid>

## Sync engine integrations

<ListGrid columns={2}>
  <DocsCard
    type="technology"
    title="Liveblocks Yjs"
    href="/docs/ready-made-features/multiplayer/sync-engine/liveblocks-yjs"
    description="Build custom multiplayer experiences"
    visual={<DocsYjsIcon className="fill-product-icon-brand h-auto w-6" />}
  />
  <DocsCard
    type="technology"
    title="Liveblocks Storage"
    href="/docs/ready-made-features/multiplayer/sync-engine/liveblocks-storage"
    description="Build custom multiplayer experiences"
    visual={<DocsStorageIcon className="fill-product-icon-brand h-auto w-6" />}
  />
</ListGrid>

## Multiplayer API Reference

### Text editor SDKs

Use these SDKs to add multiplayer editing to rich text editors.

<ListGrid columns={2}>
  <DocsCard
    type="technology"
    title="Tiptap React"
    href="/docs/api-reference/liveblocks-react-tiptap"
    description="@liveblocks/react-tiptap"
    visual={<DocsReactIcon />}
  />
  <DocsCard
    type="technology"
    title="BlockNote React"
    href="/docs/api-reference/liveblocks-react-blocknote"
    description="@liveblocks/react-blocknote"
    visual={<DocsReactIcon />}
  />
  <DocsCard
    type="technology"
    title="Lexical React"
    href="/docs/api-reference/liveblocks-react-lexical"
    description="@liveblocks/react-lexical"
    visual={<DocsReactIcon />}
  />
  <DocsCard
    type="technology"
    title="ProseMirror Node"
    href="/docs/api-reference/liveblocks-node-prosemirror"
    description="@liveblocks/node-prosemirror"
    visual={<DocsNodejsIcon className="fill-product-icon-brand h-auto w-6" />}
  />
  <DocsCard
    type="technology"
    title="Lexical Node"
    href="/docs/api-reference/liveblocks-node-lexical"
    description="@liveblocks/node-lexical"
    visual={<DocsNodejsIcon className="fill-product-icon-brand h-auto w-6" />}
  />
</ListGrid>

### Sync engine SDKs

Use these SDKs to add multiplayer editing to whiteboards, forms, tables, or any
custom UI. These SDKs integrate directly with
[Liveblocks Storage](/docs/ready-made-features/multiplayer/sync-engine/liveblocks-storage)
and
[Liveblocks Yjs](/docs/ready-made-features/multiplayer/sync-engine/liveblocks-yjs).

<ListGrid columns={2}>
  <DocsCard
    type="technology"
    title="React"
    href="/docs/api-reference/liveblocks-react"
    description="@liveblocks/react"
    visual={<DocsReactIcon />}
  />
  <DocsCard
    type="technology"
    title="Client"
    href="/docs/api-reference/liveblocks-client"
    description="@liveblocks/client"
    visual={<DocsJavascriptIcon />}
  />
  <DocsCard
    type="technology"
    title="Zustand"
    href="/docs/api-reference/liveblocks-zustand"
    description="@liveblocks/zustand"
    visual={
      <img
        alt=""
        src="/assets/zustand.png"
        width={24}
        height={24}
        loading="lazy"
      />
    }
  />
  <DocsCard
    type="technology"
    title="Redux"
    href="/docs/api-reference/liveblocks-redux"
    description="@liveblocks/redux"
    visual={<DocsReduxIcon />}
  />
</ListGrid>

## Examples using Multiplayer

<ListGrid columns={2}>
  <ExampleCard
    example={{
      title: "Collaborative text editor",
      slug: "collaborative-text-editor/lexical",
      image: "/images/examples/thumbnails/text-editor.jpg",
    }}
    technologies={["nextjs"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Advanced collaborative text editor",
      slug: "collaborative-text-editor-advanced/nextjs-tiptap-advanced",
      image: "/images/examples/thumbnails/text-editor-advanced.jpg",
    }}
    technologies={["nextjs"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Linear-like issue tracker",
      slug: "linear-like-issue-tracker",
      image: "/images/examples/thumbnails/linear-like-issue-tracker.jpg",
    }}
    technologies={["nextjs"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Notion-like AI editor",
      slug: "notion-like-ai-editor",
      image: "/images/examples/thumbnails/notion-like-ai-editor.png",
    }}
    technologies={["nextjs"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Tldraw whiteboard",
      slug: "tldraw-whiteboard",
      image: "/images/examples/thumbnails/tldraw-whiteboard.jpg",
    }}
    technologies={["nextjs"]}
    openInNewWindow
  />
</ListGrid>

---
meta:
  title: "Sync engines"
  parentTitle: "Multiplayer"
  description:
    "Embed a custom collaborative experience into your application using
    Liveblocks Storage and Liveblocks Yjs."
---

Build a custom collaborative experience using Sync Datastore. This can include
anything from whiteboards, flowcharts, spreadsheets, and more. Liveblocks
permanently stores all sync engine data in each
[room](/docs/concepts/how-liveblocks-works#Rooms), handling scaling and
maintenance for you.

## Overview

<ListGrid columns={2}>
  <DocsCard
    type="technology"
    title="Yjs"
    href="/docs/ready-made-features/multiplayer-editing/sync-engine/liveblocks-yjs"
    description="Sync engine optimized for text editors"
    visual={<DocsYjsIcon className="fill-product-icon-brand h-auto w-6" />}
  />
  <DocsCard
    type="technology"
    title="Storage"
    href="/docs/ready-made-features/multiplayer-editing/sync-engine/liveblocks-storage"
    description="Sync engine optimized for creative tools"
    visual={<DocsStorageIcon className="fill-product-icon-brand h-auto w-6" />}
  />
</ListGrid>

## Examples using Sync Datastore

<ListGrid columns={2}>
  <ExampleCard
    example={{
      title: "Tldraw whiteboard",
      slug: "tldraw-whiteboard",
      image: "/images/examples/thumbnails/tldraw-whiteboard.jpg",
    }}
    technologies={["nextjs"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Collaborative Whiteboard",
      slug: "collaborative-whiteboard-advanced",
      image:
        "/images/examples/thumbnails/collaborative-whiteboard-advanced.jpg",
      advanced: true,
    }}
    technologies={["nextjs"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Collaborative Flowchart",
      slug: "collaborative-flowchart/zustand-flowchart",
      image: "/images/examples/thumbnails/collaborative-flowchart.jpg",
      advanced: true,
    }}
    technologies={["zustand"]}
    openInNewWindow
  />
</ListGrid>

---
meta:
  title: "Liveblocks Storage"
  parentTitle: "Sync engine"
  description:
    "Liveblocks Storage is a realtime sync engine designed for multiplayer
    creative tools such as Figma, Pitch, and Spline."
---

Liveblocks Storage is a realtime sync engine designed for multiplayer creative
tools such as Figma, Pitch, and Spline. `LiveList`, `LiveMap`, and `LiveObject`
conflict-free data types can be used to build all sorts of multiplayer tools.
Liveblocks permanently stores Storage data in each
[room](/docs/concepts/how-liveblocks-works#Rooms), handling scaling and
maintenance for you.

## API Reference

### Presence

<ListGrid columns={2}>
  <DocsCard
    type="technology"
    title="JavaScript"
    href="/docs/api-reference/liveblocks-client#Room.getPresence"
    description="@liveblocks/client"
    visual={<DocsJavascriptIcon />}
  />
  <DocsCard
    type="technology"
    title="React"
    href="/docs/api-reference/liveblocks-react#Presence"
    description="@liveblocks/react"
    visual={<DocsReactIcon />}
  />
  <DocsCard
    type="technology"
    title="Redux"
    href="/docs/api-reference/liveblocks-redux#enhancer-option-presence-mapping"
    description="@liveblocks/redux"
    visual={<DocsReduxIcon />}
  />
  <DocsCard
    type="technology"
    title="Zustand"
    href="/docs/api-reference/liveblocks-zustand#middleware-option-presence-mapping"
    description="@liveblocks/zustand"
    visual={
      <img
        alt=""
        src="/assets/zustand.png"
        width={24}
        height={24}
        loading="lazy"
      />
    }
  />
</ListGrid>

### Broadcast

<ListGrid columns={2}>
  <DocsCard
    type="technology"
    title="JavaScript"
    href="/docs/api-reference/liveblocks-client#Room.broadcastEvent"
    description="@liveblocks/client"
    visual={<DocsJavascriptIcon />}
  />
  <DocsCard
    type="technology"
    title="React"
    href="/docs/api-reference/liveblocks-react#Broadcast"
    description="@liveblocks/react"
    visual={<DocsReactIcon />}
  />
  <DocsCard
    type="technology"
    title="Node.js"
    href="/docs/api-reference/liveblocks-node#post-broadcast-event"
    description="@liveblocks/node"
    visual={<DocsNodejsIcon className="fill-product-icon-brand h-auto w-6" />}
  />
  <DocsCard
    type="technology"
    title="REST API"
    href="/docs/api-reference/rest-api-endpoints#post-broadcast-event"
    description="HTTP endpoints"
    visual={<DocsApiIcon className="fill-product-icon-brand h-auto w-6" />}
  />
</ListGrid>

### Storage

<ListGrid columns={2}>
  <DocsCard
    type="technology"
    title="JavaScript"
    href="/docs/api-reference/liveblocks-client#Storage"
    description="@liveblocks/client"
    visual={<DocsJavascriptIcon />}
  />
  <DocsCard
    type="technology"
    title="React"
    href="/docs/api-reference/liveblocks-react#Storage"
    description="@liveblocks/react"
    visual={<DocsReactIcon />}
  />
  <DocsCard
    type="technology"
    title="Redux"
    href="/docs/api-reference/liveblocks-redux#enhancer-option-storage-mapping"
    description="@liveblocks/redux"
    visual={<DocsReduxIcon />}
  />
  <DocsCard
    type="technology"
    title="Zustand"
    href="/docs/api-reference/liveblocks-zustand#middleware-option-storage-mapping"
    description="@liveblocks/zustand"
    visual={
      <img
        alt=""
        src="/assets/zustand.png"
        width={24}
        height={24}
        loading="lazy"
      />
    }
  />
  <DocsCard
    type="technology"
    title="Node.js"
    href="/docs/api-reference/liveblocks-node#Storage"
    description="@liveblocks/node"
    visual={<DocsNodejsIcon className="fill-product-icon-brand h-auto w-6" />}
  />
  <DocsCard
    type="technology"
    title="REST API"
    href="/docs/api-reference/rest-api-endpoints#Storage"
    description="HTTP endpoints"
    visual={<DocsApiIcon className="fill-product-icon-brand h-auto w-6" />}
  />
</ListGrid>

## Examples using Liveblocks Storage

<ListGrid columns={2}>
  <ExampleCard
    example={{
      title: "Live Cursors Chat",
      slug: "live-cursors-chat",
      image: "/images/examples/thumbnails/live-cursors-chat.jpg",
    }}
    technologies={["nextjs"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Collaborative Todo List",
      slug: "collaborative-todo-list",
      image: "/images/examples/thumbnails/collaborative-todo-list.jpg",
    }}
    technologies={["nextjs", "redux", "zustand", "javascript", "react-native"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Collaborative Spreadsheet",
      slug: "collaborative-spreadsheet-advanced",
      image:
        "/images/examples/thumbnails/collaborative-spreadsheet-advanced.jpg",
      advanced: true,
    }}
    technologies={["nextjs"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Collaborative Whiteboard",
      slug: "collaborative-whiteboard-advanced",
      image:
        "/images/examples/thumbnails/collaborative-whiteboard-advanced.jpg",
      advanced: true,
    }}
    technologies={["nextjs"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Collaborative Flowchart",
      slug: "collaborative-flowchart/zustand-flowchart",
      image: "/images/examples/thumbnails/collaborative-flowchart.jpg",
      advanced: true,
    }}
    technologies={["zustand"]}
    openInNewWindow
  />
</ListGrid>

---
meta:
  title: "Liveblocks Yjs"
  parentTitle: "Sync engine"
  description:
    "Liveblocks Yjs is a realtime sync engine designed for collaborative text
    editors such as Notion and Google Docs."
---

Liveblocks Yjs is a realtime sync engine designed for building collaborative
text editors such as Notion and Google Docs. Liveblocks permanently stores Yjs
data in each [room](/docs/concepts/how-liveblocks-works#Rooms), handling scaling
and maintenance for you.

## Text editor integrations vs sync engines

If youâ€™re using Tiptap, BlockNote, or Lexical, we recommend using
[Text Editor](/docs/ready-made-features/multiplayer-editing/text-editor)
instead. This is an alternative to Sync Datastore, with extra features
specifically created for those editors. Sync Datastore, powered by Liveblocks
Yjs and Liveblocks Storage, is intended for use in other editors, or for
completely custom solutions.

## API Reference

<ListGrid columns={2}>
  <DocsCard
    type="technology"
    title="Yjs"
    href="/docs/api-reference/liveblocks-yjs"
    description="@liveblocks/yjs"
    visual={<DocsYjsIcon className="fill-product-icon-brand h-auto w-6" />}
  />
  <DocsCard
    type="technology"
    title="Node.js"
    href="/docs/api-reference/liveblocks-node#Yjs"
    description="@liveblocks/node"
    visual={<DocsNodejsIcon className="fill-product-icon-brand h-auto w-6" />}
  />
  <DocsCard
    type="technology"
    title="REST API"
    href="/docs/api-reference/rest-api-endpoints#Yjs"
    description="HTTP endpoints"
    visual={<DocsApiIcon className="fill-product-icon-brand h-auto w-6" />}
  />
</ListGrid>

## Examples using Liveblocks Yjs

<ListGrid columns={2}>
  <ExampleCard
    example={{
      title: "Collaborative Text Editor (Slate)",
      slug: "collaborative-text-editor/nextjs-yjs-slate",
      image: "/images/examples/thumbnails/text-editor.jpg",
    }}
    technologies={["nextjs"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Collaborative Text Editor (Quill)",
      slug: "collaborative-text-editor/nextjs-yjs-quill",
      image: "/images/examples/thumbnails/text-editor.jpg",
    }}
    technologies={["nextjs"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Collaborative Code Editor",
      slug: "collaborative-code-editor",
      image: "/images/examples/thumbnails/code-editor.jpg",
      advanced: true,
    }}
    technologies={["nextjs"]}
    openInNewWindow
  />
</ListGrid>

---
meta:
  title: "Text editor"
  parentTitle: "Multiplayer"
  description:
    "Transform your existing text editor into a collaborative one with realtime
    synchronization using our ready-made integrations."
---

Transform your existing text editor into a collaborative one that feels like
Google Docs or Notion. Our ready-made integrations with Tiptap, Blocknote, and
Lexical handle all the realtime synchronization and storage for you, so you can
focus on building your application.

## Features

Our text editor integrations go beyond multiplayer editing to provide a complete
collaborative experience:

- **Inline comments & annotations**: Let users highlight text and leave
  comments, creating discussion threads right in the document.
- **Mentions and notifications**: Tag team members to notify them about
  important changes or discussions.
- **Version history**: Track changes over time and restore previous versions
  when needed.
- **Multiplayer undo/redo**: Each user has their own undo stack, preventing
  conflicts when multiple people edit simultaneously.
- **AI capabilities** (Tiptap only): Enhance your editor with AI-powered
  features through our built-in AI toolbar.

## Overview

<ListGrid columns={2}>
  <DocsCard
    type="technology"
    title="Tiptap"
    href="/docs/ready-made-features/multiplayer-editing/text-editor/tiptap"
    description="Add collaboration to your Tiptap editor"
    visual={<DocsTiptapIcon className="fill-product-icon-brand h-auto w-6" />}
  />
  <DocsCard
    type="technology"
    title="Blocknote"
    href="/docs/ready-made-features/multiplayer-editing/text-editor/blocknote"
    description="Add collaboration to your Blocknote editor"
    visual={
      <DocsBlocknotejsIcon className="fill-product-icon-brand h-auto w-6" />
    }
  />
  <DocsCard
    type="technology"
    title="Lexical"
    href="/docs/ready-made-features/multiplayer-editing/text-editor/lexical"
    description="Add collaboration to your Lexical editor"
    visual={<DocsLexicalIcon className="fill-product-icon-brand h-auto w-6" />}
  />
</ListGrid>

## Examples using text editor integrations

<ListGrid columns={2}>
  <ExampleCard
    example={{
      title: "Collaborative text editor",
      slug: "collaborative-text-editor/lexical",
      image: "/images/examples/thumbnails/text-editor.jpg",
    }}
    technologies={["nextjs"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Advanced collaborative text editor",
      slug: "collaborative-text-editor-advanced/nextjs-tiptap-advanced",
      image: "/images/examples/thumbnails/text-editor-advanced.jpg",
    }}
    technologies={["nextjs"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Linear-like issue tracker",
      slug: "linear-like-issue-tracker",
      image: "/images/examples/thumbnails/linear-like-issue-tracker.jpg",
    }}
    technologies={["nextjs"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Notion-like AI editor",
      slug: "notion-like-ai-editor",
      image: "/images/examples/thumbnails/notion-like-ai-editor.png",
    }}
    technologies={["nextjs"]}
    openInNewWindow
  />
</ListGrid>

---
meta:
  title: "BlockNote"
  parentTitle: "Text editor"
  description: "Learn about using Multiplayer for BlockNote"
---

A quick overview of the packages for BlockNote.

## Concepts

Liveblocks BlockNote allows you add collaboration to any
[BlockNote](https://blocknotejs.org/) text editor, along with a number of
related features. Each
[collaborative room](/docs/concepts/how-liveblocks-works#Rooms) in your
application can store one document each, and these documents are persisted on
the cloud, visible on [your dashboard](/dashboard), and are integrated into
other Liveblocks products such as [Comments](/docs/ready-made-features/comments)
and [Notifications](/docs/ready-made-features/notifications).

### Permanent storage

All documents created with BlockNote are **permanently stored**. You donâ€™t need
to sync, scale, or maintain any infrastructure.

### Users and mentions

Users and groups can be added to your document, and you can tag others inline.
You can also easily enable mention suggestions for both users and groups.

<Figure>
  <Image
    src="/assets/text-editor/mentions.png"
    alt="User mentions"
    width={1312}
    height={874}
  />
</Figure>

Users, groups, and mention suggestions can be added with
[`resolveUsers`](/docs/api-reference/liveblocks-react#LiveblocksProviderResolveUsers),
[`resolveGroupsInfo`](/docs/api-reference/liveblocks-react#LiveblocksProviderResolveGroupsInfo),
and
[`resolveMentionSuggestions`](/docs/api-reference/liveblocks-react#LiveblocksProviderResolveMentionSuggestions).

```tsx highlight="6-16"
import { LiveblocksProvider } from "@liveblocks/react/suspense";

function App() {
  return (
    <LiveblocksProvider
      resolveUsers={async ({ userIds }) => {
        // Return user info from their `userIds`
        // ...
      }}
      resolveGroupsInfo={async ({ groupIds }) => {
        // Return group info from their `groupIds`
        // ...
      }}
      resolveMentionSuggestions={async ({ text, roomId }) => {
        // Return suggestions from the search `text`
        // Can return user IDs or mention objects for both users and groups
        // ...
      }}
    >
      {/* children */}
    </LiveblocksProvider>
  );
}
```

### Realtime editing

Your document can be edited in real-time by multiple users at once. Each user
renders a cursor on screen that updates live as they move, select, and edit.

<Figure>
  <Image
    src="/assets/text-editor/cursors.png"
    alt="Real-time text cursors"
    width={1312}
    height={874}
  />
</Figure>

When [authenticating your users](/docs/authentication) with
[`prepareSession`](/docs/api-reference/liveblocks-node#access-tokens) or
[`identifyUser`](/docs/api-reference/liveblocks-node#id-tokens), pass `name` and
`color` properties to their `userInfo` to add their cursor information.

```js
userInfo: {
  name: "Marie",
  color: "#00ff00",
}
```

### Annotations and comments

Add [Comments](/docs/ready-made-features/comments) to your text editor, allowing
others to select words in the editor, and leave annotations. Each annotation
creates a [thread](/docs/ready-made-features/comments/concepts#Threads), and
inside each you can reply, use emoji reactions, mention others, and more.

<Figure>
  <Image
    src="/assets/text-editor/annotations.png"
    alt="Text editor annotations"
    width={1312}
    height={874}
  />
</Figure>

Add a floating Comments composer to your text editor using
[`FloatingComposer`](/docs/api-reference/liveblocks-react-blocknote#FloatingComposer).

```tsx
<FloatingComposer editor={editor} />
```

Add [`useThreads`](/docs/ready-made-features/comments/hooks#threads-hook)
alongside
[`FloatingThreads`](/docs/api-reference/liveblocks-react-blocknote#FloatingThreads)
and
[`AnchoredThreads`](/docs/api-reference/liveblocks-react-blocknote#AnchoredThreads)
to render your comments to the page.

```tsx
export function Threads({ editor }) {
  const { threads } = useThreads();

  return (
    <>
      <AnchoredThreads editor={editor} threads={threads} />
      <FloatingThreads editor={editor} threads={threads} />
    </>
  );
}
```

`FloatingThreads` displays floating threads below text highlights in the editor,
ideal for mobile, whereas `AnchoredThreads` displays threads vertically
alongside the editor which is great on desktop. To create a new thread use the
button in the BlockNote toolbar, or
[build a button yourself](/docs/api-reference/liveblocks-react-blocknote#Opening-the-composer).

### Notifications

Add a [Notifications](/docs/ready-made-features/notifications) UI to your
application, and automatically notify users when theyâ€™ve been mentioned.
Notifications also allows you to trigger sending emails, Slack, or any other
kind of notification, using our webhooks.

<Figure>
  <Image
    src="/assets/text-editor/notifications.png"
    alt="Text editor notifications"
    width={1312}
    height={874}
  />
</Figure>

Notifications is enabled by default, which means you just need to add our UI
components to keep your users notified. Follow our
[get started guides](/docs/get-started/notifications) to learn how to set up
[`InboxNotification`](/docs/api-reference/liveblocks-react-ui#InboxNotification).

```tsx
export function CollaborativeApp() {
  const { inboxNotifications } = useInboxNotifications();

  return (
    <InboxNotificationList>
      {inboxNotifications.map((inboxNotification) => (
        <InboxNotification
          key={inboxNotification.id}
          inboxNotification={inboxNotification}
        />
      ))}
    </InboxNotificationList>
  );
}
```

Inline mentions also trigger
[`TextMention`](/docs/platform/webhooks#TextMention-notification) notification
webhook events. Learn more about
[sending email notifications](/docs/ready-made-features/notifications/email-notifications).

### Multiple editors

Itâ€™s possible to use multiple BlockNote editors on a single page, and each
editor having its own collaboration and extensions. You can enable this by
giving each editor a unique `field` value.

```tsx
import { useCreateBlockNoteWithLiveblocks } from "@liveblocks/react-blocknote";

function TextEditor() {
  const editor = useCreateBlockNoteWithLiveblocks(
    {},
    {
      field: "editor-one",
    }
  );

  // ...
}
```

Learn more about
[using multiple editors](/docs/api-reference/liveblocks-react-blocknote#Multiple-editors).

### Offline support

Liveblocks BlockNote has an experimental option that enables offline support.
Offline support means that once a document has been opened, itâ€™s saved locally
on the browser, and can be shown instantly without a loading screen. Enable this
by passing a `offlineSupport_experimental` value.

```tsx
import { useCreateBlockNoteWithLiveblocks } from "@liveblocks/react-blocknote";

function TextEditor() {
  const editor = useCreateBlockNoteWithLiveblocks(
    {},
    {
      offlineSupport_experimental: true,
    }
  );

  // ...
}
```

Learn more about
[offline support](/docs/api-reference/liveblocks-react-blocknote#Offline-support).

### Version History

Liveblocks BlockNote enables version history for your document. Versions can be
automatically created when enabled in your project settings, or manually created
using the
[REST API](/docs/api-reference/rest-api-endpoints#post-rooms-roomId-version).
These versions can be easily displayed to users using a few simple components.
This allows for a comprehensive version history feature in your collaborative
text editor.

To implement version history in your application, you can use the
`useHistoryVersions` hook along with the `HistoryVersionsList` and
`HistoryVersionPreview` components. Here's an example of how to set this up:

```tsx
import {
  useHistoryVersions,
  HistoryVersionSummaryList,
} from "@liveblocks/react";
import { HistoryVersionPreview } from "@liveblocks/react-blocknote";

function DocumentHistory() {
  const [selectedVersionId, setSelectedVersionId] = useState<string>();
  const { versions, isLoading } = useHistoryVersions();
  const selectedVersion = useMemo(
    () => versions?.find((version) => version.id === selectedVersionId),
    [selectedVersionId, versions]
  );

  if (isLoading) {
    return <div>Loading version history...</div>;
  }

  return (
    <>
      <div>
        {selectedVersion ? (
          <HistoryVersionPreview
            version={selectedVersion}
            className="h-full w-full"
            onVersionRestore={onVersionRestore}
          />
        ) : (
          <div>No version selected</div>
        )}
      </div>

      <div>
        <HistoryVersionSummaryList>
          {versions?.map((version) => (
            <HistoryVersionSummary
              onClick={() => {
                setSelectedVersionId(version.id);
              }}
              key={version.id}
              version={version}
              selected={version.id === selectedVersionId}
            />
          ))}
        </HistoryVersionSummaryList>
      </div>
    </>
  );
}
```

In this example, `useHistoryVersions` fetches the version history,
`HistoryVersionSummaryList` displays a list of available versions, and
`HistoryVersionPreview` shows a preview of the selected version. This setup
provides users with an interface to browse through the document's history and
restore different versions.

## BlockNote API Reference

<ListGrid columns={2}>
  <DocsCard
    type="technology"
    title="BlockNote React"
    href="/docs/api-reference/liveblocks-react-blocknote"
    description="@liveblocks/react-blocknote"
    visual={<DocsReactIcon />}
  />
  <DocsCard
    type="technology"
    title="BlockNote/ProseMirror Node"
    href="/docs/api-reference/liveblocks-node-prosemirror"
    description="@liveblocks/node-prosemirror"
    visual={<DocsApiIcon />}
  />
</ListGrid>

---
meta:
  title: "Lexical"
  parentTitle: "Text editor"
  description: "Learn about using Multiplayer for Lexical"
---

A quick overview of the packages for Lexical.

## Concepts

Liveblocks Lexical allows you to add collaboration to any
[Lexical](https://lexical.dev/) text editor, along with a number of related
features. Each [collaborative room](/docs/concepts/how-liveblocks-works#Rooms)
in your application can store one document each, and these documents are
persisted on the cloud, visible on [your dashboard](/dashboard), and are
integrated into other Liveblocks products such as
[Comments](/docs/ready-made-features/comments) and
[Notifications](/docs/ready-made-features/notifications).

### Permanent storage

All documents created with Lexical are **permanently stored**. You donâ€™t need to
sync, scale, or maintain any infrastructure.

### Users and mentions

Users and groups can be added to your document, and you can tag others inline.
You can also easily enable mention suggestions for both users and groups.

<Figure>
  <Image
    src="/assets/text-editor/mentions.png"
    alt="User mentions"
    width={1312}
    height={874}
  />
</Figure>

Users, groups, and mention suggestions can be added with
[`resolveUsers`](/docs/api-reference/liveblocks-react#LiveblocksProviderResolveUsers),
[`resolveGroupsInfo`](/docs/api-reference/liveblocks-react#LiveblocksProviderResolveGroupsInfo),
and
[`resolveMentionSuggestions`](/docs/api-reference/liveblocks-react#LiveblocksProviderResolveMentionSuggestions).

```tsx highlight="6-16"
import { LiveblocksProvider } from "@liveblocks/react/suspense";

function App() {
  return (
    <LiveblocksProvider
      resolveUsers={async ({ userIds }) => {
        // Return user info from their `userIds`
        // ...
      }}
      resolveGroupsInfo={async ({ groupIds }) => {
        // Return group info from their `groupIds`
        // ...
      }}
      resolveMentionSuggestions={async ({ text, roomId }) => {
        // Return suggestions from the search `text`
        // Can return user IDs or mention objects for both users and groups
        // ...
      }}
    >
      {/* children */}
    </LiveblocksProvider>
  );
}
```

### Realtime editing

Your document can be edited in real-time by multiple users at once. Each user
renders a cursor on screen that updates live as they move, select, and edit.

<Figure>
  <Image
    src="/assets/text-editor/cursors.png"
    alt="Real-time text cursors"
    width={1312}
    height={874}
  />
</Figure>

When [authenticating your users](/docs/authentication) with
[`prepareSession`](/docs/api-reference/liveblocks-node#access-tokens) or
[`identifyUser`](/docs/api-reference/liveblocks-node#id-tokens), pass `name` and
`color` properties to their `userInfo` to add their cursor information.

```js
userInfo: {
  name: "Marie",
  color: "#00ff00",
}
```

### Toolbars

Two toolbars are available allowing you to create a
[static toolbar](/docs/api-reference/liveblocks-react-lexical#Toolbar), or a
[floating toolbar](/docs/api-reference/liveblocks-react-lexical#FloatingToolbar),
as seen below.

<Figure>
  <Image
    src="/assets/text-editor/floating-toolbar.png"
    alt="FloatingToolbar"
    width={960}
    height={558}
  />
</Figure>

Add [`Toolbar`](/docs/api-reference/liveblocks-react-lexical#Toolbar) and
[`FloatingToolbar`](/docs/api-reference/liveblocks-react-lexical#FloatingToolbar)
to enable these features.

```tsx
<LexicalComposer initialConfig={initialConfig}>
  <LiveblocksPlugin>
    <Toolbar />
  </LiveblocksPlugin>
</LexicalComposer>
```

Itâ€™s easy to
[customize a toolbarâ€™s content](/docs/api-reference/liveblocks-react-lexical#toolbar-extending-the-defaults),
piecing together sections like blocks.

```tsx
function CustomToolbar() {
  return (
    <Toolbar>
      // +++
      <Toolbar.BlockSelector />
      <Toolbar.SectionInline />
      <Toolbar.Separator />
      <Toolbar.SectionCollaboration />
      // +++
    </Toolbar>
  );
}
```

You can also easily create
[custom styled buttons](/docs/api-reference/liveblocks-react-lexical#Toolbar.Button),
and
[more](/docs/api-reference/liveblocks-react-lexical#creating-a-custom-toolbar),
with any functionality you like.

```tsx
function CustomButton() {
  return (
    // +++
    <Toolbar.Button
      name="Help"
      icon={<Icon.QuestionMark />}
      shortcut="CMD-H"
      onClick={() => console.log("help")}
    />
    // +++
  );
}
```

### Annotation comments

Add [Comments](/docs/ready-made-features/comments) to your text editor, allowing
others to select words in the editor, and leave annotations. Each annotation
creates a [thread](/docs/ready-made-features/comments/concepts#Threads), and
inside each you can reply, use emoji reactions, mention others, and more.

<Figure>
  <Image
    src="/assets/text-editor/annotations.png"
    alt="Text editor annotations"
    width={1312}
    height={874}
  />
</Figure>

Add a floating Comments composer to your text editor using
[`FloatingComposer`](/docs/api-reference/liveblocks-react-lexical#FloatingComposer).

```tsx highlight="3"
<LexicalComposer initialConfig={initialConfig}>
  <LiveblocksPlugin>
    <FloatingComposer />
  </LiveblocksPlugin>
</LexicalComposer>
```

Add [`useThreads`](/docs/ready-made-features/comments/hooks#threads-hook)
alongside
[`FloatingThreads`](/docs/api-reference/liveblocks-react-lexical#FloatingThreads)
and
[`AnchoredThreads`](/docs/api-reference/liveblocks-react-lexical#AnchoredThreads)
to render your comments to the page.

```tsx
export function Threads({ editor }) {
  const { threads } = useThreads();

  return (
    <>
      <AnchoredThreads threads={threads} />
      <FloatingThreads threads={threads} />
    </>
  );
}
```

`FloatingThreads` displays floating threads below text highlights in the editor,
ideal for mobile, whereas `AnchoredThreads` displays threads vertically
alongside the editor which is great on desktop. To create a new thread use the
button in a [pre-built toolbar](#Toolbars), or
[build a button yourself](/docs/api-reference/liveblocks-react-lexical#Opening-the-FloatingComposer).

### Notifications

Add a [Notifications](/docs/ready-made-features/notifications) UI to your
application, and automatically notify users when theyâ€™ve been mentioned.
Notifications also allows you to trigger sending emails, Slack, or any other
kind of notification, using our webhooks.

<Figure>
  <Image
    src="/assets/text-editor/notifications.png"
    alt="Text editor notifications"
    width={1312}
    height={874}
  />
</Figure>

Notifications is enabled by default, which means you just need to add our UI
components to keep your users notified. Follow our
[get started guides](/docs/get-started/notifications) to learn how to set up
[`InboxNotification`](/docs/api-reference/liveblocks-react-ui#InboxNotification).

```tsx
export function CollaborativeApp() {
  const { inboxNotifications } = useInboxNotifications();

  return (
    <InboxNotificationList>
      {inboxNotifications.map((inboxNotification) => (
        <InboxNotification
          key={inboxNotification.id}
          inboxNotification={inboxNotification}
        />
      ))}
    </InboxNotificationList>
  );
}
```

Inline mentions also trigger
[`TextMention`](/docs/platform/webhooks#TextMention-notification) notification
webhook events. Learn more about
[sending email notifications](/docs/ready-made-features/notifications/email-notifications).

### AI agents and editing on the server

Fetch and modify your text editorâ€™s content from the server, enabling features
such as AI agents. Easily make changes that update in real-time for every
connected user.

<Figure>
  <Image
    src="/assets/text-editor/ai.png"
    alt="AI suggestions"
    width={1312}
    height={874}
  />
</Figure>

Use
[`withLexicalDocument`](/docs/api-reference/liveblocks-node-lexical#withLexicalDocument)
to get your editorâ€™s content and make modifications live.

```tsx
await withLexicalDocument(
  { roomId: "my-room-id", client: liveblocks },
  async (doc) => {
    // Get editor content
    const textContent = doc.getTextContent();

    await doc.update(async () => {
      // Make real-time updates
      // ...
    });
  }
);
```

### Version History

Liveblocks Lexical enables version history for your document. Versions can be
automatically created when enabled in your project settings, or manually created
using the
[REST API](/docs/api-reference/rest-api-endpoints#post-rooms-roomId-version).
These versions can be easily displayed to users using a few simple components.
This allows for a comprehensive version history feature in your collaborative
text editor.

To implement version history in your application, you can use the
`useHistoryVersions` hook along with the `HistoryVersionsList` and
`HistoryVersionPreview` components. Here's an example of how to set this up:

```tsx
import {
  useHistoryVersions,
  HistoryVersionSummaryList,
} from "@liveblocks/react";
import { HistoryVersionPreview } from "@liveblocks/react-lexical";

function DocumentHistory() {
  const [selectedVersionId, setSelectedVersionId] = useState<string>();
  const { versions, isLoading } = useHistoryVersions();
  const selectedVersion = useMemo(
    () => versions?.find((version) => version.id === selectedVersionId),
    [selectedVersionId, versions]
  );

  if (isLoading) {
    return <div>Loading version history...</div>;
  }

  return (
    <>
      <div>
        {selectedVersion ? (
          <HistoryVersionPreview
            version={selectedVersion}
            className="h-full w-full"
            onVersionRestore={onVersionRestore}
          />
        ) : (
          <div>No version selected</div>
        )}
      </div>

      <div>
        <HistoryVersionSummaryList>
          {versions?.map((version) => (
            <HistoryVersionSummary
              onClick={() => {
                setSelectedVersionId(version.id);
              }}
              key={version.id}
              version={version}
              selected={version.id === selectedVersionId}
            />
          ))}
        </HistoryVersionSummaryList>
      </div>
    </>
  );
}
```

In this example, `useHistoryVersions` fetches the version history,
`HistoryVersionSummaryList` displays a list of available versions, and
`HistoryVersionPreview` shows a preview of the selected version. This setup
provides users with an interface to browse through the document's history and
restore different versions.

## Lexical API Reference

<ListGrid columns={2}>
  <DocsCard
    type="technology"
    title="Lexical React"
    href="/docs/api-reference/liveblocks-react-lexical"
    description="@liveblocks/react-lexical"
    visual={<DocsReactIcon />}
  />
  <DocsCard
    type="technology"
    title="Lexical Node"
    href="/docs/api-reference/liveblocks-node-lexical"
    description="@liveblocks/node-lexical"
    visual={<DocsApiIcon />}
  />
</ListGrid>

---
meta:
  title: "Tiptap"
  parentTitle: "Text editor"
  description: "Learn about using Multiplayer for Tiptap"
---

A quick overview of the packages for Tiptap.

## Concepts

Liveblocks Tiptap allows you to add collaboration to any
[Tiptap](https://tiptap.dev/) text editor, along with a number of related
features. Each [collaborative room](/docs/concepts/how-liveblocks-works#Rooms)
in your application can store one document each, and these documents are
persisted on the cloud, visible on [your dashboard](/dashboard), and are
integrated into other Liveblocks products such as
[Comments](/docs/ready-made-features/comments) and
[Notifications](/docs/ready-made-features/notifications).

### Permanent storage

All documents created with Tiptap are **permanently stored**. You donâ€™t need to
sync, scale, or maintain any infrastructure.

### Users and mentions

Users and groups can be added to your document, and you can tag others inline.
You can also easily enable mention suggestions for both users and groups.

<Figure>
  <Image
    src="/assets/text-editor/mentions.png"
    alt="User mentions"
    width={1312}
    height={874}
  />
</Figure>

Users, groups, and mention suggestions can be added with
[`resolveUsers`](/docs/api-reference/liveblocks-react#LiveblocksProviderResolveUsers),
[`resolveGroupsInfo`](/docs/api-reference/liveblocks-react#LiveblocksProviderResolveGroupsInfo),
and
[`resolveMentionSuggestions`](/docs/api-reference/liveblocks-react#LiveblocksProviderResolveMentionSuggestions).

```tsx highlight="6-16"
import { LiveblocksProvider } from "@liveblocks/react/suspense";

function App() {
  return (
    <LiveblocksProvider
      resolveUsers={async ({ userIds }) => {
        // Return user info from their `userIds`
        // ...
      }}
      resolveGroupsInfo={async ({ groupIds }) => {
        // Return group info from their `groupIds`
        // ...
      }}
      resolveMentionSuggestions={async ({ text, roomId }) => {
        // Return suggestions from the search `text`
        // Can return user IDs or mention objects for both users and groups
        // ...
      }}
    >
      {/* children */}
    </LiveblocksProvider>
  );
}
```

### Realtime editing

Your document can be edited in real-time by multiple users at once. Each user
renders a cursor on screen that updates live as they move, select, and edit.

<Figure>
  <Image
    src="/assets/text-editor/cursors.png"
    alt="Real-time text cursors"
    width={1312}
    height={874}
  />
</Figure>

When [authenticating your users](/docs/authentication) with
[`prepareSession`](/docs/api-reference/liveblocks-node#access-tokens) or
[`identifyUser`](/docs/api-reference/liveblocks-node#id-tokens), pass `name` and
`color` properties to their `userInfo` to add their cursor information.

```js
userInfo: {
  name: "Marie",
  color: "#00ff00",
}
```

## Toolbars

Two toolbars are available allowing you to create a
[static toolbar](/docs/api-reference/liveblocks-react-tiptap#Toolbar), or a
[floating toolbar](/docs/api-reference/liveblocks-react-tiptap#FloatingToolbar),
as seen below.

<Figure>
  <Image
    src="/assets/text-editor/floating-toolbar.png"
    alt="FloatingToolbar"
    width={960}
    height={558}
  />
</Figure>

Add [`Toolbar`](/docs/api-reference/liveblocks-react-tiptap#Toolbar) and
[`FloatingToolbar`](/docs/api-reference/liveblocks-react-tiptap#FloatingToolbar)
to enable these features.

```tsx
<Toolbar editor={editor} />
```

Itâ€™s easy to
[customize a toolbarâ€™s content](/docs/api-reference/liveblocks-react-tiptap#toolbar-extending-the-defaults),
piecing together sections like blocks.

```tsx
function CustomToolbar({ editor }: { editor: Editor | null }) {
  return (
    <Toolbar editor={editor}>
      // +++
      <Toolbar.BlockSelector />
      <Toolbar.SectionInline />
      <Toolbar.Separator />
      <Toolbar.SectionCollaboration />
      // +++
    </Toolbar>
  );
}
```

You can also easily create
[custom styled buttons](/docs/api-reference/liveblocks-react-tiptap#Toolbar.Button),
and
[more](/docs/api-reference/liveblocks-react-tiptap#creating-a-custom-toolbar),
with any functionality you like.

```tsx
function CustomButton() {
  return (
    // +++
    <Toolbar.Button
      name="Help"
      icon={<Icon.QuestionMark />}
      shortcut="CMD-H"
      onClick={() => console.log("help")}
    />
    // +++
  );
}
```

### AI features

Weâ€™re working on AI features for Tiptap, such as a floating AI toolbar. To get
involved, [request access to AI Copilots](/ai-copilots).

<Figure>
  <Image
    src="/assets/text-editor/ai.png"
    alt="AI suggestions"
    width={1312}
    height={874}
  />
</Figure>

### Annotations and comments

Add [Comments](/docs/ready-made-features/comments) to your text editor, allowing
others to select words in the editor, and leave annotations. Each annotation
creates a [thread](/docs/ready-made-features/comments/concepts#Threads), and
inside each you can reply, use emoji reactions, mention others, and more.

<Figure>
  <Image
    src="/assets/text-editor/annotations.png"
    alt="Text editor annotations"
    width={1312}
    height={874}
  />
</Figure>

Add a floating Comments composer to your text editor using
[`FloatingComposer`](/docs/api-reference/liveblocks-react-tiptap#FloatingComposer).

```tsx
<FloatingComposer editor={editor} />
```

Add [`useThreads`](/docs/ready-made-features/comments/hooks#threads-hook)
alongside
[`FloatingThreads`](/docs/api-reference/liveblocks-react-tiptap#FloatingThreads)
and
[`AnchoredThreads`](/docs/api-reference/liveblocks-react-tiptap#AnchoredThreads)
to render your comments to the page.

```tsx
export function Threads({ editor }) {
  const { threads } = useThreads();

  return (
    <>
      <AnchoredThreads editor={editor} threads={threads} />
      <FloatingThreads editor={editor} threads={threads} />
    </>
  );
}
```

`FloatingThreads` displays floating threads below text highlights in the editor,
ideal for mobile, whereas `AnchoredThreads` displays threads vertically
alongside the editor which is great on desktop. To create a new thread use the
button in a [pre-built toolbar](#Toolbars), or
[build a button yourself](/docs/api-reference/liveblocks-react-tiptap#Opening-the-composer).

### Notifications

Add a [Notifications](/docs/ready-made-features/notifications) UI to your
application, and automatically notify users when theyâ€™ve been mentioned.
Notifications also allows you to trigger sending emails, Slack, or any other
kind of notification, using our webhooks.

<Figure>
  <Image
    src="/assets/text-editor/notifications.png"
    alt="Text editor notifications"
    width={1312}
    height={874}
  />
</Figure>

Notifications is enabled by default, which means you just need to add our UI
components to keep your users notified. Follow our
[get started guides](/docs/get-started/notifications) to learn how to set up
[`InboxNotification`](/docs/api-reference/liveblocks-react-ui#InboxNotification).

```tsx
export function CollaborativeApp() {
  const { inboxNotifications } = useInboxNotifications();

  return (
    <InboxNotificationList>
      {inboxNotifications.map((inboxNotification) => (
        <InboxNotification
          key={inboxNotification.id}
          inboxNotification={inboxNotification}
        />
      ))}
    </InboxNotificationList>
  );
}
```

Inline mentions also trigger
[`TextMention`](/docs/platform/webhooks#TextMention-notification) notification
webhook events. Learn more about
[sending email notifications](/docs/ready-made-features/notifications/email-notifications).

## Server-side modifications

Fetch and modify your text editorâ€™s content from the server, enabling features
such as AI agents. Easily make changes that update in real-time for every
connected user. Use
[`withProsemirrorDocument`](/docs/api-reference/liveblocks-node-prosemirror#withProsemirrorDocument)
to get your editorâ€™s content and make modifications live.

```tsx
await withProsemirrorDocument(
  { roomId: "your-room-id", client: liveblocks },
  async (api) => {
    // get editor content
    const text = api.getText();

    await api.update((doc, tr) => {
      // Make real-time updates
      // ...
    });
  }
);
```

### Multiple editors

Itâ€™s possible to use multiple Tiptap editors on a single page, and each editor
having its own collaboration and extensions. You can enable this by giving each
editor a unique `field` value.

```tsx
import { useLiveblocksExtension } from "@liveblocks/react-tiptap";

function TextEditor() {
  const liveblocks = useLiveblocksExtension({
    field: "editor-one",
  });

  // ...
}
```

Learn more about
[using multiple editors](/docs/api-reference/liveblocks-react-tiptap#Multiple-editors).

### Offline support

Liveblocks Tiptap has an experimental option that enables offline support.
Offline support means that once a document has been opened, itâ€™s saved locally
on the browser, and can be shown instantly without a loading screen. Enable this
by passing a `offlineSupport_experimental` value.

```tsx
import { useLiveblocksExtension } from "@liveblocks/react-tiptap";

function TextEditor() {
  const liveblocks = useLiveblocksExtension({
    offlineSupport_experimental: true,
  });

  // ...
}
```

Learn more about
[offline support](/docs/api-reference/liveblocks-react-tiptap#Offline-support).

### Version History

Liveblocks Tiptap enables version history for your document. Versions can be
automatically created when enabled in your project settings, or manually created
using the
[REST API](/docs/api-reference/rest-api-endpoints#post-rooms-roomId-version).
These versions can be easily displayed to users using a few simple components.
This allows for a comprehensive version history feature in your collaborative
text editor.

To implement version history in your application, you can use the
`useHistoryVersions` hook along with the `HistoryVersionsList` and
`HistoryVersionPreview` components. Here's an example of how to set this up:

```tsx
import {
  useHistoryVersions,
  HistoryVersionSummaryList,
} from "@liveblocks/react";
import { HistoryVersionPreview } from "@liveblocks/react-tiptap";

function DocumentHistory() {
  const [selectedVersionId, setSelectedVersionId] = useState<string>();
  const { versions, isLoading } = useHistoryVersions();
  const selectedVersion = useMemo(
    () => versions?.find((version) => version.id === selectedVersionId),
    [selectedVersionId, versions]
  );

  if (isLoading) {
    return <div>Loading version history...</div>;
  }

  return (
    <>
      <div>
        {selectedVersion ? (
          <HistoryVersionPreview
            version={selectedVersion}
            className="h-full w-full"
            onVersionRestore={onVersionRestore}
          />
        ) : (
          <div>No version selected</div>
        )}
      </div>

      <div>
        <HistoryVersionSummaryList>
          {versions?.map((version) => (
            <HistoryVersionSummary
              onClick={() => {
                setSelectedVersionId(version.id);
              }}
              key={version.id}
              version={version}
              selected={version.id === selectedVersionId}
            />
          ))}
        </HistoryVersionSummaryList>
      </div>
    </>
  );
}
```

In this example, `useHistoryVersions` fetches the version history,
`HistoryVersionSummaryList` displays a list of available versions, and
`HistoryVersionPreview` shows a preview of the selected version. This setup
provides users with an interface to browse through the document's history and
restore different versions.

## Tiptap API Reference

<ListGrid columns={2}>
  <DocsCard
    type="technology"
    title="Tiptap React"
    href="/docs/api-reference/liveblocks-react-tiptap"
    description="@liveblocks/react-tiptap"
    visual={<DocsReactIcon />}
  />
  <DocsCard
    type="technology"
    title="Tiptap/ProseMirror Node"
    href="/docs/api-reference/liveblocks-node-prosemirror"
    description="@liveblocks/node-prosemirror"
    visual={<DocsApiIcon />}
  />
</ListGrid>

---
meta:
  title: "Notifications"
  parentTitle: "Ready-made features"
  description:
    "Embed a customizable notification experience into your product to enable
    people to collaborate."
---

Embed a notification experience into your product, enabling collaboration
between your users. Liveblocks Notifications is fully customizable, allowing you
to create a range of notification experiences that look and feel like your
product. Easily send notifications, create inbox notification trays, and trigger
emails with aggregated notifications. Any custom notification can be sent, but
other parts of Liveblocks, such as
[Comments](/docs/ready-made-features/comments) and
[text editors](/docs/ready-made-features/multiplayer-editing/text-editor), can
also automatically trigger collaboration notifications where appropriate.

## Overview

<ListGrid columns={2}>
  <DocsCard
    type="technology"
    title="Concepts"
    href="/docs/ready-made-features/notifications/concepts"
    description="Learn about inbox notifications"
    visual={<DocsIdeaIcon className="fill-product-icon-brand h-auto w-6" />}
  />
  <DocsCard
    type="technology"
    title="Default components"
    href="/docs/ready-made-features/notifications/default-components"
    description="Ready-to-use customizable components"
    visual={
      <DocsDefaultComponentsIcon className="fill-product-icon-brand h-auto w-6" />
    }
  />
  <DocsCard
    type="technology"
    title="Hooks"
    href="/docs/ready-made-features/notifications/hooks"
    description="Retrieve notifications & set settings"
    visual={<DocsHooksIcon className="fill-product-icon-brand h-auto w-6" />}
  />
  <DocsCard
    type="technology"
    title="Styling and customization"
    href="/docs/ready-made-features/notifications/styling-and-customization"
    description="CSS variables, dark mode, localization"
    visual={<DocsStylingIcon className="fill-product-icon-brand h-auto w-6" />}
  />
  <DocsCard
    type="technology"
    title="Email notifications"
    href="/docs/ready-made-features/notifications/email-notifications"
    description="Send notifications with webhooks"
    visual={<DocsEmailIcon className="fill-product-icon-brand h-auto w-6" />}
  />
</ListGrid>

## Notifications API Reference

<ListGrid columns={2}>
  <DocsCard
    type="technology"
    title="React"
    href="/docs/api-reference/liveblocks-react#Notifications"
    description="@liveblocks/react"
    visual={<DocsReactIcon />}
  />
  <DocsCard
    type="technology"
    title="React UI"
    href="/docs/api-reference/liveblocks-react-ui#Notifications"
    description="@liveblocks/react-ui"
    visual={<DocsReactIcon />}
  />
  <DocsCard
    type="technology"
    title="JavaScript"
    href="/docs/api-reference/liveblocks-client#Notifications"
    description="@liveblocks/client"
    visual={<DocsJavascriptIcon />}
  />
  <DocsCard
    type="technology"
    title="Node.js"
    href="/docs/api-reference/liveblocks-node#Notifications"
    description="@liveblocks/node"
    visual={<DocsNodejsIcon className="fill-product-icon-brand h-auto w-6" />}
  />
  <DocsCard
    type="technology"
    title="REST API"
    href="/docs/api-reference/rest-api-endpoints#Notifications"
    description="HTTP endpoints"
    visual={<DocsApiIcon className="fill-product-icon-brand h-auto w-6" />}
  />
</ListGrid>

## Examples using Notifications

<ListGrid columns={2}>
  <ExampleCard
    example={{
      title: "Comments notifications",
      slug: "comments-notifications",
      image: "/images/examples/thumbnails/comments-notifications.png",
    }}
    technologies={["nextjs"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Custom notifications",
      slug: "notifications-custom",
      image: "/images/examples/thumbnails/custom-notifications.png",
    }}
    technologies={["nextjs"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Comments emails",
      slug: "comments-emails",
      image: "/images/examples/thumbnails/comments-email.png",
    }}
    technologies={["nextjs"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Text editor emails",
      slug: "collaborative-text-editor-emails",
      image: "/images/examples/thumbnails/text-editor-email.png",
    }}
    technologies={["nextjs"]}
    openInNewWindow
  />
</ListGrid>

---
meta:
  title: "Concepts"
  parentTitle: "Notifications"
  description: "Learn about Notifications"
---

A quick overview of the concepts used in Liveblocks Notifications.

## Inbox Notifications

In Liveblocks Notifications, everything revolves around _inbox notifications_.
Each user can receive these notifications, and a list of them can be rendered in
your application to create a notification tray. Inbox notifications can be sent
either automatically by other Liveblocks products, or manually by calling a
function on the server.

<Figure>
  <Image
    src="/assets/notifications/custom-notification.jpg"
    alt="Thread"
    width={1344}
    height={896}
  />
</Figure>

A userâ€™s inbox notifications can be retrieved by a
[React hook](/docs/api-reference/liveblocks-react#useInboxNotifications) or
[individually on your server](/docs/api-reference/liveblocks-node#get-users-userId-inboxNotifications-inboxNotificationId),
which is helpful after receiving a
[notification webhook event](/docs/platform/webhooks#NotificationEvent). Hereâ€™s
an example of an inbox notification object for a custom notification.

```ts
{
  id: "in_sfj29g...",
  kind: "$myCustomNotification",
  subjectId: "myCustomId_dxs9s0",
  readAt: Date <Fri Dec 16 2023 15:16:25 GMT+0000 (Greenwich Mean Time)>,
  notifiedAt: Date <Fri Dec 15 2023 14:15:22 GMT+0000 (Greenwich Mean Time)>,
  activities: [
    { myCustomProperty: "myCustomValue" },
  ]
}
```

To build a notification tray, you can use a combination of
[default components](/docs/ready-made-features/notifications/default-components)
and [hooks](/docs/ready-made-features/notifications/hooks).

## Project-based

Inbox notifications are
[project-based](/docs/concepts/how-liveblocks-works#Projects), which means that
a user can receive notifications that were sent from other
[rooms](/docs/concepts/how-liveblocks-works#Rooms). This differs to other
Liveblocks products which are room-based, and rely on users inhabiting the same
space.

<Figure>
  <Image
    src="/assets/notifications/notification-rooms.jpg"
    alt="Notification rooms"
    width={1344}
    height={896}
  />
</Figure>

Project-based components require only
[`LiveblocksProvider`](/docs/api-reference/liveblocks-react#LiveblocksProvider)
in React, which is different to other room-based Liveblocks products which also
require [`RoomProvider`](/docs/api-reference/liveblocks-react#RoomProvider).

## Notification kinds

Each inbox notification has a `kind`, and this represents the type of
notification it is. A `kind` is either a custom string prefixed with `$` (e.g.
`$myCustomNotification`) when sending a custom notification, or a predefined
string set by Liveblocks (e.g. `thread`) when itâ€™s sent by a Liveblocks product.

### Custom notifications

A custom notification is a notification that you specify yourself, and can
contain any content.

<Figure>
  <Image
    src="/assets/notifications/custom-notification-both.jpg"
    alt="Thread"
    width={1344}
    height={896}
  />
</Figure>

Custom notifications can be sent using
[`liveblocks.triggerInboxNotification`](/docs/api-reference/liveblocks-node#post-inbox-notifications-trigger)
on the server, and the `kind` must always begin with a `$`, for example
`$myCustomNotification`.

When you trigger an inbox notification, you pass the activity data, which
represents the events that happened. If youâ€™d like to update an existing inbox
notification when a new activity happens, you can
[configure the custom notification to use batching](#notification-batching).

### Collaboration notifications

[Comments](/docs/ready-made-features/comments) can send `thread` notifications
for you automatically, notifying you of events such as a mention, or a new reply
in a thread youâ€™re participating in. Additionally,
[text editors](/docs/ready-made-features/multiplayer-editing) can send
`textMention` notifications when users are mentioned inside the editor.

<Figure>
  <Image
    src="/assets/notifications/notifications-inbox.jpg"
    alt="Thread"
    width={1344}
    height={896}
  />
</Figure>

These are enabled by default and the notification `kind` names are `thread` and
`textMention`. Threads and mentions leverage Notifications behind-the-scenes to
keep track of unread comments so viewing a thread will also mark its inbox
notification as read, and vice versa.

If you use the default
[`Thread`](/docs/api-reference/liveblocks-react-ui#Thread) component, it will
automatically handle marking threads as read when they are viewed and show
unread indicators when there are unread comments in threads you are
participating in.

<Figure>
  <Image
    src="/assets/comments/thread-unread-indicator.png"
    alt="Unread indicator in Thread component"
    width={1456}
    height={896}
  />
</Figure>

## Notification batching

Batching allows you to group multiple activities into a single notification.
This is useful for reducing the number of notifications that are sent to the
user, and can be enabled on custom notification kinds. Itâ€™s always enabled for
Liveblocks `thread` notifications, where new comments in a thread are grouped
into a single notification.

Within the â€œNotificationsâ€ page in the [dashboard](/dashboard), you can add a
custom kind and enable batching. When itâ€™s enabled, triggering an inbox
notification activity for a specific `subjectId`, will update the existing inbox
notification instead of creating a new one.

<Figure>
  <video width={1512} height={982} autoPlay loop muted playsInline>
    <source
      src="/assets/notifications/notification-batching.mp4"
      type="video/mp4"
    />
  </video>
</Figure>

An inbox notification can have up to 50 activities, if you exceed this number, a
new inbox notification will be created. Liveblocks `textMention` notifications
are never batched.

## Notification channels

You can also send notifications on other channels, such as email or Slack,
letting users know when theyâ€™ve missed in-app notifications. Using our dashboard
and hooks you can allow users to set their own notification settings.

<Figure>
  <Image
    src="/assets/notifications/notification-settings.jpg"
    alt="Notification settings"
    width={1344}
    height={896}
  />
</Figure>

There are default channel types for email, Slack, Microsoft Teams, and Web Push.
Each channel works the same, but you can enable different settings for each and
use them differently. Learn more about notification channels in our
[email notifications](/docs/ready-made-features/notifications/email-notifications)
page.

## Data flow

An unread inbox notification will trigger a notification based on the project
notification settings and the user notification settings. Liveblocks evaluates
both the project-level configuration and user preferences to determine whether
to send a channel notification.

<Figure>
  <Image
    src="/assets/notifications/notification-flow.png"
    alt="Notification flow"
    width={672}
    height={990}
  />
</Figure>

## Permissions

### Access tokens

When using [access token authentication](/docs/authentication/access-token),
Liveblocks disregards the permissions specified in the tokens and returns all
notifications created for the user. Consequently, a user will receive
notifications for mentions in comments within rooms they do not have access to.

For greater control over notification permissions, we recommend utilizing
[ID tokens](/docs/authentication/id-token).

### ID token

When using [ID token authentication](/docs/authentication/id-token), Liveblocks
reads the permissions set on the room, and uses these to deliver notifications
that the user is authorized to view.

## Email notifications

Itâ€™s possible to send email notifications to your users, listing all their
unread inbox notifications using a [webhook](/docs/platform/webhooks) event that
Liveblocks provides. Learn more about
[email notifications](/docs/ready-made-features/notifications/email-notifications).

---
meta:
  title: "Default components"
  parentTitle: "Notifications"
  description: "Ready-to-use customizable components"
---

The default components included in Notifications are a great way to start
building your application. With these components you can render inbox
notification components.

- Fully styled notification components, with an optional dark mode.
- Customize through CSS variables and class names.
- Receive collaboration notifications automatically triggered by Liveblocks
  [Comments](/docs/ready-made-features/comments) or
  [text editors](/docs/ready-made-features/multiplayer-editing/text-editor).
- Receive fully custom notifications.

## InboxNotification

The [`InboxNotification`][] component renders a single inbox notification.

<Figure>
  <Image
    src="/assets/notifications/inbox-notification.png"
    alt="InboxNotification"
    width={768}
    height={446}
  />
</Figure>

### Usage

The best way to get started is to import the [`useInboxNotifications`][] hook,
and loop through each of the current userâ€™s notifications.

```tsx highlight="5,10-13"
import { InboxNotification } from "@liveblocks/react-ui";
import { useInboxNotifications } from "../liveblocks.config";

function Component() {
  const { inboxNotifications } = useInboxNotifications();

  return (
    <>
      {inboxNotifications.map((inboxNotification) => (
        <InboxNotification
          key={inboxNotification.id}
          inboxNotification={inboxNotification}
        />
      ))}
    </>
  );
}
```

#### Room titles

Room titles displayed in notifications are obtained using the
[`resolveRoomsInfo`](/docs/api-reference/liveblocks-react#LiveblocksProviderResolveRoomsInfo)
function in
[`LiveblocksProvider`](/docs/api-reference/liveblocks-react#LiveblocksProvider).
This allows you to display meaningful document or room names instead of room IDs
in your notifications. Learn more in our guide on
[how to customize room names in inbox notifications](/guides/how-to-customize-room-names-in-inbox-notifications).

#### Rendering different components

As well as displaying the default notification component, you can render
alternate components for different notification `kinds` (the type of
notification). Below weâ€™re rendering a different component for custom
`$fileUploaded` notifications.

```tsx highlight="14-18"
import { InboxNotification } from "@liveblocks/react-ui";
import { useInboxNotifications } from "../liveblocks.config";

function Component() {
  const { inboxNotifications } = useInboxNotifications();

  return (
    <>
      {inboxNotifications.map((inboxNotification) => (
        <InboxNotification
          key={inboxNotification.id}
          inboxNotification={inboxNotification}
          kinds={{
            $fileUploaded: (props) => (
              <InboxNotification.Custom {...props} title="New file" aside="ðŸ“">
                A new file has been uploaded
              </InboxNotification.Custom>
            ),
          }}
        />
      ))}
    </>
  );
}
```

You can also render any plain JSX you like. Learn more about this under
[rendering notification kinds differently](/docs/api-reference/liveblocks-react-ui#Rendering-notification-kinds-differently).

## InboxNotificationList

The [`InboxNotificationList`][] component renders your inbox notifications as a
list.

<Figure>
  <Image
    src="/assets/notifications/inbox-notification-list.png"
    alt="InboxNotificationList"
    width={768}
    height={446}
  />
</Figure>

### Usage

Wrap your [`InboxNotification`][] components in [`InboxNotificationList`][] to
render your notifications as an ordered HTML list, `ol > li`.

```tsx highlight="8,15"
import { InboxNotification, InboxNotificationList } from "@liveblocks/react-ui";
import { useInboxNotifications } from "../liveblocks.config";

function Component() {
  const { inboxNotifications } = useInboxNotifications();

  return (
    <InboxNotificationList>
      {inboxNotifications.map((inboxNotification) => (
        <InboxNotification
          key={inboxNotification.id}
          inboxNotification={inboxNotification}
        />
      ))}
    </InboxNotificationList>
  );
}
```

[`InboxNotification`]: /docs/api-reference/liveblocks-react-ui#InboxNotification
[`InboxNotificationList`]:
  /docs/api-reference/liveblocks-react-ui#InboxNotificationList
[`useInboxNotifications`]:
  /docs/api-reference/liveblocks-react#useInboxNotifications

## Customization

Itâ€™s possible to style and localize the default components:

- Import dark mode styles.
- Modify the style with CSS variables and class names.
- Use overrides to change default text used in the components.

Learn more under
[styling and customization](/docs/ready-made-features/notifications/styling-and-customization).

---
meta:
  title: "Email notifications"
  parentTitle: "Notifications"
  description: "Send notifications with webhooks"
---

Using Liveblocks webhooks, itâ€™s possible to trigger your API endpoints when
certain events occur, such as users joining or leaving rooms. One of these
events was created specifically for sending notifications from your back end,
the "`notification"` event. Certain notifications can be enabled or disabled on
different channels for this event, for example you could enable notifications on
`email` and `slack`, but not on `teams`.

<Figure>
  <Image
    src="/assets/comments/email-notification.png"
    alt="An email titled 'New notifications' showing two comments and a link to the thread"
    width={1500}
    height={1000}
  />
</Figure>

## Step-by-step guides

This page is an overviewâ€”if youâ€™re looking to send email notifications after
Comments or Text Editor updates, makes sure to read our specific guides:

- [How to send email notifications of unread comments](/docs/guides/how-to-send-email-notifications-of-unread-comments).
- [How to send email notifications for unread text editor mentions](/docs/guides/how-to-send-email-notifications-for-unread-text-editor-mentions).

## Inbox notifications

Email notifications are built around the concept of inbox notifications, which
are different from â€œnormalâ€ notifications in the sense that they can group
multiple activities together and evolve over time. This makes more sense when
sending email notifications because it helps to avoid flooding your users with
too many emails.

## Sending email notifications with webhooks

Using [Liveblocks webhooks](/docs/platform/webhooks#Liveblocks-events) you can
listen to a range of events such as user joining rooms, or threads being
created. On [your dashboard](https://liveblocks.io/dashboard) you can create a
webhook for a project, and select which events youâ€™d like to listen to.

<Figure>
  <video width={1512} height={982} autoPlay loop muted playsInline>
    <source src="/assets/webhooks/edit-events.mp4" type="video/mp4" />
  </video>
</Figure>

The endpoint URL you pass will receive request with relevant data when the event
occurs. The webhook event built for creating these unread notification emails is
called `"notification"`, and by default is sent up to every 30 minutes to each
user, though this can be customized in the webhooks dashboard.

### Notification channels

`"notification"` webhooks can be enabled and disabled on certain channels in the
notifications dashboard page. Channels are used to represent different places
your users may receive notifications, such as on `email`, `slack`, `teams`, and
`webPush`.

<Figure>
  <video width={1512} height={982} autoPlay loop muted playsInline>
    <source src="/assets/webhooks/notification-settings.mp4" type="video/mp4" />
  </video>
</Figure>

### Event object

Hereâ€™s an example of an event object thatâ€™s sent when a user receives a new (or
updated) inbox notification. Note that this is custom notification sent on the
`email` channel.

```ts
const event = {
  type: "notification",
  data: {
    channel: "email",
    kind: "$myCustomNotification",
    projectId: "my-project-id",
    roomId: "my-room-id",
    userId: "my-user-id",
    inboxNotificationId: "in_xt3p7ak...",
    createdAt: "2021-10-06T01:45:56.558Z",
  },
};
```

### Your endpoint

In your endpoint, you can use this `event` object with
[`liveblocks.getInboxNotification`](/docs/api-reference/liveblocks-node#get-users-userId-inboxNotifications-inboxNotificationId),
which will return the inbox notification for the event.

```ts
// Data from the `notification` event
const { inboxNotificationId, userId } = event.data;

// Get the inbox notification, which details when the user last read the thread
const inboxNotification = await liveblocks.getInboxNotification({
  inboxNotificationId,
  userId,
});

// { kind: "$myCustomNotification", readAt: Date<2024-07-13T14:32:50.697Z>, ... }
console.log(inboxNotification);
```

Once you have the inbox notification you can then send an email to the `userId`
containing information from the notification.

```ts
const emailAddress = __getUserEmail__(userId);

// Send email to the user that received the inbox notification
__sendEmail__({
  from: "hello@my-company.com",
  to: emailAddress,
  title: "New notification",
  html: `
    <h1>New notification</h1>
    <a href="...">Learn more</a>
  `,
});
```

Hereâ€™s an example with every step linked together, along with the code necessary
to verify a webhook request is valid.

```ts title="Full example" isCollapsable isCollapsed
import {
  Liveblocks,
  WebhookHandler,
  stringifyCommentBody,
} from "@liveblocks/node";

// Add your webhook secret key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_WEBHOOK_SECRET";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

// Add your secret key from a project's API keys dashboard
const API_SECRET = "{{SECRET_KEY}}";
const liveblocks = new Liveblocks({ secret: API_SECRET });

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // When a notification webhook event has triggered
  if (event.type === "notification") {
    const { inboxNotificationId, userId } = event.data;

    // Get the inbox notification, which details when the user last read the thread
    const inboxNotification = await liveblocks.getInboxNotification({
      inboxNotificationId,
      userId,
    });

    // Send email to the user that received the inbox notification
    const emailAddress = __getUserEmail__(userId);
    __sendEmail__({
      from: "hello@my-company.com",
      to: emailAddress,
      title: "New comment",
      html: `
        <h1>New notification</h1>
        <a href="...">Learn more</a>
      `,
    });
  }

  return new Response(null, { status: 200 });
}
```

<Banner title="Sending Comments emails">

This page is an overview of creating email notifications with Notifications. If
youâ€™d like to send emails about new comments, make sure to read
[how to send email notifications of unread comments](/docs/guides/how-to-send-email-notifications-of-unread-comments).

</Banner>

### Permissions

When you receive a `notification` webhook event, it's essential to verify if the
user has access to the room before sending an email. Liveblocks lacks the
necessary information to determine if a user has access to a room. For instance,
we create an inbox notification when a user is mentioned in a comment. In this
user's client context, we can determine if they have access to the notification
thanks to the token generated for that user. However, when we send a
`notification` webhook event, we lack this information.

#### Access token authentication

If you are using access tokens, this will always be true, Liveblocks will never
have the information.

#### ID token authentication

If you are using ID tokens, Liveblocks already possesses certain information
about the permissions you have configured for each room, specifying which users
and groups have access. However, what we currently lack is the relationship
between a user and a group. At present, you need to verify user access before
sending an email. We do, however, plan to include full permissions info in
Liveblocks in our future updates. If you're interested in learning more about
this feature, please feel free to reach out to us.

## Notification settings

Itâ€™s possible to allow users to choose their own notification settings for each
channel in your application.

<Figure>
  <Image
    src="/assets/notifications/notification-settings.jpg"
    alt="Notification settings"
    width={1344}
    height={896}
  />
</Figure>

To implement this, import
[`useNotificationSettings`](/docs/api-reference/liveblocks-react#useNotificationSettings)
into your component, and create a list of toggles. Hereâ€™s an example of a
checkbox that toggles thread notification emails.

```tsx highlight="4,8-17"
import { useNotificationSettings } from "@liveblocks/react/suspense";

function NotificationSettings() {
  const [{ settings }, updateSettings] = useNotificationSettings();

  return (
    <>
      <label>
        Receive thread notifications by email:
        <input
          type="checkbox"
          checked={settings.email?.thread}
          onChange={(e) =>
            updateSettings({ email: { thread: e.target.checked } })
          }
        />
      </label>
      {/* Other checkboxes */}
    </>
  );
}
```

## Retrieving and modifying Comments data

Hereâ€™s every Notifications-related
[`@liveblocks/node`](/docs/api-reference/liveblocks-node) function. Each also
has a corresponding REST API, you can find more info by following the links.

- [`getInboxNotification`](/docs/api-reference/liveblocks-node#get-users-userId-inboxNotifications-inboxNotificationId)
- [`triggerInboxNotification`](/docs/api-reference/liveblocks-node#post-inbox-notifications-trigger)

---
meta:
  title: "Hooks"
  parentTitle: "Notifications"
  description: "Get inbox notifications"
---

The Notifications React hooks can be used to fetch inbox notifications on the
client, and change their behavior.

## List a userâ€™s inbox notifications [#inbox-notifications-hook]

The most important Notifications hook is [`useInboxNotifications`][], which
retrieves every inbox notification for the current user. This can be used to
render a list of notifications, either using the
[default components](/docs/ready-made-features/comments/default-components), or
with your own components. Hereâ€™s an example of it used with the default
[`InboxNotification`][] component.

```tsx
import { useInboxNotifications } from "../liveblocks.config";

function Component() {
  const { inboxNotifications } = useInboxNotifications();

  // [{ kind: "$myCustomNotification", id: "in_sf8s6sh...", ... }, ...]
  console.log(inboxNotifications);

  return (
    <>
      {inboxNotifications.map((inboxNotification) => (
        <InboxNotification
          key={inboxNotification.id}
          inboxNotification={inboxNotification}
        />
      ))}
    </>
  );
}
```

There are two versions of the [`useInboxNotifications`][] hook, the
[Suspense version](#suspense-hooks), which we recommend by default, and the
[regular version](#regular-hooks).

## Get unread notifications count [#unread-notifications-count-hook]

The
[`useUnreadInboxNotificationsCount`](/docs/api-reference/liveblocks-react#useUnreadInboxNotificationsCount)
hook is useful for creating a badge that displays the unread notifications
count.

```tsx
import { useUnreadInboxNotificationsCount } from "../liveblocks.config";

function Component() {
  const { count } = useUnreadInboxNotificationsCount();

  // 3
  console.log(count);

  return <div>You have {count} unread notifications</div>;
}
```

## Mark all notifications as read

To mark all notifications as read for the current user, you can add
[`useMarkAllInboxNotificationsAsRead`](/docs/api-reference/liveblocks-react#useMarkAllInboxNotificationsAsRead).

```tsx
function NotificationReadButton() {
  const markAllInboxNotificationsAsRead = useMarkAllInboxNotificationsAsRead();

  return (
    <button onClick={markAllInboxNotificationsAsRead}>Mark all as read</button>
  );
}
```

## Fetch a userâ€™s information [#user-hook]

The only information Liveblocks stores about users is their user ID, which is
set when [authenticating with Liveblocks](/docs/authentication). With the
[`useUser`](/docs/api-reference/liveblocks-react#useUser) hook, you can fetch a
userâ€™s information from their ID. This is particularly helpful when building
custom components, as this allows you fetch their name, avatar, and any other
custom data youâ€™ve set.

```tsx
import { useUser } from "../liveblocks.config";

function Component() {
  const { user } = useUser("olivier@example.com");

  // { name: "Olivier", avatar: "https://...", color: "red" }
  console.log(user);

  return <img src={user.avatar} alt={user.name} />;
}
```

The user data retrieved is set within the
[`resolveUsers`](/docs/api-reference/liveblocks-client#resolveUsers) function in
your `liveblocks.config.ts` file.

```ts
async function resolveUsers({ userIds }) {
  // ["olivier@example.com"]
  console.log(userIds);

  return [
    {
      name: "Olivier",
      avatar: "https://example.com/olivier.png",
      color: "red",
    },
  ];
}
```

There are two versions of the
[`useUser`](/docs/api-reference/liveblocks-client#useUser) hook,
[Suspense](#suspense-hooks), which we recommend by default, and
[regular](#regular-hooks).

## Fetch a groupâ€™s information [#group-hook]

Similar to users, Liveblocks only stores group IDs for groups. With the
[`useGroupInfo`](/docs/api-reference/liveblocks-react#useGroupInfo) hook, you
can fetch a groupâ€™s information from their ID. This is particularly helpful when
building custom components, as this allows you to fetch their name, avatar, and
any other custom data youâ€™ve set.

```tsx
import { useGroupInfo } from "../liveblocks.config";

function Component() {
  const { group } = useGroupInfo("engineering");

  // { name: "Engineering", avatar: "https://...", color: "blue" }
  console.log(group);

  return <img src={group.avatar} alt={group.name} />;
}
```

The group data retrieved is set within the
[`resolveGroupsInfo`](/docs/api-reference/liveblocks-client#resolveGroupsInfo)
function in your `liveblocks.config.ts` file.

```ts
async function resolveGroupsInfo({ groupIds }) {
  // ["engineering"]
  console.log(groupIds);

  return [
    {
      name: "Engineering",
      avatar: "https://example.com/engineering.png",
      color: "blue",
    },
  ];
}
```

There are two versions of the
[`useGroupInfo`](/docs/api-reference/liveblocks-client#useGroupInfo) hook,
[Suspense](#suspense-hooks), which we recommend by default, and
[regular](#regular-hooks).

## Comments hooks

[Comments](/docs/ready-made-features/comments) integrates seamlessly into
Notifications, and a number of hooks are provided to modify this behavior.

### Unread indicator

Threads keep track of unread comments so viewing a thread will also mark its
inbox notification as read, and vice versa. If you use the default
[`Thread`](/docs/api-reference/liveblocks-react-ui#Thread) component, it will
automatically handle marking threads as read when they are viewed and show
unread indicators when there are unread comments in threads you are
participating in.

<Figure>
  <Image
    src="/assets/comments/thread-unread-indicator.png"
    alt="Unread indicator in Thread component"
    width={1456}
    height={896}
  />
</Figure>

If youâ€™re building your own custom `Thread` component, you can use
[`useMarkThreadAsRead`](/docs/api-reference/liveblocks-react#useMarkThreadAsRead)
and
[`useThreadSubscription`](/docs/api-reference/liveblocks-react#useThreadSubscription)
to replicate or customize this behavior.

### Thread subscription settings

By default, youâ€™ll receive inbox notifications for threads you are participating
in. This setting can be customized for each user and per room:

- `"all"` to be notified about everything.
- `"replies_and_mentions"` for the default setting.
- `"none"` to mute the room.

You can use
[`useRoomSubscriptionSettings`](/docs/api-reference/liveblocks-react#useRoomSubscriptionSettings)
to build a settings picker in your app and allow users to change their own
subscription settings for the current room, or use
[`updateRoomSubscriptionSettings`](/docs/api-reference/liveblocks-node#post-rooms-roomId-users-userId-subscription-settings)
server-side to control them yourself: for example, to automatically make a
documentâ€™s author notified about everything in their document.

### Getting thread data

When using inbox notifications for threads, it can be useful to fetch the actual
thread data, and
[`useInboxNotificationThread`](/docs/api-reference/liveblocks-react#useInboxNotificationThread)
makes this easy.

```tsx
function Notification({ inboxNotification }) {
  const thread = useInboxNotificationThread(inboxNotification.id);

  // { type: "thread", id: "th_sf8s6sh...", ... }
  console.log(thread);

  // ...
}
```

## Hook types [#hook-types]

There are two different ways to use the
[notifications](#inbox-notifications-hook) and [user](#user-hook) hooks; with
[React Suspense](https://react.dev/reference/react/Suspense), and without it. We
recommend using the Suspense versions, as they often result in simpler code.

### Suspense hooks [#suspense-hooks]

Using Suspense hooks means that any data retrieved, for example
`inboxNotifications` from `useInboxNotifications`, will never be `undefined`,
and your component will never see an error.

```tsx
import { useInboxNotifications } from "@liveblocks/react/suspense";

// Suspense: `inboxNotifications` is always defined
function MyNotifications() {
  const { inboxNotifications } = useInboxNotifications();

  // [{ type: "$myCustomNotification", id: "in_sf8s6sh...", ... }, ...]
  console.log(inboxNotifications);
}
```

To catch errors and display a loading screen, you can use
[`ErrorBoundary`](https://www.npmjs.com/package/react-error-boundary) and
[`ClientSideSuspense`](/docs/api-reference/liveblocks-react#suspense-avoid-ssr).

```tsx highlight="7-11"
import { ClientSideSuspense } from "@liveblocks/react/suspense";
import { ErrorBoundary } from "react-error-boundary";

// Handle errors and loading state in the component above
function Component() {
  return (
    <ErrorBoundary fallback={<div>Error</div>}>
      <ClientSideSuspense fallback={<div>Loading...</div>}>
        <MyNotifications />
      </ClientSideSuspense>
    </ErrorBoundary>
  );
}
```

To use Suspense, make sure youâ€™re exporting your hooks from
`@liveblocks/react/suspense`.

```tsx
// Suspense version of hooks
import { useInboxNotifications, useUser } from "@liveblocks/react/suspense";
//                                                                ^^^^^^^^
```

### Regular hooks [#regular-hooks]

The regular versions of Liveblocks hooks require you to check for `error` and
`isLoading` properties. You can then handle these states in the same component.

```tsx
import { useInboxNotifications } from "@liveblocks/react";

// Handle errors and loading state in the same component
function MyNotifications() {
  const { inboxNotifications, error, isLoading } = useInboxNotifications();

  if (error) {
    return <div>Error</div>;
  }

  if (isLoading) {
    return <div>Loading...</div>;
  }

  // Non-Suspense: `inboxNotifications` is only defined AFTER the `if` checks
  // [{ type: "$myCustomNotification", id: "in_sf8s6sh...", ... }, ...]
  console.log(inboxNotifications);
}
```

To use the regular hooks, make sure youâ€™re exporting from `@liveblocks/react`.

```tsx
// Regular version of hooks
import { useInboxNotifications, useUser } from "@liveblocks/react";
//                                              ^^^^^^^^^^^^^^^^^
```

[`InboxNotification`]: /docs/api-reference/liveblocks-react-ui#InboxNotification
[`InboxNotificationList`]:
  /docs/api-reference/liveblocks-react-ui#InboxNotificationList
[`useInboxNotifications`]:
  /docs/api-reference/liveblocks-react#useInboxNotifications

---
meta:
  title: "Styling and customization"
  parentTitle: "Notifications"
  description: "CSS variables, dark mode, and more"
---

Styling Notifications
[default components](/docs/ready-made-features/notifications/default-components)
is enabled through a range of means, such as CSS variables, class names, and
more.

## Default components

To add the default componentsâ€™ theme, import the
[default styles](/docs/api-reference/liveblocks-react-ui#Default-styles) CSS
file.

```ts
import "@liveblocks/react-ui/styles.css";
```

You can also import one of two CSS files to enable
[dark mode](/docs/api-reference/liveblocks-react-ui#Dark-mode), depending on how
youâ€™d like to enable it.

```ts
// Dark mode using the system theme with `prefers-color-scheme`
import "@liveblocks/react-ui/styles/dark/media-query.css";
```

```ts
// Dark mode using `className="dark"`, `data-theme="dark"`, or `data-dark="true"`
import "@liveblocks/react-ui/styles/dark/attributes.css";
```

### CSS variables

A number of
[CSS variables](/docs/api-reference/liveblocks-react-ui#CSS-variables) can be
used to customize colors, spacing, and more. This is our recommended path for
styling the default components, as you can quickly and easily modify all
components with just a few variables.

```css
/* Styles all default components */
.lb-root {
  --lb-accent: purple;
  --lb-spacing: 1em;
  --lb-radius: 0;
}
```

### Class names

Should you need deeper customization,
[class names](/docs/api-reference/liveblocks-react-ui#Class-names) can be
styled, some of which provide contextual data attributes.

```css
.lb-notification {
  /* Customize notification */
}

.lb-avatar[data-loading] {
  /* Customize avatar loading state */
}
```

---
meta:
  title: "DevTools"
  parentTitle: "Tools"
  description:
    "Learn how to leverage Liveblocks DevTools to inspect and troubleshoot your
    collaborative application."
---

Our [DevTools](/devtools) is a browser-based extension that integrates with
Liveblocks and your local development environment. This allows you to easily
inspect, visualize, and troubleshoot your collaborative online experiences.

Our DevTools is currently only available if you are on Liveblocks 1.0 or later.
To view step-by-step instructions on how to upgrade your project to Liveblocks
1.0, check out our [upgrade guides](/docs/platform/upgrading/).

<Banner title="Live demo video">

If you want to see how this works in action, check out this
[live demo](https://www.youtube.com/watch?v=-6Jxejp0iuw) recorded by
[Vincent](https://twitter.com/nvie) on YouTube.

</Banner>

## Install the browser extension

Our DevTools extension is available for all major web browsers:

- [Chrome](https://chrome.google.com/webstore/detail/liveblocks-devtools/iiagocfmmhknpdalddkbiejnfmbmlffk)
- [Firefox](https://addons.mozilla.org/en-US/firefox/addon/liveblocks-devtools/)
- [Edge](https://microsoftedge.microsoft.com/addons/detail/liveblocks-devtools/hfecmmnilleegmjaegkjjklnjbgadikg)

Within the â€œLiveblocksâ€ panel, you will see two panes: storage and presence. The
storage pane represents each object that you have defined in storage as a tree,
likewise, the presence pane represents each user that is connected to your
Liveblocks project.

## Trying our DevTools

### With our Starter Kit

The [Liveblocks Starter Kit](/starter-kit) is a great way to get started with
Liveblocks and learn how to use our DevTools.

<Figure>
  <video autoPlay loop muted playsInline>
    <source
      src="/assets/devtools/liveblocks-devtools-starter-kit.mp4"
      type="video/mp4"
    />
  </video>
</Figure>
To use the Starter Kit with DevTools, run the following command:

```bash
npx create-liveblocks-app@latest --next
```

You can then follow the guided prompts in the terminal to create your project.
For additional information on how to use the Starter Kit, see the
[Starter Kit guide](/docs/tools/nextjs-starter-kit).

Once you have completed the Starter Kit prompts and installed the extension, run
the Starter Kit with `npm run dev` and open your browser to `localhost:3000`.
You should authenticate, and then create a new draft document. Once you have
created a new document, open up the developer tools window. Find the newly
available â€œLiveblocksâ€ panel there.

<Figure>
  <video autoPlay loop muted playsInline>
    <source
      src="/assets/devtools/liveblocks-starter-dev.mp4"
      type="video/mp4"
    />
  </video>
</Figure>

### With an example from our gallery

All of [our examples](/examples) hosted on Liveblocks.io are available for you
to run locally from the
[examples directory](https://github.com/liveblocks/liveblocks/tree/main/examples)
in the Liveblocks repo. For testing and reviewing how to use our DevTools, we
will use the
[Advanced Collaborative Spreadsheet](https://liveblocks.io/examples/collaborative-spreadsheet-advanced/nextjs).

To download this example, run the following command, and follow the guided
prompts to create your project:

```bash
npx create-liveblocks-app@latest --example nextjs-spreadsheet-advanced
```

Once you have completed the prompts and installed the extension, run the example
with `npm run dev` and open your browser to `localhost:3000`.

<Figure highlight={false}>
  <Image
    src="/assets/devtools/spreadsheet-example.png"
    alt="Liveblocks DevTools panel"
    width={768}
    height={576}
  />
</Figure>

Open your browser and open up the developer tools window. Find the newly
available â€œLiveblocksâ€ panel there, and you should see the values from the
spreadsheet examples populating storage.

## Features and tips

### Highlighting

When a value in storage changes, the DevTools will highlight the value to
indicate that it has changed.

<Figure>
  <video autoPlay loop muted playsInline>
    <source src="/assets/devtools/highlight-changes.mp4" type="video/mp4" />
  </video>
</Figure>

### Search

Storage values are searchable by key and regex.

<Figure>
  <video autoPlay loop muted playsInline>
    <source src="/assets/devtools/search-regex.mp4" type="video/mp4" />
  </video>
</Figure>

### Hover

Hovering over a value in storage or presence makes an eye icon appear. If
clicked, it displays the value of that key.

<Figure>
  <video autoPlay loop muted playsInline>
    <source src="/assets/devtools/expand-tooltip.mp4" type="video/mp4" />
  </video>
</Figure>

### Expand and collapse

- You can expand and collapse objects with one level of depth by using the arrow
  keys or spacebar
- You can quickly expand and collapse nested objects within storage by holding
  the alt/option key and clicking on the object

<Banner title="Initialization">

If you open the DevTools after a Liveblocks client has already been initialized,
you may see an empty page. This is because our DevTools is only able to retrieve
the current state of storage and presence. To fix this, you can refresh the page
or open the DevTools before initializing the Liveblocks client.

</Banner>

---
meta:
  title: "MCP server"
  parentTitle: "Tools"
  description:
    "Learn to use the official MCP server for Liveblocks, helpful for inspecting
    and modifying your project with AI in Cursor, VS Code, Claude Desktop, and
    more."
---

The Liveblocks MCP server allows you to inspect and modify your project with AI
in compatible apps such as Cursor, VS Code, Claude Desktop, and more.

<Figure>
  <video autoPlay loop muted playsInline>
    <source src="/assets/ai-copilots/mcp-server.mp4" type="video/mp4" />
  </video>
</Figure>

## Features

Our MCP server features 39 different tools, enabling most features from our
[REST API](/docs/api-reference/rest-api-endpoints). You can use it to:

- Create and modify rooms, threads, comments, notifications, more.
- Read realtime Storage and Yjs values.
- Broadcast custom events to connected clients.
- Mark threads and notifications as read/unread.

AI will often string tool calls togetherâ€”for example, if you ask it to fetch a
room that doesnâ€™t exist, it will ask if youâ€™d like to create the room first, and
then fetch it after.

## Automatic setup

To install automatically, use one of the following commands, making sure to
insert a secret key from your correct project in [your dashboard](/dashboard).

<Banner type="warning" title="Only for development">

Donâ€™t insert a secret key from your product application, as AI will have direct
access to modify it.

</Banner>

### Cursor

Run the following command to set up [Cursor](https://cursor.sh/):

```bash
npx -y @smithery/cli install @liveblocks/liveblocks-mcp-server --client cursor --key "{{SECRET_KEY}}"
```

### Claude

Run the following command to set up
[Claude Desktop](https://claude.ai/download):

```bash
npx -y @smithery/cli install @liveblocks/liveblocks-mcp-server --client claude --key "{{SECRET_KEY}}"
```

### VS Code

Run the following command to set up [VS Code](https://code.visualstudio.com/):

```bash
npx -y @smithery/cli install @liveblocks/liveblocks-mcp-server --client vscode --key "{{SECRET_KEY}}"
```

### Other clients

Find installation information for other clients on
[Smithery](https://smithery.ai/server/@liveblocks/liveblocks-mcp-server).

## Manual setup

1. Clone the
   [Liveblocks MCP server](https://github.com/liveblocks/liveblocks-mcp-server)
   repo.

```bash
git clone https://github.com/liveblocks/liveblocks-mcp-server.git
```

2. Build the project.

```bash
npm install
npm run build
```

### Cursor

3. Go to File â†’ Cursor Settings â†’ MCP â†’ Add new server.

4. Add the following, with the full path to the repo and the correct secret key
   from [your dashboard](/dashboard):

```json
{
  "mcpServers": {
    "liveblocks-mcp-server": {
      "command": "node",
      "args": ["/full/path/to/the/repo/liveblocks-mcp-server/build/index.js"],
      "env": {
        "LIVEBLOCKS_SECRET_KEY": "{{SECRET_KEY}}"
      }
    }
  }
}
```

5. Check it's enabled in the MCP menu.

### Claude Desktop

3. Go to File â†’ Settings â†’ Developer â†’ Edit Config.

4. Open the JSON file, `claude_desktop_config.json`.

5. Add the following, with the full path to the repo and the correct secret key
   from [your dashboard](/dashboard):

```json
{
  "mcpServers": {
    "liveblocks-mcp-server": {
      "command": "node",
      "args": ["/full/path/to/the/repo/liveblocks-mcp-server/build/index.js"],
      "env": {
        "LIVEBLOCKS_SECRET_KEY": "{{SECRET_KEY}}"
      }
    }
  }
}
```

## Source code

The source code is available in our
[GitHub repository](https://github.com/liveblocks/liveblocks-mcp-server).

---
meta:
  title: "Next.js Starter Kit"
  parentTitle: "Tools"
  description:
    "Kickstart your collaborative SaaS product with the Liveblocks Next.js
    Starter Kit."
---

The Next.js Starter Kit is an open-source template that showcases all aspects of
Liveblocks in a single, modern application.

<Figure>
  <video autoPlay loop muted playsInline>
    <source src="/assets/nextjs-starter-kit/starter-kit.mp4" type="video/mp4" />
  </video>
</Figure>

<Banner title="Live demo">

If youâ€™d like to see how this works, make sure to
[check out this live demo video](https://www.youtube.com/watch?v=Lf7HQ4Z_Ovc) on
YouTube, or [try the project online](https://nextjs-starter-kit.liveblocks.app).

</Banner>

## Features

The Next.js Starter Kit includes the following

- Documents dashboard with pagination, drafts, groups, auto-revalidation
- Collaborative whiteboard app with a fully-featured share menu
- Authentication compatible with GitHub, Google, Auth0, and more
- Document permissions can be scoped to users, groups, and the public

## Set up the Next.js Starter Kit

### create-liveblocks-app

You can get started by running the following command:

```bash
npx create-liveblocks-app@latest --next
```

This will run an installer that allows you to download, configure, and deploy,
your project:

<Figure>
  <video autoPlay loop muted playsInline>
    <source
      src="/assets/nextjs-starter-kit/create-liveblocks-app.mp4"
      type="video/mp4"
    />
  </video>
</Figure>

Give your project a name, and select the [authentication](#authentication)
method youâ€™d like to use in your app. If you are trying to generate a proof of
concept quickly, opting to use demo authentication may be a great optionâ€”you can
still add other authentication providers later on.

#### Deploy with Vercel Integration

If you would like to set up CI/CD with your application, weâ€™ve made that process
straightforward for you as well. When prompted, you can select "deploy to
Vercel" to enable building and deploying the starter kit. The Vercel Integration
will open in a new browser window for you to complete the process of adding your
repository.

<Figure>
  <video autoPlay loop muted playsInline>
    <source
      src="/assets/nextjs-starter-kit/deploy-on-vercel.mp4"
      type="video/mp4"
    />
  </video>
</Figure>

If by clicking "Create" you receive "An unexpected internal error occurred" you
should validate within your code hosting platform of choice (GitHub, GitLab,
Bitbucket) that the Vercel integration has permission to access your repository.
In GitHub, permissions can be found can be found under Settings > Integrations >
Vercel.

#### Connect to Liveblocks and retrieve your secret key

If you prefer to work locally, you can tell the installer you would not like to
"deploy to Vercel." After declining the deployment option, the installer will
prompt adding your Liveblocks Key to the application automatically. If you
forwent deployment or indicated that you would like to get your Liveblocks
secret key automatically, the Liveblocks integration page will open in a new
browser tab. Once the integration page appears, you can sign up/sign in to
Liveblocks, create a new project, and import your API key into the installer.

<Figure>
  <video autoPlay loop muted playsInline>
    <source
      src="/assets/nextjs-starter-kit/create-liveblocks-project.mp4"
      type="video/mp4"
    />
  </video>
</Figure>

After finishing up, check the installer and follow the commands recommended to
get you started.

### Authentication [#authentication]

The Liveblocks starter kit uses [NextAuth.js](https://next-auth.js.org/) for
authentication, meaning many authentication providers can be configured with
minimal code changes. A demo authentication system is used by default, but itâ€™s
easy to add real providers, such as GitHub, Auth0, and more.

Take a look at the guide for your chosen authentication method:

- [GitHub authentication](#github-authentication)
- [Auth0 authentication](#auth0-authentication)
- [Demo authentication](#demo-authentication)

### GitHub authentication [#github-authentication]

To use GitHub auth, make sure you selected "GitHub authentication" when running
the installer (or youâ€™ve set up the
[provider manually](#add-multiple-authentication-providers)). This is how to set
up your GitHub secret key and client id.

1. Go to [Developer Settings](https://github.com/settings/apps) on GitHub and
   click "New GitHub App".
2. Enter an app name (e.g. `Liveblocks Starter Kit (dev)`). Youâ€™ll need a new
   app for each environment, so itâ€™s helpful to place "dev" in the name.
3. Add a homepage URLâ€”this isnâ€™t important now, so a placeholder will do.
4. Find the "Callback URL" input just below, and add your local development URL
   (e.g. `http://localhost:3000`).
5. Look for the "Webhook" section and make sure to uncheck "Active".
6. Use the remaining default settings and press "Create GitHub App".

<Figure>
  <video autoPlay loop muted playsInline>
    <source src="/assets/nextjs-starter-kit/github-auth.mp4" type="video/mp4" />
  </video>
</Figure>

7. On the next page under "Client secrets", press the "Generate a new client
   secret" button (note that this is different to generating a private key!).
8. Copy this secret into the `/.env.local` file as `GITHUB_CLIENT_SECRET`
9. Go back to the previous page and find the "Client ID" near the top. Copy this
   into your `.env.local` file as `GITHUB_CLIENT_ID`

Almost there! `.env.local` should now contain lines similar to this:

```dotenv file=".env.local"
GITHUB_CLIENT_SECRET=XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
GITHUB_CLIENT_ID=XXXXXXXXXXXXXXXXXXXX
```

GitHub authentication is now complete! Next,
[add yourself as a user](#how-to-sign-up) to test out your authentication.

### Auth0 authentication [#auth0-authentication]

To use Auth0 auth, make sure you selected "Auth0 authentication" when running
the installer (or youâ€™ve set up the
[provider manually](#add-multiple-authentication-providers)). This is how to set
up your Auth0 secret key and client information.

1. Go to your [Auth0 Dashboard](https://manage.auth0.com/dashboard) and click
   "Create Application".
2. Enter an app name (e.g. `Liveblocks Starter Kit (dev)`). Youâ€™ll need a new
   app for each environment, so itâ€™s helpful to place "dev" in the name.
3. Select "Single Page Web Applications", and press "Create".
4. Copy your "Client ID" from the top of the page, and place it within
   `.env.local` as `AUTH0_CLIENT_ID`.
5. Click the "Settings" tabâ€” weâ€™ll be making a number of changes here.
6. Find the "Client Secret" input field, and copy the value into `.env.local` as
   `AUTH0_CLIENT_SECRET`.
7. Copy your "Domain" from the input field, add "https://" to the start, and
   place it within `.env.local` as `AUTH0_ISSUER_BASE_URL`.
8. Add the following to the "Allowed Callback URLs" textarea:
   `http://localhost:3000/api/auth/callback/auth0`.
9. Add the following to the "Allowed Logout URLs" textarea:
   `http://localhost:3000`.
10. Scroll to the bottom and press "Save changes".

<Figure>
  <video autoPlay loop muted playsInline>
    <source src="/assets/nextjs-starter-kit/auth0-auth.mp4" type="video/mp4" />
  </video>
</Figure>

`.env.local` should now contain these three lines, along with anything
previously there:

```dotenv file=".env.local"
AUTH0_CLIENT_ID=XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
AUTH0_CLIENT_SECRET=XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
AUTH0_ISSUER_BASE_URL=https://XXXXXXXXXXXXXXXXXX.com
```

Auth0 authentication is now set up! Next, [add yourself a user](#how-to-sign-up)
to test out your authentication.

### Demo authentication [#demo-authentication]

For quickly testing out your app, the demo authentication method can be used.
This method uses a NextAuth
[`CredentialsProvider`](https://next-auth.js.org/providers/credentials) to
simulate a real sign in system. To replace it with your own authentication
method, you can add any other NextAuth
[`Provider`](https://next-auth.js.org/providers/) to
[`/auth.config.ts`](https://github.com/liveblocks/liveblocks/blob/main/starter-kits/nextjs-starter-kit/auth.config.ts).

Read the [next section](#how-to-sign-up) to learn how to add a new user to your
demo application.

### How to sign up - add yourself as a user [#how-to-sign-up]

We havenâ€™t set up a database, so weâ€™re temporarily using the
[`/data`](https://github.com/liveblocks/liveblocks/blob/main/starter-kits/nextjs-starter-kit/data)
folder instead. Before any user can sign in, they need to be added to
[`/data/users.ts`](https://github.com/liveblocks/liveblocks/blob/main/starter-kits/nextjs-starter-kit/data/users.ts).
Navigate there and add your details, for example, if youâ€™re signing in with
`yourname@example.com`:

```ts file="data/users.ts"
{
  id: "yourname@example.com",
  name: "Your Name",
  avatar: "https://liveblocks.io/avatars/avatar-0.png",
  groupIds: ["product", "engineering", "design"],
},
```

Note that this is replacing the sign-up process, so you must enter the email of
any new user. If, for example, youâ€™re using GitHub authentication, you can enter
the email address of any valid GitHub account.

### Ready to go

The Next.js Starter Kit is now ready to use! After setting up authentication,
make sure to restart the dev server to see your authentication in action.

```bash
npm run dev
```

## Assorted info

### Structure

The
[starter kit](https://github.com/liveblocks/liveblocks/tree/main/starter-kits/nextjs-starter-kit)
has the following structure:

```
app
components
data
icons
layouts
lib
 â””â”€ actions
 â””â”€ database
 â””â”€ hooks
 â””â”€ utils
primitives
styles
types
auth.ts
auth.config.ts
liveblocks.config.ts
liveblocks.server.config.ts
package.json
```

The important thing to note is that there are primitives, which are base level
components such as buttons (think of these as the small building blocks of a
page), components, which you can think of as multiplayer implementations
(cursors, badges, etc), app, which renders document level experiences and a
library (lib) of both server side and client side methods which contain the
logic to create and modify documents.

<br />
<details>
  <summary>More info about the structure</summary>
  <br />
  <dl>
    <dt>`/app/`</dt>
    <dd>Next.js app folder.</dd>
    <dt>`/components/`</dt>
    <dd>Components used in the app.</dd>
    <dt>`/data/`</dt>
    <dd>A demo database.</dd>
    <dt>`/icons/`</dt>
    <dd>Every icon component.</dd>
    <dt>`/layouts/`</dt>
    <dd>Page layout components.</dd>
    <dt>`/lib/actions/`</dt>
    <dd>
      Server actions that can be used on both client and server, used for
      accessing and modifying documents.
    </dd>
    <dt>`/lib/database/`</dt>
    <dd>Server functions used for getting database information.</dd>
    <dt>`/lib/hooks/`</dt>
    <dd>A set of React hooks that are used on the client.</dd>
    <dt>`/lib/utils/`</dt>
    <dd>Assorted document-related utilities.</dd>
    <dt>`/primitives/`</dt>
    <dd>Generic reusable components.</dd>
    <dt>`/types/`</dt>
    <dd>All reusable TypeScript types.</dd>
    <dt>`/auth.ts`</dt>
    <dd>File that links NextAuth to your database.</dd>
    <dt>`/auth.config.ts`</dt>
    <dt>File where NextAuth providers are set up.</dt>
    <dt>`/liveblocks.config.ts`</dt>
    <dd>Liveblocks config file.</dd>
    <dt>`/liveblocks.server.config.ts`</dt>
    <dd>Server-side Liveblocks config file.</dd>
  </dl>
</details>

### Async fetching and error handling

This starter kit makes extensive use of the following programming pattern for
fetching async resources:

```ts
const { data, error } = await getDocument({
  /* ... */
});

// An error has occured
if (error) {
  // { code: 400, message: "Document not found", suggestion: "Please check the URL is..." }
  console.log(error);
  return;
}

// Success, but result is empty
if (!data) {
  return;
}

// Success
// { name: "my-document", id: "hIas7GuihgHF8Fhv8Sskg",  ... }
console.log(data);
```

### Document functions

Much of the starter kitâ€™s power is in the
[`/lib/actions`](https://github.com/liveblocks/liveblocks/tree/main/starter-kits/nextjs-starter-kit/lib/actions)
directory. The functions in these files allow you to edit your documents easily
and return type-safe objects. For example in an API endpoint:

```ts
import { createDocument } from "@/lib/actions";

export async function POST() {
  // Create a new document
  const { data, error } = await createDocument({
    name: "My document",
    type: "whiteboard",
    userId: "charlie.layne@example.com",
  });

  // ...
}
```

Because these functions are server actions, they can be leveraged on both client
and server.

```tsx
import { createDocument } from "@/lib/actions";

export function CreateDocumentButton() {
  async function handleCreateDocument() {
    // Create a new document
    const { data, error } = await createDocument({
      name: "My document",
      type: "whiteboard",
      userId: "charlie.layne@example.com",
    });
  }

  return <button onClick={handleCreateDocument}>New document</button>;
}
```

Functions that return data can be used with [SWR hooks](https://swr.vercel.app/)
that automatically update your data in components. For example,
`getDocumentUsers` returns a list of users with access to the room:

```tsx
// Convert from this
const { data, error } = await getDocumentUsers({
  documentId: "my-document-id",
});

// To this
const { data, error } = useDocumentsFunctionSWR([
  getDocumentUsers,
  {
    documentId: "my-document-id",
  },
]);
```

Hereâ€™s a working example:

```tsx
import { getDocumentUsers, useDocumentsFunctionSWR } from "../../lib/client";

export function ListUsers() {
  // Get users attached to a document and update every 1000ms
  const { data: users, error: usersError } = useDocumentsFunctionSWR(
    [
      getDocumentUsers,
      {
        documentId: "my-document-id",
      },
    ],
    { refreshInterval: 1000 }
  );

  if (usersError) {
    return <div>Error</div>;
  }

  if (!users) {
    return <div>Loading...</div>;
  }

  return (
    <ul>
      {users.map((user) => (
        <li>user.name</li>
      ))}
    </ul>
  );
}
```

### How to extend the Document type

If youâ€™d like to add a new property to `Document`, itâ€™s simple. First, edit the
`Document` type in
[`/types/documents.ts`](https://github.com/liveblocks/liveblocks/blob/main/starter-kits/nextjs-starter-kit/types/document.ts):

```ts file="types/documents.ts"
export type Document = {
  // Your new property
  randomNumber: number;
  //...
};
```

Then modify the return value in
[`/lib/utils/buildDocuments.ts`](https://github.com/liveblocks/liveblocks/blob/main/starter-kits/nextjs-starter-kit/lib/utils/buildDocuments.ts).
This is a function that converts a Liveblocks room into your custom document
format:

```ts file="lib/utils/buildDocuments.ts"
// Return our custom Document format
const document: Document = {
  randomNumber: Math.random(),
  // ...
};
```

Next, run the following command to check for problems:

```bash
npm run typecheck
```

If no errors are returned, the document properties were successfully extended.

### How to extend the User & Session type

Similar to the way we extend the `Document` type, we can also extend the `User`
and `Session` type.

Adding a new property to `User`/`Session` is simple. First, edit the `User` type
in
[`/types/data.ts`](https://github.com/liveblocks/liveblocks/blob/main/starter-kits/nextjs-starter-kit/types/data.ts).

```ts file="types/data.ts"
export type User = {
  // Your new property
  randomNumber: number;
  // ...
};
```

Then make sure to return this new property in
[`/lib/database/getUser.ts`](https://github.com/liveblocks/liveblocks/blob/main/starter-kits/nextjs-starter-kit/lib/database/getUser.ts).

```ts file="lib/database/getUser.ts"
return { randomNumber: Math.random() /* ... */ };
```

The new property will now be available to use in your app:

```ts
// randomNumber: Math.random(),
console.log(session.user.info.randomNumber);
```

#### Adding this to your Liveblocks app (optional)

Liveblocks presence is a way of displaying online presence between users,
helpful for live avatars, realtime cursors, etc., and itâ€™s possible to attach a
properties to it for each user. To make a property accessible in presence (and
within the React hooks used in whiteboard), you must modify `UserInfo` in
[`/liveblocks.config.ts`](https://github.com/liveblocks/liveblocks/blob/main/starter-kits/nextjs-starter-kit/liveblocks.config.ts).

```ts file="liveblocks.config.ts"
export type UserInfo = Pick<User, "randomNumber" /* ... */>;
```

In this example
[Pick](https://www.typescriptlang.org/docs/handbook/utility-types.html) creates
the UserInfo type based off of the User type and adds additional keys based on
the properties you provide. After this, modify
[`/lib/actions/authorizeLiveblocks.ts`](https://github.com/liveblocks/liveblocks/blob/main/starter-kits/nextjs-starter-kit/lib/actions/authorizeLiveblocks.ts).
First, weâ€™ll give an anonymous user a property:

```ts file="lib/actions/authorizeLiveblocks.ts"
// Anonymous user info
const anonymousUser: User = {
  randomNumber: Math.random(),
  // ...
};
```

Next, weâ€™ll get the signed-in userâ€™s property:

```ts file="lib/actions/authorizeLiveblocks.ts"
// Get current user info from session (defined in /auth.config.ts)
// If no session found, this is a logged out/anonymous user
const {
  randomNumber,
  // ...
} = session?.user.info ?? anonymousUser;
```

And then pass this info to `authorize`:

```ts file="lib/actions/authorizeLiveblocks.ts"
// Get Liveblocks access token
const { data, error } = await authorize({
  userInfo: { randomNumber /* ... */ },
  // ...
});
```

To make sure to check everythingâ€™s hooked up correctly:

```bash
npm run typecheck
```

Once thatâ€™s working, the new property can then be used in your app:

```tsx
// My random number
const myRandomNumber = useSelf((me) => me.info.randomNumber);

// An array of everyone elseâ€™s random numbers
const everyonesRandomNumbers = useOthersMapped(
  (other) => other.info.randomNumber
);
```

### Adding multiple authentication providers [#add-multiple-authentication-providers]

Itâ€™s possible to add multiple authentication providers to the starter kit using
[NextAuth Providers](https://next-auth.js.org/providers/). Open
[`/auth.config.ts`](https://github.com/liveblocks/liveblocks/blob/main/starter-kits/nextjs-starter-kit/auth.config.ts)
and place your providers in the object:

```ts
import GithubProvider from "next-auth/providers/github";
import Auth0Provider from "next-auth/providers/auth0";

export const authOptions = {
  // ...
  providers: {
    GithubProvider({
      clientId: process.env.GITHUB_CLIENT_ID as string,
      clientSecret: process.env.GITHUB_CLIENT_SECRET as string,
    }),
    Auth0Provider({
      clientId: process.env.AUTH0_CLIENT_ID as string,
      clientSecret: process.env.AUTH0_CLIENT_SECRET as string,
      issuer: process.env.AUTH0_ISSUER_BASE_URL as string,
    }),
  }
};
```

Itâ€™s not only possible with GitHub and Auth0, any
[NextAuth provider](https://next-auth.js.org/providers/) will work, such as
Google, X, Reddit, or more. You can find more information about getting the
necessary secrets on the NextAuth documentation, or on the providerâ€™s website.

Note that if youâ€™re using `CredentialsProvider` (for example, as used in the
demo authentication), `CredentialsProvider` must be removed before any other
authentication methods will appear.

### Switching themes

The starter kit comes with both a dark mode and light mode. By default, the user
sees the theme that corresponds to their system setting, but itâ€™s easy to switch
your whole app to just dark or light mode by modifying
[`styles/globals.css`](https://github.com/liveblocks/liveblocks/blob/main/starter-kits/nextjs-starter-kit/styles/globals.css).

- To use only light mode, remove the entire
  `@media (prefers-color-scheme: dark)` media query.
- To use only dark mode, copy the "Dark mode" CSS variables into the "Light
  mode" section, then remove the entire `@media (prefers-color-scheme: dark)`
  media query.

### Adding a database

To add a database you need to modify the following async functions to return the
correct properties:

- [`/lib/database/getGroup.ts`](https://github.com/liveblocks/liveblocks/blob/main/starter-kits/nextjs-starter-kit/lib/database/getGroup.ts)
- [`/lib/database/getGroups.ts`](https://github.com/liveblocks/liveblocks/blob/main/starter-kits/nextjs-starter-kit/lib/database/getGroups.ts)
- [`/lib/database/getUser.ts`](https://github.com/liveblocks/liveblocks/blob/main/starter-kits/nextjs-starter-kit/lib/database/getUser.ts)

You can then remove the `/data` folder. Everything else should work as expected.

---
meta:
  title: "Upgrading Liveblocks"
  description: "Select the Liveblocks version youâ€™d like to update to"
---

Select the version youâ€™d like to update to. When upgrading, please note that all
packages should be upgraded to the same version. If a version isnâ€™t mentioned,
there are no breaking changes.

<ListGrid>
  <DocsCard
    type="image"
    title="Upgrading to 3.10"
    href="/docs/platform/upgrading/3.10"
    visual={<DocsCardGradientText>3.10</DocsCardGradientText>}
  />
  <DocsCard
    type="image"
    title="Upgrading to 3.0"
    href="/docs/platform/upgrading/3.0"
    visual={<DocsCardGradientText>3.0</DocsCardGradientText>}
  />
  <DocsCard
    type="image"
    title="Upgrading to 2.24"
    href="/docs/platform/upgrading/2.24"
    visual={<DocsCardGradientText>2.24</DocsCardGradientText>}
  />
  <DocsCard
    type="image"
    title="Upgrading to 2.16"
    href="/docs/platform/upgrading/2.16"
    visual={<DocsCardGradientText>2.16</DocsCardGradientText>}
  />
  <DocsCard
    type="image"
    title="Upgrading to 2.15"
    href="/docs/platform/upgrading/2.15"
    visual={<DocsCardGradientText>2.15</DocsCardGradientText>}
  />
  <DocsCard
    type="image"
    title="Upgrading to 2.9"
    href="/docs/platform/upgrading/2.9"
    visual={<DocsCardGradientText>2.9</DocsCardGradientText>}
  />
  <DocsCard
    type="image"
    title="Upgrading to 2.8"
    href="/docs/platform/upgrading/2.8"
    visual={<DocsCardGradientText>2.8</DocsCardGradientText>}
  />
  <DocsCard
    type="image"
    title="Upgrading to 2.2"
    href="/docs/platform/upgrading/2.2"
    visual={<DocsCardGradientText>2.2</DocsCardGradientText>}
  />
  <DocsCard
    type="image"
    title="Upgrading to 2.0"
    href="/docs/platform/upgrading/2.0"
    visual={<DocsCardGradientText>2.0</DocsCardGradientText>}
  />
  <DocsCard
    type="image"
    title="Upgrading to 1.10"
    href="/docs/platform/upgrading/1.10"
    visual={<DocsCardGradientText>1.10</DocsCardGradientText>}
  />
  <DocsCard
    type="image"
    title="Upgrading to 1.9"
    href="/docs/platform/upgrading/1.9"
    visual={<DocsCardGradientText>1.9</DocsCardGradientText>}
  />
  <DocsCard
    type="image"
    title="Upgrading to 1.5"
    href="/docs/platform/upgrading/1.5"
    visual={<DocsCardGradientText>1.5</DocsCardGradientText>}
  />
  <DocsCard
    type="image"
    title="Upgrading to 1.2"
    href="/docs/platform/upgrading/1.2"
    visual={<DocsCardGradientText>1.2</DocsCardGradientText>}
  />
  <DocsCard
    type="image"
    title="Upgrading to 1.0"
    href="/docs/platform/upgrading/1.0"
    visual={<DocsCardGradientText>1.0</DocsCardGradientText>}
  />
  <DocsCard
    type="image"
    title="Upgrading to 0.19"
    href="/docs/platform/upgrading/0.19"
    visual={<DocsCardGradientText>0.19</DocsCardGradientText>}
  />
  <DocsCard
    type="image"
    title="Upgrading to 0.18"
    href="/docs/platform/upgrading/0.18"
    visual={<DocsCardGradientText>0.18</DocsCardGradientText>}
  />
  <DocsCard
    type="image"
    title="Upgrading to 0.17"
    href="/docs/platform/upgrading/0.17"
    visual={<DocsCardGradientText>0.17</DocsCardGradientText>}
  />
</ListGrid>

---
meta:
  title: "Upgrading to 0.17"
  parentTitle: "Upgrading"
  description: "Guide to upgrade to Liveblocks version 0.17"
---

```bash
npm install @liveblocks/client@0.17 @liveblocks/react@0.17
```

With the release of 0.17 weâ€™re making a big investment in the stability and
reliability of Liveblocks. Our long term goal is to empower you to write and
help evolve your apps in the best way possible, and at enterprise scale. It
already was easy to get started with Liveblocks, and with these changes we want
to make _evolving_ your app just as easy.

The first step towards this goal is to take TypeScript support to the next level
for [`@liveblocks/client`][] and [`@liveblocks/react`][] (but our other packages
will soon follow suit). This will help you write code with confidence and catch
bugs as soon as possible in the development process. We have strictened our type
definitions to be more accurate and will recommend some new usage patterns, so
it will be easier for you to create _bug free_ collaborative apps.

To upgrade [`@liveblocks/client`][] and [`@liveblocks/react`][], run the
following command.

```bash
npm install @liveblocks/client@0.17 @liveblocks/react@0.17
```

With these changes, weâ€™re clearing the path to enable schema validation per
room, automatic data migrations, more powerful data selector APIs, and other
enterprise-level features.

Letâ€™s dive in and take a look!

## Changes in @liveblocks/react [#react]

### Lifting up your state to the room level [#lifting-state-to-room]

With 0.16, it was possible to initialize a storage key with [`useObject`][],
[`useList`][], [`useMap`][].

Even if handy, we realized that it introduced confusion and unpredictable
behavior for most users. Imagine a scenario where you have two components
initializing the same storage key.

```tsx
function ComponentA() {
  const author = useObject("author", {
    firstName: "Ada",
    lastName: "Lovelace",
  });

  /* ... */
}

function ComponentB() {
  const author = useObject("author", {
    firstName: "Margaret",
    lastName: "Hamilton",
  });

  /* ... */
}
```

Depending on which component renders first, `author` will be Margaret Hamilton
or Ada Lovelace. To make this more predictable, weâ€™re deprecating this and
recommend initializing the storage at the [`RoomProvider`][] level.

#### Before âŒ [@hidden]

```tsx
function ComponentA() {
  const author = useObject(
    "author",

    // âš ï¸ Donâ€™t initialize your data here anymore!
    { firstName: "Ada", lastName: "Lovelace" }
  );

  /* ... */
}
```

#### After âœ… [@hidden]

```tsx highlight="5-10,13,20"
import { LiveObject } from "@liveblocks/client";

function Root() {
  // Instead, initialize it at the RoomProvider level to remove all ambiguity
  const initialStorage = {
    author: new LiveObject({
      firstName: "Ada",
      lastName: "Lovelace",
    }),
  };

  return (
    <RoomProvider id="my-room-id" initialStorage={initialStorage}>
      <ComponentA />
    </RoomProvider>
  );
}

function ComponentA() {
  const author = useObject("author");

  /* ... */
}
```

<Banner title="Explicitly specify your live structures now">

Notice the explicit use of LiveObject here now. Before, when using useObject (or
useList, useMap), the data you passed to initialize it would automatically get
wrapped in LiveObject for you. This seemed convenient at first, but it also
caused confusion about which Storage keys were Live structures and which ones
were â€œnormalâ€ values. By opting in to which keys you want to be Live structures,
you now get full control over your storage data.

</Banner>

If you run into issues with these new patterns and you need help, please
[let us know](https://github.com/liveblocks/liveblocks/discussions/359). Weâ€™re
here to help!

### A better way to annotate your own types [#react-better-type-annotations]

In 0.16, most of our hooks accepted generic parameters that let you explicitly
provide your own types. For example:

```tsx highlight="3-5,11,19"
import { useMyPresence, RoomProvider } from "@liveblocks/react";

type Presence = {
  cursor: { x: number; y: number };
};

function Root() {
  return (
    <RoomProvider
      id="my-room-id"
      initialPresence={{ cursor: { x: 100, y: 100 } }}
    >
      <Component />
    </RoomProvider>
  );
}

function Component() {
  const [myPresence] = useMyPresence<Presence>();

  const cursor = myPresence.cursor; // Valid

  /* ... */
}
```

One issue with this API was that there was no good way to make sure that
`RoomProvider.initialPresence` and [`useMyPresence`][] types remain
synchronized, as there was no inherent connection between these.

If we added a `color` property to the `Presence` type, it would still be missing
from the `initialPresence` at the `RoomProvider` level, and TypeScript would not
be able to catch that bug. The opposite would also fail; omitting the `cursor`
property on the `initialPresence` would break at runtime but TypeScript would
not be able to catch this issue for you!

Another issue is that there could be many places where youâ€™d have to provide
those extra type annotations.

With 0.17, weâ€™re fixing all of this!

To do so, weâ€™re introducing a new API called [`createRoomContext`][]. It lets
you type your `RoomProvider` and make sure that all your hooks types are
synchronized with the `RoomProvider`. Besides this initial setup, you will no
longer have to provide any type annotations elsewhere anymore.

```tsx
import { createClient } from "@liveblocks/client";
import { createRoomContext } from "@liveblocks/react";

const client = createClient({
  /* client options */
});

type Presence = {
  cursor: { x: number; y: number };
};

// This is just to illustrate the API - read on for tips on where to put this!
const { RoomProvider, useMyPresence } = createRoomContext<Presence>(client);

function Root() {
  return (
    <RoomProvider
      id="my-room-id"
      initialPresence={{ cursor: { x: 100, y: 100 } }}
    >
      <Component />
    </RoomProvider>
  );
}

function Component() {
  const [myPresence] = useMyPresence();

  // We can now be sure that cursor is a valid property without any generic typed param
  const cursor = myPresence.cursor;

  /* ... */
}
```

As you can see, `createRoomContext` optionally takes type parameters that let
you specify the shape of your appâ€™s data (by specifying your own `Presence`,
`Storage`, `UserMeta`, `Event` types). Depending on the complexity of your app,
you may only need to use one or more of these.

Take a look at these examples to better see how to use and configure it:

- Our live-cursors-chat example app uses
  [`Presence`](https://github.com/liveblocks/liveblocks/blob/a11e5744531a21201ae9f9f9ad4f1aa5e74e141e/examples/nextjs-live-cursors-chat/liveblocks.config.ts#L8-L25)
  only
- Our live-avatars example app uses
  [`UserMeta`](https://github.com/liveblocks/liveblocks/blob/a11e5744531a21201ae9f9f9ad4f1aa5e74e141e/examples/nextjs-live-avatars/liveblocks.config.ts#L8-L26)
  only
- Our logo-builder example app uses
  [`Presence`](https://github.com/liveblocks/liveblocks/blob/a11e5744531a21201ae9f9f9ad4f1aa5e74e141e/examples/nextjs-logo-builder/liveblocks.config.ts#L8-L31),
  [`Storage`](https://github.com/liveblocks/liveblocks/blob/a11e5744531a21201ae9f9f9ad4f1aa5e74e141e/examples/nextjs-logo-builder/liveblocks.config.ts#L8-L31),
  and
  [`UserMeta`](https://github.com/liveblocks/liveblocks/blob/a11e5744531a21201ae9f9f9ad4f1aa5e74e141e/examples/nextjs-logo-builder/liveblocks.config.ts#L8-L31)

### Recommended upgrade steps

To make this refactoring as easy as possible, follow the steps below.

#### Step 1 - Upgrade `@liveblocks/client` and `@liveblocks/react` [@hidden]

To upgrade [`@liveblocks/client`][] and [`@liveblocks/react`], run the following
command.

```bash
npm install @liveblocks/client@0.17 @liveblocks/react@0.17
```

#### Step 2 - Create a new file called `liveblocks.config.ts` where you will create your Liveblocks client, provider and hooks and re-export them. [@hidden]

```tsx file="liveblocks.config.ts"
import { createClient } from "@liveblocks/client";
import { createRoomContext } from "@liveblocks/react";

const client = createClient({
  /* client options */
});

// Presence represents the properties that will exist on every User in the Room
// and that will automatically be kept in sync. Accessible through the
// `user.presence` property. Must be JSON-serializable.
type Presence = {
  // cursor: { x: number, y: number } | null,
  // ...
};

// Optionally, Storage represents the shared document that persists in the
// Room, even after all Users leave. Fields under Storage typically are
// LiveList, LiveMap, LiveObject instances, for which updates are
// automatically persisted and synced to all connected clients.
type Storage = {
  // author: LiveObject<{ firstName: string, lastName: string }>,
  // ...
};

// Optionally, UserMeta represents static/readonly metadata on each User, as
// provided by your own custom auth backend (if used). Useful for data that
// will not change during a session, like a User's name or avatar.
// type UserMeta = {
//   id?: string,  // Accessible through `user.id`
//   info?: Json,  // Accessible through `user.info`
// };

// Optionally, the type of custom events broadcasted and listened for in this
// room. Must be JSON-serializable.
// type RoomEvent = {};

export const {
  RoomProvider,
  useMyPresence,
  useObject,
  /* ...all the other hooks youâ€™re using... */
} = createRoomContext<Presence, Storage /* UserMeta, RoomEvent */>(client);
```

#### Step 3 - Replace all the direct hook imports from `@liveblocks/react` by your path to `liveblocks.config.ts` and remove all generic params. [@hidden]

##### Before âŒ [@hidden]

```tsx
import { useMyPresence, useOthers, useObject } from "@liveblocks/react";
import { Author } from "./types";

type MyPresence = {
  cursor: { x: number; y: number } | null;
};

function Component() {
  const author = useObject<Author>("author");
  const [{ cursor }] = useMyPresence<MyPresence>();
  const others = useOthers<Presence>();
}
```

##### After âœ… [@hidden]

```tsx
import { useMyPresence, useOthers, useObject } from "./liveblocks.config";

function Component() {
  const author = useObject("author");
  const [{ cursor }] = useMyPresence();
  const others = useOthers();
}
```

#### Step 4 - Remove your [`LiveblocksProvider`][] at the top of your react tree. Itâ€™s not needed anymore! [@hidden]

##### Before âŒ [@hidden]

```tsx
import { createClient } from "@liveblocks/client";
import { LiveblocksProvider, RoomProvider } from "@liveblocks/react";

const client = createClient({
  /* ... */
});

ReactDOM.render(
  <LiveblocksProvider client={client}>
    <RoomProvider id="my-room-id">
      <App />
    </RoomProvider>
  </LiveblocksProvider>,
  document.getElementById("root")
);
```

##### After âœ… [@hidden]

```tsx
import { RoomProvider } from "./liveblocks.config";

ReactDOM.render(
  <RoomProvider id="my-room-id">
    <App />
  </RoomProvider>,
  document.getElementById("root")
);
```

If you run into issues with these new patterns and you need help, please
[let us know](https://github.com/liveblocks/liveblocks/discussions/360). Weâ€™re
here to help!

## Changes in @liveblocks/client [#client]

### Removed dangerous default type params [#no-more-default-type-params]

In 0.16, while [`LiveList`][], [`LiveMap`][], [`LiveObject`][] were generics,
they also took default type params, which made them a footgun. It was easy to
accidentally use them in a way that would discard useful type information and
hinder inference.

For example:

```ts
// âœ… Inferred
let list = new LiveList([1, 2, 3]);

// âœ… Explicit
let list: LiveList<number> = new LiveList([1, 2, 3]);

// â˜¢ï¸ 0.16: Dangerous footgun: discards useful type information!
// ðŸš« 0.17: No longer possible
let list: LiveList = new LiveList([1, 2, 3]);
```

They now mimic their equivalent built-in TypeScript generics, so:

- `LiveList<T>` is now just like `Array<T>`
- `LiveMap<K, V>` is now just like `Map<K, V>`
- `LiveObject<{ a: number, b: string }>` is now just like
  `{ a: number, b: string }`

### No longer import Presence [#define-dont-import-presence]

In 0.16, we exposed a `Presence` type that you could import, which was just an
alias for â€œany JSON objectâ€â€”not that useful! Importing Presence from Liveblocks
made no sense. By definition, Presence is data owned and defined by your
application after all.

You should no longer need to _import_ this type.

```tsx
// âŒ No longer need to _import_ Presence
import type { Presence } from "@liveblocks/client";

client.enter<Presence>("myRoom");
```

Instead, just _define_ it:

```tsx
// âœ… Just define the shape your app needs
type Presence = {
  cursor: { x: number; y: number } | null;
};

client.enter<Presence>("myRoom");
```

### A better way to annotate your own types [#client-better-type-annotations]

We already talked about why, in React, we
[improved the way you can annotate your own appâ€™s data](#react-better-type-annotations),
by annotating the types only once, at the â€œtopâ€ of your app.

For the same reason, weâ€™re doing a similar thing in the client package.

<Banner title="You may not need this">

This section only applies if youâ€™re not using the React package.

</Banner>

```tsx highlight="18-21,24"
import { createClient } from "@liveblocks/client";
import { Author } from "./types";

const client = createClient({
  /* client options */
});

type Presence = {
  cursor: { x: number; y: number } | null;
};

type Storage = {
  author: LiveObject<Author>;
};

// âŒ In 0.16, you had to annotate each method separately
const room = client.enter("myRoom");
const { root } = await room.getStorage<Storage>();
const author = root.get<Author>("author");
const me = room.getPresence<Presence>();
const others = room.getOthers<Presence>();

// âœ… In 0.17, you can simply annotate it once, at the "top"
const room = client.enter<Presence, Storage>("myRoom");
const { root } = await room.getStorage();
const author = root.get("author");
const me = room.getPresence();
const others = room.getOthers();
```

If you run into issues with these new patterns and you need help, please let us
know. Weâ€™re here to help!

[`@liveblocks/client`]: /docs/api-reference/liveblocks-client
[`@liveblocks/react`]: /docs/api-reference/liveblocks-react
[`createroomcontext`]: /docs/api-reference/liveblocks-react#createRoomContext
[`liveblocksprovider`]: /docs/api-reference/liveblocks-react#LiveblocksProvider
[`livelist`]: /docs/api-reference/liveblocks-client#LiveList
[`livemap`]: /docs/api-reference/liveblocks-client#LiveMap
[`liveobject`]: /docs/api-reference/liveblocks-client#LiveObject
[`roomprovider`]: /docs/api-reference/liveblocks-react#RoomProvider
[`uselist`]: /docs/api-reference/liveblocks-react#useList
[`usemap`]: /docs/api-reference/liveblocks-react#useMap
[`usemypresence`]: /docs/api-reference/liveblocks-react#useMyPresence
[`useobject`]: /docs/api-reference/liveblocks-react#useObject

---
meta:
  title: "Upgrading to 0.18"
  parentTitle: "Upgrading"
  description: "Guide to upgrade to Liveblocks version 0.18"
---

```bash
npm install @liveblocks/client@0.18 @liveblocks/react@0.18
```

With the release of 0.18 weâ€™re bringing some exciting and pretty major
improvements to our React hooks, letting you build apps with ease and with more
control over the exact behavior.

The new APIs weâ€™re introducing here solve many subtle and not-so-subtle pain
points. We heard your feedback, and think we have shipped something awesome that
youâ€™ll love.

This guide consists of two sections:

1. Introduction of the new APIs to get a taste of the new features
2. Recommended upgrade steps to get the most out of it for your app
   ([jump straight to it](#upgrade-steps))

Letâ€™s dive right in!

## Changes in @liveblocks/react [#react]

With 0.18, the biggest conceptual shift is that our hooks to consume data from
Liveblocks now return normal JavaScript data structures (objects, arrays, maps)
that are _immutable_ by default.

Suppose you have initialized your room with:

```tsx highlight="5-9"
<RoomProvider
  id="my-room"
  initialPresence={/* ... */}
  initialStorage={{
    scientist: new LiveObject({
      firstName: "Ada",
      lastName: "Lovelace",
      pets: new LiveList(["ðŸ¶", "ðŸˆ"]),
    }),
  }}
>
  <App />
</RoomProvider>
```

### Accessing nested data [#nested-data]

Reading nested data from there is now much easier:

#### Previously âŒ [@hidden]

```tsx
function Component() {
  const scientist = useObject("scientist");
  if (scientist == null) {
    return null;
  }

  const pets = scientist.get("pets").toArray();
  // ["ðŸ¶", "ðŸˆ"]
}
```

#### Now âœ… [@hidden]

```tsx
function Component() {
  const pets = useStorage((root) => root.scientist.pets);
  // ["ðŸ¶", "ðŸˆ"]
}
```

As you can see, because we can read data with normal JavaScript data structures,
accessing nested data is now straightforward.

### Subscribing to updates is automatic now [#subscriptions]

Rerendering your components when nested dataâ€”like our scientistâ€™s pets
listâ€”changes was a true head breaker before. This required extra helper
components, manual subscriptions, and manual conversion to â€œnormalâ€ JavaScript
arrays.

Now, rerendering your component when data changes is automatic, even for deeply
nested data.

#### Previously âŒ [@hidden]

```tsx
function Component() {
  const scientist = useObject("scientist");
  if (scientist == null) {
    return null;
  }

  return <Pets livePets={scientist.get("pets")} />;
}

function Pets({ livePets }) {
  const room = useRoom();
  const [pets, setPets] = useState(livePets.toArray());

  useEffect(() => {
    return room.subscribe(livePets, () => {
      setPets(livePets.toArray());
    });
  }, [room, livePets]);
}
```

#### Now âœ… [@hidden]

```tsx
function Component() {
  const pets = useStorage((root) => root.scientist.pets);
  // ["ðŸ¶", "ðŸˆ"]
}
```

There is no typo in this example. This is the actual code.

### Multiple subscriptions are just as easy [#multi-subscriptions]

Previously, if you wanted to derive a computed value from multiple storage
values, it took some manual setup to ensure the component would automatically
rerender when either of those values changed.

Now, this is fully automatic. Or should we say, automagic?

#### Previously âŒ [@hidden]

```tsx highlight="11"
function Component() {
  const objA = useObject("a");
  const objB = useObject("b");

  const room = useRoom();
  const [sum, setSum] = useState();
  //     ^^^ Weâ€™re trying to compute the result of a.x + b.x in here

  useEffect(() => {
    function onChange() {
      setSum(objA.get("x") + objB.get("x"));
    }

    const unsubA = room.subscribe(objA, onChange);
    const unsubB = room.subscribe(objB, onChange);

    return () => {
      unsubA();
      unsubB();
    };
  }, [room, objA, objB]);
}
```

#### Now âœ… [@hidden]

```tsx
function Component() {
  const sum = useStorage((root) => root.a.x + root.b.x);
}
```

This component will rerender automatically any time `a.x` or `b.x` changes, but
not more often.

### Guaranteed referential equality [#referential-equality]

Previously we returned mutable Live structures for performance reasons because
converting live changing data to JavaScript data structures constantly (and
recursively) was previously too slow to do on every render. This led to
unintuitive behavior when used with React hooks dependencies.

Not anymore! Due to a technique called structural sharing, weâ€™re now able to
_guarantee_ for nodes in the Storage tree that as long as their (direct or
nested) contents havenâ€™t changed in Storage, their immutable representation will
remain to be the same object references on the next render. This means that you
can rely on referential equality, as you may have expected in the first place.

#### Previously âŒ [@hidden]

```tsx
function Component() {
  const scientist = useObject("scientist");

  useEffect(() => {
    // Effect never triggered when scientist (or their pets list) changes! :(
  }, [scientist]);
}
```

#### Now âœ… [@hidden]

```tsx
function Component() {
  const scientist = useStorage((root) => root.scientist);

  useEffect(() => {
    // Effect triggered every time scientist (or their pets list) changes! :)
    // But not more often than that!
  }, [scientist]);
}
```

### Suspense support

Starting with 0.18, all hooks that read data from Liveblocks come with a
Suspense version of the hook which will never return `null` to indicate the
â€œstill loadingâ€ state. Instead, they will suspend the rendering of the component
tree until Liveblocks has finished loading.

We recommend you to adopt Suspense if you can because it lets you get rid of the
ugly `null` checks, helper components to â€œeat offâ€ those null cases, and the
prop drilling that necessarily comes with all that.

#### Previously âŒ [@hidden]

```tsx
function Component() {
  const camera = useObject("camera");
  const items = useList("items");

  // ðŸ‘Ž
  if (camera == null || items == null) {
    return <div>Still loading...</div>;
  }

  return <MyRealComponent camera={camera} items={items} />;
}
```

#### Now âœ… [@hidden]

Set up a Suspense boundary once:

```tsx file="App.tsx" highlight="6"
import { Suspense } from "react";

function Setup() {
  return (
    // Once
    <Suspense fallback={<Loading />}>
      <App />
    </Suspense>
  );
}
```

Switch to use the Suspense versions of our hooks instead of the â€œnormalâ€ ones:

```tsx file="liveblocks.config.ts" highlight="2"
export const {
  suspense: {
    RoomProvider,
    useStorage,
    /* etc. */
  },
} = createRoomContext(client);
```

Then, enjoy no more null checks everywhere in your app:

```tsx file="Component.tsx"
function Component() {
  const camera = useStorage((root) => root.camera);
  const items = useStorage((root) => root.items);
  // No more null checking! :)
}
```

## Recommended upgrade steps [#upgrade-steps]

To get the most out of the new hooks, we recommend following the steps below to
gradually upgrade your app to make use of the new hooks.

### Step 1: Install the latest package [@hidden]

```bash
npm install @liveblocks/client@0.18 @liveblocks/react@0.18
```

### Step 2: Make sure youâ€™re setting initial presence [@hidden]

We now require setting an initial presence value when you connect to a room
explicitly. This ensures that every user is guaranteed to always have a known
presence value.

Check that you have this in your config file:

```tsx file="liveblocks.config.ts" highlight="3"
<RoomProvider
  id="my-room"
  initialPresence={{}}
  //              ^^^^ No longer optional
>
  <App />
</RoomProvider>
```

If your app somehow doesnâ€™t use Presence, you can just set an empty object
(`{}`) here.

### Step 3: You can remove some uncertainty from user instances [@hidden]

If you have expressions in your code that look like...

```tsx
user.info?.avatar;
//       ^
user.presence?.cursor.x;
//           ^
```

You can now remove these optional chainings. The fields `info` and `presence`
will now always be set on `User` instances.

### Step 4: Adopt Suspense (optional) [@hidden]

Now is a great moment to opt-in to Suspense (see the
[React docs](https://reactjs.org/docs/react-api.html#suspense)) with Liveblocks,
if you can or want to use it in your app. We recommend it for most apps because
it makes working with the new hooks even nicer.

To avoid repeating ourselves, please follow the instruction below.

<Banner title="Adopting Suspense">

Follow
[these instructions to adopt Suspense](/docs/api-reference/liveblocks-react#suspense).
Donâ€™t worry, weâ€™ll wait.

</Banner>

Now that you have updated your app to Suspense, you should be able to remove all
these pesky `null` checks from your code.

```tsx highlight="6-8"
function Component() {
  const a = useMap("a");
  const b = useList("b");
  const c = useObject("c");

  if (a == null || b == null || c == null) {
    return <Loading />;
  }

  /* ... */
}
```

Afterward, please verify that your app still works like normal.

### Step 5a: Replace reads with `useStorage` [@hidden]

We recommend rewriting all usages of `useList`, `useObject` and `useMap` if
those are used for _reading_ data only. If used only for reading values from
Storage, you could turn these into an equivalent `useStorage` call, which has
fewer gotchas.

For example, change:

```tsx
// âŒ
const obj = useObject("a");
const list = useObject("b");
const map = useMap("c");
```

to:

```tsx
// âœ…
const obj = useStorage((root) => root.a);
const list = useStorage((root) => root.b);
const map = useStorage((root) => root.c);
```

Note that the `root` argument you receive here is the immutable normal
JavaScript equivalent of your entire Storage tree, as returned by calling
[`.toImmutable`][].

So this means that if you have been manually converting the mutable Live
structures to normal data structures, you no longer have to do this:

```tsx
// âŒ
obj.toObject();
list.toArray();
```

```tsx
// âœ…
obj; // Already a normal JS object
list; // Already a normal JS array
```

Please note that `useList`, `useObject`, or `useMap` are not deprecated and
still work with the same behavior as before. We just no longer recommend their
use.

### Step 5b: Replace mutations with useMutation [@hidden]

If you are (also) using `useList`, `useObject` or `useMap` to obtain a mutable
reference to the Live structure to _mutate_ it, you can rewrite those use cases
to use the new `useMutation` hook instead.

For example:

```tsx
// âŒ
const obj = useObject("a");

return (
  <input
    value={obj.get("name")}
    //         ^^^ Live object used for reading
    onClick={() => {
      obj.set("name", e.currentTarget.value);
      //  ^^^ Live object used for mutating
    }}
  />
);
```

The idiomatic way to deal with Storage is to _consume_ data using simple/normal
JS data structures and to _mutate_ data using a callback function that you can
create with `useMutation`, which provides access to the mutable Live structures.

```tsx
// âœ…
const name = useStorage((root) => root.a.name);

const setName = useMutation(({ storage }, newName) => {
  storage.get("a").set("name", newName);
  //               ^^^ Mutation goes here
}, []);

return (
  <input
    value={name}
    //     ^^^^ Reading uses simple values
    onClick={(e) => setName(e.currentTarget.value)}
  />
);
```

Even though in this contrived example it may look more complicated, in large
apps this pattern will vastly simplify your appâ€™s complexity.

<Banner title="Tip!">

See the [`useMutation`][] documentation to learn all the details, because it has
a lot more in store.

</Banner>

### Step 6: Get rid of `room.subscribe()` calls [@hidden]

Historically the only way to get full control over exactly when and how your
components would rerender was to use the low-level `room.subscribe()` API.

Most, if not all, of these use cases can be replaced by an equivalent, yet much
simpler call to `useStorage` with a selector function that does an equivalent
thing.

**Common use case: subscribing to nested data**  
If you are using `room.subscribe` to manually rerender components when nested
data changes, you can replace it by â€œjustâ€ selecting the nested fields youâ€™re
interested in. See [this example](#subscriptions).

```tsx
// âœ… Automatically rerenders if pets changes (but not more often)
const nested = useStorage((root) => root.scientist.pets);
```

**Common use case: subscribing to a computed value**  
If you are using `room.subscribe` to synchronize a computation based on multiple
storage values, you can replace it by â€œjustâ€ doing the computation in See
[this example](#multi-subscriptions).

```tsx
// âœ… Automatically rerenders if computed value changes
const sum = useStorage((root) => root.a + root.b);
```

If you have another use case for `room.subscribe` that you think isnâ€™t possible
to express in an equivalent `useStorage` call, please
[let us know about it](https://github.com/liveblocks/liveblocks/discussions/504).
Weâ€™re happy to help!

### Step 7: Get rid of manual batch calls [@hidden]

Most, if not all, cases of manually calling `useBatch` or `room.batch` should no
longer be needed and can be replaced by `useMutation`, which automatically
batches already!

Thatâ€™s it!

If you run into issues with these new patterns and you need help, please
[let us know](https://github.com/liveblocks/liveblocks/discussions/504). Weâ€™re
here to help!

[`usemutation`]: /docs/api-reference/liveblocks-react#useMutation
[`.toimmutable`]: /docs/api-reference/liveblocks-client#LiveObject.toImmutable

---
meta:
  title: "Upgrading to 0.19"
  parentTitle: "Upgrading"
  description: "Guide to upgrade to Liveblocks version 0.19"
---

In the Liveblocks 0.19 release, weâ€™re adding support for Zustand v4 to
`@liveblocks/zustand`. Zustand v4 brings greatly improved TypeScript types to
its APIs, enabling us to enhance the quality of our types, bringing it in line
with our React package.

Letâ€™s take a look!

## Upgrading steps by package

### @liveblocks/react [#react]

To update `@liveblocks/react` to 0.19, run the following command using your
preferred package manager:

```bash
npm install @liveblocks/client@0.19 @liveblocks/react@0.19
```

#### useOther now requires a selector argument [@hidden]

`useOther` now requires a
[selector](/docs/api-reference/liveblocks-react#selectors-receive-immutable-data)
function argument. You will need to replace instances of `useOther` that do not
use a selector in your codebase.

#### Previously âŒ [@hidden]

```tsx
const other = useOther(id); // ðŸ‘ˆ does not include a selector
```

#### Now âœ… [@hidden]

```tsx
const other = useOther(id, (other) => other); // ðŸ‘ˆ requires a selector
```

#### Include unstable_batchedUpdates if you use React 17 [@hidden]

Weâ€™ve added support to prevent the stale props/zombie child scenario. To avoid
this issue, we enforce passing the `unstable_batchedUpdates` prop to
`RoomProvider`.

<Banner title="You may not need this">

This section only applies if you are using React 17 or lower. You do not need to
do anything if you are using React 18 or higher.

</Banner>

```tsx highlight="2,8"
// âš ï¸ Only if youâ€™re using React 17 or lower
import { unstable_batchedUpdates } from "react-dom"; // ðŸ‘ˆ
<RoomProvider
  id="my-room"
  initialPresence={...}
  initialStorage={...}
  unstable_batchedUpdates={unstable_batchedUpdates}
>
  <App />
</RoomProvider>
```

For additional context, see the
[troubleshooting guide](/docs/platform/troubleshooting#stale-props-zombie-child)

### @liveblocks/redux [#redux]

To update `@liveblocks/redux` to 0.19, run the following command using your
preferred package manager:

```bash
npm install @liveblocks/client@0.19 @liveblocks/redux@0.19
```

#### Update use of default export liveblocksEnhancer [@hidden]

The main export has been renamed, so you will need to update your imports and
use of the enhancer:

#### Previously âŒ [@hidden]

```ts
import { enhancer } from "@liveblocks/redux";
```

#### Now âœ… [@hidden]

```ts
import { liveblocksEnhancer } from "@liveblocks/redux";
```

#### Remove the second argument to state.liveblocks.enterRoom [@hidden]

When calling `state.liveblocks.enterRoom()`, you should not pass an explicit
initial state. It will use the state in your Redux store, for consistency and
ease of use. To migrate, make the following code changes:

#### Previously âŒ [@hidden]

```ts
useEffect(() => {
  enterRoom("room-id", {
    todos: [], // ðŸ‘ˆ remove explicit initial state
  });
});
```

#### Now âœ… [@hidden]

```ts
useEffect(() => {
  enterRoom("room-id");
});
```

### @liveblocks/zustand [#zustand]

In 0.19 we added support for Zustand v4 (specifically v4.1.3 or higher) and will
no longer support Zustand v4.1.2 or lower. This is because Zustand v4.1.3 brings
greatly improved TypeScript types to its APIs, and consequently, we can improve
our internal types. To migrate, make the following code changes:

To update `@liveblocks/zustand` to 0.19, run the following command using your
preferred package manager:

```bash
npm install @liveblocks/client@0.19 @liveblocks/zustand@0.19
```

- Change these imports, if applicable, and rename accordingly:

#### Previously âŒ [@hidden]

```ts
import { middleware } from "@liveblocks/zustand";
import type { LiveblocksState } from "@liveblocks/zustand";
```

#### Now âœ… [@hidden]

```ts
import { liveblocks } from "@liveblocks/zustand";
import type { WithLiveblocks } from "@liveblocks/zustand";
```

- Update to the Zustand v4 recommended pattern:

#### Previously âŒ [@hidden]

```ts
create(liveblocks<MyState, ...>(...))
```

#### Now âœ… [@hidden]

```ts
create<WithLiveblocks<MyState, ...>>()(liveblocks(...))
```

To be clear:

1. First, move the type annotation away from the `liveblocks` middleware call,
   and onto the `create` call.
2. Next, wrap your `MyState` type in a `WithLiveblocks<...>` wrapper. This will
   make sure the injected `liveblocks` property on your Zustand state will be
   correctly typed.
3. Finally, make sure to add the extra call `()` wrapper, needed by Zustand v4
   now:
   ```ts
   create<WithLiveblocks<MyState, ...>>()(liveblocks(...))
   //                                  ^^ Not a typo
   ```

- Remove the second argument to `state.liveblocks.enterRoom()`: it no longer
  takes an explicit initial state. Instead, itâ€™s automatically be populated from
  your Zustand state.

## Improvements [#improvements]

This release brings several changes to `@liveblocks/react`, which improve
rendering performance and stability. Additionally, we have refactored our
internal packages to increase code sharing. You can review the
[release notes](https://github.com/liveblocks/liveblocks/releases) for more
details.

### @liveblocks/react [#react-improvements]

#### New shouldInitiallyConnect prop [@hidden]

We added a new property `shouldInitiallyConnect` to `RoomProvider`, which lets
you control whether or not the room connects to Liveblock servers. By default,
it will check the `typeof window` to determine if it should connect. When using
SSR, you can set it to `false` to prevent the room from connecting to Liveblocks
servers.

```tsx highlight="4"
<RoomProvider
  id="room"
  initialPresence={{}}
  shouldInitiallyConnect={false} // ðŸ‘ˆ control initial connection to Liveblocks
>
  <App />
</RoomProvider>
```

#### Addition of @liveblocks-core package [@hidden]

We restructured our internal packages to increase code sharing. You may notice a
new dependency in your dependency tree: `@liveblocks/core`. It contains private
APIs that arenâ€™t intended for direct consumption.

### @liveblocks/client [#client-improvements]

#### New shouldInitiallyConnect option [@hidden]

Similar to the [`shouldInitiallyConnect`](#react-shouldInitiallyConnect) prop in
`@liveblocks/react`, we added a `shouldInitiallyConnect` option to
`client.enter`. The default value is `true`. You may want to set it to `false`
when using SSR, or if you would prefer to establish the WebSocket connection
later.

```tsx
client.enter("room", {
  initialPresence: {},
  shouldInitiallyConnect: false, // ðŸ‘ˆ for SSR using the @liveblocks/client package
});
```

### @liveblocks/\* [#all]

All packages now provide an `isReadOnly` flag on user instances. It is available
by calling `getSelf()` and `getOthers`. `isReadOnly` is true when storage is
read-only, as well as when a user has `read` permission to the `room` and
`write` permission to `presence`.

```ts highlight="3,5"
const me = room.getSelf();

me.isReadOnly; // boolean

const others = room.getOthers();
for (const other of others) {
  other.isReadOnly; // boolean
}
```

You can learn more about room permissions under
[authentication](/docs/authentication).

Thatâ€™s it!

If you run into issues with these new patterns and you need help, please let us
know [by email](mailto:support@liveblocks.io) or by joining our
[Discord community](/discord)! Weâ€™re here to help!

---
meta:
  title: "Upgrading to 1.0"
  parentTitle: "Upgrading"
  description: "Guide to upgrade to Liveblocks version 1.0"
---

Liveblocks 1.0 is our first major release, marking the end of the beta period
for storage and conflict-free data types. This release includes improvements to
our pricing model that make billing more predictable. Additionally, we have
vastly improved the ability to animate cursors at up to 60fps by updating the
throttle option in `createClient`. The primary change you should note is the
transition to making the `userId` mandatory in the `authorize` option. This
change is in line with our [new pricing model](https://liveblocks.io/pricing).

Letâ€™s take a look!

## Upgrading steps by package

### @liveblocks/node [#node]

To update `@liveblocks/node` to 1.0, run the following command using your
preferred package manager:

```bash
npm install @liveblocks/node@1.0.0
```

#### Update the authorize option [@hidden]

We have updated the `authorize` method to make `userId` mandatory. This change
ties into our new [pricing model](https://liveblocks.io/pricing), which is based
on Monthly Active Users (MAU) instead of connections. We use `userId` to track
MAU associated with a Liveblocks account.

```ts highlight="20"
import { authorize } from "@liveblocks/node";

// Replace this key with your secret key provided at
// https://liveblocks.io/dashboard/projects/{projectId}/apikeys
const secret = "sk_prod_xxxxxxxxxxxxxxxxxxxxxxxx";

export default async function auth(req, res) {
  /**
   * Implement your own security here.
   *
   * Itâ€™s your responsibility to ensure that the caller of this endpoint
   * is a valid user by validating the cookies or authentication headers
   * and that it has access to the requested room.
   */
  const room = req.body.room;
  const response = await authorize({
    room,
    secret,
    // Corresponds to the UserMeta[id] type defined in liveblocks.config.ts
    userId: "123", // Required
    groupIds: ["456"], // Optional
    userInfo: {
      // Optional, corresponds to the UserMeta[info] type defined in liveblocks.config.ts
      name: "Ada Lovelace",
      color: "red",
    },
  });
  return res.status(response.status).end(response.body);
}
```

If you do not use the `authorize` function because you are using the public API
key method, a cookie will be set in the browser when a user connects to a room.
This cookie will be used to track MAU associated with a Liveblocks account and
will expire after 30 days.

### Authorize endpoint [#authorize-endpoint]

If you do not use the `authorize` function, but call the `authorize` endpoint
with a secret key instead, you should pass the `userId` even though it is not
mandatory on the API level because the userID will be used for MAU. Set the
`Authorization: Bearer` header to your secret key.

```ts
POST https://api.liveblocks.io/v2/rooms/{roomId}/authorize
```

Set the following the request body:

```ts highlight="3"
{
  "userId": "user123",
  "groupIds": [
    "g1",
    "g2"
  ],
  "userInfo": {
    "name": "bob",
    "colors": [
      "blue",
      "red"
    ]
  }
}
```

## Improvements [#improvements]

We added additional features to [Webhooks](/docs/platform/webhooks),
enhancements to the `Room` class, and more. You can review the
[release notes](https://github.com/liveblocks/liveblocks/releases) for more
details.

### @liveblocks/client [#client-improvements]

To update `@liveblocks/client` to 1.0, run the following command using your
preferred package manager:

```bash
npm install @liveblocks/client@1.0.0
```

#### Improvements to throttle allow animation of up to 60fps [@hidden]

You can now specify the `throttle` option in
[`createClient`](https://liveblocks.io/docs/api-reference/liveblocks-client#createClientThrottle)
that can go as low as 16ms. If not set, the default value is 100ms.

```ts highlight="5"
import { createClient } from "@liveblocks/client";

const client = createClient({
  /* ... other options ... */
  throttle: 16,
});
```

You can see the marked improvement in the animation from 80ms (original limit)
to 16ms in this
[tweet](https://twitter.com/ctnicholasdev/status/1622656511758700546). If you
want to try it out for yourself, check out
[live cursors example](https://liveblocks.io/examples/live-cursors/nextjs).

#### New methods available on the Room class [@hidden]

We added new methods to the `Room` class that you can use to obtain the storage
status of a room, subscribe to storage status changes, or reconnect to a room
whenever necessary. You can also use the
[Liveblocks DevTools extension](/devtools) to visualize realtime changes to
storage while implementing these changes.

Use `room.getStorageStatus` to retrieve the storage status of a room. The
statuses are:

- `not-loaded`: Initial state when entering the room.
- `loading`: Once the storage has been requested via room.getStorage().
- `synchronizing`: When some local updates have not been acknowledged by
  Liveblocks servers.
- `synchronized`: Storage is in sync with Liveblocks servers.

Use `room.subscribe` to subscribe to storage status changes. This method returns
an unsubscribe function.

```ts
room.subscribe("storage-status", (status) => {
  // Implement your logic here
  switch (status) {
    case "not-loaded":
      break;
    case "loading":
      break;
    case "synchronizing":
      break;
    case "synchronized":
      break;
    default:
      break;
  }
});
```

You can use `room.reconnect()` to close the room connection and try to
[reconnect](/docs/api-reference/liveblocks-client#Room.reconnect).

### @liveblocks/node [#node-improvements]

#### Webhooks enhancements [@hidden]

We have added two new events to our Webhooks functionality: `RoomCreatedEvent`
and `RoomDeletedEvent`. We have also added a `WebhookHandler` class to make it
easier to verify event requests from Liveblocksâ€™ Webhooks functionality. It also
provides fully typed `WebhookEvents`.

```ts
import { WebhookHandler } from "@liveblocks/node";

const webhookHandler = new WebhookHandler(process.env.SECRET);

const event = webhookHandler.verifyRequest({
  headers: req.headers,
  rawBody: req.body,
});
```

Verification of events is critical to ensure that the events are coming from
Liveblocks and not from a malicious source. Check out our
[Webhooks guide](https://liveblocks.io/docs/platform/webhooks) for more details.

Thatâ€™s it!

If you have issues with these new patterns and need help, please let us know
[by email](mailto:support@liveblocks.io) or by joining our
[Discord community](/discord)! Weâ€™re here to help!

---
meta:
  title: "Upgrading to 1.10"
  parentTitle: "Upgrading"
  description: "Guide to upgrade to Liveblocks version 1.10"
---

Notifications is the first Liveblocks product that works across multiple rooms,
and this has required us to introduce breaking changes to ensure a consistent
API for Comments and Notifications.

## How to upgrade? [#how]

You can upgrade to 1.10 by downloading the latest version of each Liveblocks
package youâ€™re using, for example in a React app:

```bash
npm install @liveblocks/client@latest @liveblocks/react@latest @liveblocks/react-ui@latest @liveblocks/node@latest
```

<Banner title="Update every Liveblocks package">

If youâ€™re using any other Liveblocks packages make sure to update those too.

</Banner>

## All changes are for Comments and Notifications

If youâ€™re not using Comments or Notifications, there are no breaking changes for
you! However, if you are using these, or intend to use them in future, keep
reading.

## Security

Users must see the notifications across multiple rooms when they open their
inbox. This is the first time we must expose an API not associated with a single
room. It forced us to introduce a minor breaking change in our authentication
mechanism. Using
[`useInboxNotifications`](/docs/api-reference/liveblocks-react#useInboxNotifications)
will call your authentication endpoint without a `room`.

### createClient with callback

If you use `createClient` with `authEndpoint`
[as a callback](/docs/api-reference/liveblocks-client#createClientCallback),
`room` is now optional.

```typescript
const client = createClient({
  authEndpoint: (room) => {
    // The `room` argument will be `undefined` if you're using `useInboxNotifications`
  },
});
```

## Comments resolver functions

Notifications needs to resolve users, as well as Comments, so weâ€™ve lifted the
resolver functions from `createRoomContext` to `createClient`.

Before:

```tsx file="liveblocks.config.ts" highlight="7-12"
// âŒ Before - Liveblocks 1.9
const client = createClient({
  authEndpoint: "/api/liveblocks-auth",
});

const { RoomProvider } = createRoomContext({
  async resolveUsers({ userIds, roomId }) {
    // ...
  },
  async resolveMentionSuggestions({ text, roomId }) {
    // ...
  },
});
```

After:

```tsx file="liveblocks.config.ts" highlight="4-9"
// âœ… After - Liveblocks 1.10
const client = createClient({
  authEndpoint: "/api/auth/liveblocks-auth",
  async resolveUsers({ userIds }) {
    // ...
  },
  async resolveMentionSuggestions({ text }) {
    // ...
  },
});

const { RoomProvider } = createRoomContext();
```

Because the resolvers are no longer room-based, youâ€™ll notice that `roomId` is
no longer in the parameters.

### Resolver types

Because the resolvers have moved to the `client`, the `ResolveUsersArgs` and
`ResolveMentionSuggestionsArgs` types are now exported from `@liveblocks/client`
instead of `@liveblocks/react`.

```tsx highlight="5,11"
// âŒ Before - Liveblocks 1.9
import {
  ResolveUsersArgs,
  ResolveMentionSuggestionsArgs,
} from "@liveblocks/react";

// âœ… After - Liveblocks 1.10
import {
  ResolveUsersArgs,
  ResolveMentionSuggestionsArgs,
} from "@liveblocks/client";
```

Relatedly,
[`stringifyCommentBody`](/docs/api-reference/liveblocks-node#stringify-comment-body)â€™s
`CommentBodyResolveUsersArgs` no longer exists, and you should use
`ResolveUsersArgs` instead.

```tsx highlight="5,11"
// âŒ Before - Liveblocks 1.9
import { CommentBodyResolveUsersArgs } from "@liveblocks/node";

// âœ… After - Liveblocks 1.10
import { ResolveUsersArgs } from "@liveblocks/node";
```

## Comments CSS variables

Some `elevation` and `tooltip`
[CSS variables](/docs/api-reference/liveblocks-react-ui#CSS-variables) have been
removed:

- `--lb-tooltip-background`
- `--lb-tooltip-foreground`
- `--lb-tooltip-foreground-contrast`
- `--lb-elevation-background`
- `--lb-elevation-foreground`
- `--lb-elevation-foreground-contrast`

Because these no longer exist, we recommend using the basic `--lb-*` variables
directly on `.lb-elevation` or `.lb-tooltip `.

Before:

```css
/* âŒ Before - Liveblocks 1.9 */
:root {
  --lb-tooltip-foreground: white;
  --lb-elevation-background: red;
}
```

After:

```css
/* âœ… After - Liveblocks 1.10 */
.lb-tooltip {
  --lb-foreground: white;
}

.lb-elevation {
  --lb-background: red;
}
```

## Comments overrides

Comments overrides allows you to replace a string or node in default components,
with another that youâ€™ve specified. Some overrides have been changed.

- `SELF` is now `USER_SELF`.
- `UNKNOWN_USER` is now `USER_UNKNOWN`.
- `COMMENT_REACTION_REMAINING` no longer exists, and you should use the
  `LIST_REMAINING_USERS` instead.
- `COMMENT_REACTION_TOOLTIP` is now `COMMENT_REACTION_LIST`, and its arguments
  have been changed to `(list, emoji, count)`.

Before:

```tsx highlight="4-7"
// âŒ Before - Liveblocks 1.9
<CommentsConfig
  overrides={{
    SELF: "you",
    UNKNOWN_USER: "Anon",
    COMMENT_REACTION_REMAINING: (others) => `${others} people`,
    COMMENT_REACTION_TOOLTIP: (emoji, list) => (
      <>
        {list} reacted with {emoji}
      </>
    ),
  }}
/>
```

After:

```tsx highlight="4-7"
// âœ… After - Liveblocks 1.10
<CommentsConfig
  overrides={{
    USER_SELF: "you",
    USER_UNKNOWN: "Anon",
    LIST_REMAINING_USERS: (others) => `${others} people`,
    COMMENT_REACTION_LIST: (list, emoji, count) => (
      <>
        {list} reacted with {emoji}
      </>
    ),
  }}
/>
```

When upgrading, remember that overrides can be applied both globally with
`<CommentsConfig>`, and per component, e.g. `<Composer>`. Learn more in the
[overrides API reference](/docs/api-reference/liveblocks-react-ui#Overrides).

---
meta:
  title: "Upgrading to 1.2"
  parentTitle: "Upgrading"
  description: "Guide to upgrade to Liveblocks version 1.2"
---

There are no breaking changes in this update, however we are introducing a new
authentication method. If youâ€™re currently using `createClient()` with the
`authEndpoint` option, we recommend you read on.

Liveblocks 1.2 provides new ways to specify who can access certain rooms, and
with which permissions they can enter. Our new-style security tokens also bring
speed improvements, allowing clients to connect Liveblocks rooms even quicker,
as well as permitting authorization tokens that can be used for multiple rooms.

## Public key authentication changes [#public-auth-changes]

<Banner type="success" title="No changes required">
  If youâ€™re currently using Liveblocks **public keys**, no changes are required.
</Banner>

With Liveblocks 1.2, entering rooms with your public key will be noticeably
quicker. If youâ€™re currently using Liveblocks public keys, no changes are
required to your application.

## Private key authentication changes [#private-auth-changes]

<Banner type="warning" title="We recommend changing your auth back end">
  If youâ€™re currently using Liveblocks **private keys** we **highly recommend**
  you upgrade your auth back end.
</Banner>

Upgrading your existing auth back end will opt you in to using our new-style
auth tokens, which offer the following benefits:

- Grant users permission to multiple rooms in one transaction, meaning fewer
  requests on your back end.
- Much quicker to join rooms, particularly any after the first.
- Unlock access to upcoming features, such as [Comments](/comments).

If youâ€™re currently using Liveblocks private keys, no changes are strictly
necessary, but we do highly recommend you upgrade your applicationâ€™s back end.

## How to upgrade? [#how]

You can upgrade to 1.2 by downloading the latest version of each Liveblocks
package youâ€™re using, for example in a React app:

```bash
npm install @liveblocks/client@latest @liveblocks/node@latest @liveblocks/react@latest
```

<Banner title="Update every Liveblocks package">

If youâ€™re using any other Liveblocks packages make sure to update those too.

</Banner>

Weâ€™ll walk you through the necessary changes below, but first, if you currently
have a Liveblocks application in production, we recommend following a rollout
plan, to prevent any users running an old Liveblocks client, during the upgrade,
from having issues.

### Rollout plan

<Steps>
  <StepCompact>
    Keep your existing back end endpoint (e.g. `/api/auth`).
  </StepCompact>

<StepCompact>
  Create a new authentication endpoint for the upgrade (e.g.
  `/api/liveblocks-auth`).
</StepCompact>

<StepCompact>
  In your front end, point `createClient()`â€™s `authEndpoint` URL to the new
  endpoint.
</StepCompact>

<StepCompact>Done! You can deploy your application now.</StepCompact>

  <StepCompact lastStep>
    Later, when all your applicationâ€™s clients have been upgraded to the latest version, you can safely remove the old endpoint.
  </StepCompact>
</Steps>

## Deciding which token to use [#deciding]

In Liveblocks 1.2 there are two new ways to authenticate with
`@liveblocks/node`.

- [Access tokens](#access-tokens) are recommend for most applications.
- [ID tokens](#id-tokens) are best if youâ€™re using fine-grained permissions with
  our REST API.

Access tokens and ID tokens both allow for multiple room support, but have
different sources of truth. The old authentication method, single-room tokens
with `authorize`, is still supported but will eventually be deprecated.

## Access tokens [#access-tokens]

Access tokens are the new recommended way to authenticate, because theyâ€™re easy
to manage from your custom back end. They follow the analogy of a _hotel key
card_. Anyone that has a key card can enter any room that the card gives access
to. Itâ€™s easy to give out these key cards right from your back end.

### Upgrading to access tokens [#upgrade-to-access-tokens]

First, create a new endpoint in your back end, next to your existing `/api/auth`
endpoint. We recommend going with `/api/liveblocks-auth`.

Letâ€™s implement it to issue tokens that would be equivalent to your current
single-room token based setup.

<Steps>

  <Step>
    <StepTitle>Create a client</StepTitle>
    <StepContent>
    Create a Node.js client that allows you to interact with our REST API.
      ```tsx
      import { Liveblocks } from "@liveblocks/node";

      const liveblocks = new Liveblocks({
        secret: "sk_prod_xxxxxxxxxxxxxxxxxxxxxxxx",
      });
      ```
    </StepContent>

  </Step>

  <Step>
    <StepTitle>Start an auth session inside your endpoint</StepTitle>
    <StepContent>
    Every session should have a unique user ID, which is typically the ID of the user in your database.
      ```tsx highlight="10-13"
      import { Liveblocks } from "@liveblocks/node";

      const liveblocks = new Liveblocks({
        secret: "sk_prod_xxxxxxxxxxxxxxxxxxxxxxxx",
      });

      export async function POST(request) {
        const user = { id: "olivier@example.com", info: { name: "Olivier" }};

        const session = liveblocks.prepareSession(
          user.id,
          { userInfo: user.info } // Optional
        );
      }
      ```
    </StepContent>

  </Step>

  <Step>
    <StepTitle>Give the user access to the room</StepTitle>
    <StepContent>
    Give if the current user access to the room, with either `session.FULL_ACCESS`, or `session.READ_ACCESS`.
      ```tsx highlight="15,16"
      import { Liveblocks } from "@liveblocks/node";

      const liveblocks = new Liveblocks({
        secret: "sk_prod_xxxxxxxxxxxxxxxxxxxxxxxx",
      });

      export async function POST(request) {
        const user = { id: "olivier@example.com", info: { name: "Olivier" }};

        const session = liveblocks.prepareSession(
          user.id,
          { userInfo: user.info } // Optional
        );

        const { room } = await request.json();
        session.allow(room, session.FULL_ACCESS);
      }
      ```
    </StepContent>

  </Step>

  <Step>
    <StepTitle>Authorize the user and return the result</StepTitle>
    <StepContent>
    Give if the current user access to the room, with either `session.FULL_ACCESS`, or `session.READ_ACCESS`.
      ```tsx highlight="18,19"
      import { Liveblocks } from "@liveblocks/node";

      const liveblocks = new Liveblocks({
        secret: "sk_prod_xxxxxxxxxxxxxxxxxxxxxxxx",
      });

      export async function POST(request) {
        const user = { id: "olivier@example.com", info: { name: "Olivier" }};

        const session = liveblocks.prepareSession(
          user.id,
          { userInfo: user.info } // Optional
        );

        const { room } = await request.json();
        session.allow(room, session.FULL_ACCESS);

        const { status, body } = await session.authorize();
        return new Response(body, { status });
      }
      ```
    </StepContent>

  </Step>

  <Step>
    <StepTitle>Point to the new endpoint</StepTitle>
    <StepContent>
    In the front end of your app, update your `liveblocks.config.ts` file to connect to the new endpoint.
    ```ts file="liveblocks.config.ts" highlight="4"
      import { createClient } from "@liveblocks/client";

      const client = createClient({
        authEndpoint: "/api/liveblocks-auth",
      });
      ```
    </StepContent>

  </Step>

<Step>
  <StepTitle>Youâ€™re migrated!</StepTitle>
  <StepContent>
    Youâ€™ve successfully migrated, and now have a similar authentication set up
    as before! However, there are other new features we can take advantage of.
  </StepContent>
</Step>

  <Step lastStep>
    <StepTitle>Bonus: Issue access to multiple rooms</StepTitle>
    <StepContent>
    With Liveblocks 1.2, you can also issue access to multiple rooms, or even use a prefix-based wildcard in the room name, enabling any amount of rooms! You can learn more about this in our [access token](/docs/authentication/access-token#permissions) guide.
      ```tsx highlight="15-18"
      import { Liveblocks } from "@liveblocks/node";

      const liveblocks = new Liveblocks({
        secret: "sk_prod_xxxxxxxxxxxxxxxxxxxxxxxx",
      });

      export async function POST(request) {
        const user = { id: "olivier@example.com", info: { name: "Olivier" }};

        const session = liveblocks.prepareSession(
          user.id,
          { userInfo: user.info } // Optional
        );

        const { room } = await request.json();
        session.allow(room, session.FULL_ACCESS);
        session.allow("my-room-*", session.READ_ACCESS);
        session.allow("my-other-room", session.READ_ACCESS);

        const { status, body } = await session.authorize();
        return new Response(body, { status });
      }
      ```
    </StepContent>

  </Step>

</Steps>

### Learn more about access tokens

You can find guides for your specific framework and learn more about permissions
in our [access tokens authentication guides](/docs/authentication/access-token).

Hereâ€™s a full working example of access tokens in a Next.js endpoint.

```ts file="app/api/liveblocks-auth/route.ts" isCollapsed isCollapsable
import { Liveblocks } from "@liveblocks/node";

// Create a client
const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

export async function POST(request: Request) {
  const user = __getUserFromDB__(request);

  // Start an auth session inside your endpoint
  const session = liveblocks.prepareSession(
    user.id,
    { userInfo: user.metadata } // Optional
  );

  // Give the user access to the room
  const { room } = await request.json();
  if (room && __shouldUserHaveAccess__(user, room)) {
    // e.g. session.allow("my-room", ["room:write"])
    session.allow(room, session.FULL_ACCESS);
  }

  // Authorize the user and return the result
  const { status, body } = await session.authorize();
  return new Response(body, { status });
}
```

## ID tokens [#id-tokens]

Are you already using our REST API to assign fine-grained permissions to each
room, via [Create room](/docs/api-reference/rest-api-endpoints#post-rooms) or
[Update room](/docs/api-reference/rest-api-endpoints#post-rooms-roomId) APIs? If
so, ID tokens may work best for you.

ID tokens follow the analogy of a _membership card_. Anyone with that membership
card can try to enter a room, but your permissions will be checked at the door.
This approach to permissions is most powerful because it can be set up very
finely, but it comes at the cost of having to keep those permissions
programmatically in sync with Liveblocks. We recommend it for advanced use cases
only.

### Upgrading to ID tokens [#upgrade-to-id-tokens]

If youâ€™ve already set up room permissions using our REST API, then this should
be easy!

First, letâ€™s create a new endpoint in your back end, next to your existing
`/api/auth` endpoint. We recommend going with `/api/liveblocks-auth`.

All you have to do now is implement it as follows:

<Steps>

  <Step>
    <StepTitle>Create a client</StepTitle>
    <StepContent>
    Create a Node.js client that allows you to interact with our REST API.
      ```tsx
      import { Liveblocks } from "@liveblocks/node";

      const liveblocks = new Liveblocks({
        secret: "sk_prod_xxxxxxxxxxxxxxxxxxxxxxxx",
      });
      ```
    </StepContent>

  </Step>

  <Step>
    <StepTitle>Identify the user and return the result</StepTitle>
    <StepContent>
    Whichever `userId` (or `groupIds`) you pass will be used to check the permissions you configured in your Liveblocks account already.
      ```tsx highlight="10-15"
      import { Liveblocks } from "@liveblocks/node";

      const liveblocks = new Liveblocks({
        secret: "sk_prod_xxxxxxxxxxxxxxxxxxxxxxxx",
      });

      export async function POST(request) {
        const user = { id: "olivier@example.com", info: { name: "Olivier" }};

        const { status, body } = await liveblocks.identifyUser({
          userId: user.id,
          groupIds, // Optional
        });

        return new Response(body, { status });
      }
      ```
    </StepContent>

  </Step>

  <Step>
    <StepTitle>Point to the new endpoint</StepTitle>
    <StepContent>
    In the front end of your app, update your `liveblocks.config.ts` file to connect to the new endpoint.
    ```ts file="liveblocks.config.ts" highlight="4"
      import { createClient } from "@liveblocks/client";

      const client = createClient({
        authEndpoint: "/api/liveblocks-auth",
      });
      ```
    </StepContent>

  </Step>

<Step>
  <StepTitle>Youâ€™re migrated!</StepTitle>
  <StepContent>Youâ€™ve successfully migrated to id tokens!</StepContent>
</Step>

  <Step lastStep>
    <StepTitle>Bonus: Use our REST API to handle permissions</StepTitle>
    <StepContent>
    ID tokens use permissions set with our [REST API](/docs/api-reference/rest-api-endpoints).
    For example, this is how you [create a room](/docs/api-reference/rest-api-endpoints#post-rooms),
    and give a user full access.

    ```ts highlight="6-8"
    fetch("https://api.liveblocks.io/v2/rooms", {
      method: "POST",
      body: JSON.stringify({
        id: "my-room-name",
        defaultAccesses: [],
        usersAccesses: {
          "olivier@example.com": ["room:write"]
        }
      }),
    });
    ```
    </StepContent>

  </Step>
</Steps>

### Learn more about ID tokens

You can find guides for your specific framework and learn more about permissions
in our [ID tokens authentication guides](/docs/authentication/id-token).

Hereâ€™s a full working example of ID tokens in a Next.js endpoint.

```ts file="app/api/liveblocks-auth/route.ts" isCollapsed isCollapsable
import { Liveblocks } from "@liveblocks/node";

// Create a client
const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

export async function POST(request: Request) {
  const user = __getUserFromDB__(request);

  // Identify the user and return the result
  const { status, body } = await liveblocks.identifyUser({
    userId: user.id,
    groupIds, // Optional
  });

  return new Response(body, { status });
}
```

If you have issues with these new patterns and need help, please let us know
[by email](mailto:support@liveblocks.io) or by joining our
[Discord community](/discord)! Weâ€™re here to help!

---
meta:
  title: "Upgrading to 1.5"
  parentTitle: "Upgrading"
  description: "Guide to upgrade to Liveblocks version 1.5"
---

Thereâ€™s a small breaking changes in this update, as weâ€™re introducing a better
API to enter and leave rooms. If youâ€™re calling `client.enter()` or
`client.leave()` in your application, or using our Zustand or Redux packages, we
recommend you read on.

## How to upgrade? [#how]

You can upgrade to 1.5 by downloading the latest version of each Liveblocks
package youâ€™re using, for example in a React app:

```bash
npm install @liveblocks/client@latest @liveblocks/node@latest @liveblocks/react@latest
```

<Banner title="Update every Liveblocks package">

If youâ€™re using any other Liveblocks packages make sure to update those too.

</Banner>

## Recommended: new enter/leave API

Until now, the API to manually enter a Room using the client looked like the
following:

```tsx
// âŒ We recommend you stop using this API
const room = client.enter("my-room", options);

// Then later, when unmounting
client.leave("my-room");
```

These APIs will remain supported and unchanged, but starting with Liveblocks
1.5, there is a new preferred API, which we recommend you switch to:

```tsx
// âœ… Prefer this API instead
const { room, leave } = client.enterRoom("my-room", options);

// Then later, when unmounting
leave();
```

Weâ€™ve changed this API to return a new â€œleaveâ€ function every time a room
reference is requested. This allows sharing the same room connection with two or
more parts of your application, without those parts competing for control of the
room connection. The room connection will only be terminated after every `leave`
function has been called.

This enables more advanced use cases such as supporting multiple `RoomProvider`
instances for the same room ID, in different parts of your application, or using
our React package for one part of your application, while using a Zustand store
for another.

## Upgrading for Zustand users

If youâ€™re using our Zustand package, thereâ€™s a breaking changeâ€”you no longer
need to pass the room ID to leave the room:

```tsx
const {
  liveblocks: { leaveRoom },
} = useStore();

// âŒ Before
leaveRoom("my-room-name");

// âœ… After
leaveRoom();
```

## Upgrading for Redux users

If youâ€™re using our Redux package, thereâ€™s a similar breaking changeâ€”you no
longer need to pass the room ID to leave the room:

```tsx
const dispatch = useDispatch();

// âŒ Before
dispatch(actions.leaveRoom("my-room-name"));

// âœ… After
dispatch(actions.leaveRoom());
```

---
meta:
  title: "Upgrading to 1.9"
  parentTitle: "Upgrading"
  description: "Guide to upgrade to Liveblocks version 1.9"
---

Thereâ€™s a tiny breaking change related to Comments in this update. Each date
returned is now a `Date` object, whereas previously each was a `string`.

## How to upgrade? [#how]

You can upgrade to 1.9 by downloading the latest version of each Liveblocks
package youâ€™re using, for example in a React app:

```bash
npm install @liveblocks/client@latest @liveblocks/react@latest @liveblocks/react-comments@latest @liveblocks/node@latest
```

<Banner title="Update every Liveblocks package">

If youâ€™re using any other Liveblocks packages make sure to update those too.

</Banner>

## Dates are no longer strings

Each date returned from Comments is now a `Date` object, whereas previously each
was a `string`. An example of this is `createdAt`, a value attached to each
thread.

Before:

```tsx
// âŒ Before - Liveblocks 1.8
const { threads } = useThreads();

// "2023-12-15T14:15:22Z"
console.log(threads[0].createdAt);
```

After:

```tsx
// âœ… After - Liveblocks 1.9
const { threads } = useThreads();

// Date <Fri Dec 15 2023 14:15:22 GMT+0000 (Greenwich Mean Time)>
console.log(threads[0].createdAt);
```

Every Comments-related date has been updated, such as `createdAt`, `updatedAt`
properties in threads, and `editedAt`, `deletedAt` in comments, so take care to
check every date instance youâ€™re using. Itâ€™s likely that no changes are required
after this update.

---
meta:
  title: "Upgrading to 2.0"
  parentTitle: "Upgrading"
  description: "Guide to upgrade to Liveblocks version 2.0"
---

Liveblocks 2.0 is our second major release, and focuses on removing any rough
edges and smoothening the developer experience. It makes Liveblocks simpler to
set up for new users as well as for existing users. Our long term goal is to
empower you to write and evolve your apps in the best way possible, and at
enterprise scale.

<Banner title="Just want to upgrade?">

Skip ahead to the [how to upgrade](#how-to-upgrade) section.

</Banner>

## Rationale

Liveblocks has always embraced the benefits of static typing with TypeScript.
Roughly two years ago, we published 0.17, which
[introduced](/blog/whats-new-in-v0-17) the pattern of calling
`createRoomContext()` and returning a â€œbundleâ€ of type-safe hooks that you could
then use in your application. This pattern worked nicely because all the hooks
were bound to your custom type definitions for `Presence`, `Storage`, etc. in
one single place, and every Liveblocks API would deeply know about it. No need
for manual type annotations anywhere else in your codebase.

### Downsides to this approach

There were, however, a couple of downsides to this approach that have always
kept itching:

- Importing hooks from a local config file was a little bit awkward. It wasnâ€™t
  an all too familiar pattern for most users.
- Re-exporting the list of hooks took maintenance. If we added a new hook, youâ€™d
  have to also re-export it manually.
- Due to how TypeScript works, the type params youâ€™d provide to
  `createRoomContext()` had a fixed ordering to them. If you wanted to specify
  only `Presence` and `RoomEvent`, youâ€™d have to â€œskipâ€ some type params, by
  doing `createRoomContext<Presence, {}, {}, RoomEvent>()` or similar.

### Introducing Liveblocks 2.0

With 2.0, this all becomes a lot simpler. Weâ€™ve done a lot of internal
refactoring to make this possible. Weâ€™ll dive in soon, but here is a sneak peek:

```tsx showLineNumbers={false} file="liveblocks.config.ts"
// âŒ This pattern is no longer recommended unless you need multiple room types
export const {
  suspense: { RoomProvider, useRoom, useThread },
} = createRoomContext<
  MyPresence,
  MyStorage,
  MyUserMeta,
  MyRoomEvent,
  MyThreadMetadata
>(client);

// âœ… After
declare global {
  // These custom types are all optional, just define the ones you want/need
  interface Liveblocks {
    Presence: MyPresence;
    Storage: MyStorage;
    UserMeta: MyUserMeta;
    RoomEvent: MyRoomEvent;
    ThreadMetadata: MyThreadMetadata;
  }
}
```

```tsx showLineNumbers={false} file="Component.tsx"
// âŒ Before
import { RoomProvider, useRoom, useThreads } from "./liveblocks.config.ts";

// âœ… After
import { RoomProvider, useRoom, useThreads } from "@liveblocks/react/suspense";
// or
import { RoomProvider, useRoom, useThreads } from "@liveblocks/react";
```

Weâ€™ll first go over all the breaking changes, then weâ€™ll show you how to
simplify your codebase.

## How to upgrade [#how-to-upgrade]

First of all, letâ€™s upgrade all Liveblocks dependencies to their latest
versions. The easiest way to do that is to run the following command:

```bash
npx create-liveblocks-app@latest --upgrade
```

There are also some **breaking changes** in this update. **Most users will not
run into any of these**, but there is a chance that some of these will affect
your situation. Making the necessary code adjustments should however be easy. In
many cases, we provide a codemod that makes the actual change for you, so you
donâ€™t have to do so manually.

### Breaking change 1: renamed package [#bc1]

<Banner>

This breaking change only affects users of `@liveblocks/react-comments`.

</Banner>

Weâ€™ve renamed our package `@liveblocks/react-comments` to
`@liveblocks/react-ui`, because our library of pre-built UI components now
contains more than just Comments-related components. Please adjust your imports.

Run the following **codemod** or manually make the changes:

```bash
npx @liveblocks/codemod@latest react-comments-to-react-ui
```

This will change your imports like this:

```tsx showLineNumbers={false}
// âŒ Before
import { Thread } from "@liveblocks/react-comments";

// âœ… After
import { Thread } from "@liveblocks/react-ui";
```

And also:

```tsx showLineNumbers={false}
// âŒ Before
<CommentsConfig />

// âœ… After
<LiveblocksUIConfig />
```

### Breaking change 2: renamed exports in our Node package [#bc2]

<Banner>

This breaking change only affects users of `@liveblocks/node`.

</Banner>

To avoid confusion with the newly introduced custom
[`RoomInfo`](#New-custom-type-RoomInfo) type, weâ€™ve renamed the `RoomInfo` type
in our `@liveblocks/node` package.

Run the following **codemod** or manually make the changes:

```bash
npx @liveblocks/codemod@latest room-info-to-room-data
```

This will change:

```tsx showLineNumbers={false}
// âŒ Before
import { RoomInfo } from "@liveblocks/node";
const rooms: RoomInfo[] = [];

// âœ… After
import { RoomData } from "@liveblocks/node";
const rooms: RoomData[] = [];
```

### Breaking change 3: client methods from our Node package no longer take type params [#bc3]

<Banner>

This breaking change only affects users of `@liveblocks/node`.

</Banner>

In `@liveblocks/node`, none of the client methods, like
`liveblocks.getThread()`, take type params any longer.

Make the following changes:

```tsx showLineNumbers={false}
// âŒ Before
await liveblocks.createThread<MyThreadMetadata>();
await liveblocks.editThreadMetadata<MyThreadMetadata>();
await liveblocks.getThreads<MyThreadMetadata>();
await liveblocks.getThread<MyThreadMetadata>();
//                         ^^^^^^^^^^^^^^^^ No longer possible

// âœ… After
await liveblocks.createThread();
await liveblocks.editThreadMetadata();
await liveblocks.getThreads();
await liveblocks.getThread();

// In liveblocks.config.ts
declare global {
  interface Liveblocks {
    ThreadMetadata: MyThreadMetadata;
  }
}
```

You should use global type augmentation instead. Please see
[â€œSimplifying your Liveblocks applicationâ€](#simplifying) below for a lot more
detail on this transition.

### Breaking change 4: changed default export to named export in Yjs package [#bc4]

<Banner>

This breaking change only affects users of `@liveblocks/yjs`.

</Banner>

To make discoverability and refactorings easier, and to avoid confusion with the
newly introduced [`LiveblocksProvider`][] in our React package, weâ€™re no longer
using default exports, but named exports only.

Run the following **codemod** or manually make the changes:

```bash
npx @liveblocks/codemod@latest remove-yjs-default-export
```

This will change your import (and its usage) like this:

```tsx showLineNumbers={false}
// âŒ Before
import LiveblocksProvider from "@liveblocks/yjs";
const yDoc = new Y.Doc();
const yProvider = new LiveblocksProvider(room, yDoc);
```

```tsx showLineNumbers={false}
// âœ… After
import { LiveblocksYjsProvider } from "@liveblocks/yjs";
const yDoc = new Y.Doc();
const yProvider = new LiveblocksYjsProvider(room, yDoc);
```

### Breaking change 5: minor LiveList constructor change [#bc5]

<Banner>

This breaking change only affects users of Storage.

</Banner>

The `LiveList()` constructorâ€™s argument is no longer optional, because it causes
unneeded but confusing type inference issues.

Run the following **codemod** or manually make the changes:

```bash
npx @liveblocks/codemod@latest live-list-constructor
```

This will add an array to empty `LiveList` constructors:

```tsx showLineNumbers={false}
// âŒ Before
const mylist = new LiveList();

// âœ… After
const mylist = new LiveList([]);
```

### Breaking change 6: new webhook event types [#bc6]

<Banner>

This breaking change only affects users of webhooks.

</Banner>

The webhook event `NotificationEvent`â€™s type can represent multiple kinds of
notifications: `"thread"`, `"textMention"`, and custom ones (e.g.
`"$myNotification"`).

If you were using properties only available on the `"thread"` kind (e.g.
`threadId`), you will need to first check for the kind of notification before
accessing them.

```ts showLineNumbers={false}
// âŒ Before
const threadId = event.data.threadId;

// âœ… After
if (event.data.kind === "thread") {
  const threadId = event.data.threadId;
}
```

### Breaking change 7: removed deprecated APIs [#bc7]

All of the following APIs have been removed in 2.0, as they were deprecated
multiple versions ago.

**Affecting `@liveblocks/client`:**

- `Client.enter()` has been replaced by `Client.enterRoom()`
- `Client.leave()` has been replaced by `Client.enterRoom()`, which returns a
  `leave` function
- Client option `fetchPolyfill`, `WebSocketPolyfill`, are replaced by
  `polyfills: { fetch, WebSocket }`
- Legacy option `shouldInitiallyConnect` is now renamed to `autoConnect`
- Legacy connection status APIs, e.g. `room.getConnectionState()` and
  `.subscribe("connection")`. You can use `.getStatus()` or
  `.subscribe("status")` instead.
- `user.isReadOnly` field is replaced by `!user.canWrite` (note the negation
  here)
- The `Others<P, U>` type. Please change to `readonly User<P, U>[]`.

**Affecting `@liveblocks/react`:**

- The `useMap`, `useList`, and `useObject` hooks. These have been deprecated
  since the release of 0.18 (more than two years ago). Please see
  [the 0.18 upgrade guide](/docs/platform/upgrading/0.18#Step-5a:-Replace-reads-with-useStorage)
  for tips on how to rewrite these hooks to `useStorage`.
- The second argument `options` to `createRoomContext(client, options)` has been
  removed. These options have been moved to the client.

**Affecting `@liveblocks/node`:**

- Remove legacy `authorize` method from `@liveblocks/node`. Please refer to
  [the 1.2 upgrade guide](/docs/platform/upgrading/1.2#how) to learn how to
  upgrade your auth endpoint.

**Affecting `@liveblocks/redux` and `@liveblocks/zustand`:**

- Legacy aliased exports in Zustand/Redux packages are removed

## Simplifying your Liveblocks application (optional) [#simplifying]

<Banner title="Optional, but recommended">

This section is optional, but highly recommended. You can do it now, or come
back to do it later.

</Banner>

If you have dealt with the breaking changes above, or concluded they they donâ€™t
apply to your situation, we can go a step further and really simplify your
Liveblocks setup.

<Banner type="warning" title="Do you have multiple room types?">

If your Liveblocks application has multiple room types, and therefore you have
multiple Liveblocks config filesâ€”one for each room typeâ€”then you cannot switch
to a single global type definition. In that advanced case, the following
simplifications do not apply to you. We will keep supporting the
`createRoomContext` API for these advanced use cases, but no longer recommend it
for the more common case of having just a single room type.

</Banner>

### Step 1: Use the new global Liveblocks custom types [#step1]

Go to your `liveblocks.config.ts`, find your `createRoomContext()` call. Now
decide which codemod to run.

**Option 1: You are using Suspense hooks.**
(`const { suspense: { useRoom, ... } }`)

```bash
npx @liveblocks/codemod@latest remove-liveblocks-config-contexts --suspense
```

**Option 2: You are using classic hooks.** (`const { useRoom, ... }`)

```bash
npx @liveblocks/codemod@latest remove-liveblocks-config-contexts
```

Running either of these will make the following changes.

```tsx showLineNumbers={false}
// âŒ Before
export const {
  ...
} = createRoomContext<MyPresence, MyStorage, MyUserMeta, MyRoomEvent, MyThreadMetadata>(client);
```

```tsx showLineNumbers={false}
// âœ… After
declare global {
  interface Liveblocks {
    Presence: MyPresence;
    Storage: MyStorage;
    UserMeta: MyUserMeta;
    RoomEvent: MyRoomEvent;
    ThreadMetadata: MyThreadMetadata;
  }
}
```

Secondly, it will change all imports in your code base to import the hooks
directly instead:

```tsx showLineNumbers={false}
// âŒ Before
import { RoomProvider, useRoom, ... } from "./liveblocks.config.ts";
```

```tsx showLineNumbers={false}
// âœ… After
import { RoomProvider, useRoom, ... } from "@liveblocks/react/suspense";  // Option 1
import { RoomProvider, useRoom, ... } from "@liveblocks/react";           // Option 2
```

### Step 2: Set up a LiveblocksProvider [#step2]

At this point, there should not be any new TypeScript issues. However, running
the code will not yet work. This is because previously the hooks were bound to
the `client` instance by passing it to the `createRoomContext()` factory, which
we now removed. When using the global types, weâ€™ll have to provide the
Liveblocks client otherwise.

The way to do it is to use a pretty standard React provider. Make the following
change:

```tsx showLineNumbers={false} file="liveblocks.config.ts"
// âŒ Before, you no longer have to use createClient()
import { createClient } from "@liveblocks/client";

const client = createClient({
  authEndpoint: "/api/liveblocks-auth",
  throttle: 16,
  /* etc */
);
```

```tsx showLineNumbers={false} file="layout.tsx"
// âœ… After
"use client";

import { LiveblocksProvider } from "@liveblocks/react";

export function Layout({ children }) {
  return (
    // Move options here, client will be created for you
    <LiveblocksProvider
      authEndpoint="/api/liveblocks-auth"
      throttle={16}
      /* etc */
    >
      {children}
    </LiveblocksProvider>
  );
}
```

<Banner type="info" title="Where to put this?">

We recommend placing the `LiveblocksProvider` as high up your component tree as
you can, preferably in your `_app.tsx` or `layout.tsx` (or equivalent for your
React framework of choice). Unfortunately, we cannot provide a codemod for this
step, because we cannot mechanically decide where exactly to inject the
Liveblocks provider in your application.

</Banner>

If you were exporting the `client` instance before and have components that
directly accessed it before, you can now obtain a reference to the `client`
instance that the `LiveblocksProvider` creates for you using the `useClient`
hook:

```tsx showLineNumbers={false}
// âŒ Before
import { client } from "./liveblocks.config";

function MyComponent() {
  doSomethingWith(client);
}
```

```tsx showLineNumbers={false}
// âœ… After
import { useClient } from "@liveblocks/react"; // or
import { useClient } from "@liveblocks/react/suspense";

function MyComponent() {
  const client = useClient();
  doSomethingWith(client);
}
```

### Step 3: Optional cleanup of type params [#step3]

If you also exported your `Presence`, `Storage`, etc types from
`liveblocks.config.ts` before, you no longer have to. The main reason to export
these before was to use them in helper functions that used some of the
Liveblocks types, like `User`, or `Room`.

```bash
npx @liveblocks/codemod@latest remove-unneeded-type-params
```

For example:

```tsx showLineNumbers={false}
import type { Room, User } from "@liveblocks/client";
import type { MyPresence, MyStorage } from "./liveblocks.config";

// âŒ Before
function isAdult(user: User<MyPresence, MyUserMeta>) {
  //                        ^^^^^^^^^^^^^^^^^^^^^^
  return user.info.age >= 18;
  //               ^^^ Coming from MyUserMeta
}

// âŒ Before
function doSomethingWithRoom(
  room: Room<MyPresence, MyStorage, MyUserMeta, never>
  //         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
) {
  /* ... */
}
```

This is no longer needed. You can simply remove them. TypeScript will still know
about your custom `age` property on `user.info`.

```tsx showLineNumbers={false}
import type { Room, User } from "@liveblocks/client";

// âœ… After
function isAdult(user: User) {
  return user.info.age >= 18;
  //               ^^^ Still coming from configured UserMeta custom type
}

// âœ… After
function doSomethingWithRoom(room: Room) {
  /* ... */
}
```

## Improvements

Furthermore, the following miscellaneous quality-of-life improvements have been
made that are non-breaking changes.

### `ClientSideSuspense` no longer needs a function

Previously, the `ClientSideSuspense` helper needed a function as its `children`
prop, but it no longer has to.

```bash
npx @liveblocks/codemod@latest simplify-client-side-suspense-children
```

This will change:

```tsx showLineNumbers={false}
// âŒ Before
<ClientSideSuspense fallback={<Loading />}>
  {() => <MyApp />}
</ClientSideSuspense>
```

```tsx showLineNumbers={false}
// âœ… After
<ClientSideSuspense fallback={<Loading />}>
  <MyApp />
</ClientSideSuspense>
```

### Improved `InboxNotification` props types

When passing custom components to the `kinds` prop of [`InboxNotification`][],
you could use types like `InboxNotificationThreadProps` for the props. But this
wasnâ€™t always true for all notification kinds, so now you can use types named
`InboxNotificationThreadKindProps` for your components, while
`InboxNotificationThreadProps` describes the props of our own
`InboxNotification.Thread`.

```tsx showLineNumbers={false}
// âŒ Before
function MyThreadNotification(props: InboxNotificationThreadProps) {
  return <InboxNotification.Thread {...props} />;
}

<InboxNotification kinds={{ thread: MyThreadNotification }} />;
```

```tsx showLineNumbers={false}
// âœ… After
function MyThreadNotification(props: InboxNotificationThreadKindProps) {
  //                                                        ^^^^
  return <InboxNotification.Thread {...props} />;
}

<InboxNotification kinds={{ thread: MyThreadNotification }} />;
```

### New custom type `RoomInfo`

By using the [`resolveRoomsInfo`][] callback from [`createClient`][] or the new
[`LiveblocksProvider`][], you can attach arbitrary room data to a room, which
you can retrieve with the [`useRoomInfo`][] hook.

Both of these APIs will now respect the type you provide via:

```tsx showLineNumbers={false}
declare global {
  interface Liveblocks {
    RoomInfo: {
      /* your custom type definition here */
    };
  }
}
```

### New custom type `ActivitiesData`

By providing a custom `ActivitiesData` type, you can improve how your custom
notifications and their activitiesâ€™ data are typed.

```tsx showLineNumbers={false}
declare global {
  interface Liveblocks {
    // Custom activities data for custom notification kinds
    ActivitiesData: {
      // Example, a custom $alert kind
      $alert: {
        title: string;
        message: string;
      };
    };

    // Other kinds
    // ...
  }
}
```

Thatâ€™s it!

## Questions? Please ask!

If you have any trouble with these new patterns, run into a bug with one of the
codemods, or otherwise need help, please let us know
[by email](mailto:support@liveblocks.io) or by joining our
[Discord community](/discord)! Weâ€™re here to help!

[`createClient`]: /docs/api-reference/liveblocks-client#createClient
[`LiveblocksProvider`]: /docs/api-reference/liveblocks-react#LiveblocksProvider
[`InboxNotification`]: /docs/api-reference/liveblocks-react-ui#InboxNotification
[`resolveRoomsInfo`]:
  /docs/api-reference/liveblocks-client#createClientResolveRoomsInfo
[`useRoomInfo`]: /docs/api-reference/liveblocks-react#useRoomInfo

---
meta:
  title: "Upgrading to 2.15"
  parentTitle: "Upgrading"
  description: "Guide to upgrade to Liveblocks version 2.15"
---

This version of Liveblocks drops support for React versions below 18.

## Does this affect you? [#does-this-affect-you]

If you are **already on React 18 or above**, you do not have to do anything.
Just enjoy the smaller bundle size and performance improvements!

If **you are on React 16 or 17**, you should upgrade React before upgrading
Liveblocks to 2.15. See the [instructions below](#how-to-upgrade).

If **you cannot upgrade to React 18 yet** for whatever reason, you can still
keep using Liveblocks 2.14 which is the last version to support React 17 and
below.

## How to upgrade? [#how-to-upgrade]

To upgrade Liveblocks to 2.15, first upgrade React to 18 by following the
[How to Upgrade to React 18](https://react.dev/blog/2022/03/08/react-18-upgrade-guide).

Then, upgrade all Liveblocks packages by running:

```bash
npx create-liveblocks-app@latest --upgrade
```

You can now safely remove this line from your codebase:

```diff
-import { unstable_batchedUpdates } from "react-dom";
 //                                      ^^^^^^^^^^^ ...or "react-native"!

 <RoomProvider
   id="my-room"
   initialPresence={/* ... */}
   initialStorage={/* ... */}
-  unstable_batchedUpdates={unstable_batchedUpdates}
 >
   <App />
 </RoomProvider>
```

Thatâ€™s it!

---
meta:
  title: "Upgrading to 2.16"
  parentTitle: "Upgrading"
  description: "Guide to upgrade to Liveblocks version 2.16"
---

Weâ€™ve made React changes, affecting how our error listener hook works, and how
undefined metadata is filtered in Comments.

## How to upgrade

Upgrade to 2.16 by downloading the latest version of each Liveblocks package
youâ€™re using. The easiest way to do this is to run the following command:

```bash
npx create-liveblocks-app@latest --upgrade
```

## Does this affect you? [#does-this-affect-you]

**If youâ€™re using the [`useErrorListener`][] hook**, please read about
[a behavior change](#change-1).

**If youâ€™re using Comments in React**, please read about
[the change to metadata filtering](#change-2).

Otherwise, no changes will affect you.

## New errors can appear in `useErrorListener` [#change-1]

From 2.16, [`useErrorListener`][] will notify you about new errors. Previously,
only room connection errors were previously reported, possible if you were using
Presence, Storage, or Yjs. After upgrading, you can also receive a number of
errors from Comments and Notifications.

```tsx
import { useErrorListener } from "@liveblocks/react";

useErrorListener((error) => {
  switch (error.context.type) {
    // +++
    case "CREATE_THREAD_ERROR":
      const { roomId, threadId, commentId, body, metadata } = error.context;
      break;
    // +++

    // +++
    case "MARK_INBOX_NOTIFICATION_AS_READ_ERROR":
      const { inboxNotificationId, roomId } = error.context;
      break;
    // +++

    // Many other new errors
    // ...
  }
});
```

For a full list of possible errors, see the [`useErrorListener`][]
documentation.

We have also decoupled [`useErrorListener`][] from the current room. Previously
it required to be nested under a
[`RoomProvider`](/docs/api-reference/liveblocks-react#RoomProvider). Now, you
can use it anywhere under
[`LiveblocksProvider`](/docs/api-reference/liveblocks-react#LiveblocksProvider),
and it will notify you about errors from all rooms.

### To upgrade [#upgrade-change-1]

No changes are necessary to upgrade, however **if you would like to keep the old
behavior** and only show room connection errors, you can filter out all new
errors with an early return:

```ts
import { useErrorListener, useRoom } from "@liveblocks/react";

function App() {
  // +++
  const room = useRoom();
  // +++

  useErrorListener((error) => {
    // +++
    if (
      error.context.roomId !== room.id &&
      error.context.type !== "ROOM_CONNECTION_ERROR"
    ) {
      return;
    }
    // +++

    // Your previous logic
  });
}
```

## Ability to filter threads by absence of metadata [#change-2]

From 2.16, the [`useThreads`][] (and `useUserThreads_experimental`) hooks
supports filtering by _absence_ of a metadata field using `null`.

```ts
// âœ… Will now return "important" threads without a `color` field
const threads = useThreads({
  query: {
    metadata: {
      // +++
      color: null,
      // +++
      label: "important",
    },
  },
});
```

Previously this was not supported, but due to a bug, using an explicit
`undefined` would already allow you to do this. However, threads werenâ€™t
filtered correctly in our back end causing over-fetches.

### To upgrade [#upgrade-change-2]

If you relied on this bug, change `undefined` to `null` in any metadata
properties. **This will keep behavior the same**â€”if you donâ€™t make this change,
then your previous filtering will no longer work.

```ts title="Before"
const threads = useThreads({
  query: {
    metadata: {
      // âŒ Before - Will have no effect in 2.16
      // +++
      color: undefined,
      // +++
      label: "important",
    },
  },
});
```

```ts title="After"
const threads = useThreads({
  query: {
    metadata: {
      // âœ… After - Will now find threads without a `color`
      // +++
      color: null,
      // +++
      label: "important",
    },
  },
});
```

Thatâ€™s it for 2.16!

[`useerrorlistener`]: /docs/api-reference/liveblocks-react#useErrorListener
[`usethreads`]: /docs/api-reference/liveblocks-react#useThreads

---
meta:
  title: "Upgrading to 2.2"
  parentTitle: "Upgrading"
  description: "Guide to upgrade to Liveblocks version 2.2"
---

<Banner title="Upgrade to 2.0 required">

You must upgrade to 2.0 first, please follow the
[2.0 upgrade guide](/docs/platform/upgrading/2.0).

</Banner>

We are making `resolved` a first-class citizen property on
[threads](/docs/ready-made-features/comments/concepts#Threads). You donâ€™t have
to use a threadâ€™s metadata to set a thread as resolved anymore.

## How to upgrade? [#how]

You can upgrade to 2.2 by downloading the latest version of each Liveblocks
package youâ€™re using. The easiest way to do that is to run the following
command:

```bash
npx create-liveblocks-app@latest --upgrade
```

## All changes are for Comments

If you are not using Comments or are not using the `resolved` metadata property,
there are no breaking changes for you! However, if you are and have logic based
on the webhook event `threadMetadataUpdated`, keep reading.

### Webhook events

When you upgrade to 2.2, the default
[`Thread`](/docs/api-reference/liveblocks-react-ui#Thread) component will update
the threadâ€™s first-class citizen property instead of the metadata. When a thread
is marked as resolved or unresolved, we will send the events
[`threadMarkedAsResolved`](/docs/platform/webhooks#ThreadMarkedAsResolvedEvent)
and
[`threadMarkedAsUnresolved`](/docs/platform/webhooks#ThreadMarkedAsUnresolvedEvent)
instead of
[`threadMetadataUpdated`](/docs/platform/webhooks#ThreadMarkedAsUnresolvedEvent).

Before upgrading to 2.2, you should update your webhook endpoint to process
those new events accordingly.

### REST API endpoints

If you use the REST endpoint
[`Edit thread metadata`](/docs/api-reference/rest-api-endpoints#post-rooms-roomId-threads-threadId-metadata)
to update the metadata `resolved`, you should instead use the endpoints
[`Mark thread as resolved`](/docs/api-reference/rest-api-endpoints#post-rooms-roomId-threads-threadId-mark-as-resolved)
and
[`Mark thread as unresolved`](/docs/api-reference/rest-api-endpoints#post-rooms-roomId-threads-threadId-mark-as-unresolved).

Note that updating the `resolved` metadata property automatically updates the
first-class citizen one.

---
meta:
  title: "Upgrading to 2.24"
  parentTitle: "Upgrading"
  description: "Guide to upgrade to Liveblocks version 2.24"
---

Weâ€™ve renamed some of the concepts around notifications and notification
settings to improve clarity.

## How to upgrade

Upgrade to 2.24 by downloading the latest version of each Liveblocks package
youâ€™re using. The easiest way to do this is to run the following command:

```bash
npx create-liveblocks-app@latest --upgrade
```

## Does this affect you? [#does-this-affect-you]

If you are using notification settings in any wayâ€”with [`@liveblocks/client`][],
[`@liveblocks/react`][], [`@liveblocks/node`][], or
[the REST API](/docs/api-reference/rest-api-endpoints)â€”continue reading to see
the changes. The naming changes are **backwards compatible**.

Otherwise, no changes will affect you.

## Naming changes

### Rationale

Historically, we used the term â€œnotification settingsâ€ to refer to
**room-level** settings that control the
[inbox notifications](/docs/ready-made-features/notifications/concepts#Inbox-Notifications)
received by a user (e.g. setting `"threads"` to `"all"` would make the user
receive inbox notifications for any threads activity in the room, not just the
ones where they participate).

With 2.18, we introduced the concept of â€œ**user** notification settingsâ€, which
are **project-level** settings that control the notifications (
[`"notification"` webhook events](/docs/platform/webhooks#NotificationEvent),
not "inbox notifications") received by a user (e.g. setting
`email.$myCustomNotification` to `false` would disable `"notification"` webhook
events for the `$myCustomNotification` kind and the `email` channel).

To improve clarity, weâ€™re renaming these concepts:

- â€œroom **notification** settingsâ€ â†’ â€œroom **subscription** settingsâ€: they
  control which things a user is subscribed to in a room
- â€œ**user** notification settingsâ€ â†’ â€œnotification settingsâ€: they control which
  notifications a user receives

### What changed

All methods, hooks, types, and REST API endpoints that were using these terms
have been renamed to use the new naming, see the examples below.

We provide a codemod to automatically update your codebase to the new naming.

```bash
npx @liveblocks/codemod@latest rename-notification-settings
```

#### `@liveblocks/react`

```tsx
// âŒ Before
import {
  // +++
  useRoomNotificationSettings,
  useUpdateRoomNotificationSettings,
  // +++
} from "@liveblocks/react";

// âœ… After
import {
  // +++
  useRoomSubscriptionSettings,
  useUpdateRoomSubscriptionSettings,
  // +++
} from "@liveblocks/react";
```

```tsx
// âŒ Before
useErrorListener((error) =>
  // +++
  if (error.context.type === "UPDATE_NOTIFICATION_SETTINGS_ERROR") {
    // +++
    /* ... */
  }
);

// âœ… After
useErrorListener((error) =>
  // +++
  if (error.context.type === "UPDATE_ROOM_SUBSCRIPTION_SETTINGS_ERROR") {
    // +++
    /* ... */
  }
);
```

#### `@liveblocks/client`

```tsx
// âŒ Before
import type { RoomNotificationSettings } from "@liveblocks/client";

// âœ… After
import type { RoomSubscriptionSettings } from "@liveblocks/client";
```

```tsx
// âŒ Before
const { room, leave } = client.enterRoom("my-room-id");

// +++
room.getNotificationSettings();
room.updateNotificationSettings(/* ... */);
// +++

// âœ… After
const { room, leave } = client.enterRoom("my-room-id");

// +++
room.getSubscriptionSettings();
room.updateSubscriptionSettings(/* ... */);
// +++
```

```tsx
// âŒ Before
import type { UserNotificationSettings } from "@liveblocks/client";

// âœ… After
import type { NotificationSettings } from "@liveblocks/client";
```

#### `@liveblocks/node`

```tsx
// âŒ Before
const liveblocks = new Liveblocks({
  secret: "sk_prod_xxxxxxxxxxxxxxxxxxxxxxxx",
});

// +++
await liveblocks.getRoomNotificationSettings(/* ... */);
await liveblocks.updateRoomNotificationSettings(/* ... */);
await liveblocks.deleteRoomNotificationSettings(/* ... */);
// +++

// âœ… After
const liveblocks = new Liveblocks({
  secret: "sk_prod_xxxxxxxxxxxxxxxxxxxxxxxx",
});

// +++
await liveblocks.getRoomSubscriptionSettings(/* ... */);
await liveblocks.updateRoomSubscriptionSettings(/* ... */);
await liveblocks.deleteRoomSubscriptionSettings(/* ... */);
// +++
```

#### REST API

```shell
# âŒ Before
https://api.liveblocks.io/v2/rooms/:roomId/users/:userId/notification-settings

# âœ… After
https://api.liveblocks.io/v2/rooms/:roomId/users/:userId/subscription-settings
```

Thatâ€™s it for 2.24!

[`@liveblocks/client`]: /docs/api-reference/liveblocks-client
[`@liveblocks/react`]: /docs/api-reference/liveblocks-react
[`@liveblocks/node`]: /docs/api-reference/liveblocks-node

---
meta:
  title: "Upgrading to 2.8"
  parentTitle: "Upgrading"
  description: "Guide to upgrade to Liveblocks version 2.8"
---

We are introducing attachments to allow users to add files to their comments.

## How to upgrade? [#how]

You can upgrade to 2.8 by downloading the latest version of each Liveblocks
package youâ€™re using. The easiest way to do that is to run the following
command:

```bash
npx create-liveblocks-app@latest --upgrade
```

## All changes are for Comments

If you are not using Comments or are not using
[the default Comments components](/docs/ready-made-features/comments/default-components),
there are no breaking changes for you! However, if you are, or intend to use
them later, keep reading.

## Attachments

Liveblocks 2.8 adds attachments to Comments, and while not a breaking change, it
is mostly enabled by default in the default components. We recommend you either
[enable attachments](#enable-attachments) or
[disable attachments](#disable-attachments) when you upgrade.

### Enable attachments [#enable-attachments]

Attachments are enabled by default, but if youâ€™re using
[`useCreateThread`](/docs/api-reference/liveblocks-react#useCreateThread),
[`useCreateComment`](/docs/api-reference/liveblocks-react#useCreateComment), or
[`useEditComment`](/docs/api-reference/liveblocks-react#useEditComment), you can
now pass these an attachments array.

```tsx
const createThread = useCreateThread();

// âŒ Before - Liveblocks 2.7
createThread({ body: {}, metadata: {} });

// âœ… After - Liveblocks 2.8
createThread({ body: {}, attachments: [], metadata: {} });
```

These hooks are most commonly used to enable
[custom Composer behavior](/docs/api-reference/liveblocks-react-ui#Custom-behavior)
with `onComposerSubmit`, which now provides the `attachments` array for you. You
must pass this to your mutations for attachments to work correctly.

```tsx
const createThread = useCreateThread();

// âŒ Before - Liveblocks 2.7
<Composer
  onComposerSubmit={({ body }, event) => {
    event.preventDefault();
    createThread({ body, metadata: {} });
  }}
/>

// âœ… After - Liveblocks 2.8
<Composer
// +++
  onComposerSubmit={({ body, attachments }, event) => {
    // +++
    event.preventDefault();
    // +++
    createThread({ body, attachments, metadata: {} });
    // +++
  }}
/>
```

Remember that this applies to
[`useCreateComment`](/docs/api-reference/liveblocks-react#useCreateComment) and
[`useEditComment`](/docs/api-reference/liveblocks-react#useEditComment) too, not
just [`useCreateThread`](/docs/api-reference/liveblocks-react#useCreateThread).
No further changes are necessary to enable attachments in the default
components.

{/* TODO If youâ€™re using primitives you must ... */}

### Disable attachments [#disable-attachments]

If youâ€™d prefer to disable attachments, you can do so by setting the
`showAttachments` prop to `false` on each of the following components:
[`Composer`](/docs/api-reference/liveblocks-react-ui#Composer),
[`Comment`](/docs/api-reference/liveblocks-react-ui#Comment),
[`Thread`](/docs/api-reference/liveblocks-react-ui#Thread), and
[`InboxNotification`](/docs/api-reference/liveblocks-react-ui#InboxNotification.Thread).

```tsx
// Disable attachments
<Composer showAttachments={false} ... />
<Comment showAttachments={false} ... />
<Thread showAttachments={false} ... />
<InboxNotification showAttachments={false} ... />
```

## Default Composer component structure

The default [`Composer`](/docs/api-reference/liveblocks-react-ui#Composer)
componentâ€™s structure has slightly changed, so if you customized its styles:
make sure to check if and how the new structure affects your changes.

```html
<!-- âŒ Before - Liveblocks 2.7 -->
<form class="lb-root lb-composer lb-composer-form">
  <!-- The editor and its controls -->
</form>

<!-- âœ… After - Liveblocks 2.8 -->
<form class="lb-root lb-composer lb-composer-form">
  <div class="lb-composer-editor-container">
    <!-- The editor and its controls -->
  </div>
</form>
```

---
meta:
  title: "Upgrading to 2.9"
  parentTitle: "Upgrading"
  description: "Guide to upgrade to Liveblocks version 2.9"
---

We are introducing pagination to Comments and Notifications as default. You need
to upgrade your app to handle this.

## How to upgrade? [#how]

You can upgrade to 2.9 by downloading the latest version of each Liveblocks
package youâ€™re using. The easiest way to do that is to run the following
command:

```bash
npx create-liveblocks-app@latest --upgrade
```

## All changes are for Comments & Notifications

If youâ€™re not using
[`useThreads`](/docs/api-reference/liveblocks-react#useThreads) or
[`useInboxNotifications`](/docs/api-reference/liveblocks-react#useInboxNotifications)
there are no breaking changes for you! However, if you are using them, keep
reading.

## Pagination

[`useThreads`](/docs/api-reference/liveblocks-react#useThreads) and
[`useInboxNotifications`](/docs/api-reference/liveblocks-react#useInboxNotifications)
now only fetch the **latest 50 threads/notifications**, and you must use
paginate to retrieve more. Previously, these two functions would fetch every
single thread/notification, but this is no longer possible.

<Banner type="warning">
  If your rooms have fewer than 50 threads, and your users fewer than 50
  notifications, there will be no visible difference when upgrading. Pagination
  is only used after 50.
</Banner>

### Threads

Hereâ€™s a before and after example with
[`useThreads`](/docs/api-reference/liveblocks-react#useThreads), adding
pagination.

```tsx title="Before"
import { useThreads } from "@liveblocks/react/suspense";

function Threads() {
  const { threads } = useThreads();

  return (
    <div>
      {threads.map((thread) => (
        <Thread key={thread.id} thread={thread} />
      ))}
    </div>
  );
}
```

```tsx title="After"
import { useThreads } from "@liveblocks/react/suspense";

function Threads() {
  const {
    threads,
    // +++
    fetchMore,
    isFetchingMore,
    hasFetchedAll,
    fetchMoreError,
    // +++
  } = useThreads();

  // +++
  const loadMore = fetchMoreError ? (
    <>
      <p>Error loading more threads: {fetchMoreError.message}</p>
      <button onClick={fetchMore} disabled={isFetchingMore}>
        Retry
      </button>
    </>
  ) : (
    <button onClick={fetchMore} disabled={isFetchingMore}>
      Load more
    </button>
  );
  // +++

  return (
    <div>
      {threads.map((thread) => (
        <Thread key={thread.id} thread={thread} />
      ))}
      // +++
      {hasFetchedAll ? <div>ðŸŽ‰ You're all caught up!</div> : loadMore}
      // +++
    </div>
  );
}
```

### Notifications

Hereâ€™s a before and after example with
[`useInboxNotifications`](/docs/api-reference/liveblocks-react#useInboxNotifications),
adding pagination.

```tsx title="Before"
import { useInboxNotifications } from "@liveblocks/react/suspense";

function Notifications() {
  const { inboxNotifications } = useInboxNotifications();

  return (
    <div>
      {inboxNotifications.map((notification) => (
        <InboxNotification key={notification.id} inboxNotification={noâ€ ification} />
      ))}
    </div>
  );
}
```

```tsx title="After"
import { useInboxNotifications } from "@liveblocks/react/suspense";

function Notifications() {
  const {
    inboxNotifications,
    // +++
    fetchMore,
    isFetchingMore,
    hasFetchedAll,
    fetchMoreError,
    // +++
  } = useInboxNotifications();

  // +++
  const loadMore = fetchMoreError ? (
    <>
      <p>Error loading more notifications: {fetchMoreError.message}</p>
      <button onClick={fetchMore} disabled={isFetchingMore}>
        Retry
      </button>
    </>
  ) : (
    <button onClick={fetchMore} disabled={isFetchingMore}>
      Load more
    </button>
  );
  // +++

  return (
    <div>
      {inboxNotifications.map((notification) => (
        <InboxNotification key={notification.id} inboxNotification={noâ€ ification} />
      ))}
      // +++
      {hasFetchedAll ? <div>ðŸŽ‰ You're all caught up!</div> : loadMore}
      // +++
    </div>
  );
}
```

### Learn more

Learn more about pagination under
[`useThreads`](/docs/api-reference/liveblocks-react#useThreads) and
[`useInboxNotifications`](/docs/api-reference/liveblocks-react#useInboxNotifications).

---
meta:
  title: "Upgrading to 3.0"
  parentTitle: "Upgrading"
  description: "Guide to upgrade to Liveblocks version 3.0"
---

Liveblocks 3.0 is our third major release, focusing on our newest product,
[AI Copilots](https://liveblocks.io/blog/meet-liveblocks-3-0-the-fastest-way-to-let-your-users-collaborate-with-ai-in-your-product).
Weâ€™ve used this as an opportunity to tidy up some of our existing APIs, ensuring
consistency throughout our offering.

## How to upgrade [#how-to-upgrade]

First of all, letâ€™s upgrade all Liveblocks dependencies to their latest
versions. The easiest way to do that is to run the following command:

```bash
npx create-liveblocks-app@latest --upgrade
```

There are some **breaking changes** in this update.

## Does this affect you? [#does-this-affect-you]

**If youâ€™re using TypeScript 4.9 or lower**, TypeScript 5.0 is now the minimum
supported version.

**If youâ€™re using [Comments](/docs/ready-made-features/comments) and/or
[Text Editor](/docs/ready-made-features/text-editor)**, please read about
[changes to mentions](#mentions).

**If youâ€™re using [Notifications](/docs/ready-made-features/notifications)**,
please read about
[a change related to notification settings](#notification-settings).

**If youâ€™re using
[`@liveblocks/emails`](/docs/api-reference/liveblocks-emails)**, please read
about [changes to its returned values](#liveblocks-emails).

**If youâ€™re using
[`LiveblocksUIConfig`](/docs/api-reference/liveblocks-react-ui#LiveblocksUiConfig)**,
please read about [its renaming](#liveblocks-ui-config).

**If youâ€™re using any deprecated APIs** (e.g. `useBatch`, `useStorageStatus`,
`useEditorStatus`â€¦), please read about [the ones being removed](#deprecated).

Otherwise, you can simply upgrade your packages and no changes will affect you.

## Mentions [#mentions]

Weâ€™re making some changes to mentions in Comments and Text Editor to support
different mention kinds in future releases: user mentions, group mentions, etc.

### Components [#mentions-components]

The `onMentionClick` prop on [`Thread`][] and [`Comment`][] now receives a
`MentionData` object as its first argument instead of a `userId` string.

```tsx
// âŒ Before
onMentionClick(userId: string, event: MouseEvent<HTMLElement>) => void;
// userId: "user-0"

// âœ… After
onMentionClick(mention: MentionData, event: MouseEvent<HTMLElement>) => void;
// mention: { kind: "user", id: "user-0" }
```

### Primitives [#mentions-primitives]

When customizing the
[`Mention`](/docs/api-reference/liveblocks-react-ui#primitives-Comment.Body-Mention)
component on the [`Comment.Body`][] and [`Composer.Editor`][] primitives, the
`userId` prop has been replaced by a `mention` one which is a `MentionData`
object.

```tsx
import { Comment, Composer } from "@liveblocks/react-ui/primitives";

// âŒ Before
<Comment.Body
  components={{
    // +++
    Mention: ({ userId }) => <Comment.Mention>@{userId}</Comment.Mention>,
    // +++
  }}
/>;
<Composer.Editor
  components={{
    // +++
    Mention: ({ userId, isSelected }) => (
      <Composer.Mention>@{userId}</Composer.Mention>
    ),
    // +++
  }}
/>;

// âœ… After
<Comment.Body
  components={{
    // +++
    Mention: ({ mention }) => <Comment.Mention>@{mention.id}</Comment.Mention>,
    // +++
  }}
/>;
<Composer.Editor
  components={{
    // +++
    Mention: ({ mention, isSelected }) => (
      <Composer.Mention>@{mention.id}</Composer.Mention>
    ),
    // +++
  }}
/>;
```

When customizing the
[`MentionSuggestions`](/docs/api-reference/liveblocks-react-ui#primitives-Composer.Editor-MentionSuggestions)
component on the [`Composer.Editor`][] primitive, the `userIds` prop has been
replaced by a `mentions` one which is an array of `MentionData` objects, and the
`selectedUserId` prop has been renamed to `selectedMentionId`.

```tsx
import { Composer } from "@liveblocks/react-ui/primitives";

// âŒ Before
<Composer.Editor
  components={{
    // +++
    MentionSuggestions: ({ userIds, selectedUserId }) => (
      // +++
      <Composer.Suggestions>
        <Composer.SuggestionsList>
          // +++
          {userIds.map((userId) => (
            <Composer.SuggestionsListItem key={userId} value={userId}>
              {userId}
            </Composer.SuggestionsListItem>
          ))}
          // +++
        </Composer.SuggestionsList>
      </Composer.Suggestions>
    ),
  }}
/>;

// âœ… After
<Composer.Editor
  components={{
    // +++
    MentionSuggestions: ({ mentions, selectedMentionId }) => (
      // +++
      <Composer.Suggestions>
        <Composer.SuggestionsList>
          // +++
          {mentions.map((mention) => (
            <Composer.SuggestionsListItem key={mention.id} value={mention.id}>
              {mention.id}
            </Composer.SuggestionsListItem>
          ))}
          // +++
        </Composer.SuggestionsList>
      </Composer.Suggestions>
    ),
  }}
/>;
```

### `@liveblocks/emails` [#mentions-liveblocks-emails]

The [`prepareTextMentionNotificationEmailAsReact`][] and
[`prepareTextMentionNotificationEmailAsHtml`][] functionsâ€™ returned data changed
slightly:

- The `id` property is now named `textMentionId`, it refers to the mentionâ€™s
  Text Mention ID, not the user ID used for the mention
- The `id` property now refers to the mentionâ€™s ID, as in the user ID used for
  the mention
- The `kind` property now indicates the mentionâ€™s kind (e.g. `"user"`,
  `"group"`, etc.)

```tsx
await prepareTextMentionNotificationEmailAsReact(liveblocks, event);

// âŒ Before
// {
//   mention: {
// +++
//     id: "in_xxx",
// +++
//     roomId: "123",
//     createdAt: new Date(),
//     author: {
//       id: "user-who-created-the-mention",
//       info: {
//         name: "AurÃ©lien",
//       },
//     },
//     content: /* The rendered content */,
//   },
//   ...
// }

// âœ… After
// {
//   mention: {
// +++
//     textMentionId: "in_xxx",
//     id: "user-who-is-mentioned",
//     kind: "user",
// +++
//     roomId: "123",
//     createdAt: new Date(),
//     author: {
//       id: "user-who-created-the-mention",
//       info: {
//         name: "AurÃ©lien",
//       },
//     },
//     content: /* The rendered content */,
//   },
//   ...
// }
```

When customizing the
[`Mention`](/docs/api-reference/liveblocks-emails#prepare-text-mention-notification-email-as-react-customizing-components)
component in the [`prepareTextMentionNotificationEmailAsReact`][] function, the
`element` propâ€™s `userId` property has been renamed to `id`, and `element.kind`
now indicates the mentionâ€™s kind.

```tsx
await prepareThreadNotificationEmailAsReact(liveblocks, webhookEvent, {
  components: {
    // âŒ Before
    Mention: ({ element, user }) => (
      // +++
      <span style={{ color: "red" }}>@{element.userId}</span>
      // +++
    ),

    // âœ… After
    Mention: ({ element, user }) => (
      // +++
      <span style={{ color: "red" }}>@{element.id}</span>
      // +++
    ),
  },
});
```

### Utilities [#utilities]

The `getMentionedIdsFromCommentBody` utility (from
[`@liveblocks/client`](/docs/api-reference/liveblocks-client) and
[`@liveblocks/node`](/docs/api-reference/liveblocks-node)) has been replaced by
[`getMentionsFromCommentBody`](/docs/api-reference/liveblocks-client#get-mentions-from-comment-body).

```tsx
// âŒ Before
getMentionedIdsFromCommentBody(commentBody);
// ["user-1", "user-2"]

// âœ… After
getMentionsFromCommentBody(commentBody, (mention) => mention.kind === "user");
// [{ type: "mention", kind: "user", id: "user-1" }, { type: "mention", kind: "user", id: "user-2" }]
```

By default, if the optional second argument is not provided, all mentions are
returned, including future mention kinds (e.g. group mentions in the future).

```tsx
// All mentions
getMentionsFromCommentBody(commentBody);

// Only user mentions
getMentionsFromCommentBody(commentBody, (mention) => mention.kind === "user");
```

## Notification settings [#notification-settings]

2.24 [introduced a few naming changes](/docs/platform/upgrading/2.24) around the
concepts of â€œnotification settingsâ€ and â€œsubscription settingsâ€ to improve
clarity. 3.0 [removes the aliases for the previous names](#deprecated) but it
also introduces one change that we couldnâ€™t make in 2.24:

The `UPDATE_USER_NOTIFICATION_SETTINGS_ERROR` error has been renamed to
`UPDATE_NOTIFICATION_SETTINGS_ERROR`.

```tsx
// âŒ Before
useErrorListener((error) =>
  // +++
  if (error.context.type === "UPDATE_USER_NOTIFICATION_SETTINGS_ERROR") {
    // +++
    /* ... */
  }
);

// âœ… After
useErrorListener((error) =>
  // +++
  if (error.context.type === "UPDATE_NOTIFICATION_SETTINGS_ERROR") {
    // +++
    /* ... */
  }
);
```

## `@liveblocks/emails` [#liveblocks-emails]

The functions to prepare HTML/React emails are now more consistent, using the
same `body` and `content` properties instead of `reactBody`/`htmlBody` and
`reactContent`/`htmlContent`.

```tsx
// âŒ Before
prepareThreadNotificationEmailAsReact(liveblocks, event); // { comment: { reactBody: ReactNode, ... }, ... }
prepareThreadNotificationEmailAsHtml(liveblocks, event); // { comment: { htmlBody: string, ... }, ... }
prepareTextMentionNotificationEmailAsReact(liveblocks, event); // { mention: { reactContent: ReactNode, ... }, ... }
prepareTextMentionNotificationEmailAsHtml(liveblocks, event); // { mention: { htmlContent: string, ... }, ... }

// âœ… After
prepareThreadNotificationEmailAsReact(liveblocks, event); // { comment: { body: ReactNode, ... }, ... }
prepareThreadNotificationEmailAsHtml(liveblocks, event); // { comment: { body: string, ... }, ... }
prepareTextMentionNotificationEmailAsReact(liveblocks, event); // { mention: { content: ReactNode, ... }, ... }
prepareTextMentionNotificationEmailAsHtml(liveblocks, event); // { mention: { content: string, ... }, ... }
```

## `LiveblocksUiConfig` [#liveblocks-ui-config]

The
[`LiveblocksUIConfig`](/docs/api-reference/liveblocks-react-ui#LiveblocksUiConfig)
utility has been renamed to `LiveblocksUiConfig` (`UI` â†’ `Ui`) for consistency
with other Liveblocks APIs.

Run the following **codemod** or manually make the changes:

```bash
npx @liveblocks/codemod@latest liveblocks-ui-config
```

## Removed deprecated APIs [#deprecated]

All of the following APIs have been removed in 3.0, as they were deprecated
multiple versions ago.

**Affecting all packages:**

- The `code` property has been removed from `LiveblocksError`, use
  `LiveblocksError.context.code` instead for better TypeScript support.
- The deprecated aliases from the
  [2.24 naming changes](/docs/platform/upgrading/2.24) have been removed, use
  their new names instead. Thereâ€™s a codemod available to automatically use the
  new names: `npx @liveblocks/codemod@latest rename-notification-settings`.

**Affecting `@liveblocks/client`:**

- The `unstable_fallbackToHTTP` client option has been removed, set
  `largeMessageStrategy` to `"experimental-fallback-to-http"` instead.

**Affecting `@liveblocks/node`:**

- The `metadata` option has been removed from the [`getRooms`][] method, use
  `query.metadata` instead.
- The `nextPage` property has been removed from the [`getRooms`][] methodâ€™s
  response, use `query.nextPage` instead.
- The `RoomData` type has been removed, use `RoomInfo` instead. Thereâ€™s a
  codemod available to automatically use the new type:
  `npx @liveblocks/codemod@latest room-info-to-room-data`.

**Affecting `@liveblocks/react`:**

- The `useBatch` hook has been removed, use [`useMutation`][] instead for
  writing to Storage, which will automatically batch all mutations.
- The `useStorageStatus` hook has been removed, use [`useSyncStatus`][] instead
  for tracking sync status, it reflects the sync status of all parts of
  Liveblocks.

**Affecting `@liveblocks/react-lexical`:**

- The `useEditorStatus` hook has been removed, use [`useSyncStatus`][] instead
  for tracking sync status, it reflects the sync status of all parts of
  Liveblocks.

[`Thread`]: /docs/api-reference/liveblocks-react-ui#Thread
[`Comment`]: /docs/api-reference/liveblocks-react-ui#Comment
[`Comment.Body`]:
  /docs/api-reference/liveblocks-react-ui#primitives-Comment.Body
[`Composer.Editor`]:
  /docs/api-reference/liveblocks-react-ui#primitives-Composer.Editor
[`prepareTextMentionNotificationEmailAsReact`]:
  /docs/api-reference/liveblocks-emails#prepare-text-mention-notification-email-as-react
[`prepareTextMentionNotificationEmailAsHtml`]:
  /docs/api-reference/liveblocks-emails#prepare-text-mention-notification-email-as-html
[`getRooms`]: /docs/api-reference/liveblocks-node#get-rooms
[`useSyncStatus`]: /docs/api-reference/liveblocks-react#useSyncStatus
[`useMutation`]: /docs/api-reference/liveblocks-react#useMutation

---
meta:
  title: "Upgrading to 3.10"
  parentTitle: "Upgrading"
  description: "Guide to upgrade to Liveblocks version 3.10"
---

Liveblocks 3.10 releases breaking changes for [Tiptap](#Upgrade-Tiptap) and
[BlockNote](#Upgrade-BlockNote) users, as it requires at least Tiptap 3.0 or
BlockNote 0.39. No other parts of Liveblocks are affected by breaking changes.

## Not using Tiptap or BlockNote?

**If youâ€™re not using Tiptap or BlockNote, there are no breaking changes**,
simply upgrade all Liveblocks dependencies to their latest versions. The easiest
way to upgrade is to run the following command:

```bash
npx create-liveblocks-app@latest --upgrade
```

## Upgrade Tiptap

Tiptap v3 is a major update with breaking changes, but the migration process is
quite simple. First, you _must_ uninstall all Tiptap and Liveblocks dependencies
to avoid future version conflicts as we upgrade. This includes any extra Tiptap
extensions you may have installed or anything else with a dependency on Tiptap.

### AI-assisted upgrade

The easiest way to upgrade is to use our AI assistant to generate the uninstall
and install commands for you. Make sure youâ€™re signed in, paste your
`package.json` into the following input, and generate the commands.

<AskAiInput 
  placeholder="Paste package.json here" 
  prompt={`Write two **multi-line** npm commands for me:
1. Uninstall all Tiptap and Liveblocks packages. 
2. Install all the same packages with @latest on Liveblocks and @3 on Tiptap.

Here is my package.json:

\`\`\`json

{{INPUT}}

\`\`\`

Offer to rewrite the multi-line commands if I'm on Windows.

`}>

Generate commands

</AskAiInput>

Run the two commands then skip to
[Critical changes for Liveblocks users](#Critical-changes-for-Liveblocks-Tiptap-users).

### Manual upgrade

If youâ€™d like to upgrade manually, you need to run the npm command to uninstall
all Tiptap and Liveblocks packages. Note that you are likely using more package
than are listed here, such as Tiptap extensions.

```bash
npm uninstall @tiptap/react @tiptap/starter-kit @liveblocks/client @liveblocks/react @liveblocks/react-ui @liveblocks/react-tiptap @liveblocks/node
```

Next re-install all Tiptap and Liveblocks packages. If you see a peer dependency
issue during this install, you may have missed something during the previous
uninstall step.

```bash
npm install @tiptap/react@3 @tiptap/starter-kit@3 @liveblocks/client@latest @liveblocks/react@latest @liveblocks/react-ui@latest @liveblocks/react-tiptap@latest @liveblocks/node@latest
```

This will ensure that all packages are compatible with each other and prevent
version conflicts.

### Critical changes for Liveblocks Tiptap users

While Tiptap 3 includes many changes, there are two particularly critical
changes that affect Liveblocks integration:

#### StarterKit configuration change

Liveblocks provides its own undo/redo functionality for collaborative editing.
In Tiptap 2, you disabled this by setting `history: false` in the StarterKit
extension. In Tiptap 3, this option has been renamed to `undoRedo`:

```diff
const editor = useEditor({
  extensions: [
    StarterKit.configure({
-      history: false,
+      undoRedo: false,
    }),
    // Other extensions...
  ],
});
```

#### Set `immediatelyRender: false` for SSR

If you're using server-side rendering (such as with Next.js), it's now more
critical to set `immediatelyRender: false` in your editor configuration to
prevent hydration issues:

```tsx highlight="3"
const editor = useEditor(
  {
    immediatelyRender: false,
    extensions: [
      StarterKit.configure({
        undoRedo: false,
      }),
      // Other extensions...
    ],
  },
  []
);
```

This ensures the editor doesn't render on the server, which can cause mismatches
between server and client rendering.

#### Style Changes

If you have your own styles for collaboration cursors, the default CSS classes
prefix changed from `.collaboration-cursor` to `.collaboration-carets`.

```diff
- .collaboration-cursor__caret {
+ .collaboration-carets__caret {
  /* Your caret styles */
}

- .collaboration-cursor__label {
+ .collaboration-carets__label {
  /* Your label styles */
}
```

### Full migration guide

For a complete list of breaking changes and new features in Tiptap 3, refer to
the
[official Tiptap upgrade guide](https://tiptap.dev/docs/guides/upgrade-tiptap-v2).

## Upgrade BlockNote

BlockNote 0.39 has upgraded to use Tiptap 3.0 under the hood, which requires a
simple upgrade. First, you _must_ uninstall all BlockNote, Tiptap, and
Liveblocks dependencies to avoid future version conflicts as we upgrade. This
includes any extra Tiptap extensions you may have installed or anything else
with a dependency on Tiptap.

### AI-assisted upgrade

The easiest way to upgrade is to use our AI assistant to generate the uninstall
and install commands for you. Make sure youâ€™re signed in, paste your
`package.json` into the following input, and generate the commands.

<AskAiInput 
  placeholder="Paste package.json here" 
  prompt={`Write two **multi-line** npm commands for me:
1. Uninstall all BlockNote, Tiptap, and Liveblocks packages. 
2. Install all the same packages with @latest on Liveblocks and BlockNote, and @3 on Tiptap.

Here is my package.json:

\`\`\`json

{{INPUT}}

\`\`\`

Offer to rewrite the multi-line commands if I'm on Windows.

`}>

Generate commands

</AskAiInput>

Run the two commands then skip to
[Critical changes for Liveblocks BlockNote users](#Critical-changes-for-Liveblocks-BlockNote-users).

### Manual upgrade

If youâ€™d like to upgrade manually, you need to run the npm command to uninstall
all BlockNote, Tiptap, and Liveblocks packages. Note that you are likely using
more package than are listed here, such as text editor extensions.

```bash
npm uninstall @blocknote/core @blocknote/mantine @liveblocks/client @liveblocks/react @liveblocks/react-ui @liveblocks/react-blocknote @liveblocks/node
```

Next re-install all BlockNote, Tiptap, and Liveblocks packages. If you see a
peer dependency issue during this install, you may have missed something during
the previous uninstall step.

```bash
npm install @blocknote/core@latest @blocknote/mantine@latest @liveblocks/client@latest @liveblocks/react@latest @liveblocks/react-ui@latest @liveblocks/react-blocknote@latest @liveblocks/node@latest
```

This will ensure that all packages are compatible with each other and prevent
version conflicts.

### Critical changes for Liveblocks BlockNote users

#### Style Changes

If you have your own styles for collaboration cursors, the default CSS classes
prefix changed from `.collaboration-cursor` to `.collaboration-carets`.

```diff
- .collaboration-cursor__caret {
+ .collaboration-carets__caret {
  /* Your caret styles */
}

- .collaboration-cursor__label {
+ .collaboration-carets__label {
  /* Your label styles */
}
```

### BlockNote release notes

To learn more about the changes in BlockNote 0.39, please refer to the
[BlockNote 0.39 release notes](https://github.com/TypeCellOS/BlockNote/releases/tag/v0.39.0).

---
meta:
  title: "Adding Liveblocks to existing useState hooks"
  description: "Learn how to add Liveblocks to your existing useState hooks"
---

<Banner title="Not recommended" type="warning">
  Note that this is not the recommended way to build your app. We recommend
  using conflict-free data types and the `useStorage` and `useMutation` hooks,
  to take full advantage of our features.
</Banner>

You can easily add Liveblocks to an existing `useState` hook by broadcasting and
listening to events.

```ts
import { useState } from "react";
import { useBroadcastEvent, useEventListener } from "./liveblocks.config";

function useCustomState() {
  const [state, setState] = useState();
  const broadcast = useBroadcastEvent();

  // Update useState and broadcast an event
  const setStateAndBroadcast = (newValue) => {
    setState(newValue);
    broadcast({ type: "STATE_UPDATE", data: newValue });
  };

  // Listen for the broadcast event
  useEventListener(({ event }) => {
    if (event.type === "STATE_UPDATE") {
      setState(event.data);
    }
  });

  return [state, setStateAndBroadcast];
}
```

---
meta:
  title: "Can I use my own database with Yjs?"
  description:
    "Learn how to use webhooks to duplicate Yjs document data to your own
    database"
---

When building collaborative applications with Yjs and Liveblocks, you may wish
to store document data in your own database alongside Liveblocks. While
Liveblocks needs to store Yjs document data to handle realtime collaboration,
you can use webhooks to duplicate this data to your own database whenever
changes occur.

## Why Liveblocks stores Yjs data

Liveblocks must store Yjs document data to provide realtime collaboration
features. This storage is essential for:

- **Realtime synchronization**: Distributing changes to all connected users
  instantly.
- **Conflict resolution**: Merging changes from multiple users working
  simultaneously.
- **Offline support**: Syncing changes when users reconnect after being offline.
- **Document loading**: Loading the current document state when a user
  enters the room.

Without storing this data, Liveblocks wouldn't be able to provide the realtime
collaboration features that make Yjs powerful. However, you can still maintain
your own copy of the data for additional purposes like backups, analytics, or
creating full-text search.

## Duplicating data with webhooks

The best way to keep your own database in sync with Liveblocks is to use the
[`YDocUpdated`](/docs/platform/webhooks#YDocUpdatedEvent) webhook event. This
event fires whenever a Yjs document changes, allowing you to copy the updated
data to your database. Your server can then:

1. Receive the webhook event.
2. Fetch the latest document data from Liveblocks.
3. Store it in your database.

This approach ensures your database stays synchronized with Liveblocks without
interfering with realtime collaboration.

### Webhook throttling

Yjs documents can update up to 60 times per second during active collaboration,
so the `YDocUpdated` webhook is throttled to prevent overwhelming your server.
The webhook event will run no more than once every 60 seconds by default, but on
Enterprise plans, you can configure this throttle to be as low as every 5
seconds, giving you near realtime synchronization to your database.

<Banner title="Need a lower throttle speed?">

If youâ€™re interested in lowering the throttle value,
[reach out to our team](/contact/sales) to discuss your needs.

</Banner>

## Setting up database synchronization

We have detailed guides that walk you through how to set up your webhooks and
store the Yjs data in your database.

- [How to synchronize your Liveblocks Yjs document data to a Vercel Postgres database](/docs/guides/how-to-synchronize-your-liveblocks-yjs-document-data-to-a-vercel-postgres-database)
- [How to synchronize your Liveblocks Yjs document data to a Supabase Postgres database](/docs/guides/how-to-synchronize-your-liveblocks-yjs-document-data-to-a-supabase-postgres-database)
- [How to synchronize your Liveblocks Yjs document data to a PlanetScale MySQL database](/docs/guides/how-to-synchronize-your-liveblocks-yjs-document-data-to-a-planetscale-mysql-database)

If your database isnâ€™t mentioned in these guides, the process is still similar,
so we recommend following the general steps outlined in the guides. The guides
above detail fetching your Yjs data, however if youâ€™re using one of our text
editor extensions, you can use our server packages to fetch the Tiptap or
Lexical data instead.

### Tiptap

If youâ€™re using Tiptap,
[`withProsemirrorDocument`](/docs/api-reference/liveblocks-node-prosemirror#withProsemirrorDocument)
can be used to fetch the Tiptap data, as text, markdown, JSON, and more, when
receiving the webhook event.

```ts
const textContent = await withProsemirrorDocument(
  { roomId: "my-room-id", client: liveblocks },
  async (api) => {
    return api.toMarkdown();
  }
);

// "# Hello world"
console.log(textContent);
```

Additionally you can modify the live document with
[`setContent`](/docs/api-reference/liveblocks-node-prosemirror#api.setContent).

### Lexical

If youâ€™re using Lexical,
[`withLexicalDocument`](/docs/api-reference/liveblocks-node-lexical#withLexicalDocument)
can be used to fetch the Lexical data, as text, markdown, JSON, and more, when
receiving the webhook event.

```ts
const textContent = await withLexicalDocument(
  { roomId: "my-room-id", client: liveblocks },
  async (doc) => {
    return doc.toMarkdown();
  }
);

// "# Hello world"
console.log(textContent);
```

Additionally you can modify the live document with
[`update`](/docs/api-reference/liveblocks-node-lexical#doc.update).

## Learn more

For more information about data storage and webhooks, check out these resources:

### API documentation

Learn more about the APIs for working with Yjs data:

- [YDocUpdated webhook event](/docs/platform/webhooks#YDocUpdatedEvent)
- [@liveblocks/node-prosemirror](/docs/api-reference/liveblocks-node-prosemirror)
- [@liveblocks/node-lexical](/docs/api-reference/liveblocks-node-lexical)
- [Data storage](/docs/platform/data-storage)

---
meta:
  title: "Fixing Next.js server component errors"
  description: "Learn how to fix Next.js server component problems"
---

## Fixing the warning: "Only plain objects can be passed to Client Components from Server Components"

This error occurs when you create a Liveblocks data structure (`LiveObject`,
`LiveList`, or `LiveMap`) within a server component. This is often occurs when
creating a room with `RoomProvider`, for example:

```tsx file="layout.tsx"
import { ReactNode } from "react";
import { RoomProvider } from "../liveblocks.config";
import { LiveObject } from "@liveblocks/client";

export default function Layout({ children }: { children: ReactNode }) {
  return (
    <html lang="en">
      <body>
        <RoomProvider
          id="my-room-name"
          initialStorage={{
            // âŒ This line causes the error
            session: new LiveObject(),
          }}
        >
          {children}
        </RoomProvider>
      </body>
    </html>
  );
}
```

This can be fixed by turning the file into a client file with `"use client";` at
the top of the file. However, if your need a server component, you can extract
the provider to a different file.

## Structuring your app

To take this further, and to learn how to structure your Next.js app in the best
possible way, make sure to read our
[How to use Liveblocks with Next.js /app directory](/docs/guides/how-to-use-liveblocks-with-nextjs-app-directory)
guide.

---
meta:
  title: "Getting ProseMirror state on the server"
  description:
    "Learn how to retrieve your documentâ€™s ProseMirror state on the server"
---

Using
[`@liveblocks/node-prosemirror`](/docs/api-reference/liveblocks-node-prosemirror),
itâ€™s possible to retrieve the state of your ProseMirror document on the server.

## Getting document state

To get your document state, you can use
[`withProsemirrorDocument`](/docs/api-reference/liveblocks-node-prosemirror#withProsemirrorDocument)
and
[`api.getText`](/docs/api-reference/liveblocks-node-prosemirror#api.getText).

```ts
import { Liveblocks } from "@liveblocks/node";
import { withProsemirrorDocument } from "@liveblocks/node-prosemirror";

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

// +++
const textContent = await withProsemirrorDocument(
  { roomId: "your-room-id", client: liveblocks, field: "prosemirror" },
  async (api) => {
    return api.getText();
  }
);
// +++

// "My content"
console.log(textContent);
```

## Modifying document state

To modify document state with transactions, use
[`api.update`](/docs/api-reference/liveblocks-node-prosemirror#api.update). On
the ProseMirror website you can find a full list of
[transforms](https://prosemirror.net/docs/ref/#transform.Document_transforms)
and
[transactions functions](https://prosemirror.net/docs/ref/#state.Transaction).

```ts
import { Liveblocks } from "@liveblocks/node";
import { withProsemirrorDocument } from "@liveblocks/node-prosemirror";

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

await withProsemirrorDocument(
  { roomId: "your-room-id", client: liveblocks, field: "prosemirror" },
  // +++
  async (api) => {
    await api.update((_, tr) => {
      // Transaction example
      return tr.insertText("Hello world");
    });
  }
  // +++
);
```

## Using Yjs APIs instead

We donâ€™t generally recommend it, but itâ€™s also possible to use
[`@liveblocks/node`](/docs/api-reference/liveblocks-node) to retrieve the state
of your ProseMirror document, and its [`Y.Doc`](https://docs.yjs.dev/api/y.doc),
on the server. This may give you more control in some cases.

Using
[`Liveblocks.getYjsDocumentAsBinaryUpdate`](/docs/api-reference/liveblocks-node#get-rooms-roomId-ydoc-binary)
you can fetch your Yjs data, and place it inside a `Y.Doc`. We can then call
`yDocToProseMirror` from [`y-prosemirror`](https://github.com/yjs/y-prosemirror)
to retrieve the ProseMirror editorâ€™s state.

```ts
import * as Y from "yjs";
import { Liveblocks } from "@liveblocks/node";
import { yDocToProsemirrorJSON } from "y-prosemirror";

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

export async function POST() {
  // Get your Yjs data as a binary update
  const update = await liveblocks.getYjsDocumentAsBinaryUpdate("my-room-name");

  // Create a Yjs document
  const yDoc = new Y.Doc();

  // Apply the binary update to `yDoc`
  Y.applyUpdate(yDoc, new Uint8Array(update));

  // Get ProseMirror state from the default Yjs property it uses, "prosemirror"
  const prosemirrorState = yDocToProsemirrorJSON(yDoc, "prosemirror");

  // { type: "doc", content: [{ type: "paragraph", content: [...] }] }
  console.log(prosemirrorState);
}
```

If youâ€™d like to edit your `Y.Doc`, make sure to read
[how to use your `Y.Doc` on the server](/docs/guides/how-to-use-your-ydoc-on-the-server).

---
meta:
  title: "Getting Tiptap state on the server"
  description:
    "Learn how to retrieve your documentâ€™s Tiptap state on the server"
---

Using
[`@liveblocks/node-prosemirror`](/docs/api-reference/liveblocks-node-prosemirror),
itâ€™s possible to retrieve the state of your Tiptap document on the server.
Tiptap is not easy to edit on the server directly, which is why itâ€™s necessary
to use the ProseMirror package. Tiptap is an extension of ProseMirror.

## Getting document state

To get your document state, you can use
[`withProsemirrorDocument`](/docs/api-reference/liveblocks-node-prosemirror#withProsemirrorDocument)
and
[`api.getText`](/docs/api-reference/liveblocks-node-prosemirror#api.getText).

```ts
import { Liveblocks } from "@liveblocks/node";
import { withProsemirrorDocument } from "@liveblocks/node-prosemirror";

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

// +++
const textContent = await withProsemirrorDocument(
  { roomId: "your-room-id", client: liveblocks },
  async (api) => {
    return api.getText();
  }
);
// +++

// "My content"
console.log(textContent);
```

## Modifying document state

To modify document state with transactions, use
[`api.update`](/docs/api-reference/liveblocks-node-prosemirror#api.update). On
the ProseMirror website you can find a full list of
[transforms](https://prosemirror.net/docs/ref/#transform.Document_transforms)
and
[transactions functions](https://prosemirror.net/docs/ref/#state.Transaction).

```ts
import { Liveblocks } from "@liveblocks/node";
import { withProsemirrorDocument } from "@liveblocks/node-prosemirror";

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

await withProsemirrorDocument(
  { roomId: "your-room-id", client: liveblocks },
  // +++
  async (api) => {
    await api.update((_, tr) => {
      // Transaction example
      return tr.insertText("Hello world");
    });
  }
  // +++
);
```

Youâ€™ve now learned to fetch and modify document state!

## Using Yjs APIs instead

We donâ€™t generally recommend it, but itâ€™s also possible to use
[`@liveblocks/node`](/docs/api-reference/liveblocks-node) to retrieve the state
of your Tiptap document, and its [`Y.Doc`](https://docs.yjs.dev/api/y.doc), on
the server. This may give you more control in some cases.

With
[`Liveblocks.getYjsDocumentAsBinaryUpdate`](/docs/api-reference/liveblocks-node#get-rooms-roomId-ydoc-binary)
you can fetch your Yjs data, and place it inside a `Y.Doc`. Because Tiptap is a
wrapper around ProseMirror, we can then call `yDocToProseMirror` from
[`y-prosemirror`](https://github.com/yjs/y-prosemirror) to retrieve the Tiptap
editorâ€™s state.

```ts
import * as Y from "yjs";
import { Liveblocks } from "@liveblocks/node";
import { yDocToProsemirrorJSON } from "y-prosemirror";

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

export async function POST() {
  // Get your Yjs data as a binary update
  const update = await liveblocks.getYjsDocumentAsBinaryUpdate("my-room-name");

  // Create a Yjs document
  const yDoc = new Y.Doc();

  // Apply the binary update to `yDoc`
  Y.applyUpdate(yDoc, new Uint8Array(update));

  // Get Tiptap state from the Yjs property it uses, "default"
  const tiptapState = yDocToProsemirrorJSON(yDoc, "default");

  // { type: "doc", content: [{ type: "paragraph", content: [...] }] }
  console.log(tiptapState);
}
```

If youâ€™d like to edit your `Y.Doc`, make sure to read
[how to use your `Y.Doc` on the server](/docs/guides/how-to-use-your-ydoc-on-the-server).

---
meta:
  title: "How to add users to Liveblocks Comments"
  description:
    "Learn how to add your userâ€™s avatars and names to Liveblocks Comments using
    the resolver functions."
---

After following the get started guide for Comments, youâ€™ll notice that each user
is currently â€œAnonymousâ€, and that thereâ€™s no way to mention or tag other users.
To enable these features, we need to tell Comments where to find your usersâ€™
information.

<Figure>
  <Image
    src="/assets/tutorials/comments/thread.png"
    alt="Thread with resolved users"
    width={1291}
    height={892}
  />
</Figure>

## What weâ€™re learning

In this guide weâ€™ll be modifying
[`LiveblocksProvider`](/docs/api-reference/liveblocks-react#LiveblocksProvider),
learning how to:

- Add names and avatars to threads and comments with
  [`resolveUsers`](/docs/api-reference/liveblocks-react#resolveUsers).
- Create user mention suggestions in the composer using
  [`resolveMentionSuggestions`](/docs/api-reference/liveblocks-react#resolveMentionSuggestions).

## Authenticate your application

The first step is to find an
[authentication guide for your framework](/docs/authentication) and authenticate
your app, as this is necessary for Comments.

Make sure to follow the metadata step in the guide, and attach the name of your
user, along with the URL of their avatar, as these properties will both be used
in the [default components](/docs/ready-made-features/comments#Components).
Hereâ€™s an example using ID token authentication, our recommended method, with an
email address as a userâ€™s ID.

```ts title="Metadata in ID tokens"
const { status, body } = await liveblocks.identifyUser(
  {
    userId: "marc@example.com",

    // Optional
    // tenantId: "org-id",
    // groupIds: ["group-id-1", "group-id-2"],
  },
  {
    userInfo: {
      name: "Marc",
      avatar: "https://example.com/marc.png",

      // Your custom metadata
      // ...
    },
  }
);
```

Modify your `UserMeta` type in `liveblocks.config.ts` to match the metadata
format, adding type hints to your editor.

```ts file="liveblocks.config.ts"
declare global {
  interface Liveblocks {
    UserMeta: {
      id: string;

      info: {
        name: string;
        avatar: string;

        // Your custom metadata
        // ...
      };
    };
  }
}
```

## Resolving users

To show each userâ€™s name and avatar in threads and comments, we need to use
[`resolveUsers`](https://liveblocks.io/docs/api-reference/liveblocks-client#resolveUsers).

<Figure>
  <Image
    src="/assets/tutorials/comments/thread.png"
    alt="Thread with resolved users"
    width={1291}
    height={892}
  />
</Figure>

<Steps>
  <Step>
    <StepTitle>Add the function to your LiveblocksProvider</StepTitle>
    <StepContent>
      The [`resolveUsers`](/docs/api-reference/liveblocks-react#LiveblocksProviderResolveUsers) function is passed as an option to
      [`LiveblocksProvider`](/docs/api-reference/liveblocks-react#LiveblocksProvider)â€”letâ€™s add it. This function
      provides you with `userIds`, an array of user IDs that have interacted with Comments.
      These `userIds` match the IDs set when authenticating users in your app.

      ```tsx highlight="2-8"
      <LiveblocksProvider
        resolveUsers={async ({ userIds }) => {
          // ["marc@example.com", ...]
          console.log(userIds);

          // Return a list of users
          // ...
        }}

        // ...
      />;
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Return your users</StepTitle>
    <StepContent>
      `resolveUsers` requires you to return a list of users in
      the `UserMeta["info"]` format we set earlier. Remember
      that _name_ and _avatar_ are required for the default components,
      but you can also use any other metadata in your app.

      ```tsx highlight="7-16"
      <LiveblocksProvider
        resolveUsers={async ({ userIds }) => {
          // ["marc@example.com", ...]
          console.log(userIds);

          // Return a list of users
          return [
            {
              name: "Marc",
              avatar: "https://example.com/marc.png",

              // Your custom metadata
              // ...
            },
            // ...
          ];
        }}

        // ...
      />;
      ```

      Weâ€™re only returning one user here, but make sure to return an
      array containing each user, in the same order you received the IDs.

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Real-world example</StepTitle>
    <StepContent>
      In your real application youâ€™ll probably be getting users from your
      API endpoint and database via `fetch`. This is how weâ€™d recommend
      building out this function.

      ```tsx highlight="3-7"
      <LiveblocksProvider
        resolveUsers={async ({ userIds }) => {
          // Get users from your back end
          const users = await __fetchUsers__(userIds);

          // Return a list of users
          return users;
        }}

        // ...
      />;
      ```

    </StepContent>

  </Step>
  <Step lastStep>
    <StepTitle>Users are now visible</StepTitle>
    <StepContent>
      After adding this, you should now be able to see your users in threads!

      <Figure>
        <Image
          src="/assets/tutorials/comments/thread.png"
          alt="Thread with resolved users"
          width={1291}
          height={892}
        />
      </Figure>

    </StepContent>

  </Step>
</Steps>

## Resolving mention suggestions

We can see the users that have commented, but we donâ€™t have a way to search for
users to mention, for example after typing the `@` character. We can create a
simple search that resolves this data with
[`resolveMentionSuggestions`](/docs/api-reference/liveblocks-react#resolveMentionSuggestions).

<Figure>
  <Image
    src="/assets/tutorials/comments/mentions.png"
    alt="Working Comments mentions"
    width={1297}
    height={781}
  />
</Figure>

<Steps>
  <Step>
    <StepTitle>Add the function to your config file</StepTitle>
    <StepContent>
      `resolveMentionSuggestions` is placed alongside `resolveUsers`, and
      provides you with `text`, which is the string that the user is searching for.
      You can use this string to return a list of matching user IDs.

      ```tsx highlight="5-11"
      <LiveblocksProvider
        resolveUsers={async ({ userIds }) => {
          // ...
        }}
        resolveMentionSuggestions={async ({ text, roomId }) => {
          // The text the user is searching for, e.g. "mar"
          console.log(text);

          // Return a list of user IDs that match the query
          return ["marc@example.com", "marissa@example.com"];
        }}

        // ...
      />;
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Real-world example</StepTitle>
    <StepContent>

      In a real application, youâ€™ll most likely be getting a list of each user,
      before filtering the list by the userâ€™s names or IDs. If `text` is an empty
      string, then you need to return a list of every user, instead of a filtered list.

      ```tsx highlight="6-16"
      <LiveblocksProvider
        resolveUsers={async ({ userIds }) => {
          // ...
        }}
        resolveMentionSuggestions={async ({ text, roomId }) => {
          // Fetch all users from your back end
          let users = await __fetchAllUsers__();

          // If there's a query, filter for the relevant users
          if (text) {
            // Filter any way you'd like, e.g. checking if the name matches
            users = users.filter((user) => user.name.includes(text));
          }

          // Return the filtered `userIds`
          return users.map((user) => user.id);
        }}

        // ...
      />;
      ```

    </StepContent>

  </Step>
  <Step lastStep>
    <StepTitle>Mention suggestions now appear</StepTitle>
    <StepContent>

      Now weâ€™ve found and returned the correct users, Comments can display
      a list of mention suggestions!

      <Figure>
        <Image
          src="/assets/tutorials/comments/mentions.png"
          alt="Working Comments mentions"
          width={1297}
          height={781}
        />
      </Figure>

    </StepContent>

  </Step>
</Steps>

## Next steps

Youâ€™re now ready to start building your Comments application! Hereâ€™s where you
can learn more:

- [API reference](/docs/api-reference/liveblocks-react#Comments)
- [Component reference](/docs/api-reference/liveblocks-react-ui#Comments)
- [Examples](/examples/browse/comments)

---
meta:
  title: "How to add users to Liveblocks Notifications"
  description:
    "Learn how to add your userâ€™s avatars and names to Liveblocks Notifications
    using the resolver functions."
---

After following the get started guide for Notifications, and sending
notifications with [Comments](/docs/ready-made-features/comments) or
[Text editor](/docs/ready-made-features/text-editor), youâ€™ll notice that each
user is currently â€œAnonymousâ€, and that thereâ€™s no way to mention or tag other
users. To enable these features, we need to tell Notifications where to find
your usersâ€™ information.

<Figure>
  <Image
    src="/assets/notifications/notifications-inbox.jpg"
    alt="Thread"
    width={1344}
    height={896}
  />
</Figure>

## What weâ€™re learning

In this guide weâ€™ll be modifying
[`LiveblocksProvider`](/docs/api-reference/liveblocks-react#LiveblocksProvider),
learning how to:

- Add names and avatars to notifications with
  [`resolveUsers`](/docs/api-reference/liveblocks-react#resolveUsers).

## Authenticate your application

The first step is to find an
[authentication guide for your framework](/docs/authentication) and authenticate
your app, as this is necessary for Notifications.

Make sure to follow the metadata step in the guide, and attach the name of your
user, along with the URL of their avatar, as these properties will both be used
in the [default components](/docs/ready-made-features/notifications#Components).
Hereâ€™s an example using ID token authentication, our recommended method, with an
email address as a userâ€™s ID.

```ts title="Metadata in ID tokens"
const { status, body } = await liveblocks.identifyUser(
  {
    userId: "marc@example.com",

    // Optional
    // tenantId: "org-id",
    // groupIds: ["group-id-1", "group-id-2"],
  },
  {
    userInfo: {
      name: "Marc",
      avatar: "https://example.com/marc.png",

      // Your custom metadata
      // ...
    },
  }
);
```

Modify your `UserMeta` type in `liveblocks.config.ts` to match the metadata
format, adding type hints to your editor.

```ts file="liveblocks.config.ts"
declare global {
  interface Liveblocks {
    UserMeta: {
      id: string;

      info: {
        name: string;
        avatar: string;

        // Your custom metadata
        // ...
      };
    };
  }
}
```

## Resolving users

To show each userâ€™s name and avatar in threads and comments, we need to use
[`resolveUsers`](https://liveblocks.io/docs/api-reference/liveblocks-client#resolveUsers).

<Figure>
  <Image
    src="/assets/notifications/notifications-inbox.jpg"
    alt="Thread"
    width={1344}
    height={896}
  />
</Figure>

<Steps>
  <Step>
    <StepTitle>Add the function to your LiveblocksProvider</StepTitle>
    <StepContent>
      The [`resolveUsers`](/docs/api-reference/liveblocks-react#LiveblocksProviderResolveUsers) function is passed as an option to
      [`LiveblocksProvider`](/docs/api-reference/liveblocks-react#LiveblocksProvider)â€”letâ€™s add it. This function
      provides you with `userIds`, an array of user IDs that have interacted with Notifications.
      These `userIds` match the IDs set when authenticating users in your app.

      ```tsx highlight="2-8"
      <LiveblocksProvider
        resolveUsers={async ({ userIds }) => {
          // ["marc@example.com", ...]
          console.log(userIds);

          // Return a list of users
          // ...
        }}

        // ...
      />;
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Return your users</StepTitle>
    <StepContent>
      `resolveUsers` requires you to return a list of users in
      the `UserMeta["info"]` format we set earlier. Remember
      that _name_ and _avatar_ are required for the default components,
      but you can also use any other metadata in your app.

      ```tsx highlight="7-16"
      <LiveblocksProvider
        resolveUsers={async ({ userIds }) => {
          // ["marc@example.com", ...]
          console.log(userIds);

          // Return a list of users
          return [
            {
              name: "Marc",
              avatar: "https://example.com/marc.png",

              // Your custom metadata
              // ...
            },
            // ...
          ];
        }}

        // ...
      />;
      ```

      Weâ€™re only returning one user here, but make sure to return an
      array containing each user, in the same order you received the IDs.

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Real-world example</StepTitle>
    <StepContent>
      In your real application youâ€™ll probably be getting users from your
      API endpoint and database via `fetch`. This is how weâ€™d recommend
      building out this function.

      ```tsx highlight="3-7"
      <LiveblocksProvider
        resolveUsers={async ({ userIds }) => {
          // Get users from your back end
          const users = await __fetchUsers__(userIds);

          // Return a list of users
          return users;
        }}

        // ...
      />;
      ```

    </StepContent>

  </Step>
  <Step lastStep>
    <StepTitle>Users are now visible</StepTitle>
    <StepContent>
      After adding this, you should now be able to see your users in notifications!

      <Figure>
        <Image
          src="/assets/notifications/notifications-inbox.jpg"
          alt="Thread"
          width={1344}
          height={896}
        />
      </Figure>

    </StepContent>

  </Step>
</Steps>

## Next steps

Youâ€™re now ready to start building your Notifications application! Hereâ€™s where
you can learn more:

- [API reference](/docs/api-reference/liveblocks-react#Notifications)
- [Component reference](/docs/api-reference/liveblocks-react-ui#Notifications)
- [Examples](/examples/browse/notifications)

---
meta:
  title: "How to add users to Liveblocks Text Editor"
  description:
    "Learn how to add your userâ€™s avatars and names to Liveblocks Text Editor
    using the resolver functions."
---

After following the get started guide for Text Editor, youâ€™ll notice that each
user is currently â€œAnonymousâ€, and that thereâ€™s no way to mention or tag other
users. To enable these features, we need to tell Text Editor where to find your
usersâ€™ information.

<Figure>
  <Image
    src="/assets/text-editor/mentions.png"
    alt="User mentions"
    width={1312}
    height={874}
  />
</Figure>

## What weâ€™re learning

In this guide weâ€™ll be modifying
[`LiveblocksProvider`](/docs/api-reference/liveblocks-react#LiveblocksProvider),
learning how to:

- Add names and avatars to cursors and suggestions with
  [`resolveUsers`](/docs/api-reference/liveblocks-react#resolveUsers).
- Create user mention suggestions in the editor using
  [`resolveMentionSuggestions`](/docs/api-reference/liveblocks-react#resolveMentionSuggestions).

## Authenticate your application

The first step is to find an
[authentication guide for your framework](/docs/authentication) and authenticate
your app, as this is necessary for Text Editor.

Make sure to follow the metadata step in the guide, and attach the name of your
user, the color of their cursor, and their avatar URL, as these properties will
both be used in the [Text editor](/docs/ready-made-features/text-editor). Hereâ€™s
an example using ID token authentication, our recommended method, with an email
address as a userâ€™s ID.

```ts title="Metadata in ID tokens"
const { status, body } = await liveblocks.identifyUser(
  {
    userId: "marc@example.com",

    // Optional
    // tenantId: "org-id",
    // groupIds: ["group-id-1", "group-id-2"],
  },
  {
    userInfo: {
      name: "Marc",
      avatar: "https://example.com/marc.png",

      // Your custom metadata
      // ...
    },
  }
);
```

Modify your `UserMeta` type in `liveblocks.config.ts` to match the metadata
format, adding type hints to your editor.

```ts file="liveblocks.config.ts"
declare global {
  interface Liveblocks {
    UserMeta: {
      id: string;

      info: {
        name: string;
        avatar: string;

        // Your custom metadata
        // ...
      };
    };
  }
}
```

## Resolving users

To show each userâ€™s name and color in their cursors, we need to use
[`resolveUsers`](https://liveblocks.io/docs/api-reference/liveblocks-client#resolveUsers).

<Figure>
  <Image
    src="/assets/text-editor/cursors.png"
    alt="Real-time text cursors"
    width={1312}
    height={874}
  />
</Figure>

<Steps>
  <Step>
    <StepTitle>Add the function to your LiveblocksProvider</StepTitle>
    <StepContent>
      The [`resolveUsers`](/docs/api-reference/liveblocks-react#LiveblocksProviderResolveUsers) function is passed as an option to
      [`LiveblocksProvider`](/docs/api-reference/liveblocks-react#LiveblocksProvider)â€”letâ€™s add it. This function
      provides you with `userIds`, an array of user IDs that have interacted with Text Editor.
      These `userIds` match the IDs set when authenticating users in your app.

      ```tsx highlight="2-8"
      <LiveblocksProvider
        resolveUsers={async ({ userIds }) => {
          // ["marc@example.com", ...]
          console.log(userIds);

          // Return a list of users
          // ...
        }}

        // ...
      />;
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Return your users</StepTitle>
    <StepContent>
      `resolveUsers` requires you to return a list of users in
      the `UserMeta["info"]` format we set earlier. Remember
      that _name_, _color_, and _avatar_, are required for the editor component,
      but you can also use any other metadata in your app.

      ```tsx highlight="7-17"
      <LiveblocksProvider
        resolveUsers={async ({ userIds }) => {
          // ["marc@example.com", ...]
          console.log(userIds);

          // Return a list of users
          return [
            {
              name: "Marc",
              color: "#00ff00",
              avatar: "https://example.com/marc.png",

              // Your custom metadata
              // ...
            },
            // ...
          ];
        }}

        // ...
      />;
      ```

      Weâ€™re only returning one user here, but make sure to return an
      array containing each user, in the same order you received the IDs.

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Real-world example</StepTitle>
    <StepContent>
      In your real application youâ€™ll probably be getting users from your
      API endpoint and database via `fetch`. This is how weâ€™d recommend
      building out this function.

      ```tsx highlight="3-7"
      <LiveblocksProvider
        resolveUsers={async ({ userIds }) => {
          // Get users from your back end
          const users = await __fetchUsers__(userIds);

          // Return a list of users
          return users;
        }}

        // ...
      />;
      ```

    </StepContent>

  </Step>
  <Step lastStep>
    <StepTitle>Users are now visible</StepTitle>
    <StepContent>
      After adding this, you should now be able to see your user names in cursors!

      <Figure>
        <Image
          src="/assets/text-editor/cursors.png"
          alt="Real-time text cursors"
          width={1312}
          height={874}
        />
      </Figure>

    </StepContent>

  </Step>
</Steps>

## Resolving mention suggestions

We can see the users that are connected, but we donâ€™t have a way to search for
users to mention inline, for example after typing the `@` character. We can
create a simple search that resolves this data with
[`resolveMentionSuggestions`](/docs/api-reference/liveblocks-react#resolveMentionSuggestions).

<Figure>
  <Image
    src="/assets/text-editor/mentions.png"
    alt="User mentions"
    width={1312}
    height={874}
  />
</Figure>

<Steps>
  <Step>
    <StepTitle>Add the function to your config file</StepTitle>
    <StepContent>
      `resolveMentionSuggestions` is placed alongside `resolveUsers`, and
      provides you with `text`, which is the string that the user is searching for.
      You can use this string to return a list of matching user IDs.

      ```tsx highlight="5-11"
      <LiveblocksProvider
        resolveUsers={async ({ userIds }) => {
          // ...
        }}
        resolveMentionSuggestions={async ({ text, roomId }) => {
          // The text the user is searching for, e.g. "mar"
          console.log(text);

          // Return a list of user IDs that match the query
          return ["marc@example.com", "marissa@example.com"];
        }}

        // ...
      />;
      ```

    </StepContent>

  </Step>
  <Step>
    <StepTitle>Real-world example</StepTitle>
    <StepContent>

      In a real application, youâ€™ll most likely be getting a list of each user,
      before filtering the list by the userâ€™s names or IDs. If `text` is an empty
      string, then you need to return a list of every user, instead of a filtered list.

      ```tsx highlight="6-16"
      <LiveblocksProvider
        resolveUsers={async ({ userIds }) => {
          // ...
        }}
        resolveMentionSuggestions={async ({ text, roomId }) => {
          // Fetch all users from your back end
          let users = await __fetchAllUsers__();

          // If there's a query, filter for the relevant users
          if (text) {
            // Filter any way you'd like, e.g. checking if the name matches
            users = users.filter((user) => user.name.includes(text));
          }

          // Return the filtered `userIds`
          return users.map((user) => user.id);
        }}

        // ...
      />;
      ```

    </StepContent>

  </Step>
  <Step lastStep>
    <StepTitle>Mention suggestions now appear</StepTitle>
    <StepContent>

      Now weâ€™ve found and returned the correct users, Text Editor can display
      a list of mention suggestions!

      <Figure>
        <Image
          src="/assets/text-editor/mentions.png"
          alt="User mentions"
          width={1312}
          height={874}
        />
      </Figure>

    </StepContent>

  </Step>
</Steps>

## Next steps

Youâ€™re now ready to start building your Text Editor application! Hereâ€™s where
you can learn more:

- [API reference for Lexical React](/docs/api-reference/liveblocks-react-lexical)
- [API reference for Lexical Node](/docs/api-reference/liveblocks-node-lexical)
- [Examples](/examples/browse/text-editor)
- [Overview](/docs/ready-made-features/text-editor)

---
meta:
  title:
    "How to create a collaborative code editor with CodeMirror, Yjs, Next.js,
    and Liveblocks"
  description:
    "Build a collaborative code editor with CodeMirror, Yjs, Next.js, and
    Liveblocks"
---

In this tutorial, weâ€™ll be building a collaborative code editor using
CodeMirror, Yjs, Next.js, and Liveblocks.

<Figure>
  <video autoPlay loop muted playsInline>
    <source
      src="/assets/tutorials/code-editors/code-editor-demo.mp4"
      type="video/mp4"
    />
  </video>
</Figure>

This guide assumes that youâ€™re already familiar with
[React](https://react.dev/), [Next.js](https://nextjs.org/),
[TypeScript](https://www.typescriptlang.org/), and
[CodeMirror](https://codemirror.net/).

## Install CodeMirror, Yjs, and Liveblocks into your Next.js application

<Banner title="Download the example">

On GitHub we have a working example of this
[collaborative CodeMirror editor](https://github.com/liveblocks/liveblocks/tree/main/examples/nextjs-yjs-codemirror)
for you to download and run.

</Banner>

Run the following command to install the CodeMirror, Yjs, and Liveblocks
packages:

```bash
npm install @liveblocks/client @liveblocks/react @liveblocks/node @liveblocks/yjs yjs codemirror @codemirror/lang-javascript y-codemirror.next
```

## Set up access token authentication

The first step in connecting to Liveblocks is to set up an authentication
endpoint in `/app/api/liveblocks-auth/route.ts`.

```ts
import { Liveblocks } from "@liveblocks/node";
import { NextRequest } from "next/server";

const API_KEY = "{{SECRET_KEY}}";

const liveblocks = new Liveblocks({
  secret: API_KEY!,
});

export async function POST(request: NextRequest) {
  // Get the current user's info from your database
  const user = {
    id: "charlielayne@example.com",
    info: {
      name: "Charlie Layne",
      color: "#D583F0",
      picture: "https://liveblocks.io/avatars/avatar-1.png",
    },
  };

  // Create a session for the current user
  // userInfo is made available in Liveblocks presence hooks, e.g. useOthers
  const session = liveblocks.prepareSession(user.id, {
    userInfo: user.info,
  });

  // Give the user access to the room
  const { room } = await request.json();
  session.allow(room, session.FULL_ACCESS);

  // Authorize the user and return the result
  const { body, status } = await session.authorize();
  return new Response(body, { status });
}
```

Hereâ€™s an example using the older API routes format in `/pages`.

```ts file="pages/api/liveblocks-auth.ts" isCollapsed isCollapsable
import { Liveblocks } from "@liveblocks/node";
import type { NextApiRequest, NextApiResponse } from "next";

const API_KEY = "{{SECRET_KEY}}";

const liveblocks = new Liveblocks({
  secret: API_KEY!,
});

export default async function handler(
  request: NextApiRequest,
  response: NextApiResponse
) {
  // Get the current user's info from your database
  const user = {
    id: "charlielayne@example.com",
    info: {
      name: "Charlie Layne",
      color: "#D583F0",
      picture: "https://liveblocks.io/avatars/avatar-1.png",
    },
  };

  // Create a session for the current user
  // userInfo is made available in Liveblocks presence hooks, e.g. useOthers
  const session = liveblocks.prepareSession(user.id, {
    userInfo: user.info,
  });

  // Give the user access to the room
  const { room } = request.body;
  session.allow(room, session.FULL_ACCESS);

  // Authorize the user and return the result
  const { status, body } = await session.authorize();
  response.status(status).send(body);
}
```

## Initialize your Liveblocks config file

Letâ€™s initialize the `liveblocks.config.ts` file in which youâ€™ll set up the
Liveblocks client.

```bash
npx create-liveblocks-app@latest --init --framework react
```

Weâ€™ll also need another type for this tutorial. After creating the config file,
open it up and insert the following:

```tsx file="liveblocks.config.ts"
import { LiveblocksYjsProvider } from "@liveblocks/yjs";

// ...

export type TypedLiveblocksProvider = LiveblocksYjsProvider<
  Presence,
  Storage,
  UserMeta,
  RoomEvent
>;
```

## Join a Liveblocks room

Liveblocks uses the concept of rooms, separate virtual spaces where people
collaborate. To create a realtime experience, multiple users must be connected
to the same room. Create a file in the current directory within `/app`, and name
it `Room.tsx`. Pass the location of your endpoint to `LiveblocksProvider`.

```tsx file="/app/Room.tsx"
"use client";

import { ReactNode } from "react";
import {
  LiveblocksProvider,
  RoomProvider,
  ClientSideSuspense,
} from "@liveblocks/react/suspense";

export function Room({ children }: { children: ReactNode }) {
  return (
    <LiveblocksProvider authEndpoint="/api/liveblocks-auth">
      <RoomProvider id="my-room">
        <ClientSideSuspense fallback={<div>Loadingâ€¦</div>}>
          {children}
        </ClientSideSuspense>
      </RoomProvider>
    </LiveblocksProvider>
  );
}
```

## Set up the CodeMirror editor

Now that weâ€™ve set up Liveblocks, we can start integrating Monaco and Yjs in the
`Editor.tsx` file.

```tsx file="Editor.tsx"
"use client";

import * as Y from "yjs";
import { yCollab } from "y-codemirror.next";
import { EditorView, basicSetup } from "codemirror";
import { EditorState } from "@codemirror/state";
import { javascript } from "@codemirror/lang-javascript";
import { useCallback, useEffect, useState } from "react";
import { LiveblocksYjsProvider } from "@liveblocks/yjs";
import { TypedLiveblocksProvider, useRoom } from "@/liveblocks.config";
import styles from "./CollaborativeEditor.module.css";

// Collaborative code editor with undo/redo, live cursors, and live avatars
export function CollaborativeEditor() {
  const room = useRoom();
  const [element, setElement] = useState<HTMLElement>();
  const [yUndoManager, setYUndoManager] = useState<Y.UndoManager>();

  const ref = useCallback((node: HTMLElement | null) => {
    if (!node) return;
    setElement(node);
  }, []);

  // Set up Liveblocks Yjs provider and attach CodeMirror editor
  useEffect(() => {
    let provider: TypedLiveblocksProvider;
    let ydoc: Y.Doc;
    let view: EditorView;

    if (!element || !room || !userInfo) {
      return;
    }

    // Create Yjs provider and document
    ydoc = new Y.Doc();
    provider = new LiveblocksYjsProvider(room as any, ydoc);
    const ytext = ydoc.getText("codemirror");
    const undoManager = new Y.UndoManager(ytext);
    setYUndoManager(undoManager);

    // Set up CodeMirror and extensions
    const state = EditorState.create({
      doc: ytext.toString(),
      extensions: [
        basicSetup,
        javascript(),
        yCollab(ytext, provider.awareness, { undoManager }),
      ],
    });

    // Attach CodeMirror to element
    view = new EditorView({
      state,
      parent: element,
    });

    return () => {
      ydoc?.destroy();
      provider?.destroy();
      view?.destroy();
    };
  }, [element, room, userInfo]);

  return (
    <div className={styles.container}>
      <div className={styles.editorContainer} ref={ref}></div>
    </div>
  );
}
```

And here is the `Editor.module.css` file to make sure your multiplayer text
editor looks nice and tidy.

```css file="Editor.module.css" isCollapsed isCollapsable
.container {
  display: flex;
  flex-direction: column;
  position: relative;
  border-radius: 12px;
  background: #fff;
  width: 100%;
  height: 100%;
  color: #111827;
  overflow: hidden;
}

.editorHeader {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.editorContainer {
  position: relative;
  flex-grow: 1;
  overflow: auto;
}
```

## Add your editor to the current page

Next, add the `CollaborativeEditor` into the page file, and place it inside the
`Room` component we created earlier. We should now be seeing a basic
collaborative editor!

```tsx file="/app/page.tsx"
import { Room } from "./Room";
import CollaborativeEditor from "@/components/Editor";

export default function Page() {
  return (
    <Room>
      <CollaborativeEditor />
    </Room>
  );
}
```

## Add live cursors

To add live cursors to the code editor, we can get the `userInfo` for the
current user with [`useSelf`](/docs/api-reference/liveblocks-react#useSelf), and
attach it Yjs awareness. After adding the following, you should see live
cursors:

```tsx file="Cursors.tsx" highlight="1,10-11,35-40"
import { useRoom, useSelf } from "@/liveblocks.config";
// ...

// Collaborative code editor with undo/redo, live cursors, and live avatars
export function CollaborativeEditor() {
  const room = useRoom();
  const [element, setElement] = useState<HTMLElement>();
  const [yUndoManager, setYUndoManager] = useState<Y.UndoManager>();

  // Get user info from Liveblocks authentication endpoint
  const userInfo = useSelf((me) => me.info);

  const ref = useCallback((node: HTMLElement | null) => {
    if (!node) return;
    setElement(node);
  }, []);

  // Set up Liveblocks Yjs provider and attach CodeMirror editor
  useEffect(() => {
    let provider: TypedLiveblocksProvider;
    let ydoc: Y.Doc;
    let view: EditorView;

    if (!element || !room || !userInfo) {
      return;
    }

    // Create Yjs provider and document
    ydoc = new Y.Doc();
    provider = new LiveblocksYjsProvider(room as any, ydoc);
    const ytext = ydoc.getText("codemirror");
    const undoManager = new Y.UndoManager(ytext);
    setYUndoManager(undoManager);

    // Attach user info to Yjs
    provider.awareness.setLocalStateField("user", {
      name: userInfo.name,
      color: userInfo.color,
      colorLight: userInfo.color + "80", // 6-digit hex code at 50% opacity
    });

    // Set up CodeMirror and extensions
    const state = EditorState.create({
      doc: ytext.toString(),
      extensions: [
        basicSetup,
        javascript(),
        yCollab(ytext, provider.awareness, { undoManager }),
      ],
    });

    // Attach CodeMirror to element
    view = new EditorView({
      state,
      parent: element,
    });

    return () => {
      ydoc?.destroy();
      provider?.destroy();
      view?.destroy();
    };
  }, [element, room, userInfo]);

  return (
    <div className={styles.container}>
      <div className={styles.editorContainer} ref={ref}></div>
    </div>
  );
}
```

We can style these cursors by placing CSS in a global CSS file.

```css file="globals.css" isCollapsed isCollapsable
/* Cursor name */
.cm-editor .cm-ySelectionInfo {
  position: absolute;
  top: -1.6em;
  left: -1px;
  padding: 2px 6px;
  opacity: 1;
  color: #fff;
  border: 0;
  border-radius: 6px;
  border-bottom-left-radius: 0;
  line-height: normal;
  white-space: nowrap;
  font-size: 14px;
  font-family: sans-serif;
  font-style: normal;
  font-weight: 600;
  pointer-events: none;
  user-select: none;
  z-index: 1000;
}

.cm-editor .cm-ySelectionCaretDot {
  display: none;
}

/* Other CodeMirror styles */
.cm-editor {
  height: 100%;
  font-size: 14px;
}

.cm-editor.cm-focused {
  outline: none;
}

.cm-editor .cm-scroller {
  padding-top: 1rem;
}

.cm-editor .cm-gutters {
  background: none;
  border: 0;
}

.cm-editor .cm-lineNumbers .cm-gutterElement {
  padding-left: 1rem;
  padding-right: 0.5rem;
}
```

## Add a toolbar

From this point onwards, you can build your CodeMirror app as normal! For
example, should you wish to add a basic undo/redo toolbar to your app:

```tsx file="Toolbar.tsx"
import * as Y from "yjs";
import styles from "./Toolbar.module.css";

type Props = {
  yUndoManager: Y.UndoManager;
};

export function Toolbar({ yUndoManager }: Props) {
  return (
    <div className={styles.toolbar}>
      <button className={styles.button} onClick={() => yUndoManager.undo()}>
        Undo
      </button>
      <button className={styles.button} onClick={() => yUndoManager.redo()}>
        Redo
      </button>
    </div>
  );
}
```

Add some matching styles:

```css file="Toolbar.module.css" isCollapsed isCollapsable
.toolbar {
  display: flex;
  padding: 1em;
  gap: 6px;
}

.button {
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  border-radius: 6px;
  height: 32px;
  width: 32px;
  background: #fff;
  color: #1f2937;
  border: none;
  box-shadow:
    rgba(0, 0, 0, 0.12) 0 4px 8px 0,
    rgba(0, 0, 0, 0.02) 0 0 0 1px;
}

.button:hover {
  color: #111827;
  box-shadow:
    rgba(0, 0, 0, 0.16) 0 5px 8px 0,
    rgba(0, 0, 0, 0.04) 0 0 0 1px;
}

.button:focus-visible {
  outline-offset: 2px;
}
```

You can then import this into your editor to enable basic CodeMirror features:

```tsx file="Editor.tsx" highlight="1,9-13"
import { Toolbar } from "@/components/Toolbar";
// ...

export function CollaborativeEditor() {
  // ...

  return (
    <div className={styles.container}>
      <div className={styles.editorHeader}>
        <div>
          {yUndoManager ? <Toolbar yUndoManager={yUndoManager} /> : null}
        </div>
      </div>
      <div className={styles.editorContainer} ref={ref}></div>
    </div>
  );
}
```

## Create live avatars with Liveblocks hooks

Along with building out your code editor, you can now use other Liveblocks
features, such as [Presence](/docs/ready-made-features/presence). The
[`useOthers`](/docs/api-reference/liveblocks-react#useOthers) hook allows us to
view information about each user currently online, and we can turn this into a
live avatars component.

```tsx file="Avatars.tsx"
import { useOthers, useSelf } from "@/liveblocks.config";
import styles from "./Avatars.module.css";

export function Avatars() {
  const users = useOthers();
  const currentUser = useSelf();

  return (
    <div className={styles.avatars}>
      {users.map(({ connectionId, info }) => {
        return (
          <Avatar key={connectionId} picture={info.picture} name={info.name} />
        );
      })}

      {currentUser && (
        <div className="relative ml-8 first:ml-0">
          <Avatar
            picture={currentUser.info.picture}
            name={currentUser.info.name}
          />
        </div>
      )}
    </div>
  );
}

export function Avatar({ picture, name }: { picture: string; name: string }) {
  return (
    <div className={styles.avatar} data-tooltip={name}>
      <img
        src={picture}
        className={styles.avatar_picture}
        data-tooltip={name}
      />
    </div>
  );
}
```

And hereâ€™s the styles:

```css file="Avatars.module.css" isCollapsed isCollapsable
.avatars {
  display: flex;
  padding: 0 0.75rem;
}

.avatar {
  display: flex;
  place-content: center;
  position: relative;
  border: 4px solid #fff;
  border-radius: 9999px;
  width: 42px;
  height: 42px;
  background-color: #9ca3af;
  margin-left: -0.75rem;
}

.avatar:before {
  content: attr(data-tooltip);
  position: absolute;
  top: 100%;
  opacity: 0;
  transition: opacity 0.15s ease;
  padding: 5px 10px;
  color: white;
  font-size: 0.75rem;
  border-radius: 8px;
  margin-top: 10px;
  z-index: 1;
  background: black;
  white-space: nowrap;
}

.avatar:hover:before {
  opacity: 1;
}

.avatar_picture {
  width: 100%;
  height: 100%;
  border-radius: 9999px;
}
```

You can then import this to your editor to see it in action:

```tsx file="Editor.tsx" highlight="1,13"
import { Avatars } from "@/components/Avatars";
// ...

export function CollaborativeEditor() {
  // ...

  return (
    <div className={styles.container}>
      <div className={styles.editorHeader}>
        <div>
          {yUndoManager ? <Toolbar yUndoManager={yUndoManager} /> : null}
        </div>
        <Avatars />
      </div>
      <div className={styles.editorContainer} ref={ref}></div>
    </div>
  );
}
```

Note that the cursors and avatars match in color and name, as the info for both
is sourced from the Liveblocks authentication endpoint.

## Try it out

You should now see the complete editor, along with live cursors, live avatars,
and some basic features! On GitHub we have a working example of this
[multiplayer code editor](https://github.com/liveblocks/liveblocks/tree/main/examples/nextjs-yjs-codemirror).

<Figure>
  <video autoPlay loop muted playsInline>
    <source
      src="/assets/tutorials/code-editors/code-editor-demo.mp4"
      type="video/mp4"
    />
  </video>
</Figure>

---
meta:
  title:
    "How to create a collaborative code editor with Monaco, Yjs, Next.js, and
    Liveblocks"
  description:
    "Build a collaborative code editor with Monaco, Yjs, Next.js, and Liveblocks"
---

In this tutorial, weâ€™ll be building a collaborative code editor using Monaco,
Yjs, Next.js, and Liveblocks.

<Figure>
  <video autoPlay loop muted playsInline>
    <source
      src="/assets/tutorials/code-editors/code-editor-demo.mp4"
      type="video/mp4"
    />
  </video>
</Figure>

This guide assumes that youâ€™re already familiar with
[React](https://react.dev/), [Next.js](https://nextjs.org/),
[TypeScript](https://www.typescriptlang.org/), and
[Monaco](https://microsoft.github.io/monaco-editor/).

## Install Monaco, Yjs, and Liveblocks into your Next.js application

<Banner title="Download the example">

On GitHub we have a working example of this
[collaborative Monaco editor](https://github.com/liveblocks/liveblocks/tree/main/examples/nextjs-yjs-monaco)
for you to download and run.

</Banner>

Run the following command to install the Monaco, Yjs, and Liveblocks packages:

```bash
npm install @liveblocks/client @liveblocks/react @liveblocks/yjs yjs @monaco-editor/react y-monaco y-protocols
```

## Set up access token authentication

The first step in connecting to Liveblocks is to set up an authentication
endpoint in `/app/api/liveblocks-auth/route.ts`.

```ts
import { Liveblocks } from "@liveblocks/node";
import { NextRequest } from "next/server";

const API_KEY = "{{SECRET_KEY}}";

const liveblocks = new Liveblocks({
  secret: API_KEY!,
});

export async function POST(request: NextRequest) {
  // Get the current user's info from your database
  const user = {
    id: "charlielayne@example.com",
    info: {
      name: "Charlie Layne",
      color: "#D583F0",
      picture: "https://liveblocks.io/avatars/avatar-1.png",
    },
  };

  // Create a session for the current user
  // userInfo is made available in Liveblocks presence hooks, e.g. useOthers
  const session = liveblocks.prepareSession(user.id, {
    userInfo: user.info,
  });

  // Give the user access to the room
  const { room } = await request.json();
  session.allow(room, session.FULL_ACCESS);

  // Authorize the user and return the result
  const { body, status } = await session.authorize();
  return new Response(body, { status });
}
```

Hereâ€™s an example using the older API routes format in `/pages`.

```ts file="pages/api/liveblocks-auth.ts" isCollapsed isCollapsable
import { Liveblocks } from "@liveblocks/node";
import type { NextApiRequest, NextApiResponse } from "next";

const API_KEY = "{{SECRET_KEY}}";

const liveblocks = new Liveblocks({
  secret: API_KEY!,
});

export default async function handler(
  request: NextApiRequest,
  response: NextApiResponse
) {
  // Get the current user's info from your database
  const user = {
    id: "charlielayne@example.com",
    info: {
      name: "Charlie Layne",
      color: "#D583F0",
      picture: "https://liveblocks.io/avatars/avatar-1.png",
    },
  };

  // Create a session for the current user
  // userInfo is made available in Liveblocks presence hooks, e.g. useOthers
  const session = liveblocks.prepareSession(user.id, {
    userInfo: user.info,
  });

  // Give the user access to the room
  const { room } = request.body;
  session.allow(room, session.FULL_ACCESS);

  // Authorize the user and return the result
  const { status, body } = await session.authorize();
  response.status(status).send(body);
}
```

## Initialize your Liveblocks config file

Letâ€™s initialize the `liveblocks.config.ts` file in which youâ€™ll set up the
Liveblocks client.

```bash
npx create-liveblocks-app@latest --init --framework react
```

Weâ€™ll also need another type for this tutorial. After creating the config file,
open it up and insert the following:

```tsx file="liveblocks.config.ts"
import { LiveblocksYjsProvider } from "@liveblocks/yjs";

// ...

export type TypedLiveblocksProvider = LiveblocksYjsProvider<
  Presence,
  Storage,
  UserMeta,
  RoomEvent
>;
```

## Join a Liveblocks room

Liveblocks uses the concept of rooms, separate virtual spaces where people
collaborate. To create a realtime experience, multiple users must be connected
to the same room. Create a file in the current directory within `/app`, and name
it `Room.tsx`. Pass the location of your endpoint to `LiveblocksProvider`.

```tsx file="/app/Room.tsx"
"use client";

import { ReactNode } from "react";
import {
  LiveblocksProvider,
  RoomProvider,
  ClientSideSuspense,
} from "@liveblocks/react/suspense";

export function Room({ children }: { children: ReactNode }) {
  return (
    <LiveblocksProvider authEndpoint="/api/liveblocks-auth">
      <RoomProvider id="my-room">
        <ClientSideSuspense fallback={<div>Loadingâ€¦</div>}>
          {children}
        </ClientSideSuspense>
      </RoomProvider>
    </LiveblocksProvider>
  );
}
```

## Set up the Monaco editor

Now that weâ€™ve set up Liveblocks, we can start integrating Monaco and Yjs in the
`Editor.tsx` file.

```tsx file="Editor.tsx"
"use client";

import * as Y from "yjs";
import { LiveblocksYjsProvider } from "@liveblocks/yjs";
import { TypedLiveblocksProvider, useRoom } from "@/liveblocks.config";
import { useCallback, useEffect, useState } from "react";
import styles from "./CollaborativeEditor.module.css";
import { Editor } from "@monaco-editor/react";
import { editor } from "monaco-editor";
import { MonacoBinding } from "y-monaco";
import { Awareness } from "y-protocols/awareness";

// Collaborative code editor with undo/redo, live cursors, and live avatars
export function CollaborativeEditor() {
  const room = useRoom();
  const [provider, setProvider] = useState<TypedLiveblocksProvider>();
  const [editorRef, setEditorRef] = useState<editor.IStandaloneCodeEditor>();

  // Set up Liveblocks Yjs provider and attach Monaco editor
  useEffect(() => {
    let yProvider: TypedLiveblocksProvider;
    let yDoc: Y.Doc;
    let binding: MonacoBinding;

    if (editorRef) {
      yDoc = new Y.Doc();
      const yText = yDoc.getText("monaco");
      yProvider = new LiveblocksYjsProvider(room, yDoc);
      setProvider(yProvider);

      // Attach Yjs to Monaco
      binding = new MonacoBinding(
        yText,
        editorRef.getModel() as editor.ITextModel,
        new Set([editorRef]),
        yProvider.awareness as Awareness
      );
    }

    return () => {
      yDoc?.destroy();
      yProvider?.destroy();
      binding?.destroy();
    };
  }, [editorRef, room]);

  const handleOnMount = useCallback((e: editor.IStandaloneCodeEditor) => {
    setEditorRef(e);
  }, []);

  return (
    <div className={styles.container}>
      <div className={styles.editorContainer}>
        <Editor
          onMount={handleOnMount}
          height="100%"
          width="100%"
          theme="vs-light"
          defaultLanguage="typescript"
          defaultValue=""
          options={{
            tabSize: 2,
            padding: { top: 20 },
          }}
        />
      </div>
    </div>
  );
}
```

And here is the `Editor.module.css` file to make sure your multiplayer text
editor looks nice and tidy.

```css file="Editor.module.css" isCollapsed isCollapsable
.container {
  display: flex;
  flex-direction: column;
  position: relative;
  border-radius: 12px;
  background: #fff;
  width: 100%;
  height: 100%;
  color: #111827;
  overflow: hidden;
}

.editorHeader {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.editorContainer {
  position: relative;
  flex-grow: 1;
}
```

## Add your editor to the current page

Next, add the `CollaborativeEditor` into the page file, and place it inside the
`Room` component we created earlier. We should now be seeing a basic
collaborative editor!

```tsx file="/app/page.tsx"
import { Room } from "./Room";
import CollaborativeEditor from "@/components/Editor";

export default function Page() {
  return (
    <Room>
      <CollaborativeEditor />
    </Room>
  );
}
```

## Add live cursors

To add live cursors to the code editor, we can get the `userInfo` for the
current user with [`useSelf`](/docs/api-reference/liveblocks-react#useSelf), and
attach it Yjs awareness. Currently, the only way to style this is to loop
through each Yjs user, and dynamically insert CSS styles into the page, using
`::after` to display usersâ€™ names. Weâ€™ll place this in a new file:

```tsx file="Cursors.tsx"
import { useEffect, useMemo, useState } from "react";
import {
  AwarenessList,
  TypedLiveblocksProvider,
  UserAwareness,
  useSelf,
} from "@/liveblocks.config";

type Props = {
  yProvider: TypedLiveblocksProvider;
};

export function Cursors({ yProvider }: Props) {
  // Get user info from Liveblocks authentication endpoint
  const userInfo = useSelf((me) => me.info);

  const [awarenessUsers, setAwarenessUsers] = useState<AwarenessList>([]);

  useEffect(() => {
    // Add user info to Yjs awareness
    const localUser: UserAwareness["user"] = userInfo;
    yProvider.awareness.setLocalStateField("user", localUser);

    // On changes, update `awarenessUsers`
    function setUsers() {
      setAwarenessUsers([...yProvider.awareness.getStates()] as AwarenessList);
    }
    yProvider.awareness.on("change", setUsers);
    setUsers();

    return () => {
      yProvider.awareness.off("change", setUsers);
    };
  }, [yProvider]);

  // Insert awareness info into cursors with styles
  const styleSheet = useMemo(() => {
    let cursorStyles = "";

    for (const [clientId, client] of awarenessUsers) {
      if (client?.user) {
        cursorStyles += `
          .yRemoteSelection-${clientId},
          .yRemoteSelectionHead-${clientId}  {
            --user-color: ${client.user.color};
          }

          .yRemoteSelectionHead-${clientId}::after {
            content: "${client.user.name}";
          }
        `;
      }
    }

    return { __html: cursorStyles };
  }, [awarenessUsers]);

  return <style dangerouslySetInnerHTML={styleSheet} />;
}
```

This CSS will work in combination with some other styles, which we can place in
a global CSS file:

```css file="globals.css" isCollapsed isCollapsable
/* Cursor selection background */
.yRemoteSelection {
  opacity: 0.5;
  background-color: var(--user-color);
  margin-right: -1px;
}

/* Cursor caret */
.yRemoteSelectionHead {
  position: absolute;
  box-sizing: border-box;
  height: 100%;
  border-left: 2px solid var(--user-color);
}

/* Cursor name */
.yRemoteSelectionHead::after {
  position: absolute;
  top: -1.4em;
  left: -2px;
  padding: 2px 6px;
  background: var(--user-color);
  color: #fff;
  border: 0;
  border-radius: 6px;
  border-bottom-left-radius: 0;
  line-height: normal;
  white-space: nowrap;
  font-size: 14px;
  font-style: normal;
  font-weight: 600;
  pointer-events: none;
  user-select: none;
  z-index: 1000;
}
```

You can then import this into your editor to enable live cursors:

```tsx file="Editor.tsx" highlight="1,9"
import { Cursors } from "@/components/Cursors";
// ...

export function CollaborativeEditor() {
  // ...

  return (
    <div className={styles.container}>
      {provider ? <Cursors yProvider={provider} /> : null}
      <div className={styles.editorContainer}>
        <Editor
          onMount={handleOnMount}
          height="100%"
          width="100%"
          theme="vs-light"
          defaultLanguage="typescript"
          defaultValue=""
          options={{
            tabSize: 2,
            padding: { top: 20 },
          }}
        />
      </div>
    </div>
  );
}
```

## Add a toolbar

From this point onwards, you can build your Monaco app as normal! For example,
should you wish to add a basic undo/redo toolbar to your app:

```tsx file="Toolbar.tsx"
import styles from "./Toolbar.module.css";
import { editor } from "monaco-editor";

type Props = {
  editor: editor.IStandaloneCodeEditor;
};

export function Toolbar({ editor }: Props) {
  return (
    <div className={styles.toolbar}>
      <button
        className={styles.button}
        onClick={() => editor.trigger("", "undo", null)}
      >
        Undo
      </button>
      <button
        className={styles.button}
        onClick={() => editor.trigger("", "redo", null)}
      >
        Redo
      </button>
    </div>
  );
}
```

Add some matching styles:

```css file="Toolbar.module.css" isCollapsed isCollapsable
.toolbar {
  display: flex;
  padding: 1em;
  gap: 6px;
}

.button {
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  border-radius: 6px;
  height: 32px;
  width: 32px;
  background: #fff;
  color: #1f2937;
  border: none;
  box-shadow:
    rgba(0, 0, 0, 0.12) 0 4px 8px 0,
    rgba(0, 0, 0, 0.02) 0 0 0 1px;
}

.button:hover {
  color: #111827;
  box-shadow:
    rgba(0, 0, 0, 0.16) 0 5px 8px 0,
    rgba(0, 0, 0, 0.04) 0 0 0 1px;
}

.button:focus-visible {
  outline-offset: 2px;
}

.button:active {
  box-shadow:
    rgba(0, 0, 0, 0.16) 0 2px 3px 0,
    rgba(0, 0, 0, 0.04) 0 0 0 1px;
}
```

You can then import this into your editor to enable basic Monaco features:

```tsx file="Editor.tsx" highlight="1,10-12"
import { Toolbar } from "@/components/Toolbar";
// ...

export function CollaborativeEditor() {
  // ...

  return (
    <div className={styles.container}>
      {provider ? <Cursors yProvider={provider} /> : null}
      <div className={styles.editorHeader}>
        <div>{editorRef ? <Toolbar editor={editorRef} /> : null}</div>
      </div>
      <div className={styles.editorContainer}>
        <Editor
          onMount={handleOnMount}
          height="100%"
          width="100%"
          theme="vs-light"
          defaultLanguage="typescript"
          defaultValue=""
          options={{
            tabSize: 2,
            padding: { top: 20 },
          }}
        />
      </div>
    </div>
  );
}
```

## Create live avatars with Liveblocks hooks

Along with building out your code editor, you can now use other Liveblocks
features, such as [Presence](/docs/ready-made-features/presence). The
[`useOthers`](/docs/api-reference/liveblocks-react#useOthers) hook allows us to
view information about each user currently online, and we can turn this into a
live avatars component.

```tsx file="Avatars.tsx"
import { useOthers, useSelf } from "@/liveblocks.config";
import styles from "./Avatars.module.css";

export function Avatars() {
  const users = useOthers();
  const currentUser = useSelf();

  return (
    <div className={styles.avatars}>
      {users.map(({ connectionId, info }) => {
        return (
          <Avatar key={connectionId} picture={info.picture} name={info.name} />
        );
      })}

      {currentUser && (
        <div className="relative ml-8 first:ml-0">
          <Avatar
            picture={currentUser.info.picture}
            name={currentUser.info.name}
          />
        </div>
      )}
    </div>
  );
}

export function Avatar({ picture, name }: { picture: string; name: string }) {
  return (
    <div className={styles.avatar} data-tooltip={name}>
      <img
        src={picture}
        className={styles.avatar_picture}
        data-tooltip={name}
      />
    </div>
  );
}
```

And hereâ€™s the styles:

```css file="Avatars.module.css" isCollapsed isCollapsable
.avatars {
  display: flex;
  padding: 0 0.75rem;
}

.avatar {
  display: flex;
  place-content: center;
  position: relative;
  border: 4px solid #fff;
  border-radius: 9999px;
  width: 42px;
  height: 42px;
  background-color: #9ca3af;
  margin-left: -0.75rem;
}

.avatar:before {
  content: attr(data-tooltip);
  position: absolute;
  top: 100%;
  opacity: 0;
  transition: opacity 0.15s ease;
  padding: 5px 10px;
  color: white;
  font-size: 0.75rem;
  border-radius: 8px;
  margin-top: 10px;
  z-index: 1;
  background: black;
  white-space: nowrap;
}

.avatar:hover:before {
  opacity: 1;
}

.avatar_picture {
  width: 100%;
  height: 100%;
  border-radius: 9999px;
}
```

You can then import this to your editor to see it in action:

```tsx file="Editor.tsx" highlight="1,12"
import { Avatars } from "@/components/Avatars";
// ...

export function CollaborativeEditor() {
  // ...

  return (
    <div className={styles.container}>
      {provider ? <Cursors yProvider={provider} /> : null}
      <div className={styles.editorHeader}>
        <div>{editorRef ? <Toolbar editor={editorRef} /> : null}</div>
        <Avatars />
      </div>
      <div className={styles.editorContainer}>
        <Editor
          onMount={handleOnMount}
          height="100%"
          width="100%"
          theme="vs-light"
          defaultLanguage="typescript"
          defaultValue=""
          options={{
            tabSize: 2,
            padding: { top: 20 },
          }}
        />
      </div>
    </div>
  );
}
```

Note that the cursors and avatars match in color and name, as the info for both
is sourced from the Liveblocks authentication endpoint.

## Try it out

You should now see the complete editor, along with live cursors, live avatars,
and some basic features! On GitHub we have a working example of this
[multiplayer code editor](https://github.com/liveblocks/liveblocks/tree/main/examples/nextjs-yjs-monaco).

<Figure>
  <video autoPlay loop muted playsInline>
    <source
      src="/assets/tutorials/code-editors/code-editor-demo.mp4"
      type="video/mp4"
    />
  </video>
</Figure>

---
meta:
  title:
    "How to create a collaborative online whiteboard with React, Redux, and
    Liveblocks"
  description:
    "Build a multiplayer whiteboard app with React, Redux, and Liveblocks"
---

In this 25-minute tutorial, weâ€™ll be building a collaborative whiteboard app
using React, Redux and Liveblocks. As users add and move rectangles in a canvas,
changes will be automatically synced and persisted, allowing for a canvas that
updates in realtime across clients. Users will also be able to see other users
selections, and undo and redo actions.

<Figure>
  <video autoPlay loop muted playsInline>
    <source
      src="/assets/tutorials/whiteboard/tutorial-whiteboard.mp4"
      type="video/mp4"
    />
  </video>
</Figure>

This guide assumes that youâ€™re already familiar with
[React](https://reactjs.org/) and [Redux](https://redux.js.org/). If youâ€™re not
using Redux, we recommend reading one of our dedicated whiteboard tutorials:

- [React tutorial](/docs/tutorials/collaborative-online-whiteboard/react)
- [React + Zustand tutorial](/docs/tutorials/collaborative-online-whiteboard/react-zustand)

A live demo and the source code for this guide are
[in our examples](/examples/collaborative-whiteboard/redux-whiteboard).

## Install Liveblocks into your project [#install-liveblocks]

### Install Liveblocks packages

Create a new app with [`create-react-app`](https://create-react-app.dev/):

```bash
npx create-react-app redux-whiteboard
```

Then run the following command to install the Liveblocks packages and Redux:

```bash
npm install redux react-redux @reduxjs/toolkit @liveblocks/client @liveblocks/redux
```

### Connect to Liveblocks servers [#connect-liveblocks-servers]

In order to use Liveblocks, weâ€™ll need to sign up and get an API key.
[Create an account](/auth/signup), then navigate to
[the dashboard](/dashboard/apikeys) to find your public key. It should start
with `pk_`.

<Banner title="Public vs secret key">

With a secret key, you can control who can access the room. itâ€™s more secure but
you need your own back-end endpoint. For this tutorial, weâ€™ll go with a public
key. For more info, see the [authentication guide](/docs/authentication).

</Banner>

Create a new file `src/store.js` and initialize the Liveblocks client with your
public API key. Then add our
[enhancer](/docs/api-reference/liveblocks-redux#enhancer) to your store
configuration.

```js file="src/store.js"
import { createClient } from "@liveblocks/client";
import { liveblocksEnhancer } from "@liveblocks/redux";
import { configureStore, createSlice } from "@reduxjs/toolkit";

export const client = createClient({
  publicApiKey: "{{PUBLIC_KEY}}",
});

const initialState = {
  /* default state will go there */
};

const slice = createSlice({
  name: "state",
  initialState,
  reducers: {
    /* Reducer logic will go there */
  },
});

export function makeStore() {
  return configureStore({
    reducer: slice.reducer,
    enhancers: (getDefaultEnhancers) =>
      getDefaultEnhancers().concat(liveblocksEnhancer({ client })),
  });
}

const store = makeStore();

export default store;
```

And edit `src/index.js` to add the react-redux provider to your app:

```js highlight="6,7,11,13" file="src/index.js"
import React from "react";
import ReactDOM from "react-dom";
import "./index.css";
import App from "./App";

import { Provider } from "react-redux";
import store from "./store";

ReactDOM.render(
  <React.StrictMode>
    <Provider store={store}>
      <App />
    </Provider>
  </React.StrictMode>,
  document.getElementById("root")
);
```

### Connect to a Liveblocks room [#connect-liveblocks-room]

Liveblocks uses the concept of _rooms_, separate virtual spaces where people can
collaborate. To create a multiplayer experience, multiple users must be
connected to the same room.

Our enhancer is responsible to enter or leave a room when you dispatch
[`enterRoom`](/docs/api-reference/liveblocks-redux#actions-enter) or
[`leaveRoom`](/docs/api-reference/liveblocks-redux#actions-leave).

In our main component, we want to connect to the Liveblocks room when the
component does mount, and leave the room when it unmounts.

```js file="src/App.js"
import { useEffect } from "react";
import "./App.css";
import { useDispatch } from "react-redux";
import { actions } from "@liveblocks/redux";

const roomId = "redux-whiteboard";

export default function App() {
  const dispatch = useDispatch();

  useEffect(() => {
    dispatch(actions.enterRoom(roomId));

    return () => {
      dispatch(actions.leaveRoom());
    };
  }, [dispatch]);

  return <div className="container">Whiteboard app</div>;
}
```

## Create a canvas [#basic-canvas]

Whiteboard shapes will be stored even after all users disconnect, so we will use
Liveblocks storage to persist them.

Add a `shapes` property to your store, and configure the enhancer to sync and
persist them with Liveblocks.

To achieve that, we are going to use the enhancer option
[`storageMapping: { shapes: true }`](/docs/api-reference/liveblocks-redux#middleware-option-storage-mapping).
It means that the part of the state named `shapes` should be automatically
synced with Liveblocks Storage.

```js file="src/store.js" highlight="10,28"
import { createClient } from "@liveblocks/client";
import { liveblocksEnhancer } from "@liveblocks/redux";
import { configureStore, createSlice } from "@reduxjs/toolkit";

export const client = createClient({
  publicApiKey: "{{PUBLIC_KEY}}",
});

const initialState = {
  shapes: {},
};

const slice = createSlice({
  name: "state",
  initialState,
  reducers: {
    /* Reducer logic will go there */
  },
});

export function makeStore() {
  return configureStore({
    reducer: slice.reducer,
    enhancers: (getDefaultEnhancers) =>
      getDefaultEnhancers().concat(
        liveblocksEnhancer({
          client,
          storageMapping: { scientist: true },
        })
      ),
  });
}

const store = makeStore();

export default store;
```

Afterwards, we draw the shapes in our canvas. To keep it simple for the
tutorial, we are going to only support rectangle.

```jsx file="src/App.js" highlight="3,9-10,25-35,38-48"
import { useEffect } from "react";
import "./App.css";
import { useDispatch, useSelector } from "react-redux";
import { actions } from "@liveblocks/redux";

const roomId = "redux-whiteboard";

export default function App() {
  const shapes = useSelector((state) => state.shapes);
  const isLoading = useSelector((state) => state.liveblocks.isStorageLoading);
  const dispatch = useDispatch();

  useEffect(() => {
    dispatch(actions.enterRoom(roomId));

    return () => {
      dispatch(actions.leaveRoom());
    };
  }, [dispatch]);

  if (isLoading) {
    return <div className="loading">Loading</div>;
  }

  return (
    <div className="canvas">
      {Object.entries(shapes).map(([shapeId, shape]) => {
        return <Rectangle key={shapeId} shape={shape} />;
      })}
    </div>
  );
}

const Rectangle = ({ shape }) => {
  return (
    <div
      className="rectangle"
      style={{
        transform: `translate(${shape.x}px, ${shape.y}px)`,
        backgroundColor: shape.fill ? shape.fill : "#CCC",
      }}
    ></div>
  );
};
```

_Place the following within `src/App.css`, and then you will be able to insert
rectangular shapes into the whiteboard._

```css file="src/App.css" isCollapsed isCollapsable
body {
  background-color: #eeeeee;
}

.loading {
  display: flex;
  align-items: center;
  justify-content: center;
  height: 100vh;
  width: 100vw;
}

.canvas {
  background-color: #eeeeee;
  touch-action: none;
  width: 100vw;
  height: 100vh;
}

.rectangle {
  position: absolute;
  /* transition: all 0.1s ease; */
  stroke-width: 1;
  border-style: solid;
  border-width: 2px;
  height: 100px;
  width: 100px;
}

.toolbar {
  position: fixed;
  top: 12px;
  left: 50%;
  transform: translateX(-50%);
  padding: 4px;
  border-radius: 8px;
  box-shadow:
    0px 2px 4px rgba(0, 0, 0, 0.1),
    0px 0px 0px 1px rgba(0, 0, 0, 0.05);
  display: flex;
  background-color: #ffffff;
  user-select: none;
}

.toolbar button {
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 4px 8px;
  border-radius: 4px;
  background-color: #f8f8f8;
  color: #181818;
  border: none;
  box-shadow:
    0px 2px 4px rgba(0, 0, 0, 0.1),
    0px 0px 0px 1px rgba(0, 0, 0, 0.05);
  margin: 4px;
  font-weight: 500;
  font-size: 12px;
}

.toolbar button:hover,
.toolbar button:focus {
  background-color: #ffffff;
}

.toolbar button:active {
  background-color: #eeeeee;
}
```

## Insert rectangles

Currently our whiteboard is empty, and thereâ€™s no way to add rectangles. Letâ€™s
create a button that adds a randomly placed rectangle to the board.

<Figure>
  <video autoPlay loop muted playsInline>
    <source
      src="/assets/tutorials/whiteboard/tutorial-whiteboard-1.mp4"
      type="video/mp4"
    />
  </video>
</Figure>

Add a new action to your store that randomly insert a rectangle on the board.

```js file="src/store.js" highlight="9-17,27-35,39"
import { createClient } from "@liveblocks/client";
import { liveblocksEnhancer } from "@liveblocks/redux";
import { configureStore, createSlice } from "@reduxjs/toolkit";

export const client = createClient({
  publicApiKey: "{{PUBLIC_KEY}}",
});

const COLORS = ["#DC2626", "#D97706", "#059669", "#7C3AED", "#DB2777"];

function getRandomInt(max) {
  return Math.floor(Math.random() * max);
}

function getRandomColor() {
  return COLORS[getRandomInt(COLORS.length)];
}

const initialState = {
  shapes: {},
};

const slice = createSlice({
  name: "state",
  initialState,
  reducers: {
    insertRectangle: (state) => {
      const shapeId = Date.now().toString();
      const shape = {
        x: getRandomInt(300),
        y: getRandomInt(300),
        fill: getRandomColor(),
      };
      state.shapes[shapeId] = shape;
    },
  },
});

export const { insertRectangle } = slice.actions;

export function makeStore() {
  return configureStore({
    reducer: slice.reducer,
    enhancers: (getDefaultEnhancers) =>
      getDefaultEnhancers().concat(
        liveblocksEnhancer({
          client,
          storageMapping: { shapes: true },
        })
      ),
  });
}

const store = makeStore();

export default store;
```

Then add a button to dispatch this action from the board.

```jsx file="src/App.js" highlight="6,18,24-27"
import { useEffect } from "react";
import "./App.css";
import { useDispatch, useSelector } from "react-redux";
import { actions } from "@liveblocks/redux";

import { insertRectangle } from "./store";

const roomId = "redux-whiteboard";

export default function App() {
  const shapes = useSelector((state) => state.shapes);
  const isLoading = useSelector((state) => state.liveblocks.isStorageLoading);
  const dispatch = useDispatch();

  /* ... */

  return (
    <>
      <div className="canvas">
        {Object.entries(shapes).map(([shapeId, shape]) => {
          return <Rectangle key={shapeId} shape={shape} />;
        })}
      </div>
      <div className="toolbar">
        <button onClick={() => dispatch(insertRectangle())}>Rectangle</button>
      </div>
    </>
  );
}

/* Rectangle */
```

## Add selection [#selection]

We can use Liveblocks to display which shape each user is currently selecting,
in this case by adding a border to the rectangles. Weâ€™ll use a blue border to
represent the local user, and green borders for remote users.

<Figure>
  <video autoPlay loop muted playsInline>
    <source
      src="/assets/tutorials/whiteboard/tutorial-whiteboard-2.mp4"
      type="video/mp4"
    />
  </video>
</Figure>

Any online user could select a shape, and we need to keep track of this, so itâ€™s
best if each user holds their own `selectedShape` property.

Luckily, Liveblocks uses the concept of presence to handle these temporary
states. A userâ€™s presence can be used to represent the position of a cursor on
screen, or in this case the selected shape in a design tool.

We want to add some data to our Redux store, `selectedShape` will contain the
selected shape id. `selectedShape` will be set when the user select or insert a
rectangle.

The middleware option
[`presenceMapping: { selectedShape: true }`](/docs/api-reference/liveblocks-redux#middleware-option-presence-mapping)
means that we want to automatically sync the part of the state named
`selectedShape` to Liveblocks Presence.

```js file="src/store.js" highlight="5,15-17,21,31"
/* ... */

const initialState = {
  shapes: {},
  selectedShape: null,
};

const slice = createSlice({
  name: "state",
  initialState,
  reducers: {
    insertRectangle: (state) => {
      /* ... */
    },
    onShapePointerDown: (state, action) => {
      state.selectedShape = action.payload;
    },
  },
});

export const { insertRectangle, onShapePointerDown } = slice.actions;

export function makeStore() {
  return configureStore({
    reducer: slice.reducer,
    enhancers: (getDefaultEnhancers) =>
      getDefaultEnhancers().concat(
        liveblocksEnhancer({
          client,
          storageMapping: { shapes: true },
          presenceMapping: { selectedShape: true },
        })
      ),
  });
}

const store = makeStore();

export default store;
```

Update your `App` and `Rectangle` components to show if a shape is selected by
the current user or someone else in the room.

```jsx file="src/App.js" highlight="6,13-14,23-31,36,38,50-51,59,61-64"
import { useEffect } from "react";
import "./App.css";
import { useDispatch, useSelector } from "react-redux";
import { actions } from "@liveblocks/redux";

import { insertRectangle, onShapePointerDown } from "./store";

const roomId = "redux-whiteboard";

export default function App() {
  const shapes = useSelector((state) => state.shapes);
  const isLoading = useSelector((state) => state.liveblocks.isStorageLoading);
  const others = useSelector((state) => state.liveblocks.others);
  const selectedShape = useSelector((state) => state.selectedShape);
  const dispatch = useDispatch();

  /* ... */

  return (
    <>
      <div className="canvas">
        {Object.entries(shapes).map(([shapeId, shape]) => {
          let selectionColor = "transparent";

          if (selectedShape === shapeId) {
            selectionColor = "blue";
          } else if (
            others.some((user) => user.presence?.selectedShape === shapeId)
          ) {
            selectionColor = "green";
          }

          return (
            <Rectangle
              key={shapeId}
              id={shapeId}
              shape={shape}
              selectionColor={selectionColor}
            />
          );
        })}
      </div>
      <div className="toolbar">
        <button onClick={() => dispatch(insertRectangle())}>Rectangle</button>
      </div>
    </>
  );
}

const Rectangle = ({ shape, selectionColor, id }) => {
  const dispatch = useDispatch();

  return (
    <div
      className="rectangle"
      style={{
        transform: `translate(${shape.x}px, ${shape.y}px)`,
        backgroundColor: shape.fill ? shape.fill : "#CCC",
        borderColor: selectionColor,
      }}
      onPointerDown={(e) => {
        e.stopPropagation();
        dispatch(onShapePointerDown(id));
      }}
    ></div>
  );
};
```

## Delete rectangles

Now that users can select rectangles, we can add a button that allow deleting
rectangles too.

<Figure>
  <video autoPlay loop muted playsInline>
    <source
      src="/assets/tutorials/whiteboard/tutorial-whiteboard-3.mp4"
      type="video/mp4"
    />
  </video>
</Figure>

Create a `deleteShape` action to remove the selected shape from `shapes`, and
then reset the userâ€™s selection:

```js file="src/store.js" highlight="20,25-30,34"
/* ... */

const initialState = {
  shapes: {},
  selectedShape: null,
};

const slice = createSlice({
  name: "state",
  initialState,
  reducers: {
    insertRectangle: (state) => {
      const shapeId = Date.now().toString();
      const shape = {
        x: getRandomInt(300),
        y: getRandomInt(300),
        fill: getRandomColor(),
      };
      state.shapes[shapeId] = shape;
      state.selectedShape = shapeId;
    },
    onShapePointerDown: (state, action) => {
      /* ... */
    },
    deleteShape: (state) => {
      if (state.selectedShape) {
        delete state.shapes[state.selectedShape];
        state.selectedShape = null;
      }
    },
  },
});

export const { insertRectangle, onShapePointerDown, deleteShape } =
  slice.actions;

export function makeStore() {
  return configureStore({
    reducer: slice.reducer,
    enhancers: (getDefaultEnhancers) =>
      getDefaultEnhancers().concat(
        liveblocksEnhancer({
          client,
          presenceMapping: { selectedShape: true },
          storageMapping: { shapes: true },
        })
      ),
  });
}

const store = makeStore();

export default store;
```

```jsx file="src/App.js" highlight="6,25-30"
import { useEffect } from "react";
import "./App.css";
import { useDispatch, useSelector } from "react-redux";
import { actions } from "@liveblocks/redux";

import { insertRectangle, onShapePointerDown, deleteShape } from "./store";

const roomId = "redux-whiteboard";

export default function App() {
  const shapes = useSelector((state) => state.shapes);
  const isLoading = useSelector((state) => state.liveblocks.isStorageLoading);
  const selectedShape = useSelector((state) => state.selectedShape);
  const others = useSelector((state) => state.liveblocks.others);

  const dispatch = useDispatch();

  /* ... */

  return (
    <>
      <div className="canvas">{/* ... */}</div>
      <div className="toolbar">
        <button onClick={() => dispatch(insertRectangle())}>Rectangle</button>
        <button
          onClick={() => dispatch(deleteShape())}
          disabled={selectedShape == null}
        >
          Delete
        </button>
      </div>
    </>
  );
}

/* Rectangle */
```

## Move rectangles

Letâ€™s move some rectangles!

<Figure>
  <video autoPlay loop muted playsInline>
    <source
      src="/assets/tutorials/whiteboard/tutorial-whiteboard-4.mp4"
      type="video/mp4"
    />
  </video>
</Figure>

To allow users to move rectangles, weâ€™ll update the `x` and `y` properties of
the selected shape when a user drags it:

```js file="src/store.js" highlight="6,18,23-31,39-40"
/* ... */

const initialState = {
  shapes: {},
  selectedShape: null,
  isDragging: false,
};

const slice = createSlice({
  name: "state",
  initialState,
  reducers: {
    insertRectangle: (state) => {
      /* ... */
    },
    onShapePointerDown: (state, action) => {
      state.selectedShape = action.payload;
      state.isDragging = true;
    },
    deleteShape: (state) => {
      /* ... */
    },
    onCanvasPointerUp: (state) => {
      state.isDragging = false;
    },
    onCanvasPointerMove: (state, action) => {
      if (state.isDragging && state.selectedShape) {
        state.shapes[state.selectedShape].x = action.payload.x - 50;
        state.shapes[state.selectedShape].y = action.payload.y - 50;
      }
    },
  },
});

export const {
  insertRectangle,
  onShapePointerDown,
  deleteShape,
  onCanvasPointerUp,
  onCanvasPointerMove,
} = slice.actions;

export function makeStore() {
  return configureStore({
    reducer: slice.reducer,
    enhancers: (getDefaultEnhancers) =>
      getDefaultEnhancers().concat(
        liveblocksEnhancer({
          client,
          presenceMapping: { selectedShape: true },
          storageMapping: { shapes: true },
        })
      ),
  });
}

const store = makeStore();

export default store;
```

```jsx file="src/App.js" highlight="10-11,30-36"
import { useEffect } from "react";
import "./App.css";
import { useDispatch, useSelector } from "react-redux";
import { actions } from "@liveblocks/redux";

import {
  insertRectangle,
  onShapePointerDown,
  deleteShape,
  onCanvasPointerUp,
  onCanvasPointerMove,
} from "./store";

const roomId = "redux-whiteboard";

export default function App() {
  const shapes = useSelector((state) => state.shapes);
  const isLoading = useSelector((state) => state.liveblocks.isStorageLoading);
  const selectedShape = useSelector((state) => state.selectedShape);
  const others = useSelector((state) => state.liveblocks.others);

  const dispatch = useDispatch();

  /* ... */

  return (
    <>
      <div
        className="canvas"
        onPointerMove={(e) => {
          e.preventDefault();
          dispatch(onCanvasPointerMove({ x: e.clientX, y: e.clientY }));
        }}
        onPointerUp={() => {
          dispatch(onCanvasPointerUp());
        }}
      >
        {/* ... */}
      </div>
      <div className="toolbar">{/* ... */}</div>
    </>
  );
}

/* ... */
```

## Multiplayer undo/redo [#undo-redo]

With Liveblocks, you can enable multiplayer undo/redo in just a few lines of
code.

<Figure>
  <video autoPlay loop muted playsInline>
    <source
      src="/assets/tutorials/whiteboard/tutorial-whiteboard-5.mp4"
      type="video/mp4"
    />
  </video>
</Figure>

Add two buttons to the toolbar and bind them to
[`room.history.undo`](/docs/api-reference/liveblocks-client#Room.history.undo)
and
[`room.history.redo`](/docs/api-reference/liveblocks-client#Room.history.redo).
These functions only impact modifications made to the roomâ€™s storage.

```jsx file="src/App.js" highlight="12,48-53"
import { useEffect } from "react";
import "./App.css";
import { useDispatch, useSelector } from "react-redux";
import { actions } from "@liveblocks/redux";

import {
  insertRectangle,
  onShapePointerDown,
  deleteShape,
  onCanvasPointerUp,
  onCanvasPointerMove,
  client,
} from "./store";

const roomId = "redux-whiteboard";

export default function App() {
  const shapes = useSelector((state) => state.shapes);
  const isLoading = useSelector((state) => state.liveblocks.isStorageLoading);
  const selectedShape = useSelector((state) => state.selectedShape);
  const others = useSelector((state) => state.liveblocks.others);

  const dispatch = useDispatch();

  /* ... */

  return (
    <>
      <div
        className="canvas"
        onPointerMove={(e) => {
          /* ... */
        }}
        onPointerUp={() => {
          /* ... */
        }}
      >
        {/* ... */}
      </div>
      <div className="toolbar">
        <button onClick={() => dispatch(insertRectangle())}>Rectangle</button>
        <button
          onClick={() => dispatch(deleteShape())}
          disabled={selectedShape == null}
        >
          Delete
        </button>
        <button onClick={() => client.getRoom(roomId).history.undo()}>
          Undo
        </button>
        <button onClick={() => client.getRoom(roomId).history.redo()}>
          Redo
        </button>
      </div>
    </>
  );
}

/* Rectangle */
```

### Pause and resume history [#pause-resume-history]

When a user moves a rectangle, a large number of actions are sent to Liveblocks
and live synced, enabling other users to see movements in realtime.

The problem with this is that the undo button returns the rectangle to the last
intermediary position, and not the position where the rectangle started its
movement. We can fix this by pausing storage history until the move has
completed.

<Figure>
  <video autoPlay loop muted playsInline>
    <source
      src="/assets/tutorials/whiteboard/tutorial-whiteboard-6.mp4"
      type="video/mp4"
    />
  </video>
</Figure>

Weâ€™ll use
[`history.pause`](/docs/api-reference/liveblocks-client#Room.history.pause) to
disable adding any positions to the history stack while the cursors moves, and
then call
[`history.resume`](/docs/api-reference/liveblocks-client#Room.history.resume)
afterwards.

```js file="src/App.js" highlight="36,59"
import { useEffect } from "react";
import "./App.css";
import { useDispatch, useSelector } from "react-redux";
import { actions } from "@liveblocks/redux";

import {
  insertRectangle,
  onShapePointerDown,
  deleteShape,
  onCanvasPointerUp,
  onCanvasPointerMove,
  client,
} from "./store";

const roomId = "redux-whiteboard";

export default function App() {
  const shapes = useSelector((state) => state.shapes);
  const isLoading = useSelector((state) => state.liveblocks.isStorageLoading);
  const selectedShape = useSelector((state) => state.selectedShape);
  const others = useSelector((state) => state.liveblocks.others);

  const dispatch = useDispatch();

  /* ... */

  return (
    <>
      <div
        className="canvas"
        onPointerMove={(e) => {
          /* ... */
        }}
        onPointerUp={() => {
          dispatch(onCanvasPointerUp());
          client.getRoom(roomId).history.resume();
        }}
      >
        {/* ... */}
      </div>
      <div className="toolbar">{/* ... */}</div>
    </>
  );
}

const Rectangle = ({ shape, selectionColor, id }) => {
  const dispatch = useDispatch();

  return (
    <div
      className="rectangle"
      style={{
        transform: `translate(${shape.x}px, ${shape.y}px)`,
        backgroundColor: shape.fill ? shape.fill : "#CCC",
        borderColor: selectionColor,
      }}
      onPointerDown={(e) => {
        e.stopPropagation();
        client.getRoom(roomId).history.pause();
        dispatch(onShapePointerDown(id));
      }}
    ></div>
  );
};
```

VoilÃ ! We have a working collaborative whiteboard app, with persistent data
storage.

## Summary

In this tutorial, weâ€™ve learnt about the concept of rooms, presence, and others.
We've also learnt how to put all these into practice, and how to persist state
using storage too.

You can see some stats about the room you created in your
[dashboard](https://liveblocks.io/dashboard/rooms).

<Figure>
  <Image
    src="/assets/tutorials/whiteboard/tutorial-whiteboard-dashboard.png"
    alt="Liveblocks dashboard"
    width={1336}
    height={822}
    quality={80}
  />
</Figure>

## Next steps

- [API reference](/docs/api-reference/liveblocks-redux)
- [Authentication](/docs/authentication)

---
meta:
  title:
    "How to create a collaborative online whiteboard with React, Zustand, and
    Liveblocks"
  description:
    "Build a multiplayer whiteboard app with React, Zustand, and Liveblocks"
---

In this 25-minute tutorial, weâ€™ll be building a collaborative whiteboard app
using React, Zustand and Liveblocks. As users add and move rectangles in a
canvas, changes will be automatically synced and persisted, allowing for a
canvas that updates in realtime across clients. Users will also be able to see
other users selections, and undo and redo actions.

<Figure>
  <video autoPlay loop muted playsInline>
    <source
      src="/assets/tutorials/whiteboard/tutorial-whiteboard.mp4"
      type="video/mp4"
    />
  </video>
</Figure>

This guide assumes that youâ€™re already familiar with
[React](https://reactjs.org/) and [Zustand](https://github.com/pmndrs/zustand).
If youâ€™re not using Zustand, we recommend reading one of our dedicated
whiteboard tutorials:

- [React tutorial](/docs/tutorials/collaborative-online-whiteboard/react)
- [React + Redux tutorial](/docs/tutorials/collaborative-online-whiteboard/react-redux)

A live demo and the source code for this guide are
[in our examples](/examples/collaborative-whiteboard/zustand-whiteboard).

## Install Liveblocks into your project [#install-liveblocks]

### Install Liveblocks packages

Create a new app with [`create-react-app`](https://create-react-app.dev/):

```bash
npx create-react-app zustand-whiteboard --template typescript
```

To start a plain JavaScript project, you can omit the `--template typescript`
flag.

Then install the Liveblocks packages and Zustand:

```bash
npm install zustand @liveblocks/client @liveblocks/zustand
```

### Connect to Liveblocks servers [#connect-liveblocks-servers]

In order to use Liveblocks, weâ€™ll need to sign up and get an API key.
[Create an account](/auth/signup), then navigate to
[the dashboard](/dashboard/apikeys) to find your public key. It should start
with `pk_`.

<Banner title="Public vs secret key">

With a secret key, you can control who can access the room. itâ€™s more secure but
you need your own back-end endpoint. For this tutorial, weâ€™ll go with a public
key. For more info, see the [authentication guide](/docs/authentication).

</Banner>

Create a new file `src/store.ts` and initialize the Liveblocks client with your
public API key. Then add our
[`liveblocks` middleware](/docs/api-reference/liveblocks-zustand#middleware) to
your store configuration.

```ts file="src/store.ts"
import create from "zustand";
import { createClient } from "@liveblocks/client";
import { liveblocks } from "@liveblocks/zustand";
import type { WithLiveblocks } from "@liveblocks/zustand";

type State = {
  // Your Zustand state type will be defined here
};

const client = createClient({
  publicApiKey: "{{PUBLIC_KEY}}",
});

const useStore = create<WithLiveblocks<State>>()(
  liveblocks(
    (set) => ({
      // Your state and actions will go here
    }),
    { client }
  )
);

export default useStore;
```

### Connect to a Liveblocks room [#connect-liveblocks-room]

Liveblocks uses the concept of _rooms_, separate virtual spaces where people can
collaborate. To create a multiplayer experience, multiple users must be
connected to the same room.

Our middleware injected the object `liveblocks` to the store. Inside that
object, the first methods that we are going to use are
[`enterRoom`](/docs/api-reference/liveblocks-zustand#liveblocks-state-enter-room)
and
[`leaveRoom`](/docs/api-reference/liveblocks-zustand#liveblocks-state-leave-room).

In our main component, we want to connect to the Liveblocks room when the
component does mount, and leave the room when it unmounts.

```tsx file="src/App.tsx"
import { useEffect } from "react";
import useStore from "./store";

import "./App.css";

export default function App() {
  const enterRoom = useStore((state) => state.liveblocks.enterRoom);
  const leaveRoom = useStore((state) => state.liveblocks.leaveRoom);

  useEffect(() => {
    enterRoom("zustand-whiteboard");
    return () => {
      leaveRoom("zustand-whiteboard");
    };
  }, [enterRoom, leaveRoom]);

  return <div className="container">Whiteboard app</div>;
}
```

## Create a canvas [#basic-canvas]

Whiteboard shapes will be stored even after all users disconnect, so we will use
Liveblocks storage to persist them.

Add a `shapes` property to your store, and tell the middleware to sync and
persist them with Liveblocks.

To achieve that, we are going to use the middleware option
[`storageMapping: { shapes: true }`](/docs/api-reference/liveblocks-zustand#middleware-option-storage-mapping).
It means that the part of the state named `shapes` should be automatically
synced with Liveblocks Storage.

```ts file="src/store.ts" highlight="6-10,13,23,27"
import create from "zustand";
import { createClient } from "@liveblocks/client";
import { liveblocks } from "@liveblocks/zustand";
import type { WithLiveblocks } from "@liveblocks/zustand";

export type Shape = {
  x: number;
  y: number;
  fill: string;
};

type State = {
  shapes: Record<string, Shape>;
};

const client = createClient({
  publicApiKey: "{{PUBLIC_KEY}}",
});

const useStore = create<WithLiveblocks<State>>()(
  liveblocks(
    (set) => ({
      shapes: {},
    }),
    {
      client,
      storageMapping: { shapes: true },
    }
  )
);

export default useStore;
```

Afterwards, we draw the shapes in our canvas. To keep it simple for the
tutorial, we are going to only support rectangle.

```tsx file="src/App.tsx" highlight="8,11,20-30,33-43"
import { useEffect } from "react";
import useStore from "./store";
import type { Shape } from "./store";

import "./App.css";

export default function App() {
  const shapes = useStore((state) => state.shapes);
  const enterRoom = useStore((state) => state.liveblocks.enterRoom);
  const leaveRoom = useStore((state) => state.liveblocks.leaveRoom);
  const isLoading = useStore((state) => state.liveblocks.isStorageLoading);

  useEffect(() => {
    enterRoom("zustand-whiteboard");
    return () => {
      leaveRoom("zustand-whiteboard");
    };
  }, [enterRoom, leaveRoom]);

  if (isLoading) {
    return <div className="loading">Loading...</div>;
  }

  return (
    <div className="canvas">
      {Object.entries(shapes).map(([shapeId, shape]) => {
        return <Rectangle key={shapeId} shape={shape} />;
      })}
    </div>
  );
}

const Rectangle = ({ shape }: { shape: Shape }) => {
  return (
    <div
      className="rectangle"
      style={{
        transform: `translate(${shape.x}px, ${shape.y}px)`,
        backgroundColor: shape.fill ? shape.fill : "#CCC",
      }}
    ></div>
  );
};
```

_Place the following within `src/App.css`, and then you will be able to insert
rectangular shapes into the whiteboard._

```css file="src/App.css" isCollapsed isCollapsable
body {
  background-color: #eeeeee;
}

.loading {
  display: flex;
  align-items: center;
  justify-content: center;
  height: 100vh;
  width: 100vw;
}

.canvas {
  background-color: #eeeeee;
  touch-action: none;
  width: 100vw;
  height: 100vh;
}

.rectangle {
  position: absolute;
  /* transition: all 0.1s ease; */
  stroke-width: 1;
  border-style: solid;
  border-width: 2px;
  height: 100px;
  width: 100px;
}

.toolbar {
  position: fixed;
  top: 12px;
  left: 50%;
  transform: translateX(-50%);
  padding: 4px;
  border-radius: 8px;
  box-shadow:
    0px 2px 4px rgba(0, 0, 0, 0.1),
    0px 0px 0px 1px rgba(0, 0, 0, 0.05);
  display: flex;
  background-color: #ffffff;
  user-select: none;
}

.toolbar button {
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 4px 8px;
  border-radius: 4px;
  background-color: #f8f8f8;
  color: #181818;
  border: none;
  box-shadow:
    0px 2px 4px rgba(0, 0, 0, 0.1),
    0px 0px 0px 1px rgba(0, 0, 0, 0.05);
  margin: 4px;
  font-weight: 500;
  font-size: 12px;
}

.toolbar button:hover,
.toolbar button:focus {
  background-color: #ffffff;
}

.toolbar button:active {
  background-color: #eeeeee;
}
```

## Insert rectangles

Currently our whiteboard is empty, and thereâ€™s no way to add rectangles. Letâ€™s
create a button that adds a randomly placed rectangle to the board.

<Figure>
  <video autoPlay loop muted playsInline>
    <source
      src="/assets/tutorials/whiteboard/tutorial-whiteboard-1.mp4"
      type="video/mp4"
    />
  </video>
</Figure>

Add a new function to your store that randomly insert a rectangle on the board.

```ts file="src/store.ts" highlight="14,21-29,33,35-48"
import create from "zustand";
import { createClient } from "@liveblocks/client";
import { liveblocks } from "@liveblocks/zustand";
import type { WithLiveblocks } from "@liveblocks/zustand";

export type Shape = {
  x: number;
  y: number;
  fill: string;
};

type State = {
  shapes: Record<string, Shape>;
  insertRectangle: () => void;
};

const client = createClient({
  publicApiKey: "{{PUBLIC_KEY}}",
});

const COLORS = ["#DC2626", "#D97706", "#059669", "#7C3AED", "#DB2777"];

function getRandomInt(max: number) {
  return Math.floor(Math.random() * max);
}

function getRandomColor() {
  return COLORS[getRandomInt(COLORS.length)];
}

const useStore = create<WithLiveblocks<State>>()(
  liveblocks(
    (set, get) => ({
      shapes: {},
      insertRectangle: () => {
        const { shapes } = get();

        const shapeId = Date.now().toString();
        const shape = {
          x: getRandomInt(300),
          y: getRandomInt(300),
          fill: getRandomColor(),
        };

        set({
          shapes: { ...shapes, [shapeId]: shape },
        });
      },
    }),
    {
      client,
      storageMapping: { shapes: true },
    }
  )
);

export default useStore;
```

Then add a button to call this function from the board.

```tsx file="src/App.tsx" highlight="8,13,19-22"
import { useEffect } from "react";
import useStore from "./store";

import "./App.css";

export default function App() {
  const shapes = useStore((state) => state.shapes);
  const insertRectangle = useStore((state) => state.insertRectangle);

  /* ... */

  return (
    <>
      <div className="canvas">
        {Object.entries(shapes).map(([shapeId, shape]) => {
          return <Rectangle key={shapeId} shape={shape} />;
        })}
      </div>
      <div className="toolbar">
        <button onClick={insertRectangle}>Rectangle</button>
      </div>
    </>
  );
}

/* Rectangle */
```

## Add selection [#selection]

We can use Liveblocks to display which shape each user is currently selecting,
in this case by adding a border to the rectangles. Weâ€™ll use a blue border to
represent the local user, and green borders for remote users.

<Figure>
  <video autoPlay loop muted playsInline>
    <source
      src="/assets/tutorials/whiteboard/tutorial-whiteboard-2.mp4"
      type="video/mp4"
    />
  </video>
</Figure>

Any online user could select a shape, and we need to keep track of this, so itâ€™s
best if each user holds their own `selectedShape` property.

Luckily, Liveblocks uses the concept of presence to handle these temporary
states. A userâ€™s presence can be used to represent the position of a cursor on
screen, or in this case the selected shape in a design tool.

We want to add some data to our Zustand store, `selectedShape` will contain the
selected shape id. `selectedShape` will be set when the user select or insert a
rectangle.

The middleware option
[`presenceMapping: { selectedShape: true }`](/docs/api-reference/liveblocks-zustand#middleware-option-presence-mapping)
means that we want to automatically sync the part of the state named
`selectedShape` to Liveblocks Presence.

```ts file="src/store.ts" highlight="5,7,16,29,32-34,39"
/* ... */

type State = {
  shapes: Record<string, Shape>;
  selectedShape: string | null;
  insertRectangle: () => void;
  onShapePointerDown: (shapeId: string | null) => void;
};

/* ... */

const useStore = create<WithLiveblocks<State>>()(
  liveblocks(
    (set, get) => ({
      shapes: {},
      selectedShape: null,
      insertRectangle: () => {
        const { shapes } = get();

        const shapeId = Date.now().toString();
        const shape = {
          x: getRandomInt(300),
          y: getRandomInt(300),
          fill: getRandomColor(),
        };

        set({
          shapes: { ...shapes, [shapeId]: shape },
          selectedShape: shapeId,
        });
      },
      onShapePointerDown: (shapeId) => {
        set({ selectedShape: shapeId });
      },
    }),
    {
      client,
      storageMapping: { shapes: true },
      presenceMapping: { selectedShape: true },
    }
  )
);

export default useStore;
```

Update your `App` and `Rectangle` components to show if a shape is selected by
the current user or someone else in the room.

```tsx file="src/App.tsx" highlight="9,10,18-26,31,33,45-51,59,61-64"
import { useEffect } from "react";
import useStore from "./store";

import "./App.css";

export default function App() {
  const shapes = useStore((state) => state.shapes);
  const insertRectangle = useStore((state) => state.insertRectangle);
  const others = useStore((state) => state.liveblocks.others);
  const selectedShape = useStore((state) => state.selectedShape);

  /* ... */

  return (
    <>
      <div className="canvas">
        {Object.entries(shapes).map(([shapeId, shape]) => {
          let selectionColor = "transparent";

          if (selectedShape === shapeId) {
            selectionColor = "blue";
          } else if (
            others.some((user) => user.presence?.selectedShape === shapeId)
          ) {
            selectionColor = "green";
          }

          return (
            <Rectangle
              key={shapeId}
              id={shapeId}
              shape={shape}
              selectionColor={selectionColor}
            />
          );
        })}
      </div>
      <div className="toolbar">
        <button onClick={insertRectangle}>Rectangle</button>
      </div>
    </>
  );
}

const Rectangle = (props: {
  id: string;
  shape: Shape;
  selectionColor: string;
}) => {
  const { id, shape, selectionColor } = props;
  const onShapePointerDown = useStore((state) => state.onShapePointerDown);

  return (
    <div
      className="rectangle"
      style={{
        transform: `translate(${shape.x}px, ${shape.y}px)`,
        backgroundColor: shape.fill ? shape.fill : "#CCC",
        borderColor: selectionColor,
      }}
      onPointerDown={(e) => {
        e.stopPropagation();
        onShapePointerDown(id);
      }}
    ></div>
  );
};
```

## Delete rectangles

Now that users can select rectangles, we can add a button that allow deleting
rectangles too.

<Figure>
  <video autoPlay loop muted playsInline>
    <source
      src="/assets/tutorials/whiteboard/tutorial-whiteboard-3.mp4"
      type="video/mp4"
    />
  </video>
</Figure>

Add a `deleteShape` to remove the selected shape from `shapes`, and then reset
the userâ€™s selection:

```ts file="src/store.ts" highlight="8,24-35"
/* ... */

type State = {
  shapes: Record<string, Shape>;
  selectedShape: string | null;
  insertRectangle: () => void;
  onShapePointerDown: (shapeId: string | null) => void;
  deleteShape: () => void;
};

/* ... */

const useStore = create<WithLiveblocks<State>>()(
  liveblocks(
    (set, get) => ({
      shapes: {},
      selectedShape: null,
      insertRectangle: () => {
        /* ... */
      },
      onShapePointerDown: (shapeId) => {
        /* ... */
      },
      deleteShape: () => {
        const { shapes, selectedShape } = get();
        if (!selectedShape) {
          /* Nothing todo */
          return;
        }
        const { [selectedShape]: shapeToDelete, ...newShapes } = shapes;
        set({
          shapes: newShapes,
          selectedShape: null,
        });
      },
    }),
    {
      client,
      storageMapping: { shapes: true },
      presenceMapping: { selectedShape: true },
    }
  )
);

export default useStore;
```

```tsx file="src/App.ts" highlight="11,20-22"
import { useEffect } from "react";
import useStore from "./store";

import "./App.css";

export default function App() {
  const shapes = useStore((state) => state.shapes);
  const insertRectangle = useStore((state) => state.insertRectangle);
  const others = useStore((state) => state.liveblocks.others);
  const selectedShape = useStore((state) => state.selectedShape);
  const deleteShape = useStore((state) => state.deleteShape);

  /* ... */

  return (
    <>
      <div className="canvas">{/* ... */}</div>
      <div className="toolbar">
        <button onClick={insertRectangle}>Rectangle</button>
        <button onClick={deleteShape} disabled={selectedShape === null}>
          Delete
        </button>
      </div>
    </>
  );
}

/* Rectangle */
```

## Move rectangles

Letâ€™s move some rectangles!

<Figure>
  <video autoPlay loop muted playsInline>
    <source
      src="/assets/tutorials/whiteboard/tutorial-whiteboard-4.mp4"
      type="video/mp4"
    />
  </video>
</Figure>

To allow users to move rectangles, weâ€™ll update the `x` and `y` properties of
the selected shape when a user drags it:

```ts file="src/store.ts" highlight="6,10-11,21,27,32-58"
/* ... */

type State = {
  shapes: Record<string, Shape>;
  selectedShape: string | null;
  isDragging: boolean;
  insertRectangle: () => void;
  onShapePointerDown: (shapeId: string | null) => void;
  deleteShape: () => void;
  onCanvasPointerUp: () => void;
  onCanvasPointerMove: (e: React.PointerEvent) => void;
};

/* ... */

const useStore = create<WithLiveblocks<State>>()(
  liveblocks(
    (set, get) => ({
      shapes: {},
      selectedShape: null,
      isDragging: false,

      insertRectangle: () => {
        /* ... */
      },
      onShapePointerDown: (shapeId) => {
        set({ selectedShape: shapeId, isDragging: true });
      },
      deleteShape: () => {
        /* ... */
      },
      onCanvasPointerUp: () => {
        set({ isDragging: false });
      },
      onCanvasPointerMove: (e) => {
        e.preventDefault();

        const { isDragging, shapes, selectedShape } = get();
        if (!selectedShape) {
          /* Nothing todo */
          return;
        }

        const shape = shapes[selectedShape];

        if (shape && isDragging) {
          set({
            shapes: {
              ...shapes,
              [selectedShape]: {
                ...shape,
                x: e.clientX - 50,
                y: e.clientY - 50,
              },
            },
          });
        }
      },
    }),
    {
      client,
      storageMapping: { shapes: true },
      presenceMapping: { selectedShape: true },
    }
  )
);

export default useStore;
```

```tsx file="src/App.tsx" highlight="12,13,21,22"
import { useEffect } from "react";
import useStore from "./store";

import "./App.css";

export default function App() {
  const shapes = useStore((state) => state.shapes);
  const insertRectangle = useStore((state) => state.insertRectangle);
  const others = useStore((state) => state.liveblocks.others);
  const selectedShape = useStore((state) => state.selectedShape);
  const deleteShape = useStore((state) => state.deleteShape);
  const onCanvasPointerMove = useStore((state) => state.onCanvasPointerMove);
  const onCanvasPointerUp = useStore((state) => state.onCanvasPointerUp);

  /* ... */

  return (
    <>
      <div
        className="canvas"
        onPointerMove={onCanvasPointerMove}
        onPointerUp={onCanvasPointerUp}
      >
        {/* ... */}
      </div>
      <div className="toolbar">{/* ... */}</div>
    </>
  );
}

/* Rectangle */
```

## Multiplayer undo/redo [#undo-redo]

With Liveblocks, you can enable multiplayer undo/redo in just a few lines of
code.

<Figure>
  <video autoPlay loop muted playsInline>
    <source
      src="/assets/tutorials/whiteboard/tutorial-whiteboard-5.mp4"
      type="video/mp4"
    />
  </video>
</Figure>

Add two buttons to the toolbar and bind them to
[`room.history.undo`](/docs/api-reference/liveblocks-client#Room.history.undo)
and
[`room.history.redo`](/docs/api-reference/liveblocks-client#Room.history.redo).
These functions only impact modifications made to the roomâ€™s storage.

```tsx file="src/App.tsx" highlight="14,15,33,34"
import { useEffect } from "react";
import useStore from "./store";

import "./App.css";

export default function App() {
  const shapes = useStore((state) => state.shapes);
  const insertRectangle = useStore((state) => state.insertRectangle);
  const others = useStore((state) => state.liveblocks.others);
  const selectedShape = useStore((state) => state.selectedShape);
  const deleteShape = useStore((state) => state.deleteShape);
  const onCanvasPointerMove = useStore((state) => state.onCanvasPointerMove);
  const onCanvasPointerUp = useStore((state) => state.onCanvasPointerUp);
  const undo = useStore((state) => state.liveblocks.room?.history.undo);
  const redo = useStore((state) => state.liveblocks.room?.history.redo);

  /* ... */

  return (
    <>
      <div
        className="canvas"
        onPointerMove={onCanvasPointerMove}
        onPointerUp={onCanvasPointerUp}
      >
        {/* ... */}
      </div>
      <div className="toolbar">
        <button onClick={insertRectangle}>Rectangle</button>
        <button onClick={deleteShape} disabled={selectedShape === null}>
          Delete
        </button>
        <button onClick={undo}>Undo</button>
        <button onClick={redo}>Redo</button>
      </div>
    </>
  );
}

/* Rectangle */
```

### Pause and resume history [#pause-resume-history]

When a user moves a rectangle, a large number of actions are sent to Liveblocks
and live synced, enabling other users to see movements in realtime.

The problem with this is that the undo button returns the rectangle to the last
intermediary position, and not the position where the rectangle started its
movement. We can fix this by pausing storage history until the move has
completed.

<Figure>
  <video autoPlay loop muted playsInline>
    <source
      src="/assets/tutorials/whiteboard/tutorial-whiteboard-6.mp4"
      type="video/mp4"
    />
  </video>
</Figure>

Weâ€™ll use
[`history.pause`](/docs/api-reference/liveblocks-client#Room.history.pause) to
disable adding any positions to the history stack while the cursors moves, and
then call
[`history.resume`](/docs/api-reference/liveblocks-client#Room.history.resume)
afterwards.

```ts file="src/store.ts" highlight="14,22"
/* ... */

const useStore = create<WithLiveblocks<State>>()(
  liveblocks(
    (set, get) => ({
      isDragging: false,
      shapes: {},
      selectedShape: null,

      insertRectangle: () => {
        /* ... */
      },
      onShapePointerDown: (shapeId) => {
        get().liveblocks.room?.history.pause();
        set({ selectedShape: shapeId, isDragging: true });
      },
      deleteShape: () => {
        /* ... */
      },
      onCanvasPointerUp: () => {
        set({ isDragging: false });
        get().liveblocks.room?.history.resume();
      },
      onCanvasPointerMove: (e) => {
        /* ... */
      },
    }),
    {
      client,
      storageMapping: { shapes: true },
      presenceMapping: { selectedShape: true },
    }
  )
);

export default useStore;
```

### Add selection to history [#selection-history]

By default, presence updates are not added to the roomâ€™s history. Letâ€™s add the
current user selection to the roomâ€™s history to improve our undo/redo behavior.

To accomplish that, use
[`room.updatePresence`](/docs/api-reference/liveblocks-client#Room.updatePresence)
with the option `addToHistory` to update `selectedShape`. Liveblocks middleware
will update store `selectedShape` for you.

```ts file="src/store.ts" highlight="11,20-26,29-35,38,44-48"
/* ... */

const useStore = create<WithLiveblocks<State>>()(
  liveblocks(
    (set, get) => ({
      isDragging: false,
      shapes: {},
      selectedShape: null,

      insertRectangle: () => {
        const { shapes, liveblocks } = get();

        const shapeId = Date.now().toString();
        const shape = {
          x: getRandomInt(300),
          y: getRandomInt(300),
          fill: getRandomColor(),
        };

        liveblocks.room?.updatePresence(
          { selectedShape: shapeId },
          { addToHistory: true }
        );
        set({
          shapes: { ...shapes, [shapeId]: shape },
        });
      },
      onShapePointerDown: (shapeId) => {
        const room = get().liveblocks.room;
        room?.history.pause();
        room?.updatePresence(
          { selectedShape: shapeId },
          { addToHistory: true }
        );
        set({ isDragging: true });
      },
      deleteShape: () => {
        const { shapes, selectedShape, liveblocks } = get();
        if (!selectedShape) {
          /* Nothing todo */
          return;
        }
        const { [selectedShape]: shapeToDelete, ...newShapes } = shapes;
        liveblocks.room?.updatePresence(
          { selectedShape: null },
          { addToHistory: true }
        );
        set({ shapes: newShapes });
      },
      onCanvasPointerUp: () => {
        /* ... */
      },
      onCanvasPointerMove: (e) => {
        /* ... */
      },
    }),
    {
      client,
      storageMapping: { shapes: true },
      presenceMapping: { selectedShape: true },
    }
  )
);

export default useStore;
```

VoilÃ ! We have a working collaborative whiteboard app, with persistent data
storage.

## Summary

In this tutorial, weâ€™ve learnt about the concept of rooms, presence, and others.
We've also learnt how to put all these into practice, and how to persist state
using storage too.

You can see some stats about the room you created in your
[dashboard](https://liveblocks.io/dashboard/rooms).

<Figure>
  <Image
    src="/assets/tutorials/whiteboard/tutorial-whiteboard-dashboard.png"
    alt="Liveblocks dashboard"
    width={1336}
    height={822}
    quality={80}
  />
</Figure>

## Next steps

- [API reference](/docs/api-reference/liveblocks-zustand)
- [Authentication](/docs/authentication)

---
meta:
  title:
    "How to create a collaborative text editor with Lexical, Yjs, Next.js, and
    Liveblocks"
  description:
    "Build a collaborative text editor with Lexical, Yjs, Next.js, and
    Liveblocks"
---

In this tutorial, weâ€™ll be building a collaborative text editor using Lexical,
Yjs, Next.js, and Liveblocks.

<Figure>
  <video autoPlay loop muted playsInline>
    <source
      src="/assets/tutorials/text-editors/text-editor-demo.mp4"
      type="video/mp4"
    />
  </video>
</Figure>

<Banner title="No longer recommended" type="warning">

We now have an official Lexical package, and we recommend you use this instead
of following this guide. Read more in our
[Lexical getting started guide](/docs/get-started/nextjs-lexical). However,
should you like to set up Lexical manually with Yjs, without using our full
feature set, continue reading.

</Banner>

This guide assumes that youâ€™re already familiar with
[React](https://react.dev/), [Next.js](https://nextjs.org),
[TypeScript](https://www.typescriptlang.org/), and
[Lexical](https://lexical.dev).

## Install Lexical, Yjs, and Liveblocks into your React application

<Banner title="Download the example">

On GitHub we have a working example of this
[collaborative Lexical editor](https://github.com/liveblocks/liveblocks/tree/main/examples/nextjs-yjs-lexical)
for you to download and run.

</Banner>

Run the following command to install the Lexical, Yjs, and Liveblocks packages:

```bash
npm install lexical @lexical/react @lexical/yjs @liveblocks/client @liveblocks/react @liveblocks/yjs yjs
```

## Set up access token authentication

The first step in connecting to Liveblocks is to set up an authentication
endpoint in `/app/api/liveblocks-auth/route.ts`.

```ts
import { Liveblocks } from "@liveblocks/node";
import { NextRequest } from "next/server";

const API_KEY = "{{SECRET_KEY}}";

const liveblocks = new Liveblocks({
  secret: API_KEY!,
});

export async function POST(request: NextRequest) {
  // Get the current user's info from your database
  const user = {
    id: "charlielayne@example.com",
    info: {
      name: "Charlie Layne",
      color: "#D583F0",
      picture: "https://liveblocks.io/avatars/avatar-1.png",
    },
  };

  // Create a session for the current user
  // userInfo is made available in Liveblocks presence hooks, e.g. useOthers
  const session = liveblocks.prepareSession(user.id, {
    userInfo: user.info,
  });

  // Give the user access to the room
  const { room } = await request.json();
  session.allow(room, session.FULL_ACCESS);

  // Authorize the user and return the result
  const { body, status } = await session.authorize();
  return new Response(body, { status });
}
```

Hereâ€™s an example using the older API routes format in `/pages`.

```ts file="pages/api/liveblocks-auth.ts" isCollapsed isCollapsable
import { Liveblocks } from "@liveblocks/node";
import type { NextApiRequest, NextApiResponse } from "next";

const API_KEY = "{{SECRET_KEY}}";

const liveblocks = new Liveblocks({
  secret: API_KEY!,
});

export default async function handler(
  request: NextApiRequest,
  response: NextApiResponse
) {
  // Get the current user's info from your database
  const user = {
    id: "charlielayne@example.com",
    info: {
      name: "Charlie Layne",
      color: "#D583F0",
      picture: "https://liveblocks.io/avatars/avatar-1.png",
    },
  };

  // Create a session for the current user
  // userInfo is made available in Liveblocks presence hooks, e.g. useOthers
  const session = liveblocks.prepareSession(user.id, {
    userInfo: user.info,
  });

  // Give the user access to the room
  const { room } = request.body;
  session.allow(room, session.FULL_ACCESS);

  // Authorize the user and return the result
  const { status, body } = await session.authorize();
  response.status(status).send(body);
}
```

## Initialize your Liveblocks config file

Letâ€™s initialize the `liveblocks.config.ts` file in which youâ€™ll set up the
Liveblocks client.

```bash
npx create-liveblocks-app@latest --init --framework react
```

## Join a Liveblocks room

Liveblocks uses the concept of rooms, separate virtual spaces where people
collaborate. To create a realtime experience, multiple users must be connected
to the same room. Create a file in the current directory within `/app`, and name
it `Room.tsx`. Pass the location of your endpoint to `LiveblocksProvider`.

```tsx file="/app/Room.tsx"
"use client";

import { ReactNode } from "react";
import {
  LiveblocksProvider,
  RoomProvider,
  ClientSideSuspense,
} from "@liveblocks/react/suspense";

export function Room({ children }: { children: ReactNode }) {
  return (
    <LiveblocksProvider authEndpoint="/api/liveblocks-auth">
      <RoomProvider id="my-room">
        <ClientSideSuspense fallback={<div>Loadingâ€¦</div>}>
          {children}
        </ClientSideSuspense>
      </RoomProvider>
    </LiveblocksProvider>
  );
}
```

## Set up the Lexical editor

Now that we set up Liveblocks, we can start integrating Lexical and Yjs in the
`Editor.tsx` file.

```tsx file="Editor.tsx"
"use client";

import { LiveblocksYjsProvider } from "@liveblocks/yjs";
import * as Y from "yjs";
import { useRoom } from "@/liveblocks.config";
import styles from "./Editor.module.css";
import {
  $createParagraphNode,
  $createTextNode,
  $getRoot,
  LexicalEditor,
} from "lexical";
import { LexicalComposer } from "@lexical/react/LexicalComposer";
import { RichTextPlugin } from "@lexical/react/LexicalRichTextPlugin";
import { ContentEditable } from "@lexical/react/LexicalContentEditable";
import LexicalErrorBoundary from "@lexical/react/LexicalErrorBoundary";
import { CollaborationPlugin } from "@lexical/react/LexicalCollaborationPlugin";
import { Provider } from "@lexical/yjs";

// Set up editor config
const initialConfig = {
  // NOTE: This is critical for collaboration plugin to set editor state to null. It
  // would indicate that the editor should not try to set any default state
  // (not even empty one), and let collaboration plugin do it instead
  editorState: null,
  namespace: "Demo",
  nodes: [],
  onError: (error: unknown) => {
    throw error;
  },
};

// Define initial editor state
function initialEditorState(editor: LexicalEditor): void {
  const root = $getRoot();
  const paragraph = $createParagraphNode();
  const text = $createTextNode();
  paragraph.append(text);
  root.append(paragraph);
}

// Collaborative text editor with simple rich text
export default function Editor() {
  // Get Liveblocks room
  const room = useRoom();

  return (
    <div className={styles.container}>
      <LexicalComposer initialConfig={initialConfig}>
        <div className={styles.editorContainer}>
          <RichTextPlugin
            contentEditable={<ContentEditable className={styles.editor} />}
            placeholder={
              <p className={styles.placeholder}>Start typing hereâ€¦</p>
            }
            ErrorBoundary={LexicalErrorBoundary}
          />
          <CollaborationPlugin
            id="yjs-plugin"
            providerFactory={(id, yjsDocMap) => {
              // Set up Liveblocks Yjs provider
              const doc = new Y.Doc();
              yjsDocMap.set(id, doc);
              const provider = new LiveblocksYjsProvider(room, doc) as Provider;
              return provider;
            }}
            initialEditorState={initialEditorState}
            shouldBootstrap={true}
          />
        </div>
      </LexicalComposer>
    </div>
  );
}
```

And here is the `Editor.module.css` file to make sure your multiplayer text
editor looks nice and tidy.

```css file="Editor.module.css" isCollapsed isCollapsable
.container {
  display: flex;
  flex-direction: column;
  position: relative;
  border-radius: 12px;
  background: #fff;
  width: 100%;
  height: 100%;
  color: #111827;
}

.editorHeader {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.editor {
  border-radius: inherit;
  flex-grow: 1;
  width: 100%;
  height: 100%;
  padding: 1rem;
}

.editor:focus {
  outline: none;
}

.editorContainer {
  position: relative;
  height: 100%;
}

.placeholder {
  pointer-events: none;
  position: absolute;
  inset: 0;
  opacity: 0.3;
  padding: 0 1em;
}
```

## Add live cursors

To add live cursors to the text editor, we can pass the current userâ€™s
information from our authentication endpoint into `CollaborationPlugin`.

```tsx file="Editor.tsx" highlight="1,7,22-23"
import { useSelf } from "../liveblocks.config";
// ...

export default function Editor() {
  // Get Liveblocks room, and user info from Liveblocks authentication endpoint
  const room = useRoom();
  const userInfo = useSelf((me) => me.info);

  return (
    <div className={styles.container}>
      <LexicalComposer initialConfig={initialConfig}>
        <div className={styles.editorContainer}>
          <RichTextPlugin
            contentEditable={<ContentEditable className={styles.editor} />}
            placeholder={
              <p className={styles.placeholder}>Start typing hereâ€¦</p>
            }
            ErrorBoundary={LexicalErrorBoundary}
          />
          <CollaborationPlugin
            id="yjs-plugin"
            cursorColor={userInfo.color}
            username={userInfo.name}
            providerFactory={(id, yjsDocMap) => {
              // Set up Liveblocks Yjs provider
              const doc = new Y.Doc();
              yjsDocMap.set(id, doc);
              const provider = new LiveblocksYjsProvider(room, doc) as Provider;
              return provider;
            }}
            initialEditorState={initialEditorState}
            shouldBootstrap={true}
          />
        </div>
      </LexicalComposer>
    </div>
  );
}
```

## Add a toolbar

From this point onwards, you can build your Lexical app as normal! For example,
should you wish to add a basic text-style toolbar to your app:

```tsx file="Toolbar.tsx"
import { useLexicalComposerContext } from "@lexical/react/LexicalComposerContext";
import { FORMAT_TEXT_COMMAND } from "lexical";
import styles from "./Toolbar.module.css";

export function Toolbar() {
  const [editor] = useLexicalComposerContext();

  return (
    <div className={styles.toolbar}>
      <button
        className={styles.buttonBold}
        onClick={() => {
          editor.dispatchCommand(FORMAT_TEXT_COMMAND, "bold");
        }}
        aria-label="Format bold"
      >
        B
      </button>
      <button
        className={styles.buttonItalic}
        onClick={() => {
          editor.dispatchCommand(FORMAT_TEXT_COMMAND, "italic");
        }}
        aria-label="Format italic"
      >
        i
      </button>
      <button
        className={styles.buttonUnderline}
        onClick={() => {
          editor.dispatchCommand(FORMAT_TEXT_COMMAND, "underline");
        }}
        aria-label="Format underline"
      >
        u
      </button>
    </div>
  );
}
```

Add some matching styles:

```css file="Toolbar.module.css" isCollapsed isCollapsable
.toolbar {
  display: flex;
  padding: 1em;
  gap: 6px;
}

.button {
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  border-radius: 6px;
  height: 32px;
  width: 32px;
  background: #fff;
  color: #1f2937;
  border: none;
  box-shadow:
    rgba(0, 0, 0, 0.12) 0 4px 8px 0,
    rgba(0, 0, 0, 0.02) 0 0 0 1px;
}

.button:hover {
  color: #111827;
  box-shadow:
    rgba(0, 0, 0, 0.16) 0 5px 8px 0,
    rgba(0, 0, 0, 0.04) 0 0 0 1px;
}

.button:focus-visible {
  outline-offset: 2px;
}

.button:active {
  box-shadow:
    rgba(0, 0, 0, 0.16) 0 2px 3px 0,
    rgba(0, 0, 0, 0.04) 0 0 0 1px;
}
```

You can then import this into your editor to enable basic rich-text:

```tsx file="Editor.tsx" highlight="1,10-12"
import { Toolbar } from "./Toolbar";
// ...

export default function Editor() {
  // ...

  return (
    <div className={styles.container}>
      <LexicalComposer initialConfig={initialConfig}>
        <div className={styles.editorHeader}>
          <Toolbar />
        </div>
        <div className={styles.editorContainer}>{/* ... */}</div>
      </LexicalComposer>
    </div>
  );
}
```

### Theme your text styles

You can go a step further and theme your basic custom text styles by using the
`theme` property, and adding corresponding styles:

```tsx file="Editor.tsx" highlight="15-22"
import styles from "./Editor.module.css";
// ...

// Set up editor config and theme
const initialConfig = {
  // NOTE: This is critical for collaboration plugin to set editor state to null. It
  // would indicate that the editor should not try to set any default state
  // (not even empty one), and let collaboration plugin do it instead
  editorState: null,
  namespace: "Demo",
  nodes: [],
  onError: (error: unknown) => {
    throw error;
  },
  theme: {
    text: {
      bold: styles.textBold,
      italic: styles.textItalic,
      underline: styles.textUnderline,
    },
    paragraph: styles.paragraph,
  },
};

// ...
```

And then in your CSS module, you can style your rich-text:

```css file="Editor.module.css" isCollapsed isCollapsable
/* ... */

.textBold {
  font-weight: bold;
}

.textItalic {
  font-style: italic;
}

.textUnderline {
  text-decoration: underline;
}

.paragraph {
  margin: 0.2rem 0;
}
```

## Create live avatars with Liveblocks hooks

Along with building out your text editor, you can now use other Liveblocks
features, such as [Presence](/docs/ready-made-features/presence). The
[`useOthers`](/docs/api-reference/liveblocks-react#useOthers) hook allows us to
view information about each user currently online, and we can turn this into a
live avatars component.

```tsx file="Avatars.tsx"
import { useOthers, useSelf } from "@/liveblocks.config";
import styles from "./Avatars.module.css";

export function Avatars() {
  const users = useOthers();
  const currentUser = useSelf();

  return (
    <div className={styles.avatars}>
      {users.map(({ connectionId, info }) => {
        return (
          <Avatar key={connectionId} picture={info.picture} name={info.name} />
        );
      })}

      {currentUser && (
        <div className="relative ml-8 first:ml-0">
          <Avatar
            picture={currentUser.info.picture}
            name={currentUser.info.name}
          />
        </div>
      )}
    </div>
  );
}

export function Avatar({ picture, name }: { picture: string; name: string }) {
  return (
    <div className={styles.avatar} data-tooltip={name}>
      <img
        src={picture}
        className={styles.avatar_picture}
        data-tooltip={name}
      />
    </div>
  );
}
```

And hereâ€™s the styles:

```css file="Avatars.module.css" isCollapsed isCollapsable
.avatars {
  display: flex;
  padding: 0 0.75rem;
}

.avatar {
  display: flex;
  place-content: center;
  position: relative;
  border: 4px solid #fff;
  border-radius: 9999px;
  width: 42px;
  height: 42px;
  background-color: #9ca3af;
  margin-left: -0.75rem;
}

.avatar:before {
  content: attr(data-tooltip);
  position: absolute;
  top: 100%;
  opacity: 0;
  transition: opacity 0.15s ease;
  padding: 5px 10px;
  color: white;
  font-size: 0.75rem;
  border-radius: 8px;
  margin-top: 10px;
  z-index: 1;
  background: black;
  white-space: nowrap;
}

.avatar:hover:before {
  opacity: 1;
}

.avatar_picture {
  width: 100%;
  height: 100%;
  border-radius: 9999px;
}
```

You can then import this to your editor to see it in action:

```tsx file="Editor.tsx" highlight="1,12"
import { Avatars } from "./Avatars";
// ...

export default function Editor() {
  // ...

  return (
    <div className={styles.container}>
      <LexicalComposer initialConfig={initialConfig}>
        <div className={styles.editorHeader}>
          <Toolbar />
          <Avatars />
        </div>
        <div className={styles.editorContainer}>{/* ... */}</div>
      </LexicalComposer>
    </div>
  );
}
```

Note that the cursors and avatars match in color and name, as the info for both
is sourced from the Liveblocks authentication endpoint.

## Try it out

You should now see the complete editor, along with live cursors, live avatars,
and some basic rich-text features! On GitHub we have a working example of this
[multiplayer text editor](https://github.com/liveblocks/liveblocks/tree/main/examples/nextjs-yjs-lexical).

<Figure>
  <video autoPlay loop muted playsInline>
    <source
      src="/assets/tutorials/text-editors/text-editor-demo.mp4"
      type="video/mp4"
    />
  </video>
</Figure>

---
meta:
  title:
    "How to create a collaborative text editor with Quill, Yjs, Next.js, and
    Liveblocks"
  description:
    "Build a collaborative text editor with Quill, Yjs, Next.js, and Liveblocks"
---

In this tutorial, weâ€™ll be building a collaborative text editor using Quill,
Yjs, Next.js, and Liveblocks.

<Figure>
  <video autoPlay loop muted playsInline>
    <source
      src="/assets/tutorials/text-editors/text-editor-demo.mp4"
      type="video/mp4"
    />
  </video>
</Figure>

This guide assumes that youâ€™re already familiar with
[React](https://react.dev/), [Next.js](https://nextjs.org/),
[TypeScript](https://www.typescriptlang.org/), and
[Quill](https://quilljs.com/).

## Install Quill, Yjs, and Liveblocks into your Next.js application

<Banner title="Download the example">

On GitHub we have a working example of this
[collaborative Quill editor](https://github.com/liveblocks/liveblocks/tree/main/examples/nextjs-yjs-quill)
for you to download and run.

</Banner>

Run the following command to install the Quill, Yjs, and Liveblocks packages:

```bash
npm install @liveblocks/client @liveblocks/react @liveblocks/yjs yjs quill quill-cursors react-quill y-quill
```

## Set up access token authentication

The first step in connecting to Liveblocks is to set up an authentication
endpoint in `/app/api/liveblocks-auth/route.ts`.

```ts
import { Liveblocks } from "@liveblocks/node";
import { NextRequest } from "next/server";

const API_KEY = "{{SECRET_KEY}}";

const liveblocks = new Liveblocks({
  secret: API_KEY!,
});

export async function POST(request: NextRequest) {
  // Get the current user's info from your database
  const user = {
    id: "charlielayne@example.com",
    info: {
      name: "Charlie Layne",
      color: "#D583F0",
      picture: "https://liveblocks.io/avatars/avatar-1.png",
    },
  };

  // Create a session for the current user
  // userInfo is made available in Liveblocks presence hooks, e.g. useOthers
  const session = liveblocks.prepareSession(user.id, {
    userInfo: user.info,
  });

  // Give the user access to the room
  const { room } = await request.json();
  session.allow(room, session.FULL_ACCESS);

  // Authorize the user and return the result
  const { body, status } = await session.authorize();
  return new Response(body, { status });
}
```

Hereâ€™s an example using the older API routes format in `/pages`.

```ts file="pages/api/liveblocks-auth.ts" isCollapsed isCollapsable
import { Liveblocks } from "@liveblocks/node";
import type { NextApiRequest, NextApiResponse } from "next";

const API_KEY = "{{SECRET_KEY}}";

const liveblocks = new Liveblocks({
  secret: API_KEY!,
});

export default async function handler(
  request: NextApiRequest,
  response: NextApiResponse
) {
  // Get the current user's info from your database
  const user = {
    id: "charlielayne@example.com",
    info: {
      name: "Charlie Layne",
      color: "#D583F0",
      picture: "https://liveblocks.io/avatars/avatar-1.png",
    },
  };

  // Create a session for the current user
  // userInfo is made available in Liveblocks presence hooks, e.g. useOthers
  const session = liveblocks.prepareSession(user.id, {
    userInfo: user.info,
  });

  // Give the user access to the room
  const { room } = request.body;
  session.allow(room, session.FULL_ACCESS);

  // Authorize the user and return the result
  const { status, body } = await session.authorize();
  response.status(status).send(body);
}
```

## Initialize your Liveblocks config file

Letâ€™s initialize the `liveblocks.config.ts` file in which youâ€™ll set up the
Liveblocks client.

```bash
npx create-liveblocks-app@latest --init --framework react
```

## Join a Liveblocks room

Liveblocks uses the concept of rooms, separate virtual spaces where people
collaborate. To create a realtime experience, multiple users must be connected
to the same room. Create a file in the current directory within `/app`, and name
it `Room.tsx`. Pass the location of your endpoint to `LiveblocksProvider`.

```tsx file="/app/Room.tsx"
"use client";

import { ReactNode } from "react";
import {
  LiveblocksProvider,
  RoomProvider,
  ClientSideSuspense,
} from "@liveblocks/react/suspense";

export function Room({ children }: { children: ReactNode }) {
  return (
    <LiveblocksProvider authEndpoint="/api/liveblocks-auth">
      <RoomProvider id="my-room">
        <ClientSideSuspense fallback={<div>Loadingâ€¦</div>}>
          {children}
        </ClientSideSuspense>
      </RoomProvider>
    </LiveblocksProvider>
  );
}
```

## Set up the Quill editor

Now that weâ€™ve set up Liveblocks, we can start integrating Quill and Yjs in the
`Editor.tsx` file.

```tsx file="Editor.tsx"
"use client";

import Quill from "quill";
import ReactQuill from "react-quill";
import { QuillBinding } from "y-quill";
import * as Y from "yjs";
import { LiveblocksYjsProvider } from "@liveblocks/yjs";
import { useRoom } from "@/liveblocks.config";
import { useEffect, useRef, useState } from "react";
import styles from "./Editor.module.css";

// Collaborative text editor with simple rich text, live cursors, and live avatars
export function CollaborativeEditor() {
  const room = useRoom();
  const [text, setText] = useState<Y.Text>();
  const [provider, setProvider] = useState<any>();

  // Set up Liveblocks Yjs provider
  useEffect(() => {
    const yDoc = new Y.Doc();
    const yText = yDoc.getText("quill");
    const yProvider = new LiveblocksYjsProvider(room, yDoc);
    setText(yText);
    setProvider(yProvider);

    return () => {
      yDoc?.destroy();
      yProvider?.destroy();
    };
  }, [room]);

  if (!text || !provider) {
    return null;
  }

  return <QuillEditor yText={text} provider={provider} />;
}

type EditorProps = {
  yText: Y.Text;
  provider: any;
};

function QuillEditor({ yText, provider }: EditorProps) {
  const reactQuillRef = useRef<ReactQuill>(null);

  // Set up Yjs and Quill
  useEffect(() => {
    let quill: ReturnType<ReactQuill["getEditor"]>;
    let binding: QuillBinding;

    if (!reactQuillRef.current) {
      return;
    }

    quill = reactQuillRef.current.getEditor();
    binding = new QuillBinding(yText, quill, provider.awareness);
    return () => {
      binding?.destroy?.();
    };
  }, [yText, provider]);

  return (
    <div className={styles.container}>
      <div className={styles.editorContainer}>
        <ReactQuill
          className={styles.editor}
          placeholder="Start typing hereâ€¦"
          ref={reactQuillRef}
          theme="snow"
          modules={{
            toolbar: false,
            history: {
              // Local undo shouldn't undo changes from remote users
              userOnly: true,
            },
          }}
        />
      </div>
    </div>
  );
}
```

And here is the `Editor.module.css` file to make sure your multiplayer text
editor looks nice and tidy.

```css file="Editor.module.css" isCollapsed isCollapsable
.container {
  display: flex;
  flex-direction: column;
  position: relative;
  border-radius: 12px;
  background: #fff;
  width: 100%;
  height: 100%;
  color: #111827;
}

.editorHeader {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.editor {
  border-radius: inherit;
  flex-grow: 1;
  width: 100%;
  height: 100%;
  padding: 1rem;
  outline: none;
}

.editorContainer {
  position: relative;
  height: 100%;
}

.placeholder {
  pointer-events: none;
  position: absolute;
  inset: 0;
  opacity: 0.3;
  padding: 0 1em;
}

.editor p {
  margin: 1em 0;
}
```

We recommend importing some global styles into your `layout.tsx` or `page.tsx`
file too. Weâ€™ll be creating a custom UI, but some classes are still necessary
for Quill:

```css file="globals.css" isCollapsed isCollapsable
/* Let cursor flags show on the first line */
div.ql-container {
  overflow: unset;
}

/* Remove editor focus */
div.ql-editor:focus {
  outline: none;
}

/* Hide non-visible clipboard element */
div.ql-clipboard {
  left: -100000px;
  height: 1px;
  overflow-y: hidden;
  position: absolute;
  top: 50%;
}
```

## Add your editor to the current page

Next, add the `CollaborativeEditor` into the page file, and place it inside the
`Room` component we created earlier. We should now be seeing a basic
collaborative editor!

```tsx file="/app/page.tsx"
import { Room } from "./Room";
import CollaborativeEditor from "@/components/Editor";

export default function Page() {
  return (
    <Room>
      <CollaborativeEditor />
    </Room>
  );
}
```

## Add live cursors

To add live cursors to the text editor, we can get the `userInfo` for the
current user with [`useSelf`](/docs/api-reference/liveblocks-react#useSelf), and
feed it into `editor`. We should now see some cursors with names.

```tsx file="CollaborativeEditor.tsx" highlight="1,4,9-17,30"
import { useSelf } from "../liveblocks.config.ts";
// ...

Quill.register("modules/cursors", QuillCursors);

// ...

function QuillEditor({ yText, provider }: EditorProps) {
  // Add user info to cursors from Liveblocks authentication endpoint
  const userInfo = useSelf((me) => me.info);
  useEffect(() => {
    const { name, color } = userInfo;
    provider.awareness.setLocalStateField("user", {
      name,
      color,
    });
  }, [userInfo]);

  // ...

  return (
    <div className={styles.container}>
      <div className={styles.editorContainer}>
        <ReactQuill
          className={styles.editor}
          placeholder="Start typing hereâ€¦"
          ref={reactQuillRef}
          theme="snow"
          modules={{
            cursors: true,
            toolbar: false,
            history: {
              // Local undo shouldn't undo changes from remote users
              userOnly: true,
            },
          }}
        />
      </div>
    </div>
  );
}
```

## Add a toolbar

From this point onwards, you can build your Quill app as normal! For example,
should you wish to add a basic text-style toolbar to your app:

```tsx file="Toolbar.tsx"
import styles from "./Toolbar.module.css";
import { QuillEditorType } from "@/components/CollaborativeEditor";
import { useCallback } from "react";

type Props = {
  getQuill: () => QuillEditorType | null;
};

type Formats = "bold" | "italic" | "underline";

export function Toolbar({ getQuill }: Props) {
  const formatSelection = useCallback(
    (format: Formats) => {
      const quill = getQuill();
      if (!quill) {
        return;
      }

      const selection = quill.getSelection();
      if (!selection) {
        return;
      }

      const { index, length } = selection;
      const hasFormat = quill.getFormat(index, length)[format];

      quill.formatText(
        index,
        length,
        {
          [format]: !hasFormat,
        },
        "user"
      );
    },
    [getQuill]
  );

  return (
    <div className={styles.toolbar}>
      <button
        className={styles.button}
        onClick={() => formatSelection("bold")}
        aria-label="bold"
      >
        B
      </button>
      <button
        onClick={() => formatSelection("italic")}
        className={styles.button}
        aria-label="italic"
      >
        I
      </button>
      <button
        onClick={() => formatSelection("underline")}
        className={styles.button}
        aria-label="underline"
      >
        U
      </button>
    </div>
  );
}
```

Add some matching styles:

```css file="Toolbar.module.css" isCollapsed isCollapsable
.toolbar {
  display: flex;
  padding: 1em;
  gap: 6px;
}

.button {
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  border-radius: 6px;
  height: 32px;
  width: 32px;
  background: #fff;
  color: #1f2937;
  border: none;
  box-shadow:
    rgba(0, 0, 0, 0.12) 0 4px 8px 0,
    rgba(0, 0, 0, 0.02) 0 0 0 1px;
}

.button:hover {
  color: #111827;
  box-shadow:
    rgba(0, 0, 0, 0.16) 0 5px 8px 0,
    rgba(0, 0, 0, 0.04) 0 0 0 1px;
}

.button:focus-visible {
  outline-offset: 2px;
}

.button:active {
  box-shadow:
    rgba(0, 0, 0, 0.16) 0 2px 3px 0,
    rgba(0, 0, 0, 0.04) 0 0 0 1px;
}

.button[data-active] {
  background: #fafafa;
}
```

You can then import this into your editor, and create the `getQuill` function to
enable basic rich-text:

```tsx file="Editor.tsx" highlight="1,7-14,18-20"
import { Toolbar } from "./Toolbar";
// ...

function QuillEditor({ yText, provider }: EditorProps) {
  // ...

  // Function to get the current Quill editor
  const getQuill = useCallback(() => {
    if (!reactQuillRef.current) {
      return null;
    }

    return reactQuillRef.current.getEditor();
  }, []);

  return (
    <div className={styles.container}>
      <div className={styles.editorHeader}>
        <Toolbar getQuill={getQuill} />
      </div>
      <div className={styles.editorContainer}>{/* ... */}</div>
    </div>
  );
}
```

## Create live avatars with Liveblocks hooks

Along with building out your text editor, you can now use other Liveblocks
features, such as [Presence](/docs/ready-made-features/presence). The
[`useOthers`](/docs/api-reference/liveblocks-react#useOthers) hook allows us to
view information about each user currently online, and we can turn this into a
live avatars component.

```tsx file="Avatars.tsx"
import { useOthers, useSelf } from "@/liveblocks.config";
import styles from "./Avatars.module.css";

export function Avatars() {
  const users = useOthers();
  const currentUser = useSelf();

  return (
    <div className={styles.avatars}>
      {users.map(({ connectionId, info }) => {
        return (
          <Avatar key={connectionId} picture={info.picture} name={info.name} />
        );
      })}

      {currentUser && (
        <div className="relative ml-8 first:ml-0">
          <Avatar
            picture={currentUser.info.picture}
            name={currentUser.info.name}
          />
        </div>
      )}
    </div>
  );
}

export function Avatar({ picture, name }: { picture: string; name: string }) {
  return (
    <div className={styles.avatar} data-tooltip={name}>
      <img
        src={picture}
        className={styles.avatar_picture}
        data-tooltip={name}
      />
    </div>
  );
}
```

And hereâ€™s the styles:

```css file="Avatars.module.css" isCollapsed isCollapsable
.avatars {
  display: flex;
  padding: 0 0.75rem;
}

.avatar {
  display: flex;
  place-content: center;
  position: relative;
  border: 4px solid #fff;
  border-radius: 9999px;
  width: 42px;
  height: 42px;
  background-color: #9ca3af;
  margin-left: -0.75rem;
}

.avatar:before {
  content: attr(data-tooltip);
  position: absolute;
  top: 100%;
  opacity: 0;
  transition: opacity 0.15s ease;
  padding: 5px 10px;
  color: white;
  font-size: 0.75rem;
  border-radius: 8px;
  margin-top: 10px;
  z-index: 1;
  background: black;
  white-space: nowrap;
}

.avatar:hover:before {
  opacity: 1;
}

.avatar_picture {
  width: 100%;
  height: 100%;
  border-radius: 9999px;
}
```

You can then import this into your editor to see it in action:

```tsx file="Editor.tsx" highlight="1,11"
import { Avatars } from "./Avatars";
// ...

function QuillEditor({ yText, provider }: EditorProps) {
  // ...

  return (
    <div className={styles.container}>
      <div className={styles.editorHeader}>
        <Toolbar getQuill={getQuill} />
        <Avatars />
      </div>
      <div className={styles.editorContainer}>{/* ... */}</div>
    </div>
  );
}
```

Note that the cursors and avatars match in color and name, as the info for both
is sourced from the Liveblocks authentication endpoint.

## Try it out

You should now see the complete editor, along with live cursors, live avatars,
and some basic rich-text features! On GitHub we have a working example of this
[multiplayer text editor](https://github.com/liveblocks/liveblocks/tree/main/examples/nextjs-yjs-quill).

<Figure>
  <video autoPlay loop muted playsInline>
    <source
      src="/assets/tutorials/text-editors/text-editor-demo.mp4"
      type="video/mp4"
    />
  </video>
</Figure>

---
meta:
  title:
    "How to create a collaborative text editor with Slate, Yjs, Next.js, and
    Liveblocks"
  description:
    "Build a collaborative text editor with Slate, Yjs, Next.js, and Liveblocks"
---

In this tutorial, weâ€™ll be building a collaborative text editor using Slate,
Yjs, Next.js, and Liveblocks.

<Figure>
  <video autoPlay loop muted playsInline>
    <source
      src="/assets/tutorials/text-editors/text-editor-demo.mp4"
      type="video/mp4"
    />
  </video>
</Figure>

This guide assumes that youâ€™re already familiar with
[React](https://react.dev/), [Next.js](https://nextjs.org/),
[TypeScript](https://www.typescriptlang.org/), and
[Slate](https://docs.slatejs.org/).

## Install Slate, Yjs, and Liveblocks into your Next.js application

<Banner title="Download the example">

On GitHub we have a working example of this
[collaborative Slate editor](https://github.com/liveblocks/liveblocks/tree/main/examples/nextjs-yjs-slate)
for you to download and run.

</Banner>

Run the following command to install the Slate, Yjs, and Liveblocks packages:

```bash
npm install @liveblocks/client @liveblocks/react @liveblocks/yjs @liveblocks/node yjs slate slate-react @slate-yjs/core @slate-yjs/react
```

### Transpile slate-yjs

Add `transpilePackages` to your `next.config.ts` file to allow
`@slate-yjs/react` to be bundled correctly.

```js highlight="2"
module.exports = {
  transpilePackages: ["@slate-yjs/react"],

  // ...
};
```

#### Got an error?

Note that if youâ€™re seeing an error that resembles the following, youâ€™re
probably using an older version of Next.js that doesnâ€™t support
`transpilePackages`.

```
Error: Directory import '/node_modules/use-sync-external-store/shim' is not supported resolving ES modules imported from /node_modules/@slate-yjs/react/dist/index.js
Did you mean to import use-sync-external-store/shim/index.js?
```

You may need to upgrade to a newer version of Next.js for this to work.

```bash
npm i next@latest
```

## Set up access token authentication

The first step in connecting to Liveblocks is to set up an authentication
endpoint in `/app/api/liveblocks-auth/route.ts`.

```ts
import { Liveblocks } from "@liveblocks/node";
import { NextRequest } from "next/server";

const API_KEY = "{{SECRET_KEY}}";

const liveblocks = new Liveblocks({
  secret: API_KEY!,
});

export async function POST(request: NextRequest) {
  // Get the current user's info from your database
  const user = {
    id: "charlielayne@example.com",
    info: {
      name: "Charlie Layne",
      color: "#D583F0",
      picture: "https://liveblocks.io/avatars/avatar-1.png",
    },
  };

  // Create a session for the current user
  // userInfo is made available in Liveblocks presence hooks, e.g. useOthers
  const session = liveblocks.prepareSession(user.id, {
    userInfo: user.info,
  });

  // Give the user access to the room
  const { room } = await request.json();
  session.allow(room, session.FULL_ACCESS);

  // Authorize the user and return the result
  const { body, status } = await session.authorize();
  return new Response(body, { status });
}
```

Hereâ€™s an example using the older API routes format in `/pages`.

```ts file="/pages/api/liveblocks-auth.ts" isCollapsed isCollapsable
import { Liveblocks } from "@liveblocks/node";
import type { NextApiRequest, NextApiResponse } from "next";

const API_KEY = "{{SECRET_KEY}}";

const liveblocks = new Liveblocks({
  secret: API_KEY!,
});

export default async function handler(
  request: NextApiRequest,
  response: NextApiResponse
) {
  // Get the current user's info from your database
  const user = {
    id: "charlielayne@example.com",
    info: {
      name: "Charlie Layne",
      color: "#D583F0",
      picture: "https://liveblocks.io/avatars/avatar-1.png",
    },
  };

  // Create a session for the current user
  // userInfo is made available in Liveblocks presence hooks, e.g. useOthers
  const session = liveblocks.prepareSession(user.id, {
    userInfo: user.info,
  });

  // Give the user access to the room
  const { room } = request.body;
  session.allow(room, session.FULL_ACCESS);

  // Authorize the user and return the result
  const { body, status } = await session.authorize();
  response.status(status).send(body);
}
```

## Initialize your Liveblocks config file

Letâ€™s initialize the `liveblocks.config.ts` file in which youâ€™ll set up the
Liveblocks client.

```bash
npx create-liveblocks-app@latest --init --framework react
```

## Join a Liveblocks room

Liveblocks uses the concept of rooms, separate virtual spaces where people
collaborate. To create a realtime experience, multiple users must be connected
to the same room. Create a file in the current directory within `/app`, and name
it `Room.tsx`. Pass the location of your endpoint to `LiveblocksProvider`.

```tsx file="/app/Room.tsx"
"use client";

import { ReactNode } from "react";
import {
  LiveblocksProvider,
  RoomProvider,
  ClientSideSuspense,
} from "@liveblocks/react/suspense";

export function Room({ children }: { children: ReactNode }) {
  return (
    <LiveblocksProvider authEndpoint="/api/liveblocks-auth">
      <RoomProvider id="my-room">
        <ClientSideSuspense fallback={<div>Loadingâ€¦</div>}>
          {children}
        </ClientSideSuspense>
      </RoomProvider>
    </LiveblocksProvider>
  );
}
```

## Set up the Slate editor

Now that weâ€™ve set up Liveblocks, we can start integrating Slate and Yjs in the
`Editor.tsx` file.

```tsx file="Editor.tsx"
import { LiveblocksYjsProvider } from "@liveblocks/yjs";
import { useEffect, useMemo, useState } from "react";
import { createEditor, Editor, Transforms } from "slate";
import { Editable, Slate, withReact } from "slate-react";
import { withYjs, YjsEditor } from "@slate-yjs/core";
import * as Y from "yjs";
import { LiveblocksProviderType, useRoom } from "../liveblocks.config";
import styles from "./Editor.module.css";

export default function CollaborativeEditor() {
  const room = useRoom();
  const [connected, setConnected] = useState(false);
  const [sharedType, setSharedType] = useState<Y.XmlText>();
  const [provider, setProvider] = useState<LiveblocksProviderType>();

  // Set up Liveblocks Yjs provider
  useEffect(() => {
    const yDoc = new Y.Doc();
    const yProvider = new LiveblocksYjsProvider(room, yDoc);
    const sharedDoc = yDoc.get("slate", Y.XmlText) as Y.XmlText;
    yProvider.on("sync", setConnected);

    setSharedType(sharedDoc);
    setProvider(yProvider);

    return () => {
      yDoc?.destroy();
      yProvider?.off("sync", setConnected);
      yProvider?.destroy();
    };
  }, [room]);

  if (!connected || !sharedType || !provider) {
    return <div>Loadingâ€¦</div>;
  }

  return <SlateEditor sharedType={sharedType} />;
}

const emptyNode = {
  children: [{ text: "" }],
};

function SlateEditor({ sharedType }: { sharedType: Y.XmlText }) {
  // Set up editor with plugins
  const editor = useMemo(() => {
    const e = withReact(withYjs(createEditor(), sharedType));

    // Ensure editor always has at least 1 valid child
    const { normalizeNode } = e;
    e.normalizeNode = (entry) => {
      const [node] = entry;

      if (!Editor.isEditor(node) || node.children.length > 0) {
        return normalizeNode(entry);
      }

      Transforms.insertNodes(editor, emptyNode, { at: [0] });
    };

    return e;
  }, [sharedType]);

  useEffect(() => {
    YjsEditor.connect(editor);
    return () => YjsEditor.disconnect(editor);
  }, [editor]);

  return (
    <div className={styles.container}>
      <div className={styles.editorContainer}>
        <Slate editor={editor} initialValue={[emptyNode]}>
          <Editable
            className={styles.editor}
            placeholder="Start typing hereâ€¦"
          />
        </Slate>
      </div>
    </div>
  );
}
```

And here is the `Editor.module.css` file to make sure your multiplayer text
editor looks nice and tidy.

```css file="Editor.module.css" isCollapsed isCollapsable
.container {
  display: flex;
  flex-direction: column;
  position: relative;
  border-radius: 12px;
  background: #fff;
  width: 100%;
  height: 100%;
  color: #111827;
}

.editorHeader {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.editor {
  border-radius: inherit;
  flex-grow: 1;
  width: 100%;
  height: 100%;
  padding: 1rem;
}

.editor:focus {
  outline: none;
}

.editorContainer {
  position: relative;
  height: 100%;
}

.placeholder {
  pointer-events: none;
  position: absolute;
  inset: 0;
  opacity: 0.3;
  padding: 0 1em;
}

.editor p {
  margin: 1em 0;
}
```

## Add your editor to the current page

Next, add the `CollaborativeEditor` into the page file, and place it inside the
`Room` component we created earlier. We should now be seeing a basic
collaborative editor!

```tsx file="/app/page.tsx"
import { Room } from "@/app/Room";
import CollaborativeEditor from "@/components/Editor";

export default function Page() {
  return (
    <Room>
      <CollaborativeEditor />
    </Room>
  );
}
```

## Add live cursors

To add live cursors to the text editor, we can rely on hooks from the
`@slate-yjs/react` package.

```tsx file="Cursors.tsx"
import {
  CursorOverlayData,
  useRemoteCursorOverlayPositions,
} from "@slate-yjs/react";
import React, { CSSProperties, ReactNode, useRef } from "react";
import { Cursor } from "./types";
import styles from "./Cursors.module.css";

export function Cursors({ children }: { children: ReactNode }) {
  const containerRef = useRef<HTMLDivElement>(null);
  const [cursors] = useRemoteCursorOverlayPositions<Cursor>({
    containerRef,
  });

  return (
    <div className={styles.cursors} ref={containerRef}>
      {children}
      {cursors.map((cursor) => (
        <Selection key={cursor.clientId} {...cursor} />
      ))}
    </div>
  );
}

function Selection({
  data,
  selectionRects,
  caretPosition,
}: CursorOverlayData<Cursor>) {
  if (!data) {
    return null;
  }

  const selectionStyle: CSSProperties = {
    backgroundColor: data.color,
  };

  return (
    <>
      {selectionRects.map((position, i) => (
        <div
          style={{ ...selectionStyle, ...position }}
          className={styles.selection}
          key={i}
        />
      ))}
      {caretPosition && <Caret caretPosition={caretPosition} data={data} />}
    </>
  );
}

type CaretProps = Pick<CursorOverlayData<Cursor>, "caretPosition" | "data">;

function Caret({ caretPosition, data }: CaretProps) {
  const caretStyle: CSSProperties = {
    ...caretPosition,
    background: data?.color,
  };

  const labelStyle: CSSProperties = {
    transform: "translateY(-100%)",
    background: data?.color,
  };

  return (
    <div style={caretStyle} className={styles.caretMarker}>
      <div className={styles.caret} style={labelStyle}>
        {data?.name}
      </div>
    </div>
  );
}
```

And of course we need some corresponding CSS to keep the cursors in the correct
positions.

```css file="Cursors.module.css" isCollapsed isCollapsable
.cursors {
  position: relative;
}

.caretMarker {
  position: absolute;
  width: 2px;
}

.caret {
  position: absolute;
  font-size: 14px;
  color: #fff;
  white-space: nowrap;
  top: 0;
  border-radius: 6px;
  border-bottom-left-radius: 0;
  padding: 2px 6px;
  pointer-events: none;
}

.selection {
  position: absolute;
  pointer-events: none;
  opacity: 0.2;
}
```

Back in your `Editor` component, get the current userâ€™s info with
[`useSelf`](/docs/api-reference/liveblocks-react#useSelf), add the `withCursors`
plugin, and pass the user info and awareness. Then wrap your editor in the
Cursors component to see them working.

```tsx file="Editor.tsx" highlight="1-3,7-8,12-20,29,34"
import { withCursors, withYjs, YjsEditor } from "@slate-yjs/core";
import { useSelf } from "../liveblocks.config";
import { Cursors } from "./Cursors";
// ...

export default function SlateEditor() {
  // Get user info from Liveblocks authentication endpoint
  const userInfo = useSelf((self) => self.info);

  // Set up editor with plugins, and place user info into Yjs awareness and cursors
  const editor = useMemo(() => {
    const e = withReact(
      withCursors(
        withYjs(createEditor(), sharedType),
        provider.awareness as any,
        {
          data: userInfo,
        }
      )
    );

    // ...
  }, [sharedType, provider.awareness, userInfo]);

  return (
    <div className={styles.container}>
      <div className={styles.editorContainer}>
        <Slate editor={editor} initialValue={[emptyNode]}>
          <Cursors>
            <Editable
              className={styles.editor}
              placeholder="Start typing hereâ€¦"
            />
          </Cursors>
        </Slate>
      </div>
    </div>
  );
}
```

## Add a toolbar

From this point onwards, you can build your Slate app as normal! For example,
should you wish to add a basic text-style toolbar to your app:

```tsx file="Toolbar.tsx"
import { Editor } from "slate";
import { useSlate } from "slate-react";
import styles from "./Toolbar.module.css";
import { CustomText } from "./types";

export function Toolbar() {
  const editor = useSlate();

  return (
    <div className={styles.toolbar}>
      <button
        className={styles.button}
        data-active={isMarkActive(editor, "bold") || undefined}
        onClick={(event) => {
          event.preventDefault();
          toggleMark(editor, "bold");
        }}
      >
        B
      </button>
      <button
        className={styles.button}
        data-active={isMarkActive(editor, "italic") || undefined}
        onClick={(event) => {
          event.preventDefault();
          toggleMark(editor, "italic");
        }}
      >
        i
      </button>
      <button
        className={styles.button}
        data-active={isMarkActive(editor, "underline") || undefined}
        onClick={(event) => {
          event.preventDefault();
          toggleMark(editor, "underline");
        }}
      >
        u
      </button>
    </div>
  );
}

function toggleMark(editor: Editor, format: keyof CustomText) {
  const isActive = isMarkActive(editor, format);

  if (isActive) {
    Editor.removeMark(editor, format);
  } else {
    Editor.addMark(editor, format, true);
  }
}

function isMarkActive(editor: Editor, format: keyof CustomText) {
  const marks = Editor.marks(editor);
  return marks ? marks?.[format] === true : false;
}
```

Add some matching styles:

```css file="Toolbar.module.css" isCollapsed isCollapsable
.toolbar {
  display: flex;
  padding: 1em;
  gap: 6px;
}

.button {
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  border-radius: 6px;
  height: 32px;
  width: 32px;
  background: #fff;
  color: #1f2937;
  border: none;
  box-shadow:
    rgba(0, 0, 0, 0.12) 0 4px 8px 0,
    rgba(0, 0, 0, 0.02) 0 0 0 1px;
}

.button:hover {
  color: #111827;
  box-shadow:
    rgba(0, 0, 0, 0.16) 0 5px 8px 0,
    rgba(0, 0, 0, 0.04) 0 0 0 1px;
}

.button:focus-visible {
  outline-offset: 2px;
}

.button:active {
  box-shadow:
    rgba(0, 0, 0, 0.16) 0 2px 3px 0,
    rgba(0, 0, 0, 0.04) 0 0 0 1px;
}

.button[data-active] {
  background: #fafafa;
}
```

### Theme your leaf styles

These styles are rendered with leaf components, which weâ€™ll add to a new file:

```tsx file="Leaf.tsx"
import { PropsWithChildren } from "react";
import { CustomText } from "@/src/types";

type Props = PropsWithChildren<{
  attributes: Record<string, string>;
  leaf: CustomText;
}>;

export function Leaf({ attributes, children, leaf }: Props) {
  if (leaf.bold) {
    children = <strong>{children}</strong>;
  }

  if (leaf.italic) {
    children = <em>{children}</em>;
  }

  if (leaf.underline) {
    children = <u>{children}</u>;
  }

  return <span {...attributes}>{children}</span>;
}
```

You can then import this into your editor to enable basic rich-text:

```tsx file="Editor.tsx" highlight="1,2,8,13,15-17"
import { Toolbar } from "@/src/Toolbar";
import { Leaf } from "@/src/Leaf";
// ...

export default function SlateEditor() {
  // ...

  const renderLeaf = useCallback((props: any) => <Leaf {...props} />, []);

  return (
    <div className={styles.container}>
      <div className={styles.editorContainer}>
        <Slate editor={editor} initialValue={[emptyNode]}>
          <Cursors>
            <div className={styles.editorHeader}>
              <Toolbar />
            </div>
            <Editable
              className={styles.editor}
              placeholder="Start typing hereâ€¦"
              renderLeaf={renderLeaf}
            />
          </Cursors>
        </Slate>
      </div>
    </div>
  );
}
```

## Create live avatars with Liveblocks hooks

Along with building out your text editor, you can now use other Liveblocks
features, such as [Presence](/docs/ready-made-features/presence). The
[`useOthers`](/docs/api-reference/liveblocks-react#useOthers) hook allows us to
view information about each user currently online, and we can turn this into a
live avatars component.

```tsx file="Avatars.tsx"
import { useOthers, useSelf } from "@/liveblocks.config";
import styles from "./Avatars.module.css";

export function Avatars() {
  const users = useOthers();
  const currentUser = useSelf();

  return (
    <div className={styles.avatars}>
      {users.map(({ connectionId, info }) => {
        return (
          <Avatar key={connectionId} picture={info.picture} name={info.name} />
        );
      })}

      {currentUser && (
        <div className="relative ml-8 first:ml-0">
          <Avatar
            picture={currentUser.info.picture}
            name={currentUser.info.name}
          />
        </div>
      )}
    </div>
  );
}

export function Avatar({ picture, name }: { picture: string; name: string }) {
  return (
    <div className={styles.avatar} data-tooltip={name}>
      <img
        src={picture}
        className={styles.avatar_picture}
        data-tooltip={name}
      />
    </div>
  );
}
```

And hereâ€™s the styles:

```css file="Avatars.module.css" isCollapsed isCollapsable
.avatars {
  display: flex;
  padding: 0 0.75rem;
}

.avatar {
  display: flex;
  place-content: center;
  position: relative;
  border: 4px solid #fff;
  border-radius: 9999px;
  width: 42px;
  height: 42px;
  background-color: #9ca3af;
  margin-left: -0.75rem;
}

.avatar:before {
  content: attr(data-tooltip);
  position: absolute;
  top: 100%;
  opacity: 0;
  transition: opacity 0.15s ease;
  padding: 5px 10px;
  color: white;
  font-size: 0.75rem;
  border-radius: 8px;
  margin-top: 10px;
  z-index: 1;
  background: black;
  white-space: nowrap;
}

.avatar:hover:before {
  opacity: 1;
}

.avatar_picture {
  border-radius: 9999px;
}
```

You can then import this to your editor to see it in action:

```tsx file="Editor.tsx" highlight="1,14"
import { Avatars } from "./Avatars";
// ...

export default function SlateEditor() {
  // ...

  return (
    <div className={styles.container}>
      <div className={styles.editorContainer}>
        <Slate editor={editor} initialValue={[emptyNode]}>
          <Cursors>
            <div className={styles.editorHeader}>
              <Toolbar />
              <Avatars />
            </div>
            <Editable
              className={styles.editor}
              placeholder="Start typing hereâ€¦"
              renderLeaf={renderLeaf}
            />
          </Cursors>
        </Slate>
      </div>
    </div>
  );
}
```

Note that the cursors and avatars match in color and name, as the info for both
is sourced from the Liveblocks authentication endpoint.

## Try it out

You should now see the complete editor, along with live cursors, live avatars,
and some basic rich-text features! On GitHub we have a working example of this
[multiplayer text editor](https://github.com/liveblocks/liveblocks/tree/main/examples/nextjs-yjs-slate).

<Figure>
  <video autoPlay loop muted playsInline>
    <source
      src="/assets/tutorials/text-editors/text-editor-demo.mp4"
      type="video/mp4"
    />
  </video>
</Figure>

---
meta:
  title:
    "How to create a collaborative text editor with Tiptap, Yjs, Next.js, and
    Liveblocks"
  description:
    "Build a collaborative text editor with Tiptap, Yjs, Next.js, and Liveblocks"
---

In this tutorial, weâ€™ll be building a collaborative text editor using Tiptap,
Yjs, Next.js, and Liveblocks.

<Figure>
  <video autoPlay loop muted playsInline>
    <source
      src="/assets/tutorials/text-editors/text-editor-demo.mp4"
      type="video/mp4"
    />
  </video>
</Figure>

<Banner title="No longer recommended" type="warning">

We now have an official Tiptap package, and we recommend you use this instead of
following this guide. Read more in our
[Tiptap getting started guide](/docs/get-started/nextjs-tiptap). However, should
you like to set up Tiptap manually with Yjs, without using our full feature set,
continue reading.

</Banner>

This guide assumes that youâ€™re already familiar with
[React](https://react.dev/), [Next.js](https://nextjs.org/),
[TypeScript](https://www.typescriptlang.org/), and
[Tiptap](https://tiptap.dev/).

## Install Tiptap, Yjs, and Liveblocks into your Next.js application

<Banner title="Download the example">

On GitHub we have a working example of this
[collaborative Tiptap editor](https://github.com/liveblocks/liveblocks/tree/main/examples/nextjs-yjs-tiptap)
for you to download and run.

</Banner>

Run the following command to install the Tiptap, Yjs, and Liveblocks packages:

```bash
npm install @liveblocks/client @liveblocks/react @liveblocks/yjs yjs @tiptap/extension-collaboration @tiptap/extension-collaboration-cursor @tiptap/pm @tiptap/react @tiptap/starter-kit
```

## Set up access token authentication

The first step in connecting to Liveblocks is to set up an authentication
endpoint in `/app/api/liveblocks-auth/route.ts`.

```ts
import { Liveblocks } from "@liveblocks/node";
import { NextRequest } from "next/server";

const API_KEY = "{{SECRET_KEY}}";

const liveblocks = new Liveblocks({
  secret: API_KEY!,
});

export async function POST(request: NextRequest) {
  // Get the current user's info from your database
  const user = {
    id: "charlielayne@example.com",
    info: {
      name: "Charlie Layne",
      color: "#D583F0",
      picture: "https://liveblocks.io/avatars/avatar-1.png",
    },
  };

  // Create a session for the current user
  // userInfo is made available in Liveblocks presence hooks, e.g. useOthers
  const session = liveblocks.prepareSession(user.id, {
    userInfo: user.info,
  });

  // Give the user access to the room
  const { room } = await request.json();
  session.allow(room, session.FULL_ACCESS);

  // Authorize the user and return the result
  const { body, status } = await session.authorize();
  return new Response(body, { status });
}
```

Hereâ€™s an example using the older API routes format in `/pages`.

```ts file="pages/api/liveblocks-auth.ts" isCollapsed isCollapsable
import { Liveblocks } from "@liveblocks/node";
import type { NextApiRequest, NextApiResponse } from "next";

const API_KEY = "{{SECRET_KEY}}";

const liveblocks = new Liveblocks({
  secret: API_KEY!,
});

export default async function handler(
  request: NextApiRequest,
  response: NextApiResponse
) {
  // Get the current user's info from your database
  const user = {
    id: "charlielayne@example.com",
    info: {
      name: "Charlie Layne",
      color: "#D583F0",
      picture: "https://liveblocks.io/avatars/avatar-1.png",
    },
  };

  // Create a session for the current user
  // userInfo is made available in Liveblocks presence hooks, e.g. useOthers
  const session = liveblocks.prepareSession(user.id, {
    userInfo: user.info,
  });

  // Give the user access to the room
  const { room } = request.body;
  session.allow(room, session.FULL_ACCESS);

  // Authorize the user and return the result
  const { status, body } = await session.authorize();
  response.status(status).send(body);
}
```

## Initialize your Liveblocks config file

Letâ€™s initialize the `liveblocks.config.ts` file in which youâ€™ll set up the
Liveblocks client.

```bash
npx create-liveblocks-app@latest --init --framework react
```

## Join a Liveblocks room

Liveblocks uses the concept of rooms, separate virtual spaces where people
collaborate. To create a realtime experience, multiple users must be connected
to the same room. Create a file in the current directory within `/app`, and name
it `Room.tsx`. Pass the location of your endpoint to `LiveblocksProvider`.

```tsx file="/app/Room.tsx"
"use client";

import { ReactNode } from "react";
import {
  LiveblocksProvider,
  RoomProvider,
  ClientSideSuspense,
} from "@liveblocks/react/suspense";

export function Room({ children }: { children: ReactNode }) {
  return (
    <LiveblocksProvider authEndpoint="/api/liveblocks-auth">
      <RoomProvider id="my-room">
        <ClientSideSuspense fallback={<div>Loadingâ€¦</div>}>
          {children}
        </ClientSideSuspense>
      </RoomProvider>
    </LiveblocksProvider>
  );
}
```

## Set up the Tiptap editor

Now that weâ€™ve set up Liveblocks, we can start integrating Tiptap and Yjs in the
`Editor.tsx` file.

```tsx file="Editor.tsx"
"use client";

import { useEditor, EditorContent } from "@tiptap/react";
import StarterKit from "@tiptap/starter-kit";
import Collaboration from "@tiptap/extension-collaboration";
import CollaborationCursor from "@tiptap/extension-collaboration-cursor";
import * as Y from "yjs";
import { LiveblocksYjsProvider } from "@liveblocks/yjs";
import { useRoom } from "@/liveblocks.config";
import { useEffect, useState } from "react";
import styles from "./CollaborativeEditor.module.css";

// Collaborative text editor with simple rich text, live cursors, and live avatars
export function CollaborativeEditor() {
  const room = useRoom();
  const [doc, setDoc] = useState<Y.Doc>();
  const [provider, setProvider] = useState<any>();

  // Set up Liveblocks Yjs provider
  useEffect(() => {
    const yDoc = new Y.Doc();
    const yProvider = new LiveblocksYjsProvider(room, yDoc);
    setDoc(yDoc);
    setProvider(yProvider);

    return () => {
      yDoc?.destroy();
      yProvider?.destroy();
    };
  }, [room]);

  if (!doc || !provider) {
    return null;
  }

  return <TiptapEditor doc={doc} provider={provider} />;
}

type EditorProps = {
  doc: Y.Doc;
  provider: any;
};

function TiptapEditor({ doc, provider }: EditorProps) {
  // Set up editor with plugins
  const editor = useEditor({
    editorProps: {
      attributes: {
        // Add styles to editor element
        class: styles.editor,
      },
    },
    extensions: [
      StarterKit.configure({
        // The Collaboration extension comes with its own history handling
        undoRedo: false,
      }),
      // Register the document with Tiptap
      Collaboration.configure({
        document: doc,
      }),
      // Attach provider and user info
      CollaborationCursor.configure({
        provider: provider,
      }),
    ],
  });

  return (
    <div className={styles.container}>
      <EditorContent editor={editor} className={styles.editorContainer} />
    </div>
  );
}
```

And here is the `Editor.module.css` file to make sure your multiplayer text
editor looks nice and tidy.

```css file="Editor.module.css" isCollapsed isCollapsable
.container {
  display: flex;
  flex-direction: column;
  position: relative;
  border-radius: 12px;
  background: #fff;
  width: 100%;
  height: 100%;
  color: #111827;
}

.editorHeader {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.editor {
  border-radius: inherit;
  flex-grow: 1;
  width: 100%;
  height: 100%;
  padding: 1rem;
}

.editor:focus {
  outline: none;
}

.editorContainer {
  position: relative;
  height: 100%;
}

.placeholder {
  pointer-events: none;
  position: absolute;
  inset: 0;
  opacity: 0.3;
  padding: 0 1em;
}

.editor p {
  margin: 1em 0;
}
```

## Add your editor to the current page

Next, add the `CollaborativeEditor` into the page file, and place it inside the
`Room` component we created earlier. We should now be seeing a basic
collaborative editor!

```tsx file="/app/page.tsx"
import { Room } from "./Room";
import CollaborativeEditor from "@/components/Editor";

export default function Page() {
  return (
    <Room>
      <CollaborativeEditor />
    </Room>
  );
}
```

## Add live cursors

To add live cursors to the text editor, we can get the `userInfo` for the
current user with [`useSelf`](/docs/api-reference/liveblocks-react#useSelf), and
feed it into `editor`. We should now see some cursors with names.

```tsx file="CollaborativeEditor.tsx" highlight="1,5-6,17"
import { useSelf } from "../liveblocks.config.ts";
// ...

function TiptapEditor({ doc, provider }: EditorProps) {
  // Get user info from Liveblocks authentication endpoint
  const userInfo = useSelf((me) => me.info);

  // Set up editor with plugins, and place user info into Yjs awareness and cursors
  const editor = useEditor({
    // ...
    extensions: [
      // ...

      // Attach provider and user info
      CollaborationCursor.configure({
        provider: provider,
        user: userInfo,
      }),
    ],
  });

  return (
    <div className={styles.container}>
      <EditorContent editor={editor} className={styles.editorContainer} />
    </div>
  );
}
```

We can style these cursors by placing CSS in a global CSS file.

```css file="globals.css" isCollapsed isCollapsable
/* Give a remote user a caret */
.collaboration-carets__caret {
  border-left: 1px solid #0d0d0d;
  border-right: 1px solid #0d0d0d;
  margin-left: -1px;
  margin-right: -1px;
  pointer-events: none;
  position: relative;
  word-break: normal;
}

/* Render the username above the caret */
.collaboration-carets__label {
  font-style: normal;
  font-weight: 600;
  left: -1px;
  line-height: normal;
  position: absolute;
  user-select: none;
  white-space: nowrap;
  font-size: 14px;
  color: #fff;
  top: -1.4em;
  border-radius: 6px;
  border-bottom-left-radius: 0;
  padding: 2px 6px;
  pointer-events: none;
}
```

## Add a toolbar

From this point onwards, you can build your Tiptap app as normal! For example,
should you wish to add a basic text-style toolbar to your app:

```tsx file="Toolbar.tsx"
import { Editor } from "@tiptap/react";
import styles from "./Toolbar.module.css";

type Props = {
  editor: Editor | null;
};

export function Toolbar({ editor }: Props) {
  if (!editor) {
    return null;
  }

  return (
    <div className={styles.toolbar}>
      <button
        className={styles.button}
        onClick={() => editor.chain().focus().toggleBold().run()}
        disabled={!editor.can().chain().focus().toggleBold().run()}
        data-active={editor.isActive("bold") ? "is-active" : undefined}
        aria-label="bold"
      >
        B
      </button>
      <button
        className={styles.button}
        onClick={() => editor.chain().focus().toggleItalic().run()}
        disabled={!editor.can().chain().focus().toggleItalic().run()}
        data-active={editor.isActive("italic") ? "is-active" : undefined}
        aria-label="italic"
      >
        i
      </button>
      <button
        className={styles.button}
        onClick={() => editor.chain().focus().toggleStrike().run()}
        disabled={!editor.can().chain().focus().toggleStrike().run()}
        data-active={editor.isActive("strike") ? "is-active" : undefined}
        aria-label="strikethrough"
      >
        S
      </button>
    </div>
  );
}
```

Add some matching styles:

```css file="Toolbar.module.css" isCollapsed isCollapsable
.toolbar {
  display: flex;
  padding: 1em;
  gap: 6px;
}

.button {
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  border-radius: 6px;
  height: 32px;
  width: 32px;
  background: #fff;
  color: #1f2937;
  border: none;
  box-shadow:
    rgba(0, 0, 0, 0.12) 0 4px 8px 0,
    rgba(0, 0, 0, 0.02) 0 0 0 1px;
}

.button:hover {
  color: #111827;
  box-shadow:
    rgba(0, 0, 0, 0.16) 0 5px 8px 0,
    rgba(0, 0, 0, 0.04) 0 0 0 1px;
}

.button:focus-visible {
  outline-offset: 2px;
}

.button:active {
  box-shadow:
    rgba(0, 0, 0, 0.16) 0 2px 3px 0,
    rgba(0, 0, 0, 0.04) 0 0 0 1px;
}

.button[data-active] {
  background: #fafafa;
}
```

You can then import this into your editor to enable basic rich-text:

```tsx file="Editor.tsx" highlight="1,9-11"
import { Toolbar } from "./Toolbar";
// ...

function TiptapEditor({ doc, provider }: EditorProps) {
  // ...

  return (
    <div className={styles.container}>
      <div className={styles.editorHeader}>
        <Toolbar editor={editor} />
      </div>
      <EditorContent editor={editor} className={styles.editorContainer} />
    </div>
  );
}
```

## Create live avatars with Liveblocks hooks

Along with building out your text editor, you can now use other Liveblocks
features, such as [Presence](/docs/ready-made-features/presence). The
[`useOthers`](/docs/api-reference/liveblocks-react#useOthers) hook allows us to
view information about each user currently online, and we can turn this into a
live avatars component.

```tsx file="Avatars.tsx"
import { useOthers, useSelf } from "@/liveblocks.config";
import styles from "./Avatars.module.css";

export function Avatars() {
  const users = useOthers();
  const currentUser = useSelf();

  return (
    <div className={styles.avatars}>
      {users.map(({ connectionId, info }) => {
        return (
          <Avatar key={connectionId} picture={info.picture} name={info.name} />
        );
      })}

      {currentUser && (
        <div className="relative ml-8 first:ml-0">
          <Avatar
            picture={currentUser.info.picture}
            name={currentUser.info.name}
          />
        </div>
      )}
    </div>
  );
}

export function Avatar({ picture, name }: { picture: string; name: string }) {
  return (
    <div className={styles.avatar} data-tooltip={name}>
      <img
        src={picture}
        className={styles.avatar_picture}
        data-tooltip={name}
      />
    </div>
  );
}
```

And hereâ€™s the styles:

```css file="Avatars.module.css" isCollapsed isCollapsable
.avatars {
  display: flex;
  padding: 0 0.75rem;
}

.avatar {
  display: flex;
  place-content: center;
  position: relative;
  border: 4px solid #fff;
  border-radius: 9999px;
  width: 42px;
  height: 42px;
  background-color: #9ca3af;
  margin-left: -0.75rem;
}

.avatar:before {
  content: attr(data-tooltip);
  position: absolute;
  top: 100%;
  opacity: 0;
  transition: opacity 0.15s ease;
  padding: 5px 10px;
  color: white;
  font-size: 0.75rem;
  border-radius: 8px;
  margin-top: 10px;
  z-index: 1;
  background: black;
  white-space: nowrap;
}

.avatar:hover:before {
  opacity: 1;
}

.avatar_picture {
  width: 100%;
  height: 100%;
  border-radius: 9999px;
}
```

You can then import this to your editor to see it in action:

```tsx file="Editor.tsx" highlight="11"
import { Avatars } from "./Avatars";
// ...

function TiptapEditor({ doc, provider }: EditorProps) {
  // ...

  return (
    <div className={styles.container}>
      <div className={styles.editorHeader}>
        <Toolbar editor={editor} />
        <Avatars />
      </div>
      <EditorContent editor={editor} className={styles.editorContainer} />
    </div>
  );
}
```

Note that the cursors and avatars match in color and name, as the info for both
is sourced from the Liveblocks authentication endpoint.

## Try it out

You should now see the complete editor, along with live cursors, live avatars,
and some basic rich-text features! On GitHub we have a working example of this
[multiplayer text editor](https://github.com/liveblocks/liveblocks/tree/main/examples/nextjs-yjs-tiptap).

<Figure>
  <video autoPlay loop muted playsInline>
    <source
      src="/assets/tutorials/text-editors/text-editor-demo.mp4"
      type="video/mp4"
    />
  </video>
</Figure>

---
meta:
  title:
    "How to create a collaborative to-do list with JavaScript and Liveblocks"
  description: "Build a collaborative to-do list with JavaScript and Liveblocks"
---

The goal of this tutorial is to show you how to build a collaborative to-do list
app in 15 minutes. The to-dos will be persisted on Liveblocks backend and synced
in realtime across clients. Users will also be able to see whoâ€™s currently using
the app and when someone is typing.

<Figure>
  <video autoPlay loop muted playsInline>
    <source
      src="/assets/tutorials/todo-list/tutorial-todo-list-1.mp4"
      type="video/mp4"
    />
  </video>
</Figure>

Weâ€™re going to use vanilla JavaScript and [esbuild](https://esbuild.github.io/)
for the bundling.

If youâ€™re using a front-end framework such as React, we recommend reading one of
our dedicated to-do list tutorials:

- [React tutorial](/docs/tutorials/collaborative-to-do-list/react)
- [React + Redux tutorial](/docs/tutorials/collaborative-to-do-list/react-redux)
- [React + Zustand tutorial](/docs/tutorials/collaborative-to-do-list/react-zustand)

The source code for this guide is
[available on GitHub](https://github.com/liveblocks/liveblocks/tree/main/examples/javascript-todo-list).

## Install Liveblocks into your project [#install-liveblocks]

### Install Liveblocks packages

Create an empty node project with `npm init` and run the following command to
install Liveblocks package and `esbuild`:

```bash
npm install @liveblocks/client esbuild
```

[`@liveblocks/client`][] lets you interact with Liveblocks servers.
[`esbuild`](https://esbuild.github.io/) lets your bundle your app with
`@liveblocks/client`.

Then add a build script to your `package.json` that will be responsible to
bundle our app.

```json
"scripts": {
  "build": "esbuild app.js --bundle --outfile=static/app.js"
},
```

### Connect to Liveblocks servers [#connect-liveblocks-servers]

Youâ€™ll need an API key in order to use Liveblocks.
[Create a Liveblocks account](/auth/signup) to get
[your API key](/dashboard/apikeys). It should start with `pk_`.

<Banner title="Public vs secret key">

With a secret key, you can control who can access the room. itâ€™s more secure but
you need your own back-end endpoint. For this tutorial, weâ€™ll go with a public
key. For more info, see the [authentication guide](/docs/authentication).

</Banner>

To connect to Liveblocks servers, create a client with [`createClient`][] and
set your public API key like below.

```jsx file="app.js"
import { createClient } from "@liveblocks/client";

const client = createClient({
  publicApiKey: "{{PUBLIC_KEY}}",
});
```

### Connect to a Liveblocks room [#connect-liveblocks-room]

A room is the virtual space where people collaborate. To create a collaborative
experience, youâ€™ll need to connect your users to a Liveblocks room following the
instructions below.

You can easily connect to a room by using [`client.enter`][] by passing the room
id as a parameter. For this tutorial weâ€™ll use `javascript-todo-app`.

```jsx highlight="7-13" file="app.js"
import { createClient } from "@liveblocks/client";

const client = createClient({
  publicApiKey: "{{PUBLIC_KEY}}",
});

function run() {
  const { room, leave } = client.enterRoom("javascript-todo-app", {
    initialPresence: { isTyping: false },
  });
}

run();
```

Weâ€™ve also passed an `initialPresence` value hereâ€”weâ€™ll be using this later.

## Show whoâ€™s currently in the room [#who-is-here]

<Banner title="Need help troubleshooting presence?">

Try the [Liveblocks DevTools extension](/devtools) to inspect and debug your
collaborative experiences as you build them, in realtime.

</Banner>

Now that Liveblocks is set up, weâ€™re going to use [`room.subscribe("others")`][]
to show whoâ€™s currently inside the room.

<Figure>
  <video autoPlay loop muted playsInline>
    <source
      src="/assets/tutorials/todo-list/tutorial-todo-list-2.mp4"
      type="video/mp4"
    />
  </video>
</Figure>

Create a file `static/index.html` with the following content:

```html file="static/index.html"
<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Liveblocks - Todo list</title>
    <link rel="stylesheet" href="index.css" />
  </head>
  <body>
    <div class="container">
      <div id="who_is_here" class="who_is_here"></div>
    </div>
    <script src="app.js"></script>
  </body>
</html>
```

And replace `app.js` content with the code below, build your app with
`npm run build` and open `static/index.html` in multiple browser windows.

```jsx file="app.js" highlight="12-16"
import { createClient } from "@liveblocks/client";

const client = createClient({
  publicApiKey: "{{PUBLIC_KEY}}",
});

function run() {
  const { room, leave } = client.enterRoom("javascript-todo-app", {
    initialPresence: { isTyping: false },
  });

  const whoIsHere = document.getElementById("who_is_here");

  room.subscribe("others", (others) => {
    whoIsHere.innerHTML = `There are ${others.count} other users online`;
  });
}

run();
```

_If you want to make your app feel less "brutalist" while following along,
create a file `static/index.css` with the following CSS._

```css file="static/index.css" isCollapsed isCollapsable
body {
  background-color: rgb(243, 243, 243);
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto",
    "Oxygen", "Ubuntu", "Cantarell", "Fira Sans", "Droid Sans",
    "Helvetica Neue", sans-serif;
  -webkit-font-smoothing: antialiased;
}

.container {
  display: flex;
  flex-direction: column;
  width: 100%;
  margin-left: auto;
  margin-right: auto;
  margin-top: 3rem;
  max-width: 28rem;
}

input {
  box-sizing: border-box;
  padding: 0.5rem 0.875rem;
  margin: 0.5rem 0;
  width: 100%;
  background-color: white;
  box-shadow:
    0 0 #000,
    0 0 #000,
    0 0 #000,
    0 0 #000,
    0 1px 2px 0 rgba(0, 0, 0, 0.05);
  border-radius: 0.5rem;
  color: black;
  border: 0 solid;
  font-size: 16px;
}

input:hover {
  box-shadow:
    0 0 #000,
    0 0 #000,
    0 0 #000,
    0 0 #000,
    0 1px 3px 0 rgba(0, 0, 0, 0.1),
    0 1px 2px 0 rgba(0, 0, 0, 0.06);
}

input:focus {
  outline: none;
}

.todo_container {
  display: flex;
  padding: 0.5rem 0.875rem;
  align-items: center;
  justify-content: space-between;
}

.todo {
  flex-grow: 1;
}

.delete_button {
  padding: 0;
  margin: 0;
  font-size: 16px;
  border: 0 solid;
  appearance: button;
  background-color: transparent;
}

.delete_button:focus {
  outline: none;
}

.who_is_here {
  align-self: flex-end;
  font-size: 11px;
  color: #aaa;
}

.someone_is_typing {
  position: absolute;
  font-size: 11px;
  color: #aaa;
}
```

## Show if someone is typing [#someone-is-typing]

<Figure>
  <video autoPlay loop muted playsInline>
    <source
      src="/assets/tutorials/todo-list/tutorial-todo-list-3.mp4"
      type="video/mp4"
    />
  </video>
</Figure>

Any users in the room can be typing, so we need to have a state `isTyping` per
connected user. This state is only temporary, it is not persisted after users
leave the room. Liveblocks has a concept of "presence" to handle this kind of
temporary states. For example, a user "presence" can be used to share the cursor
position or the selected shape if your building a design tool.

Weâ€™re going to use [`room.updatePresence`][] hook to set the `presence` of the
current user.

First, add an input to `static/index.html`

```html file="static/index.html" highlight="11"
<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Liveblocks - Todo list</title>
    <link rel="stylesheet" href="index.css" />
  </head>
  <body>
    <div class="container">
      <div id="who_is_here" class="who_is_here"></div>
      <input id="todo_input" type="text" placeholder="What needs to be done?" />
    </div>
    <script src="app.js"></script>
  </body>
</html>
```

Then listen to `keydown` and `blur` to detect when the user is typing.

```jsx file="App.js" highlight="13,19-32"
import { createClient } from "@liveblocks/client";

const client = createClient({
  publicApiKey: "{{PUBLIC_KEY}}",
});

function run() {
  const { room, leave } = client.enterRoom("javascript-todo-app", {
    initialPresence: { isTyping: false },
  });

  const whoIsHere = document.getElementById("who_is_here");
  const todoInput = document.getElementById("todo_input");

  room.subscribe("others", (others) => {
    whoIsHere.innerHTML = `There are ${others.count} other users online`;
  });

  todoInput.addEventListener("keydown", (e) => {
    // Clear the input when the user presses "Enter".
    // We'll add todo later on
    if (e.key === "Enter") {
      room.updatePresence({ isTyping: false });
      todoInput.value = "";
    } else {
      room.updatePresence({ isTyping: true });
    }
  });

  todoInput.addEventListener("blur", () => {
    room.updatePresence({ isTyping: false });
  });
}

run();
```

Now that we set the `isTyping` state when necessary, add a new `div` to display
a message when at least one other user has `isTyping` equals to `true`.

```html file="static/index.html" highlight="12"
<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Liveblocks - Todo list</title>
    <link rel="stylesheet" href="index.css" />
  </head>
  <body>
    <div class="container">
      <div id="who_is_here" class="who_is_here"></div>
      <input id="todo_input" type="text" placeholder="What needs to be done?" />
      <div id="someone_is_typing" class="someone_is_typing"></div>
    </div>
    <script src="app.js"></script>
  </body>
</html>
```

```jsx highlight="14,19-23" file="app.js"
import { createClient } from "@liveblocks/client";

const client = createClient({
  publicApiKey: "{{PUBLIC_KEY}}",
});

function run() {
  const { room, leave } = client.enterRoom("javascript-todo-app", {
    initialPresence: { isTyping: false },
  });

  const whoIsHere = document.getElementById("who_is_here");
  const todoInput = document.getElementById("todo_input");
  const someoneIsTyping = document.getElementById("someone_is_typing");

  room.subscribe("others", (others) => {
    whoIsHere.innerHTML = `There are ${others.count} other users online`;

    someoneIsTyping.innerHTML = others
      .toArray()
      .some((user) => user.presence?.isTyping)
      ? "Someone is typing..."
      : "";
  });

  todoInput.addEventListener("keydown", (e) => {
    // Clear the input when the user presses "Enter".
    // We'll add todo later on
    if (e.key === "Enter") {
      room.updatePresence({ isTyping: false });
      todoInput.value = "";
    } else {
      room.updatePresence({ isTyping: true });
    }
  });

  todoInput.addEventListener("blur", () => {
    room.updatePresence({ isTyping: false });
  });
}

run();
```

## Sync and persist to-dos [#add-liveblocks-storage]

<Banner title="Need help troubleshooting storage?">

Try the [Liveblocks DevTools extension](/devtools) to inspect and debug your
collaborative experiences as you build them, in realtime.

</Banner>

As opposed to the `presence`, some collaborative features require that every
user interacts with the same piece of state. For example, in Google Doc, it is
the paragraphs, headings, images in the document. In Figma, itâ€™s all the shapes
that make your design. Thatâ€™s what we call the roomâ€™s `storage`.

<Figure>
  <video autoPlay loop muted playsInline>
    <source
      src="/assets/tutorials/todo-list/tutorial-todo-list-1.mp4"
      type="video/mp4"
    />
  </video>
</Figure>

The roomâ€™s storage is a conflicts-free state that multiple users can edit at the
same time. It is persisted to our backend even after everyone leaves the room.
Liveblocks provides custom data structures inspired by
[CRDTs](https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type) that
can be nested to create the state that you want.

- [`LiveObject`][] - Similar to JavaScript object. If multiple users update the
  same property simultaneously, the last modification received by the Liveblocks
  servers is the winner.
- [`LiveList`][] - An ordered collection of items synchronized across clients.
  Even if multiple users add/remove/move elements simultaneously, LiveList will
  solve the conflicts to ensure everyone sees the same collection of items.
- [`LiveMap`][] - Similar to a JavaScript Map. If multiple users update the same
  property simultaneously, the last modification received by the Liveblocks
  servers is the winner.

Weâ€™re going to store the list of todos in a `LiveList`. Initialize the storage
with the `initialStorage` option when entering the room. Then we use
[`LiveList.push`][] when the user press "Enter".

```jsx highlight="1,8-11,17-19,28" file="src/App.js"
import { createClient, LiveList } from "@liveblocks/client";

const client = createClient({
  publicApiKey: "{{PUBLIC_KEY}}",
});

async function run() {
  const { room, leave } = client.enterRoom("javascript-todo-app", {
    initialPresence: { isTyping: false },
    initialStorage: { todos: new LiveList() },
  });

  const whoIsHere = document.getElementById("who_is_here");
  const todoInput = document.getElementById("todo_input");
  const someoneIsTyping = document.getElementById("someone_is_typing");

  const { root } = await room.getStorage();

  let todos = root.get("todos");

  room.subscribe("others", (others) => {
    /* ... */
  });

  todoInput.addEventListener("keydown", (e) => {
    if (e.key === "Enter") {
      room.updatePresence({ isTyping: false });
      todos.push({ text: todoInput.value });
      todoInput.value = "";
    } else {
      room.updatePresence({ isTyping: true });
    }
  });

  todoInput.addEventListener("blur", () => {
    room.updatePresence({ isTyping: false });
  });
}

run();
```

At this point, the todos are added to the storage but they are not rendered! Add
a container for our todos and use [`room.subscribe(todos)`][] to get rerender
the app whenever the todos are updated.

```html file="static/index.html" highlight="13"
<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Liveblocks - Todo list</title>
    <link rel="stylesheet" href="index.css" />
  </head>
  <body>
    <div class="container">
      <div id="who_is_here" class="who_is_here"></div>
      <input id="todo_input" type="text" placeholder="What needs to be done?" />
      <div id="someone_is_typing" class="someone_is_typing"></div>
      <div id="todos_container"></div>
    </div>
    <script src="app.js"></script>
  </body>
</html>
```

```jsx highlight="16,34-56" file="src/App.js"
import { createClient, LiveList } from "@liveblocks/client";

const client = createClient({
  publicApiKey: "{{PUBLIC_KEY}}",
});

async function run() {
  const { room, leave } = client.enterRoom("javascript-todo-app", {
    initialPresence: { isTyping: false },
    initialStorage: { todos: new LiveList() },
  });

  const whoIsHere = document.getElementById("who_is_here");
  const todoInput = document.getElementById("todo_input");
  const someoneIsTyping = document.getElementById("someone_is_typing");
  const todosContainer = document.getElementById("todos_container");

  const { root } = await room.getStorage();

  let todos = root.get("todos");

  room.subscribe("others", (others) => {
    /* ... */
  });

  todoInput.addEventListener("keydown", (e) => {
    /* ... */
  });

  todoInput.addEventListener("blur", () => {
    /* ... */
  });

  function renderTodos() {
    todosContainer.innerHTML = "";

    for (let i = 0; i < todos.length; i++) {
      const todo = todos.get(i);

      const todoContainer = document.createElement("div");
      todoContainer.classList.add("todo_container");

      const todoText = document.createElement("div");
      todoText.classList.add("todo");
      todoText.innerHTML = todo.text;
      todoContainer.appendChild(todoText);

      todosContainer.appendChild(todoContainer);
    }
  }

  room.subscribe(todos, () => {
    renderTodos();
  });

  renderTodos();
}

run();
```

Finally, add a delete button for each todo and call [`LiveList.delete`][] to
remove a todo from the list by index.

```jsx highlight="48-54" file="src/App.js"
import { createClient, LiveList } from "@liveblocks/client";

const client = createClient({
  publicApiKey: "{{PUBLIC_KEY}}",
});

async function run() {
  const { room, leave } = client.enterRoom("javascript-todo-app", {
    initialPresence: { isTyping: false },
    initialStorage: { todos: new LiveList() },
  });

  const whoIsHere = document.getElementById("who_is_here");
  const todoInput = document.getElementById("todo_input");
  const someoneIsTyping = document.getElementById("someone_is_typing");
  const todosContainer = document.getElementById("todos_container");

  const { root } = await room.getStorage();

  let todos = root.get("todos");

  room.subscribe("others", (others) => {
    /* ... */
  });

  todoInput.addEventListener("keydown", (e) => {
    /* ... */
  });

  todoInput.addEventListener("blur", () => {
    /* ... */
  });

  function renderTodos() {
    todosContainer.innerHTML = "";

    for (let i = 0; i < todos.length; i++) {
      const todo = todos.get(i);

      const todoContainer = document.createElement("div");
      todoContainer.classList.add("todo_container");

      const todoText = document.createElement("div");
      todoText.classList.add("todo");
      todoText.innerHTML = todo.text;
      todoContainer.appendChild(todoText);

      const deleteButton = document.createElement("button");
      deleteButton.classList.add("delete_button");
      deleteButton.innerHTML = "âœ•";
      deleteButton.addEventListener("click", () => {
        todos.delete(i);
      });
      todoContainer.appendChild(deleteButton);

      todosContainer.appendChild(todoContainer);
    }
  }

  room.subscribe(todos, () => {
    renderTodos();
  });

  renderTodos();
}

run();
```

In this tutorial, we discovered whatâ€™s a room, how to connect and enter a room.
And how to use the roomâ€™s api to interact with its presence and storage.

You can see some stats about the room you created in your
[dashboard](https://liveblocks.io/dashboard/rooms).

<Figure>
  <Image
    src="/assets/tutorials/todo-list/tutorial-todo-list-dashboard.png"
    alt="Liveblocks dashboard"
    width={1380}
    height={778}
  />
</Figure>

## Next steps

- [API reference](/docs/api-reference/liveblocks-client)
- [Authentication](/docs/authentication)

[`@liveblocks/client`]: /docs/api-reference/liveblocks-client
[`client.enter`]: /docs/api-reference/liveblocks-client#Client.enter
[`createclient`]: /docs/api-reference/liveblocks-client#createClient
[`livelist.delete`]: /docs/api-reference/liveblocks-client#LiveList.delete
[`livelist.push`]: /docs/api-reference/liveblocks-client#LiveList.push
[`livelist`]: /docs/api-reference/liveblocks-client#LiveList
[`livemap`]: /docs/api-reference/liveblocks-client#LiveMap
[`liveobject`]: /docs/api-reference/liveblocks-client#LiveObject
[`room.subscribe("others")`]:
  /docs/api-reference/liveblocks-client#Room.subscribe.others
[`room.subscribe(todos)`]:
  /docs/api-reference/liveblocks-client#Room.subscribe(storageItem)
[`room.updatepresence`]:
  /docs/api-reference/liveblocks-client#Room.updatePresence

---
meta:
  title: "How to create a collaborative to-do list with React and Liveblocks"
  description: "Build a collaborative to-do list with React and Liveblocks"
---

In this 15-minute tutorial, weâ€™ll be building a collaborative to-do list using
React and Liveblocks. As users edit the list, changes will be automatically
synced and persisted, allowing for a list that updates in realtime across
clients. Users will also be able to see who else is currently online, and when
another user is typing.

<Figure>
  <video autoPlay loop muted playsInline>
    <source
      src="/assets/tutorials/todo-list/tutorial-todo-list-1.mp4"
      type="video/mp4"
    />
  </video>
</Figure>

This guide assumes that youâ€™re already familiar with React,
[Next.js](https://nextjs.org/) and
[TypeScript](https://www.typescriptlang.org/). If youâ€™re using a
state-management library such as Redux or Zustand, we recommend reading one of
our dedicated to-do list tutorials:

- [React + Redux tutorial](/docs/tutorials/collaborative-to-do-list/react-redux)
- [React + Zustand tutorial](/docs/tutorials/collaborative-to-do-list/react-zustand)

The source code for this guide is
[available on GitHub](https://github.com/liveblocks/liveblocks/tree/main/examples/nextjs-todo-list).

## Install Liveblocks into your project [#install-liveblocks]

### Install Liveblocks packages

Create a new app with [`create-next-app`](https://nextjs.org/docs):

```bash
npx create-next-app@latest next-todo-list --typescript
```

<Banner title="Next.js setup options">

For this tutorial, we wonâ€™t use the `src` directory or the experimental `app`
directory.

</Banner>

Then run the following command to install the Liveblocks packages:

```bash
npm install @liveblocks/client @liveblocks/react
```

## Join a Liveblocks room

Liveblocks uses the concept of rooms, separate virtual spaces where people
collaborate. To create a realtime experience, multiple users must be connected
to the same room. Create a file in the current directory within `/app`, and name
it `Room.tsx`. Pass the location of your endpoint to `LiveblocksProvider`.

```tsx file="/pages/index.tsx"
"use client";

import { ReactNode } from "react";
import {
  LiveblocksProvider,
  RoomProvider,
  ClientSideSuspense,
} from "@liveblocks/react/suspense";

export default function Page() {
  return (
    <LiveblocksProvider publicApiKey={"{{SECRET_KEY}}"}>
      <RoomProvider id="my-room">
        <ClientSideSuspense fallback={<div>Loadingâ€¦</div>}>
          <TodoList />
        </ClientSideSuspense>
      </RoomProvider>
    </LiveblocksProvider>
  );
}

function TodoList() {
  return (
    <div>
      {/* Weâ€™re starting to implement the to-do list in the next section */}
    </div>
  );
}
```

## Show whoâ€™s currently in the room [#who-is-here]

<Banner title="Need help troubleshooting presence?">

Try the [Liveblocks DevTools extension](/devtools) to inspect and debug your
collaborative experiences as you build them, in realtime.

</Banner>

Now that Liveblocks is set up, we can start using the hooks to display how many
users are currently online.

<figure className="relative my-10 overflow-hidden rounded-lg">
  <video autoPlay loop muted playsInline>
    <source
      src="/assets/tutorials/todo-list/tutorial-todo-list-2.mp4"
      type="video/mp4"
    />
  </video>
  <div className="shadow-thin-border-300 pointer-events-none absolute inset-0 rounded-lg" />
</figure>

Weâ€™ll be doing this by adding [`useOthers`][], a selector hook that provides us
information about which _other_ users are online.

[`useOthers`][] takes a selector function that receives an array, `others`,
containing information about each user. We can get the current user count from
the length of that array. Add the following code to `pages/index.tsx`, and open
your app in multiple windows to see it in action.

```tsx file="pages/index.tsx"
import {
  LiveblocksProvider,
  RoomProvider,
  ClientSideSuspense,
  useOthers,
} from "@liveblocks/react/suspense";

function WhoIsHere() {
  const userCount = useOthers((others) => others.length);

  return (
    <div className="who_is_here">There are {userCount} other users online</div>
  );
}

function TodoList() {
  return (
    <div className="container">
      <WhoIsHere />
    </div>
  );
}

/* Page */
```

_For a tidier UI, replace the content of `styles/globals.css` file with the
following css._

```css file="styles/globals.css" isCollapsed isCollapsable
body {
  background-color: rgb(243, 243, 243);
}

.container {
  display: flex;
  flex-direction: column;
  width: 100%;
  margin-left: auto;
  margin-right: auto;
  margin-top: 3rem;
  max-width: 28rem;
}

input {
  box-sizing: border-box;
  padding: 0.5rem 0.875rem;
  margin: 0.5rem 0;
  width: 100%;
  background-color: white;
  box-shadow:
    0 0 #000,
    0 0 #000,
    0 0 #000,
    0 0 #000,
    0 1px 2px 0 rgba(0, 0, 0, 0.05);
  border-radius: 0.5rem;
  color: black;
  border: 0 solid;
  font-size: 16px;
}

input:hover {
  box-shadow:
    0 0 #000,
    0 0 #000,
    0 0 #000,
    0 0 #000,
    0 1px 3px 0 rgba(0, 0, 0, 0.1),
    0 1px 2px 0 rgba(0, 0, 0, 0.06);
}

input:focus {
  outline: none;
}

.todo_container {
  display: flex;
  padding: 0.5rem 0.875rem;
  align-items: center;
  justify-content: space-between;
}

.todo {
  flex-grow: 1;
}

.delete_button {
  padding: 0;
  margin: 0;
  font-size: 16px;
  border: 0 solid;
  appearance: button;
  background-color: transparent;
}

.delete_button:focus {
  outline: none;
}

.who_is_here {
  align-self: flex-end;
  font-size: 11px;
  color: #aaa;
}

.someone_is_typing {
  position: absolute;
  font-size: 11px;
  color: #aaa;
}
```

## Show if someone is typing [#someone-is-typing]

Next, weâ€™ll add some code to show a message when another user is typing.

<Figure>
  <video autoPlay loop muted playsInline>
    <source
      src="/assets/tutorials/todo-list/tutorial-todo-list-3.mp4"
      type="video/mp4"
    />
  </video>
</Figure>

Any online user could start typing, and we need to keep track of this, so itâ€™s
best if each user holds their own `isTyping` property.

Luckily, Liveblocks uses the concept of _presence_ to handle these temporary
states. A userâ€™s presence can be used to represent the position of a cursor on
screen, the selected shape in a design tool, or in this case, if theyâ€™re
currently typing or not.

Letâ€™s define a new type `Presence` with the property `isTyping` in
`liveblocks.config.ts` to ensure all our presence hooks are typed properly.

```tsx file="liveblocks.config.ts"
declare global {
  interface Liveblocks {
    // +++
    Presence: { isTyping: boolean };
    // +++
  }
}
```

We can then call [`useUpdateMyPresence`][] whenever we wish to update the userâ€™s
current presence, in this case whether theyâ€™re typing or not.

```tsx file="pages/index.tsx"
import {
  LiveblocksProvider,
  RoomProvider,
  ClientSideSuspense,
  useOthers,
  useUpdateMyPresence,
} from "@liveblocks/react/suspense";
import { useState } from "react";

/* WhoIsHere */

function TodoList() {
  const [draft, setDraft] = useState("");
  const updateMyPresence = useUpdateMyPresence();

  return (
    <div className="container">
      <WhoIsHere />
      <input
        type="text"
        placeholder="What needs to be done?"
        value={draft}
        onChange={(e) => {
          setDraft(e.target.value);
          updateMyPresence({ isTyping: true });
        }}
        onKeyDown={(e) => {
          if (e.key === "Enter") {
            updateMyPresence({ isTyping: false });
            setDraft("");
          }
        }}
        onBlur={() => updateMyPresence({ isTyping: false })}
      />
    </div>
  );
}

/* Page */
```

Now that weâ€™re keeping track of everyoneâ€™s state, we can create a new component
called `SomeoneIsTyping`, and use this to display a message whilst anyone else
is typing. To check if anyone is typing, weâ€™re iterating through `others` and
returning true if `isTyping` is true for any user.

```tsx file="pages/index.tsx"
import {
  LiveblocksProvider,
  RoomProvider,
  ClientSideSuspense,
  useOthers,
  useUpdateMyPresence,
} from "@liveblocks/react/suspense";
import { useState } from "react";

/* WhoIsHere */

function SomeoneIsTyping() {
  const someoneIsTyping = useOthers((others) =>
    others.some((other) => other.presence.isTyping)
  );

  return (
    <div className="someone_is_typing">
      {someoneIsTyping ? "Someone is typing..." : ""}
    </div>
  );
}

function TodoList() {
  const [draft, setDraft] = useState("");
  const updateMyPresence = useUpdateMyPresence();

  return (
    <div className="container">
      <WhoIsHere />
      <input {/* ... */ } />
      <SomeoneIsTyping />
    </div>
  );
}

/* Page */
```

We also need to make sure that we pass an `initialPresence` for `isTyping` to
`RoomProvider`.

```tsx file="pages/index.tsx"
/* WhoIsHere */
/* SomeoneIsTyping */
/* TodoList */

export default function Page() {
  return (
    <LiveblocksProvider publicApiKey={"{{SECRET_KEY}}"}>
      // +++
      <RoomProvider id="my-room" initialPresence={{ isTyping: false }}>
        // +++
        <ClientSideSuspense fallback={<div>Loadingâ€¦</div>}>
          <ToDoList />
        </ClientSideSuspense>
      </RoomProvider>
    </LiveblocksProvider>
  );
}
```

## Sync and persist to-dos [#add-liveblocks-storage]

<Banner title="Need help troubleshooting storage?">

Try the [Liveblocks DevTools extension](/devtools) to inspect and debug your
collaborative experiences as you build them, in realtime.

</Banner>

To-do list items will be stored even after all users disconnect, so we wonâ€™t be
using presence to store these values. For this, we need something new.

<Figure>
  <video autoPlay loop muted playsInline>
    <source
      src="/assets/tutorials/todo-list/tutorial-todo-list-1.mp4"
      type="video/mp4"
    />
  </video>
</Figure>

Weâ€™re going to use a [`LiveList`][] to store the list of todos inside the roomâ€™s
storage, a type of storage that Liveblocks provides. A `LiveList` is similar to
a JavaScript array, but its items are synced in realtime across different
clients. Even if multiple users insert, delete, or move items simultaneously,
the `LiveList` will still be consistent for all users in the room.

First, let's declare a new type `Storage` in `liveblocks.config.ts`, like we did
for `Presence`. This will ensure that our storage hooks are properly typed.

```tsx file="liveblocks.config.ts"
import { LiveList } from "@liveblocks/client";

declare global {
  interface Liveblocks {
    Presence: { isTyping: boolean };

    // +++
    Storage: {
      todos: LiveList<{ text: string }>;
    };
    // +++
  }
}
```

Go back to `Page` to initialize the storage with the `initialStorage` prop on
the `RoomProvider`.

```tsx highlight="3,14" file="pages/index.tsx"
/* ... */

import { LiveList } from "@liveblocks/client";

/* WhoIsHere */
/* SomeoneIsTyping */
/* TodoList */

export default function Page() {
  return (
    <LiveblocksProvider publicApiKey={"{{SECRET_KEY}}"}>
      <RoomProvider
        id="my-room"
        initialPresence={{ isTyping: false }}
        // +++
        initialStorage={{ todos: new LiveList() }}
        // +++
      >
        <ClientSideSuspense fallback={<div>Loadingâ€¦</div>}>
          <ToDoList />
        </ClientSideSuspense>
      </RoomProvider>
    </LiveblocksProvider>
  );
}
```

### Accessing storage [#accessing-liveblocks-storage]

Weâ€™re going to use the [`useStorage`][] hook to get the list of todos previously
created.

`useStorage` allows us to select part of the storage from the `root` level. We
can find our `todos` `LiveList` at `root.todos`, and we can map through our list
to display each item.

```tsx file="pages/index.tsx"
import {
  LiveblocksProvider,
  RoomProvider,
  ClientSideSuspense,
  useOthers,
  useUpdateMyPresence,
  useStorage,
} from "@liveblocks/react/suspense";
import { LiveList } from "@liveblocks/client";
import { useState } from "react";

/* WhoIsHere */
/* SomeoneIsTyping */

function TodoList() {
  const [draft, setDraft] = useState("");
  const updateMyPresence = useUpdateMyPresence();
  const todos = useStorage((root) => root.todos);

  return (
    <div className="container">
      <WhoIsHere />
      <input
        {/* ... */}
        onKeyDown={(e) => {
          if (e.key === "Enter") {
            updateMyPresence({ isTyping: false });
            setDraft("");
          }
        }}
      />
      <SomeoneIsTyping />
      {todos.map((todo, index) => {
        return (
          <div key={index} className="todo_container">
            <div className="todo">{todo.text}</div>
            <button
              className="delete_button"
            >
              âœ•
            </button>
          </div>
        );
      })}
    </div>
  );
}

/* Page */
```

### Setting storage [#setting-liveblocks-storage]

To modify the list, we can use the [`useMutation`][] hook. This is a hook that
works similarly to `useCallback`, with a dependency array, allowing you to
create a reusable storage mutation.

`useMutation` gives you access to the storage root, a [`LiveObject`][]. From
here we can use [`LiveObject.get`][] to retrieve the `todos` list, then use
[`LiveList.push`][] and [`LiveList.delete`][] to modify our todo list. These
functions are then passed into the appropriate events.

```tsx file="pages/index.tsx"
import {
  LiveblocksProvider,
  RoomProvider,
  ClientSideSuspense,
  useOthers,
  useUpdateMyPresence,
  useStorage,
  useMutation,
} from "@liveblocks/react/suspense";
import { LiveList } from "@liveblocks/client";
import { useState } from "react";

/* WhoIsHere */
/* SomeoneIsTyping */

export default function TodoList() {
  const [draft, setDraft] = useState("");
  const updateMyPresence = useUpdateMyPresence();
  const todos = useStorage((root) => root.todos);

  const addTodo = useMutation(({ storage }, text) => {
    storage.get("todos").push({ text })
  }, []);

  const deleteTodo = useMutation(({ storage }, index) => {
    storage.get("todos").delete(index);
  }, []);

  return (
    <div className="container">
      <WhoIsHere />
      <input
        {/* ... */}

        onKeyDown={(e) => {
          if (e.key === "Enter") {
            updateMyPresence({ isTyping: false });
            addTodo(draft);
            setDraft("");
          }
        }}
      />
      <SomeoneIsTyping />
      {todos.map((todo, index) => {
        return (
          <div key={index} className="todo_container">
            <div className="todo">{todo.text}</div>

            <button
              className="delete_button"
              onClick={() => deleteTodo(index)}
            >
              âœ•
            </button>

          </div>
        );
      })}
    </div>
  );
}

/* Page */
```

VoilÃ ! We have a working collaborative to-do list, with persistent data storage.

## Summary

In this tutorial, weâ€™ve learnt about the concept of rooms, presence, and others.
Weâ€™ve also learnt how to put all these into practice, and how to persist state
using storage too.

You can see some stats about the room you created in your
[dashboard](https://liveblocks.io/dashboard/rooms).

<Figure>
  <Image
    src="/assets/tutorials/todo-list/tutorial-todo-list-dashboard.png"
    alt="Liveblocks dashboard"
    width={1380}
    height={778}
  />
</Figure>

## Next steps

- [API reference](/docs/api-reference/liveblocks-react)
- [Authentication](/docs/authentication)

[`livelist.delete`]: /docs/api-reference/liveblocks-client#LiveList.delete
[`livelist.push`]: /docs/api-reference/liveblocks-client#LiveList.push
[`livelist`]: /docs/api-reference/liveblocks-client#LiveList
[`liveobject.get`]: /docs/api-reference/liveblocks-client#LiveList.push
[`liveobject`]: /docs/api-reference/liveblocks-client#LiveList.push
[`roomprovider`]: /docs/api-reference/liveblocks-react#RoomProvider
[`create-react-app`]: https://create-react-app.dev/
[`createroomcontext`]: /docs/api-reference/liveblocks-react#createRoomContext
[`useothers`]: /docs/api-reference/liveblocks-react#useOthers
[`useupdatemypresence`]:
  /docs/api-reference/liveblocks-react#useUpdateMyPresence
[`usestorage`]: /docs/api-reference/liveblocks-react#useStorage
[`usemutation`]: /docs/api-reference/liveblocks-react#useMutation

---
meta:
  title:
    "How to create a collaborative to-do list with React, Redux, and Liveblocks"
  description:
    "Build a collaborative to-do list with React, Redux, and Liveblocks"
---

In this 15-minute tutorial, weâ€™ll be building a collaborative to-do list using
React, [Redux](https://redux.js.org/), and Liveblocks. As users edit the list,
changes will be automatically synced and persisted, allowing for a list that
updates in realtime across clients. Users will also be able to see who else is
currently online, and when another user is typing.

<Figure>
  <video autoPlay loop muted playsInline>
    <source
      src="/assets/tutorials/todo-list/tutorial-todo-list-1.mp4"
      type="video/mp4"
    />
  </video>
</Figure>

This guide assumes that youâ€™re already familiar with
[React](https://reactjs.org/) and [Redux](https://redux.js.org/). If youâ€™re not
using Redux, we recommend reading one of our dedicated to-do list tutorials:

- [React tutorial](/docs/tutorials/collaborative-to-do-list/react)
- [React + Zustand tutorial](/docs/tutorials/collaborative-to-do-list/react-zustand)

The source code for this guide is
[available on github](https://github.com/liveblocks/liveblocks/tree/main/examples/redux-todo-list).

## Install Liveblocks into your project [#install-liveblocks]

### Install Liveblocks packages

First, we need to create a new app with
[`create-react-app`](https://create-react-app.dev/):

```bash
npx create-react-app redux-todo-app
```

Then run the following command to install the Liveblocks packages and Redux:

```bash
npm install redux react-redux @reduxjs/toolkit @liveblocks/client @liveblocks/redux
```

[`@liveblocks/client`](/docs/api-reference/liveblocks-client) lets you interact
with Liveblocks servers.
[`@liveblocks/redux`](/docs/api-reference/liveblocks-redux) contains a
Liveblocks enhancer for a redux store.

### Connect to Liveblocks servers [#connect-liveblocks-servers]

In order to use Liveblocks, weâ€™ll need to sign up and get an API key.
[Create an account](/auth/signup), then navigate to
[the dashboard](/dashboard/apikeys) to find your public key (it starts with
`pk_`).

<Banner title="Public vs secret key">

With a secret key, you can control who can access the room. itâ€™s more secure but
you need your own back-end endpoint. For this tutorial, weâ€™ll go with a public
key. For more info, see the [authentication guide](/docs/authentication).

</Banner>

Create a new file `src/store.js` and initialize the Liveblocks client with your
public API key. Then add our
[enhancer](/docs/api-reference/liveblocks-redux#enhancer) to your store
configuration.

```js file="src/store.js"
import { createClient } from "@liveblocks/client";
import { liveblocksEnhancer } from "@liveblocks/redux";
import { configureStore, createSlice } from "@reduxjs/toolkit";

const client = createClient({
  publicApiKey: "{{PUBLIC_KEY}}",
});

const initialState = {};

const slice = createSlice({
  name: "state",
  initialState,
  reducers: {
    /* logic will be added here */
  },
});

export function makeStore() {
  return configureStore({
    reducer: slice.reducer,
    enhancers: (getDefaultEnhancers) =>
      getDefaultEnhancers().concat(liveblocksEnhancer({ client })),
  });
}

const store = makeStore();

export default store;
```

We need to edit `src/index.js` to add the react-redux provider:

```js highlight="6,7,11,13" file="src/index.js"
import React from "react";
import ReactDOM from "react-dom";
import "./index.css";
import App from "./App";

import { Provider } from "react-redux";
import store from "./store";

ReactDOM.render(
  <React.StrictMode>
    <Provider store={store}>
      <App />
    </Provider>
  </React.StrictMode>,
  document.getElementById("root")
);
```

### Connect to a Liveblocks room [#connect-liveblocks-room]

Liveblocks uses the concept of _rooms_, separate virtual spaces where people can
collaborate. To create a multiplayer experience, multiple users must be
connected to the same room.

We are going to dispatch the actions provided by `@liveblocks/redux` to
[`enter`](/docs/api-reference/liveblocks-redux#actions-enter) and
[`leave`](/docs/api-reference/liveblocks-redux#actions-leave) the room.

In our main component, we want to connect to the Liveblocks room when the
component does mount, and leave the room when it unmounts.

```js file="src/App.js"
import React, { useEffect } from "react";
import { useDispatch } from "react-redux";
import { actions } from "@liveblocks/redux";

import "./App.css";

export default function App() {
  const dispatch = useDispatch();

  useEffect(() => {
    dispatch(actions.enterRoom("redux-demo-room"));

    return () => {
      dispatch(actions.leaveRoom("redux-demo-room"));
    };
  }, [dispatch]);

  return <div className="container">To-do list app</div>;
}
```

## Show whoâ€™s currently in the room [#who-is-here]

<Banner title="Need help troubleshooting presence?">

Try the [Liveblocks DevTools extension](/devtools) to inspect and debug your
collaborative experiences as you build them, in realtime.

</Banner>

Now that Liveblocks is set up, we can start updating our code to display how
many users are currently online.

<Figure>
  <video autoPlay loop muted playsInline>
    <source
      src="/assets/tutorials/todo-list/tutorial-todo-list-2.mp4"
      type="video/mp4"
    />
  </video>
</Figure>

Weâ€™ll be doing this by using the injected object
[`liveblocks.others`](/docs/api-reference/liveblocks-redux#liveblocks-state-others)
to show whoâ€™s currently inside the room.

```js highlight="2,7-17,35-37" file="src/App.js"
import React, { useEffect } from "react";
import { useDispatch, useSelector } from "react-redux";
import { actions } from "@liveblocks/redux";

import "./App.css";

function WhoIsHere() {
  const othersUsersCount = useSelector(
    (state) => state.liveblocks.others.length
  );

  return (
    <div className="who_is_here">
      There are {othersUsersCount} other users online
    </div>
  );
}

export default function App() {
  const dispatch = useDispatch();

  useEffect(() => {
    dispatch(actions.enterRoom("redux-demo-room"));

    return () => {
      dispatch(actions.leaveRoom("redux-demo-room"));
    };
  }, [dispatch]);

  return (
    <div className="container">
      <WhoIsHere />
    </div>
  );
}
```

_For a tidier look, here's some styling to place within `src/App.css`._

```css file="src/App.css" isCollapsed isCollapsable
body {
  background-color: rgb(243, 243, 243);
}

.container {
  display: flex;
  flex-direction: column;
  width: 100%;
  margin-left: auto;
  margin-right: auto;
  margin-top: 3rem;
  max-width: 28rem;
}

input {
  box-sizing: border-box;
  padding: 0.5rem 0.875rem;
  margin: 0.5rem 0;
  width: 100%;
  background-color: white;
  box-shadow:
    0 0 #000,
    0 0 #000,
    0 0 #000,
    0 0 #000,
    0 1px 2px 0 rgba(0, 0, 0, 0.05);
  border-radius: 0.5rem;
  color: black;
  border: 0 solid;
  font-size: 16px;
}

input:hover {
  box-shadow:
    0 0 #000,
    0 0 #000,
    0 0 #000,
    0 0 #000,
    0 1px 3px 0 rgba(0, 0, 0, 0.1),
    0 1px 2px 0 rgba(0, 0, 0, 0.06);
}

input:focus {
  outline: none;
}

.todo_container {
  display: flex;
  padding: 0.5rem 0.875rem;
  align-items: center;
  justify-content: space-between;
}

.todo {
  flex-grow: 1;
}

.delete_button {
  padding: 0;
  margin: 0;
  font-size: 16px;
  border: 0 solid;
  appearance: button;
  background-color: transparent;
}

.delete_button:focus {
  outline: none;
}

.who_is_here {
  align-self: flex-end;
  font-size: 11px;
  color: #aaa;
}

.someone_is_typing {
  position: absolute;
  font-size: 11px;
  color: #aaa;
}
```

## Show if someone is typing [#someone-is-typing]

Next, we'll add some code to show a message when another user is typing.

<Figure>
  <video autoPlay loop muted playsInline>
    <source
      src="/assets/tutorials/todo-list/tutorial-todo-list-3.mp4"
      type="video/mp4"
    />
  </video>
</Figure>

Any online user could start typing, and we need to keep track of this, so it's
best if each user holds their own `isTyping` property.

Luckily, Liveblocks uses the concept of presence to handle these temporary
states. A user's presence can be used to represent the position of a cursor on
screen, the selected shape in a design tool, or in this case, if they're
currently typing or not.

We want to add some data to our redux store, `draft` will contain the value of
the input. `isTyping` will be set when the user is writing a draft.

The enhancer option
[`presenceMapping: { isTyping: true }`](/docs/api-reference/liveblocks-redux#enhancer-option-presence-mapping)
means that we want to automatically sync the part of the state named `isTyping`
to Liveblocks Presence.

```js highlight="10-11,18-21,25,34" file="src/store.js"
import { createClient } from "@liveblocks/client";
import { liveblocksEnhancer } from "@liveblocks/redux";
import { configureStore, createSlice } from "@reduxjs/toolkit";

const client = createClient({
  publicApiKey: "{{PUBLIC_KEY}}",
});

const initialState = {
  draft: "",
  isTyping: false,
};

const slice = createSlice({
  name: "state",
  initialState,
  reducers: {
    setDraft: (state, action) => {
      state.isTyping = action.payload === "" ? false : true;
      state.draft = action.payload;
    },
  },
});

export const { setDraft } = slice.actions;

export function makeStore() {
  return configureStore({
    reducer: slice.reducer,
    enhancers: (getDefaultEnhancers) =>
      getDefaultEnhancers().concat(
        liveblocksEnhancer({
          client,
          presenceMapping: { isTyping: true },
        })
      ),
  });
}

const store = makeStore();

export default store;
```

Now that we set the `isTyping` state when necessary, let's create a new
component called `SomeoneIsTyping` to display a message when at least one other
user has `isTyping` equals to `true`.

```js highlight="5,11-19,22,40-47" file="src/App.js"
import React, { useEffect } from "react";
import { useDispatch, useSelector } from "react-redux";
import { actions } from "@liveblocks/redux";

import { setDraft } from "./store";

import "./App.css";

/* WhoIsHere */

function SomeoneIsTyping() {
  const someoneIsTyping = useSelector((state) =>
    state.liveblocks.others.some((user) => user.presence?.isTyping)
  );

  return someoneIsTyping ? (
    <div className="someone_is_typing">Someone is typing</div>
  ) : null;
}

export default function App() {
  const draft = useSelector((state) => state.draft);
  const dispatch = useDispatch();

  useEffect(() => {
    dispatch(actions.enterRoom("redux-demo-room"));

    return () => {
      dispatch(actions.leaveRoom("redux-demo-room"));
    };
  }, [dispatch]);

  return (
    <div className="container">
      <WhoIsHere />
      <input
        className="input"
        type="text"
        placeholder="What needs to be done?"
        value={draft}
        onChange={(e) => dispatch(setDraft(e.target.value))}
      ></input>
      <SomeoneIsTyping />
    </div>
  );
}
```

## Sync and persist to-dos [#add-liveblocks-storage]

<Banner title="Need help troubleshooting storage?">

Try the [Liveblocks DevTools extension](/devtools) to inspect and debug your
collaborative experiences as you build them, in realtime.

</Banner>

To-do list items will be stored even after all users disconnect, so we won't be
using presence to store these values. For this, we need something new.

<Figure>
  <video autoPlay loop muted playsInline>
    <source
      src="/assets/tutorials/todo-list/tutorial-todo-list-1.mp4"
      type="video/mp4"
    />
  </video>
</Figure>

Add an array of todos to your redux store, and tell the enhancer to sync and
persist them with Liveblocks.

To achieve that, we are going to use the enhancer option
[`storageMapping: { todos: true }`](/docs/api-reference/liveblocks-redux#enhancer-option-storage-mapping).
It means that the part of the state named `todos` will be synced with Liveblocks
Storage.

```js highlight="10,23-30,34,43" file="src/store.js"
import { createClient } from "@liveblocks/client";
import { liveblocksEnhancer } from "@liveblocks/redux";
import { configureStore, createSlice } from "@reduxjs/toolkit";

const client = createClient({
  publicApiKey: "{{PUBLIC_KEY}}",
});

const initialState = {
  todos: [],
  draft: "",
  isTyping: false,
};

const slice = createSlice({
  name: "state",
  initialState,
  reducers: {
    setDraft: (state, action) => {
      state.isTyping = action.payload === "" ? false : true;
      state.draft = action.payload;
    },
    addTodo: (state) => {
      state.isTyping = false;
      state.todos.push({ text: state.draft });
      state.draft = "";
    },
    deleteTodo: (state, action) => {
      state.todos.splice(action.payload, 1);
    },
  },
});

export const { setDraft, addTodo, deleteTodo } = slice.actions;

export function makeStore() {
  return configureStore({
    reducer: slice.reducer,
    enhancers: (getDefaultEnhancers) =>
      getDefaultEnhancers().concat(
        liveblocksEnhancer({
          client,
          storageMapping: { todos: true },
          presenceMapping: { isTyping: true },
        })
      ),
  });
}

const store = makeStore();

export default store;
```

We can display the list of todos and use the actions `addTodo` and `deleteTodo`
to update our list:

```js highlight="5,13,38-41,45-57" file="src/App.js"
import React, { useEffect } from "react";
import { useDispatch, useSelector } from "react-redux";
import { actions } from "@liveblocks/redux";

import { setDraft, addTodo, deleteTodo } from "./store";

import "./App.css";

/* WhoIsHere */
/* SomeoneIsTyping */

export default function App() {
  const todos = useSelector((state) => state.todos);
  const draft = useSelector((state) => state.draft);
  const dispatch = useDispatch();

  useEffect(() => {
    dispatch(actions.enterRoom("redux-demo-room"));

    return () => {
      dispatch(actions.leaveRoom("redux-demo-room"));
    };
  }, [dispatch]);

  return (
    <div className="container">
      <WhoIsHere />
      <input
        className="input"
        type="text"
        placeholder="What needs to be done?"
        value={draft}
        onChange={(e) => dispatch(setDraft(e.target.value))}
        onKeyDown={(e) => {
          if (e.key === "Enter") {
            dispatch(addTodo());
          }
        }}
      ></input>
      <SomeoneIsTyping />
      {todos.map((todo, index) => {
        return (
          <div className="todo_container" key={index}>
            <div className="todo">{todo.text}</div>
            <button
              className="delete_button"
              onClick={() => dispatch(deleteTodo(index))}
            >
              âœ•
            </button>
          </div>
        );
      })}
    </div>
  );
}
```

VoilÃ ! We have a working collaborative to-do list, with persistent data storage.

## Summary

In this tutorial, weâ€™ve learnt about the concept of rooms, presence, and others.
We've also learnt how to put all these into practice, and how to persist state
using storage too.

You can see some stats about the room you created in your
[dashboard](https://liveblocks.io/dashboard/rooms).

<Figure>
  <Image
    src="/assets/tutorials/todo-list/tutorial-todo-list-dashboard.png"
    alt="Liveblocks dashboard"
    width={1380}
    height={778}
  />
</Figure>

## Next steps

- [API reference](/docs/api-reference/liveblocks-redux)
- [Authentication](/docs/authentication)

---
meta:
  title:
    "How to create a collaborative to-do list with React, Zustand, and
    Liveblocks"
  description:
    "Build a collaborative to-do list with React, Zustand, and Liveblocks"
---

In this 15-minute tutorial, weâ€™ll be building a collaborative to-do list using
React, [Zustand](https://github.com/pmndrs/zustand), and Liveblocks. As users
edit the list, changes will be automatically synced and persisted, allowing for
a list that updates in realtime across clients. Users will also be able to see
who else is currently online, and when another user is typing.

<Figure>
  <video autoPlay loop muted playsInline>
    <source
      src="/assets/tutorials/todo-list/tutorial-todo-list-1.mp4"
      type="video/mp4"
    />
  </video>
</Figure>

This guide assumes that youâ€™re already familiar with
[React](https://reactjs.org/) and [Zustand](https://github.com/pmndrs/zustand).
If youâ€™re not using Zustand, we recommend reading one of our dedicated to-do
list tutorials:

- [React tutorial](/docs/tutorials/collaborative-to-do-list/react)
- [React + Redux tutorial](/docs/tutorials/collaborative-to-do-list/react-redux)

The source code for this guide is
[available on github](https://github.com/liveblocks/liveblocks/tree/main/examples/zustand-todo-list).

## Install Liveblocks into your project [#install-liveblocks]

### Install Liveblocks packages

First, we need to create a new app with
[`create-react-app`](https://create-react-app.dev/):

```bash
npx create-react-app zustand-todo-app --template typescript
```

To start a plain JavaScript project, you can omit the `--template typescript`
flag.

Then install the Liveblocks packages and Zustand:

```bash
npm install zustand @liveblocks/client @liveblocks/zustand
```

[`@liveblocks/client`](/docs/api-reference/liveblocks-client) lets you interact
with Liveblocks servers.
[`@liveblocks/zustand`](/docs/api-reference/liveblocks-zustand) contains a
middleware for Zustand.

### Connect to Liveblocks servers [#connect-liveblocks-servers]

In order to use Liveblocks, weâ€™ll need to sign up and get an API key.
[Create an account](/auth/signup), then navigate to
[the dashboard](/dashboard/apikeys) to find your public key (it starts with
`pk_`).

<Banner title="Public vs secret key">

With a secret key, you can control who can access the room. itâ€™s more secure but
you need your own back-end endpoint. For this tutorial, weâ€™ll go with a public
key. For more info, see the [authentication guide](/docs/authentication).

</Banner>

Create a new file `src/store.ts` and initialize the Liveblocks client with your
public API key. Then add our
[liveblocks](/docs/api-reference/liveblocks-zustand#liveblocks) to your store
configuration.

```ts file="src/store.ts"
import create from "zustand";
import { createClient } from "@liveblocks/client";
import { liveblocks } from "@liveblocks/zustand";
import type { WithLiveblocks } from "@liveblocks/zustand";

type State = {
  // Your Zustand state type will be defined here
};

const client = createClient({
  publicApiKey: "{{PUBLIC_KEY}}",
});

const useStore = create<WithLiveblocks<State>>()(
  liveblocks(
    (set) => ({
      // Your state and actions will go here
    }),
    { client }
  )
);

export default useStore;
```

### Connect to a Liveblocks room [#connect-liveblocks-room]

Liveblocks uses the concept of _rooms_, separate virtual spaces where people can
collaborate. To create a collaborative experience, multiple users must be
connected to the same room.

Our middleware injected the object `liveblocks` to the store. Inside that
object, the first methods that we are going to use are
[`enterRoom`](/docs/api-reference/liveblocks-zustand#liveblocks-state-enter-room)
and
[`leaveRoom`](/docs/api-reference/liveblocks-zustand#liveblocks-state-leave-room).

In our main component, we want to connect to the Liveblocks room when the
component does mount, and leave the room when it unmounts.

```tsx file="src/App.tsx"
import React, { useEffect } from "react";
import useStore from "./store";

import "./App.css";

export default function App() {
  const {
    liveblocks: { enterRoom, leaveRoom },
  } = useStore();

  useEffect(() => {
    enterRoom("zustand-todo-app");
    return () => {
      leaveRoom("zustand-todo-app");
    };
  }, [enterRoom, leaveRoom]);

  return <div className="container">To-do list app</div>;
}
```

## Show whoâ€™s currently in the room [#who-is-here]

<Banner title="Need help troubleshooting presence?">

Try the [Liveblocks DevTools extension](/devtools) to inspect and debug your
collaborative experiences as you build them, in realtime.

</Banner>

Now that Liveblocks is set up, weâ€™re going to use the injected object
[`liveblocks.others`](/docs/api-reference/liveblocks-zustand#liveblocks-state-others)
to show whoâ€™s currently inside the room.

<Figure>
  <video autoPlay loop muted playsInline>
    <source
      src="/assets/tutorials/todo-list/tutorial-todo-list-2.mp4"
      type="video/mp4"
    />
  </video>
</Figure>

```tsx highlight="6-14,30" file="src/App.tsx"
import React, { useEffect } from "react";
import useStore from "./store";

import "./App.css";

function WhoIsHere() {
  const othersUsersCount = useStore((state) => state.liveblocks.others.length);

  return (
    <div className="who_is_here">
      There are {othersUsersCount} other users online
    </div>
  );
}

export default function App() {
  const {
    liveblocks: { enterRoom, leaveRoom },
  } = useStore();

  useEffect(() => {
    enterRoom("zustand-todo-app");
    return () => {
      leaveRoom("zustand-todo-app");
    };
  }, [enterRoom, leaveRoom]);

  return (
    <div className="container">
      <WhoIsHere />
    </div>
  );
}
```

_For a tidier look, here's some styling to place within `src/App.css`._

```css file="src/App.css" isCollapsed isCollapsable
body {
  background-color: rgb(243, 243, 243);
}

.container {
  display: flex;
  flex-direction: column;
  width: 100%;
  margin-left: auto;
  margin-right: auto;
  margin-top: 3rem;
  max-width: 28rem;
}

input {
  box-sizing: border-box;
  padding: 0.5rem 0.875rem;
  margin: 0.5rem 0;
  width: 100%;
  background-color: white;
  box-shadow:
    0 0 #000,
    0 0 #000,
    0 0 #000,
    0 0 #000,
    0 1px 2px 0 rgba(0, 0, 0, 0.05);
  border-radius: 0.5rem;
  color: black;
  border: 0 solid;
  font-size: 16px;
}

input:hover {
  box-shadow:
    0 0 #000,
    0 0 #000,
    0 0 #000,
    0 0 #000,
    0 1px 3px 0 rgba(0, 0, 0, 0.1),
    0 1px 2px 0 rgba(0, 0, 0, 0.06);
}

input:focus {
  outline: none;
}

.todo_container {
  display: flex;
  padding: 0.5rem 0.875rem;
  align-items: center;
  justify-content: space-between;
}

.todo {
  flex-grow: 1;
}

.delete_button {
  padding: 0;
  margin: 0;
  font-size: 16px;
  border: 0 solid;
  appearance: button;
  background-color: transparent;
}

.delete_button:focus {
  outline: none;
}

.who_is_here {
  align-self: flex-end;
  font-size: 11px;
  color: #aaa;
}

.someone_is_typing {
  position: absolute;
  font-size: 11px;
  color: #aaa;
}
```

## Show if someone is typing [#someone-is-typing]

Next, we'll add some code to show a message when another user is typing.

<Figure>
  <video autoPlay loop muted playsInline>
    <source
      src="/assets/tutorials/todo-list/tutorial-todo-list-3.mp4"
      type="video/mp4"
    />
  </video>
</Figure>

Any online user could start typing, and we need to keep track of this, so it's
best if each user holds their own `isTyping` property.

Luckily, Liveblocks uses the concept of presence to handle these temporary
states. A user's presence can be used to represent the position of a cursor on
screen, the selected shape in a design tool, or in this case, if they're
currently typing or not.

We want to add some data to our Zustand store, `draft` will contain the value of
the input. `isTyping` will be set when the user is writing a draft.

The middleware option
[`presenceMapping: { isTyping: true }`](/docs/api-reference/liveblocks-zustand#middleware-option-presence-mapping)
means that we want to automatically sync the part of the state named `isTyping`
to Liveblocks Presence.

```ts highlight="7-9,19-21,25" file="src/store.ts"
import create from "zustand";
import { createClient } from "@liveblocks/client";
import { liveblocks } from "@liveblocks/zustand";
import type { WithLiveblocks } from "@liveblocks/zustand";

type State = {
  draft: string;
  isTyping: boolean;
  setDraft: (draft: string) => void;
};

const client = createClient({
  publicApiKey: "{{PUBLIC_KEY}}",
});

const useStore = create<WithLiveblocks<State>>()(
  liveblocks(
    (set) => ({
      draft: "",
      isTyping: false,
      setDraft: (draft) => set({ draft, isTyping: draft !== "" }),
    }),
    {
      client,
      presenceMapping: { isTyping: true },
    }
  )
);

export default useStore;
```

Now that we set the `isTyping` state when necessary, create a new component
called `SomeoneIsTyping` to display a message when at least one other user has
`isTyping` equals to `true`.

```tsx highlight="8-16,20-21,35-42" file="src/App.tsx"
import React, { useEffect } from "react";
import useStore from "./store";

import "./App.css";

/* WhoIsHere */

function SomeoneIsTyping() {
  const others = useStore((state) => state.liveblocks.others);

  const someoneIsTyping = others.some((user) => user.presence.isTyping);

  return someoneIsTyping ? (
    <div className="someone_is_typing">Someone is typing</div>
  ) : null;
}

export default function App() {
  const {
    draft,
    setDraft,
    liveblocks: { enterRoom, leaveRoom },
  } = useStore();

  useEffect(() => {
    enterRoom("zustand-todo-app");
    return () => {
      leaveRoom("zustand-todo-app");
    };
  }, [enterRoom, leaveRoom]);

  return (
    <div className="container">
      <WhoIsHere />
      <input
        className="input"
        type="text"
        placeholder="What needs to be done?"
        value={draft}
        onChange={(e) => setDraft(e.target.value)}
      ></input>
      <SomeoneIsTyping />
    </div>
  );
}
```

## Sync and persist to-dos [#add-liveblocks-storage]

<Banner title="Need help troubleshooting storage?">

Try the [Liveblocks DevTools extension](/devtools) to inspect and debug your
collaborative experiences as you build them, in realtime.

</Banner>

To-do list items will be stored even after all users disconnect, so we won't be
using presence to store these values. For this, we need something new.

<Figure>
  <video autoPlay loop muted playsInline>
    <source
      src="/assets/tutorials/todo-list/tutorial-todo-list-1.mp4"
      type="video/mp4"
    />
  </video>
</Figure>

Add an array of todos to your Zustand store, and tell the middleware to sync and
persist them with Liveblocks.

To achieve that, we are going to use the middleware option
[`storageMapping: { todos: true }`](/docs/api-reference/liveblocks-zustand#middleware-option-storage-mapping).
It means that the part of the state named `todos` should be automatically synced
with Liveblocks Storage.

```ts highlight="6,8-9,19,21-29,34" file="src/store.ts"
/* ... */

type State = {
  draft: string;
  isTyping: boolean;
  todos: { text: string }[];
  setDraft: (draft: string) => void;
  addTodo: () => void;
  deleteTodo: (index: number) => void;
};

/* ... */

const useStore = create<WithLiveblocks<State>>()(
  liveblocks(
    (set) => ({
      draft: "",
      isTyping: false,
      todos: [],
      setDraft: (draft) => set({ draft, isTyping: draft !== "" }),
      addTodo: () =>
        set((state) => ({
          todos: state.todos.concat({ text: state.draft }),
          draft: "",
        })),
      deleteTodo: (index) =>
        set((state) => ({
          todos: state.todos.filter((_, i) => index !== i),
        })),
    }),
    {
      client,
      presenceMapping: { isTyping: true },
      storageMapping: { todos: true },
    }
  )
);

export default useStore;
```

We can display the list of todos and use the functions `addTodo` and
`deleteTodo` to update our list:

```tsx highlight="13-15,39-43,46-60" file="src/App.tsx"
import React, { useEffect } from "react";
import useStore from "./store";

import "./App.css";

/* WhoIsHere */
/* SomeoneIsTyping */

export default function App() {
  const {
    draft,
    setDraft,
    todos,
    addTodo,
    deleteTodo,
    liveblocks: { enterRoom, leaveRoom, isStorageLoading },
  } = useStore();

  useEffect(() => {
    enterRoom("zustand-todo-app");
    return () => {
      leaveRoom("zustand-todo-app");
    };
  }, [enterRoom, leaveRoom]);

  if (isStorageLoading) {
    return <div>Loading...</div>;
  }

  return (
    <div className="container">
      <WhoIsHere />
      <input
        className="input"
        type="text"
        placeholder="What needs to be done?"
        value={draft}
        onChange={(e) => setDraft(e.target.value)}
        onKeyDown={(e) => {
          if (e.key === "Enter") {
            addTodo();
          }
        }}
      ></input>
      <SomeoneIsTyping />
      {todos.map((todo, index) => {
        return (
          <div className="todo_container" key={index}>
            <div className="todo">{todo.text}</div>
            <button
              className="delete_button"
              onClick={() => {
                deleteTodo(index);
              }}
            >
              âœ•
            </button>
          </div>
        );
      })}
    </div>
  );
}
```

VoilÃ ! We have a working collaborative to-do list, with persistent data storage.

## Summary

In this tutorial, weâ€™ve learnt about the concept of rooms, presence, and others.
We've also learnt how to put all these into practice, and how to persist state
using storage too.

You can see some stats about the room you created in your
[dashboard](https://liveblocks.io/dashboard/rooms).

<Figure>
  <Image
    src="/assets/tutorials/todo-list/tutorial-todo-list-dashboard.png"
    alt="Liveblocks dashboard"
    width={1380}
    height={778}
  />
</Figure>

## Next steps

- [API reference](/docs/api-reference/liveblocks-zustand)
- [Authentication](/docs/authentication)

---
meta:
  title: "How to create a notification settings panel"
  description:
    "Learn how to create a notifications preference interface, allowing users to
    choose which notifications they should receive."
---

[Notifications](/docs/ready-made-features/notifications) allows you to add
in-app notifications to your product. However, it also allows you to send unread
notifications via other channels, such as email, Slack, Microsoft Teamsâ€”an
effective way to link back to your app and keep users engaged.

Additionally, Liveblocks allows your end users to individually choose which
notifications they should receive, and on which channel. This guide shows you
how to create a notification preferences panel, which enables this.

<Figure>
  <Image
    src="/assets/notifications/notification-settings.jpg"
    alt="Notification settings"
    width={1344}
    height={896}
  />
</Figure>

## Set up webhooks first

Before starting, itâ€™s important that youâ€™ve already set up a notification
channel in our dashboard, and set up a webhook endpoint. Here are two guides
that take you through how to do this:

- [How to send email notifications of unread comments](/docs/guides/how-to-send-email-notifications-of-unread-comments).
- [How to send email notifications for unread text editor mentions](/docs/guides/how-to-send-email-notifications-for-unread-text-editor-mentions).

## Enabling a notification channel

If youâ€™ve followed one of the previous guides, you should already have enabled a
notification kind for a certain channel in the Notifications dashboard (this is
different to setting up a webhook), however if you already have a production
project, make sure of
[what to check before enabling a notification kind](/docs/guides/what-to-check-before-enabling-a-new-notification-kind)
before continuing, as you may change the behavior of your app.

<Figure>
  <Image
    src="/assets/tutorials/webhooks/liveblocks-click-notifications.png"
    alt="Notifications dashboard page"
    width={712}
    height={445}
  />
</Figure>

Each notification channel has a unique identifier, such as `email` or `slack`,
but they all function in the same way. These distinct names allow developers to
customize notifications for different platforms.

## Building the interface

Now that the back endâ€™s set up, you can use Liveblocks hooks to build the
interface. Each user in your app can set their own preferences for
notifications, and after enabling a notification kind, each userâ€™s will be set
to the default value in the Notifications dashboard.

With
[`useNotificationSettings`](/docs/api-reference/liveblocks-react#useNotificationSettings)
you can see the default value in your app. For example, the value if thread
notifications on the email channel are enabled:

```tsx
import { useNotificationSettings } from "@liveblocks/react";

function NotificationSettings() {
  // +++
  const [{ isLoading, error, settings }, updateSettings] =
    useNotificationSettings();
  // +++

  if (isLoading || error) {
    return null;
  }

  // +++
  // { email: { thread: true } }
  console.log(settings);
  // +++
}
```

You can also use this function to toggle valuesâ€”**this will disable
corresponding webhook events for the current user, meaning they no longer
receive notifications of that type, on that channel**. All other webhook events
are sent as normal, only the current user is affected. Hereâ€™s how to create a
checkbox that toggles the current userâ€™s email/thread setting, disabling the
corresponding webhook.

```tsx
import { useNotificationSettings } from "@liveblocks/react";

function NotificationSettings() {
  const [{ isLoading, error, settings }, updateSettings] =
    useNotificationSettings();

  if (isLoading || error) {
    return null;
  }

  return (
    <>
      {settings.email ? (
        <>
          // +++
          <label>
            Receive thread notifications by email
            <input
              type="checkbox"
              checked={settings.email.thread}
              onChange={(e) =>
                updateSettings({ email: { thread: e.target.checked } })
              }
            />
          </label>
          // +++
        </>
      ) : null}
    </>
  );
}
```

Also make sure to check if the notification kind is enabled before creating the
UI. This way, if itâ€™s toggled in the dashboard, it will gracefully
disappear/reappear. Weâ€™re doing this above by checking if `settings.email`
exists before displaying the `input`.

### Custom notification kinds

You can also use
[custom notification kinds](/docs/ready-made-features/notifications/concepts#Custom-notifications)
as highlighted below, where weâ€™re using a custom `$documentInvite` kind.

```tsx
import { useNotificationSettings } from "@liveblocks/react";

function NotificationSettings() {
  const [{ isLoading, error, settings }, updateSettings] =
    useNotificationSettings();

  if (isLoading || error) {
    return null;
  }

  return (
    <>
      {settings.email ? (
        <>
          // +++
          <label>
            Receive document invites notifications by email
            <input
              type="checkbox"
              checked={settings.email.$documentInvite}
              onChange={(e) =>
                updateSettings({ email: { $documentInvite: e.target.checked } })
              }
            />
          </label>
          // +++
          <label>
            Receive thread notifications by email
            <input
              type="checkbox"
              checked={settings.email.thread}
              onChange={(e) =>
                updateSettings({ email: { thread: e.target.checked } })
              }
            />
          </label>
        </>
      ) : null}
    </>
  );
}
```

Note that you can
[type your app](/docs/api-reference/liveblocks-react#Typing-your-data) to
receive hints for custom notifications.

```tsx file="liveblocks.config.ts"
declare global {
  interface Liveblocks {
    // Custom activities data for custom notification kinds
    ActivitiesData: {
      // +++
      $documentInvite: {
        documentId: string; // Example
      };
      // +++
    };

    // ...
  }
}
```

### Extend it further

If you extend this further, you can create a whole notifications settings panel,
with settings for each notification kind on channel. Below weâ€™ve created an
interface with three kinds of two channels, email and Slack. Like with
`settings.email`, weâ€™re also checking if `settings.slack` exists before using
it.

```tsx
import { useNotificationSettings } from "@liveblocks/react";

function NotificationSettings() {
  const [{ isLoading, error, settings }, updateSettings] =
    useNotificationSettings();

  if (isLoading || error) {
    return null;
  }

  return (
    <>
      {settings.email ? (
        <>
          <label>
            Receive document invites notifications by email
            <input
              type="checkbox"
              checked={settings.email.$documentInvite}
              onChange={(e) =>
                updateSettings({ email: { $documentInvite: e.target.checked } })
              }
            />
          </label>
          <label>
            Receive thread notifications by email
            <input
              type="checkbox"
              checked={settings.email.thread}
              onChange={(e) =>
                updateSettings({ email: { thread: e.target.checked } })
              }
            />
          </label>
          <label>
            Receive text mentions notifications by email
            <input
              type="checkbox"
              checked={settings.email.textMention}
              onChange={(e) =>
                updateSettings({ email: { textMention: e.target.checked } })
              }
            />
          </label>
        </>
      ) : null}

      {settings.slack ? (
        <>
          <label>
            Receive document invites notifications on Slack
            <input
              type="checkbox"
              checked={settings.slack.$documentInvite}
              onChange={(e) =>
                updateSettings({ slack: { $documentInvite: e.target.checked } })
              }
            />
          </label>
          <label>
            Receive thread notifications on Slack
            <input
              type="checkbox"
              checked={settings.slack.thread}
              onChange={(e) =>
                updateSettings({ slack: { thread: e.target.checked } })
              }
            />
          </label>
          <label>
            Receive text mentions notifications on Slack
            <input
              type="checkbox"
              checked={settings.slack.textMention}
              onChange={(e) =>
                updateSettings({ slack: { textMention: e.target.checked } })
              }
            />
          </label>
        </>
      ) : null}
    </>
  );
}
```

You now have a notification settings interface that allows each user to choose
their own settings! This works by toggling webhooks on specific channels and
kinds.

## Other methods

Should you need to access and modify notification settings outside of React, we
also provide
[JavaScript functions](/docs/api-reference/liveblocks-client#Client.getNotificationSettings),
[Node.js methods](/docs/api-reference/liveblocks-node#get-users-userId-notification-settings),
and
[REST API endpoints](/docs/api-reference/rest-api-endpoints#get-rooms-roomId-users-userId-notification-settings).

---
meta:
  title: "How to customize room names in inbox notifications"
  description: "Learn how to display custom room names instead of room IDs in inbox notifications using resolveRoomsInfo."
---

When using inbox notifications with Comments, youâ€™ll notice that room IDs are displayed by default (e.g., â€Chris mentioned you in _room-abc123_â€). This isnâ€™t ideal for users who need to see meaningful context. In this guide, youâ€™ll learn how to replace room IDs with actual document or room names using `resolveRoomsInfo`.

## Use resolveRoomsInfo to display custom names

You can provide a [`resolveRoomsInfo`](/docs/api-reference/liveblocks-react#LiveblocksProviderResolveRoomsInfo) function to [`LiveblocksProvider`](/docs/api-reference/liveblocks-react#LiveblocksProvider) that maps room IDs to human-readable names. This function receives an array of room IDs and should return an array of room info objects with a `name` property.

```tsx
import { LiveblocksProvider } from "@liveblocks/react/suspense";

function App() {
  return (
    <LiveblocksProvider
      resolveRoomsInfo={async ({ roomIds }) => {
        // Fetch your documents or rooms from your database
        const documentsData = await __getDocumentsFromDB__(roomIds);

        // Return room info with names
        return documentsData.map((documentData) => ({
          name: documentData.name,
        }));
      }}
      // Other props
      // ...
    >
      {/* children */}
    </LiveblocksProvider>
  );
}
```

Once youâ€™ve added this, the [`InboxNotification`](/docs/api-reference/liveblocks-react-ui#InboxNotification) component will automatically use the room names instead of IDs, showing notifications like â€œChris mentioned you in _Document A_â€ instead of â€œChris mentioned you in _room-abc123_â€.

## Adding room URLs

You can also provide a `url` property for each room, which will be used by the `InboxNotification` component to make notifications clickable.

```tsx
<LiveblocksProvider
  resolveRoomsInfo={async ({ roomIds }) => {
    const documentsData = await __getDocumentsFromDB__(roomIds);

    return documentsData.map((documentData) => ({
      name: documentData.name,
      url: documentData.url,
    }));
  }}
  // Other props
  // ...
>
  {/* children */}
</LiveblocksProvider>
```

This is particularly useful when you need additional data from your backend to construct the URL, rather than building it directly in your React components using just the room ID.

---
meta:
  title: "How to filter rooms using query language"
  description:
    "Learn how to filter for certain rooms using their names and metadata with
    our query language"
---

When retrieving rooms with our REST API, itâ€™s possible to filter for specific
threads using [custom metadata](/docs/ready-made-features/comments/metadata) and
room ID prefixes using our custom query language. This enables the
[Get Rooms REST API](/docs/api-reference/rest-api-endpoints#get-rooms) to have
filtering that works the same as with
[`liveblocks.getRooms`](/docs/api-reference/liveblocks-node#get-rooms).

## Query language

You can filter rooms by their metadata and room ID prefixes, which is helpful
when youâ€™re using a
[naming pattern](/docs/authentication/access-token#Naming-pattern) for your
rooms. Filters can be combined using `AND` logic.

```js
// Rooms with IDs that begin with "liveblocks:"
roomId^'liveblocks:'

// Rooms with { roomType: 'whiteboard' } string metadata
metadata['roomType']:'whiteboard'

// Combine queries with AND
roomId^'liveblocks:' AND metadata['roomType']:'whiteboard'

// Use multiple metadata filters at once
metadata['roomType']:'whiteboard' AND metadata['creator']:'florent'
```

<Banner>

The `AND` is optional and can actually be omitted, but weâ€™re using it here for
clarity.

</Banner>

Note that room metadata can contain `strings` or `arrays`, but only `strings`
can be filtered. If you wish to return a single specific room, instead use the
[Get Room API](/docs/api-reference/rest-api-endpoints#get-rooms-roomId) or
[`liveblocks.getRoom`](/docs/api-reference/liveblocks-node#get-rooms-roomId).

### How to use

To use the query language with the
[REST API](/docs/api-reference/rest-api-endpoints#get-rooms) pass your query
string to the `query` parameter. For example, given this query:

```js
roomId^'liveblocks:' AND metadata['roomType']:'whiteboard'
```

Encode it, and add it to the `query` parameter:

```
https://api.liveblocks.io/v2/rooms?query=roomId%5E'liveblocks%3A'%20AND%20metadata%5B'roomType'%5D%3A'whiteboard'
```

To learn more on _setting_ custom metadata on rooms, make sure to
[read our guide](/docs/rooms/metadata).

---
meta:
  title: "How to filter threads with query language"
  description:
    "Learn how to filter for certain threads using their metadata with our query
    language"
---

When using Comments and retrieving threads with our REST API, itâ€™s possible to
filter for specific threads using
[custom metadata](/docs/ready-made-features/comments/metadata) and our custom
query language. This enables the
[Get Threads REST API](/docs/api-reference/rest-api-endpoints#get-rooms-roomId-threads)
to have filtering that works the same as with
[`useThreads`](/docs/api-reference/liveblocks-react#useThreads) and
[`liveblocks.getThreads`](/docs/api-reference/liveblocks-node#get-rooms-roomId-threads).

## Query language

You can filter threads by their metadata, allowing you to select for certain
properties, values, or even for string prefixes. Filters can be combined using
`AND` logic.

```js
// Resolved threads
resolved:true

// Threads with { status: 'open' } string metadata
metadata['status']:'open'

// Threads with `{ org }` string metadata that starts with "liveblocks:"
metadata['org']^'liveblocks:'

// Threads with { priority: 3 } number metadata
metadata['priority']:3

// Threads with { pinned: false } boolean metadata
metadata['pinned']:false

// Threads without a `color` property
metadata['color']:null

// Combine queries with AND
resolved:true AND metadata['priority']:3

// A more complex combination
metadata['status']:'closed' AND metadata['org']^'liveblocks:'
```

<Banner>

The `AND` is optional and can actually be omitted, but weâ€™re using it here for
clarity.

</Banner>

### How to use

To use the query language with the
[REST API](/docs/api-reference/rest-api-endpoints#get-rooms-roomId-threads) pass
your query string to the `query` parameter. For example, given this query:

```js
metadata['status']:'open' AND metadata['priority']:3
```

Encode it, and add it to the `query` parameter:

```
https://api.liveblocks.io/v2/rooms/{roomId}/threads?query=metadata%5B'status'%5D%3A'open'%20AND%20metadata%5B'priority'%5D%3A3
```

To learn more on _setting_ custom metadata on threads, make sure to
[read our guide](/docs/ready-made-features/comments/metadata).

---
meta:
  title: "Grant access to individual rooms with access tokens"
  description:
    "Learn how to grant access to individual rooms with access tokens"
---

<Banner title="Looking for more complex permissions?" type="warning">

If youâ€™re looking to build an application with permissions at organization,
group, and user levels, we recommend using
[ID tokens](/docs/authentication/id-token) instead. Access tokens have
[limitations when granting nested permissions](#limitations).

</Banner>

With [access tokens](/docs/authentication/access-token) we always recommend
using a [naming pattern](/docs/authentication/access-token#Naming-pattern) to
grant access to multiple rooms at once, for example every room in a userâ€™s
organization.

```ts
// âœ… Grants access to every `acme` organization room
session.allow(`acme:*`, session.FULL_ACCESS);
```

However, it may not always be possible to grant access to every room with a
wildcard and naming pattern. One example would be if a user is invited to _only
one room_ in a _different_ organization. Thereâ€™s a way to work around this
limitation.

## Grant access to individual rooms

When using
[`authEndpoint`](/docs/api-reference/liveblocks-client#createClientAuthEndpoint),
Liveblocks provides the current room ID in the `request`. Below is a Next.js
example, where the current room ID is taken from the body, and the user is
allowed access to the room. Note that `room` is `undefined` when
[Notifications](/docs/ready-made-features/comments/email-notifications) is
authenticating, which is why weâ€™re checking if it exists. Notifications works
across rooms, and it doesnâ€™t require any permissions.

```tsx highlight="17,19-21"
import { Liveblocks } from "@liveblocks/node";

const liveblocks = new Liveblocks({
  secret: "sk_prod_xxxxxxxxxxxxxxxxxxxxxxxx",
});

export async function POST(request: Request) {
  // Get the current user from your database
  const user = __getUserFromDB__(request);

  // Start an auth session inside your endpoint
  const session = liveblocks.prepareSession(
    user.id,
    { userInfo: user.metadata } // Optional
  );

  const { room } = request.body;

  if (room && __shouldUserHaveAccess__(user, room)) {
    session.allow(room, session.FULL_ACCESS);
  }

  // Authorize the user and return the result
  const { status, body } = await session.authorize();
  return new Response(body, { status });
}
```

This approach relies on you creating the `__shouldUserHaveAccess__` function,
and determining whether the user is allowed inside the room.

---
meta:
  title: "How to migrate to Liveblocks Comments"
  description:
    "Learn how to import your threads, comments, and reaction to Liveblocks
    Comments in this migration guide."
---

To migrate your threads, comments, and reactions to Liveblocks Comments, you can
create a migration script using our
[Node.js methods](https://liveblocks.io/docs/api-reference/liveblocks-node) or
[REST API](https://liveblocks.io/docs/api-reference/rest-api-endpoints). This
guide will take you through all the Liveblocks features required to create a
migration script in Node.js. Note that each Node.js method also has an
equivalent REST API which could be used instead.

<Banner title="Before starting" type="warning">

Before starting to migrate, make sure to
[set up authentication](https://liveblocks.io/docs/authentication) in your app,
deciding on either _ID tokens_ or _access tokens_.

</Banner>

## Creating rooms

The first step is to create the multiplayer room where the comments are stored.
This is equivalent to a document in your project. Make sure to read the sections
on permissions under
[access tokens](/docs/authentication/access-token#permissions) or
[ID tokens](/docs/authentication/id-token#permissions) to fully understand
setting up your room.

Create a room using
[`liveblocks.createRoom`](/docs/api-reference/liveblocks-node#post-rooms) or the
[Create Room API](/docs/api-reference/rest-api-endpoints#post-rooms), and set
permissions if youâ€™re using ID tokens.

```ts
// The unique ID for the room
const roomId = "my-room-id";

// Create a room
const room = await liveblocks.createRoom(roomId, {
  // If you're using ID tokens, set your permissions/accesses, examples below
  defaultAccesses: [
    // "room:write"`
  ],
  // groupsAccesses: {
  //   my-group: ["room:write"]
  // }
  // usersAccesses: {
  //   my-user: ["room:write"]
  // }
});
```

## Creating threads

Next up is creating threads in the room. Before starting, make sure you
understand the
[concepts behind Comments](/docs/ready-made-features/comments/concepts). When a
thread is created, the first comment is also created, and you can do this with
[`liveblocks.createThread`](/docs/api-reference/liveblocks-node#post-rooms-roomId-threads)
or the
[Create Thread API](/docs/api-reference/rest-api-endpoints#post-rooms-roomId-threads).

```ts
// The unique ID for the room
const roomId = "my-room-id";

// Create a room
const room = await liveblocks.createRoom(roomId, {
  defaultAccesses: [],
});

// +++
// Create a thread
const thread = await liveblocks.createThread({
  roomId,

  data: {
    comment: {
      // ID of the user that created the thread
      userId: "florent@example.com",

      body: {
        version: 1,
        content: [
          // The initial comment's body text goes here
          // {
          //   type: "paragraph",
          //   children: [{ text: "Hello " }, { text: "world", bold: true }],
          // },
        ],
      },
    },
  },
});
// +++
```

Read under
[`liveblocks.createThread`](/docs/api-reference/liveblocks-node#post-rooms-roomId-threads)
to learn how to create a Comment body, and check in
[GitHub](https://github.com/liveblocks/liveblocks/blob/64a2f5707785b95b1f56d7ff3b53a234dfc9ccd7/packages/liveblocks-core/src/protocol/Comments.ts#L55)
for information about each comment body element.

## Adding further comments

To add more comments to the new thread, use
[`liveblocks.createComment`](/docs/api-reference/liveblocks-node#post-rooms-roomId-threads-threadId-comments)
or the
[Create Comment API](/docs/api-reference/rest-api-endpoints#post-rooms-roomId-threads-threadId-comments).
Weâ€™re just sharing a simple code snippet below, but of course, we recommend you
use a loop.

```ts
// The unique ID for the room
const roomId = "my-room-id";

// Create a room
const room = await liveblocks.createRoom(roomId, {
  defaultAccesses: [],
});

// Create a thread
const thread = await liveblocks.createThread({
  /* ... */
});

// +++
// Adding a comment to the existing thread
const comment = await liveblocks.createComment({
  roomId,
  threadId: thread.id,

  data: {
    // ID of the user that created the comment
    userId: "pierre@example.com",

    // Optional, when the comment was created
    createdAt: new Date(),

    body: {
      version: 1,
      content: [
        // The comment's body text goes here
        // {
        //   type: "paragraph",
        //   children: [{ text: "Hello " }, { text: "world", bold: true }],
        // },
      ],
    },
  },
});
// +++
```

## Adding reactions

To add reactions to each comment, use
[`liveblocks.addCommentReaction`](/docs/api-reference/liveblocks-node#post-rooms-roomId-threads-threadId-comments-commentId-add-reaction)
or the
[Add Comment Reaction API](/docs/api-reference/rest-api-endpoints#post-rooms-roomId-threads-threadId-comments-commentId-add-reaction).

```ts
// The unique ID for the room
const roomId = "my-room-id";

// Create a room
const room = await liveblocks.createRoom(roomId, {
  defaultAccesses: [],
});

// Create a thread
const thread = await liveblocks.createThread({
  /* ... */
});

// Adding a comment to the existing thread
const comment = await liveblocks.createComment({
  /* ... */
});

// +++
// Add a reaction to a comment
const reaction = await liveblocks.addCommentReaction({
  roomId,
  threadId: thread.id,
  commentId: comment.id,

  data: {
    // The reaction emoji
    emoji: "âœ…",

    // ID of the user that reacted
    userId: "guillaume@example.com",

    // Optional, the time the reaction was added
    createdAt: new Date(),
  },
});
// +++
```

## Migrating users

Thereâ€™s no need to migrate users to Comments, as the only user information
Liveblocks stores
[is each userâ€™s ID](/docs/ready-made-features/comments/users-and-mentions).
Other user info is retrieved in-app by Comments with
[`resolveUserInfo`](/docs/api-reference/liveblocks-react#LiveblocksProviderResolveUsers).

## Putting it together

To create a migration script, put everything together and loop through all the
functions weâ€™ve listed above. Below is an example of a migration script, though
youâ€™ll need to make changes based on the format of the comment system youâ€™re
migrating from. `oldDocumentId` and `oldDocumentThreads` represent your current
data.

```tsx
import { Liveblocks } from "@liveblocks/node";

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

async function migrateDocument({ oldDocumentId, oldDocumentThreads }) {
  console.log(`Migrating document: ${oldDocumentId}`);

  // The unique ID for the room
  const roomId = oldDocumentId;

  // Create a Liveblocks room
  const room = await liveblocks.createRoom(roomId, {
    // If you're using ID tokens, set your permissions/accesses, examples below
    defaultAccesses: [
      // "room:write"`
    ],
    // groupsAccesses: {
    //   my-group: ["room:write"]
    // }
    // usersAccesses: {
    //   my-user: ["room:write"]
    // }
  });

  // Loop through your existing threads for the current room
  for (const oldThread of oldDocumentThreads) {
    const [firstComment, ...otherComments] = oldThread.comments;

    // Create a Liveblocks thread
    const thread = await liveblocks.createThread({
      roomId: room.id,

      data: {
        comment: {
          // ID of the user that created the thread
          userId: firstComment.userId,

          body: {
            version: 1,
            content: __convertCommentToLiveblocksFormat__(firstComment.body),
          },
        },
      },
    });

    // Loop through this existing thread's comments
    for (const oldComment of otherComments) {
      // Create a Liveblocks comment
      const comment = await liveblocks.createComment({
        roomId: room.id,
        threadId: thread.id,

        data: {
          // ID of the user that created the comment
          userId: oldComment.userId,

          // Optional, when the comment was created
          createdAt: new Date(oldComment.timestamp),

          body: {
            version: 1,
            content: __convertCommentToLiveblocksFormat__(oldComment.body),
          },
        },
      });

      // Loop through this existing comment's reactions
      for (const oldReaction of oldComment.reactions) {
        // Add a reaction to a Liveblocks comment
        await liveblocks.addCommentReaction({
          roomId: room.id,
          threadId: thread.id,
          commentId: comment.id,

          data: {
            // The reaction emoji
            emoji: oldReaction.emoji,

            // ID of the user that reacted
            userId: oldReaction.userId,

            // Optional, the time the reaction was added
            createdAt: new Date(oldReaction.timestamp),
          },
        });
      }
    }
  }

  console.log(`Document migrated: ${oldDocumentId}`);
}
```

---
meta:
  title: "How to modify Liveblocks Storage from the server"
  description:
    "Learn about the different methods you can use to modify Liveblocks Storage
    within Node.js"
---

In realtime applications, Liveblocks Storage is generally modified from the
browser with [`useMutation`](/docs/api-reference/liveblocks-react#useMutation)
or through
[conflict-free data methods](/docs/api-reference/liveblocks-client#Storage).
However, it can also be useful to modify your realtime storage from server-side
Node.js too.

## What weâ€™re doing

<Banner title="Make sure youâ€™re on the latest version" type="info">

This guide assumes youâ€™re using the latest version of `@liveblocks/node`.

</Banner>

In this guide, weâ€™ll demonstrate how to easily modify storage from the server.
Weâ€™ll do this using `@liveblocks/node`.

## Start modifying storage

We can now start modifying storage from the server!

```ts file="route.ts"
// Creating a node client (centrally)
const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

export async function POST() {
  console.log("Updating storage");

  // Mutate storage
  +++
  await liveblocks.mutateStorage(
    "my-room",

    ({ root }) => {
      root.get("list").push("item3");
    }
  );
  +++

  console.log("Storage update complete!");
}
```

---
meta:
  title: "How to notify users about unread comments outside of your app"
  description:
    "Learn how to trigger thread notifications externally, such as in Slack,
    Microsoft Teams, and more."
---

Liveblocks [Comments](/docs/ready-made-features/comments) allows you to build a
commenting experience. With our webhooks and REST API, itâ€™s possible to
aggregate a list of unread comments, and use them to trigger notifications in
Slack, Microsoft Teams, or any other external service with an API, using
webhooks. Notifications can also be displayed in your app using
[`useInboxNotifications`](/docs/api-reference/liveblocks-react#useInboxNotifications)
and the
[`InboxNotification`](/docs/api-reference/liveblocks-react-ui#InboxNotification)
component.

<Banner title="Want to send email notifications?">

We have a specific guide on
[how to send email notifications of unread comments](/docs/guides/how-to-send-email-notifications-of-unread-comments),
which we recommend reading if youâ€™re building emails.

</Banner>

## What weâ€™re building

In this guide weâ€™ll be learning how to notify users about unread comments
outside of your app, and more specifically, weâ€™ll be looking at how to:

- Trigger events based on unread comments using the
  [`NotificationEvent`](/docs/platform/webhooks#NotificationEvent) webhook
  event.
- Fetch unread comments using the
  [`@liveblocks/node`](/docs/api-reference/liveblocks-node) package.

<Banner title="Have a project ready">

This guide assumes you already have a Liveblocks Comments project set up. If you
donâ€™t have one yet, you can
[get started with Comments](/docs/get-started/comments), and come back after
youâ€™re set up.

</Banner>

## What are inbox notifications?

Liveblocks uses the concept of inbox notifications, which differ to external
notifications. Inbox notifications are displayed within in-app inboxes, group
multiple activities together, and can change over time, like when a new comment
is added to a thread.

External notifications, such as Slack, and Microsoft Teams, are different, and
Liveblocks is set up to send them in a way that wonâ€™t overload your users with
notifications. This means that Liveblocks will wait to trigger these
notifications until a certain amount of time has passed, and will only trigger
them if your users has not read the notification on the front-end, which we
automatically keep track of. We then aggregate multiple unread comments into a
single notification, so your users just get a single ping per thread.

Learn more about Notifications for Comments in the
[overview page](/docs/ready-made-features/comments/email-notifications).

## Using webhooks

Liveblocks provides a number of [webhooks](/docs/platform/webhooks) that can
send requests to your API endpoint when certain events occurs. One webhook we
provide is the [`NotificationEvent`](/docs/platform/webhooks#NotificationEvent)
webhook, which is triggered for each participating user in a thread, and can be
used to send external notifications to your users.

The information it returns allows you to retrieve comments that have not yet
been read by the user, making it possible to aggregate multiple unread comments
into a single external notification. Letâ€™s take a look at how to set this up.

### Notification channels

You can send notifications via different channels, such as email, Slack,
Microsoft Teams, and Web Push. In our dashboard, you can enable notifications on
certain channels, and in this guide, weâ€™ll be using the Slack channel. You must
always enable the correct channel to ensure your
[`NotificationEvent`](/docs/platform/webhooks#NotificationEvent) webhook events
are triggered, and this guide will take you through setting it up.

<Banner title="Which notification channel?">

All channels currently work the same way, apart from in-app, but we suggest
selecting the service youâ€™re setting up, such as Slack or Microsoft Teams, so
itâ€™s easy to tell which youâ€™ve implemented.

</Banner>

## Create an endpoint in your project

When a webhook event is triggered, it can send a POST request to the back end in
your project. In this guide, weâ€™ll be using a Next.js route handler (API
endpoint) as an example, but other frameworks work similarly.

In order to use webhooks, weâ€™ll need to retrieve the `headers` and `body` from
the request. Hereâ€™s the basic endpoint weâ€™ll be starting from:

```ts
export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Handle webhooks and notifications
  // ...

  return new Response(null, { status: 200 });
}
```

Create this endpoint in your project, and make it available on `localhost` at
the following URL:

```
/api/liveblocks-notifications
```

Make a note of this endpoint URL, as youâ€™ll be using it later.

### Testing webhooks locally

Running webhooks locally can be difficult, but one way to do this is to use a
tool such as [`localtunnel`](https://www.npmjs.com/package/localtunnel) or
[`ngrok`](https://www.npmjs.com/package/ngrok) which allow you to temporarily
put your localhost server online.

If your project is running on `localhost:3000`, you can run the following
command to generate a temporary URL thatâ€™s available while your localhost server
is running:

```bash
npx localtunnel --port 3000
```

`localtunnel` generates a base URL that can be placed into the Liveblocks
webhooks dashboard for quick testing. To use this, take the full address of your
webhook endpoint, and replace the domain in your `localhost` address with the
generated URL.

```shell
# Take your local URL
http://localhost:3000/api/liveblocks-notifications

# Replace localhost with the generated domain, then copy it
https://my-localtunnel-url.loca.lt/api/liveblocks-notifications
```

You now have a URL that can be used in the webhooks dashboard.

## Set up webhooks on the Liveblocks dashboard

To use webhooks, you need to pass your endpoint URL to the webhooks dashboard
inside your Liveblocks project, and tell the webhook to trigger when a comment
has been created.

<Steps>
  <Step>
    <StepTitle>Select your project</StepTitle>
    <StepContent>
      From the [Liveblocks dashboard](/dashboard), navigate to the project youâ€™d
      like to use with webhooks, or create a new project.
      <Figure>
        <Image
          src="/assets/tutorials/webhooks/liveblocks-create-project.png"
          alt="Create a Liveblocks project"
          width={712}
          height={445}
        />
      </Figure>
    </StepContent>
  </Step>

<Step>
  <StepTitle>Go to the notifications dashboard</StepTitle>
  <StepContent>
    Click on the **â€œNotificationsâ€** tab on the menu at the left.
    <Figure>
      <Image
        src="/assets/tutorials/webhooks/liveblocks-click-notifications.png"
        alt="Click notifications"
        width={712}
        height={445}
      />
    </Figure>
  </StepContent>
</Step>

<Step>
  <StepTitle>Enable the thread notification type</StepTitle>
  <StepContent>
    Click on **â€œEditâ€** at the top right, enable `thread` notifications on the
    Slack channel, and publish your changes.
    <Figure>
      <Image
        src="/assets/tutorials/webhooks/liveblocks-enable-thread-notification-slack.png"
        alt="Enable thread notifications"
        width={712}
        height={445}
      />
    </Figure>
  </StepContent>
</Step>

<Step>
  <StepTitle>Go to the webhooks dashboard</StepTitle>
  <StepContent>
    Click on the **â€œWebhooksâ€** tab on the menu at the left.
    <Figure>
      <Image
        src="/assets/tutorials/webhooks/liveblocks-click-webhooks.png"
        alt="Click webhooks"
        width={712}
        height={445}
      />
    </Figure>
  </StepContent>
</Step>

<Step>
  <StepTitle>Create an endpoint</StepTitle>
  <StepContent>
    Click the **â€œAdd endpointâ€¦â€** button on the webhooks dashboard to start
    setting up your webhook.
    <Figure>
      <Image
        src="/assets/tutorials/webhooks/liveblocks-add-endpoint.png"
        alt="Click add endpoint"
        width={712}
        height={445}
      />
    </Figure>
  </StepContent>
</Step>

<Step>
  <StepTitle>Add your endpoint URL</StepTitle>
  <StepContent>
    Enter the URL of the endpoint. In a production app this will be the real
    endpoint, but for now enter your `localtunnel` URL from earlier.
    <Figure>
      <Image
        src="/assets/tutorials/webhooks/liveblocks-add-endpoint-url.png"
        alt="Add endpoint URL"
        width={712}
        height={445}
      />
    </Figure>
  </StepContent>
</Step>

<Step>
  <StepTitle>Enable notification webhook events</StepTitle>
  <StepContent>
    Check the **â€œnotificationâ€** event in the dialog to enable the correct
    webhooks events.
    <Figure>
      <Image
        src="/assets/tutorials/webhooks/liveblocks-enable-notification-webhook.png"
        alt="Add endpoint URL"
        width={712}
        height={445}
      />
    </Figure>
  </StepContent>
</Step>

<Step>
  <StepTitle>Get your webhook secret key</StepTitle>
  <StepContent>
    Click **â€œAdd endpointâ€** at the bottom, then find your **â€œSecret keyâ€** on
    the next page, and copy it.
    <Figure>
      <Image
        src="/assets/tutorials/webhooks/liveblocks-get-secret-key.png"
        alt="Copy your webhook secret key"
        width={710}
        height={445}
      />
    </Figure>
  </StepContent>
</Step>

  <Step lastStep>
    <StepTitle>Webhooks dashboard is set up!</StepTitle>

    <StepContent>
      Notification webhooks are set up! Letâ€™s go back to the
      code.
    </StepContent>

  </Step>
</Steps>

## Verify the webhook request

The [`@liveblocks/node`](/docs/api-reference/liveblocks-node) package provides
you with a function that verifies whether the current request is a real webhook
request from Liveblocks. You can set this up by setting up a
[`WebhookHandler`](/docs/api-reference/liveblocks-node#WebhookHandler) and
running [`verifyRequest`](/docs/api-reference/liveblocks-node#verifyRequest).

Make sure to add your _webhook_ secret key from earlierâ€”in a real project weâ€™d
recommend using an environment variable for this.

```ts highlight="1,3-5,11-21"
import { WebhookHandler } from "@liveblocks/node";

// Add your webhook secret key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_WEBHOOK_SECRET_KEY";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // Send notifications
  // ...

  return new Response(null, { status: 200 });
}
```

## Check the event and notification permissions

After verifying the request, we can then check weâ€™re receiving the correct type
of event, on the correct channel. There are different `notification` events, and
in this case weâ€™d like to check for
[thread notification](/docs/platform/webhooks#Thread-notification), as weâ€™re
specifically listening for new comments. We can do this using
[`ThreadNotificationEvent`](/docs/api-reference/liveblocks-node#isThreadNotificationEvent),
making sure to check for the `slack` channel.

```ts
import { WebhookHandler, isThreadNotificationEvent } from "@liveblocks/node";

// Add your webhook secret key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_WEBHOOK_SECRET_KEY";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // +++
  // When an inbox notification has been created on the slack channel
  if (isThreadNotificationEvent(event) && event.data.channel === "slack") {
    const { roomId, threadId, inboxNotificationId, userId } = event.data;

    // Check if user has access to room
    if (!__hasRoomAccess__(userId, roomId)) {
      return new Response(null, { status: 200 });
    }

    // Send notifications
    // ...
  }
  // +++

  return new Response(null, { status: 200 });
}
```

Note that weâ€™re also checking if the user should receive a
notificationâ€”Liveblocks doesnâ€™t have knowledge of your permissions system on the
back end, so itâ€™s your responsibility to check if this user should have access
to the room.

## Get comment and thread data

<Banner title="Threads vs comments">
  Note that a thread is different to a commentâ€”a thread is â€œtop-levelâ€, and each
  thread contains a list of comments. When you create a thread with
  [`useCreateThread`](/docs/api-reference/liveblocks-react#useCreateThread), you
  also create the first comment in the thread.
</Banner>

The next step is to use the
[Liveblocks client](/docs/api-reference/liveblocks-node#Liveblocks-client) from
`@liveblocks/node` to retrieve the inbox notification, and the corresponding
threadâ€™s data. To do this weâ€™ll need to add our projectâ€™s secret key from
[the dashboard](/dashboard/api-keys) to the Liveblocks client (_not_ the webhook
secret key we used earlier), before awaiting the following functions:
[`getInboxNotification`](/docs/api-reference/liveblocks-node#get-users-userId-inboxNotifications-inboxNotificationId)
and [`getThread`](/docs/api-reference/liveblocks-node#get-thread).

```ts
import {
  // +++
  Liveblocks,
  // +++
  WebhookHandler,
  isThreadNotificationEvent,
} from "@liveblocks/node";

// Add your webhook secret key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_WEBHOOK_SECRET_KEY";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

// Add your secret key from a project's API keys dashboard
// +++
const API_SECRET = "{{SECRET_KEY}}";
const liveblocks = new Liveblocks({ secret: API_SECRET });
// +++

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // When an inbox notification has been created
  if (isThreadNotificationEvent(event) && event.data.channel === "slack") {
    const { roomId, threadId, inboxNotificationId, userId } = event.data;

    // Check if user has access to room
    if (!__hasRoomAccess__(userId, roomId)) {
      return new Response(null, { status: 200 });
    }

    try {
      // Get thread and notification
      const [thread, inboxNotification] = await Promise.all([
        liveblocks.getThread({ roomId, threadId }),
        liveblocks.getInboxNotification({ inboxNotificationId, userId }),
      ]);

      // Send external notifications
      // ...
    } catch (err) {
      console.log(err);
      return new Response("Could not fetch notification data", { status: 500 });
    }
  }

  return new Response(null, { status: 200 });
}
```

## Get the unread comments

The next step is to get each unread comment by comparing the `readAt` time in
the inbox notification with the `createAt` time on each comment. Weâ€™re also
filtering out each comment with no body, which represents a deleted comment.

```ts
import {
  Liveblocks,
  WebhookHandler,
  isThreadNotificationEvent,
} from "@liveblocks/node";

// Add your webhook secret key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_WEBHOOK_SECRET_KEY";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

// Add your secret key from a project's API keys dashboard
const API_SECRET = "{{SECRET_KEY}}";
const liveblocks = new Liveblocks({ secret: API_SECRET });

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // When an inbox notification has been created
  if (isThreadNotificationEvent(event) && event.data.channel === "slack") {
    const { roomId, threadId, inboxNotificationId, userId } = event.data;

    // Check if user has access to room
    if (!__hasRoomAccess__(userId, roomId)) {
      return new Response(null, { status: 200 });
    }

    try {
      // Get thread and notification
      const [thread, inboxNotification] = await Promise.all([
        liveblocks.getThread({ roomId, threadId }),
        liveblocks.getInboxNotification({ inboxNotificationId, userId }),
      ]);

      // Get unread comments (and filter out deleted comments)
      // +++
      const readAt = inboxNotification.readAt;
      const unreadComments = thread.comments
        .filter((comment) => (readAt ? comment.createdAt > readAt : true))
        .filter((comment) => comment.body !== undefined);

      // No unread comments, therefore no notification needed
      if (unreadComments.length === 0) {
        return new Response(null, { status: 200 });
      }
      // +++

      // Send notifications
      // ...
    } catch (err) {
      console.log(err);
      return new Response("Could not fetch notification data", { status: 500 });
    }
  }

  return new Response(null, { status: 200 });
}
```

If there are no unread notifications, then weâ€™re choosing not to send an email.

## Generating comment text for the external notification

Now that we have the comment data, we have one more step before sending the
notificationsâ€”formatting each commentâ€™s text, found inside `comment.body`, and
generating the text for our external notification.

By using
[`await stringifyCommentBody`](/docs/api-reference/liveblocks-node#stringify-comment-body),
we can convert each comment into plain text, markdown, or HTML. In this code
snippet, you can see weâ€™re looping through each comment, and replacing
`comment.body` with a markdown string.

```ts
import {
  Liveblocks,
  WebhookHandler,
  isThreadNotificationEvent,
  // +++
  stringifyCommentBody,
  // +++
} from "@liveblocks/node";

// Add your webhook secret key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_WEBHOOK_SECRET_KEY";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

// Add your secret key from a project's API keys dashboard
const API_SECRET = "{{SECRET_KEY}}";
const liveblocks = new Liveblocks({ secret: API_SECRET });

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // When an inbox notification has been created
  if (event.type === "notification") {
    const { roomId, threadId, inboxNotificationId, userId } = event.data;

    // Check if user has access to room
    if (!__hasRoomAccess__(userId, roomId)) {
      return new Response(null, { status: 200 });
    }

    try {
      // Get thread and notification
      const [thread, inboxNotification] = await Promise.all([
        liveblocks.getThread({ roomId, threadId }),
        liveblocks.getInboxNotification({ inboxNotificationId, userId }),
      ]);

      // Get unread comments (and filter out deleted comments)
      const readAt = inboxNotification.readAt;
      const unreadComments = thread.comments
        .filter((comment) => (readAt ? comment.createdAt > readAt : true))
        .filter((comment) => comment.body !== undefined);

      // No unread comments, therefore notification needed
      if (unreadComments.length === 0) {
        return new Response(null, { status: 200 });
      }

      // Convert comments to markdown and return { body: "**...**", ...comment } format
      // +++
      const textComments = await Promise.all(
        unreadComments.map(async (comment) => ({
          body: await stringifyCommentBody(comment.body, {
            format: "markdown",
          }),
          ...comment,
        }))
      );
      // +++

      // Create final markdown for notification
      // +++
      let markdown = "# New notifications";
      for (const comment of textComments) {
        markdown += `
          **Comment by ${comment.userId} at ${comment.createdAt}**:
          ${comment.body}
        `;
      }
      markdown += `
        [Go to thread](https://my-company.com/room/${roomId}#${threadId})
      `;
      // +++

      // Send notifications
      // ...
    } catch (err) {
      console.log(err);
      return new Response("Could not fetch notification data", { status: 500 });
    }
  }

  return new Response(null, { status: 200 });
}
```

This snippet outputs simple formatting, for example it renders a user IDs (e.g.
`@jory.quispe`) instead of a names (e.g. `@Jory Quispe`), but you can create
more complex formatting easily by using more complex
[`stringifyCommentBody`](/docs/api-reference/liveblocks-node#stringify-comment-body)
options.

## Send external notifications

Now that the commentâ€™s body has been formatted, we can send the external
notifications. In this example, weâ€™re sending our markdown to an incoming
webhook in Slack.

```tsx
import {
  Liveblocks,
  WebhookHandler,
  isThreadNotificationEvent,
  stringifyCommentBody,
} from "@liveblocks/node";

// Add your webhook secret key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_WEBHOOK_SECRET_KEY";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

// Add your secret key from a project's API keys dashboard
const API_SECRET = "{{SECRET_KEY}}";
const liveblocks = new Liveblocks({ secret: API_SECRET });

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // When an inbox notification has been created
  if (event.type === "notification") {
    const { roomId, threadId, inboxNotificationId, userId } = event.data;

    // Check if user has access to room
    if (!__hasRoomAccess__(userId, roomId)) {
      return new Response(null, { status: 200 });
    }

    try {
      // Get thread and notification
      const [thread, inboxNotification] = await Promise.all([
        liveblocks.getThread({ roomId, threadId }),
        liveblocks.getInboxNotification({ inboxNotificationId, userId }),
      ]);

      // Get unread comments (and filter out deleted comments)
      const readAt = inboxNotification.readAt;
      const unreadComments = thread.comments
        .filter((comment) => (readAt ? comment.createdAt > readAt : true))
        .filter((comment) => comment.body !== undefined);

      // No unread comments, therefore notification needed
      if (unreadComments.length === 0) {
        return new Response(null, { status: 200 });
      }

      // Convert comments to markdown and return { body: "**...**", ...comment } format
      const textComments = await Promise.all(
        unreadComments.map(async (comment) => ({
          body: await stringifyCommentBody(comment.body, {
            format: "markdown",
          }),
          ...comment,
        }))
      );

      // Create final markdown for notification
      let markdown = "# New notifications";
      for (const comment of textComments) {
        markdown += `
          **Comment by ${comment.userId} at ${comment.createdAt}**:
          ${comment.body}
        `;
      }
      markdown += `
        [Go to thread](https://my-company.com/room/${roomId}#${threadId})
      `;

      // Send your external notifications, e.g. to Slack
      // +++
      await fetch(
        "https://hooks.slack.com/services/T00000000/B00000000/XXXXXXXXXXXXXXXXXXXXXXXX",
        {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            text: markdown,
            username: `@${userId}`,
          }),
        }
      );
      // +++
    } catch (err) {
      console.log(err);
      return new Response("Could not fetch notification data", { status: 500 });
    }
  }

  return new Response(null, { status: 200 });
}
```

Weâ€™ve now successfully sent an external notification to a user!

## Allow users to toggle notifications

Using Liveblocks hooks and methods, itâ€™s possible to create a notifications
settings interface, allowing end users to choose which notifications theyâ€™d like
to receive, and on which channels, saving their preferences.

<Figure>
  <Image
    src="/assets/notifications/notification-settings.jpg"
    alt="Notification settings"
    width={1344}
    height={896}
  />
</Figure>

Learn more in our guide on
[creating a notification settings panel](/docs/guides/how-to-create-a-notification-settings-panel).

## Recap

Great, weâ€™re successfully sending external notifications to users when comments
are left unread! In this guide weâ€™ve learned:

- How to use [webhooks](/docs/platform/webhooks) and the
  [`NotificationEvent`](/docs/platform/webhooks#NotificationEvent).
- How to use the [`@liveblocks/node`](/docs/api-reference/liveblocks-node)
  package to fetch and render unread thread data.
- How to hook it up to an external service, such as Slack.

---
meta:
  title:
    "How to notify users about unread custom notifications outside of your app"
  description:
    "Learn how to trigger custom notifications externally, such as in Slack,
    Microsoft Teams, and more."
---

Liveblocks [Notifications](/docs/ready-made-features/notifications) allows you
to build a notification inbox, and send custom notifications to your users. With
our webhooks and REST API, itâ€™s possible to fetch unread
[custom notifications](/docs/ready-made-features/notifications/concepts#Custom-notifications)
and send external notifications via email, in Slack, in Microsoft Teams, or in
any other service with an API, using webhooks. Notifications can also be
displayed in your app using
[`useInboxNotifications`](/docs/api-reference/liveblocks-react#useInboxNotifications)
and the
[`InboxNotification`](/docs/api-reference/liveblocks-react-ui#InboxNotification)
component.

## What weâ€™re building

In this guide weâ€™ll be learning how to notify users about unread custom
notifications outside of your app, and more specifically, weâ€™ll be looking at
how to:

- Trigger events based on unread custom notifications using the
  [`NotificationEvent`](/docs/platform/webhooks#NotificationEvent) webhook
  event.
- Fetch unread notifications using the
  [`@liveblocks/node`](/docs/api-reference/liveblocks-node) package.

<Banner title="Have a project ready">

This guide assumes you already have a Liveblocks Notifications project set up.
If you donâ€™t have one yet, you can
[get started with Notifications](/docs/get-started/notifications), and come back
after youâ€™re set up.

</Banner>

## What are inbox notifications?

Liveblocks uses the concept of inbox notifications, which differ to external
notifications. Inbox notifications are displayed within in-app inboxes, group
multiple activities together, and can change over time. These activities are
useful for sending status updates, for example seeing â€œPendingâ€¦â€ or â€œCompleteâ€¦â€
statuses in a file upload notification.

External notifications, such as Slack, and Microsoft Teams, are different, and
Liveblocks is set up to send them in a way that wonâ€™t overload your users with
notifications. This means that Liveblocks will wait to trigger these
notifications until a certain amount of time has passed, and will only trigger
them if your users has not read the notification on the front-end, which we
automatically keep track of.

Learn more about Notifications in the
[concepts page](/docs/ready-made-features/notifications/concepts).

## Using webhooks

Liveblocks provides a number of [webhooks](/docs/platform/webhooks) that can
send requests to your API endpoint when certain events occurs. One webhook we
provide is the [`NotificationEvent`](/docs/platform/webhooks#NotificationEvent)
webhook, which is triggered for each participating user in a thread, and can be
used to send external notifications to your users.

The information it returns allows you to retrieve the data attached to the
custom notification. Letâ€™s take a look at how to set this up.

### Notification channels

You can send notifications via different channels, such as email, Slack,
Microsoft Teams, and Web Push. In our dashboard, you can enable notifications on
certain channels, and in this guide, weâ€™ll be enabling a custom `$fileUploaded`
[notification kind](/docs/ready-made-features/notifications/concepts#Notification-kinds)
on the Slack channel. You must always enable the correct channel to ensure your
[`NotificationEvent`](/docs/platform/webhooks#NotificationEvent) webhook events
are triggered, and this guide will take you through setting it up.

<Banner title="Which notification channel?">

All channels currently work the same way, apart from in-app, but we suggest
selecting the service youâ€™re setting up, such as Slack or Microsoft Teams, so
itâ€™s easy to tell which youâ€™ve implemented.

</Banner>

## Create an endpoint in your project

When a webhook event is triggered, it can send a POST request to the back end in
your project. In this guide, weâ€™ll be using a Next.js route handler (API
endpoint) as an example, but other frameworks work similarly.

In order to use webhooks, weâ€™ll need to retrieve the `headers` and `body` from
the request. Hereâ€™s the basic endpoint weâ€™ll be starting from:

```ts
export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Handle webhooks and notifications
  // ...

  return new Response(null, { status: 200 });
}
```

Create this endpoint in your project, and make it available on `localhost` at
the following URL:

```
/api/liveblocks-notifications
```

Make a note of this endpoint URL, as youâ€™ll be using it later.

### Testing webhooks locally

Running webhooks locally can be difficult, but one way to do this is to use a
tool such as [`localtunnel`](https://www.npmjs.com/package/localtunnel) or
[`ngrok`](https://www.npmjs.com/package/ngrok) which allow you to temporarily
put your localhost server online.

If your project is running on `localhost:3000`, you can run the following
command to generate a temporary URL thatâ€™s available while your localhost server
is running:

```bash
npx localtunnel --port 3000
```

`localtunnel` generates a base URL that can be placed into the Liveblocks
webhooks dashboard for quick testing. To use this, take the full address of your
webhook endpoint, and replace the domain in your `localhost` address with the
generated URL.

```shell
# Take your local URL
http://localhost:3000/api/liveblocks-notifications

# Replace localhost with the generated domain, then copy it
https://my-localtunnel-url.loca.lt/api/liveblocks-notifications
```

You now have a URL that can be used in the webhooks dashboard.

## Set up webhooks on the Liveblocks dashboard

To use webhooks, you need to pass your endpoint URL to the webhooks dashboard
inside your Liveblocks project, and tell the webhook to trigger when a comment
has been created.

<Steps>
  <Step>

    <StepTitle>Set up sending a custom notification</StepTitle>
    <StepContent>
      If your app, make sure youâ€™re sending a custom notification with
      [`triggerInboxNotification`](/docs/api-reference/liveblocks-node#post-inbox-notifications-trigger).
      In our example, weâ€™re sending a `$fileUploaded` notification.

      ```ts
      await liveblocks.triggerInboxNotification({
        // +++
        kind: "$fileUploaded",
        // +++
        userId: "steven@example.com",
        subjectId: "my-file",

        activityData: {
          status: "pending",
          file: "https://example.com/my-file.zip",
        },
      });
      ```

    </StepContent>

  </Step>

<Step>
  <StepTitle>Select your project</StepTitle>
  <StepContent>
    From the [Liveblocks dashboard](/dashboard), navigate to the project youâ€™d
    like to use with webhooks, or create a new project.
    <Figure>
      <Image
        src="/assets/tutorials/webhooks/liveblocks-create-project.png"
        alt="Create a Liveblocks project"
        width={712}
        height={445}
      />
    </Figure>
  </StepContent>
</Step>

{" "}

<Step>
  <StepTitle>Go to the notifications dashboard</StepTitle>
  <StepContent>
    Click on the **â€œNotificationsâ€** tab on the menu at the left.
    <Figure>
      <Image
        src="/assets/tutorials/webhooks/liveblocks-click-notifications.png"
        alt="Click notifications"
        width={712}
        height={445}
      />
    </Figure>
  </StepContent>
</Step>

{" "}

<Step>
  <StepTitle>Enable your custom notification kind</StepTitle>
  <StepContent>
    Click on the **â€œEditâ€** at the top right,, switch to the **â€œKindsâ€** tab,
    and enable your custom notification kind. In our example weâ€™re adding the
    `$fileUploaded` kind.
    <Figure>
      <Image
        src="/assets/tutorials/webhooks/liveblocks-notification-kind.png"
        alt="Enable custom notification kind"
        width={712}
        height={445}
      />
    </Figure>
  </StepContent>
</Step>

{" "}

<Step>
  <StepTitle>Enable the thread notification type</StepTitle>
  <StepContent>
    Click on **â€œEditâ€** at the top right, enable `$fileUploaded` notifications
    on the Slack channel, and publish your changes.
    <Figure>
      <Image
        src="/assets/tutorials/webhooks/liveblocks-enable-custom-notification-kind.png"
        alt="Enable custom notification"
        width={712}
        height={445}
      />
    </Figure>
  </StepContent>
</Step>

{" "}

<Step>
  <StepTitle>Go to the webhooks dashboard</StepTitle>
  <StepContent>
    Click on the **â€œWebhooksâ€** tab on the menu at the left.
    <Figure>
      <Image
        src="/assets/tutorials/webhooks/liveblocks-click-webhooks.png"
        alt="Click webhooks"
        width={712}
        height={445}
      />
    </Figure>
  </StepContent>
</Step>

{" "}

<Step>
  <StepTitle>Create an endpoint</StepTitle>
  <StepContent>
    Click the **â€œCreate endpointâ€¦â€** button on the webhooks dashboard to start
    setting up your webhook.
    <Figure>
      <Image
        src="/assets/tutorials/webhooks/liveblocks-add-endpoint.png"
        alt="Click add endpoint"
        width={712}
        height={445}
      />
    </Figure>
  </StepContent>
</Step>

{" "}

<Step>
  <StepTitle>Add your endpoint URL</StepTitle>
  <StepContent>
    Enter the URL of the endpoint. In a production app this will be the real
    endpoint, but for now enter your `localtunnel` URL from earlier.
    <Figure>
      <Image
        src="/assets/tutorials/webhooks/liveblocks-add-endpoint-url.png"
        alt="Add endpoint URL"
        width={712}
        height={445}
      />
    </Figure>
  </StepContent>
</Step>

<Step>
  <StepTitle>Enable notification webhook events</StepTitle>
  <StepContent>
    Check the **â€œnotificationâ€** event in the dialog to enable the correct
    webhooks events.
    <Figure>
      <Image
        src="/assets/tutorials/webhooks/liveblocks-enable-notification-webhook.png"
        alt="Add endpoint URL"
        width={712}
        height={445}
      />
    </Figure>
  </StepContent>
</Step>

<Step>
  <StepTitle>Get your webhook secret key</StepTitle>
  <StepContent>
    Click **Add endpointâ€** at the bottom, then find your **â€œSecret keyâ€** on
    the next page, and copy it.
    <Figure>
      <Image
        src="/assets/tutorials/webhooks/liveblocks-get-secret-key.png"
        alt="Copy your webhook secret key"
        width={710}
        height={445}
      />
    </Figure>
  </StepContent>
</Step>

  <Step lastStep>
    <StepTitle>Webhooks dashboard is set up!</StepTitle>

    <StepContent>
      Notification webhooks are set up! Letâ€™s go back to the
      code.
    </StepContent>

  </Step>
</Steps>

## Verify the webhook request

The [`@liveblocks/node`](/docs/api-reference/liveblocks-node) package provides
you with a function that verifies whether the current request is a real webhook
request from Liveblocks. You can set this up by setting up a
[`WebhookHandler`](/docs/api-reference/liveblocks-node#WebhookHandler) and
running [`verifyRequest`](/docs/api-reference/liveblocks-node#verifyRequest).

Make sure to add your _webhook_ secret key from earlierâ€”in a real project weâ€™d
recommend using an environment variable for this.

```ts highlight="1,3-5,11-21"
import { WebhookHandler } from "@liveblocks/node";

// Add your webhook secret key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_WEBHOOK_SECRET_KEY";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // Send external notification
  // ...

  return new Response(null, { status: 200 });
}
```

## Check the event and notification permissions

After verifying the request, we can then check weâ€™re receiving the correct type
of event, on the correct channel. There are different `notification` events, and
in this case weâ€™d like to check for a
[custom notification](/docs/platform/webhooks#Custom-notification) with the
`$fileUploaded` kind, as weâ€™re specifically listening for this. We can do this
with `event.data.kind`, also making sure to check for the `slack` channel.

```ts
import { WebhookHandler, isCustomNotificationEvent } from "@liveblocks/node";

// Add your webhook secret key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_WEBHOOK_SECRET_KEY";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // +++
  // When a $fileUploaded notification has been created on the slack channel
  if (event.data.kind === "$fileUploaded" && event.data.channel === "slack") {
    const { inboxNotificationId, userId } = event.data;

    // Send external notification
    // ...
  }
  // +++

  return new Response(null, { status: 200 });
}
```

Note that Liveblocks doesnâ€™t have knowledge of your permissions system on the
back end, so itâ€™s your responsibility to check if this user should have access
to the notification.

## Get custom notification data

The next step is to use the
[Liveblocks client](/docs/api-reference/liveblocks-node#Liveblocks-client) from
`@liveblocks/node` to retrieve the inbox notification, and the corresponding
data set with
[`triggerInboxNotification`](/docs/api-reference/liveblocks-node#post-inbox-notifications-trigger).
To do this weâ€™ll need to add our projectâ€™s secret key from
[the dashboard](/dashboard/api-keys) to the Liveblocks client (_not_ the webhook
secret key we used earlier), before awaiting the
[`getInboxNotification`](/docs/api-reference/liveblocks-node#get-users-userId-inboxNotifications-inboxNotificationId)
fucntion.

```ts
import {
  // +++
  Liveblocks,
  // +++
  WebhookHandler,
  isCustomNotificationEvent,
} from "@liveblocks/node";

// Add your webhook secret key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_WEBHOOK_SECRET_KEY";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

// Add your secret key from a project's API keys dashboard
// +++
const API_SECRET = "{{SECRET_KEY}}";
const liveblocks = new Liveblocks({ secret: API_SECRET });
// +++

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // When a $fileUploaded notification has been created on the slack channel
  if (event.data.kind === "$fileUploaded" && event.data.channel === "slack") {
    const { inboxNotificationId, userId } = event.data;

    // +++
    try {
      // Get thread and notification
      const inboxNotification = await liveblocks.getInboxNotification({
        inboxNotificationId,
        userId,
      });

      // The custom data we set with `triggerInboxNotification`: `status` and `file`
      const { status, file } = inboxNotification.activities[0];

      // Send external notification
      // ...
    } catch (err) {
      console.log(err);
      return new Response("Could not fetch notification data", { status: 500 });
    }
    // +++
  }

  return new Response(null, { status: 200 });
}
```

## Send external notifications

Now that the custom notification has been retrieved, we can send the external
notifications. In this example, weâ€™re sending a message to an incoming webhook
in Slack.

```ts
import {
  Liveblocks,
  WebhookHandler,
  isCustomNotificationEvent,
} from "@liveblocks/node";

// Add your webhook secret key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_WEBHOOK_SECRET_KEY";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

// Add your secret key from a project's API keys dashboard
const API_SECRET = "{{SECRET_KEY}}";
const liveblocks = new Liveblocks({ secret: API_SECRET });

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // When a $fileUploaded notification has been created on the slack channel
  if (event.data.kind === "$fileUploaded" && event.data.channel === "slack") {
    const { inboxNotificationId, userId } = event.data;

    try {
      // Get thread and notification
      const inboxNotification = await liveblocks.getInboxNotification({
        inboxNotificationId,
        userId,
      });

      // The custom data we set with `triggerInboxNotification`: `status` and `file`
      const { status, file } = inboxNotification.activities[0];

      // Send your external notification, e.g. to Slack
      // +++
      await fetch(
        "https://hooks.slack.com/services/T00000000/B00000000/XXXXXXXXXXXXXXXXXXXXXXXX",
        {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            text: `A new file has been uploaded by ${userId}: ${file}`,
            username: `File Upload Bot`,
          }),
        }
      );
      // +++
    } catch (err) {
      console.log(err);
      return new Response("Could not fetch notification data", { status: 500 });
    }
  }

  return new Response(null, { status: 200 });
}
```

Weâ€™ve now successfully sent an external notification to a user!

## Allow users to toggle notifications

Using Liveblocks hooks and methods, itâ€™s possible to create a notifications
settings interface, allowing end users to choose which notifications theyâ€™d like
to receive, and on which channels, saving their preferences.

<Figure>
  <Image
    src="/assets/notifications/notification-settings.jpg"
    alt="Notification settings"
    width={1344}
    height={896}
  />
</Figure>

Learn more in our guide on
[creating a notification settings panel](/docs/guides/how-to-create-a-notification-settings-panel).

## Recap

Great, weâ€™re successfully sending external notifications to users when comments
are left unread! In this guide weâ€™ve learned:

- How to use [webhooks](/docs/platform/webhooks) and the
  [`NotificationEvent`](/docs/platform/webhooks#NotificationEvent).
- How to use the [`@liveblocks/node`](/docs/api-reference/liveblocks-node)
  package to fetch the custome notification data.
- How to hook it up to an external service, such as Slack.

---
meta:
  title:
    "How to migrate your existing rooms IDs to use access token naming patterns"
  description:
    "Learn how to migrate your current rooms IDs to match access token naming
    patterns."
---

When using [access token authentication](/docs/authentication/access-token) we
recommend using a naming pattern for your room IDs. If youâ€™ve already created
rooms, itâ€™s possible to rename them with `@liveblocks/node` or our REST API.

## Update your room IDs

To rename a room ID, you can use the
[liveblocks.updateRoomId](/docs/api-reference/liveblocks-node#post-rooms-update-roomId)
endpoint to update a room ID.

```ts
import { Liveblocks } from "@liveblocks/node";

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

const room = await liveblocks.updateRoomId({
  roomId: "my-room-id",
  newRoomId: "new-room-id",
});

// { type: "room", id: "new-room-id", ... }
console.log(room);
```

When you change a room ID, currently connected users will disconnect, but there
is a way around this.

## Handle active users connected to a room

To avoid users disconnecting after the change, you can listen for a room ID
changed error, `4006`, with
[`useErrorListener`](/docs/api-reference/liveblocks-react#useErrorListener) or
[`room.subscribe("error")`](/docs/api-reference/liveblocks-client#Room.subscribe.error).
This error is sent immediately after the ID is changed, and it returns the new
room ID inside `error.message`. You can use this the new ID to redirect users to
the new location of the room in your application.

```tsx
import { useErrorListener } from "../liveblocks.config";

function App() {
  useErrorListener((error) => {
    if (error.context.code === 4006) {
      // Room ID has been changed, get the new ID and redirect
      const newRoomId = error.message;
      __redirect__(`https://example.com/document/${newRoomId}`);
    }
  });
}
```

After implementing this, you can safely update the room ID, and users will be
immediately redirected to the new location.

---
meta:
  title: "How to send email notifications for unread text editor mentions"
  description:
    "Learn how to automatically send email notifications when a text mention or
    is created with Liveblocks Text Editor."
---

Liveblocks allows you to embed a text editing experience with
[Text Editor](/docs/ready-made-features/text-editor) using Tiptap or Lexical.
Using our webhooks and REST API, itâ€™s possible get unread text mentions and use
them to email users when theyâ€™re mentioned in a document. Notifications can also
be displayed in your app using
[`useInboxNotifications`](/docs/api-reference/liveblocks-react#useInboxNotifications)
and the
[`InboxNotification`](/docs/api-reference/liveblocks-react-ui#InboxNotification)
component.

<Figure>
  <Image
    src="/assets/emails/new-text-mention-email.png"
    alt="An email showing a text mention in a text editor document"
    width={1126}
    height={470}
  />
</Figure>

<Banner title="Ready-made email templates">

We have two examples containing ready-made email templates, built with React
Email. These are great starting points for your Text Editor notification emails:
[Tiptap emails example](/examples/collaborative-text-editor-emails/nextjs-tiptap-emails-resend),
[Lexical emails example](/examples/collaborative-text-editor-emails/nextjs-lexical-emails-resend).

</Banner>

## What weâ€™re building

In this guide weâ€™ll be learning how to send text mentions notifications, and
more specifically, weâ€™ll be looking at how to:

- Trigger events based on unread comments using the
  [`NotificationEvent`](/docs/platform/webhooks#NotificationEvent) webhook
  event.
- Fetch unread text mention and add styles to the surrounding text using the
  [`@liveblocks/emails`](/docs/api-reference/liveblocks-emails) package.
- Send an email notification containing the mention and its surrounding text
  with [Resend](https://resend.com/).

<Banner title="Have a project ready">

This guide assumes you already have a Liveblocks Text Editor project set up. If
you donâ€™t have one yet, you can get started with
[Lexical](/docs/get-started/text-editor/lexical) or
[Tiptap](/docs/get-started/text-editor/tiptap), and come back after youâ€™re set
up. You could also use our
[ready-made email examples](/examples/collaborative-text-editor-emails) which
have this set up already, along with some email templates.

</Banner>

## What are inbox notifications?

Email notifications are built around the concept of inbox notifications, which
are different from â€œnormalâ€ notifications in the sense that they can group
multiple activities together and evolve over time. This makes more sense when
sending email notifications because it helps to avoid flooding your users with
too many emails.

Learn more about Notifications for Lexical Text Editor in the
[overview page](/docs/ready-made-features/text-editor/lexical#Notifications).

## Using webhooks

Liveblocks provides a number of [webhooks](/docs/platform/webhooks) that can
send requests to your API endpoint when certain events occurs. One webhook we
provide is the [`NotificationEvent`](/docs/platform/webhooks#NotificationEvent)
webhook, which is triggered for each mentioned users in a document, 30 minutes
after activity has occurred, and this can be used to send emails to your users.

The information it returns allows you to retrieve a text mention that have not
yet been read by the user. Letâ€™s take a look at how to set this up.

### Notification channels

You can send notifications via different channels, such as email, Slack,
Microsoft Teams, and Web Push. In our dashboard, you can enable notifications on
certain channels, and in this case, weâ€™ll be using the email channel. You must
always enable the correct channel to ensure your
[`NotificationEvent`](/docs/platform/webhooks#NotificationEvent) webhook events
are triggered, and this guide will take you through setting it up.

## Create an endpoint in your project

When a webhook event is triggered, it can send a POST request to the back end in
your project. In this guide, weâ€™ll be using a Next.js route handler (API
endpoint) as an example, but other frameworks work similarly.

In order to use webhooks, weâ€™ll need to retrieve the `headers` and `body` from
the request. Hereâ€™s the basic endpoint weâ€™ll be starting from:

```ts
export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Handle webhooks and notifications
  // ...

  return new Response(null, { status: 200 });
}
```

Create this endpoint in your project, and make it available on `localhost` at
the following URL:

```
/api/liveblocks-notifications
```

Make a note of this endpoint URL, as youâ€™ll be using it later.

### Testing webhooks locally

Running webhooks locally can be difficult, but one way to do this is to use a
tool such as [`localtunnel`](https://www.npmjs.com/package/localtunnel) or
[`ngrok`](https://www.npmjs.com/package/ngrok) which allow you to temporarily
put your localhost server online.

If your project is running on `localhost:3000`, you can run the following
command to generate a temporary URL thatâ€™s available while your localhost server
is running:

```bash
npx localtunnel --port 3000
```

`localtunnel` generates a base URL that can be placed into the Liveblocks
webhooks dashboard for quick testing. To use this, take the full address of your
webhook endpoint, and replace the domain in your `localhost` address with the
generated URL.

```shell
# Take your local URL
http://localhost:3000/api/liveblocks-notifications

# Replace localhost with the generated domain, then copy it
https://my-localtunnel-url.loca.lt/api/liveblocks-notifications
```

You now have a URL that can be used in the webhooks dashboard.

## Set up webhooks on the Liveblocks dashboard

To use webhooks, you need to pass your endpoint URL to the webhooks dashboard
inside your Liveblocks project, and tell the webhook to trigger when a comment
has been created.

<Steps>
  <Step>
    <StepTitle>Select your project</StepTitle>
    <StepContent>
      From the [Liveblocks dashboard](/dashboard), navigate to the project youâ€™d
      like to use with webhooks, or create a new project.
      <Figure>
        <Image
          src="/assets/tutorials/webhooks/liveblocks-create-project.png"
          alt="Create a Liveblocks project"
          width={712}
          height={445}
        />
      </Figure>
    </StepContent>
  </Step>

<Step>
  <StepTitle>Go to the notifications dashboard</StepTitle>
  <StepContent>
    Click on the **â€œNotificationsâ€** tab on the menu at the left.
    <Figure>
      <Image
        src="/assets/tutorials/webhooks/liveblocks-click-notifications.png"
        alt="Click notifications"
        width={712}
        height={445}
      />
    </Figure>
  </StepContent>
</Step>

<Step>
  <StepTitle>Enable the textMention notification type</StepTitle>
  <StepContent>
    Click on **â€œEditâ€** at the top right, enable `textMention` notifications on
    the email channel, and publish your changes.
    <Figure>
      <Image
        src="/assets/tutorials/webhooks/liveblocks-enable-textMention-notification.png"
        alt="Enable textMention notifications"
        width={712}
        height={445}
      />
    </Figure>
  </StepContent>
</Step>

<Step>
  <StepTitle>Go to the webhooks dashboard</StepTitle>
  <StepContent>
    Click on the **â€œWebhooksâ€** tab on the menu at the left.
    <Figure>
      <Image
        src="/assets/tutorials/webhooks/liveblocks-click-webhooks.png"
        alt="Click webhooks"
        width={712}
        height={445}
      />
    </Figure>
  </StepContent>
</Step>

<Step>
  <StepTitle>Create an endpoint</StepTitle>
  <StepContent>
    Click the **â€œCreate endpointâ€¦â€** button on the webhooks dashboard to start
    setting up your webhook.
    <Figure>
      <Image
        src="/assets/tutorials/webhooks/liveblocks-add-endpoint.png"
        alt="Click add endpoint"
        width={712}
        height={445}
      />
    </Figure>
  </StepContent>
</Step>

<Step>
  <StepTitle>Add your endpoint URL</StepTitle>
  <StepContent>
    Enter the URL of the endpoint. In a production app this will be the real
    endpoint, but for now enter your `localtunnel` URL from earlier.
    <Figure>
      <Image
        src="/assets/tutorials/webhooks/liveblocks-add-endpoint-url.png"
        alt="Add endpoint URL"
        width={712}
        height={445}
      />
    </Figure>
  </StepContent>
</Step>

<Step>
  <StepTitle>Get your webhook secret key</StepTitle>
  <StepContent>
    Click **â€œCreate endpointâ€** at the bottom, then find your **â€œSecret keyâ€**
    on the next page, and copy it.
    <Figure>
      <Image
        src="/assets/tutorials/webhooks/liveblocks-get-secret-key.png"
        alt="Copy your webhook secret key"
        width={710}
        height={445}
      />
    </Figure>
  </StepContent>
</Step>

  <Step lastStep>
    <StepTitle>Webhooks dashboard is set up!</StepTitle>

    <StepContent>
      Note that you can filter specifically for `notification` events, but weâ€™re
      ignoring this for now so we can test more easily. Letâ€™s go back to the
      code.
    </StepContent>

  </Step>
</Steps>

## Verify the webhook request

The [`@liveblocks/node`](/docs/api-reference/liveblocks-node) package provides
you with a function that verifies whether the current request is a real webhook
request from Liveblocks. You can set this up by setting up a
[`WebhookHandler`](/docs/api-reference/liveblocks-node#WebhookHandler) and
running [`verifyRequest`](/docs/api-reference/liveblocks-node#verifyRequest).

Make sure to add your â€œWebhook secret keyâ€ from the Liveblocks dashboardâ€”in a
real project weâ€™d recommend using an environment variable for this.

```ts highlight="1,3-5,11-21"
import { WebhookHandler } from "@liveblocks/node";

// Add your webhook secret key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_WEBHOOK_SECRET_KEY";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // Send notifications
  // ...

  return new Response(null, { status: 200 });
}
```

## Check the event and notification permissions

After verifying the request, we can then check weâ€™re receiving the correct type
of event on the correct channel. There are different `notification` events, and
in this case weâ€™d like to check for
[text mention notification](/docs/platform/webhooks#TextMention-notification),
as weâ€™re specifically listening for new text mentions. We can do this using
[`isTextMentionNotificationEvent`](/docs/api-reference/liveblocks-node#isTextMentionNotificationEvent),
making sure to check for the `email` channel.

```ts
import {
  WebhookHandler,
  isTextMentionNotificationEvent,
} from "@liveblocks/node";

// Add your webhook secret key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_WEBHOOK_SECRET_KEY";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // +++
  // When an inbox notification has been created on the email channel
  if (isTextMentionNotificationEvent(event) && event.data.channel === "email") {
    // Check if user has access to room
    if (!__hasRoomAccess__(event.userId, event.roomId)) {
      return new Response(null, { status: 200 });
    }

    // The user to send the email to
    const emailAddress = __getEmailAddressFromDB__(event.userId);

    // Send notifications
    // ...
  }
  // +++

  return new Response(null, { status: 200 });
}
```

Note that weâ€™re also checking if the user should receive a notification, and
getting their email addressâ€”Liveblocks doesnâ€™t have knowledge of your
permissions system on the back end, so itâ€™s your responsibility to check if this
user should have access to the room.

## Fetching data for emails

[`@liveblocks/emails`](/docs/api-reference/liveblocks-emails) provides functions
for fetching unread text mentions and styling emails, returning them as either
React components or an HTML string. In this guide weâ€™ll use the React function,
but the HTML function works almost identically, so you can still follow along if
youâ€™d prefer HTML emails.

First set up your
[`Liveblocks`](/docs/api-reference/liveblocks-node#Liveblocks-client) Node.js
client and wrap
[`prepareTextMentionNotificationEmailAsReact`](/docs/api-reference/liveblocks-emails#prepare-text-mention-notification-email-as-react)
in `try/catch`, getting the data for the email.

<Banner>

If youâ€™d prefer your email content as an HTML string, use
[`prepareTextMentionNotificationEmailAsHtml`](/docs/api-reference/liveblocks-emails#prepare-text-mention-notification-email-as-html).

</Banner>

```ts
import {
  // +++
  Liveblocks,
  // +++
  WebhookHandler,
  isTextMentionNotificationEvent,
} from "@liveblocks/node";
// +++
import { prepareTextMentionNotificationEmailAsReact } from "@liveblocks/emails";
// +++

// Add your webhook secret key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_WEBHOOK_SECRET_KEY";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

// +++
// Add your secret key from a project's API keys dashboard
const API_SECRET = "{{SECRET_KEY}}";
const liveblocks = new Liveblocks({ secret: API_SECRET });
// +++

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // When an inbox notification has been created on the email channel
  if (isTextMentionNotificationEvent(event) && event.data.channel === "email") {
    // Check if user has access to room
    if (!__hasRoomAccess__(event.userId, event.roomId)) {
      return new Response(null, { status: 200 });
    }

    // The user to send the email to
    const emailAddress = __getEmailAddressFromDB__(event.userId);

    // +++
    let emailData;

    try {
      emailData = await prepareTextMentionNotificationEmailAsReact(
        liveblocks,
        event
      );
    } catch (err) {
      console.log(err);
      return new Response("Could not fetch text mention notification data", {
        status: 500,
      });
    }

    // The text mention has already been read
    if (!emailData) {
      return new Response(null, { status: 200 });
    }

    // Create email
    // ...
    // +++
  }

  return new Response(null, { status: 200 });
}
```

## Create the emails

Next, we need to create the emails with React, using `emailData` to build the
content.

```tsx
import {
  Liveblocks,
  WebhookHandler,
  isTextMentionNotificationEvent,
} from "@liveblocks/node";
import { prepareTextMentionNotificationEmailAsReact } from "@liveblocks/emails";

// Add your webhook secret key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_WEBHOOK_SECRET_KEY";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

// Add your secret key from a project's API keys dashboard
const API_SECRET = "{{SECRET_KEY}}";
const liveblocks = new Liveblocks({ secret: API_SECRET });

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // When an inbox notification has been created on the email channel
  if (isTextMentionNotificationEvent(event) && event.data.channel === "email") {
    // Check if user has access to room
    if (!__hasRoomAccess__(event.userId, event.roomId)) {
      return new Response(null, { status: 200 });
    }

    // The user to send the email to
    const emailAddress = __getEmailAddressFromDB__(event.userId);

    let emailData;

    try {
      emailData = await prepareTextMentionNotificationEmailAsReact(
        liveblocks,
        event
      );
    } catch (err) {
      console.log(err);
      return new Response("Could not fetch text mention notification data", {
        status: 500,
      });
    }

    // The text mention has already been read
    if (!emailData) {
      return new Response(null, { status: 200 });
    }

    // +++
    const email = (
      <div>
        <div>
          @{emailData.mention.author.id} at {emailData.mention.createdAt}
        </div>
        <div>{emailData.mention.content}</div>
      </div>
    );
    // +++

    // Send emails
    // ...
  }

  return new Response(null, { status: 200 });
}
```

## Resolving data

Weâ€™ve now fully created a basic React email, and itâ€™s ready to send. However,
weâ€™re displaying each userâ€™s ID, and not their names. We can go back to
[`prepareTextMentionNotificationEmailAsReact`](/docs/api-reference/liveblocks-emails#prepare-text-mention-notification-email-as-react)
and use resolver functions to transform an ID into a name, for example
`chris@example.com` -> `Chris`. These functions work similarly to
[resolvers on the client](/docs/api-reference/liveblocks-react#LiveblocksProviderResolveUsers).

```tsx
// ...

emailData = await prepareTextMentionNotificationEmailAsReact(
  liveblocks,
  event,
  {
    // +++
    resolveUsers: async ({ userIds }) => {
      const usersData = await __getUsersFromDB__(userIds);

      return usersData.map((userData) => ({
        name: userData.name, // "Chris"
        avatar: userData.avatar.src, // "https://example.com/chris.jpg"
      }));
    },
    resolveRoomInfo: async ({ roomId }) => {
      const roomData = await __getRoomFromDB__(roomId);

      return {
        name: roomData.name, // "Untitled document"
        url: roomData.url, //`https://example.com/my-room-id`
      };
    },
    // +++
  }
);

// ...
```

## Customizing text mention and surrounding text components

We can also edit `prepareTextMentionNotificationEmailAsReact` to allow for
[custom components](/docs/api-reference/liveblocks-emails#prepare-text-mention-notification-email-as-react-customizing-components)
for the text mention and its surrounding text, for example we can customize the
container, color mentions, and modify fonts.

```tsx
// ...

emailData = await prepareTextMentionNotificationEmailAsReact(
  liveblocks,
  event,
  {
    resolveUsers: async ({ userIds }) => {
      const usersData = await __getUsersFromDB__(userIds);

      return usersData.map((userData) => ({
        name: userData.name, // "Chris"
        avatar: userData.avatar.src, // "https://example.com/chris.jpg"
      }));
    },
    resolveRoomInfo: async ({ roomId }) => {
      const roomData = await __getRoomFromDB__(roomId);

      return {
        name: roomData.name, // "Untitled document"
        url: roomData.url, //`https://example.com/my-room-id`
      };
    },
    // +++
    components: {
      Container: ({ children }) => (
        <main style={{ margin: "12px 0" }}>{children}</main>
      ),

      // `user` is the optional data returned from `resolveUsers`
      Mention: ({ element, user }) => (
        <span style={{ color: "red" }}>@{user?.name ?? element.id}</span>
      ),

      Text: ({ children }) => (
        <p style={{ fontSize: "16px", fontStyle: "italic" }}>{children}</p>
      ),
    },
    // +++
  }
);

// ...
```

Any component can be passed here, including those used in
[`react-email`](https://react.email/),
[learn more](/docs/api-reference/liveblocks-emails#prepare-text-mention-notification-email-as-react-customizing-components).

<Banner>

If youâ€™re using HTML instead of React, you can
[apply custom CSS properties](/docs/api-reference/liveblocks-emails#prepare-text-mention-notification-email-as-html-styling-elements).

</Banner>

## Send notification emails

Now that the React code has been generated, we can send the notification emails.
[Resend](https://resend.com) is a great tool for easily sending emails, and in
this code example, weâ€™re using it to send notifications to each user. Make sure
to add your API key from the [Resend dashboard](https://resend.com/overview)
before running the code.

```tsx
import {
  Liveblocks,
  WebhookHandler,
  isTextMentionNotificationEvent,
} from "@liveblocks/node";
import { prepareTextMentionNotificationEmailAsReact } from "@liveblocks/emails";
// +++
import { Resend } from "resend";
// +++

// +++
// Create Resend client (add your API key)
const resend = new Resend("re_123456789");
// +++

// Add your webhook secret key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_WEBHOOK_SECRET_KEY";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

// Add your secret key from a project's API keys dashboard
const API_SECRET = "{{SECRET_KEY}}";
const liveblocks = new Liveblocks({ secret: API_SECRET });

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // When an inbox notification has been created on the email channel
  if (isTextMentionNotificationEvent(event) && event.data.channel === "email") {
    // Check if user has access to room
    if (!__hasRoomAccess__(event.userId, event.roomId)) {
      return new Response(null, { status: 200 });
    }

    // The user to send the email to
    const emailAddress = __getEmailAddressFromDB__(event.userId);

    let emailData;

    try {
      emailData = await prepareTextMentionNotificationEmailAsReact(
        liveblocks,
        event,
        {
          resolveUsers: async ({ userIds }) => {
            const usersData = await __getUsersFromDB__(userIds);

            return usersData.map((userData) => ({
              name: userData.name, // "Chris"
              avatar: userData.avatar.src, // "https://example.com/chris.jpg"
            }));
          },
          resolveRoomInfo: async ({ roomId }) => {
            const roomData = await __getRoomFromDB__(roomId);

            return {
              name: roomData.name, // "Untitled document"
              url: roomData.url, //`https://example.com/my-room-id`
            };
          },
          components: {
            Container: ({ children }) => (
              <main style={{ margin: "12px 0" }}>{children}</main>
            ),

            // `user` is the optional data returned from `resolveUsers`
            Mention: ({ element, user }) => (
              <span style={{ color: "red" }}>@{user?.name ?? element.id}</span>
            ),
          },
        }
      );
    } catch (err) {
      console.log(err);
      return new Response("Could not fetch text mention notification data", {
        status: 500,
      });
    }

    // The text mention has already been read
    if (!emailData) {
      return new Response(null, { status: 200 });
    }

    const email = (
      <div>
        <div>
          @{emailData.mention.author.id} at {emailData.mention.createdAt}
        </div>
        <div>{emailData.mention.content}</div>
      </div>
    );

    // +++
    // Send email to the user's email address
    try {
      const data = await resend.emails.send({
        from: "My company <hello@my-company.com>",
        to: emailAddress,
        subject: "New text mention",
        react: email,
      });
    } catch (err) {
      console.error(err);
    }
    // +++
  }

  return new Response(null, { status: 200 });
}
```

## Allow users to toggle notifications

Using Liveblocks hooks and methods, itâ€™s possible to create a notifications
settings interface, allowing end users to choose which notifications theyâ€™d like
to receive, and on which channels, saving their preferences.

<Figure>
  <Image
    src="/assets/notifications/notification-settings.jpg"
    alt="Notification settings"
    width={1344}
    height={896}
  />
</Figure>

Learn more in our guide on
[creating a notification settings panel](/docs/guides/how-to-create-a-notification-settings-panel).

## Recap

Great, weâ€™re successfully sending email notifications after new text mentions
are created! In this guide weâ€™ve learned:

- How to use [webhooks](/docs/platform/webhooks) and the
  [`NotificationEvent`](/docs/platform/webhooks#NotificationEvent).
- How to use the [`@liveblocks/emails`](/docs/api-reference/liveblocks-emails)
  package to fetch and render unread text mention data.
- How to send email notifications with [Resend](https://resend.com).

---
meta:
  title: "How to send email notifications of unread comments"
  description:
    "Learn how to automatically send email notifications of unread comments."
---

Liveblocks [Comments](/docs/ready-made-features/comments) allows you to build a
commenting experience. With our webhooks and REST API, itâ€™s possible to
aggregate a list of unread comments from the last 30 minutes into a single
email, and send it to your users. Notifications can also be displayed in your
app using
[`useInboxNotifications`](/docs/api-reference/liveblocks-react#useInboxNotifications)
and the
[`InboxNotification`](/docs/api-reference/liveblocks-react-ui#InboxNotification)
component.

<Figure>
  <Image
    src="/assets/emails/new-comments-email.png"
    alt="An email showing 7 new comments, with comment bodies and links to each comment"
    width={1567}
    height={830}
  />
</Figure>

<Banner title="Ready-made email templates">

We have an example containing ready-made email templates, built with React
Email. This a great starting point for your Comments notification emails:
[Comments emails example](/examples/comments-emails/nextjs-comments-emails-resend).
We also have a second example that shows you how to
[send simple HTML emails](/examples/comments-emails/nextjs-comments-emails-sendgrid).

</Banner>

## What weâ€™re building

In this guide weâ€™ll be learning how to send emails notifying users about unread
comments, and more specifically, weâ€™ll be looking at how to:

- Trigger events based on unread comments using the
  [`NotificationEvent`](/docs/platform/webhooks#NotificationEvent) webhook
  event.
- Fetch unread comments and add styles to comment text using the
  [`@liveblocks/emails`](/docs/api-reference/liveblocks-emails) package.
- Send an email notification containing a list of unread comments in thread
  format with [Resend](https://resend.com/).

<Banner title="Have a project ready">

This guide assumes you already have a Liveblocks Comments project set up. If you
donâ€™t have one yet, you can
[get started with Comments](/docs/get-started/comments), and come back after
youâ€™re set up. You could also use our
[Comments emails example](/examples/comments-emails/nextjs-comments-emails-resend)
which has this set up already, alongside ready-made email templates.

</Banner>

## What are inbox notifications?

Email notifications are built around the concept of inbox notifications, which
are different from â€œnormalâ€ notifications in the sense that they can group
multiple activities together and evolve over time, which makes more sense when
sending email notifications because it helps to avoid sending too many emails.
In the case of Comments, inbox notifications are grouped per thread, which means
that if there are 4 new comments in a thread youâ€™re participating in, you will
have a single inbox notification for it, instead of 4 â€œnormalâ€ notifications.

Learn more about Notifications for Comments in the
[overview page](/docs/ready-made-features/comments/email-notifications).

## Using webhooks

Liveblocks provides a number of [webhooks](/docs/platform/webhooks) that can
send requests to your API endpoint when certain events occurs. One webhook we
provide is the [`NotificationEvent`](/docs/platform/webhooks#NotificationEvent)
webhook, which is triggered for each participating user in a thread, 30 minutes
after activity has occurred, and this can be used to send emails to your users.

The information it returns allows you to retrieve comments that have not yet
been read by the user, making it possible to aggregate multiple unread comments
into a single notification email. Letâ€™s take a look at how to set this up.

### Notification channels

You can send notifications via different channels, such as email, Slack,
Microsoft Teams, and Web Push. In our dashboard, you can enable notifications on
certain channels, and in this case, weâ€™ll be using the email channel. You must
always enable the correct channel to ensure your
[`NotificationEvent`](/docs/platform/webhooks#NotificationEvent) webhook events
are triggered, and this guide will take you through setting it up.

## Create an endpoint in your project

When a webhook event is triggered, it can send a POST request to the back end in
your project. In this guide, weâ€™ll be using a Next.js route handler (API
endpoint) as an example, but other frameworks work similarly.

In order to use webhooks, weâ€™ll need to retrieve the `headers` and `body` from
the request. Hereâ€™s the basic endpoint weâ€™ll be starting from:

```ts
export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Handle webhooks and notifications
  // ...

  return new Response(null, { status: 200 });
}
```

Create this endpoint in your project, and make it available on `localhost` at
the following URL:

```
/api/liveblocks-notifications
```

Make a note of this endpoint URL, as youâ€™ll be using it later.

### Testing webhooks locally

Running webhooks locally can be difficult, but one way to do this is to use a
tool such as [`localtunnel`](https://www.npmjs.com/package/localtunnel) or
[`ngrok`](https://www.npmjs.com/package/ngrok) which allow you to temporarily
put your localhost server online.

If your project is running on `localhost:3000`, you can run the following
command to generate a temporary URL thatâ€™s available while your localhost server
is running:

```bash
npx localtunnel --port 3000
```

`localtunnel` generates a base URL that can be placed into the Liveblocks
webhooks dashboard for quick testing. To use this, take the full address of your
webhook endpoint, and replace the domain in your `localhost` address with the
generated URL.

```shell
# Take your local URL
http://localhost:3000/api/liveblocks-notifications

# Replace localhost with the generated domain, then copy it
https://my-localtunnel-url.loca.lt/api/liveblocks-notifications
```

You now have a URL that can be used in the webhooks dashboard.

## Set up webhooks on the Liveblocks dashboard

To use webhooks, you need to pass your endpoint URL to the webhooks dashboard
inside your Liveblocks project, and tell the webhook to trigger when a comment
has been created.

<Steps>
  <Step>
    <StepTitle>Select your project</StepTitle>
    <StepContent>
      From the [Liveblocks dashboard](/dashboard), navigate to the project youâ€™d
      like to use with webhooks, or create a new project.
      <Figure>
        <Image
          src="/assets/tutorials/webhooks/liveblocks-create-project.png"
          alt="Create a Liveblocks project"
          width={712}
          height={445}
        />
      </Figure>
    </StepContent>
  </Step>

<Step>
  <StepTitle>Go to the notifications dashboard</StepTitle>
  <StepContent>
    Click on the **â€œNotificationsâ€** tab on the menu at the left.
    <Figure>
      <Image
        src="/assets/tutorials/webhooks/liveblocks-click-notifications.png"
        alt="Click notifications"
        width={712}
        height={445}
      />
    </Figure>
  </StepContent>
</Step>

<Step>
  <StepTitle>Enable the thread notification type</StepTitle>
  <StepContent>
    Click on **â€œEditâ€** at the top right, enable `thread` notifications on the
    email channel, and publish your changes.
    <Figure>
      <Image
        src="/assets/tutorials/webhooks/liveblocks-enable-thread-notification.png"
        alt="Enable thread notifications"
        width={712}
        height={445}
      />
    </Figure>
  </StepContent>
</Step>

<Step>
  <StepTitle>Go to the webhooks dashboard</StepTitle>
  <StepContent>
    Click on the **â€œWebhooksâ€** tab on the menu at the left.
    <Figure>
      <Image
        src="/assets/tutorials/webhooks/liveblocks-click-webhooks.png"
        alt="Click webhooks"
        width={712}
        height={445}
      />
    </Figure>
  </StepContent>
</Step>

<Step>
  <StepTitle>Create an endpoint</StepTitle>
  <StepContent>
    Click the **â€œCreate endpointâ€¦â€** button on the webhooks dashboard to start
    setting up your webhook.
    <Figure>
      <Image
        src="/assets/tutorials/webhooks/liveblocks-add-endpoint.png"
        alt="Click add endpoint"
        width={712}
        height={445}
      />
    </Figure>
  </StepContent>
</Step>

<Step>
  <StepTitle>Add your endpoint URL</StepTitle>
  <StepContent>
    Enter the URL of the endpoint. In a production app this will be the real
    endpoint, but for now enter your `localtunnel` URL from earlier.
    <Figure>
      <Image
        src="/assets/tutorials/webhooks/liveblocks-add-endpoint-url.png"
        alt="Add endpoint URL"
        width={712}
        height={445}
      />
    </Figure>
  </StepContent>
</Step>

<Step>
  <StepTitle>Get your webhook secret key</StepTitle>
  <StepContent>
    Click **â€œCreate endpointâ€** at the bottom, then find your **â€œSecret keyâ€**
    on the next page, and copy it.
    <Figure>
      <Image
        src="/assets/tutorials/webhooks/liveblocks-get-secret-key.png"
        alt="Copy your webhook secret key"
        width={710}
        height={445}
      />
    </Figure>
  </StepContent>
</Step>

  <Step lastStep>
    <StepTitle>Webhooks dashboard is set up!</StepTitle>

    <StepContent>
      Note that you can filter specifically for `notification` events, but weâ€™re
      ignoring this for now so we can test more easily. Letâ€™s go back to the
      code.
    </StepContent>

  </Step>
</Steps>

## Verify the webhook request

The [`@liveblocks/node`](/docs/api-reference/liveblocks-node) package provides
you with a function that verifies whether the current request is a real webhook
request from Liveblocks. You can set this up by setting up a
[`WebhookHandler`](/docs/api-reference/liveblocks-node#WebhookHandler) and
running [`verifyRequest`](/docs/api-reference/liveblocks-node#verifyRequest).

Make sure to add your â€œWebhook secret keyâ€ from the Liveblocks dashboardâ€”in a
real project weâ€™d recommend using an environment variable for this.

```ts highlight="1,3-5,11-21"
import { WebhookHandler } from "@liveblocks/node";

// Add your webhook secret key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_WEBHOOK_SECRET_KEY";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // Send notifications
  // ...

  return new Response(null, { status: 200 });
}
```

## Check the event and notification permissions

After verifying the request, we can then check weâ€™re receiving the correct type
of event, on the correct channel. There are different `notification` events, and
in this case weâ€™d like to check for
[thread notification](/docs/platform/webhooks#Thread-notification), as weâ€™re
specifically listening for new comments. We can do this using
[`ThreadNotificationEvent`](/docs/api-reference/liveblocks-node#isThreadNotificationEvent),
making sure to check for the `email` channel.

```ts
import { WebhookHandler, isThreadNotificationEvent } from "@liveblocks/node";

// Add your webhook secret key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_WEBHOOK_SECRET_KEY";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // +++
  // When an inbox notification has been created on the email channel
  if (isThreadNotificationEvent(event) && event.data.channel === "email") {
    // Check if user has access to room
    if (!__hasRoomAccess__(event.userId, event.roomId)) {
      return new Response(null, { status: 200 });
    }

    // The user to send the email to
    const emailAddress = __getEmailAddressFromDB__(event.userId);

    // Send notifications
    // ...
  }
  // +++

  return new Response(null, { status: 200 });
}
```

Note that weâ€™re also checking if the user should receive a notification, and
getting their email addressâ€”Liveblocks doesnâ€™t have knowledge of your
permissions system on the back end, so itâ€™s your responsibility to check if this
user should have access to the room.

## Fetching data for emails

[`@liveblocks/emails`](/docs/api-reference/liveblocks-emails) provides functions
for fetching unread comments and styling emails, returning them as either React
components or an HTML string. In this guide weâ€™ll use the React function, but
the HTML function works almost identically, so you can still follow along if
youâ€™d prefer HTML emails.

<Figure>
  <Image
    src="/assets/emails/new-comments-email.png"
    alt="An email showing 7 new comments, with comment bodies and links to each comment"
    width={1567}
    height={830}
  />
</Figure>

First set up your
[`Liveblocks`](/docs/api-reference/liveblocks-node#Liveblocks-client) Node.js
client and wrap
[`prepareThreadNotificationEmailAsReact`](/docs/api-reference/liveblocks-emails#prepare-thread-notification-email-as-react)
in `try/catch`, getting the data for the email.

<Banner>

If youâ€™d prefer your email content as an HTML string, use
[`prepareThreadNotificationEmailAsHtml`](/docs/api-reference/liveblocks-emails#prepare-thread-notification-email-as-html).

</Banner>

```ts
import {
  // +++
  Liveblocks,
  // +++
  WebhookHandler,
  isThreadNotificationEvent,
} from "@liveblocks/node";
// +++
import { prepareThreadNotificationEmailAsReact } from "@liveblocks/emails";
// +++

// Add your webhook secret key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_WEBHOOK_SECRET_KEY";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

// +++
// Add your secret key from a project's API keys dashboard
const API_SECRET = "{{SECRET_KEY}}";
const liveblocks = new Liveblocks({ secret: API_SECRET });
// +++

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // When an inbox notification has been created on the email channel
  if (isThreadNotificationEvent(event) && event.data.channel === "email") {
    // Check if user has access to room
    if (!__hasRoomAccess__(event.userId, event.roomId)) {
      return new Response(null, { status: 200 });
    }

    // The user to send the email to
    const emailAddress = __getEmailAddressFromDB__(event.userId);

    // +++
    let emailData;

    try {
      emailData = await prepareThreadNotificationEmailAsReact(
        liveblocks,
        event
      );
    } catch (err) {
      console.log(err);
      return new Response("Could not fetch thread notification data", {
        status: 500,
      });
    }

    // All comments have already been read
    if (!emailData) {
      return new Response(null, { status: 200 });
    }

    // Create emails
    // ...
    // +++
  }

  return new Response(null, { status: 200 });
}
```

## Create the emails

Next, we need to create the emails with React.
[`prepareThreadNotificationEmailAsReact`](/docs/api-reference/liveblocks-emails#prepare-thread-notification-email-as-react)
helps you identify two different thread notification types, _unread replies_ in
a thread, or an _unread mention_ in a comment. We can choose to create different
emails for these cases.

```tsx
import {
  Liveblocks,
  WebhookHandler,
  isThreadNotificationEvent,
} from "@liveblocks/node";
import { prepareThreadNotificationEmailAsReact } from "@liveblocks/emails";

// Add your webhook secret key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_WEBHOOK_SECRET_KEY";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

// Add your secret key from a project's API keys dashboard
const API_SECRET = "{{SECRET_KEY}}";
const liveblocks = new Liveblocks({ secret: API_SECRET });

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // When an inbox notification has been created on the email channel
  if (isThreadNotificationEvent(event) && event.data.channel === "email") {
    // Check if user has access to room
    if (!__hasRoomAccess__(event.userId, event.roomId)) {
      return new Response(null, { status: 200 });
    }

    // The user to send the email to
    const emailAddress = __getEmailAddressFromDB__(event.userId);

    let emailData;

    try {
      emailData = await prepareThreadNotificationEmailAsReact(
        liveblocks,
        event
      );
    } catch (err) {
      console.log(err);
      return new Response("Could not fetch thread notification data", {
        status: 500,
      });
    }

    // All comments have already been read
    if (!emailData) {
      return new Response(null, { status: 200 });
    }

    // +++
    let email;
    switch (emailData.type) {
      case "unreadMention": {
        email = (
          <div>
            <div>
              @{emailData.comment.author.id} at {emailData.comment.createdAt}
            </div>
            <div>{emailData.comment.body}</div>
          </div>
        );
        break;
      }

      case "unreadReplies": {
        email = (
          <div>
            {emailData.comments.map((comment) => (
              <div key={comment.id}>
                <div>
                  @{comment.author.id} at {comment.createdAt}
                </div>
                <div>{comment.body}</div>
              </div>
            ))}
          </div>
        );
        break;
      }
    }
    // +++

    // Send emails
    // ...
  }

  return new Response(null, { status: 200 });
}
```

## Resolving data

Weâ€™ve now fully created a basic React email, and itâ€™s ready to send. However,
weâ€™re displaying each userâ€™s ID, and not their names. We can go back to
[`prepareThreadNotificationEmailAsReact`](/docs/api-reference/liveblocks-emails#prepare-thread-notification-email-as-react)
and use resolver functions to transform an ID into a name, for example
`steven@example.com` -> `Steven`. These functions work similarly to
[resolvers on the client](/docs/api-reference/liveblocks-react#LiveblocksProviderResolveUsers).

```tsx
// ...

emailData = await prepareThreadNotificationEmailAsReact(liveblocks, event, {
  // +++
  resolveUsers: async ({ userIds }) => {
    const usersData = await __getUsersFromDB__(userIds);

    return usersData.map((userData) => ({
      name: userData.name, // "Steven"
      avatar: userData.avatar.src, // "https://example.com/steven.jpg"
    }));
  },
  resolveRoomInfo: async ({ roomId }) => {
    const roomData = await __getRoomFromDB__(roomId);

    return {
      name: roomData.name, // "Untitled document"
      url: roomData.url, //`https://example.com/my-room-id`
    };
  },
  // +++
});

// ...
```

## Customizing comment components

We can also edit `prepareThreadNotificationEmailAsReact` to allow for
[custom components in comment bodies](/docs/api-reference/liveblocks-emails#prepare-thread-notification-email-as-react-customizing-components),
for example we can add margin around a paragraph, color mentions, and underline
links.

```tsx
// ...

emailData = await prepareThreadNotificationEmailAsReact(liveblocks, event, {
  resolveUsers: async ({ userIds }) => {
    const usersData = await __getUsersFromDB__(userIds);

    return usersData.map((userData) => ({
      name: userData.name, // "Steven"
      avatar: userData.avatar.src, // "https://example.com/steven.jpg"
    }));
  },
  resolveRoomInfo: async ({ roomId }) => {
    const roomData = await __getRoomFromDB__(roomId);

    return {
      name: roomData.name, // "Untitled document"
      url: roomData.url, //`https://example.com/my-room-id`
    };
  },
  // +++
  components: {
    Paragraph: ({ children }) => <p style={{ margin: "12px 0" }}>{children}</p>,

    // `user` is the optional data returned from `resolveUsers`
    Mention: ({ element, user }) => (
      <span style={{ color: "red" }}>@{user?.name ?? element.id}</span>
    ),

    // If the link is rich-text render it, otherwise use the URL
    Link: ({ element, href }) => (
      <a href={href} style={{ textDecoration: "underline" }}>
        {element?.text ?? href}
      </a>
    ),
  },
  // +++
});

// ...
```

Any component can be passed here, including those used in
[`react-email`](https://react.email/),
[learn more](/docs/api-reference/liveblocks-emails#prepare-thread-notification-email-as-react-customizing-components).

<Banner>

If youâ€™re using HTML instead of React, you can
[apply custom CSS properties](/docs/api-reference/liveblocks-emails#prepare-thread-notification-email-as-html-styling-elements).

</Banner>

## Send notification emails

Now that the React code has been generated, we can send the notification emails.
[Resend](https://resend.com) is a great tool for easily sending emails, and in
this code example, weâ€™re using it to send notifications to each user. Make sure
to add your API key from the [Resend dashboard](https://resend.com/overview)
before running the code.

```tsx
import {
  Liveblocks,
  WebhookHandler,
  isThreadNotificationEvent,
} from "@liveblocks/node";
import { prepareThreadNotificationEmailAsReact } from "@liveblocks/emails";
// +++
import { Resend } from "resend";
// +++

// +++
// Create Resend client (add your API key)
const resend = new Resend("re_123456789");
// +++

// Add your webhook secret key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_WEBHOOK_SECRET_KEY";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

// Add your secret key from a project's API keys dashboard
const API_SECRET = "{{SECRET_KEY}}";
const liveblocks = new Liveblocks({ secret: API_SECRET });

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // When an inbox notification has been created on the email channel
  if (isThreadNotificationEvent(event) && event.data.channel === "email") {
    // Check if user has access to room
    if (!__hasRoomAccess__(event.userId, event.roomId)) {
      return new Response(null, { status: 200 });
    }

    // The user to send the email to
    const emailAddress = __getEmailAddressFromDB__(event.userId);

    let emailData;

    try {
      emailData = await prepareThreadNotificationEmailAsReact(
        liveblocks,
        event,
        {
          resolveUsers: async ({ userIds }) => {
            const usersData = await __getUsersFromDB__(userIds);

            return usersData.map((userData) => ({
              name: userData.name, // "Steven"
              avatar: userData.avatar.src, // "https://example.com/steven.jpg"
            }));
          },
          resolveRoomInfo: async ({ roomId }) => {
            const roomData = await __getRoomFromDB__(roomId);

            return {
              name: roomData.name, // "Untitled document"
              url: roomData.url, //`https://example.com/my-room-id`
            };
          },
          components: {
            Paragraph: ({ children }) => (
              <p style={{ margin: "12px 0" }}>{children}</p>
            ),

            // `user` is the optional data returned from `resolveUsers`
            Mention: ({ element, user }) => (
              <span style={{ color: "red" }}>@{user?.name ?? element.id}</span>
            ),

            // If the link is rich-text render it, otherwise use the URL
            Link: ({ element, href }) => (
              <a href={href} style={{ textDecoration: "underline" }}>
                {element?.text ?? href}
              </a>
            ),
          },
        }
      );
    } catch (err) {
      console.log(err);
      return new Response("Could not fetch thread notification data", {
        status: 500,
      });
    }

    // All comments have already been read
    if (!emailData) {
      return new Response(null, { status: 200 });
    }

    let email;
    switch (emailData.type) {
      case "unreadMention": {
        email = (
          <div>
            <div>
              @{emailData.comment.author.id} at {emailData.comment.createdAt}
            </div>
            <div>{emailData.comment.body}</div>
          </div>
        );
        break;
      }

      case "unreadReplies": {
        email = (
          <div>
            {emailData.comments.map((comment) => (
              <div key={comment.id}>
                <div>
                  @{comment.author.id} at {comment.createdAt}
                </div>
                <div>{comment.body}</div>
              </div>
            ))}
          </div>
        );
        break;
      }
    }

    // +++
    // Send email to the user's email address
    try {
      const data = await resend.emails.send({
        from: "My company <hello@my-company.com>",
        to: emailAddress,
        subject: "New comment",
        react: email,
      });
    } catch (err) {
      console.error(err);
    }
    // +++
  }

  return new Response(null, { status: 200 });
}
```

## Allow users to toggle notifications

Using Liveblocks hooks and methods, itâ€™s possible to create a notifications
settings interface, allowing end users to choose which notifications theyâ€™d like
to receive, and on which channels, saving their preferences.

<Figure>
  <Image
    src="/assets/notifications/notification-settings.jpg"
    alt="Notification settings"
    width={1344}
    height={896}
  />
</Figure>

Learn more in our guide on
[creating a notification settings panel](/docs/guides/how-to-create-a-notification-settings-panel).

## Recap

Great, weâ€™re successfully sending email notifications after new comments are
created! In this guide weâ€™ve learned:

- How to use [webhooks](/docs/platform/webhooks) and the
  [`NotificationEvent`](/docs/platform/webhooks#NotificationEvent).
- How to use the [`@liveblocks/emails`](/docs/api-reference/liveblocks-emails)
  package to fetch and render unread thread data.
- How to send email notifications with [Resend](https://resend.com).

---
meta:
  title: "How to send email notifications when comments are created"
  description:
    "Learn how to automatically send email notifications when a comment or
    thread is created with Liveblocks Comments."
---

Liveblocks allows you to build a commenting experience with
[Comments](/docs/ready-made-features/comments). Using our webhooks and REST API,
itâ€™s possible to send email notifications to users when theyâ€™re mentioned in
comments.

<Banner title="Youâ€™re probably looking for a different guide" type="warning">

This guide is about sending an email immediately after every comment is posted.
If youâ€™d prefer aggregate multiple notifications into one email, and only notify
users about unread comments, you should read this guide on
[how to send email notifications of unread comments](/docs/guides/how-to-send-email-notifications-of-unread-comments).

</Banner>

## What weâ€™re building

In this guide weâ€™ll be learning how to send comments notifications, and more
specifically, weâ€™ll be looking at how to:

- Trigger events when comments are created using the
  [CommentCreated](/docs/platform/webhooks#CommentCreatedEvent) webhook event.
- Fetch a commentâ€™s data using the
  [@liveblocks/node](/docs/api-reference/liveblocks-node) package.
- Create notifications containing the commentâ€™s
  [formatted text](/docs/guides/how-to-send-email-notifications-when-comments-are-created#Formatting-a-comment's-body).
- Send an email notification with [Resend](https://resend.com/).

<Banner title="Have a project ready">

This guide assumes you already have a Liveblocks Comments project set up. If you
havenâ€™t already got one, you can
[get started with Comments](/docs/get-started/comments), and come back after
youâ€™re set up. You could also use our
[basic Comments example](/examples/comments/nextjs-comments).

</Banner>

## Create an endpoint in your project

When a webhook event is triggered, it can send a POST request to the back end in
your project, and from within there we can send the email. In this guide, weâ€™ll
be using a Next.js route handler (API endpoint) as an example, but other
frameworks work similarly.

In order to use webhooks, weâ€™ll need to retrieve the `headers` and `body` from
the request. Hereâ€™s the basic endpoint weâ€™ll be starting from:

```ts
export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Handle webhooks and notifications
  // ...

  return new Response(null, { status: 200 });
}
```

Create this endpoint in your project, and make it available on `localhost`, for
example at the following URL:

```
/api/liveblocks-notifications
```

Make a note of this endpoint URL, as youâ€™ll be using it later.

### Testing webhooks locally

Running webhooks locally can be difficult, but one way to do this is to use a
tool such as [`localtunnel`](https://www.npmjs.com/package/localtunnel) or
[`ngrok`](https://www.npmjs.com/package/ngrok) which allow you to temporarily
put your localhost server online.

If your project is running on `localhost:3000`, you can run the following
command to generate a temporary URL thatâ€™s available while your localhost server
is running:

```bash
npx localtunnel --port 3000
```

`localtunnel` generates a base URL that can be placed into the Liveblocks
webhooks dashboard for quick testing. To use this, take the full address of your
webhook endpoint, and replace the domain in your `localhost` address with the
generated URL.

```shell
# Take your local URL
http://localhost:3000/api/liveblocks-notifications

# Replace localhost with the generated domain, then copy it
https://my-localtunnel-url.loca.lt/api/liveblocks-notifications
```

You now have a URL that can be used in the webhooks dashboard.

## Set up webhooks on the Liveblocks dashboard

To use webhooks, you need to pass your endpoint URL to the webhooks dashboard
inside your Liveblocks project, and tell the webhook to trigger when a comment
has been created.

<Steps>
  <Step>
    <StepTitle>Select your project</StepTitle>
    <StepContent>
      From the [Liveblocks dashboard](/dashboard), navigate to the project youâ€™d
      like to use with webhooks, or create a new project.
      <Figure>
        <Image
          src="/assets/tutorials/webhooks/liveblocks-create-project.png"
          alt="Create a Liveblocks project"
          width={712}
          height={445}
        />
      </Figure>
    </StepContent>
  </Step>

<Step>
  <StepTitle>Go to the webhooks dashboard</StepTitle>
  <StepContent>
    Click on the **â€œWebhooksâ€** tab on the menu at the left.
    <Figure>
      <Image
        src="/assets/tutorials/webhooks/liveblocks-click-webhooks.png"
        alt="Click webhooks"
        width={712}
        height={445}
      />
    </Figure>
  </StepContent>
</Step>

<Step>
  <StepTitle>Create an endpoint</StepTitle>
  <StepContent>
    Click the **â€œCreate endpointâ€¦â€** button on the webhooks dashboard to start
    setting up your webhook.
    <Figure>
      <Image
        src="/assets/tutorials/webhooks/liveblocks-add-endpoint.png"
        alt="Click add endpoint"
        width={712}
        height={445}
      />
    </Figure>
  </StepContent>
</Step>

<Step>
  <StepTitle>Add your endpoint URL</StepTitle>
  <StepContent>
    Enter the URL of the endpoint. In a production app this will be the real
    endpoint, but for now enter your `localtunnel` URL from earlier.
    <Figure>
      <Image
        src="/assets/tutorials/webhooks/liveblocks-add-endpoint-url.png"
        alt="Add endpoint URL"
        width={712}
        height={445}
      />
    </Figure>
  </StepContent>
</Step>

<Step>
  <StepTitle>Get your webhook secret key</StepTitle>
  <StepContent>
    Click **â€œCreate endpointâ€** at the bottom, then find your **â€œSecret keyâ€**
    on the next page, and copy it.
    <Figure>
      <Image
        src="/assets/tutorials/webhooks/liveblocks-get-secret-key.png"
        alt="Copy your webhook secret key"
        width={710}
        height={445}
      />
    </Figure>
  </StepContent>
</Step>

  <Step lastStep>
    <StepTitle>Webhooks dashboard is set up!</StepTitle>

    <StepContent>
      Note that you can filter specifically for `commentCreated` events, but weâ€™re
      ignoring this for now so we can test more easily. Letâ€™s go back to the
      code.
    </StepContent>

  </Step>
</Steps>

## Verify the webhook request

The [`@liveblocks/node`](/docs/api-reference/liveblocks-node) package provides
you with a function that verifies whether the current request is a real webhook
request from Liveblocks. You can set this up by setting up a
[`WebhookHandler`](/docs/api-reference/liveblocks-node#WebhookHandler) and
running [`verifyRequest`](/docs/api-reference/liveblocks-node#verifyRequest).

Make sure to add your â€œWebhook secret keyâ€ from the Liveblocks dashboardâ€”in a
real project weâ€™d recommend using an environment variable for this.

```ts highlight="1,3-5,11-21"
import { WebhookHandler } from "@liveblocks/node";

// Add your webhook secret key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_WEBHOOK_SECRET_KEY";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // Send notifications
  // ...

  return new Response(null, { status: 200 });
}
```

We can then check weâ€™re receiving the correct type of event, get the data from
the webhook, and handle sending the notification inside there.

```ts highlight="23-29"
import { WebhookHandler } from "@liveblocks/node";

// Add your webhook secret key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_WEBHOOK_SECRET_KEY";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // When a comment has been created
  if (event.type === "commentCreated") {
    const { roomId, threadId, commentId } = event.data;

    // Send notifications
    // ...
  }

  return new Response(null, { status: 200 });
}
```

We now have the `roomId`, `threadId`, and `commentId` of the created comment,
along with some
[other information](/docs/platform/webhooks#CommentCreatedEvent).

## Get comment and thread data

<Banner title="Threads vs comments">
  Note that a thread is different to a commentâ€”a thread is â€œtop-levelâ€, and each
  thread contains a list of comments. When you create a thread with
  [`useCreateThread`](/docs/api-reference/liveblocks-react#useCreateThread), you
  also create the first comment in the thread.
</Banner>

The next step is to use the
[Liveblocks client](/docs/api-reference/liveblocks-node#Liveblocks-client) from
`@liveblocks/node` to retrieve the entire commentâ€™s data, along with the thread
participants. In Liveblocks Comments, a participant refers to a user that has
commented or been mentioned in a threadâ€”weâ€™ll be sending a notification to each
of these users.

To do this weâ€™ll need to add our projectâ€™s secret key to the Liveblocks client,
before awaiting the following functions:
[`getComment`](/docs/api-reference/liveblocks-node#get-comment) and
[`getThreadParticipants`](/docs/api-reference/liveblocks-node#get-thread-participants).

```ts highlight="1,7-9,31-43"
import { Liveblocks, WebhookHandler } from "@liveblocks/node";

// Add your webhook secret key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_WEBHOOK_SECRET_KEY";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

// Add your secret key from a project's API keys dashboard
const API_SECRET = "{{SECRET_KEY}}";
const liveblocks = new Liveblocks({ secret: API_SECRET });

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // When a comment has been created
  if (event.type === "commentCreated") {
    const { roomId, threadId, commentId } = event.data;

    try {
      // Get comment data and participants
      const [comment, { participantIds }] = await Promise.all([
        liveblocks.getComment({ roomId, threadId, commentId }),
        liveblocks.getThreadParticipants({ roomId, threadId }),
      ]);

      // Send notifications
      // ...
    } catch (err) {
      console.log(err);
      return new Response("Could not fetch comment data", { status: 500 });
    }
  }

  return new Response(null, { status: 200 });
}
```

## Formatting a commentâ€™s body

Now that we have the comment data and a list of participants, we have one more
step before sending the notificationsâ€”formatting the commentâ€™s text, found
inside `comment.body`. Letâ€™s take a look at how it works for an example comment,
using
[`stringifyCommentBody`](/docs/api-reference/liveblocks-node#stringify-comment-body)
to transform `comment.body`.

<Figure>
  <Image
    src="/assets/comments/comment-body.png"
    alt="Comment with example body: 'Thank you so much @Emil Joyce!', with 'so much' in bold"
    width={1289}
    height={390}
  />
</Figure>

```ts
import { stringifyCommentBody } from "@liveblocks/node";

// Format comment text into a string
const stringComment = await stringifyCommentBody(comment.body);

// "Thank you so much emil.joyce@example.com!"
console.log(stringComment);
```

As you can see on line 6, weâ€™re converting the body into a plain string, which
means we lose the formatting. Weâ€™re also seeing the userâ€™s ID, instead of the
nameâ€”this is because we need to provide the userâ€™s information, as the comment
only stores the userâ€™s ID.

By providing two options, we can transform the comment into HTML, keeping the
formatting, and add the user information.

```ts
import { stringifyCommentBody } from "@liveblocks/node";

// Format comment text into an HTML string
const htmlComment = await stringifyCommentBody(comment.body, {
  // Transform into HTML
  format: "html",

  // Provider user information
  async resolveUsers({ userIds }) {
    // ["emil.joyce@example.com", ...]
    console.log(userIds);

    // Return each user's name
    [{ name: "Emil Joyce" } /*, ... */];
  },
});

// "<p>Thank you <b>so much</b> <span data-mention>@Emil Joyce</span>!</p>"
console.log(stringComment);
```

On line 18, you can now see that weâ€™re creating an HTML string, and using the
mentioned userâ€™s name. Note that you can also easily transform your comment into
Markdown, or a completely custom format, learn more under
[`stringifyCommentBody`](/docs/api-reference/liveblocks-node#stringify-comment-body).

Letâ€™s use this HTML formatting function in our endpoint, getting user
information from your database.

```ts highlight="1,38-50"
import { Liveblocks, WebhookHandler, stringifyCommentBody } from "@liveblocks/node";

// Add your webhook secret key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_WEBHOOK_SECRET_KEY";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

// Add your secret key from a project's API keys dashboard
const API_SECRET = "{{SECRET_KEY}}";
const liveblocks = new Liveblocks({ secret: API_SECRET });

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // When a comment has been created
  if (event.type === "commentCreated") {
    const { roomId, threadId, commentId } = event.data;

    try {
      // Get comment data and participants
      const [comment, { participantIds }] = await Promise.all([
        liveblocks.getComment({ roomId, threadId, commentId }),
        liveblocks.getThreadParticipants({ roomId, threadId }),
      ]);

      // HTML comment body
      const htmlComment = await stringifyCommentBody(comment.body, {
        format: "html",

        async resolveUsers({ userIds }) {
          // Get the correct users from your database
          const users = await __getUsers__(userIds);

          return users.map((user) => ({
            name: user.name,
          });
        },
      });

      // Send notifications
      // ...
    } catch (err) {
      console.log(err);
      return new Response("Could not fetch comment data", { status: 500 });
    }
  }

  return new Response(null, { status: 200 });
}
```

## Send notifications

Now that the commentâ€™s body is in our preferred format, we can send the
notifications. Earlier we retrieved `participants`, a list of `userIds` that
have been mentioned in the thread. You most likely have user information in your
database, which you can retrieve from these `userIds`.

<Banner title="userIds">
  These are the same `userIds` that are passed to
  [`resolveUsers`](/docs/api-reference/liveblocks-client#resolveUsers) in your
  `liveblocks.config.ts` file.
</Banner>

After getting each userâ€™s email, simply loop through and send the formatted
comment.

```ts highlight="52-64"
import { Liveblocks, WebhookHandler, stringifyCommentBody } from "@liveblocks/node";

// Add your webhook secret key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_WEBHOOK_SECRET_KEY";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

// Add your secret key from a project's API keys dashboard
const API_SECRET = "{{SECRET_KEY}}";
const liveblocks = new Liveblocks({ secret: API_SECRET });

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // When a comment has been created
  if (event.type === "commentCreated") {
    const { roomId, threadId, commentId } = event.data;

    try {
      // Get comment data and participants
      const [comment, { participantIds }] = await Promise.all([
        liveblocks.getComment({ roomId, threadId, commentId }),
        liveblocks.getThreadParticipants({ roomId, threadId }),
      ]);

      // HTML comment body
      const htmlComment = await stringifyCommentBody(comment.body, {
        format: "html",

        async resolveUsers({ userIds }) {
          // Get the correct users from your database
          const users = await __getUsers__(userIds);

          return users.map((user) => ({
            name: user.name,
          });
        },
      });

      // Get participating users from your database
      const users = await __getUsers__(participantIds);

      // Send notifications
      for (const user of users) {
        // Send email to the user's email address
        // send({
        //   from: "hello@my-company.com",
        //   to: user.email,
        //   title: "New comment",
        //   html: htmlComment
        // });
      }
    } catch (err) {
      console.log(err);
      return new Response("Could not fetch comment data", { status: 500 });
    }
  }

  return new Response(null, { status: 200 });
}
```

## Sending emails with Resend

[Resend](https://resend.com) is a great tool for easily sending emails, and in
this code example, weâ€™re using it to send the notifications to each user. Make
sure to add your API key from the
[Resend dashboard](https://resend.com/overview) before running the code.

```ts highlight="2,4-5,59-69" file="route.ts"
import { Liveblocks, WebhookHandler, stringifyCommentBody } from "@liveblocks/node";
import { Resend } from "resend";

// Create Resend client (add your API key)
const resend = new Resend("re_123456789");

// Add your webhook secret key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_WEBHOOK_SECRET_KEY";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

// Add your secret key from a project's API keys dashboard
const API_SECRET = "{{SECRET_KEY}}";
const liveblocks = new Liveblocks({ secret: API_SECRET });

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // When a comment has been created
  if (event.type === "commentCreated") {
    const { roomId, threadId, commentId } = event.data;

    try {
      // Get comment data and participants
      const [comment, { participantIds }] = await Promise.all([
        liveblocks.getComment({ roomId, threadId, commentId }),
        liveblocks.getThreadParticipants({ roomId, threadId }),
      ]);

      // HTML comment body
      const htmlComment = stringifyCommentBody(comment.body, {
        format: "html",

        async resolveUsers({ userIds }) {
          // Get the correct users from your database
          const users = await __getUsers__(userIds);

          return users.map((user) => ({
            name: user.name,
          });
        },
      });

      // Get participating users from your database
      const users = await __getUsers__(participantIds);

      // Send email to the users' email addresses
      try {
        const data = await resend.emails.send({
          from: "My company <hello@my-company.com>",
          to: [users.map((user) => user.email)],
          subject: "New comment",
          html: htmlComment,
        });
      } catch (err) {
        console.error(err);
      }
    } catch (err) {
      console.log(err);
      return new Response("Could not fetch comment data", { status: 500 });
    }
  }

  return new Response(null, { status: 200 });
}
```

## Recap

Great, weâ€™re successfully sending email notifications after new comments are
created! In this guide weâ€™ve learned:

- How to use [webhooks](/docs/platform/webhooks) and the
  [`CommentCreatedEvent`](/docs/platform/webhooks#CommentCreatedEvent).
- How to use the `@liveblocks/node` package to get
  [comment data](/docs/api-reference/liveblocks-node#get-comment) and
  [thread participants](/docs/api-reference/liveblocks-node#get-thread-participants).
- How to shape a commentâ€™s body into HTML with
  [`stringifyCommentBody`](/docs/api-reference/liveblocks-node#stringify-comment-body).
- How to send email notifications with [Resend](https://resend.com).

---
meta:
  title:
    "How to synchronize your Liveblocks Storage document data to a PlanetScale
    MySQL database"
  description:
    "Learn how to automatically update your PlanetScale MySQL database with
    changes from your Storage-based application."
---

Liveblocks allows you to build collaborative applications with
[Storage](/storage), a persisted conflict-free data store. Using our webhooks
and REST API, you can then retrieve the Storage document data as it changes, and
store it in your database.

## What weâ€™re building

In this guide weâ€™ll be linking a Storage application up to a
[PlanetScale](https://planetscale.com/) MySQL database so that Storage document
data is automatically synchronized. This is enabled through the following:

- [StorageUpdated](/docs/platform/webhooks#StorageUpdatedEvent) webhook event
- [Get Storage Document](/docs/api-reference/rest-api-endpoints#get-rooms-roomId-storage)
  REST API

<Banner title="Have a project ready">

This guide assumes you already have a Liveblocks Storage project set up. If you
havenâ€™t already got one, you can select _Custom_ on our
[getting started page](https://liveblocks.io/docs/get-started/custom), choose a
framework, and come back after youâ€™re set up. You could also use an example such
as our [collaborative
spreadsheet)(/examples/collaborative-spreadsheet-advanced/nextjs-spreadsheet-advanced).

</Banner>

### This specific webhook is throttled

Note that the [StorageUpdated](/docs/platform/webhooks#StorageUpdatedEvent)
webhook event is throttled at a rate of _once every 60 seconds_. This is because
Storage can update up to _60 times per second_, and it would be impractical to
run the webhook this frequently.

## Create an endpoint in your project

When a webhook event is triggered, it can send a POST request to the back end in
your project, and from within there we can update the database. In this guide,
weâ€™ll be using a Next.js route handler (API endpoint) as an example, but other
frameworks work similarly.

In order to use webhooks, weâ€™ll need to retrieve the `headers` and `body` from
the request. Hereâ€™s the basic endpoint weâ€™ll be starting from:

```ts
export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Handle webhooks and database
  // ...

  return new Response(null, { status: 200 });
}
```

Create this endpoint in your project, and make it available on `localhost` at
the following URL:

```
/api/liveblocks-database-sync
```

### Testing webhooks locally

Running webhooks locally can be difficult, but one way to do this is to use a
tool such as [`localtunnel`](https://www.npmjs.com/package/localtunnel) or
[`ngrok`](https://www.npmjs.com/package/ngrok) which allow you to temporarily
put your localhost server online.

If your project is running on `localhost:3000`, you can run the following
command to generate a temporary URL thatâ€™s available while your localhost server
is running:

```bash
npx localtunnel --port 3000
```

`localtunnel` generates a base URL that can be placed into the Liveblocks
webhooks dashboard for quick testing. To use this, take the full address of your
webhook endpoint, and replace the domain in your `localhost` address with the
generated URL.

```shell
# Take your local URL
http://localhost:3000/api/liveblocks-database-sync

# Replace localhost with the generated domain, then copy it
https://my-localtunnel-url.loca.lt/api/liveblocks-database-sync
```

You now have a URL that can be used in the webhooks dashboard.

## Set up webhooks on the Liveblocks dashboard

To use webhooks, you need to pass your endpoint URL to the webhooks dashboard
inside your Liveblocks project, and tell the webhook to trigger when Storage
document data has changed.

<Steps>
  <Step>
    <StepTitle>Select your project</StepTitle>
    <StepContent>
      From the [Liveblocks dashboard](/dashboard), navigate to the project youâ€™d
      like to use with webhooks, or create a new project.
      <Figure>
        <Image
          src="/assets/tutorials/webhooks/liveblocks-create-project.png"
          alt="Create a Liveblocks project"
          width={712}
          height={445}
        />
      </Figure>
    </StepContent>
  </Step>

<Step>
  <StepTitle>Go to the webhooks dashboard</StepTitle>
  <StepContent>
    Click on the **â€œWebhooksâ€** tab on the menu at the left.
    <Figure>
      <Image
        src="/assets/tutorials/webhooks/liveblocks-click-webhooks.png"
        alt="Click webhooks"
        width={712}
        height={445}
      />
    </Figure>
  </StepContent>
</Step>

<Step>
  <StepTitle>Create an endpoint</StepTitle>
  <StepContent>
    Click the **â€œCreate endpointâ€¦â€** button on the webhooks dashboard to start
    setting up your webhook.
    <Figure>
      <Image
        src="/assets/tutorials/webhooks/liveblocks-add-endpoint.png"
        alt="Click add endpoint"
        width={712}
        height={445}
      />
    </Figure>
  </StepContent>
</Step>

<Step>
  <StepTitle>Add your endpoint URL</StepTitle>
  <StepContent>
    Enter the URL of the endpoint. In a production app this will be the real
    endpoint, but for now enter your `localtunnel` URL from earlier.
    <Figure>
      <Image
        src="/assets/tutorials/webhooks/liveblocks-add-endpoint-url.png"
        alt="Add endpoint URL"
        width={712}
        height={445}
      />
    </Figure>
  </StepContent>
</Step>

<Step>
  <StepTitle>Get your secret key</StepTitle>
  <StepContent>
    Click **â€œCreate endpointâ€** at the bottom, then find your **â€œSecret keyâ€**
    on the next page, and copy it.
    <Figure>
      <Image
        src="/assets/tutorials/webhooks/liveblocks-get-secret-key.png"
        alt="Copy your webhook secret key"
        width={712}
        height={445}
      />
    </Figure>
  </StepContent>
</Step>

  <Step lastStep>
    <StepTitle>Webhooks dashboard is set up!</StepTitle>

    <StepContent>
      Note that you can filter specifically for `storageUpdated` events, but weâ€™re
      ignoring this for now so we can test more easily. Letâ€™s go back to the
      code.
    </StepContent>

  </Step>
</Steps>

## Verify the webhook request

The [`@liveblocks/node`](/docs/api-reference/liveblocks-node) package provides
you with a function that verifies whether the current request is a real webhook
request from Liveblocks. You can set this up by setting up a
[`WebhookHandler`](/docs/api-reference/liveblocks-node#WebhookHandler) and
running [`verifyRequest`](/docs/api-reference/liveblocks-node#verifyRequest).

Make sure to add your â€œSigning Secretâ€ from the Liveblocks dashboardâ€”in a real
project weâ€™d recommend using an environment variable for this.

```ts highlight="1,3-5,11-21"
import { WebhookHandler } from "@liveblocks/node";

// Add your signing key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_SIGNING_SECRET";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // Update database
  // ...

  return new Response(null, { status: 200 });
}
```

We can then check weâ€™re receiving the correct type of event, get the updated
`roomId`, and handle updating the database inside there.

```ts highlight="23-29"
import { WebhookHandler } from "@liveblocks/node";

// Add your signing key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_SIGNING_SECRET";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // When Storage document data has been updated
  if (event.type === "storageUpdated") {
    const { roomId } = event.data;

    // Update database
    // ...
  }

  return new Response(null, { status: 200 });
}
```

## Get the current roomâ€™s Storage document data

Before updating our database, we need to get the current roomâ€™s data. We can do
this through the
[Get Storage Document](/docs/api-reference/rest-api-endpoints#get-rooms-roomId-storage)
REST API. You use the REST API, you need to add your secret key from your
project page.

```ts highlight="7-8,30-43"
import { WebhookHandler } from "@liveblocks/node";

// Add your signing key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_SIGNING_SECRET";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

// Add your secret key from a project's API keys dashboard
const API_SECRET = "{{SECRET_KEY}}";

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // When Storage document data has been updated
  if (event.type === "storageUpdated") {
    const { roomId } = event.data;

    // Get Storage data from Liveblocks REST API
    const url = `https://api.liveblocks.io/v2/rooms/${roomId}/storage`;
    const response = await fetch(url, {
      headers: { Authorization: `Bearer ${API_SECRET}` },
    });

    if (!response.ok) {
      return new Response("Problem accessing Liveblocks REST APIs", {
        status: 500,
      });
    }

    // Your JSON Storage document data as a string
    const storageData = await response.text();

    // Update database
    // ...
  }

  return new Response(null, { status: 200 });
}
```

## Create a PlanetScale MySQL database

Weâ€™re ready to set up our PlanetScale database! Weâ€™ll be creating a simple
`documents` table that contains the following fields:

| Field         | Description                        | Type           | Key       |
| ------------- | ---------------------------------- | -------------- | --------- |
| `roomId`      | The `roomId`.                      | `VARCHAR(255)` | `PRIMARY` |
| `storageData` | The stringified JSON Storage data. | `TEXT`         |           |

<Steps>
  <Step>
    <StepTitle>Create a database</StepTitle>
    <StepContent>
      Navigate to PlanetScaleâ€™s [new database page](https://app.planetscale.com/new),
      give your database a name, and click â€œCreateâ€ at the bottom.

      <Figure>
        <Image
          src="/assets/tutorials/webhooks/planetscale-create-db.png"
          alt="Create a PlanetScale database"
          width={1486}
          height={792}
        />
      </Figure>
    </StepContent>

  </Step>

  <Step>
    <StepTitle>Create a new branch</StepTitle>
    <StepContent>
      After the database has been created, click â€œNew branchâ€ at the top right to create
      a branchâ€”this works like Git.

      <Figure>
        <Image
          src="/assets/tutorials/webhooks/planetscale-create-new-branch.png"
          alt="Create a new branch"
          width={866}
          height={681}
        />
      </Figure>
    </StepContent>

  </Step>

  <Step>
    <StepTitle>Set up your schema</StepTitle>
    <StepContent>
      Click â€œConsoleâ€ at the top, select your branch, and enter the following to set up your table.

      ```sql
      CREATE TABLE documents (
         roomId VARCHAR(255) PRIMARY KEY,
         storageData TEXT NOT NULL
      );
      ```

      <Figure>
        <Image
          src="/assets/tutorials/webhooks/planetscale-create-schema.png"
          alt="Create your table"
          width={1531}
          height={745}
        />
      </Figure>
    </StepContent>

  </Step>

  <Step>
    <StepTitle>Click â€œConnectâ€</StepTitle>
    <StepContent>
      After the database has been created, click â€œConnectâ€ at the top right to create
      new credentials.

      <Figure>
        <Image
          src="/assets/tutorials/webhooks/planetscale-connect.png"
          alt="Click connect"
          width={864}
          height={534}
        />
      </Figure>
    </StepContent>

  </Step>

  <Step>
    <StepTitle>Create credentials</StepTitle>
    <StepContent>
      Give your new credentials a name, then click â€œCreate Passwordâ€.

      <Figure>
        <Image
          src="/assets/tutorials/webhooks/planetscale-create-credentials.png"
          alt="Create a PlanetScale password"
          width={936}
          height={655}
        />
      </Figure>
    </StepContent>

  </Step>

  <Step>
    <StepTitle>Add the credentials to your project</StepTitle>
    <StepContent>
    Select â€œNode.jsâ€ in the dropdown and copy the database URL (or add it as an environment variable).

    <Figure>
      <Image
        src="/assets/tutorials/webhooks/planetscale-get-credentials.png"
        alt="Get the database URL"
        width={1473}
        height={593}
      />
    </Figure>
    </StepContent>

  </Step>

  <Step lastStep>
    <StepTitle>
      Database ready!
    </StepTitle>

    <StepContent>
      Letâ€™s take a look at the code.
    </StepContent>

  </Step>
</Steps>

## Add the Storage data to your database

And finally, we can add the Storage JSON data to our database! First, we need to
install `mysql2`:

```bash
npm i mysql2
```

Then implement the following to synchronize your data to PlanetScale:

```ts highlight="2,11-12,49-67"
import { WebhookHandler } from "@liveblocks/node";
import mysql from "mysql2";

// Add your signing key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_SIGNING_SECRET";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

// Add your secret key from a project's API keys dashboard
const API_SECRET = "{{SECRET_KEY}}";

// Your PlanetScale database URL
const DATABASE_URL = "YOUR_DATABASE_URL";

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // When Storage document data has been updated
  if (event.type === "storageUpdated") {
    const { roomId } = event.data;

    // Get Storage data from Liveblocks REST API
    const url = `https://api.liveblocks.io/v2/rooms/${roomId}/storage`;
    const response = await fetch(url, {
      headers: { Authorization: `Bearer ${API_SECRET}` },
    });

    if (!response.ok) {
      return new Response("Problem accessing Liveblocks REST APIs", {
        status: 500,
      });
    }

    // Your JSON Storage document data as a string
    const storageData = await response.text();

    // Update database
    const connection = await mysql.createConnection(DATABASE_URL);

    const sql = `
      INSERT INTO documents (roomId, storageData)
      VALUES (?, ?)
      ON DUPLICATE KEY UPDATE
          storageData = VALUES(storageData);
    `;

    try {
      await connection.query(sql, [roomId, storageData]);
    } catch (err) {
      return new Response("Problem inserting data into database", {
        status: 500,
      });
    }

    await connection.end();
  }

  return new Response(null, { status: 200 });
}
```

## Check if it worked

To check if your database synchronization is working, you can replay a
`storageUpdated` event from the Liveblocks dashboard.

<Figure>
  <Image
    src="/assets/tutorials/webhooks/liveblocks-replay-event.png"
    alt="Create your table schema"
    width={768}
    height={426}
  />
</Figure>

Then go back to the Console page on PlanetScale and enter the following to see
all entries:

```sql
SELECT * FROM documents;
```

You should now see your Storage documentâ€”weâ€™ve successfully set up data
synchronization! When a user edits Storage data in your app, this function will
be called, and your database will be updated. You can rely on this to stay up to
date, within the 60 second throttle limit.

## Learn more

You can learn more about Liveblocks webhooks in our full
[webhooks guide](/docs/platform/webhooks). We also have an API reference for the
[Get Storage Document API](/docs/api-reference/rest-api-endpoints#get-rooms-roomId-storage).

---
meta:
  title:
    "How to synchronize your Liveblocks Storage document data to a Supabase
    Postgres database"
  description:
    "Learn how to automatically update your Supabase Postgres database with
    changes from your Storage-based application."
---

Liveblocks allows you to build collaborative applications with
[Storage](/storage), a persisted conflict-free data store. Using our webhooks
and REST API, you can then retrieve the Storage document data as it changes, and
store it in your database.

## What weâ€™re building

In this guide weâ€™ll be linking a Storage application up to a
[Supabase Postgres](https://supabase.com/database) database so that Storage
document data is automatically synchronized. This is enabled through the
following:

- [StorageUpdated](/docs/platform/webhooks#StorageUpdatedEvent) webhook event
- [Get Storage Document](/docs/api-reference/rest-api-endpoints#get-rooms-roomId-storage)
  REST API

<Banner title="Have a project ready">

This guide assumes you already have a Liveblocks Storage project set up. If you
havenâ€™t already got one, you can select _Custom_ on our
[getting started page](https://liveblocks.io/docs/get-started/custom), choose a
framework, and come back after youâ€™re set up. You could also use an example such
as our [collaborative
spreadsheet)(/examples/collaborative-spreadsheet-advanced/nextjs-spreadsheet-advanced).

</Banner>

### This specific webhook is throttled

Note that the [StorageUpdated](/docs/platform/webhooks#StorageUpdatedEvent)
webhook event is throttled at a rate of _once every 60 seconds_. This is because
Storage can update up to _60 times per second_, and it would be impractical to
run the webhook this frequently.

## Create an endpoint in your project

When a webhook event is triggered, it can send a POST request to the back end in
your project, and from within there we can update the database. In this guide,
weâ€™ll be using a Next.js route handler (API endpoint) as an example, but other
frameworks work similarly.

In order to use webhooks, weâ€™ll need to retrieve the `headers` and `body` from
the request. Hereâ€™s the basic endpoint weâ€™ll be starting from:

```ts
export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Handle webhooks and database
  // ...

  return new Response(null, { status: 200 });
}
```

Create this endpoint in your project, and make it available on `localhost` at
the following URL:

```
/api/liveblocks-database-sync
```

### Testing webhooks locally

Running webhooks locally can be difficult, but one way to do this is to use a
tool such as [`localtunnel`](https://www.npmjs.com/package/localtunnel) or
[`ngrok`](https://www.npmjs.com/package/ngrok) which allow you to temporarily
put your localhost server online.

If your project is running on `localhost:3000`, you can run the following
command to generate a temporary URL thatâ€™s available while your localhost server
is running:

```bash
npx localtunnel --port 3000
```

`localtunnel` generates a base URL that can be placed into the Liveblocks
webhooks dashboard for quick testing. To use this, take the full address of your
webhook endpoint, and replace the domain in your `localhost` address with the
generated URL.

```shell
# Take your local URL
http://localhost:3000/api/liveblocks-database-sync

# Replace localhost with the generated domain, then copy it
https://my-localtunnel-url.loca.lt/api/liveblocks-database-sync
```

You now have a URL that can be used in the webhooks dashboard.

## Set up webhooks on the Liveblocks dashboard

To use webhooks, you need to pass your endpoint URL to the webhooks dashboard
inside your Liveblocks project, and tell the webhook to trigger when Storage
document data has changed.

<Steps>
  <Step>
    <StepTitle>Select your project</StepTitle>
    <StepContent>
      From the [Liveblocks dashboard](/dashboard), navigate to the project youâ€™d
      like to use with webhooks, or create a new project.
      <Figure>
        <Image
          src="/assets/tutorials/webhooks/liveblocks-create-project.png"
          alt="Create a Liveblocks project"
          width={712}
          height={445}
        />
      </Figure>
    </StepContent>
  </Step>

<Step>
  <StepTitle>Go to the webhooks dashboard</StepTitle>
  <StepContent>
    Click on the **â€œWebhooksâ€** tab on the menu at the left.
    <Figure>
      <Image
        src="/assets/tutorials/webhooks/liveblocks-click-webhooks.png"
        alt="Click webhooks"
        width={712}
        height={445}
      />
    </Figure>
  </StepContent>
</Step>

<Step>
  <StepTitle>Create an endpoint</StepTitle>
  <StepContent>
    Click the **â€œCreate endpointâ€¦â€** button on the webhooks dashboard to start
    setting up your webhook.
    <Figure>
      <Image
        src="/assets/tutorials/webhooks/liveblocks-add-endpoint.png"
        alt="Click add endpoint"
        width={712}
        height={445}
      />
    </Figure>
  </StepContent>
</Step>

<Step>
  <StepTitle>Add your endpoint URL</StepTitle>
  <StepContent>
    Enter the URL of the endpoint. In a production app this will be the real
    endpoint, but for now enter your `localtunnel` URL from earlier.
    <Figure>
      <Image
        src="/assets/tutorials/webhooks/liveblocks-add-endpoint-url.png"
        alt="Add endpoint URL"
        width={712}
        height={445}
      />
    </Figure>
  </StepContent>
</Step>

<Step>
  <StepTitle>Get your secret key</StepTitle>
  <StepContent>
    Click **â€œCreate endpointâ€** at the bottom, then find your **â€œSecret keyâ€**
    on the next page, and copy it.
    <Figure>
      <Image
        src="/assets/tutorials/webhooks/liveblocks-get-secret-key.png"
        alt="Copy your webhook secret key"
        width={712}
        height={445}
      />
    </Figure>
  </StepContent>
</Step>

  <Step lastStep>
    <StepTitle>Webhooks dashboard is set up!</StepTitle>

    <StepContent>
      Note that you can filter specifically for `storageUpdated` events, but weâ€™re
      ignoring this for now so we can test more easily. Letâ€™s go back to the
      code.
    </StepContent>

  </Step>
</Steps>

## Verify the webhook request

The [`@liveblocks/node`](/docs/api-reference/liveblocks-node) package provides
you with a function that verifies whether the current request is a real webhook
request from Liveblocks. You can set this up by setting up a
[`WebhookHandler`](/docs/api-reference/liveblocks-node#WebhookHandler) and
running [`verifyRequest`](/docs/api-reference/liveblocks-node#verifyRequest).

Make sure to add your â€œSigning Secretâ€ from the Liveblocks dashboardâ€”in a real
project weâ€™d recommend using an environment variable for this.

```ts highlight="1,3-5,11-21"
import { WebhookHandler } from "@liveblocks/node";

// Add your signing key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_SIGNING_SECRET";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // Update database
  // ...

  return new Response(null, { status: 200 });
}
```

We can then check weâ€™re receiving the correct type of event, get the updated
`roomId`, and handle updating the database inside there.

```ts highlight="23-29"
import { WebhookHandler } from "@liveblocks/node";

// Add your signing key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_SIGNING_SECRET";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // When Storage document data has been updated
  if (event.type === "storageUpdated") {
    const { roomId } = event.data;

    // Update database
    // ...
  }

  return new Response(null, { status: 200 });
}
```

## Get the current roomâ€™s Storage document data

Before updating our database, we need to get the current roomâ€™s data. We can do
this through the
[Get Storage Document](/docs/api-reference/rest-api-endpoints#get-rooms-roomId-storage)
REST API. You use the REST API, you need to add your secret key from your
project page.

```ts highlight="7-8,30-43"
import { WebhookHandler } from "@liveblocks/node";

// Add your signing key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_SIGNING_SECRET";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

// Add your secret key from a project's API keys dashboard
const API_SECRET = "{{SECRET_KEY}}";

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // When Storage document data has been updated
  if (event.type === "storageUpdated") {
    const { roomId } = event.data;

    // Get Storage data from Liveblocks REST API
    const url = `https://api.liveblocks.io/v2/rooms/${roomId}/storage`;
    const response = await fetch(url, {
      headers: { Authorization: `Bearer ${API_SECRET}` },
    });

    if (!response.ok) {
      return new Response("Problem accessing Liveblocks REST APIs", {
        status: 500,
      });
    }

    // Your JSON Storage document data as a string
    const storageData = await response.text();

    // Update database
    // ...
  }

  return new Response(null, { status: 200 });
}
```

## Create a Supabase Postgres database

Weâ€™re ready to set up our Supabase database! Weâ€™ll be creating a simple
`documents` table that contains the following fields:

| Field         | Description                        | Type           | Key       |
| ------------- | ---------------------------------- | -------------- | --------- |
| `roomId`      | The `roomId`.                      | `VARCHAR(255)` | `PRIMARY` |
| `storageData` | The stringified JSON Storage data. | `TEXT`         |           |

<Steps>
  <Step>
    <StepTitle>New project</StepTitle>
    <StepContent>
      Navigate to Supabaseâ€™s [dashboard
      page](https://supabase.com/dashboard/projects), and click â€œNew projectâ€ at
      the top.
      <Figure>
        <Image
          src="/assets/tutorials/webhooks/supabase-new-project.png"
          alt="Click new project"
          width={942}
          height={443}
        />
      </Figure>
    </StepContent>
  </Step>

<Step>
  <StepTitle>Create a database</StepTitle>
  <StepContent>
    Give your database a name and password, then click â€œCreate new projectâ€ at
    the bottom. Make sure to save your password, because you wonâ€™t be able to
    view it again.
    <Figure>
      <Image
        src="/assets/tutorials/webhooks/supabase-new-project-details.png"
        alt="Create a new project"
        width={1517}
        height={1203}
      />
    </Figure>
  </StepContent>
</Step>

<Step>
  <StepTitle>Create your table</StepTitle>
  <StepContent>
    Click the SQL Editor icon in the left bar, enter the following code into the
    console, and click â€œRunâ€ at the bottom right to create the table. ```sql
    CREATE TABLE documents ( roomId VARCHAR(255) PRIMARY KEY, storageData TEXT
    NOT NULL ); ```
    <Figure>
      <Image
        src="/assets/tutorials/webhooks/supabase-create-schema.png"
        alt="Create your table schema"
        width={1635}
        height={984}
      />
    </Figure>
  </StepContent>
</Step>

<Step>
  <StepTitle>Get your credentials</StepTitle>
  <StepContent>
    Click the Settings icon in the left bar, click â€œAPIâ€ at the left and find
    two items: 1. Your â€œURLâ€, under â€œProject URLâ€. 2. Your `anon``public` key,
    under â€œProject API keyâ€. Make a note of these, or add them as environment
    variables in your project.
    <Figure>
      <Image
        src="/assets/tutorials/webhooks/supabase-get-credentials.png"
        alt="Create your table schema"
        width={2053}
        height={972}
      />
    </Figure>
  </StepContent>
</Step>

  <Step lastStep>
    <StepTitle>Database ready!</StepTitle>
    <StepContent>Letâ€™s take a look at the code.</StepContent>
  </Step>
</Steps>

## Add the Storage data to your database

And finally, we can add the Storage JSON data to our database! First, we need to
install the Supabase library:

```bash
npm i @supabase/supabase-js
```

Then implement the following to synchronize your data, making sure to add your
Project URL:

```ts highlight="2,11-15,52-62"
import { WebhookHandler } from "@liveblocks/node";
import { createClient } from "@supabase/supabase-js";

// Add your signing key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_SIGNING_SECRET";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

// Add your secret key from a project's API keys dashboard
const API_SECRET = "{{SECRET_KEY}}";

// Create a Supabase client
const supabase = createClient(
  "YOUR_SUPABASE_PROJECT_URL",
  "YOUR_SUPABASE_PUBLIC_ANON_KEY"
);

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // When Storage document data has been updated
  if (event.type === "storageUpdated") {
    const { roomId } = event.data;

    // Get Storage data from Liveblocks REST API
    const url = `https://api.liveblocks.io/v2/rooms/${roomId}/storage`;
    const response = await fetch(url, {
      headers: { Authorization: `Bearer ${API_SECRET}` },
    });

    if (!response.ok) {
      return new Response("Problem accessing Liveblocks REST APIs", {
        status: 500,
      });
    }

    // Your JSON Storage document data as a string
    const storageData = await response.text();

    // Update database
    const { data, error } = await supabase
      .from("documents")
      .insert({ roomid: roomId, storagedata: storageData })
      .select();

    if (error) {
      return new Response("Problem inserting data into database", {
        status: 500,
      });
    }
  }

  return new Response(null, { status: 200 });
}
```

## Check if it worked

To check if it worked, you can replay an event from the Liveblocks dashboard, or
just edit your document.

<Figure>
  <Image
    src="/assets/tutorials/webhooks/liveblocks-replay-event.png"
    alt="Create your table schema"
    width={768}
    height={426}
  />
</Figure>

Next, go to Supabase, and click the Table Editor icon on the left bar. Find your
`documents` table on the left, and check the entries. You should now see your
Storage documentâ€”weâ€™ve successfully set up data synchronization!

When a user edits Storage data in your app, this function will be called, and
your database will be updated. You can rely on this to stay up to date, within
the 60 second throttle limit.

## Learn more

You can learn more about Liveblocks webhooks in our full
[webhooks guide](/docs/platform/webhooks). We also have an API reference for the
[Get Storage Document API](/docs/api-reference/rest-api-endpoints#get-rooms-roomId-storage).

---
meta:
  title:
    "How to synchronize your Liveblocks Storage document data to a Vercel
    Postgres database"
  description:
    "Learn how to automatically update your Vercel Postgres database with
    changes from your Storage-based application."
---

Liveblocks allows you to build collaborative applications with
[Storage](/storage), a persisted conflict-free data store. Using our webhooks
and REST API, you can then retrieve the Storage document data as it changes, and
store it in your database.

## What weâ€™re building

In this guide weâ€™ll be linking a Storage application up to a
[Vercel Postgres](https://vercel.com/docs/storage/vercel-postgres) database so
that Storage document data is automatically synchronized. This is enabled
through the following:

- [StorageUpdated](/docs/platform/webhooks#StorageUpdatedEvent) webhook event
- [Get Storage Document](/docs/api-reference/rest-api-endpoints#get-rooms-roomId-storage)
  REST API

<Banner title="Have a project ready">

This guide assumes you already have a Liveblocks Storage project set up. If you
havenâ€™t already got one, you can select _Custom_ on our
[getting started page](https://liveblocks.io/docs/get-started/custom), choose a
framework, and come back after youâ€™re set up. You could also use an example such
as our [collaborative
spreadsheet)(/examples/collaborative-spreadsheet-advanced/nextjs-spreadsheet-advanced).

</Banner>

### This specific webhook is throttled

Note that the [StorageUpdated](/docs/platform/webhooks#StorageUpdatedEvent)
webhook event is throttled at a rate of _once every 60 seconds_. This is because
Storage can update up to _60 times per second_, and it would be impractical to
run the webhook this frequently.

## Create an endpoint in your project

When a webhook event is triggered, it can send a POST request to the back end in
your project, and from within there we can update the database. In this guide,
weâ€™ll be using a Next.js route handler (API endpoint) as an example, but other
frameworks work similarly.

In order to use webhooks, weâ€™ll need to retrieve the `headers` and `body` from
the request. Hereâ€™s the basic endpoint weâ€™ll be starting from:

```ts
export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Handle webhooks and database
  // ...

  return new Response(null, { status: 200 });
}
```

Create this endpoint in your project, and make it available on `localhost` at
the following URL:

```
/api/liveblocks-database-sync
```

### Testing webhooks locally

Running webhooks locally can be difficult, but one way to do this is to use a
tool such as [`localtunnel`](https://www.npmjs.com/package/localtunnel) or
[`ngrok`](https://www.npmjs.com/package/ngrok) which allow you to temporarily
put your localhost server online.

If your project is running on `localhost:3000`, you can run the following
command to generate a temporary URL thatâ€™s available while your localhost server
is running:

```bash
npx localtunnel --port 3000
```

`localtunnel` generates a base URL that can be placed into the Liveblocks
webhooks dashboard for quick testing. To use this, take the full address of your
webhook endpoint, and replace the domain in your `localhost` address with the
generated URL.

```shell
# Take your local URL
http://localhost:3000/api/liveblocks-database-sync

# Replace localhost with the generated domain, then copy it
https://my-localtunnel-url.loca.lt/api/liveblocks-database-sync
```

You now have a URL that can be used in the webhooks dashboard.

## Set up webhooks on the Liveblocks dashboard

To use webhooks, you need to pass your endpoint URL to the webhooks dashboard
inside your Liveblocks project, and tell the webhook to trigger when Storage
document data has changed.

<Steps>
  <Step>
    <StepTitle>Select your project</StepTitle>
    <StepContent>
      From the [Liveblocks dashboard](/dashboard), navigate to the project youâ€™d
      like to use with webhooks, or create a new project.

      <Figure>
        <Image
          src="/assets/tutorials/webhooks/liveblocks-create-project.png"
          alt="Create a Liveblocks project"
          width={712}
          height={445}
        />
      </Figure>
    </StepContent>

  </Step>

<Step>
  <StepTitle>Go to the webhooks dashboard</StepTitle>
  <StepContent>
    Click on the **â€œWebhooksâ€** tab on the menu at the left.
    <Figure>
      <Image
        src="/assets/tutorials/webhooks/liveblocks-click-webhooks.png"
        alt="Click webhooks"
        width={712}
        height={445}
      />
    </Figure>
  </StepContent>
</Step>

<Step>
  <StepTitle>Create an endpoint</StepTitle>
  <StepContent>
    Click the **â€œCreate endpointâ€¦â€** button on the webhooks dashboard to start
    setting up your webhook.
    <Figure>
      <Image
        src="/assets/tutorials/webhooks/liveblocks-add-endpoint.png"
        alt="Click add endpoint"
        width={712}
        height={445}
      />
    </Figure>
  </StepContent>
</Step>

<Step>
  <StepTitle>Add your endpoint URL</StepTitle>
  <StepContent>
    Enter the URL of the endpoint. In a production app this will be the real
    endpoint, but for now enter your `localtunnel` URL from earlier.
    <Figure>
      <Image
        src="/assets/tutorials/webhooks/liveblocks-add-endpoint-url.png"
        alt="Add endpoint URL"
        width={712}
        height={445}
      />
    </Figure>
  </StepContent>
</Step>

<Step>
  <StepTitle>Get your secret key</StepTitle>
  <StepContent>
    Click **â€œCreate endpointâ€** at the bottom, then find your **â€œSecret keyâ€**
    on the next page, and copy it.
    <Figure>
      <Image
        src="/assets/tutorials/webhooks/liveblocks-get-secret-key.png"
        alt="Copy your webhook secret key"
        width={712}
        height={445}
      />
    </Figure>
  </StepContent>
</Step>

  <Step lastStep>
    <StepTitle>
      Webhooks dashboard is set up!
    </StepTitle>

    <StepContent>
      Note that you can filter specifically for `storageUpdated`
      events, but weâ€™re ignoring this for now so we can test more easily. Letâ€™s go
      back to the code.
    </StepContent>

  </Step>

</Steps>

## Verify the webhook request

The [`@liveblocks/node`](/docs/api-reference/liveblocks-node) package provides
you with a function that verifies whether the current request is a real webhook
request from Liveblocks. You can set this up by setting up a
[`WebhookHandler`](/docs/api-reference/liveblocks-node#WebhookHandler) and
running [`verifyRequest`](/docs/api-reference/liveblocks-node#verifyRequest).

Make sure to add your â€œSigning Secretâ€ from the Liveblocks dashboardâ€”in a real
project weâ€™d recommend using an environment variable for this.

```ts highlight="1,3-5,11-21"
import { WebhookHandler } from "@liveblocks/node";

// Add your signing key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_SIGNING_SECRET";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // Update database
  // ...

  return new Response(null, { status: 200 });
}
```

We can then check weâ€™re receiving the correct type of event, get the updated
`roomId`, and handle updating the database inside there.

```ts highlight="23-29"
import { WebhookHandler } from "@liveblocks/node";

// Add your signing key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_SIGNING_SECRET";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // When Storage document data has been updated
  if (event.type === "storageUpdated") {
    const { roomId } = event.data;

    // Update database
    // ...
  }

  return new Response(null, { status: 200 });
}
```

## Get the current roomâ€™s Storage document data

Before updating our database, we need to get the current roomâ€™s data. We can do
this through the
[Get Storage Document](/docs/api-reference/rest-api-endpoints#get-rooms-roomId-storage)
REST API. You use the REST API, you need to add your secret key from your
project page.

```ts highlight="7-8,30-43"
import { WebhookHandler } from "@liveblocks/node";

// Add your signing key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_SIGNING_SECRET";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

// Add your secret key from a project's API keys dashboard
const API_SECRET = "{{SECRET_KEY}}";

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // When Storage document data has been updated
  if (event.type === "storageUpdated") {
    const { roomId } = event.data;

    // Get Storage data from Liveblocks REST API
    const url = `https://api.liveblocks.io/v2/rooms/${roomId}/storage`;
    const response = await fetch(url, {
      headers: { Authorization: `Bearer ${API_SECRET}` },
    });

    if (!response.ok) {
      return new Response("Problem accessing Liveblocks REST APIs", {
        status: 500,
      });
    }

    // Your JSON Storage document data as a string
    const storageData = await response.text();

    // Update database
    // ...
  }

  return new Response(null, { status: 200 });
}
```

## Create a Vercel Postgres database

Weâ€™re ready to set up our database! This is how to get started with Vercel
Postgres:

<Steps>
  <StepCompact>
    Navigate to the [Vercel Storage](https://vercel.com/dashboard/stores)
    dashboard.
  </StepCompact>

<StepCompact>Click "Create Database", then select â€œPostgresâ€.</StepCompact>

<StepCompact>Give the database a name and click â€œCreateâ€.</StepCompact>

  <StepCompact lastStep>
    Follow the getting started guide to connect the database to
    your Vercel project, link your environment variables, and install the packages.
  </StepCompact>
</Steps>

## Add the Storage data to your database

And finally, we can add the Storage JSON data to our database. Here weâ€™re
creating a simple `documents` table that contains the following fields:

| Field         | Description                        | Type           | Key       |
| ------------- | ---------------------------------- | -------------- | --------- |
| `roomId`      | The `roomId`.                      | `VARCHAR(255)` | `PRIMARY` |
| `storageData` | The stringified JSON Storage data. | `TEXT`         |           |

This is how to implement it in your endpoint:

```ts highlight="2,46-65"
import { WebhookHandler } from "@liveblocks/node";
import { sql } from "@vercel/postgres";

// Add your signing key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_SIGNING_SECRET";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

// Add your secret key from a project's API keys dashboard
const API_SECRET = "{{SECRET_KEY}}";

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // When Storage document data has been updated
  if (event.type === "storageUpdated") {
    const { roomId } = event.data;

    // Get Storage data from Liveblocks REST API
    const url = `https://api.liveblocks.io/v2/rooms/${roomId}/storage`;
    const response = await fetch(url, {
      headers: { Authorization: `Bearer ${API_SECRET}` },
    });

    if (!response.ok) {
      return new Response("Problem accessing Liveblocks REST APIs", {
        status: 500,
      });
    }

    // Your JSON Storage document data as a string
    const storageData = await response.text();

    // Update database
    try {
      await sql`
        CREATE TABLE IF NOT EXISTS documents (
          roomId VARCHAR(255) PRIMARY KEY,
          storageData TEXT NOT NULL
        );
      `;
      await sql`
        INSERT INTO documents (roomId, storageData)
        VALUES (${roomId}, ${storageData})
        ON CONFLICT (roomId)
        DO UPDATE SET
          storageData = EXCLUDED.storageData
      `;
    } catch (err) {
      return new Response("Problem inserting data into database", {
        status: 500,
      });
    }
  }

  return new Response(null, { status: 200 });
}
```

## Check if it worked

To check if your database synchronization is working, you can replay a
`storageUpdated` event from the Liveblocks dashboard.

<Figure>
  <Image
    src="/assets/tutorials/webhooks/liveblocks-replay-event.png"
    alt="Create your table schema"
    width={768}
    height={426}
  />
</Figure>

Then go to the Data page on your Vercel Postgres dashboard, find your table in
the dropdown, and check the entries. You should now see your Storage
documentâ€”weâ€™ve successfully set up data synchronization!

When a user edits Storage data in your app, this function will be called, and
your database will be updated. You can rely on this to stay up to date, within
the 60 second throttle limit.

## Learn more

You can learn more about Liveblocks webhooks in our full
[webhooks guide](/docs/platform/webhooks). We also have an API reference for the
[Get Storage Document API](/docs/api-reference/rest-api-endpoints#get-rooms-roomId-storage).

---
meta:
  title:
    "How to synchronize your Liveblocks Yjs document data to a PlanetScale MySQL
    database"
  description:
    "Learn how to automatically update your PlanetScale MySQL database with
    changes from your Yjs application."
---

Liveblocks allows you to build collaborative applications with
[Yjs](https://yjs.dev/), which is tightly integrated into our infrastructure.
Using our webhooks and REST API, you can then retrieve the Yjs document data as
it changes, and store it in your database.

## What weâ€™re building

In this guide weâ€™ll be linking a Yjs application up to a
[PlanetScale](https://planetscale.com/) MySQL database so that Yjs document data
is automatically synchronized. This is enabled through the following:

- [YDocUpdated](/docs/platform/webhooks#YDocUpdatedEvent) webhook event
- [Get Yjs Document](/docs/api-reference/rest-api-endpoints#get-rooms-roomId-ydoc)
  REST API

<Banner title="Have a project ready">

This guide assumes you already have a Liveblocks Yjs project set up. If you
havenâ€™t already got one, you can open our getting started page, select a
[text editor](/docs/get-started/text-editor) or
[code editor](/docs/get-started/code-editor), both of which use Yjs, and come
back after youâ€™re set up.

</Banner>

### This specific webhook is throttled

Note that the [YDocUpdated](/docs/platform/webhooks#YDocUpdatedEvent) webhook
event is throttled at a rate of _once every 60 seconds_. This is because Yjs can
update up to _60 times per second_, and it would be impractical to run the
webhook this frequently.

## Create an endpoint in your project

When a webhook event is triggered, it can send a POST request to the back end in
your project, and from within there we can update the database. In this guide,
weâ€™ll be using a Next.js route handler (API endpoint) as an example, but other
frameworks work similarly.

In order to use webhooks, weâ€™ll need to retrieve the `headers` and `body` from
the request. Hereâ€™s the basic endpoint weâ€™ll be starting from:

```ts
export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Handle webhooks and database
  // ...

  return new Response(null, { status: 200 });
}
```

Create this endpoint in your project, and make it available on `localhost` at
the following URL:

```
/api/liveblocks-database-sync
```

### Testing webhooks locally

Running webhooks locally can be difficult, but one way to do this is to use a
tool such as [`localtunnel`](https://www.npmjs.com/package/localtunnel) or
[`ngrok`](https://www.npmjs.com/package/ngrok) which allow you to temporarily
put your localhost server online.

If your project is running on `localhost:3000`, you can run the following
command to generate a temporary URL thatâ€™s available while your localhost server
is running:

```bash
npx localtunnel --port 3000
```

`localtunnel` generates a base URL that can be placed into the Liveblocks
webhooks dashboard for quick testing. To use this, take the full address of your
webhook endpoint, and replace the domain in your `localhost` address with the
generated URL.

```shell
# Take your local URL
http://localhost:3000/api/liveblocks-database-sync

# Replace localhost with the generated domain, then copy it
https://my-localtunnel-url.loca.lt/api/liveblocks-database-sync
```

You now have a URL that can be used in the webhooks dashboard.

## Set up webhooks on the Liveblocks dashboard

To use webhooks, you need to pass your endpoint URL to the webhooks dashboard
inside your Liveblocks project, and tell the webhook to trigger when Yjs
document data has changed.

<Steps>
  <Step>
    <StepTitle>Select your project</StepTitle>
    <StepContent>
      From the [Liveblocks dashboard](/dashboard), navigate to the project youâ€™d
      like to use with webhooks, or create a new project.
      <Figure>
        <Image
          src="/assets/tutorials/webhooks/liveblocks-create-project.png"
          alt="Create a Liveblocks project"
          width={712}
          height={445}
        />
      </Figure>
    </StepContent>
  </Step>

<Step>
  <StepTitle>Go to the webhooks dashboard</StepTitle>
  <StepContent>
    Click on the **â€œWebhooksâ€** tab on the menu at the left.
    <Figure>
      <Image
        src="/assets/tutorials/webhooks/liveblocks-click-webhooks.png"
        alt="Click webhooks"
        width={712}
        height={445}
      />
    </Figure>
  </StepContent>
</Step>

<Step>
  <StepTitle>Create an endpoint</StepTitle>
  <StepContent>
    Click the **â€œCreate endpointâ€¦â€** button on the webhooks dashboard to start
    setting up your webhook.
    <Figure>
      <Image
        src="/assets/tutorials/webhooks/liveblocks-add-endpoint.png"
        alt="Click add endpoint"
        width={712}
        height={445}
      />
    </Figure>
  </StepContent>
</Step>

<Step>
  <StepTitle>Add your endpoint URL</StepTitle>
  <StepContent>
    Enter the URL of the endpoint. In a production app this will be the real
    endpoint, but for now enter your `localtunnel` URL from earlier.
    <Figure>
      <Image
        src="/assets/tutorials/webhooks/liveblocks-add-endpoint-url.png"
        alt="Add endpoint URL"
        width={712}
        height={445}
      />
    </Figure>
  </StepContent>
</Step>

<Step>
  <StepTitle>Get your secret key</StepTitle>
  <StepContent>
    Click **â€œCreate endpointâ€** at the bottom, then find your **â€œSecret keyâ€**
    on the next page, and copy it.
    <Figure>
      <Image
        src="/assets/tutorials/webhooks/liveblocks-get-secret-key.png"
        alt="Copy your webhook secret key"
        width={712}
        height={445}
      />
    </Figure>
  </StepContent>
</Step>

  <Step lastStep>
    <StepTitle>Webhooks dashboard is set up!</StepTitle>

    <StepContent>
      Note that you can filter specifically for `ydocUpdated` events, but weâ€™re
      ignoring this for now so we can test more easily. Letâ€™s go back to the
      code.
    </StepContent>

  </Step>
</Steps>

## Verify the webhook request

The [`@liveblocks/node`](/docs/api-reference/liveblocks-node) package provides
you with a function that verifies whether the current request is a real webhook
request from Liveblocks. You can set this up by setting up a
[`WebhookHandler`](/docs/api-reference/liveblocks-node#WebhookHandler) and
running [`verifyRequest`](/docs/api-reference/liveblocks-node#verifyRequest).

Make sure to add your â€œSigning Secretâ€ from the Liveblocks dashboardâ€”in a real
project weâ€™d recommend using an environment variable for this.

```ts highlight="1,3-5,11-21"
import { WebhookHandler } from "@liveblocks/node";

// Add your signing key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_SIGNING_SECRET";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // Update database
  // ...

  return new Response(null, { status: 200 });
}
```

We can then check weâ€™re receiving the correct type of event, get the updated
`roomId`, and handle updating the database inside there.

```ts highlight="23-29"
import { WebhookHandler } from "@liveblocks/node";

// Add your signing key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_SIGNING_SECRET";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // When Yjs document data has been updated
  if (event.type === "ydocUpdated") {
    const { roomId } = event.data;

    // Update database
    // ...
  }

  return new Response(null, { status: 200 });
}
```

## Get the current roomâ€™s Yjs document data

Before updating our database, we need to get the current roomâ€™s data. We can do
this through the
[Get Yjs Document](/docs/api-reference/rest-api-endpoints#get-rooms-roomId-ydoc)
REST API. You use the REST API, you need to add your secret key from your
project page.

```ts highlight="7-8,30-43"
import { WebhookHandler } from "@liveblocks/node";

// Add your signing key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_SIGNING_SECRET";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

// Add your secret key from a project's API keys dashboard
const API_SECRET = "{{SECRET_KEY}}";

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // When Yjs document data has been updated
  if (event.type === "ydocUpdated") {
    const { roomId } = event.data;

    // Get Yjs data from Liveblocks REST API
    const url = `https://api.liveblocks.io/v2/rooms/${roomId}/ydoc`;
    const response = await fetch(url, {
      headers: { Authorization: `Bearer ${API_SECRET}` },
    });

    if (!response.ok) {
      return new Response("Problem accessing Liveblocks REST APIs", {
        status: 500,
      });
    }

    // Your JSON Yjs document data as a string
    const yDocData = await response.text();

    // Update database
    // ...
  }

  return new Response(null, { status: 200 });
}
```

## Create a PlanetScale MySQL database

Weâ€™re ready to set up our PlanetScale database! Weâ€™ll be creating a simple
`documents` table that contains the following fields:

| Field      | Description                    | Type           | Key       |
| ---------- | ------------------------------ | -------------- | --------- |
| `roomId`   | The `roomId`.                  | `VARCHAR(255)` | `PRIMARY` |
| `yDocData` | The stringified JSON Yjs data. | `TEXT`         |           |

<Steps>
  <Step>
    <StepTitle>Create a database</StepTitle>
    <StepContent>
      Navigate to PlanetScaleâ€™s [new database page](https://app.planetscale.com/new),
      give your database a name, and click â€œCreateâ€ at the bottom.

      <Figure>
        <Image
          src="/assets/tutorials/webhooks/planetscale-create-db.png"
          alt="Create a PlanetScale database"
          width={1486}
          height={792}
        />
      </Figure>
    </StepContent>

  </Step>

  <Step>
    <StepTitle>Create a new branch</StepTitle>
    <StepContent>
      After the database has been created, click â€œNew branchâ€ at the top right to create
      a branchâ€”this works like Git.

      <Figure>
        <Image
          src="/assets/tutorials/webhooks/planetscale-create-new-branch.png"
          alt="Create a new branch"
          width={866}
          height={681}
        />
      </Figure>
    </StepContent>

  </Step>

  <Step>
    <StepTitle>Set up your schema</StepTitle>
    <StepContent>
      Click â€œConsoleâ€ at the top, select your branch, and enter the following to set up your table.

      ```sql
      CREATE TABLE documents (
         roomId VARCHAR(255) PRIMARY KEY,
         yDocData TEXT NOT NULL
      );
      ```

      <Figure>
        <Image
          src="/assets/tutorials/webhooks/planetscale-create-schema.png"
          alt="Create your table"
          width={1531}
          height={745}
        />
      </Figure>
    </StepContent>

  </Step>

  <Step>
    <StepTitle>Click â€œConnectâ€</StepTitle>
    <StepContent>
      After the database has been created, click â€œConnectâ€ at the top right to create
      new credentials.

      <Figure>
        <Image
          src="/assets/tutorials/webhooks/planetscale-connect.png"
          alt="Click connect"
          width={864}
          height={534}
        />
      </Figure>
    </StepContent>

  </Step>

  <Step>
    <StepTitle>Create credentials</StepTitle>
    <StepContent>
      Give your new credentials a name, then click â€œCreate Passwordâ€.

      <Figure>
        <Image
          src="/assets/tutorials/webhooks/planetscale-create-credentials.png"
          alt="Create a PlanetScale password"
          width={936}
          height={655}
        />
      </Figure>
    </StepContent>

  </Step>

  <Step>
    <StepTitle>Add the credentials to your project</StepTitle>
    <StepContent>
    Select â€œNode.jsâ€ in the dropdown and copy the database URL (or add it as an environment variable).

    <Figure>
      <Image
        src="/assets/tutorials/webhooks/planetscale-get-credentials.png"
        alt="Get the database URL"
        width={1473}
        height={593}
      />
    </Figure>
    </StepContent>

  </Step>

  <Step lastStep>
    <StepTitle>
      Database ready!
    </StepTitle>

    <StepContent>
      Letâ€™s take a look at the code.
    </StepContent>

  </Step>
</Steps>

## Add the Yjs data to your database

And finally, we can add the Yjs JSON data to our database! First, we need to
install `mysql2`:

```bash
npm i mysql2
```

Then implement the following to synchronize your data to PlanetScale:

```ts highlight="2,11-12,49-67"
import { WebhookHandler } from "@liveblocks/node";
import mysql from "mysql2";

// Add your signing key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_SIGNING_SECRET";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

// Add your secret key from a project's API keys dashboard
const API_SECRET = "{{SECRET_KEY}}";

// Your PlanetScale database URL
const DATABASE_URL = "YOUR_DATABASE_URL";

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // When Yjs document data has been updated
  if (event.type === "ydocUpdated") {
    const { roomId } = event.data;

    // Get Yjs data from Liveblocks REST API
    const url = `https://api.liveblocks.io/v2/rooms/${roomId}/ydoc`;
    const response = await fetch(url, {
      headers: { Authorization: `Bearer ${API_SECRET}` },
    });

    if (!response.ok) {
      return new Response("Problem accessing Liveblocks REST APIs", {
        status: 500,
      });
    }

    // Your JSON Yjs document data as a string
    const yDocData = await response.text();

    // Update database
    const connection = await mysql.createConnection(DATABASE_URL);

    const sql = `
      INSERT INTO documents (roomId, yDocData)
      VALUES (?, ?)
      ON DUPLICATE KEY UPDATE
          yDocData = VALUES(yDocData);
    `;

    try {
      await connection.query(sql, [roomId, yDocData]);
    } catch (err) {
      return new Response("Problem inserting data into database", {
        status: 500,
      });
    }

    await connection.end();
  }

  return new Response(null, { status: 200 });
}
```

## Check if it worked

To check if your database synchronization is working, you can replay a
`yDocUpdated` event from the Liveblocks dashboard.

<Figure>
  <Image
    src="/assets/tutorials/webhooks/liveblocks-replay-event.png"
    alt="Create your table schema"
    width={768}
    height={426}
  />
</Figure>

Then go back to the Console page on PlanetScale and enter the following to see
all entries:

```sql
SELECT * FROM documents;
```

You should now see your Yjs documentâ€”weâ€™ve successfully set up data
synchronization! When a user edits Yjs data in your app, this function will be
called, and your database will be updated. You can rely on this to stay up to
date, within the 60 second throttle limit.

## Learn more

You can learn more about Liveblocks webhooks in our full
[webhooks guide](/docs/platform/webhooks). We also have an API reference for the
[Get Yjs Document API](/docs/api-reference/rest-api-endpoints#get-rooms-roomId-ydoc).

---
meta:
  title:
    "How to synchronize your Liveblocks Yjs document data to a Supabase Postgres
    database"
  description:
    "Learn how to automatically update your Supabase Postgres database with
    changes from your Yjs application."
---

Liveblocks allows you to build collaborative applications with
[Yjs](https://yjs.dev/), which is tightly integrated into our infrastructure.
Using our webhooks and REST API, you can then retrieve the Yjs document data as
it changes, and store it in your database.

## What weâ€™re building

In this guide weâ€™ll be linking a Yjs application up to a
[Supabase Postgres](https://supabase.com/database) database so that Yjs document
data is automatically synchronized. This is enabled through the following:

- [YDocUpdated](/docs/platform/webhooks#YDocUpdatedEvent) webhook event
- [Get Yjs Document](/docs/api-reference/rest-api-endpoints#get-rooms-roomId-ydoc)
  REST API

<Banner title="Have a project ready">

This guide assumes you already have a Liveblocks Yjs project set up. If you
havenâ€™t already got one, you can open our getting started page, select a
[text editor](/docs/get-started/text-editor) or
[code editor](/docs/get-started/code-editor), both of which use Yjs, and come
back after youâ€™re set up.

</Banner>

### This specific webhook is throttled

Note that the [YDocUpdated](/docs/platform/webhooks#YDocUpdatedEvent) webhook
event is throttled at a rate of _once every 60 seconds_. This is because Yjs can
update up to _60 times per second_, and it would be impractical to run the
webhook this frequently.

## Create an endpoint in your project

When a webhook event is triggered, it can send a POST request to the back end in
your project, and from within there we can update the database. In this guide,
weâ€™ll be using a Next.js route handler (API endpoint) as an example, but other
frameworks work similarly.

In order to use webhooks, weâ€™ll need to retrieve the `headers` and `body` from
the request. Hereâ€™s the basic endpoint weâ€™ll be starting from:

```ts
export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Handle webhooks and database
  // ...

  return new Response(null, { status: 200 });
}
```

Create this endpoint in your project, and make it available on `localhost` at
the following URL:

```
/api/liveblocks-database-sync
```

### Testing webhooks locally

Running webhooks locally can be difficult, but one way to do this is to use a
tool such as [`localtunnel`](https://www.npmjs.com/package/localtunnel) or
[`ngrok`](https://www.npmjs.com/package/ngrok) which allow you to temporarily
put your localhost server online.

If your project is running on `localhost:3000`, you can run the following
command to generate a temporary URL thatâ€™s available while your localhost server
is running:

```bash
npx localtunnel --port 3000
```

`localtunnel` generates a base URL that can be placed into the Liveblocks
webhooks dashboard for quick testing. To use this, take the full address of your
webhook endpoint, and replace the domain in your `localhost` address with the
generated URL.

```shell
# Take your local URL
http://localhost:3000/api/liveblocks-database-sync

# Replace localhost with the generated domain, then copy it
https://my-localtunnel-url.loca.lt/api/liveblocks-database-sync
```

You now have a URL that can be used in the webhooks dashboard.

## Set up webhooks on the Liveblocks dashboard

To use webhooks, you need to pass your endpoint URL to the webhooks dashboard
inside your Liveblocks project, and tell the webhook to trigger when Yjs
document data has changed.

<Steps>
  <Step>
    <StepTitle>Select your project</StepTitle>
    <StepContent>
      From the [Liveblocks dashboard](/dashboard), navigate to the project youâ€™d
      like to use with webhooks, or create a new project.
      <Figure>
        <Image
          src="/assets/tutorials/webhooks/liveblocks-create-project.png"
          alt="Create a Liveblocks project"
          width={712}
          height={445}
        />
      </Figure>
    </StepContent>
  </Step>

<Step>
  <StepTitle>Go to the webhooks dashboard</StepTitle>
  <StepContent>
    Click on the **â€œWebhooksâ€** tab on the menu at the left.
    <Figure>
      <Image
        src="/assets/tutorials/webhooks/liveblocks-click-webhooks.png"
        alt="Click webhooks"
        width={712}
        height={445}
      />
    </Figure>
  </StepContent>
</Step>

<Step>
  <StepTitle>Create an endpoint</StepTitle>
  <StepContent>
    Click the **â€œCreate endpointâ€¦â€** button on the webhooks dashboard to start
    setting up your webhook.
    <Figure>
      <Image
        src="/assets/tutorials/webhooks/liveblocks-add-endpoint.png"
        alt="Click add endpoint"
        width={712}
        height={445}
      />
    </Figure>
  </StepContent>
</Step>

<Step>
  <StepTitle>Add your endpoint URL</StepTitle>
  <StepContent>
    Enter the URL of the endpoint. In a production app this will be the real
    endpoint, but for now enter your `localtunnel` URL from earlier.
    <Figure>
      <Image
        src="/assets/tutorials/webhooks/liveblocks-add-endpoint-url.png"
        alt="Add endpoint URL"
        width={712}
        height={445}
      />
    </Figure>
  </StepContent>
</Step>

<Step>
  <StepTitle>Get your webhook secret key</StepTitle>
  <StepContent>
    Click **â€œCreate endpointâ€** at the bottom, then find your **â€œSecret keyâ€**
    on the next page, and copy it.
    <Figure>
      <Image
        src="/assets/tutorials/webhooks/liveblocks-get-secret-key.png"
        alt="Copy your webhook secret key"
        width={712}
        height={445}
      />
    </Figure>
  </StepContent>
</Step>

  <Step lastStep>
    <StepTitle>Webhooks dashboard is set up!</StepTitle>

    <StepContent>
      Note that you can filter specifically for `ydocUpdated` events, but weâ€™re
      ignoring this for now so we can test more easily. Letâ€™s go back to the
      code.
    </StepContent>

  </Step>
</Steps>

## Verify the webhook request

The [`@liveblocks/node`](/docs/api-reference/liveblocks-node) package provides
you with a function that verifies whether the current request is a real webhook
request from Liveblocks. You can set this up by setting up a
[`WebhookHandler`](/docs/api-reference/liveblocks-node#WebhookHandler) and
running [`verifyRequest`](/docs/api-reference/liveblocks-node#verifyRequest).

Make sure to add your â€œSigning Secretâ€ from the Liveblocks dashboardâ€”in a real
project weâ€™d recommend using an environment variable for this.

```ts highlight="1,3-5,11-21"
import { WebhookHandler } from "@liveblocks/node";

// Add your signing key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_SIGNING_SECRET";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // Update database
  // ...

  return new Response(null, { status: 200 });
}
```

We can then check weâ€™re receiving the correct type of event, get the updated
`roomId`, and handle updating the database inside there.

```ts highlight="23-29"
import { WebhookHandler } from "@liveblocks/node";

// Add your signing key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_SIGNING_SECRET";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // When Yjs document data has been updated
  if (event.type === "ydocUpdated") {
    const { roomId } = event.data;

    // Update database
    // ...
  }

  return new Response(null, { status: 200 });
}
```

## Get the current roomâ€™s Yjs document data

Before updating our database, we need to get the current roomâ€™s data. We can do
this through the
[Get Yjs Document](/docs/api-reference/rest-api-endpoints#get-rooms-roomId-ydoc)
REST API. You use the REST API, you need to add your secret key from your
project page.

```ts highlight="7-8,30-43"
import { WebhookHandler } from "@liveblocks/node";

// Add your signing key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_SIGNING_SECRET";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

// Add your secret key from a project's API keys dashboard
const API_SECRET = "{{SECRET_KEY}}";

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // When Yjs document data has been updated
  if (event.type === "ydocUpdated") {
    const { roomId } = event.data;

    // Get Yjs data from Liveblocks REST API
    const url = `https://api.liveblocks.io/v2/rooms/${roomId}/ydoc`;
    const response = await fetch(url, {
      headers: { Authorization: `Bearer ${API_SECRET}` },
    });

    if (!response.ok) {
      return new Response("Problem accessing Liveblocks REST APIs", {
        status: 500,
      });
    }

    // Your JSON Yjs document data as a string
    const yDocData = await response.text();

    // Update database
    // ...
  }

  return new Response(null, { status: 200 });
}
```

## Create a Supabase Postgres database

Weâ€™re ready to set up our Supabase database! Weâ€™ll be creating a simple
`documents` table that contains the following fields:

| Field      | Description                    | Type           | Key       |
| ---------- | ------------------------------ | -------------- | --------- |
| `roomId`   | The `roomId`.                  | `VARCHAR(255)` | `PRIMARY` |
| `yDocData` | The stringified JSON Yjs data. | `TEXT`         |           |

<Steps>
  <Step>
    <StepTitle>New project</StepTitle>
    <StepContent>
      Navigate to Supabaseâ€™s [dashboard
      page](https://supabase.com/dashboard/projects), and click â€œNew projectâ€ at
      the top.
      <Figure>
        <Image
          src="/assets/tutorials/webhooks/supabase-new-project.png"
          alt="Click new project"
          width={942}
          height={443}
        />
      </Figure>
    </StepContent>
  </Step>

<Step>
  <StepTitle>Create a database</StepTitle>
  <StepContent>
    Give your database a name and password, then click â€œCreate new projectâ€ at
    the bottom. Make sure to save your password, because you wonâ€™t be able to
    view it again.
    <Figure>
      <Image
        src="/assets/tutorials/webhooks/supabase-new-project-details.png"
        alt="Create a new project"
        width={1517}
        height={1203}
      />
    </Figure>
  </StepContent>
</Step>

<Step>
  <StepTitle>Create your table</StepTitle>
  <StepContent>
    Click the SQL Editor icon in the left bar, enter the following code into the
    console, and click â€œRunâ€ at the bottom right to create the table. ```sql
    CREATE TABLE documents ( roomId VARCHAR(255) PRIMARY KEY, yDocData TEXT NOT
    NULL ); ```
    <Figure>
      <Image
        src="/assets/tutorials/webhooks/supabase-create-schema.png"
        alt="Create your table schema"
        width={1635}
        height={984}
      />
    </Figure>
  </StepContent>
</Step>

<Step>
  <StepTitle>Get your credentials</StepTitle>
  <StepContent>
    Click the Settings icon in the left bar, click â€œAPIâ€ at the left and find
    two items: 1. Your â€œURLâ€, under â€œProject URLâ€. 2. Your `anon``public` key,
    under â€œProject API keyâ€. Make a note of these, or add them as environment
    variables in your project.
    <Figure>
      <Image
        src="/assets/tutorials/webhooks/supabase-get-credentials.png"
        alt="Create your table schema"
        width={2053}
        height={972}
      />
    </Figure>
  </StepContent>
</Step>

  <Step lastStep>
    <StepTitle>Database ready!</StepTitle>
    <StepContent>Letâ€™s take a look at the code.</StepContent>
  </Step>
</Steps>

## Add the Yjs data to your database

And finally, we can add the Yjs JSON data to our database! First, we need to
install the Supabase library:

```bash
npm i @supabase/supabase-js
```

Then implement the following to synchronize your data, making sure to add your
Project URL:

```ts highlight="2,11-15,52-62"
import { WebhookHandler } from "@liveblocks/node";
import { createClient } from "@supabase/supabase-js";

// Add your signing key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_SIGNING_SECRET";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

// Add your secret key from a project's API keys dashboard
const API_SECRET = "{{SECRET_KEY}}";

// Create a Supabase client
const supabase = createClient(
  "YOUR_SUPABASE_PROJECT_URL",
  "YOUR_SUPABASE_PUBLIC_ANON_KEY"
);

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // When Yjs document data has been updated
  if (event.type === "ydocUpdated") {
    const { roomId } = event.data;

    // Get Yjs data from Liveblocks REST API
    const url = `https://api.liveblocks.io/v2/rooms/${roomId}/ydoc`;
    const response = await fetch(url, {
      headers: { Authorization: `Bearer ${API_SECRET}` },
    });

    if (!response.ok) {
      return new Response("Problem accessing Liveblocks REST APIs", {
        status: 500,
      });
    }

    // Your JSON Yjs document data as a string
    const yDocData = await response.text();

    // Update database
    const { data, error } = await supabase
      .from("documents")
      .insert({ roomid: roomId, ydocdata: yDocData })
      .select();

    if (error) {
      return new Response("Problem inserting data into database", {
        status: 500,
      });
    }
  }

  return new Response(null, { status: 200 });
}
```

## Check if it worked

To check if it worked, you can replay an event from the Liveblocks dashboard, or
just edit your document.

<Figure>
  <Image
    src="/assets/tutorials/webhooks/liveblocks-replay-event.png"
    alt="Create your table schema"
    width={1563}
    height={657}
  />
</Figure>

Next, go to Supabase, and click the Table Editor icon on the left bar. Find your
`documents` table on the left, and check the entries. You should now see your
Yjs documentâ€”weâ€™ve successfully set up data synchronization!

When a user edits Yjs data in your app, this function will be called, and your
database will be updated. You can rely on this to stay up to date, within the 60
second throttle limit.

## Learn more

You can learn more about Liveblocks webhooks in our full
[webhooks guide](/docs/platform/webhooks). We also have an API reference for the
[Get Yjs Document API](/docs/api-reference/rest-api-endpoints#get-rooms-roomId-ydoc).

---
meta:
  title:
    "How to synchronize your Liveblocks Yjs document data to a Vercel Postgres
    database"
  description:
    "Learn how to automatically update your Vercel Postgres database with
    changes from your Yjs application."
---

Liveblocks allows you to build collaborative applications with
[Yjs](https://yjs.dev/), which is tightly integrated into our infrastructure.
Using our webhooks and REST API, you can then retrieve the Yjs document data as
it changes, and store it in your database.

## What weâ€™re building

In this guide weâ€™ll be linking a Yjs application up to a
[Vercel Postgres](https://vercel.com/docs/storage/vercel-postgres) database so
that Yjs document data is automatically synchronized. This is enabled through
the following:

- [YDocUpdated](/docs/platform/webhooks#YDocUpdatedEvent) webhook event
- [Get Yjs Document](/docs/api-reference/rest-api-endpoints#get-rooms-roomId-ydoc)
  REST API

<Banner title="Have a project ready">

This guide assumes you already have a Liveblocks Yjs project set up. If you
havenâ€™t already got one, you can open our getting started page, select a
[text editor](/docs/get-started/text-editor) or
[code editor](/docs/get-started/code-editor), both of which use Yjs, and come
back after youâ€™re set up.

</Banner>

### This specific webhook is throttled

Note that the [YDocUpdated](/docs/platform/webhooks#YDocUpdatedEvent) webhook
event is throttled at a rate of _once every 60 seconds_. This is because Yjs can
update up to _60 times per second_, and it would be impractical to run the
webhook this frequently.

## Create an endpoint in your project

When a webhook event is triggered, it can send a POST request to the back end in
your project, and from within there we can update the database. In this guide,
weâ€™ll be using a Next.js route handler (API endpoint) as an example, but other
frameworks work similarly.

In order to use webhooks, weâ€™ll need to retrieve the `headers` and `body` from
the request. Hereâ€™s the basic endpoint weâ€™ll be starting from:

```ts
export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Handle webhooks and database
  // ...

  return new Response(null, { status: 200 });
}
```

Create this endpoint in your project, and make it available on `localhost` at
the following URL:

```
/api/liveblocks-database-sync
```

### Testing webhooks locally

Running webhooks locally can be difficult, but one way to do this is to use a
tool such as [`localtunnel`](https://www.npmjs.com/package/localtunnel) or
[`ngrok`](https://www.npmjs.com/package/ngrok) which allow you to temporarily
put your localhost server online.

If your project is running on `localhost:3000`, you can run the following
command to generate a temporary URL thatâ€™s available while your localhost server
is running:

```bash
npx localtunnel --port 3000
```

`localtunnel` generates a base URL that can be placed into the Liveblocks
webhooks dashboard for quick testing. To use this, take the full address of your
webhook endpoint, and replace the domain in your `localhost` address with the
generated URL.

```shell
# Take your local URL
http://localhost:3000/api/liveblocks-database-sync

# Replace localhost with the generated domain, then copy it
https://my-localtunnel-url.loca.lt/api/liveblocks-database-sync
```

You now have a URL that can be used in the webhooks dashboard.

## Set up webhooks on the Liveblocks dashboard

To use webhooks, you need to pass your endpoint URL to the webhooks dashboard
inside your Liveblocks project, and tell the webhook to trigger when Yjs
document data has changed.

<Steps>
  <Step>
    <StepTitle>Select your project</StepTitle>
    <StepContent>
      From the [Liveblocks dashboard](/dashboard), navigate to the project youâ€™d
      like to use with webhooks, or create a new project.

      <Figure>
        <Image
          src="/assets/tutorials/webhooks/liveblocks-create-project.png"
          alt="Create a Liveblocks project"
          width={712}
          height={445}
        />
      </Figure>
    </StepContent>

  </Step>

<Step>
  <StepTitle>Go to the webhooks dashboard</StepTitle>
  <StepContent>
    Click on the **â€œWebhooksâ€** tab on the menu at the left.
    <Figure>
      <Image
        src="/assets/tutorials/webhooks/liveblocks-click-webhooks.png"
        alt="Click webhooks"
        width={712}
        height={445}
      />
    </Figure>
  </StepContent>
</Step>

<Step>
  <StepTitle>Create an endpoint</StepTitle>
  <StepContent>
    Click the **â€œCreate endpointâ€¦â€** button on the webhooks dashboard to start
    setting up your webhook.
    <Figure>
      <Image
        src="/assets/tutorials/webhooks/liveblocks-add-endpoint.png"
        alt="Click add endpoint"
        width={712}
        height={445}
      />
    </Figure>
  </StepContent>
</Step>

<Step>
  <StepTitle>Add your endpoint URL</StepTitle>
  <StepContent>
    Enter the URL of the endpoint. In a production app this will be the real
    endpoint, but for now enter your `localtunnel` URL from earlier.
    <Figure>
      <Image
        src="/assets/tutorials/webhooks/liveblocks-add-endpoint-url.png"
        alt="Add endpoint URL"
        width={712}
        height={445}
      />
    </Figure>
  </StepContent>
</Step>

<Step>
  <StepTitle>Get your webhook secret key</StepTitle>
  <StepContent>
    Click **â€œCreate endpointâ€** at the bottom, then find your **â€œSecret keyâ€**
    on the next page, and copy it.
    <Figure>
      <Image
        src="/assets/tutorials/webhooks/liveblocks-get-secret-key.png"
        alt="Copy your webhook secret key"
        width={712}
        height={445}
      />
    </Figure>
  </StepContent>
</Step>

  <Step lastStep>
    <StepTitle>
      Webhooks dashboard is set up!
    </StepTitle>

    <StepContent>
      Note that you can filter specifically for `ydocUpdated`
      events, but weâ€™re ignoring this for now so we can test more easily. Letâ€™s go
      back to the code.
    </StepContent>

  </Step>

</Steps>

## Verify the webhook request

The [`@liveblocks/node`](/docs/api-reference/liveblocks-node) package provides
you with a function that verifies whether the current request is a real webhook
request from Liveblocks. You can set this up by setting up a
[`WebhookHandler`](/docs/api-reference/liveblocks-node#WebhookHandler) and
running [`verifyRequest`](/docs/api-reference/liveblocks-node#verifyRequest).

Make sure to add your â€œSigning Secretâ€ from the Liveblocks dashboardâ€”in a real
project weâ€™d recommend using an environment variable for this.

```ts highlight="1,3-5,11-21"
import { WebhookHandler } from "@liveblocks/node";

// Add your signing key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_SIGNING_SECRET";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // Update database
  // ...

  return new Response(null, { status: 200 });
}
```

We can then check weâ€™re receiving the correct type of event, get the updated
`roomId`, and handle updating the database inside there.

```ts highlight="23-29"
import { WebhookHandler } from "@liveblocks/node";

// Add your signing key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_SIGNING_SECRET";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // When Yjs document data has been updated
  if (event.type === "ydocUpdated") {
    const { roomId } = event.data;

    // Update database
    // ...
  }

  return new Response(null, { status: 200 });
}
```

## Get the current roomâ€™s Yjs document data

Before updating our database, we need to get the current roomâ€™s data. We can do
this through the
[Get Yjs Document](/docs/api-reference/rest-api-endpoints#get-rooms-roomId-ydoc)
REST API. You use the REST API, you need to add your secret key from your
project page.

```ts highlight="7-8,30-43"
import { WebhookHandler } from "@liveblocks/node";

// Add your signing key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_SIGNING_SECRET";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

// Add your secret key from a project's API keys dashboard
const API_SECRET = "{{SECRET_KEY}}";

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // When Yjs document data has been updated
  if (event.type === "ydocUpdated") {
    const { roomId } = event.data;

    // Get Yjs data from Liveblocks REST API
    const url = `https://api.liveblocks.io/v2/rooms/${roomId}/ydoc`;
    const response = await fetch(url, {
      headers: { Authorization: `Bearer ${API_SECRET}` },
    });

    if (!response.ok) {
      return new Response("Problem accessing Liveblocks REST APIs", {
        status: 500,
      });
    }

    // Your JSON Yjs document data as a string
    const yDocData = await response.text();

    // Update database
    // ...
  }

  return new Response(null, { status: 200 });
}
```

## Create a Vercel Postgres database

Weâ€™re ready to set up our database! This is how to get started with Vercel
Postgres:

<Steps>
  <StepCompact>
    Navigate to the [Vercel Storage](https://vercel.com/dashboard/stores)
    dashboard.
  </StepCompact>

<StepCompact>Click "Create Database", then select â€œPostgresâ€.</StepCompact>

<StepCompact>Give the database a name and click â€œCreateâ€.</StepCompact>

  <StepCompact lastStep>
    Follow the getting started guide to connect the database to
    your Vercel project, link your environment variables, and install the packages.
  </StepCompact>
</Steps>

## Add the Yjs data to your database

And finally, we can add the Yjs JSON data to our database. Here weâ€™re creating a
simple `documents` table that contains the following fields:

| Field      | Description                    | Type           | Key       |
| ---------- | ------------------------------ | -------------- | --------- |
| `roomId`   | The `roomId`.                  | `VARCHAR(255)` | `PRIMARY` |
| `yDocData` | The stringified JSON Yjs data. | `TEXT`         |           |

This is how to implement it in your endpoint:

```ts highlight="2,46-65"
import { WebhookHandler } from "@liveblocks/node";
import { sql } from "@vercel/postgres";

// Add your signing key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_SIGNING_SECRET";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

// Add your secret key from a project's API keys dashboard
const API_SECRET = "{{SECRET_KEY}}";

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // When Yjs document data has been updated
  if (event.type === "ydocUpdated") {
    const { roomId } = event.data;

    // Get Yjs data from Liveblocks REST API
    const url = `https://api.liveblocks.io/v2/rooms/${roomId}/ydoc`;
    const response = await fetch(url, {
      headers: { Authorization: `Bearer ${API_SECRET}` },
    });

    if (!response.ok) {
      return new Response("Problem accessing Liveblocks REST APIs", {
        status: 500,
      });
    }

    // Your JSON Yjs document data as a string
    const yDocData = await response.text();

    // Update database
    try {
      await sql`
        CREATE TABLE IF NOT EXISTS documents (
          roomId VARCHAR(255) PRIMARY KEY,
          yDocData TEXT NOT NULL
        );
      `;
      await sql`
        INSERT INTO documents (roomId, yDocData)
        VALUES (${roomId}, ${yDocData})
        ON CONFLICT (roomId)
        DO UPDATE SET
          yDocData = EXCLUDED.yDocData
      `;
    } catch (err) {
      return new Response("Problem inserting data into database", {
        status: 500,
      });
    }
  }

  return new Response(null, { status: 200 });
}
```

## Check if it worked

To check if your database synchronization is working, you can replay a
`yDocUpdated` event from the Liveblocks dashboard.

<Figure>
  <Image
    src="/assets/tutorials/webhooks/liveblocks-replay-event.png"
    alt="Create your table schema"
    width={1563}
    height={657}
  />
</Figure>

Then go to the Data page on your Vercel Postgres dashboard, find your table in
the dropdown, and check the entries. You should now see your Yjs documentâ€”weâ€™ve
successfully set up data synchronization!

When a user edits Yjs data in your app, this function will be called, and your
database will be updated. You can rely on this to stay up to date, within the 60
second throttle limit.

## Learn more

You can learn more about Liveblocks webhooks in our full
[webhooks guide](/docs/platform/webhooks). We also have an API reference for the
[Get Yjs Document API](/docs/api-reference/rest-api-endpoints#get-rooms-roomId-ydoc).

---
meta:
  title: "How to test webhooks on localhost"
  description:
    "Learn how to test Liveblocks webhooks on your local system using
    localtunnel or ngrok."
---

Testing webhooks on your local system can be difficult, but there are ways to
make it possible using tools such as
[`localtunnel`](https://www.npmjs.com/package/localtunnel) and
[`ngrok`](https://www.npmjs.com/package/ngrok).

## Create an endpoint in your project

The first step in testing webhooks is making sure you have an API endpoint set
up in your project. This is the endpoint thatâ€™ll receive the webhook event from
Liveblocks.

In order to use webhooks, weâ€™ll need to retrieve the `headers` and `body` from
the request. Hereâ€™s the basic endpoint weâ€™ll be starting from:

```ts
export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Handle webhooks
  // ...

  return new Response(null, { status: 200 });
}
```

Create this endpoint in your project, and make it available on `localhost` at
the following URL:

```
/api/liveblocks-webhook
```

## Testing webhooks locally

There are several tools that allow you to temporarily place your localhost
server online, by providing you with a temporary URL. Letâ€™s take a look at these
options.

### svix-cli

The [`svix-cli`](https://github.com/svix/svix-webhooks/tree/main/svix-cli)
provides a `listen` command that creates a publicly accessible URL for testing
webhooks. This approach is particularly useful in enterprise environments where
other tunneling tools may be blocked by security policies.

The `listen` command acts as a proxy, forwarding any requests to your local URL
without requiring account setup or network configuration changes.

If your project is running on `localhost:3000`, you can run the following
command to generate your URL:

```bash
svix listen http://localhost:3000/api/liveblocks-webhook
```

The `svix-cli` will provide you with a unique URL and forward any POST requests
it receives to your local endpoint. To use this, copy the generated URL directly
into the Liveblocks webhooks dashboard.

```shell
# The svix-cli generates a URL like this:
https://play.svix.com/in/c_tSdQhb4Q5PTF5m2juiWu8qFREqE/

# Use this URL directly in the webhooks dashboard
```

You now have a URL that can be used in the webhooks dashboard, along with a
debug interface to view logs and request details.

### localtunnel

[`localtunnel`](https://www.npmjs.com/package/localtunnel) allows you to get
started without signing up. If your project is running on `localhost:3000`, you
can run the following `localtunnel` command to generate your URL, which will
stay online while your localhost server is running:

```bash
npx localtunnel --port 3000
```

`localtunnel` generates a base URL that can be placed into the Liveblocks
webhooks dashboard for quick testing. To use this, take the full address of your
webhook endpoint, and replace the domain in your `localhost` address with the
generated URL.

```shell
# Take your local URL
http://localhost:3000/api/liveblocks-webhook

# Replace localhost with the generated domain, then copy it
https://my-localtunnel-url.loca.lt/api/liveblocks-webhook
```

You now have a URL that can be used in the webhooks dashboard.

### ngrok

[`ngrok`](https://www.npmjs.com/package/ngrok) requires you to sign up and
install, but it has more features and is simpler to use after youâ€™ve created an
account. If your project is running on `localhost:3000`, you can run the
following `ngrok` command to generate your URL, which will stay online while
your localhost server is running:

```bash
ngrok http 3000
```

`ngrok` generates a base URL that can be placed into the Liveblocks webhooks
dashboard for quick testing. To use this, take the full address of your webhook
endpoint, and replace the domain in your `localhost` address with the generated
URL.

```shell
# Take your local URL
http://localhost:3000/api/liveblocks-webhook

# Replace localhost with the generated domain, then copy it
https://my-ngrok-url.ngrok.io/api/liveblocks-webhook
```

You now have a URL that can be used in the webhooks dashboard.

## Set up webhooks on the Liveblocks dashboard

To use webhooks, you need to pass your endpoint URL to the webhooks dashboard
inside your Liveblocks project, and tell the webhook to trigger on any specific
[webhook events](/docs/platform/webhooks#Liveblocks-events).

<Steps>
  <Step>
    <StepTitle>Select your project</StepTitle>
    <StepContent>
      From the [Liveblocks dashboard](/dashboard), navigate to the project youâ€™d
      like to use with webhooks, or create a new project.
      <Figure>
        <Image
          src="/assets/tutorials/webhooks/liveblocks-create-project.png"
          alt="Create a Liveblocks project"
          width={712}
          height={445}
        />
      </Figure>
    </StepContent>
  </Step>

<Step>
  <StepTitle>Go to the webhooks dashboard</StepTitle>
  <StepContent>
    Click on the **â€œWebhooksâ€** tab on the menu at the left.
    <Figure>
      <Image
        src="/assets/tutorials/webhooks/liveblocks-click-webhooks.png"
        alt="Click webhooks"
        width={712}
        height={445}
      />
    </Figure>
  </StepContent>
</Step>

<Step>
  <StepTitle>Create an endpoint</StepTitle>
  <StepContent>
    Click the **â€œCreate endpointâ€¦â€** button on the webhooks dashboard to start
    setting up your webhook.
    <Figure>
      <Image
        src="/assets/tutorials/webhooks/liveblocks-add-endpoint.png"
        alt="Click add endpoint"
        width={712}
        height={445}
      />
    </Figure>
  </StepContent>
</Step>

<Step>
  <StepTitle>Add your endpoint URL</StepTitle>
  <StepContent>
    Enter the URL of the endpoint. In a production app this will be the real
    endpoint, but for now enter your `localtunnel` or `ngrok` URL from earlier.

    You can filter for any specific [webhook events](/docs/platform/webhooks#Liveblocks-events) here, in case youâ€™d only like to listen to certain types.
    <Figure>
      <Image
        src="/assets/tutorials/webhooks/liveblocks-add-endpoint-url.png"
        alt="Add endpoint URL"
        width={712}
        height={445}
      />
    </Figure>

  </StepContent>
</Step>

<Step>
  <StepTitle>Get your secret key</StepTitle>
  <StepContent>
    Click **â€œCreate endpointâ€** at the bottom, then find your **â€œSecret keyâ€**
    on the next page, and copy it.
    <Figure>
      <Image
        src="/assets/tutorials/webhooks/liveblocks-get-secret-key.png"
        alt="Copy your webhook secret key"
        width={712}
        height={445}
      />
    </Figure>
  </StepContent>
</Step>

  <Step lastStep>
    <StepTitle>Webhooks dashboard is set up!</StepTitle>

    <StepContent>
      Done! Letâ€™s go back to the code.
    </StepContent>

  </Step>
</Steps>

## Verify the webhook request

Itâ€™s recommended to verify that your webhook requests have come from Liveblocks,
and the [`@liveblocks/node`](/docs/api-reference/liveblocks-node) package
provides you with a function that will verify this for you. You can set this up
by creating a
[`WebhookHandler`](/docs/api-reference/liveblocks-node#WebhookHandler) and
running [`verifyRequest`](/docs/api-reference/liveblocks-node#verifyRequest).

Make sure to add your "Webhook secret key" from the Liveblocks dashboardâ€”in a
real project weâ€™d recommend using an environment variable for this.

```ts highlight="1,3-5,11-21"
import { WebhookHandler } from "@liveblocks/node";

// Add your webhook secret key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_WEBHOOK_SECRET";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // Use webhook event
  // ...

  return new Response(null, { status: 200 });
}
```

The webhook has now been verified!

## Use your webhook event

From this point on, you can use the webhook event as you like. Hereâ€™s a
[Comments](/docs/ready-made-features/comments) example, showing you how to fetch
a new thread after itâ€™s just been created.

```ts highlight="2,8-10,28-37"
import { WebhookHandler } from "@liveblocks/node";
import { Liveblocks } from "@liveblocks/node";

// Add your webhook secret key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_WEBHOOK_SECRET";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

// Add your secret key from a project's API keys dashboard
const API_SECRET = "{{SECRET_KEY}}";
const liveblocks = new Liveblocks({ secret: API_SECRET });

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  // When a new thread has been created
  if (event.type === "threadCreated") {
    const { roomId, threadId } = event.data;

    // Fetch new thread
    const thread = await liveblocks.getThread({ roomId, threadId });

    // Use thread
    // ...
  }

  return new Response(null, { status: 200 });
}
```

Visit the [webhook events](/docs/platform/webhooks#Liveblocks-events) section of
our webhooks guide to learn more.

---
meta:
  title: "How to use fallback AI models in AI Copilots"
  description:
    "Learn how to set different AI models as fallbacks when your primary model
    isnâ€™t available"
---

AI Copilots allows you to select an AI model when you
[create a copilot](/docs/ready-made-features/ai-copilots/copilots#Creating-a-copilot),
however AI models are regularly down and token usage limits are easily reached.
Liveblocks supports using OpenAI-compatible models when you create a copilot,
and you can use this with a service such as
[OpenRouter](https://openrouter.ai/), which will swap in a fallback model when
your primary model is unavailable or over its rate limit.

## Creating fallbacks with OpenRouter

How to set up OpenRouter and attach your fallback models to your Liveblocks
copilot.

<Steps>

<Step>
  <StepTitle>Create an account</StepTitle>
  <StepContent>
    To get started, first sign up for an account at
    [OpenRouter](https://openrouter.ai/).
  </StepContent>
</Step>

<Step>
  <StepTitle>Add credit or set up integrations</StepTitle>
  <StepContent>
    You can add credit, and pay OpenRouter directly for model usage, or you can
    insert API keys from AI providers. Go to â€œSettingsâ€ and then either â€œCreditâ€
    or â€œIntegrationsâ€, and set it up as you prefer.
  </StepContent>
</Step>

<Step>
  <StepTitle>Create a preset</StepTitle>
  <StepContent>
    Presets let you define your AI settings, including the fallback model.
    Create a new preset, and make note of the **name**, as weâ€™ll need this
    later. Select multiple AI modelsâ€”the first will be your primary, and the
    rest will be your fallbacks. After this, save your model.
  </StepContent>
</Step>

<Step>
  <StepTitle>Create an API key</StepTitle>
  <StepContent>
    Navigate to â€œSettingsâ€ and then â€œAPI Keysâ€. Create an **API key**, and save
    it for later.
  </StepContent>
</Step>

<Step>
  <StepTitle>Add to your Liveblocks copilot</StepTitle>
  <StepContent>
    Navigate to the [Liveblocks dashboard](https://liveblocks.io/dashboard), select your project and
    click on â€œCopilotsâ€. Click on â€œAdd Copilotâ€ and use the following settings:

  <dl>
    <dt>Name</dt>
    <dd>_Whatever you like_. Example: `My Copilot`</dd>
    <dt>Model</dt>
    <dd>`OpenAI compatible`</dd>
    <dt>Model</dt>
    <dd>Insert the **name** of the OpenRouter preset, prefixed by `@preset/`. For example if the name was `my-model` your should insert `@preset/my-model`.</dd>
    <dt>Custom provider name</dt>
    <dd>_Whatever you like_. Example: `custom`</dd>
    <dt>Base URL</dt>
    <dd>`https://openrouter.ai/api/v1/`</dd>
    <dt>API Key</dt>
    <dd>Insert the OpenRouter **API key** you created earlier. Example: `sk-or-v1-...`</dd>
    <dt>System Prompt</dt>
    <dd>_Your system prompt_. Example: `You are a helpful assistant.`</dd>
  </dl>
  </StepContent>
</Step>

<Step lastStep>
  <StepTitle>Copy the copilot ID into your app</StepTitle>
  <StepContent>
    Youâ€™ve now set up a copilot with fallbacks! Copy the `copilotId` from the dashboard into
    [`AiChat`](/docs/api-reference/liveblocks-react-ui#AiChat) and
    [`useSendAiMessage`](/docs/api-reference/liveblocks-react#useSendAiMessage) to
    start using it in your application.

    ```tsx
    import { AiChat } from "@liveblocks/react-ui";

    function Chat() {
      return (
        <AiChat
          chatId="my-chat-id"
          // +++
          copilotId="co_tUYtNctLAtUIAAIZBc1Zk"
          // +++
        />
      );
    }
    ```

    ```tsx
    import { useSendAiMessage } from "@liveblocks/react";

    function SendMessage() {
      const sendAiMessage = useSendAiMessage("my-chat-id", {
        // +++
        copilotId: "co_tUYtNctLAtUIAAIZBc1Zk",
        // +++
      });

      return (
        <button onClick={() => sendAiMessage("What's new?")}>What's new?</button>
      );
    }
    ```

  </StepContent>
</Step>
</Steps>

## Learn more

While weâ€™ve had success with OpenRouter, there are likely alternative services
that work too, as long as they are OpenAI-compatible. To learn more about
setting up a copilot read our
[Copilots](/docs/ready-made-features/ai-copilots/copilots) overview page.

---
meta:
  title: "How to use Liveblocks multiplayer undo/redo with React"
  description: "Learn how to use Liveblocks multiplayer undo/redo with React"
---

In this guide, weâ€™ll be learning how to use Liveblocks multiplayer undo/redo
with React using the hooks from the [`@liveblocks/react`][] package.

This guide uses [TypeScript](https://www.typescriptlang.org/). Liveblocks can
definitely be used without TypeScript. We believe typings are helpful to make
collaborative apps more robust, but if youâ€™d prefer to skip the TypeScript
syntax, feel free to write your code in JavaScript.

<Banner title="Install Liveblocks">

This guide assumes you already have Liveblocks set up into your React
application. If you donâ€™t make sure to follow
[these quick steps to get started](/docs/get-started/react) first.

</Banner>

## Multiplayer undo/redo [#undo-redo]

Implementing undo/redo in a multiplayer environment is
[notoriously complex](/blog/how-to-build-undo-redo-in-a-multiplayer-environment),
but Liveblocks provides functions to handle it for you. `useUndo` and `useRedo`
return functions that allow you to undo and redo the last changes made to your
app.

```tsx highlight="4,5,9,10"
import { useUndo, useRedo } from "@liveblocks/react/suspense";

function App() {
  const undo = useUndo();
  const redo = useRedo();

  return (
    <>
      <button onClick={() => undo()}>Undo</button>
      <button onClick={() => redo()}>Redo</button>
    </>
  );
}
```

An example of this in use would be a button that updates the current `firstName`
of a scientist. Every time a Liveblocks storage change is detected, in this case
`.set` being called, itâ€™s stored. Pressing the undo button will change the name
back to its previous value.

```tsx highlight="6,9,15,16"
import { useState } from "react";
import { useMutation, useUndo } from "@liveblocks/react/suspense";

function YourComponent() {
  const [text, setText] = useState("");
  const undo = useUndo();

  const updateName = useMutation(({ storage }, newName) => {
    storage.get("scientist").set("firstName", newName);
  });

  return (
    <>
      <input
        type="text"
        value={text}
        onChange={(e) => setText(e.target.value)}
      />
      <button onClick={() => updateName(text)}>Update Name</button>
      <button onClick={() => undo()}></button>
    </>
  );
}
```

Multiplayer undo/redo is much more complex that it soundsâ€”if youâ€™re interested
in the technical details, you can find more information in our interactive
article:
[How to build undo/redo in a multiplayer environment](/blog/how-to-build-undo-redo-in-a-multiplayer-environment).

### Pause and resume history [#pause-resume]

Sometimes it can be helpful to pause undo/redo history, so that multiple updates
are reverted with a single call.

For example, letâ€™s consider a design tool; when a user drags a rectangle, the
intermediate rectangle positions should not be part of the undo/redo history,
otherwise pressing `undo` may only move the rectangle one pixel backwards.
However, these small pixel updates should still be transmitted to others, so
that the transition is smooth.

`useHistory` is a hook that allows us to pause and resume history states as we
please.

```tsx highlight="4,8,9"
import { useHistory } from "@liveblocks/react/suspense";

function App() {
  const { resume, pause } = useHistory();

  return <Rectangle onDragStart={() => pause()} onDragEnd={() => resume()} />;
}
```

### Presence history

By default, undo/redo only impacts the room storageâ€”thereâ€™s generally no need to
use it with presence, for example thereâ€™s no reason to undo the position of a
userâ€™s cursor. However, occasionally it can be useful.

If we explore the design tool scenario, the currently selected rectangle may be
stored in a userâ€™s presence. If `undo` is pressed, and the rectangle is moved
back, it would make sense to remove the userâ€™s selection on that rectangle.

To enable this, we can use the `addToHistory` option when updating the userâ€™s
presence.

```tsx highlight="4,9"
import { useUpdateMyPresence } from "@liveblocks/react/suspense";

function App() {
  const updateMyPresence = useUpdateMyPresence();

  return (
    <Rectangle
      onClick={(rectangleId) =>
        updateMyPresence({ selected: rectangleId }, { addToHistory: true })
      }
    />
  );
}
```

This also works in mutations with `setMyPresence`.

```tsx highlight="4"
import { useMutation } from "@liveblocks/react/suspense";

const updateSelected = useMutation(({ setMyPresence }, rectangleId) => {
  setMyPresence({ selected: rectangleId }, { addToHistory: true });
});
```

[`@liveblocks/client`]: /docs/api-reference/liveblocks-client
[`@liveblocks/react`]: /docs/api-reference/liveblocks-react
[`createroomcontext`]: /docs/api-reference/liveblocks-react#createRoomContext
[`livelist`]: /docs/api-reference/liveblocks-client#LiveList
[`livelist.push`]: /docs/api-reference/liveblocks-client#LiveList.push
[`livemap`]: /docs/api-reference/liveblocks-client#LiveMap
[`liveobject`]: /docs/api-reference/liveblocks-client#LiveObject
[`liveobject.get`]: /docs/api-reference/liveblocks-client#LiveObject.get
[`liveobject.set`]: /docs/api-reference/liveblocks-client#LiveObject.set
[`room.history.pause`]: /docs/api-reference/liveblocks-client#Room.history.pause
[`room.history.resume`]:
  /docs/api-reference/liveblocks-client#Room.history.resume
[`room.subscribe`]:
  /docs/api-reference/liveblocks-client#Room.subscribe(storageItem)
[`roomprovider`]: /docs/api-reference/liveblocks-react#RoomProvider
[`usehistory`]: /docs/api-reference/liveblocks-react#useHistory
[`useothers`]: /docs/api-reference/liveblocks-react#useOthers
[`useredo`]: /docs/api-reference/liveblocks-react#useRedo
[`useundo`]: /docs/api-reference/liveblocks-react#useUndo
[`useupdatemypresence`]:
  /docs/api-reference/liveblocks-react#useUpdateMyPresence
[`useconnectionids`]: /docs/api-reference/liveblocks-react#useConnectionIds
[`usestorage`]: /docs/api-reference/liveblocks-react#useStorage
[`usemutation`]: /docs/api-reference/liveblocks-react#useMutation

---
meta:
  title: "How to use Liveblocks multiplayer undo/redo with Redux"
  description: "Learn how to use Liveblocks multiplayer undo/redo with Redux"
---

In this guide, weâ€™ll be learning how to use Liveblocks multiplayer undo/redo
with Redux using the APIs from the [`@liveblocks/redux`][] package.

<Banner title="Install Liveblocks">

This guide assumes you already have Liveblocks set up into your Redux store. If
you donâ€™t make sure to follow
[these quick steps to get started](/docs/get-started/redux) first.

</Banner>

## Multiplayer undo/redo [#undo-redo]

Implementing undo/redo when multiple users can edit the app state simultaneously
is quite complex!

**When only one user can edit the app state, undo/redo acts like a "time
machine"**; undo/redo replaces the current app state with an app state that was
already be seen by the user.

When multiple users are involved, undo or redo can lead to an app state that no
one has seen before. For example, let's imagine a design tool with two users
editing the same circle.

- Initial state => `{ radius: "10px", color: "yellow" }`
- User A sets the `color` to `blue` => `{ radius: "10px", color: "blue" }`
- User B sets the `radius` to `20px` => `{ radius: "20px", color: "blue" }`
- User A realizes that it preferred the circle in yellow and undoes **its last
  modification** => `{ radius: "20px", color: "yellow" }`

A yellow circle with a radius of 20px in a completely new state. **Undo/redo in
a multiplayer app does not act like a "time machine"; it only undoes local
operation**.

The good news is that [`room.history.undo`][] and [`room.history.redo`][] takes
that complexity out of your hands so you can focus on the core features of your
app.

Access these two functions from the client like below so you can easily bind
them to keyboard events (âŒ˜+Z/âŒ˜+â‡§+Z on Mac and Ctrl+Z/Ctrl+Y on Windows) or undo
and redo buttons in your application..

```js
const { undo, redo } = client.getRoom("room-id").history;
```

### Pause and resume history [#pause-resume]

Some applications require skipping intermediate states from the undo/redo
history. Let's consider a design tool; when a user drags a rectangle, the
intermediate rectangle positions should not be part of the undo/redo history.
But they should be shared with the rest of the room to create a great
experience.

[`room.history.pause`][] and [`room.history.resume`][] lets you skip these
intermediate states. To go back to our design tool example, the sequence of
calls would look like that:

- User presses the rectangle
- Call `room.history.pause` to skip future operations from the history
- User drags the rectangle
- User release the rectangle
- Call `room.history.resume`

At this point, if the user calls `room.history.undo`, the rectangle will go back
to its initial position.

```js
const { pause, resume } = client.getRoom("room-id").history;
```

[`room.history.undo`]: /docs/api-reference/liveblocks-client#Room.history.undo
[`room.history.redo`]: /docs/api-reference/liveblocks-client#Room.history.redo
[`room.history.pause`]: /docs/api-reference/liveblocks-client#Room.history.pause
[`room.history.resume`]:
  /docs/api-reference/liveblocks-client#Room.history.resume
[`liveobject`]: /docs/api-reference/liveblocks-client#LiveObject
[`livemap`]: /docs/api-reference/liveblocks-client#LiveMap
[`livelist`]: /docs/api-reference/liveblocks-client#LiveList
[`createclient`]: /docs/api-reference/liveblocks-client#createClient
[api reference]: /docs/api-reference/liveblocks-redux
[authentication]: /docs/authentication

---
meta:
  title: "How to use Liveblocks multiplayer undo/redo with Zustand"
  description: "Learn how to use Liveblocks multiplayer undo/redo with Zustand"
---

In this guide, weâ€™ll be learning how to use Liveblocks multiplayer undo/redo
with Zustand using the APIs from the [`@liveblocks/zustand`][] package.

<Banner title="Install Liveblocks">

This guide assumes you already have Liveblocks set up into your Zustand store.
If you donâ€™t make sure to follow
[these quick steps to get started](/docs/get-started/zustand) first.

</Banner>

## Multiplayer undo/redo [#undo-redo]

Implementing undo/redo when multiple users can edit the app state simultaneously
is quite complex!

**When only one user can edit the app state, undo/redo acts like a "time
machine"**; undo/redo replaces the current app state with an app state that was
already be seen by the user.

When multiple users are involved, undo or redo can lead to an app state that no
one has seen before. For example, let's imagine a design tool with two users
editing the same circle.

- Initial state => `{ radius: "10px", color: "yellow" }`
- User A sets the `color` to `blue` => `{ radius: "10px", color: "blue" }`
- User B sets the `radius` to `20px` => `{ radius: "20px", color: "blue" }`
- User A realizes that it preferred the circle in yellow and undoes **its last
  modification** => `{ radius: "20px", color: "yellow" }`

A yellow circle with a radius of 20px in a completely new state. **Undo/redo in
a multiplayer app does not act like a "time machine"; it only undoes local
operation**.

The good news is that [`room.history.undo`][] and [`room.history.redo`][] takes
that complexity out of your hands so you can focus on the core features of your
app.

Access these two functions from your store like below so you can easily bind
them to keyboard events (âŒ˜+Z/âŒ˜+â‡§+Z on Mac and Ctrl+Z/Ctrl+Y on Windows) or undo
and redo buttons in your application..

```tsx
import useStore from "../store";

function YourComponent() {
  const undo = useStore((state) => state.liveblocks.room?.history.undo);
  const redo = useStore((state) => state.liveblocks.room?.history.redo);

  return (
    <>
      <button onClick={undo}>Undo</button>
      <button onClick={redo}>Redo</button>
    </>
  );
}
```

### Pause and resume history [#pause-resume]

Some applications require skipping intermediate states from the undo/redo
history. Let's consider a design tool; when a user drags a rectangle, the
intermediate rectangle positions should not be part of the undo/redo history.
But they should be shared with the rest of the room to create a great
experience.

[`room.history.pause`][] and [`room.history.resume`][] lets you skip these
intermediate states. To go back to our design tool example, the sequence of
calls would look like that:

- User presses the rectangle
- Call `room.history.pause` to skip future operations from the history
- User drags the rectangle
- User release the rectangle
- Call `room.history.resume`

At this point, if the user calls `room.history.undo`, the rectangle will go back
to its initial position.

```tsx
import useStore from "../store";

const pause = useStore((state) => state.liveblocks.room?.history.pause);
const resume = useStore((state) => state.liveblocks.room?.history.resume);
```

[`room.history.undo`]: /docs/api-reference/liveblocks-client#Room.history.undo
[`room.history.redo`]: /docs/api-reference/liveblocks-client#Room.history.redo
[`room.history.pause`]: /docs/api-reference/liveblocks-client#Room.history.pause
[`room.history.resume`]:
  /docs/api-reference/liveblocks-client#Room.history.resume
[`liveobject`]: /docs/api-reference/liveblocks-client#LiveObject
[`livemap`]: /docs/api-reference/liveblocks-client#LiveMap
[`livelist`]: /docs/api-reference/liveblocks-client#LiveList
[`createclient`]: /docs/api-reference/liveblocks-client#createClient
[api reference]: /docs/api-reference/liveblocks-zustand
[authentication]: /docs/authentication

---
meta:
  title: "How to use Liveblocks Presence with React"
  description: "Learn how to use Liveblocks Presence with React"
---

In this guide, weâ€™ll be learning how to use Liveblocks Presence with React using
the hooks from the [`@liveblocks/react`][] package.

This guide uses [TypeScript](https://www.typescriptlang.org/). Liveblocks can
definitely be used without TypeScript. We believe typings are helpful to make
collaborative apps more robust, but if youâ€™d prefer to skip the TypeScript
syntax, feel free to write your code in JavaScript.

<Banner title="Install Liveblocks">

This guide assumes you already have Liveblocks set up into your React
application. If you donâ€™t make sure to follow
[these quick steps to get started](/docs/get-started/react) first.

</Banner>

## Get other users in the room [#get-others]

Now that the provider is set up, we can start using the Liveblocks hooks. The
first weâ€™ll add is [`useOthers`][], a hook that provides us information about
which _other_ users are connected to the room.

To show how many other users are in the room, import `useOthers` into a
component and use it as below.

```tsx highlight="1,4"
import { RoomProvider, useOthers } from "@liveblocks/react/suspense";

function App() {
  const others = useOthers();

  return <div>There are {others.length} other users with you in the room.</div>;
}

function Index() {
  return (
    <RoomProvider id="my-room-id">
      <App />
    </RoomProvider>
  );
}
```

Great! Weâ€™re connected, and we already have information about the other users
currently online.

## Define initial presence [#define-presence]

Most collaborative features rely on each user having their own temporary state,
which is then shared with others. For example, in an app using multiplayer
cursors, the location of each userâ€™s cursor will be their state. In Liveblocks,
we call this _presence_.

We can use _presence_ to hold any object that we wish to share with others. An
example would be the pixel coordinates of a userâ€™s cursor:

```js
cursor: { x: 256, y: 367 }
```

To start using presence, letâ€™s define a type named `Presence` in
`liveblocks.config.ts`.

```tsx file="liveblocks.config.ts" highlight="8-10,12"
declare global {
  interface Liveblocks {
    Presence: {
      cursor: { x: number; y: number } | null;
    };
  }
}
```

Then, define an `initialPresence` value on our `RoomProvider`. Weâ€™ll set the
initial cursor to `null` to represent a user whose cursor is currently
off-screen.

```tsx file="index.ts" highlight="7"
import { RoomProvider, useOthers } from "@liveblocks/react/suspense";

// App

function Index() {
  return (
    <RoomProvider id="my-room-id" initialPresence={{ cursor: null }}>
      <App />
    </RoomProvider>
  );
}
```

## Update user presence [#update-presence]

We can add the [`useUpdateMyPresence`][] hook to share this information in
realtime, and in this case, update the current user cursor position when
`onPointerMove` is called. Next, import `updateMyPresence` and call it with the
updated cursor coordinates whenever a pointer move event is detected.

```tsx
import { useUpdateMyPresence } from "@liveblocks/react/suspense";

function App() {
  const updateMyPresence = useUpdateMyPresence();

  return (
    <div
      style={{ width: "100vw", height: "100vh" }}
      onPointerMove={(e) =>
        updateMyPresence({ cursor: { x: e.clientX, y: e.clientY } })
      }
      onPointerLeave={() => updateMyPresence({ cursor: null })}
    />
  );
}
```

Weâ€™re setting `cursor` to `null` when the userâ€™s pointer leaves the element.

## Get other usersâ€™ presence [#get-others-presence]

To retrieve each userâ€™s presence, and cursor locations, we can once again add
[`useOthers`][]. This time weâ€™ll use a selector function to map through each
userâ€™s presence, and grab their cursor property. If a cursor is set to `null`, a
user is off-screen, so weâ€™ll skip rendering it.

```tsx highlight="20-26"
import {
  useOthers,
  useUpdateMyPresence,
  RoomProvider,
} from "@liveblocks/react/suspense";

function App() {
  const others = useOthers();
  const updateMyPresence = useUpdateMyPresence();

  return (
    <div
      style={{ width: "100vw", height: "100vh" }}
      onPointerMove={(e) =>
        updateMyPresence({ cursor: { x: e.clientX, y: e.clientY } })
      }
      onPointerLeave={() => updateMyPresence({ cursor: null })}
    >
      {others.map(({ connectionId, presence }) =>
        presence.cursor ? (
          <Cursor
            key={connectionId}
            x={presence.cursor.x}
            y={presence.cursor.y}
          />
        ) : null
      )}
    </div>
  );
}

// Basic cursor component
function Cursor({ x, y }) {
  return (
    <img
      style={{
        position: "absolute",
        transform: `translate(${x}px, ${y}px)`,
      }}
      src="/assets/cursor.svg"
    />
  );
}
```

Presence isnâ€™t only for [multiplayer cursors](/examples/browse/cursors), and can
be helpful for a number of other use cases such as
[live avatar stacks](/examples/browse/avatar-stack) and
[realtime form presence](/examples/browse/forms).

[`@liveblocks/client`]: /docs/api-reference/liveblocks-client
[`@liveblocks/react`]: /docs/api-reference/liveblocks-react
[`createroomcontext`]: /docs/api-reference/liveblocks-react#createRoomContext
[`livelist`]: /docs/api-reference/liveblocks-client#LiveList
[`livelist.push`]: /docs/api-reference/liveblocks-client#LiveList.push
[`livemap`]: /docs/api-reference/liveblocks-client#LiveMap
[`liveobject`]: /docs/api-reference/liveblocks-client#LiveObject
[`liveobject.get`]: /docs/api-reference/liveblocks-client#LiveObject.get
[`liveobject.set`]: /docs/api-reference/liveblocks-client#LiveObject.set
[`room.history.pause`]: /docs/api-reference/liveblocks-client#Room.history.pause
[`room.history.resume`]:
  /docs/api-reference/liveblocks-client#Room.history.resume
[`room.subscribe`]:
  /docs/api-reference/liveblocks-client#Room.subscribe(storageItem)
[`roomprovider`]: /docs/api-reference/liveblocks-react#RoomProvider
[`usehistory`]: /docs/api-reference/liveblocks-react#useHistory
[`useothers`]: /docs/api-reference/liveblocks-react#useOthers
[`useredo`]: /docs/api-reference/liveblocks-react#useRedo
[`useundo`]: /docs/api-reference/liveblocks-react#useUndo
[`useupdatemypresence`]:
  /docs/api-reference/liveblocks-react#useUpdateMyPresence
[`useconnectionids`]: /docs/api-reference/liveblocks-react#useConnectionIds
[`usestorage`]: /docs/api-reference/liveblocks-react#useStorage
[`usemutation`]: /docs/api-reference/liveblocks-react#useMutation

---
meta:
  title: "How to use Liveblocks Presence with Redux"
  description: "Learn how to use Liveblocks Presence with Redux"
---

In this guide, weâ€™ll be learning how to use Liveblocks Presence with Redux using
the APIs from the [`@liveblocks/redux`][] package.

<Banner title="Install Liveblocks">

This guide assumes you already have Liveblocks set up into your Redux store. If
you donâ€™t make sure to follow
[these quick steps to get started](/docs/get-started/redux) first.

</Banner>

## Get other users in the room [#get-others]

<Banner title="Need help troubleshooting presence?">

Try the [Liveblocks DevTools extension](/devtools) to inspect and debug your
collaborative experiences as you build them, in realtime.

</Banner>

If you want to list all the people connected to the room, you can use
`state.liveblocks.others` to get an array of the other users in the room.

```jsx
import { useSelector } from "react-redux";

function App() {
  const others = useSelector((state) => state.liveblocks.others);
}
```

## Update user presence [#update-presence]

To create immersive multiplayer experiences, itâ€™s helpful for each person in the
room to share their realâ€‘time state with other connected users. That realâ€‘time
state often corresponds to a cursor position or even the item a user has
currently selected. We call this concept "Presence".

For instance, to share the cursorâ€™s position in realâ€‘time with others, weâ€™re
going to add a new `presenceMapping` option to our `enhancer` to specify which
part of the state maps to the current userâ€™s `presence`.

```jsx file="src/store.js"
/* ... imports and client setup ... */

const initialState = {
  cursor: { x: 0, y: 0 },
};

const slice = createSlice({
  name: "state",
  initialState,
  reducers: {
    setCursor: (state, action) => {
      state.cursor = action.payload;
    },
  },
});

export const { setCursor } = slice.actions;

function makeStore() {
  return configureStore({
    reducer: slice.reducer,
    enhancers: (getDefaultEnhancers) =>
      getDefaultEnhancers().concat(
        enhancer({
          client,
          presenceMapping: { cursor: true },
        })
      ),
  });
}

const store = makeStore();

export default store;
```

Then you can dispatch an action like in any redux app and we will broadcast this
cursor to everyone in the room.

```jsx
import { useDispatch } from "react-redux";
import { setCursor } from "./store.js";

function YourComponent() {
  const dispatch = useDispatch();

  return (
    <div
      style={{ width: "100vw", height: "100vh" }}
      onPointerMove={(e) => dispatch(setCursor({ x: e.clientX, y: e.clientY }))}
    />
  );
}
```

## Get other usersâ€™ presence [#get-others-presence]

Get peopleâ€™s cursor positions with
`liveblocks.others.map(user => user.presence?.cursor)`. Itâ€™s worth noting that a
user presence can be `undefined`.

```jsx
import { useSelector } from "react-redux";

function OthersCursors() {
  const others = useSelector((state) => state.liveblocks.others);

  const othersCursors = others.map((user) => user.presence?.cursor);

  // Render cursors with custom SVGs based on x and y
}
```

[`room.history.undo`]: /docs/api-reference/liveblocks-client#Room.history.undo
[`room.history.redo`]: /docs/api-reference/liveblocks-client#Room.history.redo
[`room.history.pause`]: /docs/api-reference/liveblocks-client#Room.history.pause
[`room.history.resume`]:
  /docs/api-reference/liveblocks-client#Room.history.resume
[`liveobject`]: /docs/api-reference/liveblocks-client#LiveObject
[`livemap`]: /docs/api-reference/liveblocks-client#LiveMap
[`livelist`]: /docs/api-reference/liveblocks-client#LiveList
[`createclient`]: /docs/api-reference/liveblocks-client#createClient
[api reference]: /docs/api-reference/liveblocks-redux
[authentication]: /docs/authentication

---
meta:
  title: "How to use Liveblocks Presence with Zustand"
  description: "Learn how to use Liveblocks Presence with Zustand"
---

In this guide, weâ€™ll be learning how to use Liveblocks Presence with Zustand
using the APIs from the [`@liveblocks/zustand`][] package.

<Banner title="Install Liveblocks">

This guide assumes you already have Liveblocks set up into your Zustand store.
If you donâ€™t make sure to follow
[these quick steps to get started](/docs/get-started/zustand) first.

</Banner>

## Get other users in the room [#get-others]

<Banner title="Need help troubleshooting presence?">

Try the [Liveblocks DevTools extension](/devtools) to inspect and debug your
collaborative experiences as you build them, in realtime.

</Banner>

If you want to list all the people connected to the room, you can use
`liveblocks.others` to get an array of the other users in the room.

```tsx
import useStore from "./store";

function YourComponent() {
  useStore((state) => state.liveblocks.others);
}
```

## Update user presence [#update-presence]

To create immersive multiplayer experiences, itâ€™s helpful for each person in the
room to share their realâ€‘time state with other connected users. That realâ€‘time
state often corresponds to a cursor position or even the item a user has
currently selected. We call this concept â€œPresenceâ€.

For instance, to share the cursorâ€™s position in realâ€‘time with others, weâ€™re
going to add a new `presenceMapping` option to our `liveblocks` middleware
configuration to specify which part of the state maps to the current userâ€™s
presence. In this case, weâ€™re updating the `cursor` position in our store in the
`onPointerMove` event listener in our React component.

```ts file="src/store.ts" highlight="6,9-10,20-21,25-27"
import create from "zustand";
import { createClient } from "@liveblocks/client";
import { liveblocks } from "@liveblocks/zustand";
import type { WithLiveblocks } from "@liveblocks/zustand";

type Cursor = { x: number; y: number };

type State = {
  cursor: Cursor;
  setCursor: (cursor: Cursor) => void;
};

const client = createClient({
  publicApiKey: "{{PUBLIC_KEY}}",
});

const useStore = create<WithLiveblocks<State>>()(
  liveblocks(
    (set) => ({
      cursor: { x: 0, y: 0 },
      setCursor: (cursor) => set({ cursor }),
    }),
    {
      client,
      presenceMapping: {
        cursor: true,
      },
    }
  )
);

export default useStore;
```

```tsx file="src/App.tsx" highlight="18-24"
import React, { useEffect } from "react";
import useStore from "./store";

import "./App.css";

const App = () => {
  const {
    liveblocks: { enterRoom, leaveRoom },
  } = useStore();

  useEffect(() => {
    enterRoom("room-id");
    return () => {
      leaveRoom("room-id");
    };
  }, [enterRoom, leaveRoom]);

  const setCursor = useStore((state) => state.setCursor);
  return (
    <div
      style={{ width: "100vw", height: "100vh" }}
      onPointerMove={(e) => setCursor({ x: e.clientX, y: e.clientY })}
    />
  );
};

export default App;
```

## Get other usersâ€™ presence [#get-others-presence]

Get peopleâ€™s cursor positions with
`liveblocks.others.map(user => user.presence.cursor)`.

```tsx file="src/App.tsx"
function App() {
  /* ... */

  const others = useStore((state) => state.liveblocks.others);
  const othersCursors = others.map((user) => user.presence.cursor);

  // Render cursors with custom SVGs based on x and y
}
```

[`@liveblocks/zustand`]: /docs/api-reference/liveblocks-zustand
[`room.history.undo`]: /docs/api-reference/liveblocks-client#Room.history.undo
[`room.history.redo`]: /docs/api-reference/liveblocks-client#Room.history.redo
[`room.history.pause`]: /docs/api-reference/liveblocks-client#Room.history.pause
[`room.history.resume`]:
  /docs/api-reference/liveblocks-client#Room.history.resume
[`liveobject`]: /docs/api-reference/liveblocks-client#LiveObject
[`livemap`]: /docs/api-reference/liveblocks-client#LiveMap
[`livelist`]: /docs/api-reference/liveblocks-client#LiveList
[`createclient`]: /docs/api-reference/liveblocks-client#createClient
[api reference]: /docs/api-reference/liveblocks-zustand
[authentication]: /docs/authentication

---
meta:
  title: "How to use Liveblocks Storage with React"
  description: "Learn how to use Liveblocks Storage with React"
---

In this guide, weâ€™ll be learning how to use Liveblocks Storage with React using
the hooks from the [`@liveblocks/react`][] package.

This guide uses [TypeScript](https://www.typescriptlang.org/). Liveblocks can
definitely be used without TypeScript. We believe typings are helpful to make
collaborative apps more robust, but if youâ€™d prefer to skip the TypeScript
syntax, feel free to write your code in JavaScript.

<Banner title="Install Liveblocks">

This guide assumes you already have Liveblocks set up into your React
application. If you donâ€™t make sure to follow
[these quick steps to get started](/docs/get-started/react) first.

</Banner>

## Sync and persist the state across client [#storage-intro]

<Banner title="Need help troubleshooting storage?">

Try the [Liveblocks DevTools extension](/devtools) to inspect and debug your
collaborative experiences as you build them, in realtime.

</Banner>

Some collaborative features require a single shared state between all usersâ€”an
example of this would be a
[collaborative design tool](/examples/browse/whiteboard), with each shape having
its own state, or a form with shared inputs. In Liveblocks, this is where
`storage` comes in. Room storage automatically updates for every user on
changes, and unlike presence, persists after users disconnect.

### Storage types

Our storage uses special data structures (inspired by
[CRDTs](https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type)) to
resolve all conflicts, meaning that state is always accurate. There are
[multiple storage types](https://liveblocks.io/docs/api-reference/liveblocks-client#Storage)
available:

- [`LiveObject`][] - Similar to a JavaScript object.
- [`LiveList`][] - An array-like ordered collection of items.
- [`LiveMap`][] - Similar to a JavaScript Map.

### Defining initial storage [#initial-storage]

To use storage, first define a type named `Storage` in `liveblocks.config.ts`.
In this example weâ€™ll define a [`LiveObject`][] called `scientist`, containing
first and last name properties.

```tsx file="liveblocks.config.ts" highlight="1,4-6,11"
import { LiveObject } from "@liveblocks/client";

declare global {
  interface Liveblocks {
    Storage: { scientist: LiveObject<{ firstName: string; lastName: string }> };
  }
}
```

Then, define the initial structure within [`RoomProvider`][].

```tsx file="index.ts"
import { LiveObject } from "@liveblocks/client";
import { RoomProvider } from "@liveblocks/react/suspense";

/* App */

function Index() {
  return (
    <RoomProvider
      id="my-room-id"
      initialPresence={/* ... */}
      // +++
      initialStorage={{
        scientist: new LiveObject({
          firstName: "Marie",
          lastName: "Curie",
        }),
        // +++
      }}
    >
      <App />
    </RoomProvider>
  );
}
```

### Using storage

Once the default structure is defined, we can then make use of our storage. The
[`useStorage`][] hook allows us to access an immutable version of our storage
using a selector function.

```tsx highlight="4,12,13"
import { useStorage } from "@liveblocks/react";

function App() {
  const scientist = useStorage((root) => root.scientist);

  if (scientist == null) {
    return <div>Loading...</div>;
  }

  return (
    <>
      <input value={scientist.firstName} />
      <input value={scientist.lastName} />
    </>
  );
}
```

The two input values will now automatically update in a realtime as `firstName`
and `lastName` are modified by other users.

`useStorage` returns `null` during the initial loading because the storage is
loaded from the server. It can quickly become cumbersome to handle `null`
whenever we use `useStorage`, but we have some good new for you;
`@liveblocks/react` contains a
[`Suspense`](https://beta.reactjs.org/reference/react/Suspense) version of all
of our hooks.

### Updating storage

The best way to update storage is through mutations. The [`useMutation`][] hook
allows you to create reusable callback functions that modify Liveblocks state.
For example, letâ€™s create a mutation that can modify the scientistâ€™s name.

Inside this mutation weâ€™re accessing the storage root, a [`LiveObject`][] like
`scientist`, and retrieving a mutable copy of `scientist` with
[`LiveObject.get`]. From there, we can set the updated name using
[`LiveObject.set`].

```tsx
// Define mutation
const updateName = useMutation(({ storage }, nameType, newName) => {
  const mutableScientist = storage.get("scientist");
  mutableScientist.set(nameType, newName);
}, []);
```

We can then call this mutation, and pass `nameType` and `newName` arguments.

```tsx
updateName("firstName", "Albert");
```

If we take a look at this in the context of a component, we can see how to
combine [`useStorage`][] to display the names, and [`useMutation`][] to modify
them. Note that `useMutation` takes a dependency array, and works similarly to
`useCallback`.

```tsx file="index.ts"
import { useStorage, useMutation } from "@liveblocks/react";

function YourComponent() {
  const scientist = useStorage((root) => root.scientist);

  if (scientist == null) {
    return <div>Loading...</div>;
  }

  const updateName = useMutation(({ storage }, nameType, newName) => {
    const mutableScientist = storage.get("scientist");
    mutableScientist.set(nameType, newName);
  }, []);

  return (
    <>
      <input
        value={scientist.firstName}
        onChange={(e) => updateName("firstName", e.target.value)}
      />
      <input
        value={scientist.lastName}
        onChange={(e) => updateName("lastName", e.target.value)}
      />
    </>
  );
}
```

All changes made within `useMutation` are automatically batched and sent to the
Liveblocks together. `useMutation` can also be used to retrieve and modify
presence too, giving you access to multiple parameters, not just `storage`.

```tsx
useMutation({ storage, self, others, setMyPresence });
```

Find more information in the
[Mutations](/docs/api-reference/liveblocks-react#useMutation) section of our
documentation.

### Nested data structures

With Liveblocks storage, itâ€™s possible to nest data structures inside each
other, for example `scientist` could hold a [`LiveList`][] containing a list of
pets.

```tsx highlight="3"
initialStorage={{
  scientist: new LiveObject({
    pets: new LiveList(["ðŸ¶", "ðŸ±", "ðŸ·"]),
    firstName: "Marie",
    lastName: "Curie",
  })
}}
```

Because the `useStorage` selector converts your data structure into a normal
immutable JavaScript structure (made from objects, arrays, maps), `pets` can be
accessed directly with `useStorage`.

```tsx
// ["ðŸ¶", "ðŸ±", "ðŸ·"]
const pets = useStorage((root) => root.scientist.pets);
```

You can even reach into a `LiveObject` or `LiveList` and extract a property.

```tsx
// "Marie"
const firstName = useStorage((root) => root.scientist.firstName);

// "ðŸ¶"
const firstPet = useStorage((root) => root.scientist.pets[0]);
```

### Improving storage performance

`useStorage` is highly efficient and only triggers a rerender when the value
returned from the selector changes. For example, the following selectors will
only trigger rerenders when their respective values change, and are unaffected
by any other storage updates.

```tsx
// âœ… Rerenders only when root.scientist.firstName changes
const firstName = useStorage((root) => root.scientist.firstName);

// âœ… Rerenders only when root.scientist changes
const scientist = useStorage((root) => root.scientist);
```

However, selector functions must return a stable result to be efficientâ€”if a new
object is created within the selector function, it will rerender on every
storage change.

```tsx
// âŒ Rerenders on every change because `map` returns a new array every time
const pets = useStorage((root) => root.scientist.pets.map((pet) => pet + pet));
```

To account for this, we can pass a `shallow` equality check function, provided
by `@liveblocks/react`:

```tsx highlight="1,6"
import { shallow } from "@liveblocks/react";

// âœ… Rerenders only when root.scientist.pets shallowly changes
const pets = useStorage(
  (root) => root.scientist.pets.map((pet) => pet + pet),
  shallow
);
```

Find more information in the
[How selectors work](/docs/api-reference/liveblocks-react#selectors) section of
our documentation.

### Using Suspense

If youâ€™d like to use `Suspense` in your application, make sure to re-export our
hooks from `"@liveblocks/react/suspense"`.

And then put a `Suspense` component right below the `RoomProvider`. This version
of `useStorage` never returns `null`, the loading fallback will be handled by
`Suspense` `fallback`.

```tsx file="index.ts" highlight="2,28-30"
import { LiveObject } from "@liveblocks/client";
import { Suspense } from "react";
import { RoomProvider, useStorage } from "@liveblocks/react/suspense";

function App() {
  const scientist = useStorage((root) => root.scientist);

  return (
    <>
      <input value={scientist.firstName} />
      <input value={scientist.lastName} />
    </>
  );
}

function Index() {
  return (
    <RoomProvider
      id="my-room-id"
      initialPresence={/* ... */}
      initialStorage={{
        scientist: new LiveObject({
          firstName: "Marie",
          lastName: "Curie",
        }),
      }}
    >
      <Suspense fallback={<div>Loading</div>}>
        <App />
      </Suspense>
    </RoomProvider>
  );
}
```

If youâ€™re using a framework that supports Server Side Rendering like
[Next.js](https://nextjs.org/), you cannot use `Suspense` directly like this.
Liveblocks does not load the storage on the server by default, so the components
using `useStorage` will never be able to render. To keep the benefits from
`Suspense`, you should use `ClientSideSuspense` from ` @liveblocks/react`
instead of the normal `Suspense` from React like this:

```tsx file="index.ts" highlight="1,12-14"
import { ClientSideSuspense } from "@liveblocks/react/suspense";

// ...

function Index() {
  return (
    <RoomProvider
      id="my-room-id"
      initialPresence={/* ... */}
      initialStorage={/* ... */}
    >
      <ClientSideSuspense fallback={<div>Loading...</div>}>
        {() => <App />}
      </ClientSideSuspense>
    </RoomProvider>
  );
}
```

[`@liveblocks/client`]: /docs/api-reference/liveblocks-client
[`@liveblocks/react`]: /docs/api-reference/liveblocks-react
[`createroomcontext`]: /docs/api-reference/liveblocks-react#createRoomContext
[`livelist`]: /docs/api-reference/liveblocks-client#LiveList
[`livelist.push`]: /docs/api-reference/liveblocks-client#LiveList.push
[`livemap`]: /docs/api-reference/liveblocks-client#LiveMap
[`liveobject`]: /docs/api-reference/liveblocks-client#LiveObject
[`liveobject.get`]: /docs/api-reference/liveblocks-client#LiveObject.get
[`liveobject.set`]: /docs/api-reference/liveblocks-client#LiveObject.set
[`room.history.pause`]: /docs/api-reference/liveblocks-client#Room.history.pause
[`room.history.resume`]:
  /docs/api-reference/liveblocks-client#Room.history.resume
[`room.subscribe`]:
  /docs/api-reference/liveblocks-client#Room.subscribe(storageItem)
[`roomprovider`]: /docs/api-reference/liveblocks-react#RoomProvider
[`usehistory`]: /docs/api-reference/liveblocks-react#useHistory
[`useothers`]: /docs/api-reference/liveblocks-react#useOthers
[`useredo`]: /docs/api-reference/liveblocks-react#useRedo
[`useundo`]: /docs/api-reference/liveblocks-react#useUndo
[`useupdatemypresence`]:
  /docs/api-reference/liveblocks-react#useUpdateMyPresence
[`useconnectionids`]: /docs/api-reference/liveblocks-react#useConnectionIds
[`usestorage`]: /docs/api-reference/liveblocks-react#useStorage
[`usemutation`]: /docs/api-reference/liveblocks-react#useMutation

---
meta:
  title: "How to use Liveblocks Storage with Redux"
  description: "Learn how to use Liveblocks Storage with Redux"
---

In this guide, weâ€™ll be learning how to use Liveblocks Storage with Redux using
the APIs from the [`@liveblocks/redux`][] package.

<Banner title="Install Liveblocks">

This guide assumes you already have Liveblocks set up into your Redux store. If
you donâ€™t make sure to follow
[these quick steps to get started](/docs/get-started/redux) first.

</Banner>

## Sync and persist the state across client [#storage-intro]

As opposed to `presence`, some collaborative features require that every user
interacts with the same piece of state. For example, in Google Docs, it is the
paragraphs, headings, images in the document. In Figma, itâ€™s all the shapes that
make your design. Thatâ€™s what we call the roomâ€™s `storage`.

<Banner title="Need help troubleshooting storage?">

Try the [Liveblocks DevTools extension](/devtools) to inspect and debug your
collaborative experiences as you build them, in realtime.

</Banner>

The roomâ€™s storage is a conflicts-free state that multiple users can edit at the
same time. It is persisted to our backend even after everyone leaves the room.
Liveblocks provides custom data structures inspired by
[CRDTs](https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type) that
can be nested to create the state that you want.

- [`LiveObject`][] - Similar to JavaScript object. If multiple users update the
  same property simultaneously, the last modification received by the Liveblocks
  servers is the winner.
- [`LiveList`][] - An ordered collection of items synchronized across clients.
  Even if multiple users add/remove/move elements simultaneously, LiveList will
  solve the conflicts to ensure everyone sees the same collection of items.
- [`LiveMap`][] - Similar to a JavaScript Map. If multiple users update the same
  property simultaneously, the last modification received by the Liveblocks
  servers is the winner.

When using our Redux integration you cannot interact directly with these data
structures. Our enhancer synchronizes your store with our data structures based
on the `storageMapping` configuration.

Here is an example to explain how it works under the hood. Imagine you have the
following store:

```js
/* ...client setup... */

const initialState = {
  firstName: "Marie",
  lastName: "Curie",
  discoveries: ["Polonium", "Radium"],
};

const slice = createSlice({
  name: "state",
  initialState,
  reducers: {
    setFirstName: (state, action) => {
      state.firstName = action.payload;
    },
    setLastName: (state, action) => {
      state.lastName = action.payload;
    },
    addDiscovery: (state, action) => {
      state.discoveries.push(action.payload);
    },
  },
});

export const { setScientist } = slice.actions;

function makeStore() {
  return configureStore({
    reducer: slice.reducer,
    enhancers: (getDefaultEnhancers) =>
      getDefaultEnhancers().concat(
        enhancer({
          client,
          storageMapping: {
            firstName: true,
            lastName: true,
            discoveries: true,
          },
        })
      ),
  });
}

const store = makeStore();
```

With this setup, the room's `storage` root is :

```js
const root = new LiveObject({
  firstName: "Marie",
  lastName: "Curie",
  discoveries: new LiveList(["Polonium", "Radium"]),
});
```

If you update your store by dispatching `setFirstName("Pierre")`, the enhancer
will do `root.set("firstName", "Pierre")` for you and update the store of all
the users currently connected to the room. The enhancer compares the previous
state and the new state to detect changes and patch our data structures
accordingly.

The reverse process happens when receiving updates from other clients; the
enhancer patches your immutable state.

When entering a room with `enterRoom`, the enhancer fetches the room's storage
from our server and patches your store. If this is the first time you're
entering a room, the storage will be empty. `enterRoom` takes an additional
argument to initialize the room's storage.

```js
enterRoom("room-id", {
  firstName: "Lise",
  lastName: "Meitner",
  discoveries: ["Nuclear fission", "Protactinium"],
});
```

[`room.history.undo`]: /docs/api-reference/liveblocks-client#Room.history.undo
[`room.history.redo`]: /docs/api-reference/liveblocks-client#Room.history.redo
[`room.history.pause`]: /docs/api-reference/liveblocks-client#Room.history.pause
[`room.history.resume`]:
  /docs/api-reference/liveblocks-client#Room.history.resume
[`liveobject`]: /docs/api-reference/liveblocks-client#LiveObject
[`livemap`]: /docs/api-reference/liveblocks-client#LiveMap
[`livelist`]: /docs/api-reference/liveblocks-client#LiveList
[`createclient`]: /docs/api-reference/liveblocks-client#createClient
[api reference]: /docs/api-reference/liveblocks-redux
[authentication]: /docs/authentication

---
meta:
  title: "How to use Liveblocks Storage with Zustand"
  description: "Learn how to use Liveblocks Storage with Zustand"
---

In this guide, weâ€™ll be learning how to use Liveblocks Storage with Zustand
using the APIs from the [`@liveblocks/zustand`][] package.

<Banner title="Install Liveblocks">

This guide assumes you already have Liveblocks set up into your Zustand store.
If you donâ€™t make sure to follow
[these quick steps to get started](/docs/get-started/zustand) first.

</Banner>

## Sync and persist the state across client [#storage-intro]

As opposed to `presence`, some collaborative features require that every user
interacts with the same piece of state. For example, in Google Docs, it is the
paragraphs, headings, images in the document. In Figma, itâ€™s all the shapes that
make your design. Thatâ€™s what we call the roomâ€™s â€œstorageâ€.

<Banner title="Need help troubleshooting storage?">

Try the [Liveblocks DevTools extension](/devtools) to inspect and debug your
collaborative experiences as you build them, in realtime.

</Banner>

The roomâ€™s storage is a conflicts-free state that multiple users can edit at the
same time. It is persisted to our backend even after everyone leaves the room.
Liveblocks provides custom data structures inspired by
[CRDTs](https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type) that
can be nested to create the state that you want.

- [`LiveObject`][] - Similar to JavaScript object. If multiple users update the
  same property simultaneously, the last modification received by the Liveblocks
  servers is the winner.
- [`LiveList`][] - An ordered collection of items synchronized across clients.
  Even if multiple users add/remove/move elements simultaneously, LiveList will
  solve the conflicts to ensure everyone sees the same collection of items.
- [`LiveMap`][] - Similar to a JavaScript Map. If multiple users update the same
  property simultaneously, the last modification received by the Liveblocks
  servers is the winner.

When using our Zustand integration you cannot interact directly with these data
structures. Our middleware synchronizes your store with our data structures
based on the `storageMapping` configuration.

Here is an example to explain how it works under the hood. Imagine you have the
following store:

```ts file="src/store.ts" highlight="6-8,20-22"
/* ...client setup */

const useStore = create<WithLiveblocks<State>>()(
  liveblocks(
    (set) => ({
      firstName: "Marie",
      lastName: "Curie",
      discoveries: ["Polonium", "Radium"],

      setFirstName: (firstName) => set({ firstName }),
      setLastName: (lastName) => set({ lastName }),
      addDiscovery: (discovery) =>
        set((state) => ({
          discoveries: state.discoveries.concat([discovery]),
        })),
    }),
    {
      client,
      storageMapping: {
        firstName: true,
        lastName: true,
        discoveries: true,
      },
    }
  )
);
```

With this setup, the room's `storage` root is:

```ts
const root = new LiveObject({
  firstName: "Marie",
  lastName: "Curie",
  discoveries: new LiveList(["Polonium", "Radium"]),
});
```

If you update your store by calling `setFirstName("Pierre")`, the middleware
will do `root.set("firstName", "Pierre")` for you and update the store of all
the users currently connected to the room. The middleware compares the previous
state and the new state to detect changes and patch our data structures
accordingly.

The reverse process happens when receiving updates from other clients; the
middleware patches your immutable state.

When entering a room with `liveblocks.enterRoom`, the middleware fetches the
room's storage from our server and patches your store. If this is the first time
you're entering a room, the storage will be initialized with the current value
in your Zustand state, typically your initial state.

[`@liveblocks/zustand`]: /docs/api-reference/liveblocks-zustand
[`room.history.undo`]: /docs/api-reference/liveblocks-client#Room.history.undo
[`room.history.redo`]: /docs/api-reference/liveblocks-client#Room.history.redo
[`room.history.pause`]: /docs/api-reference/liveblocks-client#Room.history.pause
[`room.history.resume`]:
  /docs/api-reference/liveblocks-client#Room.history.resume
[`liveobject`]: /docs/api-reference/liveblocks-client#LiveObject
[`livemap`]: /docs/api-reference/liveblocks-client#LiveMap
[`livelist`]: /docs/api-reference/liveblocks-client#LiveList
[`createclient`]: /docs/api-reference/liveblocks-client#createClient
[api reference]: /docs/api-reference/liveblocks-zustand
[authentication]: /docs/authentication

---
meta:
  title: "How to use Liveblocks with Astro"
  description: "Learn how to add Liveblocks to your Astro app"
---

When adding Liveblocks to [Astro](https://astro.build) apps, it's recommended to
use
[`client:only`](https://docs.astro.build/en/reference/directives-reference/#clientonly)
with your components. This is recommended because Liveblocks only needs on the
client, and in Astro, you may run into bundling issues if the app is rendered on
both the server and client.

## Example

Here's an example of `client:only` used with various frameworks:

```astro
---
import SvelteInput from "../components/SvelteInput.svelte";
import ReactInput from "../components/ReactInput.tsx";
import VueInput from "../components/VueInput.vue";
---

<main>
  <ReactInput client:only="react" />
  <SvelteInput client:only="svelte" />
  <VueInput client:only="vue" />
</main>
```

## Not required with .astro components

Note that when using `.astro` components and the `<script>` tag, `client:only`
is not necessary, because it always runs on the client:

```astro
---
import VanillaInput from "../components/VanillaInput.astro";
---

<main>
  <VanillaInput />
</main>
```

```html
<script>
  import { room, myLiveObject } from "../liveblocksSetup.js";

  const input = document.querySelector("#vanilla");

  room.subscribe(myLiveObject, (updatedLiveObject) => {
    input.value = updatedLiveObject.get("text");
  });

  room.addEventListener("input", (e) => {
    myLiveObject.set("text", e.target.value);
  });
</script>

<input id="vanilla" type="text" onClick="this.select()" />
```

## Using @liveblocks/react with Astro

Note that when using our React package with Astro, `RoomProvider` does not work
in nested `.astro` files, as each component is a separate "island", and cannot
see the context in another island. Each React root in `.astro` files is like a
new React app, and will need its own `RoomProvider`.

---
meta:
  title: "How to use Liveblocks with Next.js /app directory"
  description: "Learn how to add Liveblocks to your Next.js app directory"
---

A pattern weâ€™d recommend when using [Next.js](https://nextjs.org) /app directory
is creating a providers client component for
[`LiveblocksProvider`](/docs/api-reference/liveblocks-react#LiveblocksProvider)
and importing it into `layout.tsx`.

```tsx file="app/Providers.tsx"
import { ReactNode } from "react";
import { LiveblocksProvider } from "@liveblocks/react/suspense";

export function Providers({ children }: { children: ReactNode }) {
  return (
    <LiveblocksProvider authEndpoint="/api/liveblocks-auth">
      {children}
    </LiveblocksProvider>
  );
}
```

```tsx file="app/layout.tsx"
import { ReactNode } from "react";
import { Providers } from "./Providers";

export default function Layout({ children }: { children: ReactNode }) {
  return (
    <html lang="en">
      <body>
        <Providers>{children}</Providers>
      </body>
    </html>
  );
}
```

To join rooms, create a `Room.tsx` client component in the current route, using
`RoomProvider` within here.

```tsx file="app/Room.tsx"
"use client";

import { ReactNode } from "react";
import { RoomProvider } from "../liveblocks.config";
import { LiveObject } from "@liveblocks/client";

export default function Room({ children }: { children: ReactNode }) {
  return (
    <RoomProvider
      id="my-room-name"
      initialStorage={{
        // âœ… This is a client component, so everything works!
        session: new LiveObject(),
      }}
    >
      {children}
    </RoomProvider>
  );
}
```

Doing this avoids an issue when importing `LiveObject/LiveMap/ListList` into
server components. You can then use `Room.tsx` in your page component, and
everything will work as expected.

```tsx file="app/page.tsx"
import { Room } from "./Room";

export default function Page() {
  return <Room>{/* Your Liveblocks app */}</Room>;
}
```

## Structuring your app

To take this one step further, you can then server-render your layout within
`Room`â€™s `children`, whilst using other client components for realtime parts of
your app:

```tsx file="room.tsx"
import { ReactNode } from "react";
import { Room } from "./Room";
import { LiveCanvas } from "./LiveCanvas";

export default function Page({ children }: { children: ReactNode }) {
  return (
    // Room.tsx is a client component that contains RoomProvider
    <Room>
      {/* This layout is server rendered */}
      <header style={{ height: "150px" }}>My drawing app</header>
      <main style={{ width: "100%" }}>
        {/* LiveCanvas is a client component using Liveblocks features */}
        <LiveCanvas />
      </main>
    </Room>
  );
}
```

---
meta:
  title: "How to use Yjs subdocuments"
  description: "Learn how to Yjs subdocuments on client and server"
---

Liveblocks Yjs supports [subdocuments](https://docs.yjs.dev/api/subdocuments),
which allow you to nest Yjs documents inside each other. This guide takes you
through how to use them on client and server.

## When to use subdocuments

Subdocuments are helpful when you have multiple _large_ Yjs documents in the
same room, and you wish to lazy-load them individually. Each subdocument works
similarly to a normal Yjs document, allowing you to use
[shared types](https://docs.yjs.dev/getting-started/working-with-shared-types),
[awareness](https://docs.yjs.dev/getting-started/adding-awareness), and more.

### Not necessary for multiple text editors

Please note that **subdocuments are not necessary for displaying multiple text
editors** on one page. For this use case, itâ€™s often best to create a
[`Y.Map`](https://docs.yjs.dev/api/shared-types/y.map) in your Yjs document, and
place the contents of each editor inside. For example, if your text editor uses
[`Y.XmlFragment`](https://docs.yjs.dev/api/shared-types/y.xmlfragment), hereâ€™s
how to create this.

```tsx
// Create Yjs document with an `editors` map
const yDoc = new Y.Doc();
const yMap = yDoc.getMap("editors");

// Create shared types and add to map
const editorOne = new Y.XMLFragment();
const editorTwo = new Y.XMLFragment();
yMap.set("editor-1", editorOne);
yMap.set("editor-2", editorTwo);

// Pass `editorOne` and `editorTwo` to your text editors
// ...
```

This is much simpler than using subdocuments. However, if the content of these
editors is very large, or if your text editor only accepts a `Y.Doc`,
subdocuments may be for you.

## On the client

Subdocuments can be stored in your Yjs tree like any other shared type. In this
example weâ€™ll create a [`Y.Map`](https://docs.yjs.dev/api/shared-types/y.map) to
store them in, making sure to lazy load any subdocuments.

```ts
import { LiveblocksYjsProvider } from "@liveblocks/yjs";
import * as Y from "yjs";

// Create main document and connect, disabling auto-loading of subdocuments
const yDoc = new Y.Doc();
const yProvider = new LiveblocksYjsProvider(room, doc, {
  autoloadSubdocs: false,
});

// Create a Y.Map to hold subdocuments
const subdocMap = yDoc.getMap("subdocs");
```

### Create a subdocument [#create-a-subdocument]

To create a new subdocument, create a `new Y.Doc()`, and use it like any other.

```ts highlight="8-9,11-14,16-17"
import { LiveblocksYjsProvider } from "@liveblocks/yjs";
import * as Y from "yjs";

// Create main document and connect, disabling auto-loading of subdocuments
const yDoc = new Y.Doc();
const yProvider = new LiveblocksYjsProvider(room, doc, {
  autoloadSubdocs: false,
});

// Create a Y.Map to hold subdocuments
const subdocMap = yDoc.getMap("subdocs");

// Create subdocument
const subdoc = new Y.Doc();
yDoc.getMap().set("my-document", subdoc);
subdoc.getText("default").insert(0, "This is a subdocument");

// Make note of its `guid`, which is used for retrieving it later
const guid = subdoc.guid; // e.g. "c4a755..."
```

Make sure to keep track of its `guid`.

### Load the subdocument

To load the subdocument on _another client_, use its `guid`.

```ts highlight="8-9"
import { LiveblocksYjsProvider } from "@liveblocks/yjs";
import * as Y from "yjs";

// Create main document and connect, disabling auto-loading of subdocuments
const yDoc = new Y.Doc();
const yProvider = new LiveblocksYjsProvider(room, doc, {
  autoloadSubdocs: false,
});

// From another client, load the subdoc using the GUID from `subdoc.guid` or `doc.getSubdocGuids`
yProvider.loadSubdoc("c4a755...");

// Alternatively, get a reference to a subdocument from `doc.getSubdocs()` and then load
// subdoc.load();
```

### Listening for changes

To keep track of subdocument changes, you can use `Y.Doc.on("subdocs")`.

```ts highlight="10-13"
import { LiveblocksYjsProvider } from "@liveblocks/yjs";
import * as Y from "yjs";

// Create main document and connect, disabling auto-loading of subdocuments
const yDoc = new Y.Doc();
const yProvider = new LiveblocksYjsProvider(room, yDoc, {
  autoloadSubdocs: false,
});

yDoc.on("subdocs", ({ added, removed, loaded }) => {
  // Subdocument change
  // ...
});
```

## On the server

Itâ€™s possible to use your subdocument on the server, without connecting with a
provider.

### Fetching a subdocument

When fetching a Yjs subdocument on the server, itâ€™s recommended to use
[`liveblocks.getYjsDocumentAsBinaryUpdate`](/docs/api-reference/liveblocks-node#get-rooms-roomId-ydoc-binary)
with the `guid` of your subdocument. We stored the `guid` when we
[created the subdocument](#create-a-subdocument).

```ts highlight="9-13,15-17"
import { Liveblocks } from "@liveblocks/node";
import * as Y from "yjs";

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

export function POST() {
  // Get your Yjs subdocument as a binary update
  const update = liveblocks.getYjsDocumentAsBinaryUpdate("my-room-id", {
    // The `guid` of your subdocument, as noted earlier
    guid: "c4a755...",
  });

  // Create a Yjs document for your subdoc and apply the update
  const subdoc = new Y.Doc();
  Y.applyUpdate(subdoc, new Uint8Array(update));

  // `subdoc` can now be read
  // ...
}
```

Weâ€™ve now retrieved the subdocument, and it can be read, but any changes you
make wonâ€™t be applied to other clients, and are only temporary.

### Updating a subdocument

To permanently apply changes to your subdocument, sending them to Liveblocks and
other clients, you can use
[`liveblocks.sendYjsBinaryUpdate`](/docs/api-reference/liveblocks-node#put-rooms-roomId-ydoc).

```ts highlight="19-20,22-23,25-29"
import { Liveblocks } from "@liveblocks/node";
import * as Y from "yjs";

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

export function POST() {
  // Get your Yjs subdocument as a binary update
  const update = liveblocks.getYjsDocumentAsBinaryUpdate("my-room-id", {
    // The `guid` of your subdocument, as noted earlier
    guid: "c4a755...",
  });

  // Create a Yjs document for your subdoc and apply the update
  const subdoc = new Y.Doc();
  Y.applyUpdate(subdoc, new Uint8Array(update));

  // Make changes to your `subdoc`, for example
  subdoc.getText("my-text").insert(0, "Hello world");

  // Convert `subdoc` into a binary update
  const subdocChanges = Y.encodeStateAsUpdate(subdoc);

  // Send the changes to Liveblocks, and other clients
  liveblocks.sendYjsBinaryUpdate("my-room-id", subdocChanges, {
    // The `guid` of your subdocument, as noted earlier
    guid: "c4a755...",
  });
}
```

After running this code, all connected users will see the update.

---
meta:
  title: "How to use your Y.Doc on the server"
  description: "Learn how to retrieve your Yjs documentâ€™s Y.Doc on the server"
---

Using [`@liveblocks/node`](/docs/api-reference/liveblocks-node), itâ€™s possible
to retrieve your Yjs document and use it as a
[`Y.Doc`](https://docs.yjs.dev/api/y.doc) on the server. This is often helpful
for retrieving text editor state, and we have some specific guides for this:

- [Getting Tiptap state on the server](/docs/guides/getting-tiptap-state-on-the-server).
- [Getting ProseMirror state on the server](/docs/guides/getting-prosemirror-state-on-the-server).

## Getting your Y.Doc

Using
[`Liveblocks.getYjsDocumentAsBinaryUpdate`](/docs/api-reference/liveblocks-node#get-rooms-roomId-ydoc-binary)
you can fetch your Yjs data, and place it inside a `Y.Doc`.

```ts
import * as Y from "yjs";
import { Liveblocks } from "@liveblocks/node";

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

export async function POST() {
  // Get your Yjs data as a binary update
  const update = await liveblocks.getYjsDocumentAsBinaryUpdate("my-room-name");

  // Create a Yjs document
  const yDoc = new Y.Doc();

  // Apply the binary update to `yDoc`
  Y.applyUpdate(yDoc, new Uint8Array(update));

  // `yDoc` can now be used as you like
  // ...
}
```

Note that any changes you make will not be applied to other users, as the
`Y.Doc` is not connected to any providers.

## Applying changes

Should you wish to send any changes to your document to other users, you can
encode `yDoc` as a binary update, and use
[`Liveblocks.sendYjsBinaryUpdate`](/docs/api-reference/liveblocks-node#put-rooms-roomId-ydoc)
to apply the change.

```ts highlight="18-20,22-23,25-26"
import * as Y from "yjs";
import { Liveblocks } from "@liveblocks/node";

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

export async function POST() {
  // Get your Yjs data as a binary update
  const update = await liveblocks.getYjsDocumentAsBinaryUpdate("my-room-name");

  // Create a Yjs document
  const yDoc = new Y.Doc();

  // Apply the binary update to `yDoc`
  Y.applyUpdate(yDoc, new Uint8Array(update));

  // An example of a `yDoc` modification
  const yText = yDoc.getText("text");
  yText.insert(0, "Hello world");

  // Encode the document state as an update
  const yUpdate = Y.encodeStateAsUpdate(yDoc);

  // Send the update to Liveblocks
  await liveblocks.sendYjsBinaryUpdate(roomId, yUpdate);
}
```

These changes will be immediately applied to all connected users.

---
meta:
  title: "Migrating from Tiptap 2 to 3"
  description:
    "Learn how to upgrade your Liveblocks project from Tiptap 2 to Tiptap 3"
---

Tiptap v3 is a major update with breaking changes, but the migration process is
quite simple. This guide will help you upgrade your Liveblocks project that uses
Tiptap from version 2 to version 3.

<Banner title="Liveblocks 3.10.0+ requires Tiptap 3" type="warning">

Any Liveblocks version after 3.10.0 requires Tiptap 3. If you're upgrading
Liveblocks to version 3.10.0 or higher, you'll need to upgrade Tiptap to version
3 as well.

</Banner>

## Upgrade dependencies

First, you _must_ uninstall all Tiptap and Liveblocks dependencies to avoid
future version conflicts as we upgrade. This includes any extra Tiptap
extensions you may have installed or anything else with a dependency on Tiptap.

### AI-assisted upgrade

The easiest way to do this is to allow our AI assistant to generate the commands
for you. Make sure youâ€™re signed in, paste your `package.json` into the
following input, and generate the commands.

<AskAiInput 
  placeholder="Paste package.json here" 
  prompt={`Write two multi-line npm commands for me:
1. Uninstall all Tiptap and Liveblocks packages. 
2. Install all the same packages with @latest on Liveblocks and @3 on Tiptap

Here is my package.json:

\`\`\`json

{{INPUT}}

\`\`\`

`}>

Generate commands

</AskAiInput>

### Manual upgrade

If youâ€™d like to upgrade manually, you need to run the npm command to uninstall
all Tiptap and Liveblocks packages. Note that you are likely using more package
than are listed here, such as Tiptap extensions.

```bash
npm uninstall @tiptap/react @tiptap/starter-kit @liveblocks/client @liveblocks/react @liveblocks/react-ui @liveblocks/react-tiptap @liveblocks/node
```

Next re-install all Tiptap and Liveblocks packages. If you see a peer dependency
issue during this install, you may have missed something during the previous
uninstall step.

```bash
npm install @tiptap/react@3 @tiptap/starter-kit@3 @liveblocks/client@latest @liveblocks/react@latest @liveblocks/react-ui@latest @liveblocks/react-tiptap@latest @liveblocks/node@latest
```

This will ensure that all packages are compatible with each other and prevent
version conflicts.

## Critical changes for Liveblocks users

While Tiptap 3 includes many changes, there are two particularly critical
changes that affect Liveblocks integration:

### 1. StarterKit configuration change

Liveblocks provides its own undo/redo functionality for collaborative editing.
In Tiptap 2, you disabled this by setting `history: false` in the StarterKit
extension. In Tiptap 3, this option has been renamed to `undoRedo`:

```tsx highlight="3-5"
const editor = useEditor({
  extensions: [
    StarterKit.configure({
      undoRedo: false, // Previously: history: false
    }),
    // Other extensions...
  ],
});
```

### 2. Set `immediatelyRender: false` for SSR

If you're using server-side rendering (such as with Next.js), it's now more
critical to set `immediatelyRender: false` in your editor configuration to
prevent hydration issues:

```tsx highlight="3"
const editor = useEditor(
  {
    immediatelyRender: false,
    extensions: [
      StarterKit.configure({
        undoRedo: false,
      }),
      // Other extensions...
    ],
  },
  []
);
```

This ensures the editor doesn't render on the server, which can cause mismatches
between server and client rendering.

## Style Changes

If you have your own styles for collaboration cursors, the default CSS classes
prefix changed from `.collaboration-cursor` to `.collaboration-carets`.

```diff
- .collaboration-cursor__caret {
+ .collaboration-carets__caret {
  /* Your caret styles */
}

- .collaboration-cursor__label {
+ .collaboration-carets__label {
  /* Your label styles */
}
```

## Full migration guide

For a complete list of breaking changes and new features in Tiptap 3, refer to
the
[official Tiptap upgrade guide](https://tiptap.dev/docs/guides/upgrade-tiptap-v2).

---
meta:
  title: "Migrating to Liveblocks Notifications"
  description:
    "Learn how to migrate from your existing notification system to Liveblocks
    Notifications using a parallel running strategy"
---

[Notifications](/docs/ready-made-features/notifications) are a core driver of
engagement in collaborative products. By using Liveblocks Notifications, you can
unify how updates are delivered across your product suite, ensuring that users
receive timely, relevant, and actionable updates instead of noisy alerts. This
creates cross-product consistency, deeper engagement, and long-term retention,
making collaboration a habit rather than a feature.

This guide walks you through how to migrate from your existing system to
**Liveblocks Notifications** using a **parallel running strategy**. With this
approach, both systems operate simultaneously, allowing you to gradually
transition data and logic. Once all notifications have been successfully
migrated and validated, you can switch to Liveblocks Notifications to power your
end-to-end collaboration experience.

## Understand Liveblocks notification concepts

Before starting the migration, it's important to understand the key concepts in
Liveblocks Notifications. We suggest reviewing our
[notification concepts documentation](/docs/ready-made-features/notifications/concepts)
for a comprehensive overview.

### Custom vs. Collaboration notifications

Liveblocks provides two types of notifications: collaboration notifications and
custom notifications.

**Collaboration notifications** are built-in and designed to cover the most
common collaboration patterns out of the box. They automatically handle things
like mentions, replies, and comment activity across your app. For example, when
someone tags a teammate or replies in a thread, a collaboration notification is
sent to keep that person in the loop without any extra setup.

**Custom notifications** give you flexibility to extend beyond those default
patterns. You can create notifications for product-specific events like task
assignments, workflow approvals, or new AI-generated updates. These are ideal
when you want to connect collaboration moments that are unique to your product
or when you are combining multiple systems into a unified notification
experience. Take a look at our
[custom notification example](/examples/notifications-custom/nextjs-notifications-custom)
to get an idea of what you can build.

Together, they let you balance speed and control. Use collaboration
notifications to power your core collaboration flows and add custom ones
wherever your product needs a more tailored experience.

### Key terminology

- An **inbox notification** refers to an in-app message or icon shown to a user
  to indicate theyâ€™ve received a notification (similar to a notifications tray).
- A **notification** refers to a channel-based message (e.g. Slack, Teams,
  email, web push) triggered if the inbox notification goes unread for a period
  of time, or immediately if the notification throttle is instantaneous.
- The **project notification settings** refer to how channel notifications can
  be configured in the Liveblocks dashboard.

  <Figure>
    <Image
      src="/assets/notifications/project-notification-settings.png"
      alt="Project notification settings"
      width={1344}
      height={896}
    />
  </Figure>
  You can view what notification kinds are active for each channel.
  <Figure>
    <Image
      src="/assets/notifications/project-notification-settings-kinds.png"
      alt="Project notification settings kinds"
      width={1344}
      height={896}
    />
  </Figure>
  View the configuration for each notification kind.
  <Figure>
    <Image
      src="/assets/notifications/project-notification-settings-edit.png"
      alt="Project notification settings edit"
      width={1344}
      height={896}
    />
  </Figure>
  Update the configuration for each notification channel and kind.

- The **user notification settings** refer to how a user can choose which
  notifications to receive on which channel (email, Slack, Teams, and more).

  <Figure>
    <Image
      src="/assets/notifications/notification-settings.jpg"
      alt="User notification settings"
      width={1344}
      height={896}
    />
  </Figure>

### Data flow

An unread inbox notification will trigger a notification based on the project
notification settings and the user notification settings. Liveblocks evaluates
both the project-level configuration and user preferences to determine whether
to send a channel notification.

<Figure>
  <Image
    src="/assets/notifications/notification-flow.png"
    alt="Notification flow"
    width={672}
    height={990}
  />
</Figure>

## Prepare for the migration

### Create data mappings from your system to Liveblocks

#### In-app notifications mappings

The most important step is to map your systemâ€™s in-app notifications to
Liveblocksâ€™s inbox notifications, as you will dual write to both your system and
Liveblocks in a later step.

Inbox notifications are triggered by your backend using the
[`triggerInboxNotification` API](/docs/api-reference/liveblocks-node#post-inbox-notifications-trigger).

```tsx
await liveblocks.triggerInboxNotification({
  // The ID of the user that will receive the inbox notification
  userId: "steven@example.com",

  // The custom notification kind, must start with a $
  kind: "$fileUploaded",

  // Custom ID for this specific notification
  subjectId: "my-file",

  // Custom data related to the activity that you need to render the inbox notification
  activityData: {
    // Data can be a string, number, or boolean
    file: "https://example.com/my-file.zip",
    size: 256,
    success: true,
  },

  // Optional, define the room ID the notification was sent from
  roomId: "my-room-id",
});
```

`kind` must start with a `$`, and represents the type of notification.

`activityData` is used to send custom data with the notification, and properties
can have `string`, `number`, or `boolean` values.

`subjectId` represents the custom ID the notification should be associated to.

Itâ€™s also possible to batch inbox notifications together by `subjectId`, rather
than creating a new one each time.

#### Batching custom notifications

Batching allows you to group multiple activities into a single notification.
This is useful for reducing the number of notifications that are sent to the
user, and can be enabled on custom notification kinds.

Within the â€œNotificationsâ€ page in the
[dashboard](https://liveblocks.io/dashboard), you can add a custom kind and
enable batching. When itâ€™s enabled, triggering an inbox notification activity
for a specific `subjectId`, will update the existing inbox notification instead
of creating a new one.

<details>
<summary>Notification batching example</summary>

A common use case is file upload notifications as a file usually goes through an
upload process.

```tsx
const options = {
  userId: "steven@example.com",
  kind: "$fileUploaded",
  subjectId: "my-file",
};

await liveblocks.triggerInboxNotification({
  ...options,

  activityData: {
    status: "processing",
  },
});

await liveblocks.triggerInboxNotification({
  ...options,

  activityData: {
    status: "complete",
  },
});

const { data: inboxNotifications } = await liveblocks.getInboxNotifications({
  userId: "steven@example.com",
});

// {
//   id: "in_3dH7sF3...",
//   kind: "$fileUploaded",
//   activities: [
//     { status: "processing" },
//     { status: "complete" },
//   ],
//   ...
// }
console.log(inboxNotifications[0]);
```

</details>

With this information, go through each of your notification types and map them
to Liveblocks.

For each type of notification, decide its kind, the `subjectId`, and whether it
will be batched. Use the `activityData` to pass in the content that would be
relevant to display to the user.

<details>
<summary>Model for a custom inbox notification</summary>

```tsx
export interface LiveblocksActivity {
  // Unique ID for this activity within the notification
  id: string;

  // When the activity occurred
  createdAt: string; // ISO 8601 timestamp

  // Custom data payload sent when triggering the notification
  data: Record<string, string | number | boolean | null>;
}

export interface LiveblocksInboxNotification {
  // Unique inbox notification ID
  id: string;

  // The tenant ID (useful in multi-tenant setups)
  tenantId: string;

  // Notification kind â€” for custom notifications, must start with "$"
  kind: string; // e.g., "$alert"

  // Identifier used to group notifications
  subjectId: string;

  // When the notification was first sent
  notifiedAt: string;

  // When the user marked it as read (null if unread)
  readAt: string | null;

  // Optional room or project scope
  roomId: string | null;

  // Ordered list of activities within the notification
  activities: LiveblocksActivity[];
}
```

</details>

### Setup notification settings in the Liveblocks dashboard

Now that you have identified all mappings, youâ€™ll want to define how channel
notifications will behave. This can be done through Liveblocksâ€™s notification
dashboard.

There are four settings per kind:

- **Enabled:** whether the channel is enabled
- **User default:** the default setting for the user
  - If true, the notifications will be sent to the channel unless the user
    disabled them
  - If false, the notifications wonâ€™t be sent unless the user enabled them
- **Throttle:** The throttle period (e.g., the 30 minutes delay) can be
  configured in your project settings on the Liveblocks dashboard. During this
  throttle time, if multiple events happen, they can be combined or managed so
  as not to overwhelm the user with too many notifications at once.
- **Batching:** When itâ€™s enabled, triggering an inbox notification activity for
  a specific `subjectId`, will update the existing inbox notification instead of
  creating a new one.

<details>
<summary>Example</summary>

A batched file upload notification could trigger a Slack message on each update
instantly and an email thirty minutes later.

</details>

### Setup your webhook endpoint to receive notifications

<Banner title="Feature flag">

Use a feature flag to either send notifications from your legacy system or from
the webhook endpoint.

</Banner>

Youâ€™ve setup notifications! Now the only thing left before starting the
migration is to setup the webhook endpoint to consume the notifications. This
will allow proper monitoring of the migration.

**Follow our webhooks documentation to setup your endpoint:**

- [Configuring webhooks](/docs/platform/webhooks#Configuring-webhooks)

**Follow this guide to setup email notifications for comments:**

- [Email notifications](/docs/ready-made-features/notifications/email-notifications)

**Follow this guide to setup a new notification kind:**

- [What to check before enabling a new notification kind](/docs/guides/what-to-check-before-enabling-a-new-notification-kind)

## Dual write

During this phase, youâ€™ll write to both your legacy notification system and
Liveblocks simultaneously. This ensures data consistency while allowing you to
validate that Liveblocks is working correctly before fully switching over.
Youâ€™ll dual write both in-app notifications and user notification settings.

### In-app notifications

Store Liveblocks IDs alongside your legacy IDs to keep states aligned. Create
the Liveblocks notification, then add the corresponding Liveblocks ID to the
created legacy notification.

```tsx
// Server: dual-write
import { Liveblocks } from "@liveblocks/node";
const liveblocks = new Liveblocks({ secret: process.env.LIVEBLOCKS_SECRET! });

async function createNotificationDualWrite(input: LegacyNotification) {
  const liveblocksData = mapLegacyToLiveblocks(input);

  // 1. Write to Liveblocks
  const { id: liveblocksId } = await liveblocks.triggerInboxNotification({
    userId: liveblocksData.userId,
    kind: liveblocksData.kind,
    subjectId: liveblocksData.subjectId,
    roomId: liveblocksData.roomId,
    activityData: liveblocksData.activityData,
  });

  // 2. Write to legacy
  const legacy = await legacyNotifications.insert({
    ...input,
    // We add the liveblocksId to mark notifications as read later
    liveblocksId,
  });

  return { legacyId: legacy.id, liveblocksId };
}
```

Now whenever the user marks a notification as read you can also mark it as read
in Liveblocks.

```tsx
// Server: dual-write
import { Liveblocks } from "@liveblocks/node";
const liveblocks = new Liveblocks({ secret: process.env.LIVEBLOCKS_SECRET! });

async function markNotificationAsReadDualWrite(legacyNotificationId) {
  // 1) write to legacy
  const legacy = await legacyNotifications.markAsRead(legacyNotificationId);

  if (legacy.liveblocksId) {
    await liveblocks.markInboxNotificationAsRead(legacyNotificationId);
  }

  return { legacyId: legacy.id, liveblocksId };
}
```

### User notification settings

Each time users change their channel notification settings preference, the
changes must be reflected in Liveblocks. You will use the
`updateNotificationSettings` API to do that.

```tsx
// Server: dual-write user channel settings
async function updateUserChannelSettings(userId: string, settings) {
  await legacyUserSettings.set(userId, settings);

  const liveblocksSettings = mapLegacyToLiveblocks(settings);

  const updatedSettings = await liveblocks.updateNotificationSettings({
    userId,
    data: liveblocksSettings,
  });
}
```

## Backfill

Once dual writing is in place, youâ€™ll need to backfill existing data from your
legacy system into Liveblocks. This will ensure user settings are available in
Liveblocks before you complete the migration.

### User notification settings

Go through all your usersâ€™ settings and update the notification settings in
Liveblocks.

```tsx
// Server: backfill user channel settings
async function updateUserChannelSettings(userId: string) {
  const settings = await legacyUserSettings.get(userId);

  const liveblocksSettings = mapLegacyToLiveblocks(settings);

  const updatedSettings = await liveblocks.updateNotificationSettings({
    userId,
    data: liveblocksSettings,
  });
}
```

### Setup the inbox notification UI

<Banner title="Feature flag">

Use a feature flag to either display notifications from your legacy system or
Liveblocks.

</Banner>

Follow our documentation on notifications to setup the inbox notification UI in
your application.

[InboxNotification component](/docs/ready-made-features/notifications/default-components#InboxNotification)

### Setup user notification settings UI

<Banner title="Feature flag">

Use a feature flag to display user notifications settings from your legacy
system or from the Liveblocks.

</Banner>

Follow our guide on creating a notification settings panel:

[How to create a notification settings panel](/docs/guides/how-to-create-a-notification-settings-panel#Custom-notification-kinds)

## Release

You have setup dual writing, backfilled the data, prepared the webhook endpoint
to send channel notifications and setup the UIs for inbox notifications and user
notification settings. The only thing left to do to release is to toggle the
feature flag to switch from your legacy notification system to Liveblocksâ€™s.

## Clean-up

You can now stop writing to the legacy system and only write to Liveblocks
notifications and user notification settings. You can also remove the feature
flag from your webhook endpoint and from your application.

---
meta:
  title: "Modifying Yjs document data with the REST API"
  description:
    "Learn how to update your Yjs document using the Liveblocks REST API"
---

Liveblocks allows you to update your Yjs document data, or `yDoc`, from the REST
API, helpful for sending updates from the server. This is made possible through
[`Liveblocks.sendYjsBinaryUpdate`](/docs/api-reference/liveblocks-node#put-rooms-roomId-ydoc)
in [`@liveblocks/node`](/docs/api-reference/liveblocks-node).

## Updating a Yjs document

Updating a Yjs document requires you to create a
[binary update](https://docs.yjs.dev/api/document-updates), before sending it to
Liveblocks using
[`Liveblocks.sendYjsBinaryUpdate`](/docs/api-reference/liveblocks-node#put-rooms-roomId-ydoc).
Hereâ€™s an example in a serverless endpoint.

```ts
import * as Y from "yjs";
import { Liveblocks } from "@liveblocks/node";

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});
const roomId = "my-room-name";

export async function POST() {
  // Create a Yjs document
  const yDoc = new Y.Doc();

  // Create your data structures and make your update
  // Each editor is different, you probably need to change these two lines
  const yText = yDoc.getText("text");
  yText.insert(0, "Hello world");

  // Encode the document state as an update
  const yUpdate = Y.encodeStateAsUpdate(yDoc);

  // Insert the update
  await liveblocks.sendYjsBinaryUpdate(roomId, yUpdate);
}
```

Note that if youâ€™re using a text editor,
[each one works differently](#each-editor-works-differently), so youâ€™ll most
likely need to modify these two lines to use a format your editor defines.

```ts
const yText = yDoc.getText("text");
yText.insert(0, "Hello world");
```

## Initializing a Yjs document

Itâ€™s also possible to create a new room with an initial Yjs document. To do
this, call
[`Liveblocks.createRoom`](/docs/api-reference/liveblocks-node#post-rooms), then
send the update as before.

```ts highlight="21-24"
import * as Y from "yjs";
import { Liveblocks } from "@liveblocks/node";

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});
const roomId = "my-room-name";

export async function POST() {
  // Create a Yjs document
  const yDoc = new Y.Doc();

  // Create your data structures and make your update
  // Each editor is different, you probably need to change these two lines
  const yText = yDoc.getText("text");
  yText.insert(0, "Hello world");

  // Encode the document state as an update
  const yUpdate = Y.encodeStateAsUpdate(yDoc);

  // Create the new room
  const room = await liveblocks.createRoom(roomId, {
    defaultAccesses: ["room:write"],
  });

  // Initialize the Yjs document with the update
  await liveblocks.sendYjsBinaryUpdate(roomId, yUpdate);
}
```

## Each editor works differently [#each-editor-works-differently]

Note that each text and code editor may work differently, and may include
specific functions for creating binary updates, or use different shared types.
Slate and Tiptap use
[`Y.XmlFragment`](https://docs.yjs.dev/api/shared-types/y.xmlfragment) instead
of [`Y.Text`](https://docs.yjs.dev/api/shared-types/y.text).

### Slate

This is how to initialize a [Slate](/docs/get-started/yjs-slate-react) document.

```ts highlight="3,14-18,20-22"
import * as Y from "yjs";
import { Liveblocks } from "@liveblocks/node";
import { slateNodesToInsertDelta } from "@slate-yjs/core";

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});
const roomId = "my-room-name";

export async function POST() {
  // Create a Yjs document
  const yDoc = new Y.Doc();

  // The Slate document we're creating
  const slateDoc = {
    type: "paragraph",
    children: [{ text: "Hello world" }],
  };

  // Create your data structures and make your update
  const insertDelta = slateNodesToInsertDelta(slateDoc);
  (yDoc.get("content", Y.XmlText) as Y.XmlText).applyDelta(insertDelta);

  // Encode the document state as an update
  const yUpdate = Y.encodeStateAsUpdate(yDoc);

  // Create the new room
  const room = await liveblocks.createRoom(roomId, {
    defaultAccesses: ["room:write"],
  });

  // Initialize the Yjs document with the update
  await liveblocks.sendYjsBinaryUpdate(roomId, yUpdate);
}
```

### Tiptap

This is how to initialize a
[Tiptap](https://tiptap.dev/docs/editor/api/extensions/collaboration) document.

```ts highlight="13-15,17-19"
import * as Y from "yjs";
import { Liveblocks } from "@liveblocks/node";

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});
const roomId = "my-room-name";

export async function POST() {
  // Create a Yjs document
  const yDoc = new Y.Doc();

  // The Tiptap Yjs state we're creating
  const yXmlElement = new Y.XmlElement("paragraph");
  yXmlElement.insert(0, [new Y.XmlText("Hello world")]);

  // Create your data structures and make your update
  const yXmlFragment = yDoc.getXmlFragment("default");
  yXmlFragment.insert(0, [yXmlElement]);

  // Encode the document state as an update message
  const yUpdate = Y.encodeStateAsUpdate(yDoc);

  // Create the new room
  const room = await liveblocks.createRoom(roomId, {
    defaultAccesses: ["room:write"],
  });

  // Initialize the Yjs document with the update
  await liveblocks.sendYjsBinaryUpdate(roomId, yUpdate);
}
```

---
meta:
  title: "Reauthenticate without reloading the page or losing state"
  description:
    "Learn how to reauthenticate the current room without refreshing the page"
---

Sometimes itâ€™s helpful to [reauthenticate](/docs/authentication) users, for
example after a logged out user has signed into your application, and you wish
to display their details.

## How to reauthenticate

By calling
[`room.reconnect`](/docs/api-reference/liveblocks-client#Room.reconnect) you can
reconnect and reauthenticate your collaborative application without refreshing
the page or unmounting the
[`RoomProvider`](/docs/api-reference/liveblocks-react#RoomProvider) component.
Using this method will preserve the current clientâ€™s state, such as the
undo/redo history.

```ts highlight="5"
const { room, leave } = client.enterRoom("my-room", {
  // ...
});

room.reconnect();
```

### In React

In our React package, you can retrieve the current room with the
[`useRoom`](/docs/api-reference/liveblocks-react#useRoom) hook, before calling
`room.reconnect` from there.

```tsx highlight="4,6"
import { useRoom } from "../liveblocks.config";

export function App() {
  const room = useRoom();

  return <button onClick={room.reconnect}>Reauthenticate</button>;
}
```

---
meta:
  title: "Revalidate API data in realtime with SWR"
  description:
    "Learn how use Liveblocks and SWR to revalidate API data in realtime"
---

[SWR](https://swr.vercel.app) is a library that provides
[React](https://react.dev) hooks for data fetching. Itâ€™s possible to revalidate
your data in realtime by broadcasting events using Liveblocks.

An example usage of this may be a share dialog containing a list of usersâ€”when a
new user is added to the dialog, we can broadcast an event telling other online
users to refresh their user list.

## Broadcasting events

A simple SWR hook that fetches a list of users may look similar to this:

```tsx
function Component() {
  const { data: users, mutate } = useSWR("/api/users", fetcher);

  return (
     <div>
       {users.map((user) => /* ... */)}:
     </div>
  );
}
```

To create a function that allows us to update this data in realtime, we can
broadcast an event telling other clients to revalidate their data with
[useBroadcastEvent](https://liveblocks.io/docs/api-reference/liveblocks-react#useBroadcastEvent):

```tsx
const broadcast = useBroadcastEvent();

// Sending a custom REVALIDATE event
broadcast({ type: "REVALIDATE" });
```

We can then listen for the event with
[useEventListener](https://liveblocks.io/docs/api-reference/liveblocks-react#useEventListener),
and call the mutate function from SWR to update the data:

```tsx
const { data: users, mutate } = useSWR("/api/users", fetcher);

useEventListener(({ event }) => {
  if (event.type === "REVALIDATE") {
    mutate();
  }
});
```

## Putting it together

If we put everything together, we can display a list of users, broadcasting a
revalidate event when a new user is added to the list.

```tsx
import { useBroadcastEvent, useEventListener } from "../liveblocks.config";

function Component() {
  // Data updates on every button click
  const { data, mutate } = useSWR("/api/user", fetcher);

  // Listen for custom event
  useEventListener(({ event }) => {
    if (event.type === "REVALIDATE") {
      mutate();
    }
  });

  // Create broadcast hook
  const broadcast = useBroadcastEvent();

  function addUser() {
    // Code to add a new user to your list
    // ...

    // Broadcast the custom event
    broadcast({ type: "REVALIDATE" });
  }

  return (
    <div>
      {users.map((user) => /* ... */)}:
      <button onClick={addUser}>Add new user</button>
    </div>
  );
}
```

Great, data that revalidates in realtime at the click of a button! You can find
an example of this technique being used in the
[Next.js Starter Kit](https://github.com/liveblocks/liveblocks/blob/main/starter-kits/nextjs-starter-kit/components/ShareDialog/ShareDialog.tsx#L123-L131).

---
meta:
  title: "Setting an initial or default value in BlockNote"
  description:
    "Learn how to set an initial value to display when the document is empty"
---

Yjs doesnâ€™t allow you to set an initial value for a document, as documents are
stored as a list of changes, rather than as the current state. If you were to
try add a default value, this would instead be sent as an append command,
meaning that it would be added to any existing data in the document, instead of
working as a default value.

<Banner title="This guide is for Yjs, not Text Editor" type="warning">

If youâ€™re using our [Text Editor](/docs/ready-made-features/text-editor)
BlockNote product, thereâ€™s an
[option to set the initial value](/docs/api-reference/liveblocks-react-blocknote#Setting-initial-content),
and you should use this method. This guide is only
[Sync Datastore and Yjs](/docs/platform/sync-datastore).

</Banner>

## Setting content in BlockNote

BlockNote allows you to set a default value by setting `initialContent` in
`useCreateBlockNote`, however when connected to Yjs this will trigger the
duplication problem.

```tsx
function Editor({ doc, provider }: EditorProps) {
  const editor: BlockNoteEditor = useCreateBlockNote({
    // +++
    initialContent: [{ type: "paragraph", content: "Hello world" }],
    // +++

    // Other options
    // ...
  });

  return <BlockNoteView editor={editor} />;
}
```

### Default value with Yjs

To avoid this problem, you can instead wait for Liveblocks Yjs to connect, check
if the editorâ€™s content is empty, and _then_ set a default value.

```tsx
function Editor({ doc, provider }: EditorProps) {
  const editor = useEditor({
    // Options
    // ...
  });

  // +++
  // Set default state
  useEffect(() => {
    function setDefault() {
      if (!editor) {
        return;
      }

      if (editor.document.length === 1) {
        editor.insertBlocks(
          [{ type: "paragraph", content: "Hello world" }],
          editor.document[0]
        );
      }
    }

    if (provider.isReady) {
      setDefault();
    }

    provider.on("sync", setDefault);
    return () => provider.off("sync", setDefault);
  }, [provider, editor]);
  // +++

  return <BlockNoteView editor={editor} />;
}
```

---
meta:
  title: "Setting an initial or default value in Tiptap"
  description:
    "Learn how to set an initial value to display when the document is empty"
---

Yjs doesnâ€™t allow you to set an initial value for a document, as documents are
stored as a list of changes, rather than as the current state. If you were to
try add a default value, this would instead be sent as an append command,
meaning that it would be added to any existing data in the document, instead of
working as a default value.

<Banner title="This guide is for Yjs, not Text Editor" type="warning">

If youâ€™re using our [Text Editor](/docs/ready-made-features/text-editor) Tiptap
product, thereâ€™s an
[option to set the initial value](/docs/api-reference/liveblocks-react-tiptap#Setting-initial-content),
and you should use this method. This guide is only
[Sync Datastore and Yjs](/docs/platform/sync-datastore).

</Banner>

## Setting content in Tiptap

Tiptap allows you to set a default value by setting `content` in `useEditor`,
however when connected to Yjs this will trigger the duplication problem.

```tsx highlight="3"
function Editor({ doc, provider }: EditorProps) {
  const editor = useEditor({
    content: "<p>This will duplicate on load</p>",

    // Options
    // ...
  });

  return <EditorContent editor={editor} />;
}
```

### Default value with Yjs

To avoid this problem, you can instead wait for Liveblocks Yjs to connect, check
if the editorâ€™s content is empty, and _then_ set a default value.

```tsx highlight="7-27"
function Editor({ doc, provider }: EditorProps) {
  const editor = useEditor({
    // Options
    // ...
  });

  // Set default state
  useEffect(() => {
    function setDefault() {
      if (!editor) {
        return;
      }

      if (editor.getText() === "") {
        editor.commands.setContent(`
          <h1>Default content</h1>
          <p>
            My <strong>paragraph</strong>
          </p>
        `);
      }
    }

    setDefault();
    provider.on("sync", setDefault);
    return () => provider.off("sync", setDefault);
  }, [provider, editor]);

  return <EditorContent editor={editor} />;
}
```

---
meta:
  title: "Tiptap best practices and tips"
  description:
    "Learn best practices and common pitfalls to avoid when working with Tiptap
    and Liveblocks"
---

This guide covers best practices and common pitfalls to avoid when working with
Tiptap and Liveblocks.

<Banner title="Tiptap is backed by Yjs">

Tiptap uses [Yjs](https://docs.yjs.dev/) for synchronization. Make sure to also
check out our [Yjs best practices and tips](/guides/yjs-best-practices-and-tips)
guide for additional recommendations.

</Banner>

## Always include StarterKit or Doc & Paragraph extensions

The Tiptap
[StarterKit](https://tiptap.dev/docs/editor/extensions/functionality/starterkit)
extension is **required** for Tiptap to function properly. It provides essential
node types that every Tiptap editor needs, specifically the `Doc` and
`Paragraph` nodes. Alternatively you can include only the
[Doc](https://tiptap.dev/docs/editor/extensions/nodes/document) and
[Paragraph](https://tiptap.dev/docs/editor/extensions/nodes/paragraph)
extensions.

### Why StarterKit is required

Tiptap documents must have a root `Doc` node and at least one `Paragraph` node
to maintain a valid document structure. Without these core nodes, the editor
will not work correctly and synchronization will fail.

```tsx
import { useEditor } from "@tiptap/react";
import StarterKit from "@tiptap/starter-kit";

const editor = useEditor({
  extensions: [
    // +++
    StarterKit.configure({
      // Required, Liveblocks extension handles its own history
      undoRedo: false,
    }),
    // +++
    // Add other extensions here
  ],
});
```

<Banner>

`undoRedo` used to be called `history` in Tiptap v2.

</Banner>

### What StarterKit includes

In addition to the required `Doc` and `Paragraph` nodes, StarterKit also
includes commonly used extensions like:

- Text formatting (Bold, Italic, Strike, Code)
- Block types (Heading, Blockquote, CodeBlock, BulletList, OrderedList,
  ListItem)
- Horizontal rule and hard break
- History (undo/redo) (This must be disabled to work with Liveblocks)

If you need more control over which extensions are included, you can configure
StarterKit to disable specific extensions:

```tsx
const editor = useEditor({
  extensions: [
    StarterKit.configure({
      // Disable extensions you don't need
      // +++
      heading: false,
      blockquote: false,
      // +++
      // Required, Liveblocks extension handles its own history
      undoRedo: false,
    }),
  ],
});
```

However, you should **never disable** the `doc` or `paragraph` options, as these
are required for the editor to function.

## Disable server-side rendering with immediatelyRender: false

When using Tiptap with server-side rendering (SSR) frameworks like Next.js, you
should _always_ set `immediatelyRender: false` in your `useEditor` hook. Tiptap
should never be rendered on the server.

### Why disable server-side rendering?

Tiptap is a client-side editor that relies on browser APIs and the DOM. When
rendered on the server, it can cause:

- Hydration mismatches between server and client
- Errors related to missing browser APIs

### How to disable server-side rendering

Set `immediatelyRender: false` in your `useEditor` configuration:

```tsx
// âœ… CORRECT: Disable server-side rendering for Next.js and other SSR frameworks
import { useEditor } from "@tiptap/react";
import { useLiveblocksExtension } from "@liveblocks/react-tiptap";
import StarterKit from "@tiptap/starter-kit";

function Editor() {
  const liveblocks = useLiveblocksExtension();

  const editor = useEditor({
    // Required for SSR frameworks like Next.js
    // +++
    immediatelyRender: false,
    // +++
    extensions: [
      StarterKit.configure({
        // Required, Liveblocks extension handles its own history
        undoRedo: false,
      }),
      liveblocks,
    ],
  });

  return <EditorContent editor={editor} />;
}
```

This ensures that Tiptap is only rendered on the client side, avoiding any
server-side rendering issues.

<Banner title="Required for Next.js" type="warning">

If you're using Next.js (App Router or Pages Router) or any other SSR framework,
**always set `immediatelyRender: false`**. Failing to do so will cause hydration
errors and other unexpected behavior.

</Banner>

## Enable content validation

Tiptap has a schema that defines the structure of your document. By default,
Tiptap does **not validate content** against this schema. When invalid content
is present, it will **silently break synchronization** without any error
messages.

This can happen when:

- Extensions are added or removed from the editor
- The schema changes between different versions of your application
- Users collaborate on documents with different editor configurations

### How to enable content validation

Always enable content validation by setting `enableContentCheck: true` and
implementing an `onContentError` handler:

```tsx
import { useEditor } from "@tiptap/react";
import StarterKit from "@tiptap/starter-kit";

const editor = useEditor({
  extensions: [
    StarterKit.configure({
      // Required, Liveblocks extension handles its own history
      undoRedo: false,
    }),
  ],
  // +++
  enableContentCheck: true,
  onContentError: ({ editor, error, disableCollaboration }) => {
    // Disable collaboration to prevent data corruption
    disableCollaboration();

    // Make the editor read-only to prevent further changes
    editor.setEditable(false, false);

    // Log the error for debugging
    console.error("Content validation error:", error);

    // Notify the user that there's an issue
    alert(
      "There was an error loading this document. The content may be incompatible with the current editor version. The document has been made read-only to prevent data loss."
    );
  },
  // +++
});
```

This ensures that:

- Invalid content is detected early
- Collaboration is disabled to prevent data corruption
- The editor is made read-only to prevent further changes
- The issue is logged for debugging
- Users are notified of the problem

## Use initialContent instead of content

When setting default content for your Tiptap editor, always use
[`initialContent`](/docs/api-reference/liveblocks-react-tiptap#Setting-initial-content)
on
[`useLiveblocksExtension`](/docs/api-reference/liveblocks-react-tiptap#useLiveblocksExtension)
instead of `content` on `useEditor`. Using `content` will cause the content to
be appended to the document every time the page loads or the component
re-renders.

### The problem with content

The `content` option in Tiptap sets the editor content every time the editor is
initialized. When using Liveblocks, this means the content will be **added** to
the existing document rather than replacing it, causing duplication:

```tsx
// âŒ AVOID: This will duplicate content on every page load
const editor = useEditor({
  extensions: [
    StarterKit.configure({
      // Required, Liveblocks extension handles its own history
      undoRedo: false,
    }),
    liveblocks,
  ],
  // âŒ This text will be added to the document every time the editor is loaded
  // +++
  content: "<p>Default text</p>",
  // +++
});
```

### Use initialContent instead

The `initialContent` option sets a flag internally and only sets the content the
**very first time** the document is empty. This prevents duplication:

```tsx
// âœ… CORRECT: This only sets content once
import { useEditor } from "@tiptap/react";
import { useLiveblocksExtension } from "@liveblocks/react-tiptap";
import StarterKit from "@tiptap/starter-kit";

function Editor() {
  const liveblocks = useLiveblocksExtension({
    // âœ… This text is only set the first time the room is used
    // +++
    initialContent: "<p>Default text</p>",
    // +++
  });

  const editor = useEditor({
    extensions: [
      StarterKit.configure({
        // Required, Liveblocks extension handles its own history
        undoRedo: false,
      }),
      liveblocks,
    ],
  });

  return <EditorContent editor={editor} />;
}
```

<Banner title="Not compatible with the field option" type="warning">

The
[`initialContent`](/docs/api-reference/liveblocks-react-tiptap#Setting-initial-content)
option does not currently work when using the
[`field`](/docs/api-reference/liveblocks-react-tiptap#Multiple-editors) option
for multiple editors. If you need to set initial content for multiple editors,
you'll need to implement your own logic to check if the document is empty before
setting content.

</Banner>

## Support multiple editors with the field option

If you want to display multiple Tiptap editors on the same page, use the
[`field`](/docs/api-reference/liveblocks-react-tiptap#Multiple-editors) option
with a unique identifier for each editor. This ensures that each editor
synchronizes to its own section of the Yjs document.

```tsx
import { useEditor } from "@tiptap/react";
import { useLiveblocksExtension } from "@liveblocks/react-tiptap";
import StarterKit from "@tiptap/starter-kit";

function EditorOne() {
  const liveblocks = useLiveblocksExtension({
    // Unique identifier for this editor
    // +++
    field: "editor-1",
    // +++
  });

  const editor = useEditor({
    extensions: [
      StarterKit.configure({
        // Required, Liveblocks extension handles its own history
        undoRedo: false,
      }),
      liveblocks,
    ],
  });

  return <EditorContent editor={editor} />;
}

function EditorTwo() {
  const liveblocks = useLiveblocksExtension({
    // Different unique identifier
    // +++
    field: "editor-2",
    // +++
  });

  const editor = useEditor({
    extensions: [
      StarterKit.configure({
        // Required, Liveblocks extension handles its own history
        undoRedo: false,
      }),
      liveblocks,
    ],
  });

  return <EditorContent editor={editor} />;
}
```

Without the `field` option, both editors would synchronize to the same location
in the document, causing conflicts and data loss.

## Never use extensions with binary data

Never use Tiptap extensions that store binary data (such as base64-encoded
images) directly in the document. Binary data will be synchronized across all
clients and can fill up your Liveblocks room extremely quickly, leading to:

- Increased bandwidth usage
- Slower synchronization
- Higher storage costs
- Potential rate limiting

### Common pitfall: Image extension

The official Tiptap
[Image extension](https://tiptap.dev/docs/editor/extensions/nodes/image) has an
`allowBase64` option. This option is **defaulted to `false`**, and it should
**never be set to `true`**.

```tsx
// âŒ NEVER DO THIS
import Image from "@tiptap/extension-image";

const editor = useEditor({
  extensions: [
    StarterKit.configure({
      // Required, Liveblocks extension handles its own history
      undoRedo: false,
    }),
    Image.configure({
      // This will quickly fill up your room and cause problems
      // +++
      allowBase64: true,
      // +++
    }),
  ],
});
```

### Recommended approach

Instead of storing images as base64 in the document:

1. Upload images to a file storage service (e.g., AWS S3, Cloudflare R2, Vercel
   Blob)
2. Store only the URL in the document
3. Reference the URL in your image nodes

```tsx
// âœ… CORRECT: Store only URLs
import Image from "@tiptap/extension-image";

const editor = useEditor({
  extensions: [
    StarterKit.configure({
      // Required, Liveblocks extension handles its own history
      undoRedo: false,
    }),
    Image.configure({
      // The default option. Never set to `true` as it will cause issues with Liveblocks
      // +++
      allowBase64: false,
      // +++
    }),
  ],
});

// When adding an image
// +++
editor.commands.setImage({
  // URL only, no base64
  src: "https://your-storage.com/images/photo.jpg",
});
// +++
```

## Prevent users from losing unsaved changes

To prevent users from accidentally losing their work when closing the browser
tab or navigating away, enable the
[`preventUnsavedChanges`](/docs/api-reference/liveblocks-react#prevent-users-losing-unsaved-changes)
option:

```tsx
import { RoomProvider } from "@liveblocks/react/suspense";

<RoomProvider
  id="my-room"
  initialPresence={{}}
  // Warn users before they leave with unsaved changes
  // +++
  preventUnsavedChanges={true}
  // +++
>
  {/* Your components */}
</RoomProvider>;
```

This will display a browser confirmation dialog when users try to leave the page
with unsaved changes, helping prevent accidental data loss.
[Learn more](/docs/api-reference/liveblocks-react#prevent-users-losing-unsaved-changes).

---
meta:
  title: "What happens when a user joins a room at maximum capacity?"
  description:
    "Learn what happens when a room reaches the maximum simultaneous connections
    per room"
---

Liveblocks allows you to gracefully handle maximum user limits in rooms. But
first, when is a room at maximum capacity?

- A room is full when itâ€™s hit your maximum simultaneous connections per room
  limit.
- Your maximum simultaneous connections limit is defined by your current
  [plan](/pricing).
- Any users above that count will not be able to join the room.
- Any users already in the room will not be affected by another user trying to
  join.
- If a user canâ€™t join a room, they will not be counted towards your MAUs.

## Example

For example, letâ€™s say your plan allows for 50 simultaneous connections. If
thereâ€™s a room that currently has 50 users inside, Marie (the 51st user) will
not be able to join the room. If Marie tries to join, the first 50 users in the
room will be unaffected, and the room will function as normal. However, Marieâ€™s
client will receive an error, which can be handled.

## Handling users that are over the count

No JavaScript `Error` is thrown when a user tries to join a room thatâ€™s full,
instead you can listen for error events, which are helpful for displaying a
warning or redirecting the user elsewhere.

### In React

With our
[`@liveblocks/react`](https://liveblocks.io/docs/api-reference/liveblocks-react)
package, you can listen for error events with
[`useErrorListener`](/docs/api-reference/liveblocks-react#useErrorListener).
When `error.context.code === 4005`, that means the room was full when the user
tried to join.

```tsx highlight="15-17"
import { useErrorListener } from "../liveblocks.config";

function App() {
  // Listen for errors
  useErrorListener((error) => {
    switch (error.context.code) {
      case -1:
        // Authentication error
        break;

      case 4001:
        // Could not connect because you don't have access to this room
        break;

      case 4005:
        // Could not connect because room was full
        break;

      default:
        // Unexpected error
        break;
    }
  });

  // ...
}
```

### In JavaScript

With our [`@liveblocks/client`](/docs/api-reference/liveblocks-client) package,
you can listen for error events with
[`room.subscribe("error")`](/docs/api-reference/liveblocks-client#Room.subscribe.error).
When `error.context.code === 4005`, that means the room was full when the user
tried to join.

```ts highlight="17-19"
// No error is thrown when the room is full
const { room, leave } = client.enterRoom("my-room", {
  /* ... */
});

// Listen for errors
const unsubscribe = room.subscribe("error", (error) => {
  switch (error.context.code) {
    case -1:
      // Authentication error
      break;

    case 4001:
      // Could not connect because you don't have access to this room
      break;

    case 4005:
      // Could not connect because room was full
      break;

    default:
      // Unexpected error
      break;
  }
});
```

---
meta:
  title: "What to check before enabling a new notification kind"
  description: "Checklist for changing notification kinds in the dashboard"
---

When publishing changes to your notification settings in the dashboard, you
should make sure your app is ready to handle any webhooks changes. This is not a
problem when _disabling_ a notification kind, but when you _enable_ a new
notification kind you should check that your app is ready to receive these new
notifications.

## Enabling in the dashboard

When in the notifications settings dashboard, you can enable and disable various
webhook events for different kinds. For example, below weâ€™ve toggled a custom
notification `kind`.

<Figure>
  <Image
    src="/assets/tutorials/webhooks/liveblocks-toggle-custom-notification.png"
    alt="Toggle a custom notification kind"
    width={712}
    height={445}
  />
</Figure>

Before publishing this change, itâ€™s important to understand what will occur, and
to modify your app.

## What happens when you enable a notification kind

After enabling and publishing a notification kind, a new webhook event will be
sent for that `kind` on the channel you selected. Below is an example of an API
endpoint set up for a Liveblocks webhookâ€”you can see the new event that will be
received if you were to enable a custom notification sent on the email channel.

<Banner title="Step-by-step guides">

If you donâ€™t recognise this code, you should read one of our guides on setting
up notification kinds with webhooks, where everything is explained:
[thread guide](/docs/guides/how-to-send-email-notifications-of-unread-comments)
and
[textMention guide](/docs/guides/how-to-send-email-notifications-for-unread-text-editor-mentions).

</Banner>

```ts
import { WebhookHandler } from "@liveblocks/node";

// Add your webhook secret key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_WEBHOOK_SECRET_KEY";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  if (event.type !== "notification") {
    return new Response("This is not a notification webhook", { status: 400 });
  }

  // {
  //   type: "notification",
  //   data: {
  // +++
  //     channel: "email",
  //     kind: "$myCustomNotification",
  // +++
  //     projectId: "my-project-id",
  //     roomId: "my-room-id",
  //     userId: "my-user-id",
  //     inboxNotificationId: "in_xt3p7ak...",
  //     createdAt: "2021-10-06T01:45:56.558Z",
  //   },
  // }
  console.log(event);

  return new Response(null, { status: 200 });
}
```

As you can see above, the two highlighted lines are the fields for the new
event, and youâ€™ll need to handle them.

## Before publishing the change

Before publishing your notification settings change, youâ€™ll most likely wish to
check for `channel` and `kind` in your webhook endpoint, and handle it
accordingly.

```ts
import { WebhookHandler } from "@liveblocks/node";

// Add your webhook secret key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_WEBHOOK_SECRET_KEY";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a real webhook request
  let event;
  try {
    event = webhookHandler.verifyRequest({
      headers: headers,
      rawBody: JSON.stringify(body),
    });
  } catch (err) {
    console.error(err);
    return new Response("Could not verify webhook call", { status: 400 });
  }

  if (event.type !== "notification") {
    return new Response("This is not a notification webhook", { status: 400 });
  }

  // +++
  if (
    event.data.channel === "email" &&
    event.data.kind === "$myCustomNotification"
  ) {
    // Send an email to your user for this custom notification
    // ...

    return new Response(null, { status: 200 });
  }
  // +++

  return new Response(null, { status: 200 });
}
```

If you donâ€™t handle this, you may find yourself running into problems, depending
on the way youâ€™ve written the logic in your app.

## Safe to publish

After changing your webhook endpoint, itâ€™s safe for you to go back to the
notification settings page, and publish your changes.

<Figure>
  <Image
    src="/assets/tutorials/webhooks/liveblocks-enable-custom-notification.png"
    alt="Enable a notification kind"
    width={712}
    height={445}
  />
</Figure>

Events for the new notification kind will now be called in your app.

## Users can change their preferences

Each user in your app can set their own preferences for notifications, and after
enabling a notification kind, each userâ€™s will be set to the default value.

<Figure>
  <Image
    src="/assets/tutorials/webhooks/liveblocks-default-enabled.png"
    alt="Default notification settings"
    width={768}
    height={480}
  />
</Figure>

You can use
[`useUpdateNotificationSettings`](/docs/api-reference/liveblocks-react#useUpdateNotificationSettings)
to view and set each userâ€™s individual values, making it easy to create
notification setting panels. Below, weâ€™re allowing users to toggle `thread`
notifications on the `email` channel.

```tsx
import { useNotificationSettings } from "@liveblocks/react";

function NotificationSettings() {
  // +++
  const [{ isLoading, error, settings }, updateSettings] =
    useNotificationSettings();
  // +++

  if (isLoading || error) {
    return null;
  }

  return (
    <form>
      <input
        type="checkbox"
        // +++
        checked={settings.email?.thread}
        onChange={(e) =>
          updateSettings({ email: { thread: e.target.checked } })
        }
        // +++
        id="setting-email-thread"
      />
      <label htmlFor="setting-email-thread">
        Receive thread notifications by email
      </label>
    </form>
  );
}
```

You can use this hook to create a full notification panel for each user. If
youâ€™re not on React, you can use
[JavaScript](/docs/api-reference/liveblocks-client#Client.getNotificationSettings)
or
[Node.js](/docs/api-reference/liveblocks-node#get-users-userId-notification-settings)
functions instead.

---
meta:
  title: "Why you canâ€™t delete Yjs documents"
  description:
    "Learn why Yjs documents canâ€™t be deleted and how tombstones, offline
    history, and CRDTs work"
---

When working with Yjs and Liveblocks, you might wonder why thereâ€™s no way to
delete a Yjs document without deleting the entire room. This isnâ€™t a
limitationâ€”itâ€™s a fundamental aspect of how Yjs works as a Conflict-free
Replicated Data Type (CRDT). Understanding this behavior is essential for
building robust collaborative applications.

<Banner title="Text editors">

This guide applies to our extensions for
[Tiptap](/docs/ready-made-features/multiplayer-editing/text-editor/tiptap),
[Lexical](/docs/ready-made-features/multiplayer-editing/text-editor/lexical),
[BlockNote](/docs/ready-made-features/multiplayer-editing/text-editor/blocknote),
as they all use Yjs under the hood.

</Banner>

## Yjs stores changes, not state

Unlike traditional databases that store the current state of your data, Yjs
stores a complete history of changes made to a document. When you make an edit
in a Yjs document, youâ€™re not replacing the old dataâ€”youâ€™re appending a new
change to the documentâ€™s history.

This approach is what enables Yjs to handle realtime collaboration so
effectively. When multiple users edit the same document simultaneously, Yjs can
merge their changes automatically without conflicts, even if theyâ€™re working
offline.

## The role of tombstones

When you "delete" content in a Yjs document, the data isnâ€™t actually removed.
Instead, Yjs creates a tombstoneâ€”a marker that indicates the content has been
deleted. These tombstones are crucial for maintaining consistency across all
users.

Tombstones serve several important purposes:

- **Conflict resolution**: If one user deletes content while another user is
  editing it offline, the tombstone helps Yjs resolve this conflict when they
  reconnect.
- **Causal ordering**: Tombstones maintain the causal relationship between
  operations, ensuring that edits are applied in the correct order.
- **Synchronization**: When a new user joins or an offline user reconnects,
  tombstones ensure they see the correct state of the document.

Without tombstones, Yjs wouldnâ€™t be able to guarantee that all users see the
same document state, especially in scenarios with offline editing or network
issues.

## Offline peers and history

One of Yjsâ€™s most powerful features is its ability to handle offline editing.
Users can continue working on a document even without an internet connection,
and their changes will sync automatically when they reconnect.

For this to work, Yjs needs to maintain the complete history of changes. When an
offline user reconnects, their client sends all the changes they made while
offline. The server then merges these changes with any updates from other users,
using the documentâ€™s history to resolve conflicts.

If you could delete parts of a documentâ€™s history, offline users wouldnâ€™t be
able to sync properly. Their changes might conflict with the "deleted" history,
leading to data loss or inconsistent states across different users.

## Why you canâ€™t delete Yjs documents

Given how Yjs works, thereâ€™s no safe way to delete a Yjs document without
potentially breaking synchronization for offline or slow-to-sync users. Hereâ€™s
why:

1. **Active sessions**: Users might have the document open and be making
   changes. Deleting the document would cause their changes to fail or create a
   new document unintentionally.

2. **Offline users**: Someone might be editing the document offline. When they
   reconnect, theyâ€™d try to sync changes to a document that no longer exists.

3. **Pending synchronization**: Changes might still be in transit across the
   network. Deleting the document could cause these changes to be lost or create
   inconsistencies.

4. **CRDT guarantees**: Yjsâ€™s conflict-free guarantees depend on having access
   to the complete history. Partial deletion would break these guarantees.

## What you can do instead

While you canâ€™t delete a Yjs document directly, you have several options:

### Delete the entire room

The only way to fully delete a Yjs document is to delete the room that contains
it. This ensures that all associated data is removed cleanly, and thereâ€™s no
risk of orphaned changes or synchronization issues.

```ts
import { Liveblocks } from "@liveblocks/node";

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

// Delete the room and all its data, including the Yjs document
await liveblocks.deleteRoom("my-room-id");
```

You can then create a new room and start afresh.

```ts
import { Liveblocks } from "@liveblocks/node";

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

// Create a new room
await liveblocks.createRoom("my-new-room-id", {
  defaultAccesses: ["room:write"],
});
```

When deleting a room, bear in mind that all data associated with it is removed,
including threads, Storage, and more.

### Clear the document content

If you want to â€œresetâ€ a document without deleting it, you can clear its Yjs
content by replacing it with an empty string, keeping the room. However this
doesnâ€™t actually delete the documentâ€™s historyâ€”it adds a new â€œdelete everythingâ€
operation, meaning the document data size has got larger instead of smaller.

```ts
import * as Y from "yjs";
import { Liveblocks } from "@liveblocks/node";

const liveblocks = new Liveblocks({
  secret: "{{SECRET_KEY}}",
});

// Get the current document
const update = await liveblocks.getYjsDocumentAsBinaryUpdate("my-room-id");
const yDoc = new Y.Doc();
Y.applyUpdate(yDoc, new Uint8Array(update));

// Clear the content (example with Y.Text)
const yText = yDoc.getText("content");
yText.delete(0, yText.length);

// Send the update back
const yUpdate = Y.encodeStateAsUpdate(yDoc);
await liveblocks.sendYjsBinaryUpdate("my-room-id", yUpdate);
```

## Learn more

For more information about working with Yjs and Liveblocks, check out these
guides:

- [Yjs best practices and tips](/docs/guides/yjs-best-practices-and-tips)
- [How to use your Y.Doc on the server](/docs/guides/how-to-use-your-ydoc-on-the-server)
- [Modifying Yjs document data with the REST API](/docs/guides/modifying-yjs-document-data-with-the-rest-api)
- [Data storage](/docs/platform/data-storage)

---
meta:
  title: "Yjs best practices and tips"
  description:
    "Learn best practices and common pitfalls to avoid when working with Yjs and
    Liveblocks"
---

This guide covers best practices and common pitfalls to avoid when working with
Yjs and Liveblocks.

## Avoid importing Yjs twice

One of the most common issues when working with Yjs is accidentally importing it
twice in your application. This often happens when mixing CommonJS (CJS) and
ECMAScript Modules (ESM), or when certain bundlers bundle more than one version
of Yjs.

When Yjs is imported twice, the two instances don't share the same class
references, which can lead to synchronization issues and unexpected behavior. You'll see a Yjs warning in the Console if this happens.

### Fixing duplicate Yjs imports

If you find duplicate Yjs imports, you can:

1. **Use package manager resolution**: Configure your package manager to resolve
   Yjs to a single version:

```json
// package.json (npm/yarn)
{
  "resolutions": {
    "yjs": "^13.6.0"
  }
}
```

```json
// package.json (pnpm)
{
  "pnpm": {
    "overrides": {
      "yjs": "^13.6.0"
    }
  }
}
```

2. **Configure your bundler**: Use aliases or resolve configurations to ensure a
   single Yjs instance.

## Avoid subdocuments when possible

While Liveblocks Yjs supports
[subdocuments](/guides/how-to-use-yjs-subdocuments), it's generally better to
avoid them unless you have a specific use case that requires them.

Subdocuments add complexity to your application and are only necessary when:

- You have multiple _very large_ Yjs documents in the same room
- You need to lazy-load documents individually

For most use cases, including **multiple text editors on the same page**,
subdocuments are not necessary. Instead, use a
[`Y.Map`](https://docs.yjs.dev/api/shared-types/y.map) to organize your data:

```tsx
// Create Yjs document with an `editors` map
const yDoc = new Y.Doc();
const yMap = yDoc.getMap("editors");

// Create shared types and add to map
const editorOne = new Y.XMLFragment();
const editorTwo = new Y.XMLFragment();
yMap.set("editor-1", editorOne);
yMap.set("editor-2", editorTwo);
```

This approach is simpler and performs better for most applications.

## Use getYjsProviderForRoom for better resilience

When working with React or other UI frameworks where re-renders are common, use
[`getYjsProviderForRoom`](/docs/api-reference/liveblocks-yjs#getYjsProviderForRoom) instead of creating a new provider on each render. This
ensures the provider is reused across renders, making your application more
resilient:

```tsx
import { useRoom } from "@liveblocks/react";
import { getYjsProviderForRoom } from "@liveblocks/yjs";

function App() {
  const room = useRoom();
  const yProvider = getYjsProviderForRoom(room);
  const yDoc = yProvider.getYDoc();

  // ...
}
```

This approach ensures that:

- The provider is properly reused across component re-renders
- Connection state is maintained even when the component updates
- Resources are properly cleaned up when the component unmounts

## Use YKeyValue for efficient key-value storage

In many cases, [`Y.Map`](https://docs.yjs.dev/api/shared-types/y.map) can be inefficient for key-value storage. Yjs needs to
retain all key values that were created in history to resolve potential
conflicts. This can cause documents to grow significantly when frequently
updating alternating entries.

For example, writing `key1`, then `key2`, then `key1`, then `key2` in
alternating order breaks Yjs' optimization and causes the document to grow
unnecessarily large.

### Recommended approach: YKeyValue

For more efficient key-value storage, use
[`YKeyValue`](https://github.com/yjs/y-utility?tab=readme-ov-file#ykeyvalue)
from the `y-utility` package:

```bash
npm install y-utility
```

```ts
import * as Y from "yjs";
import { YKeyValue } from "y-utility/y-keyvalue";

const ydoc = new Y.Doc();
const yarr = ydoc.getArray();
const ykv = new YKeyValue(yarr);

// Fires events similarly to Y.Map when content changes
ykv.on("change", (changes) => {
  console.log(changes);
});

ykv.set("key1", "val1");
ykv.set("key1", "updated");
ykv.delete("key1");
ykv.set("key1", "new val");
ykv.get("key1"); // => 'new val'
```

`YKeyValue` creates documents whose size only depends on the size of the map,
not the number of operations. This can reduce document size dramaticallyâ€”in
benchmarks, a document with 100k operations on 10 keys was reduced from **524KB
with `Y.Map`** to just **271 bytes with `YKeyValue`**.

## Enable experimental V2 encoding for Y.Maps

If you're using `Y.Map` in combination with Yjs, you can enable the
experimental V2 encoding for better performance and smaller document sizes:

```ts
import { useRoom } from "@liveblocks/react";
import { getYjsProviderForRoom } from "@liveblocks/yjs";

function App() {
  const room = useRoom();

  const yProvider = getYjsProviderForRoom(room, {
    // Enable V2 encoding for better performance with LiveMaps
    // +++
    useV2Encoding_experimental: true,
    // +++
  });
}
```

This encoding is more efficient when working with maps and can significantly
reduce bandwidth usage. Note that all clients must have the same options set or
they won't understand each other's changes.

