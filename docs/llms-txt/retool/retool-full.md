# Retool Documentation

> Complete product documentation for Retool.

This file contains all documentation content in a single document following the llmstxt.org standard.

## Agent-to-agent communication

The Agent-to-agent (A2A) protocol provides standardized and secure communication between external agents and agents built with Retool, so you can trigger your agent from an external agent, or embed agents in your own systems.

## Overview
A2A support allows you to build agents across multiple platforms and have them talk to one another programmatically. You may want to use A2A, for example, to build distributed AI systems across different regions, to connect third-party agents to internal orchestration agents, or to daisy-chain specialized agents together to complete complex tasks.    

:::info
Currently, Retool supports ingress into Retool agents from an external agent.
:::

Retool has implemented the [core set of A2A functionality](https://a2a-protocol.org/v0.2.0/topics/key-concepts/#fundamental-communication-elements), so you can: 
    - View an agent card.
    - Send a message.
    - Poll for updates on tasks.
    - Stream processing or task updates via Server-Sent Events (SSE). 
    - Cancel tasks. 

Refer to [Set up an A2A trigger](../guides/triggers/trigger-with-a2a.mdx) to learn how to enable the A2A trigger, and [A2A endpoints](../reference/a2a-endpoints.mdx) to learn how to cURL for endpoint responses. 

## How it works
The diagram below details the four main steps an A2A request follows, as well as the interactions between the client, the A2A server, and your agent. 

## Limitations
Retool's A2A support has the following limitations: 

- Retool only supports ingress for A2A. 
- Retool only supports the HTTP+REST and JSON-RPC protocols.
- Retool only supports API key-based authentication. 
- Retool does not support the [input-required](https://a2a-protocol.org/v0.2.0/specification/#93-multi-turn-interaction-input-required) or [auth-required](https://a2a-protocol.org/v0.2.0/specification/#63-taskstate-enum) task states, so when using A2A with Retool agents, calling tools that require approvals and have delegated authentication will fail. 
 
Additional functionality will be added over time. 

## FAQ

### How can I provide feedback on A2A? 
Please provide feedback at [this form link](https://example.retool.com/form/ddaf5f13-5d66-4aa8-868b-95dfc4edff61) or reply to the [Agent-to-agent protocol support topic](https://community.retool.com/t/agent-to-agent-protocol-support/62334) the Retool Community Forum. 

### Does enabling A2A expose all agents? 
No, Retool requires you to enable A2A as a trigger on a specific agent. Self-hosted Retool customers can toggle off the **AI Agents A2A** feature flag in **Settings** > **Beta** to remove A2A support; it is on by default. 

### Can I call Retool Agents from non-agent systems like external apps or backends?
Yes, A2A can be used by a programmatically-invoked REST API from non-agent systems. 

### Will Retool support additional transport protocols like gRPC?
Retool will support additional protocols depending on customer demand. If you'd like to request additional protocol support, [please fill out this form](https://example.retool.com/form/ddaf5f13-5d66-4aa8-868b-95dfc4edff61). 

### Does Retool A2A support streaming responses?
Yes, Retool supports streaming responses via SSE. 

### Can we connect to external A2A systems from Retool?
Yes, Retool supports ingress into Retool agents via the A2A protocol. You can build custom tools in agents, or custom resource queries in apps and workflows to trigger external agents via REST APIs.

### The URL value in my agent card is missing the HTTP or HTTPS prefix, how do I fix this?
For self-hosted Retool, set the [BASE_DOMAIN](../../self-hosted/reference/environment-variables/#property-BASE_DOMAIN.mdx) environment variable. 

### Can I rotate my API keys? 
Yes, API keys can be rotated. An API key is provided for each agent, and must be passed to the client via an `X-Api-Key` header.

## Additional resources
To continue learning about A2A, explore the following resources:

* [Set up an A2A trigger](../guides/triggers/trigger-with-a2a.mdx)
* [A2A tutorial](../tutorials/a2a-tutorial.mdx)
* [What is A2A Protocol?](https://a2a-protocol.org/dev/)
* [A2A endpoints](../reference/a2a-endpoints.mdx)

---

## Agentic workflows

import Shared from '/docs/_shared/_agentic-workflows.mdx';

---

## Retool Agents best practices

Retool recommends using the following best practices to create operationally efficient, cost-aware, performant, reliable, secure, and sustainable agents.

## Operational excellence
Best practices for operating Retool Agents effectively include implementation strategies, monitoring, and continuous improvement methodologies.

Test agents using the built-in [chat](../guides/chat-with-agent.mdx) interface, which uses the latest saved version, before deploying to users.

The agent logs provide run details including inputs, outputs, thoughts, and runtime information helpful for debugging tool and LLM calls.

Use [evals](./evals.mdx) for systematic testing of agent behavior after significant changes to instructions or tool descriptions, ensuring consistent performance and quality across scenarios.

Use the monitoring page to observe agents in production, providing visibility into runs, errors, tool calls, token usage, cost, runtime and more.

## Cost optimization
Best practices on managing and optimizing costs associated with Retool Agents include resource allocation, usage patterns, and budgeting considerations.

Clear [instructions](#instruction-guidance) allow the agent to optimally choose tools and iterate the fewest number of times, reducing total runtime and associated costs.

Clear, short, specific tool descriptions allow the agent to optimally select its execution path, reducing unnecessary tool calls and iterations.

Consider the total size of responses from your tool calls. Returning large amounts of data results in token-inefficient LLM calls, so wherever possible, minimize the data returned from tools.

Select the fastest model that can effectively solve your particular problem to minimize total runtime and associated costs.

## Performance
Best practices for performance include strategies and techniques to maximize the performance of Retool Agents, including response-time optimization, and throughput considerations.

Connect only the necessary [tools](../guides/tools) to each agent.

Set clear timeout thresholds for each tool to prevent long-running tool calls from degrading overall agent responsiveness.

### Instruction guidance

In general, Retool Agents perform best when they have a set of well-written instructions. Use the following best practices to create instructions with Retool Agents:

* **Explicitly state the agent's purpose**: Clearly specify the agent's role and goals upfront to ensure alignment.

  
  ```You are a data analyst agent tasked with identifying anomalies in daily sales data.```
  

* **Break down tasks clearly**: Provide step-by-step guidance to simplify complex instructions into manageable steps.

  
  ```
  1. Pull sales data from the provided database.
  2. Calculate the weekly average sales figures.
  3. Identify any days with sales deviations greater than ±15% from the weekly average.
  ```
  

* **Be precise**: Explicitly state validation rules and decision-making criteria. Include relevant context directly in each instruction; avoid relying on prior prompts or implicit context.

  
  ```All phone numbers must contain exactly 10 digits. If a provided number doesn't meet this criterion, flag it and request correction.```
  

* **Include explicit error handling guidance**: Clearly state how the agent should handle errors, edge cases, or unexpected scenarios.
  
  ```If data retrieval fails due to an API error, notify the administrator immediately with the specific error message and retry once after 5 minutes.```
  

* **Provide information about the user and context**: Provide the agent with dynamic information about the [current_user](../reference/current-user.mdx), date, and time zone using embedded expressions. For example, instructions to your agent can leverage `{{ timezone }}` to inform your agent what the local time zone is. This embedded expression evaluates to the [IANA time zone name](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Temporal/ZonedDateTime#time_zones_and_offsets).
  
  ```You are a helpful assistant chatting with {{ current_user.name }}. Today is {{ new Date() }} in the {{ timezone }} time zone.```
  

Refer to the [Configuration](../quickstart.mdx#configuration) section of the Quickstart guide for additional instruction guidance.

#### Example instructions
You can use the following examples as templates when creating instructions for Retool Agents.

  

```
You are a data analysis assistant. When analyzing the provided dataset:
1. First identify the key metrics present
2. Calculate relevant statistical measures
3. Present insights in bullet points
4. If you spot any anomalies, highlight them separately
```

  
  

```
You are helping with Retool app debugging. Given the error message:
- First identify the component type involved
- Check for common configuration issues
- Suggest specific fixes
- Provide example code if relevant
Only use features available in the current Retool version.
```

  
 

```
Act as a SQL query optimizer. For any query provided:
1. Analyze the query structure
2. Identify potential performance bottlenecks
3. Suggest specific optimizations
4. Explain the reasoning behind each suggestion
```

  

#### Common issues with instructions
The following table provides some common pitfalls or issues you may encounter when crafting instructions for agents, as well as do's and don'ts for instruction writing.

| Issue                                    | Do                                                                                                      | Don't                                                                            |
| -----------------------------------------| ------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------|
| Vague or ambiguous instructions          | Write specific, clear instructions, that include numbers or percentages if necessary.                       | Write vague or short instructions that don't provide enough context for the model.                                  |
| Providing too much information           | Provide only the context directly relevant to the current task.                                            | Include unnecessary historical context or irrelevant details.                  |
| Lack of error handling guidance          | Point out what the agent should do if it encounters missing data or errors when running.  | Fail to specify how to handle edge cases or errors.           |
| Inconsistent output requirements         | Clearly define output format upfront and maintain consistency.                                          | Fail to specify response format or change format requirements mid-conversation. |
| Assuming prior context                   | Include necessary context in each instruction, even if briefly.                                                 | Refer to information from previous conversations without restating it.       |
| Imprecise tool usage                     | Specify which tool to use for certain tasks.      | Fail to specify which tools the agent should use for specific tasks.             |
| Missing validation requirements          | Include specific validation criteria and acceptable ranges or values.                                         | Fail to specify what makes a response acceptable.                                 |
| Unclear priority order                   | Clearly define the steps an agent should take, and in what order (first, second, third, etc.).                | Fail to specify the order of operations for multiple tasks.                       |
| Lack of response size guidelines         | Specify the amount of bullet points or words an agent should provide in a summary.                        | Fail to specify the desired level of detail or response length                       |

## Reliability

Best practices to ensure the reliability of Retool Agents include error handling, failover mechanisms, and continuous availability strategies.

Implement proper error handling in custom tools and agent instructions, returning errors that the LLM can understand to recover from failure situations.

Use [evals](./evals.mdx) and [chat](../guides/chat-with-agent.mdx) to test agents thoroughly across different scenarios to help reduce failures and errors.

Monitor total runtime and individual agent runs from the Monitor page.

Include thorough descriptions of what was changed and whether the change was major, minor, or a patch.

## Security
Best practices for security considerations when implementing and using Retool Agents include data protection, access controls, and compliance requirements.

Apply the principle of least access when [permissioning agents](../../permissions/guides/agent-permissions.mdx), which follow the same permission model as apps and workflows. Use role-based access control for agent management.

Carefully consider what data you expose through tools, as agents have full access to any data accessible via their connected tools. Use OAuth to authenticate tools where possible so that user data access is scoped to their permissions. Limit access to only what's necessary for the agent's function.

Implement role-based permissions across Retool to ensure that agent builders do not accidentally use resources they should not have access to.

## Sustainability
Best practices on sustainable usage patterns for Retool Agents focus on resource efficiency and environmental impact considerations.

Design prompts, instructions, and tool responses to minimize token consumption by using concise language and limiting data transfer to only what's necessary.

Cache responses when appropriate, use streaming for long-running processes, and implement rate limiting to prevent resource overuse during peak periods.

Schedule periodic reviews of agent usage patterns and resource consumption to identify and address inefficiencies in your implementation.

---

## Evals in Retool Agents

Evals are systematic tests to assess large language models (LLMs) and agents on tasks like reasoning, accuracy, or safety. They use benchmarks or real-world scenarios to ensure models produce reliable, coherent, and ethical outputs.

When running an eval, Retool provides an input to the LLM. A [reviewer](#reviewer) scores the LLM output (0 to 1). Sometimes there are clear expected outputs (for example, [programmatic reviewers](#programmatic) like exact match), and sometimes expected outputs are less clear (for example, [LLM as a judge](#llm-as-a-judge) reviewers like tone detection).

:::info
Eval runs count towards billable agent runtime. For more information about billing, refer to the [Billing and usage](/support/billing-usage/agents) page.
:::

By tracking and scoring the results of your evals, you can test agents to determine if you've introduced breaking changes to an agent, you've improved the agent’s behavior, or if the agent is working as expected.

## Evals tab
import SharedEvals from '/docs/_shared/_agent-evals.mdx';

## Reviewers

*Reviewers* score the correctness of the agent's output, and provide an explanation for the score. During the Eval run, a reviewer accepts the output from the LLM, parameters that vary based on the reviewer type selected, and returns a score beetween 0 and 1.

Retool provides *Programmatic* and *LLM as a Judge* preconfigured reviewers you can use to help evaluate your agent.

### Programmatic

Programmatic reviewers use code to score output based on predefined rules. Use programmatic reviewers when you can clearly define the agent's expected output.

| Reviewer name               | Description                                                                                                                                           | Parameters                                                                                       |
| ----------------------------| ----------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------|
| **Exact match**             | Determines whether two values are the same.                                                                                                           | None                                                                                             |
| **Valid JSON**              | Evaluates the validity of the JSON output.                                                                                                            | None                                                                                             |
| **Valid XML**               | Evaluates the validity of the XML output.                                                                                                             | None                                                                                             |
| **String contains**         | Determines whether a string contains a certain value.                                                                                                 | `searchString` - the search string to look up  `ignoreCase` - ignore capitalization.       |
| **JSON Schema match**       | Determines whether the output of the agent is valid JSON conforming to the schema you specify.                                                        | `JSON Schema` - the format of your JSON schema.                                                  |
| **Levenshtein**            | A similarity score based on the Levenshtein distance between two strings with the formula `1 - (lev / length of longer string) = similarity score`. For example, the distance between `Hello World` and `hello borld` is `1` and the output of the reviewer is `0.91` | None                                                                                             |

### LLM-as-a-judge

LLM-as-a-judge reviewers use an LLM to determine the agent's score based on what you define in the input **Prompt** and **Choice score** between 0 and 1. Use LLM as a Judge reviewers when the agent's expected output is not clearly defined.

| Reviewer name               | Description                                                                                                  | Parameters                              |
| ----------------------------| ------------------------------------------------------------------------------------------------------------ |-----------------------------------------|
| **Tone detection**          | Evaluates the tone of an agent's output based on the user input prompt.                                      | `Prompt`  `Choice Scores`         |
| **Factuality**              | Evaluates whether an output is factual.                                                                      | `Prompt`  `Choice Scores`         |
| **Closed QA**               | Evaluates whether an output answers the input.                                                               | `Prompt`  `Choice Scores`         |

---

## Agents FAQ

This FAQ aims to provide answers to common questions about Agents, and provide you with the information you need to leverage Agents effectively.

## General
Frequently asked general questions about Agents:

Please share feedback in Retool’s [community forum](https://community.retool.com/t/launch-day-retool-agents-is-here/58551).

Reach out to your Enterprise account manager or [contact Retool support](/support).

The following links provide more information about AI and Agents.

- [AI Fundamentals YouTube playlist](https://www.youtube.com/playlist?list=PLqWdQFDVLADmJG9eNFIxe-d6yn227hQ_m)
- [Getting Started with AI in Retool YouTube playlist](https://www.youtube.com/playlist?list=PLqWdQFDVLADlN36WdDyPy5_fl0N2M0NZg)
- [Community forum](https://community.retool.com/t/launch-day-retool-agents-is-here/58551)
- [Builder Talks](https://community.retool.com/t/builder-talks-2-exploring-ai-with-kent-matei/58250)
- [Retool University](https://university.retool.com/p/login) links:
  - [Retool Intro to GenAI](https://university.retool.com/app/portal/courses)
  - [AI Agent Concepts](https://university.retool.com/app/portal/courses)
  - [AI Fundamentals Path](https://university.retool.com/app/portal/courses)
  - [Agents](https://university.retool.com/app/portal/courses)
  - [Lab: Retool Vectors](https://university.retool.com/app/portal/labs)
  - [Lab: AI Action](https://university.retool.com/app/portal/labs)
  - [Lab: Agents](https://university.retool.com/app/portal/labs)

## Data collection and privacy
Frequently asked questions about data collection and how information is used with Agents:

No, Retool uses foundation models. Neither Retool nor the providers of the third-party models will use agent inputs or outputs to train or fine-tune models. Prior to making a third-party model available for use with Agents, Retool ensures contractual safeguards are in place that restrict such providers from using inputs and outputs for their own purposes.

Retool engages other vendors to help provide agents. Vendors that process agent inputs and outputs on Retool’s behalf are [Retool’s sub-processors](/legal/subprocessors) and are also contractually restricted from using inputs and outputs for their own purposes.

No, Retool-managed, open-source models are hosted by Retool’s third-party infrastructure provider. Inputs and outputs will not be shared with the provider of the open-source model.

The data sent to the Retool-managed (cloud-hosted) agents observability API consists of the following:

- UUIDs corresponding to objects in the Retool deployment's Postgres database.
- Success/failure status of agent runs.
- Model type of agent runs.
- Runtime of agent runs.
- Number of LLM tokens used by agent runs.
- Information about the tools used during agent runs. Tool information is limited to UUIDs and the configured tool name and tool parameter names.

No customer data beyond the names of configured tools and tool parameters are sent to this API.

If you have any feedback or concerns about this data, please reach out to your account team.

## AI models and LLM keys
Frequently asked questions about AI models and LLM-provider keys:

Retool-managed keys are available for certain [AI providers and models](../../data-sources/concepts/models). If you use Agents with any of these third-party models, the third-party model will process all agent inputs, including the prompt provided by the internal user of the agent, to initiate performance of a task or to generate output. Please review and comply with any policies published by the provider of the third-party model.

Yes. When you bring your own key to an account with a model provider, the provider’s handling of data while under its control will be governed by the agreement you have with that provider. When output data that is returned by the provider is in Retool’s control, such data will be subject to your agreement with Retool.

## Self-hosted
Frequently asked questions about self-hosted deployments and Agents:

import PY1 from '/docs/_partials/_agent-docker-compose-yaml.mdx';

import PY2 from '/docs/_partials/_agent-evals-self-hosted.mdx';

No agent inputs or outputs are sent back to Retool servers.

Agents is in public beta with the [3.234.0 edge release](../../../releases/edge/) and the [3.253.0 stable release](../../../releases/stable/) for Self-hosted organizations.

---

## Retool Agents overview

Retool Agents is a product that makes it simple for builders to automate work using large-language models (LLMs) by creating *agents*. An agent is a system that can complete or delegate tasks based on LLM reasoning. You can invoke agents using chat and email, evaluate agent performance, and even call them directly from apps and workflows.

## Agent process

Agents call [tools](./tools.mdx)—for example, workflows, functions, or other agents—to gather information and complete or delegate actions. When invoked, an agent:

1. Receives a *task*, or input, as natural language. Tasks are provided as input to agents via written instructions.
2. Uses an LLM to decide whether to respond to the input, get more information, or take action in another system.
3. Provides the result of the tool call back to the LLM, and the LLM reasons in an open-ended cycle called an *agentic loop* without a pre-defined stopping point.

Agentic loop steps can occur up to the maximum number of iterations specified in Retool Agents. A *run* is a single agentic loop defined by the agent, its input, and its output.

An agent acts according to the instructions it is provided. The LLM can only make two decisions: to continue calling tools, or to provide a final answer. It can call an LLM, execute tool calls, and provide the data from the tool calls back to the LLM in a loop until the LLM decides the task provided is complete.

## Invoke an agent {#invoke}

import Invoke from '../../_partials/_invoke-agents.mdx';

## Agent architecture

The architecture of an agent consists of:
* **Orchestration layer**: Manages memory, state, reasoning, and planning.
* **Model**: The LLM that the agent utilizes.
* **Tools**: Bundled capabilities that allow an agent to perform an action (e.g., access an API, a website, etc).

Agents use frameworks like *ReAct* (Reasoning and Acting) to alternate between thinking and taking action.

## When to use agents
Agents work well for open-ended, dynamic tasks, but they are not optimal for well-structured tasks that can be encoded into discrete steps. For well-structured tasks, it may be more beneficial to use agentic workflows. The following diagram is a visual representation of the different types of GenAI and Agentic workflows that can be built using Retool Workflows, vs. the flow of a Retool Agent.

For more information about the differences between agents and agentic workflows, refer to the [Agentic Workflows](../concepts/agentic-workflows) conceptual guide.

## Why Retool Agents
Retool Agents gives builders a central place to create, test, deploy, and monitor AI agents.

Some of the key features that Retool Agents provides are:

* **Intuitive agent-building experience:**
    * Form-based UI for agent configuration.
    * Built-in chat experience.
    * Integration with existing Retool components.
* **Thoughtful tool functionality:**
    * A set of **Core tools** for out-of-the-box functionality to get your agents up and running faster (Retool Email, Retool Storage, Web Search, Code Execution, etc.).
    * Ability to create custom tools.
    * Natural language tool generation with the **Config Assistant** and **Function Generator**.
    * Ability to connect to an MCP server to pull in third-party tools.
* **An evaluation framework:**
    * Ability to test against datasets.
    * Multiple included reviewer types (exact match, LLM as judge, etc.).
    * Ability to score agent runs with an eval.
    * Ability to compare two runs side-by-side.
* **Monitoring and observability:**
    * Visibility into agent runs, token usage, and cost.
    * Visualization of agent behavior.
* **A Human-in-the-Loop (HITL) component:**
    * Consent mechanisms for tool execution.
    * Chat to test.
    * Version history and change tracking.

## Additional resources
To continue learning about agents, refer to the following resources for more information.

* [Retool Agents](https://retool.com/agents)
* [Retool Agents Pricing](../../../data-sources/concepts/models#available-platforms-and-models)
* [Retool Agents FAQ](../concepts/faq)

---

## Tools for Retool Agents

A tool is a logical block that an agent can use to complete an action, like fetching data. Each Retool Agent has at least one tool, or more commonly a set of tools, at its disposal that it can use as it runs. The agent determines which tools to use, and in what order to call them. Within Retool Agents, a tool can be a function, a workflow, or another agent.

## Add Tools
import SharedTools from '/docs/_shared/_agent-tools.mdx';

Retool Agents offers the following core tools:

| Tool name                     | Description                                                                                                                                                                                                                                                                                                         |
| ----------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Send Email**                | Send an email using Retool Email.                                                                                                                                                                                                                                                                                  |
| **Execute Code**              | Execute an arbitrary JavaScript or Python script. Cannot include custom libraries.                                                                                                                                                                                                                                  |
| **Get Calendar Events**       | Retrieve a list of calendar events from a specified user's Google Calendar.                                                                                                                                                                                                                                         |
| **Create Calendar Event**     | Create a new event on a user's Google Calendar.                                                                                                                                                                                                                                                                     |
| **Delete Calendar Event**     | Delete an existing event from a user's Google Calendar.                                                                                                                                                                                                                                                             |
| **Get Open Time Slots**       | Query one or more Google Calendars to find available time slots between a given time range.                                                                                                                                                                                                                         |
| **Update Calendar Event**     | Update an existing event on a user's Google Calendar. Any provided values will fully replace the existing values for those fields.                                                                                                                                                                                  |
| **Invite to Calendar Event**  | Add one or more attendees to an existing Google Calendar event.                                                                                                                                                                                                                                                     |
| **Create Google Doc**         | Create a new, empty Google Doc with a specified title.                                                                                                                                                                                                                                                              |
| **Get Google Doc**            | Retrieve the full structure and metadata of a Google Doc by its document ID.                                                                                                                                                                                                                                        |
| **Update Google Doc**         | Applies changes to an existing Google Doc using the Google Docs `batchUpdate` API. Supply the unique document ID and a JSON object or array describing the desired updates (insert text, apply styles, add images, etc.). The final state of the document is returned as determined by the provided update requests.|
| **Search Google Docs**        | Retrieve a list of files from the user's Google Drive, optionally filtered or paginated.                                                                                                                                                                                                                            |
| **Create Slides Deck**        | Creates a new Google Slides deck.                                                                                                                                                                                                                                                                                   |
| **Update Slides Deck**        | Updates a Google Slides deck by editing text, bullet points, or replacing media.                                                                                                                                                                                                                                    |
| **Get Slides Deck**           | Retrieves a Google Slides deck from the deck ID and provides metadata such as the title, owner, created and updated times, and the URL.                                                                                                                                                                             |
| **Search Slides Deck**        | Retrieves a list of Google Slides via keyword or filter.                                                                                                                                                                                                                                                            |
| **Share Slides Deck**         | Update the sharing settings a Google Slides deck (make public, change permission roles, or invite collaborators).                                                                                                                                                                                                   |
| **Get File Contents**         | Retrieve the contents of a file by its ID and return the data as a Base64-encoded string.                                                                                                                                                                                                                           |
| **Upload File**               | Upload a file to Retool Storage.                                                                                                                                                                                                                                                                                    |
| **Get File Metadata**         | Retrieve a paginated list of file metadata from Retool Storage.                                                                                                                                                                                                                                                     |
| **Rename File**               | Rename an existing file in Retool Storage.                                                                                                                                                                                                                                                                          |
| **Move File**                 | Move a file to a different folder in Retool Storage.                                                                                                                                                                                                                                                                |
| **Set File Public Access**    | Update the public accessibility of a file in Retool Storage.                                                                                                                                                                                                                                                        |
| **List Folders**              | Retrieve a paginated list of folders from Retool Storage.                                                                                                                                                                                                                                                           |
| **Create Folder**             | Create a new folder in Retool Storage.                                                                                                                                                                                                                                                                              |
| **Rename Folder**             | Rename an existing folder in Retool Storage.                                                                                                                                                                                                                                                                        |
| **Delete Folder**             | Delete a folder from Retool Storage.                                                                                                                                                                                                                                                                                |
| **List Vectors**              | Retrieve a list of vector namespaces from the Retool Vectors resource.                                                                                                                                                                                                                                              |
| **Semantic Search**           | Search for semantically similar records in a specified vector namespace using a natural language query.                                                                                                                                                                                                             |
| **Get Document Chunks**       | Retrieve the individual chunks of a document stored in a document vector namespace.                                                                                                                                                                                                                                 |
| **List URLS**                 | Retrieve a list of indexed URLs stored in a document vector namespace.                                                                                                                                                                                                                                              |
| **Get URL Chunks**            | Retrieve the individual content chunks of an indexed URL stored in a document vector namespace.                                                                                                                                                                                                                     |
| **List Documents**            | Retrieve a list of documents stored in a document vector namespace.                                                                                                                                                                                                                                                 |
| **Search Web**                | Perform a web search and retrieve a list of relevant results based on a natural language query.                                                                                                                                                                                                                     |
| **Get Webpage Content**       | Fetch the contents of a webpage and extract the main text content for analysis or processing.                                                                                                                                                                                                                       |

---

## Retool Agents concept guides



---

## Retool Agents chat

After you configure an agent, you can chat with it to test how it behaves with different inputs. You can use what you learn from your chat threads to make any necessary modifications to the agent configuration or tools. Retool recommends chatting with your agent before deploying changes to make sure the agent behaves how you expect.

:::note
An agent's chat message history is only available to the user that created the chat threads.
:::

## Agent chats
To create a new chat message, select **+ New chat** from the **Chats** tab, enter your message, and watch the agent run. The agent displays *tool chips* in the message thread that detail information about the success or failure of tools.

export function ArcadeEmbed() {
  return (
    
      
    
  )
}

If a tool requires authentication, click **Authenticate** in the **Chats** tab. Follow the prompts to **Authenticate** and **Approve** the tool. 

 Tool authentication required.

To stop an agent chat, click the **Stop** button within the agent's message window. If the agent already started using a tool, in-progress tools may continue running, but no new tasks (i.e. tools or LLM calls) will be scheduled, and the chat thread will cease to populate.

export function StopChat() {
  return (
    
      
    
  )
}

### Current tool panel
As your agent thinks, it displays the current tool it's calling in the message thread, as well as in the panel to the right of the thread. You can show or hide the tool panel depending on your view preference.

export function ArcadeEmbed_hide() {
  return (
    
      
    
  )
}

## Rename a thread
Each new chat thread is automatically named based on the message you input. To rename a chat thread, click on the **...** next to the thread name, and select **Rename thread** from the dropdown.

export function ArcadeEmbed_rename() {
  return (
    
      
    
  )
}

## Add to evals dataset

You can create a test case directly from a chat thread and add it to a previously-created dataset for [evals](../concepts/evals). Select the **...** button at the end of an agent chat thread, and click **+ Add to Eval dataset**. Fill in the required fields on the **Create Test Case** modal, and click **Create**.

export function ArcadeEmbed_eval() {
  return (
    
      
    
  )
}

## Share a thread

import Partials from '/docs/_partials/_agent-share-thread.mdx';

---

## Automatically configure an agent with the Configuration Assistant

You can use the **Configuration Assistant** to automatically write **Instructions** and create **Tools** for your agent. The **Configuration Assistant** is an LLM with knowledge of how agents works and the ability to configure them. You can choose which [AI model](/data-sources/concepts/models) you want the **Configuration Assistant** to use.

:::note

Using the **Configuration Assistant** on an agent with existing instructions or tools overwrites the existing instructions and adds new tools to the list.

:::

Use the following steps to prompt the **Configuration Assistant** to create a vacation planning agent:

1. Create a new agent or navigate to an existing agent. Open the **Configuration** tab.
2. Optionally, configure which AI model you want to use. Enter your prompt in the **Message Configuration Assistant** message field. For example:
  ```
  Create a vacation planner. When given dates, find the best place to go based on the weather that time of year. Search the internet for suggested things to do and places to stay. Email me an itinerary, and put the PTO on my calendar.
  ```
1. After the **Configuration Assistant** thinks, click **Accept** or **Reject** to respond to the proposed plan.
2. Most tools require additional configuration.
   1. Click **Select resource** on [core tools](../tools/use-core-tools) to configure it to access a particular resource. Create a new resource, or select from your existing ones.
   2. Select **Finish up** on custom [custom tools](../tools/create-custom-tools) to create the tool's function logic. You can use the **Function Generator** to provide your function with instructions

export function ArcadeEmbed() {
  return (
    
      
    
  )
}

---

## Configure Agents

import DocCardList from "@theme/DocCardList";

---

## Configure your organization for Agents

import SelfhostedLatest from "@site/src/components/SelfhostedLatest"

An organization admin must complete the steps in the following sections to make sure your organization is ready to use Agents.

:::note

To learn how to create and use agents, visit the [Agents quickstart](../../quickstart.mdx) or the [Agents tutorials](../../tutorials.mdx).

:::

## Configure organization settings

Ensure that Agents is enabled and that it has access to the proper AI models.

1. To ensure your users can access Agents, navigate to **Settings** > **AI**. Verify that the **Retool AI** and **AI Agents** settings are toggled on.
2. Navigate to **Resources** > **Retool AI**. Ensure that at least one AI provider is enabled. You can choose to use Retool-managed keys or self-managed keys.

:::note
Only AI models that support tool creation can be used with Agents. Refer to [AI providers and models](../../../data-sources/concepts/models.mdx) for supported models.
:::

## Self-hosted configuration

Complete the steps in the following sections if your deployment is self-hosted. Skip these steps if you use Retool cloud.

### Requirements

To use Agents on Self-hosted deployments, your organization must:

- Be on Self-hosted Retool version 3.234.0 or later (3.253.0 or later for stable releases).
- Have its own AI model key(s) configured.
- Meet all of the requirements outlined in the [tutorial](../../../self-hosted/tutorials.mdx) for your chosen deployment infrastructure.

### Installation

Agents is supported for the following self-hosted deployment options.

Follow the instructions outlined in the [AWS Fargate and ECS](../../../self-hosted/tutorials/ecs-fargate/cloudformation.mdx) tutorial.

Follow the instructions outlined in the tutorial corresponding to your deployment infrastructure:

- [Amazon EC2](../../../self-hosted/tutorials/ec2.mdx)
- [Azure Virtual Machines](../../../self-hosted/tutorials/azure-vm.mdx)
- [Docker](../../../self-hosted/tutorials/docker.mdx)
- [Google Compute Engine](../../../self-hosted/tutorials/gcp.mdx)

To deploy a Self-hosted Retool instance that contains agents, use the [Retool Helm chart 6.6.0](../../../self-hosted/tutorials/kubernetes/helm#1-add-the-retool-helm-chart-repository) or later.

Configure the `values.yaml` file as follows:

1. In the `image.tag` for the `tryretool/backend` and `tryretool/code-executor-service`, specify the [Docker tag](https://hub.docker.com/r/tryretool/backend/tags) for the version of Retool to install, such as tryretool/backend:.
    :::important
    Agents is available on self-hosted Retool version `3.253.0-stable` or later.
    :::

2. Set agents to `enabled: true`.

For further configuration, you can reference the full `agents:` block as defined in [retool-helm](https://github.com/tryretool/retool-helm/blob/main/values.yaml).

### Additional configuration

Agents on self-hosted deployments rely on [Temporal](../../../self-hosted/concepts/temporal). To deploy agents, you must create two additional [containers](../../../self-hosted/concepts/architecture#containers-and-services) with configuration and networking egress identical to the [workflows-worker](../../../self-hosted/concepts/architecture#workflows-worker) container:

| Container | SERVICE_TYPE Environment Variable [^env] | Networks | Dependencies | Restart Policy |
|-----------|----------------|----------|--------------|----------------|
| `agent-worker` | `WORKFLOW_TEMPORAL_WORKER` | `backend`, `code-executor` | `postgres` | `always` |
| `agent-eval-worker` | `AGENT_EVAL_TEMPORAL_WORKER` |`backend`, `code-executor` | `postgres` | `always` |

[^env]: For a complete list of Agents-related environment variables, refer to the [Environment variables reference](../../../self-hosted/reference/environment-variables/index.mdx).

import PY1 from '/docs/_partials/_agent-docker-compose-yaml.mdx';

### Set up evals 
import PY2 from '/docs/_partials/_agent-evals-self-hosted.mdx';

### Configure AI providers

After installation, navigate to `/resources/retool_ai` and configure one or more AI model providers.

## Choose a change management strategy

Agents can be versioned and protected using Retool's change management features:

- **Source Control**: Organizations on the Enterprise plan can use Source Control to [protect agents](../../../source-control/guides/protect/agents.mdx) and manage changes through Git workflows. Consider creating feature branches when making significant changes to agents.
- **Version History**: All changes to agents are automatically tracked in version history, allowing you to review and restore previous versions.

## Track usage

Organization admins can monitor Agents usage and costs.

### Monitor agent runs

Use the [Monitor](../../quickstart.mdx#monitor) dashboard to track:

- Agent run success or failure rates
- LLM token usage
- Runtime performance
- Tool invocations

### Billing and usage limits

Retool organizations receive up to $50 worth of agent runtime per month. For Self-hosted deployments using self-managed LLMs, this equals 10 hours of free usage per month at $5/hour.

If you exceed the cap, agents will not execute and you'll see a warning message. Contact your account team to discuss additional capacity.

For more information about pricing, refer to the [Model pricing](../../../data-sources/concepts/models.mdx#model-usage-and-pricing) and the [Agents billing and usage](../../../../support/billing-usage/agents) pages.

## Next steps

Once configuration is complete:

1. Create your first agent using the [Agents tutorial](../../../agents/tutorials/agents-tutorial) page.
2. Configure agent [tools](../tools/index.mdx) to connect to your data sources.
3. Set up [permissions](../../../permissions/guides/agent-permissions.mdx) to control who can create and use agents.
4. (Optional) Configure [email triggers](../triggers/trigger-with-email/) or [A2A triggers](../../concepts/a2a.mdx) for automated agent invocation.
5. For answers to common questions about Agents, review the [Agents FAQ](../../concepts/faq.mdx).

---

## Create an agent from a template

Retool Agents offers several pre-defined templates to help you create agents quickly for certain use-cases. 

To create an agent from a template, select **Templates** or **+ New Agent** in the left navigation bar, or select the **+ Agent** button to open the **Create agent** modal that contains the list of templates. 

export function ArcadeEmbed() {
  return (
    
      
    
  )
}

Once you create an agent from template, use the following steps to configure your tools:  

1. Some tools require configuration to connect a [resource](../../../data-sources/tutorials/create-resource#create-a-new-resource) (e.g., Google Docs, or Web Search). Click **Select Resource**.  
2. Use the dropdown to add a new resource or select a previously-created resource.  
3. Optionally select **Apply to all tools that need this type of resource** to apply the selected resource to all tools of the same type within the agent.  
4. Optionally select **Require user confirmation before use**, which prompts users for approval when the tool is triggered. For more information, refer to [User consent handling](../../permissions/guides/agent-permissions.mdx#user-consent-handling).  
5. Click **Save**.  

Certain templates that require [custom tools](./tools/create-custom-tools) are pre-populated with mock data (shown in the example screenshot below). You can [edit the function](./tools/create-custom-tools#edit-function) to update the data it pulls in, and modify it to fit your own business needs. 

  The Competition Scanner template showing mock competitor data from Retool Database.

---

## Run evals and compare them side-by-side

Evals allow you to:
* Test your agent's effectiveness and accuracy.
* Experiment with the output that different models provide.
* Compare two eval runs side-by-side.

For more information about evals, refer to the [Evals](../../concepts/evals) conceptual guide. 

After you've created a datset and test cases, you can create and run an eval. Running an eval of your dataset produces an **Avg score** based on whether the test cases in the dataset passed or failed. 

:::info
Eval runs count towards billable agent runtime. For more information about billing, refer to the [Billing and usage](/support/billing-usage/agents) page.
:::

## Run an eval
To run an eval of your dataset items, from a test case, use the breadcrumbs to go back to the **Datasets** tab. 

From the agent: 

1. Click the **Evals** tab. 
2. Click the **Run** button. 
3. Give the run a **Name**, check the box next to your dataset name, and click **Run eval**. 
4. When the status changes to **Completed**, your eval will produce an **Avg score**. 
5. Click on the run to view the logs for each test case. Clicking on each line item opens the **Test Case Details** panel. 

export function ArcadeEmbed_RE() {
  return (
    
      
    
  )
}

Hovering over the **Score** displays the rationale for a success or failure. In the case of a failed run, navigate back to the test case to examine or correct the expected output. 

## Compare evals
You can compare two runs side-by-side. 

1. On the **Evals** tab, check the box next to two runs and select **Compare**. 
2. If **Eval A** and **Eval B** look correct on the **Compare evals** modal, select **Compare** again. 
3. The run details are shown in side-by-side panels so you can more easily identify failures.  

export function ArcadeEmbed() {
  return (
    
      
    
  )
}

If you have done multiple eval runs, you can select other runs from the dropdowns at the top of the **Compare** page to change the information displayed.

---

## Create datasets to evaluate agent performance

Before you create an eval, you first need to add a dataset. A dataset is a collection of test cases. An agent can have many datasets, and each dataset can have many test cases. It may be beneficial to group test cases into datasets based on use-case (for instance, agent accuracy, or response time).

Within an eval, you can select one or more datasets to evaluate. 

## Create a dataset
To create a dataset, navigate to the agent you want to evaluate.

1. Click the **Datasets** tab, and then click **Add Dataset**. 
2. Provide a **Name** and optionally add a **Description** for your dataset. 
3. Click **Create**. 

export function ArcadeEmbed() {
  return (
    
      
    
  )
}

## Create a test case
*Test cases* provide input and expected output for the evaluations. 

Datasets can have many test cases, and test cases can be one of two **Types**:
* **Tool choice**: Verifies that the agent selects the expected tool, and extracts the expected parameters, based on the specified input.
* **Final answer**: Requires choosing either a **Programmatic** or **LLM as a Judge** reviewer to score the correctness of an agent's output. Use programmatic reviewers when the agent's expected output can be clearly defined (for example, Exact match), and LLM-as-a-Judge reviewers when it's not as clearly defined (for example, Tone detection).

For more information on reviewers, refer to the [Reviewers](../../concepts/evals#reviewers) section of the [Evals](../../concepts/evals) concept page. 

### Tool choice test case
To create a **Tool choice** test case:

1. Click on the dataset, and select the **Add Test Case** button.
2. Select the dataset name from the **Dataset** dropdown.
3. Enter a phrase you want to test in the **Input** field. The example below uses the **Input** phrase `What's the weather in Tokyo?`
4. Select **Tool choice** for the **Type**.
5. In the **Expected tool** dropdown, select the tool you would expect your agent to choose given the input phrase. In the following example the **Expected tool** is `Get weather`. 
6. Enter any **Expected parameters**. In the following example the parameters are the **City**, `Tokyo`, and the current **Date** in `DD-MM-YYYY` format. 
7. Click **Create**. 

export function ArcadeEmbed_TC() {
  return (
    
      
    
  )
}

### Final answer test case
To create a **Final answer** test case:

1. Click on the dataset, and select the **Add Test Case** button.
2. Select the dataset name from the **Dataset** dropdown.
3. Enter a phrase you want to test in the **Input** field.
4. Select **Final answer** for the **Type**.
5. Choose a reviewer from the **Programmatic** or **LLM-as-a-Judge** options.
6. Add the data you want to test with the reviewer (this varies based on the selected reviewer). The example below uses the `String contains` reviewer and searches for the **Substring** `access` based on the **Input** `What's my calendar look like today?`. Since the test case involves a weather agent, it would not be expected that the agent would have access to a calendar tool, and it is likely that the agent will respond with `I do not have access`. 
7. Click **Save** on the **Choose a reviewer** modal. 
8. Click **Create** to add the test case to your dataset. 

export function ArcadeEmbed_FA() {
  return (
    
      
    
  )
}

## Next steps
Once you've created a dataset and test cases, you can create an eval. Check out [Run and compare evals](../evals/compare-eval-runs) to learn how to create an eval from a dataset and compare two evals side-by-side.

---

## Evals



---

## Monitor Retool Agents

The **Monitor** page for Retool Agents has three main components: a global view showing all agents, a detailed individual agent view, and an individual agent run view.

The key benefits of the **Monitor** page are:   
* Reduce time to identify and resolve agent issues.
* Improve understanding of resource usage patterns.
* Enhance ability to optimize agent workflows.
* Improve visibility into cost drivers.
* Provide actionable insights for runtime optimization.

## All agents view 
The **Monitor** page is comprised of several sections that detail information for all agents.

  Monitoring page for all agents.

### The agent sidebar
The agent sidebar includes an expandable list of all agents, small activity graphs showing recent runs, and a search bar. 
Click on agent from the sidebar to access monitoring information for that particular agent, or expand an agent and click on a particular run to access the monitoring information for that agent run. 

Use the agents sidebar to view monitoring information for all agents, a particular agent, or an agent run.

### Time range selector
The time range selector at the top of the page shows runs and errors across all agents for the selected timeframe when hovering over the graph. 

 The time range selector allows you to view the run and error history of all agents or an individual agent.

* The **Live** button turns on real-time live events. If the end of the time-range includes the present, activating **Live** mode pulls in live events, so that you can see agents and tool calls in real-time. 
* The dropdown selection below the **Live** button contains the following timeline view options: **Past 15 minutes**, **Past 1 hour**, **Past 1 day**, **Past 1 week**, **Past two weeks**, **Past 1 month**, or a **Custom** range. 
* Selecting the  or  buttons allows you to scroll through the timeline history based for the time range you've selected. For example, if you select **Past 1 week**, you can go backward or forward in the history a week at a time. 

### Visualizations
The **Agent graph** shows agent-resource interactions in real-time. Agents are displayed as primary nodes, and tools are shown as secondary nodes. Active connections are shown as animated lines during tool execution.

Hover over or click on an agent in the **Agent graph** to display its activity in the **Activity graph**.

 The **Agent graph** and **Activity graph** provide visual representations of agent resource connections and tool calls.

### Usage and cost information
To help track resource consumption across all agents, the **Token usage**, the **Estimated cost**, the **Total runtime** (primary cost metric), and the **Total runs** are displayed beneath the **Agent graph** and **Activity graph**. 

 The usage, cost, and count metrics are displayed underneath the visualizations.

**Agent tool usage**, **Agent total runtime**, and **Agent run count** show global runtime statistics. 

## Individual agent view 
To get to the individual agent view, click on the name of the agent in the agent sidebar. Each agent displays a **Last status** indicator (`SUCCESS`, `MANUALLY_CANCELED`, `FAILURE`, `TIMED_OUT`), a **Last started** timestamp, and a **Last run duration** for the last agent run that occurred. 

  Monitoring page for a single agent.

Each individual agent has the same monitoring dashboard as the all agents view, with the exception of the **Agent total runtime** and **Agent run count** global runtime statistics. 

## Agent run view
Individual agent runs are displayed when expanding the dropdown to the left of the agent name in the agent sidebar. Each individual agent run is represented by the date and time it occurred.

  Monitoring page for a single agent run.

Clicking on the run displays the **Run ID** for that particular agent run, as well as the **Status** (`SUCCESS`, `MANUALLY_CANCELED`, `FAILURE`, `TIMED_OUT`), **Started** timestamp , and **Run duration**. 

The usage and cost information, **Token usage**, **Estimated cost**, **Total runtime**, and **Tool calls**, is shown above the replay of the agent run, and the **Current activity** visual that contains the tool chips.

---

## Connect an MCP server to an agent

import MCP from '/docs/_partials/_agents-mcp.mdx';

An MCP server dynamically provides a list of tools. It is not a one-time static import from the server into Retool. The tool list is fetched whenever Retool connects to the MCP server.

MCP Server is a resource type configured with a URL, but you cannot write queries directly to these resources.

**Key features:**
* Add an MCP server to an agent.
* An agent can retrieve and select tools.
* Agents can invoke one or more of those tools.

## Supported authentication
Retool supports the following authentication options for MCP resources:
* [OAuth 2.0](../../../data-sources/guides/authentication/google-oauth) - Supports multiple flows including:
  * Authorization Code (default with PKCE)
  * Client Credentials
  * Authorization Code with PKCE
* [Basic Auth](../../../data-sources/concepts/authentication#basic) - Username and password authentication
* Bearer Token - Token-based authentication using an API key or access token

## Supported protocol versions
Protocol versions provide a framework to connect MCP resources to clients (such as IDEs, chat interfaces, or other software).

Retool currently supports the following protocol versions:

```JavaScript
export const LATEST_PROTOCOL_VERSION = "2025-06-18";
export const DEFAULT_NEGOTIATED_PROTOCOL_VERSION = "2025-03-26";
export const SUPPORTED_PROTOCOL_VERSIONS = [
  LATEST_PROTOCOL_VERSION,
  "2025-03-26",
  "2024-11-05",
  "2024-10-07",
  ];
```

## Limitations

Retool's MCP implementation has the following limitations:

### Transport protocols
* Retool only supports remote-hosted MCP servers accessible via HTTP/HTTPS. 
* Retool supports the following transport types: Streamable HTTP and Server-Sent Events (SSE).
* Local `stdio`-based MCP servers are not directly supported and must be exposed via an HTTP gateway (see instructions below).

### Timeouts
* The tool execution timeout is up to 2 minutes maximum.
* The tool listing timeout is 5 seconds.

### Protocol version support
* Supported protocol versions are determined by the MCP TypeScript SDK version (currently v1.17.5). 
* Retool automatically negotiates the protocol version with the MCP server during connection. 

## Connect to an MCP server

Retool Agents can connect to open MCP servers via Streamable HTTP or SSE, as well as private MCP servers using basic authentication with a username and password, bearer token authentication, or OAuth 2.0 with a client ID and client secret.

Many MCP servers are built to run locally over `stdio`. These can be exposed to Retool via an HTTP gateway.

:::note
To discover MCP servers that you can connect to, refer to the [official MCP registry](https://blog.modelcontextprotocol.io/posts/2025-09-08-mcp-registry-preview/).
:::

The following sample instructions explain how to use [supergateway](https://github.com/supercorp-ai/supergateway) and [ngrok](https://ngrok.com/) to create a server URL:

First, use supergateway to start an MCP server that is accessible at `http://localhost:8000/sse`.

```bash
npx -y supergateway --stdio "npx " --cors
```

For example, the [Brave Search MCP Server](https://github.com/modelcontextprotocol/servers/tree/main/src/brave-search) can be run via the command:

```bash
BRAVE_API_KEY=... npx -y supergateway --stdio "npx
@modelcontextprotocol/server-brave-search" --cors
```

Next, use ngrok to tunnel your local MCP server to the internet. Generate a strong password to use for authentication.

```bash
ngrok http --basic-auth 'mylongusername:mylongpassword' 8000
```

ngrok provides a temporary URL similar to the following: `https://xyz-123.ngrok-free.app`, which is the server's base URL. ngrok also supports [static domains](https://ngrok.com/blog-post/free-static-domains-ngrok-users).

If you are using supergateway, your MCP server URL will be `https://xyz-123.ngrok-free.app/sse`, which you can then paste into Retool.

## Connect an MCP server to an agent

To connect an MCP server to an agent:

1. Open an existing agent or [create a new one](../../tutorials.mdx).
2. On the **Configuration** tab, click **Add new tool**.
3. Click **Connect to MCP Server**.
4. Select a previously created resource from the **Select MCP Server** dropdown, or choose **Add new resource**.
5. Give the new resource a **Name**.
6. Paste in the URL of your MCP server in the **Server URL** field, and optionally add your authentication credentials.
7. Click **Create resource**.

export function ArcadeEmbed() {
  return (
    
      
    
  )
}

If your MCP server requires authentication, click **Authenticate MCP Server** from the **Connect to MCP server** page, the **Configuration** tab, or click **Authenticate** in the **Chats** tab. Follow the prompts to **Authenticate** and **Approve** the tool.

 Tool authentication required.

The tools exposed by the MCP server will be available as tools on your Retool Agent.

---

## Create a custom tool

import Connectsvg from "/img/icon-packs/bold/interface-geometric-circle-alternate.svg";

Create a custom tool to provide your agent with reusable, complex logic with strongly-typed parameters. Custom tools are especially useful if you have a specific need not covered by one of the [core tools](./use-core-tools.mdx) or other types of tools you can create or import. Custom tools use a canvas of pre-built query blocks that you connect together to interact with resources, transform data, and run additional logic.

Custom tools are very similar to the [multi-step functions](../../../workflows/guides/functions.mdx) that are available in Retool Workflows.

## Features

Key features of custom tools for agents include:

- Strongly-typed parameters.
- A **Function Generator** chat interface that can automatically create a custom function.
- The flexibility and power of workflows without the cost associated with workflow runs.
- An independent control flow.
- Support for all available [block types](../../../workflows/guides/blocks/blocks.mdx).

:::note

Custom tools run on behalf of the currently authenticated user, which is reflected in the `current_user` object.

:::

## Add a custom tool

The instructions in this section explain how to create a custom tool using an example that gets [Retool changelog](/changelog/) entries between a start and end date. This example is also used as part of the [Retool Agents tutorial](../../tutorials/agents-tutorial.mdx#create-a-custom-tool).

1. Create a new agent or navigate to an existing agent. Open the **Configuration** tab.
2. In the **Tools** section, click the **+ Add Tool** button.
3. Click **Create new custom tool**. A tool configuration page opens.
4. In the **Name** setting, enter `fetchFromChangelog`
5. In the **Description** setting, enter `Searches for and filters changelog entries by user-provided date range.`
6. Click **Add parameter**  twice. Click  to update each parameter, and configure them with the following settings:
    | Name          | Type         | Description                                                             | Required |
    |---------------|--------------|------------------------------------------------------------------------ | ---------|
    | `startDate`   | String       | The start date (inclusive) for filtering entries, in YYYY-MM-DD format. | Yes      |
    | `endDate`     | String       | The end date (inclusive) for filtering entries, in YYYY-MM-DD format.   | Yes      |
7. Select **Edit function** in the **Function Logic** section.

### Edit function

You have two options for creating function logic: you can manually assemble blocks to create your desired control flow, or you can use the **Function Generator**, to create a function automatically using your choice of LLM.

To manually assemble blocks that retrieve changelog entries and filter them by date, complete the following steps:

1. Delete the `code1` block. Click and drag  from the Parameters block. Create a  **Resource query** block with the **REST API** resource type to `GET` the JSON feed for the Changelog: `https://docs.retool.com/changelog/feed.json`. Name it `getChangelogEntries`.
2. From `getChangelogEntries`, click and drag  to add a  **Code** block. Replace the default code with the following JavaScript:
    ```javascript
    return getChangelogEntries.data.items
    ```
3. From the  **Code** block, click and drag  to add a **Filter** block with the following **Expression** to use the `moment()` date library to match any posts within the specified range:
    ```json
    moment(value.date_modified).isBetween(moment(params.startDate), moment(params.endDate))
    ```
4. All functions must have a **Response** block. From the **Filter** block, click and drag  to add a **Response** block with a **Status code** of `200` and the following **Return body**:
    ```json
    filter1.data
    ```
5. Click **Done**.
6. On the **Edit Tool** page, click **Save**.

export function ArcadeEmbed() {
  return (
    
      
    
  )
}

Provide the **Function Generator** instructions about what actions you want your function to perform:

1. Paste the following command into the **Function Generator**:
    ```
    Write a function that retrieves the changelog entries from https://docs.retool.com/changelog/feed.json. Return only the items with a date_modified between or on the startDate and endDate.
    ```
2. The **Function Generator** provides a plan that outlines the function it will create. Review the plan, and click ** Accept**.
3. Once the canvas updates with your new function, provide example start and end dates in the **params** block and click **Test Function**.
    :::important
    Depending on the model and prompt you use, you may have varying results and need to troubleshoot the code that's generated.
    :::
4. Click **Done**.
5. On the **Edit Tool** page, click **Save**.

:::note

You can also optionally @ tag any previously-created [resources](../../../data-sources/index.mdx) to indicate that you want to include a [Resource query block](../../../workflows/guides/blocks/resource-query.mdx) that accesses that resource.

:::

## Billing for custom tools

While the functions used by custom tools are functionally similar to workflows, they are billed differently. The time that your custom tool takes to run contributes to the overall billable time for your agent. Refer to the [Billing and usage](/support/billing-usage/agents) guide for more information.

---

## Import tools from another agent

When configuring an agent, you can import tools from another agent. This functionality is useful for reusing complex custom tools without the need to recreate them.

Importing a tool creates a deep copy. You can make changes to the imported tool without impacting the tool's usage in the original agent.

:::note

Users don't need `edit` access to an agent in order to import a tool from it.

:::

Complete the following steps to import a tool from another agent:

1. Create a new agent or navigate to an existing agent. Open the **Configuration** tab.
2. In the **Tools** section, click the **+ Add Tool** button.
3. Select the **Import from other agent** button.
4. From the dropdown, search for or select the agent that you want to import a tool from.
5. From the list of **Available Tools**, select the tools that you want to import.
6. Click **Import 1 Selected**. The number updates to reflect how many tools you are importing.
7. In the **Configuration** tab, you can choose to make edits to your newly imported tool. Any edits to this tool are reflected only in this agent, and the tool in the original agent remains unchanged.

export function ArcadeEmbed() {
  return (
    
      
    
  )
}

---

## Tools



---

## Invoke an agent as a tool

You can configure your agent to use another agent as a [tool](../../concepts/tools.mdx). This is useful for situations in which you have one agent that performs a narrowly-scoped task, and you want another agent that to reuse that capability.

:::note

Using an agent as a tool does not copy the agent—it creates a new trigger for the existing agent. Any changes that you make to an agent that is referenced as a tool persist in all uses of that agent.

:::

For example, a marketing team wants to create an agent that helps them with providing discount codes based on the item catalogue and inventory. If the sales team already has an agent that evaluates whether to send discount emails to customers, the marketing team can use that agent as a tool.

## Features

Key features of agents as tools include:

- Minimize duplicate work by leveraging existing agents.
- Outsource certain decision-making to a more specialized agent.

## Configure an agent as a tool

Complete the following steps to configure an agent as a tool:

1. Create a new agent or navigate to an existing agent. Open the **Configuration** tab.
2. In the **Tools** section, click the **+ Add Tool** button.
3. Select **Use Agent**.
4. On the **Use Agent** page, select the agent that you want to use, or choose to create a new one.
5. The **Name** setting auto-populates with the name of the agent. Rename the tool if you choose, and add a description.
6. Click **Save**.

export function ArcadeEmbed() {
  return (
    
      
    
  )
}

---

## Retool Agents core tools

There are several pre-built **Core tools** that Retool provides with Retool Agents so you can get started building faster. Every Retool organization will be seeded with resources for core tools.

Core tools for Retool Agents.

import SharedCoreTools from '/docs/_shared/_agent-core-tools.mdx';

## Add core tools to an agent
To add a core tool to an agent, sign in to your Retool organization, and select the **Agents** tab in the top navigation bar.

1. Open an existing agent or [create a new one](../../tutorials.mdx).
4. On the **Configuration** tab, click **Add new tool**.
5. Click the **+** on the **Core tools** you want to add, and select **Add tools**.

The agent **Configuration** tab displays the tools you added in the **Tools** section.

export function ArcadeEmbed() {
  return (
    
      
    
  )
}

## Selecting resources
Once you add a tool to your agent, a `Select Resource` dropdown appears. Use this dropdown to choose from existing resources in your organization, or create a new one. To use an existing resource, you need **Edit** permissions for that resource.

If you create a new resource, you have options to share credentials between users and apply the resource you create to all tools that need that type of resource.

export function ArcadeEmbed_SR() {
  return (
    
      
    
  )
}

## Convert a core tool to a custom tool
When you edit a core tool, Retool Agents automatically converts it to a [custom tool](./create-custom-tools), and you can edit the **Function Logic**. You will be prompted with a warning message when converting a core tool to a custom tool. This is a check to ensure you're making an intended change. Converting a core tool to a custom tool doesn't change the way the tool functions until you modify it.

1. Click  to expand the core tool, and click the **Edit** () icon.
2. Click **Continue** on the warning message that pops up.
3. Select **Edit function** in the **Function Logic** section.
4. Update the tool as desired and click **Done**.
5. Click **Save** on the **Edit tool** page to save the updates to your new custom tool.

export function ArcadeEmbed_CT() {
  return (
    
      
    
  )
}

---

## Trigger a workflow as a tool

You can configure your agent to use a workflow as a [tool](../../concepts/tools.mdx). This is useful for users that already have a workflow that they want to leverage.

:::note

Using a workflow as a tool does not copy the workflow—it creates a new trigger for the workflow. Any changes that you make to a workflow that is referenced as a tool persist in all uses of that workflow.

:::

For example, a marketing team wants to create an agent that helps them with providing discount codes based on the item catalogue and inventory. If the team already has a workflow that retrieves the catalogue of clothing, they can use that workflow as a tool for your agent without needing to create a [custom tool](./create-custom-tools.mdx) or new workflow.

## Features

Key features of workflows as tools include:

- Minimize duplicate work by leveraging existing workflows.
- Share a single workflow between several agents.
- Use the [workflow limits](../../../workflows/concepts/limits.mdx), which are longer than those of custom tools.

:::note

When a workflow is called by an agent, Retool triggers the workflow as if it was triggered by the first user with admin permissions in your organization. If the workflow requires access to user-authenticated resource, the workflow is run as if it was triggered by the authenticated user.

:::

## Requirements

Your workflow must meet the following requirements be used in an agent:

- It must be [published](../../../workflows/guides/version-and-publish.mdx).
- It must include a [response block](../../../workflows/guides/blocks/response.mdx).
- It must not have [path parameters or headers](../../../workflows/guides/triggers/webhooks.mdx#).

## Configure a workflow as a tool

Complete the following steps to add a workflow as a tool:

1. Create a new agent or navigate to an existing agent. Open the **Configuration** tab.
2. In the **Tools** section, click the **+ Add Tool** button.
3. Click **Use workflow**.
4. On the **Use workflow** page, select the workflow that you want to use, or create a new one.
5. Enter a **Name** and **Description** for your workflow.
6. If your workflow uses JSON parameters in the trigger block, add corresponding parameters to the tool configuration. Each parameter must have the same **Name** and **Type** as what is used in the workflow. Mark parameters as **Required** if they are necessary for the workflow run.
7. Click **Save** to finalize your changes.

export function ArcadeEmbed() {
  return (
    
      
    
  )
}

## Billing for workflows as tools

Your organization is billed for a workflow run every time an agent calls a workflow as a tool. The time it takes for your workflow to run also counts towards the billable time for your agent. Refer to the [Billing and usage](/support/billing-usage/agents) guide for more information.

:::note

To avoid being billed for a workflow run, consider using a [custom tool](./create-custom-tools.mdx) instead.

:::

---

## Triggers



---

## Set up an A2A trigger

To allow external agents to communicate with Retool agents, you can enable the A2A trigger on your agent's configuration page, and copy the endpoint and API key into your A2A client. An API key is provided for each agent, and must be passed to the client via an `X-Api-Key` header. API keys can be rotated. 

The process to use the Agent-to-agent (A2A) protocol with agents is similar to creating a [webhook trigger in workflows](../../../workflows/guides/webhooks). 

The A2A client then sends messages via common messaging formats like the HTTP+REST or JSON-RPC APIs, and Server-Sent Events (SSE) for long-running streaming updates. 

:::info
Prior to enabling A2A, you must have all the necessary permissions for **Retool AI** and **AI Agents** turned on for your organization. Refer to [Permissions for Agents](../../../permissions/guides/agent-permissions#admin-capabilities.mdx) for more information. 
:::

## Enable the A2A trigger

On your agent's **Configuration** page: 

1. Click the **A2A** trigger. 
2. Toggle the **A2A** switch on. 
3. You can either copy and paste the **Endpoint** and the **API key** separately into your A2A client, or you can click **Copy** next to **Endpoint** and select **Copy as cURL** from the dropdown. This copies a cURL command preformatted with your agent's information and API key to your clipboard. 

The default endpoint provided is the [Get agent card](../../reference/a2a-endpoints.mdx#get-agent-card) endpoint.

export function ArcadeEmbed() {
  return (
    
      
    
  )
}

You can [cURL to test the agent response](../../reference/a2a-endpoints) to different endpoints, or [trigger your agent via an external agent](../../tutorials/a2a-tutorial.mdx). 

## Additional resources
To continue learning about A2A, explore the following resources:

* [Agent-to-agent communication](../../concepts/a2a.mdx)
* [A2A tutorial](../../tutorials/a2a-tutorial.mdx)
* [What is A2A Protocol?](https://a2a-protocol.org/dev/)
* [A2A endpoints](../../reference/a2a-endpoints.mdx)

---

## Trigger agents with email

:::note
Before getting started, reach out to your account manager or support so that they can configure your organization's settings to allow **Email** triggers for agents.
:::

**Email** triggers enable you, or anyone else that has access to the unique agent's email address, to send an email with a user message that triggers your agent. Treat the agent's email address as sensitive information.

:::warning

If the sender's email address matches that of a Retool user with `use` access to the agent, `current_user` reflects that user and the agent can only use tools to which the user has access.

If the sender's email address does _not_ match any Retool user with appropriate permissions, the agent falls back to an organization admin. **Retool strongly recommends that you only allow known Retool users with access to the agent to use email triggers.**

Refer to the `current_user` [reference](../../../reference/current-user) and the [Manage permissions](../../../../../permissions/guides/agent-permissions) page for more information.

:::

The following changes occur when setting up an email trigger:

- The **Trigger** section contains an email address that you can use to trigger your agent.
- An additional set of **Instructions** is added to tell your agent how to respond to and send emails.
- A **Reply to Email** tool is added to the list of **Tools**.

To set up an email trigger for an agent:

1. Create a new agent or navigate to an existing agent. Open the **Configuration** tab.
2. In the **Triggers** section, click **+ Email**.
3. Copy the email address and send your agent an email.

:::note
You can CC other recipients when sending an email to trigger the agent. Recipients will then also receive the agent's response.
:::

export function ArcadeEmbed() {
  return (
    
      
    
  )
}

---

## Configure email triggers for Agents using Mailgun

Self-hosted organizations can implement [email triggers](./) for Agents using [Mailgun](https://www.mailgun.com/), a paid, third-party mail service. 

:::warning

If your Self-hosted environment is behind a VPN, and you want to trigger agents via email, make sure your `api/agents/emailWebhook` endpoint is accessible by Mailgun. Refer to [Mailgun's Webhooks documentation](https://documentation.mailgun.com/docs/mailgun/user-manual/events/webhooks) for the domain that will need access to your webhook.

:::

Setting up a Mailgun account and enabling the environment variables using the process described below allows you to send an email to your agent, which Mailgun forwards to your Self-hosted deployment as a webhook event, which then triggers the agent to run.  

## Requirements

To implement email triggers, you need:

- A verified [Mailgun](https://www.mailgun.com) account.
- A custom domain to use with Mailgun.
- Ingress for Mailgun to send webhook notifications. 
- A webhook endpoint URL reachable by Mailgun. Tools such as [ngrok](https://ngrok.com) can be used to accomplish this. 

## Set up Mailgun

Complete the following steps to configure Mailgun:

1. Add a new custom domain and verify it. Do not use the sandbox domain Mailgun creates automatically upon login. 
2. Create a new [Receiving Route](https://help.mailgun.com/hc/en-us/articles/360011355893-Routes) and toggle on **Store and notify** and enable **Message Retention**. Retool uses Mailgun's `Messages` API to look up the message, so it is important to enable **Store and Notify** and **Message Retention**, otherwise, the following error message will display: `{"message":"Message retrieval disabled for domain"}`. Message retention durations are limited by the Mailgun plan selected. 

    
    Create a new Receiving Route in Mailgun.
     

3. Create an endpoint URL and update any firewall configuration so that it is reachable by Mailgun. You can use tools such as [Ngrok](https://ngrok.com/) to create a URL. For example: `https://.ngrok-free.app/api/agents/emailWebhook`.  
4. In Mailgun, add a new [Webhook](https://documentation.mailgun.com/docs/mailgun/user-manual/events/webhooks) and provide the webhook URL you created for your agent.  

        
    Provide your webhook endpoint URL.
     

          
    The Webhooks page of the Mailgun dashboard.
     

## Environment variables
Set the following environment variables within your deployment's configuration file.

- `MAILGUN_WEBHOOK_API_KEY` - The **HTTP webhook signing key** found in the **Webhooks** section of your Mailgun dashboard. 
- `MAILGUN_API_KEY` - The **Mailgun API key** found in the **API Security** section of your Mailgun dashboard. Refer to [Mailgun's help page](https://help.mailgun.com/hc/en-us/articles/203380100-Where-can-I-find-my-API-keys-and-SMTP-credentials) for more information.
- `AGENT_EMAIL_DOMAIN` - The domain of your email address. For example, if your email is `johndoe@retool.com` then your email domain is `retool.com`.  

## Set up a custom tool for email
The **Send Email** and **Reply to Email** tools are not supported for Self-hosted deployments. To send email or reply to an email on a Self-hosted deployment, create a [custom tool](../../tools/create-custom-tools) to connect to an agent with an email resource like SMTP or Twilio.

---

## Retool Agents how-to guides



---

## Retool Agents documentation

Retool Agents is a platform that lets you encode a business process, connect to external systems of records, make deterministic decisions with code, make non-deterministic decisions with LLMs, include humans in decision making, and take actions by writing data, calling into other systems, or responding directly to customers.

---

## Retool Agents quickstart

import Image from '@site/src/components/Image';

Retool Agents is a product that allows you to build AI agents for various use cases, test, deploy, evaluate, and monitor them within Retool.

This guide serves as an introduction to [Retool Agents](../agents/concepts/overview.mdx). It covers many of the concepts and terminology you will come across as you build agents. After reading this page, you should have a good understanding of the fundamentals for building Retool Agents.

## Page structure
Retool Agents displays three primary pages within the left-hand navigation bar:
* [Home](#all-agents)
* [Monitor](#monitor)
* [Templates](#templates)

Under **Templates** is **+ New Agent**, which opens the [Create agent](#create-agent) modal. And the **Recents** section lists any agents you've recently created or viewed.

Within an agent, the following tabs are displayed:
* [Chats](#chats)
* [Configuration](#configuration)
* [Logs](#logs)
* [Evals](#evals)
* [Datasets](#datasets-and-test-cases)

### All agents
Clicking on the **Agents** tab in the top navigation bar displays the **All agents** page. You can get back to the **All agents** page by clicking **Home** in the left-hand navigation toolbar from other pages within Retool Agents.

The **All agents** page displays all agents, and folders containing agents, for your Retool organization. You can **Sort**, **Filter**, or **Search for agents**, toggle between **Grid view** or **Table view**, **Refresh** the agents list, create a **New Folder** or create a **New Agent**.

  The all agents home page shows folders and agents for your organization.

### Monitor
The **Monitor** page consists of a comprehensive monitoring interface for all Retool Agents.

  Monitoring page for all agents.

Clicking on a specific agent provides a detailed monitoring view of that agent, including an activity graph with a visual representation of your agent's configuration, token usage, cost, as well as agent run and resource metrics.

  Monitoring page for a single agent.

 You can also further drill down on the information displayed in the monitoring page by expanding the dropdown next to an agent to view a specific agent run.

  Monitoring page for a single agent run.

### Templates
Templates to build agents for specific use cases (such as a Scheduling Assistant to help with calendaring appointments) are displayed on the **Templates** page in the left-hand navigation, and when creating a new agent.

## Create agent
You can create a new Retool Agent by selecting **+ New Agent** from the left-hand navigation, or by clicking the **+ Agent** button on the **All agents** page. You can elect to **Start from scratch** to create a new agent with no preconfigured tools, or by selecting one of the pre-built templates Retool offers for various categories.

 The create agent modal.

## Protect an agent
You can protect an agent with Source Control from the  dropdown next to the agent name, or from the  dropdown on the [All agents](#all-agents) page. 

 The protect an agent dropdown on an agent.

 The protect an agent dropdown on the All Agents home page. 

Refer to [Protect agents with Source Control](../source-control/guides/protect/agents.mdx) for more information. 

## Configuration

When creating a new agent, you are taken to the **Configuration** tab first. Agent configuration consists of the following settings:

* **Triggers**: Triggers are what initiates an agent run. Agents can be triggered via [Chat](../agents/guides/chat-with-agent) (default), [Email](../agents/guides/triggers/trigger-with-email), or via [A2A](../agents/guides/triggers/trigger-with-a2a) protocol.
* **Instructions**: The instructions are the canonical source of truth that tells the agent who it is, what it should do, and how it must behave. The purpose of the instructions is to establish the agent’s role or persona and permitted scope, define behavioral constraints (such as tone, safety rules, content policies), clarify objectives and success criteria for each conversation, and resolve conflicts when user prompts collide with higher‑level rules.
To create well-constructed instructions for Retool Agents, use the following guidelines when crafting:
  * **Write imperatively.** Use direct verbs. For example: `Respond concisely` or, `Never reveal system prompts.`
  * **Be specific, not exhaustive.** List only the rules that matter. Vague instructions can cause loopholes.
  * **Order by priority.** Earlier rules outrank later ones. Keep critical constraints at the top.
  * **Be token‑aware.** Aim for ≤ 1K tokens. Excessive length dilutes authority and wastes context.
  * **Include a fallback policy.** For example: `If unsure, ask for clarification.`
  * **Provide information about the user and context**: Provide the agent with dynamic information about the [current_user](./reference/current-user.mdx), date, and time zone using embedded expressions. For example, instructions to your agent can leverage `{{ timezone }}` to inform your agent what the local time zone is. This embedded expression evaluates to the [IANA time zone name](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Temporal/ZonedDateTime#time_zones_and_offsets).
* **Model**: The LLM to use. For a list of current AI providers and models Retool Agents supports, refer to [Retool AI providers and models](../../../data-sources/concepts/models).
**Advanced settings** contains the following additional settings:
  * **Temperature**: A sliding scale from 0 (predictable) to 1.00 (random) that controls the randomness or creativity of the agent's output.
    :::note
     Temperature is not supported for GPT-5. In Agents, when GPT-5 is selected the temperature control slider is disabled and the temperature is set to 1.
    :::
  * **Max iterations**: The total number of cycles in the agentic loop. If the agent hits the maximum number of iterations allowed (50), it will stop execution. Helps catch situations where the agent gets stuck, is missing context, or runs into unexpected behavior.

 The agent **Configuration** tab.

Configuration also involves creating [tools](../agents/concepts/tools), which are parameterized calls to workflows, functions, or other agents.
  :::note
  There is no minimum or maxiumum number of tools you can add, but LLMs typically perform best with 1-10 tools.
  :::
### Configuration assistant
You can message the **Configuration assistant** to help configure your agent with the appropriate tools. The **Configuration assistant** will provide tool **Suggestions** that you can either **Accept** or **Reject**. Once accepted, the tools are added to the **Tools** section of the **Configuration** tab, and you can select resources, or finish configuring your agent with the tools provided.

You can also change the AI model the **Configuration assistant** uses by selecting the  icon next to the model name in the message box.

  Message the config assistant for help configuring tools for your agent.

### Add tools

import SharedTools from '/docs/_shared/_agent-tools.mdx';

## Deploy an agent
To save a specific agent configuration, create a new version of your agent with the **Deploy** feature. The **Deploy** dropdown modal is available at the top of every page within the agent. Select the **Release type** (Major, Minor, or Patch), provide an optional **Description of changes**, and **Deploy** your agent. If you have made modifications to your agent but have not yet deployed those changes `Undeployed changes` is displayed next to the **Deploy** dropdown.

## Version history
Agent change history is saved automatically in the **Agent version** dropdown. When you update an agent, the version history dropdown displays **Modified**, and when you **Deploy** your agent, the major, minor, and patch version history is displayed.

  The version history is displayed next to the agent name at the top of every agent page.

## Invoke an agent

import Invoke from '../_partials/_invoke-agents.mdx';

## Chats
The **Chat** tab allows you to chat with an agent and view the LLM's tool call runs and reasoning so that you can test your agent as you build.

The `message` and `previousMessages` input parameters from the chat are automatically passed to the agent, so you do not need to configure or specify these inputs.

### Share thread

import Partials from '/docs/_partials/_agent-share-thread.mdx';

## Logs
The **Logs** tab displays a detailed list view of the steps the agent took while running. The log details include:

* **Timestamp**: The timezone is stored in UTC and shown in your local timezone.
* **Type**: The start or end of the agent, the LLM, or the tool.
* **Status**: The status of the step. The status listed is either `Completed`, `Running`, `Queued`, or `Failed`. A status may show `Queued` if a tool requires approval or authorization before it can be used.
* **Tool**: The tool the agent called (if applicable to the step).
* **Thoughts**: The agent's reasoning.
* **Input**: The message input.
* **Run**: The `run ID` for that step.

  Agent logs display detailed information about the agent runs.

## Evals

import SharedEvals from '/docs/_shared/_agent-evals.mdx';

---

## A2A endpoints

You can use the following Agent-to-agent (A2A) API endpoints with agents. For more detailed information about A2A, refer to the [Agent-to-agent communication](../concepts/a2a.mdx) conceptual guide.

| Name                                                                | Description                                                                   | Endpoint                                        |
| --------------------------------------------------------------------| ------------------------------------------------------------------------------|-------------------------------------------------|
|  [Get agent card](./a2a-endpoints#get-agent-card)                   | View an agent's information through the agent card.                           | `GET /a2a/:agentId/.well-known/agent-card.json` |
|  [Send message](./a2a-endpoints#send-message)                       | Sends a message to an agent.                                                  | `POST /a2a/:agentId/v1/message:send`            |
|  [Get task](./a2a-endpoints#get-task)                               | Polls an agent to view the output of a specific task.                         | `GET /a2a/:agentId/v1/tasks/:taskId`            |
|  [Send streaming messages](./a2a-endpoints#send-streaming-messages) | Sends a message to an agent and subscribes to real-time updates via SSE.      | `POST /a2a/:agentId/v1/message:stream`          |
|  [Subscribe to task](./a2a-endpoints#subscribe-to-task)             | Streams updates from an agent for an existing task.                           | `POST /a2a/:agentId/v1/tasks/:taskId:subscribe` |
|  [Cancel task](./a2a-endpoints#cancel-task)                         | Requests the cancellation of an ongoing task running on an agent.             | `POST /a2a/:agentId/v1/tasks/:taskId:cancel`    |

### Get agent card
The [agent card](https://a2a-protocol.org/dev/specification/#8-agent-discovery-the-agent-card) describes the agent's identity, capabilities, skills, and interaction requirements.

```curl
curl --url "https://yourdomain.retool.com/api/agents/a2a/agent_id/.well-known/agent-card.json" \
  -H "Content-Type: application/json" \
  -H "X-Api-Key: retool_wk_########"
```

```json
{
    "name":"A2A test",
    "preferredTransport":"HTTP+JSON",
    "description":"",
    "url":"https://yourdomain.retool.com/api/agents/a2a/agent_id",
    "provider":
        {"organization":"youradmin@retool.com",
        "url":"https://yourdomain.retool.com"
    },
    "protocolVersion":"0.3.0",
    "version":"0.0.1",
    "capabilities":{
        "streaming":true,
        "pushNotifications":false
    },
    "defaultInputModes":[
        "application/json"
    ],
    "defaultOutputModes":[
        "application/json"
    ],
    "skills":[

    ]
}"%"
```

### Send message
A [send message](https://a2a-protocol.org/dev/specification/#311-send-message) request is the primary way to initiate agent interactions. Clients can send a message to an agent and receive a task in response.

:::info
The `taskId` in A2A is the `runId` within Retool. When you send a message, for example, via `POST /a2a/:agentId/v1/message:send` the response is an [A2A Task object](https://a2a-protocol.org/dev/specification/#311-send-message) with a top-level ID field of `taskId`.
:::

```curl
curl -X POST \
  "https://yourdomain.retool.com/api/agents/a2a/agent_id/v1/message:send" \
  -H "Content-Type: application/json" \
  -H "X-Api-Key: retool_wk_#####" \
  -d '{
    "message": {
      "messageId": "msg-12345",
      "role": "user",
      "parts": [
        {
          "kind": "text",
          "text": "tell me a joke"
        }
      ]
    }
  }'
```

```json
{
    "id":"054c93a8-b0ed-49ea-915d-418e615cb7b4",
    "contextId":"23a617f6-f7a7-40a8-955c-f17faad5c954",
    "status":{
        "state":"submitted",
        "message":{
            "role":"agent",
            "parts":[
                {"kind":"text",
                 "text":"Task submitted"
                 }
            ],
            "messageId":"status-054c93a8-b0ed-49ea-915d-418e615cb7b4-1764717334957",
            "taskId":"054c93a8-b0ed-49ea-915d-418e615cb7b4",
            "contextId":"23a617f6-f7a7-40a8-955c-f17faad5c954",
            "kind":"message"
        }
    },
    "kind":"task",
    "history":[
        {
            "role":"user",
            "parts":[
                {
                    "kind":"text",
                    "text":"tell me a joke"
                }
            ],
            "messageId":"dd992a34-b2bc-4f4f-b0c1-0e7399da87d2",
            "contextId":"23a617f6-f7a7-40a8-955c-f17faad5c954",
            "taskId":"054c93a8-b0ed-49ea-915d-418e615cb7b4",
            "kind":"message"
        }
    ]
}
```

When testing this endpoint with Retool, you can view the POST in the [log output](../quickstart.mdx#logs), the [monitoring page](../quickstart.mdx#monitor), or you can make use of the get task or streaming endpoints.

### Get task
[Get task](https://a2a-protocol.org/dev/specification/#313-get-task) retrieves the current state (including status, artifacts, and optionally history) of a previously initiated task. This is typically used for polling the status of a task initiated with [message:send](../guides/triggers/trigger-with-a2a.mdx#send-message), or for fetching the final state of a task.

```curl
curl --url "https://yourdomain.retool.com/api/agents/a2a/agent_id/v1/tasks/task_id" \
  -H 'Content-Type: application/json' \
  -H 'X-Api-Key: retool_wk_######'
```

```json
{
    "id":"054c93a8-b0ed-49ea-915d-418e615cb7b4",
    "contextId":"23a617f6-f7a7-40a8-955c-f17faad5c954",
    "status":{
        "state":"completed",
        "message":{
            "role":"agent",
            "parts":[
                {
                    "kind":"text",
                    "text":"Why don't skeletons fight each other? \n\nBecause they don't have the guts!"
                }
            ],
            "messageId":"8dc8c544-f6d9-49a8-b9e3-cecf2433f23d",
            "contextId":"23a617f6-f7a7-40a8-955c-f17faad5c954",
            "taskId":"054c93a8-b0ed-49ea-915d-418e615cb7b4",
            "kind":"message"
        }
    },
    "kind":"task",
    "history":[
        {
            "role":"user",
            "parts":[
                {
                    "kind":"text",
                    "text":"tell me a joke"
                }
            ],
            "messageId":"dd992a34-b2bc-4f4f-b0c1-0e7399da87d2",
            "contextId":"23a617f6-f7a7-40a8-955c-f17faad5c954",
            "taskId":"054c93a8-b0ed-49ea-915d-418e615cb7b4",
            "kind":"message"
        },
        {
            "role":"agent",
            "parts":[
                {
                    "kind":"text",
                    "text":"Why don't skeletons fight each other? \n\nBecause they don't have the guts!"
                }
            ],
            "messageId":"8dc8c544-f6d9-49a8-b9e3-cecf2433f23d",
            "contextId":"23a617f6-f7a7-40a8-955c-f17faad5c954",
            "taskId":"054c93a8-b0ed-49ea-915d-418e615cb7b4",
            "kind":"message"
        }
    ]
}"%"
```

### Send streaming messages
[Send streaming messages](https://a2a-protocol.org/dev/specification/#312-send-streaming-message) is similar to [message:send](../guides/triggers/trigger-with-a2a.mdx#send-message), but it provides real-time streaming of updates during processing.

```curl
 curl -X POST \
  "https://yourdomain.retool.com/api/agents/a2a/agent_id/v1/message:stream" \
  -H "Content-Type: application/json" \
  -H "X-Api-Key: retool_wk_your_api_key" \
  -d '{
    "message": {
      "messageId": "msg-123456",
      "role": "user","parts": [
        {
          "kind": "text",
          "text": "tell me a joke"
        }
      ]
    }
  }'
```

```json
"event":"task
data":{
   "task":{
      "id":"7c185114-3ba7-4742-80d1-1e03af262ffa",
      "contextId":"85ba1598-f940-436f-a964-1bed22b94930",
      "status":{
         "state":"submitted",
         "message":{
            "role":"agent",
            "parts":[
               {
                  "kind":"text",
                  "text":"Task submitted"
               }
            ],
            "messageId":"status-7c185114-3ba7-4742-80d1-1e03af262ffa-1764963458316",
            "taskId":"7c185114-3ba7-4742-80d1-1e03af262ffa",
            "contextId":"85ba1598-f940-436f-a964-1bed22b94930",
            "kind":"message"
         }
      },
      "kind":"task",
      "history":[
         {
            "role":"user",
            "parts":[
               {
                  "kind":"text",
                  "text":"tell me a joke"
               }
            ],
            "messageId":"d61ae646-96d7-45a9-806d-ecac05a2d649",
            "contextId":"85ba1598-f940-436f-a964-1bed22b94930",
            "taskId":"7c185114-3ba7-4742-80d1-1e03af262ffa",
            "kind":"message"
         }
      ]
   }
}"event":"statusUpdate
data":{
   "statusUpdate":{
      "kind":"status-update",
      "taskId":"7c185114-3ba7-4742-80d1-1e03af262ffa",
      "contextId":"85ba1598-f940-436f-a964-1bed22b94930",
      "status":{
         "state":"working",
         "message":{
            "role":"agent",
            "parts":[
               {
                  "kind":"text",
                  "text":"Agent run started, thinking"
               }
            ],
            "messageId":"status-7c185114-3ba7-4742-80d1-1e03af262ffa-1764963461322",
            "taskId":"7c185114-3ba7-4742-80d1-1e03af262ffa",
            "contextId":"85ba1598-f940-436f-a964-1bed22b94930",
            "kind":"message"
         }
      },
      "final":false
   }
}"event":"statusUpdate
data":{
   "statusUpdate":{
      "kind":"status-update",
      "taskId":"7c185114-3ba7-4742-80d1-1e03af262ffa",
      "contextId":"85ba1598-f940-436f-a964-1bed22b94930",
      "status":{
         "state":"working",
         "message":{
            "role":"agent",
            "parts":[
               {
                  "kind":"text",
                  "text":"Why don't skeletons fight each other?\n\nBecause they don't have the guts!"
               }
            ],
            "messageId":"bed394ef-cd1c-46e9-b469-755620575236",
            "contextId":"85ba1598-f940-436f-a964-1bed22b94930",
            "taskId":"7c185114-3ba7-4742-80d1-1e03af262ffa",
            "kind":"message"
         }
      },
      "final":false
   }
}"event":"statusUpdate
data":{
   "statusUpdate":{
      "kind":"status-update",
      "taskId":"7c185114-3ba7-4742-80d1-1e03af262ffa",
      "contextId":"85ba1598-f940-436f-a964-1bed22b94930",
      "status":{
         "state":"completed",
         "message":{
            "role":"agent",
            "parts":[
               {
                  "kind":"text",
                  "text":"Why don't skeletons fight each other?\n\nBecause they don't have the guts!"
               }
            ],
            "messageId":"bed394ef-cd1c-46e9-b469-755620575236",
            "contextId":"85ba1598-f940-436f-a964-1bed22b94930",
            "taskId":"7c185114-3ba7-4742-80d1-1e03af262ffa",
            "kind":"message"
         }
      },
      "final":true
   }
}
```

### Subscribe to task
[Subscribe to Task](https://a2a-protocol.org/dev/specification/#316-subscribe-to-task) establishes a streaming connection to receive updates for an existing task.

```curl
 curl -X POST \
  "https://yourdomain.retool.com/api/agents/a2a/agent_id/v1/tasks/task_id:subscribe" \
  -H 'Content-Type: application/json' \
  -H 'X-Api-Key: retool_wk_#####'
```

```json
{
   "kind":"status-update",
   "taskId":"054c93a8-b0ed-49ea-915d-418e615cb7b4",
   "contextId":"23a617f6-f7a7-40a8-955c-f17faad5c954",
   "status":{
      "state":"completed",
      "message":{
         "role":"agent",
         "parts":[
            {
               "kind":"text",
               "text":"Why don't skeletons fight each other? \n\nBecause they don't have the guts!"
            }
         ],
         "messageId":"8dc8c544-f6d9-49a8-b9e3-cecf2433f23d",
         "contextId":"23a617f6-f7a7-40a8-955c-f17faad5c954",
         "taskId":"054c93a8-b0ed-49ea-915d-418e615cb7b4",
         "kind":"message"
      }
   },
   "final":true
}"%"
```

### Cancel task
[Cancel task](https://a2a-protocol.org/dev/specification/#315-cancel-task) requests the cancellation of an ongoing task. The server will attempt to cancel the task, but success is not guaranteed (e.g., the task might have already completed or failed, or cancellation might not be supported at its current stage).

```curl
 curl -X POST \
  "https://yourdomain.retool.com/api/agents/a2a/agent_id/v1/tasks/task_id:cancel" \
  -H 'Content-Type: application/json' \
  -H 'X-Api-Key: retool_wk_#####'
```

```json
{
   "success":false,
   "message":"workflow execution already completed"
}"%"
```

---

## The Current User object

The `current_user` object can be populated with the details of an admin user or the currently authenticated user. The assignment of the `current_user` object depends on how the agent is invoked. In general, the `current_user` is assigned to the currently authenticated user. However, when you trigger an agent from a workflow, use a workflow as a tool, or trigger an agent by an unknown email, the `current_user` is populated as an admin user.

Refer to the following table for more information about who is assigned to the `current_user` role:

| Trigger                          | Description                                                                                             | Assigned to `current_user`          |
| -------------------------------- | ------------------------------------------------------------------------------------------------------- | ----------------------------------- |
| Agent as tool                    | Triggered by another [agent as a tool](../guides/tools/use-agent-as-tool.mdx).                          | The `current_user` of the triggering agent.               |
| Agent block in custom tool       | Triggered by another agent as a block in a [custom tool](../guides/tools/create-custom-tools.mdx).      | The `current_user` of the triggering agent.              |
| App                              | Triggered by the [Agent Chat](../../apps/reference/components/special-inputs/agent-chat.mdx) component. | The `current_user` of the app. [More information](../../apps/reference/objects/current-user.mdx).      |
| Workflow                         | Triggered by an [Agent block](../../workflows/guides/blocks/agent/index.mdx) in a workflow.                   | The `current_user` of the workflow, which is an admin user. [More information](../../workflows/reference/objects/current-user.mdx). |
| Chat                             | Triggered by the [Chat tab](../quickstart.mdx#chats) in Retool Agents.                                  | The user of the chat.   |
| Email trigger from known user    | Triggered by an email from a Retool user with access to the agent.                                                    | The Retool user who sent the email. |
| Email trigger from unknown email | Triggered by an email that cannot be matched with a Retool user who has access to the agent.            | An admin user.               |

Reference the following examples:
- A workflow uses the Invoke Agent block to call an agent named Vacation Plan, and Vacation Plan calls another agent named Get Weather. The `current_user` of the workflow is an admin user. Therefore, the `current_user` objects of Vacation Plan and Get Weather are both also populated with an admin user.
- An agent called Marketing Assistant is called using the Agent Chat app component. Marketing Assistant calls another agent named Discount Decider. The `current_user` of Marketing Assistant and Discount Decider are both populated with the app's authenticated user.

## Properties

---

## Agents glossary

import SharedGlossary from '../../_partials/_glossary.mdx';

---

## Retool Agents reference



---

## A2A tutorial

To trigger a Retool agent from an external agent via the Agent-to-agent (A2A) protocol, ensure your agent has the necessary configuration and tools to work with your external agent. 

This tutorial walks you through the process to stand up an A2A-compliant agent with [Crew AI](https://docs.crewai.com/en/learn/a2a-agent-delegation) and use A2A to trigger a web research agent.

## 1. Create a Retool agent
Your agent will need a web browsing or URL fetching tool. You can follow the instructions in the [Agents tutorial](../tutorials/agents-tutorial.mdx), or use the instructions below to create a minimal agent example. 
1. Select the **Agents** tab in the top navigation bar.
2. From the **All agents** page, click the **+ Agent** button.
3. Select **Start from scratch** and click **Create**.
4. In the **Agent name** field, enter `A2A test`.
5. In the **Description** field, enter `Retool A2A web research assistant` and click **Create**.
6. On the **Agent Configuration** page, click **Add Tool** and add the **Search Web** and **Get Webpage Content** tools.

:::note
You may be required to set up a resource for web searching if you do not already have one created. Refer to the [Connect to Tavily Web Search](../../data-sources/guides/connect/tavily) guide for detailed instructions.
:::

## 2. Turn on A2A
On your agent's **Configuration** page:
1. Click the **A2A** trigger. 
2. Toggle the **A2A** switch on. 

You will need the **Endpoint** and **API key** for the next step. Refer to the [Set up an A2A trigger](../guides/triggers/trigger-with-a2a#enable-the-a2a-trigger) guide for more information. 

## 3. Create an external agent
The example below uses Crew AI with A2A to create a web research assistant that delegates web research to the Retool agent.

To set up Crew AI, from your terminal or a command line: 
1. [Optional] Run `brew install python@3.12`. 
    :::note 
    You may need to use Homebrew to install a [Python version compatible with Crew AI](https://docs.crewai.com/en/installation) if you are running an older version of Python. This tutorial uses Python 3.12 as an example. If you are already running a version between 3.10 and the current version, you can skip this step. 
    :::
2. Create your virtual environment:  
    ```bash
    python3.12 -m venv venv
    source venv/bin/activate
    ```
3. Install and set up version 1.6.1 of Crew AI. You will need to create an OpenAI API key if you do not have one already. 
    ```bash
    pip install "crewai[a2a]==1.6.1"
    export OPENAI_API_KEY="sk-your-key"
    ```
4. Using your preferred text editor or IDE, create a new Python file. Name the file `my_script.py` and copy and paste in the below code.

    ```python title="my_script.py"

    import sys

    from crewai import Agent, Crew, Task
    from crewai.a2a import A2AConfig
    from crewai.a2a.auth import APIKeyAuth

    # =============================================================================
    # CONFIGURATION - Replace these with your Retool agent details
    # =============================================================================

    RETOOL_AGENT_ENDPOINT = "https://your-org.retool.com/api/agents/a2a/YOUR-AGENT-UUID/.well-known/agent-card.json"
    RETOOL_API_KEY = "retool_wk_your_api_key_here"

    # =============================================================================

    def create_crew(topic: str) -> Crew:
        """Create a simple web research crew."""

        research_coordinator = Agent(
            role="Research Coordinator",
            goal="Gather comprehensive information on topics by delegating web research tasks",
            backstory="""You are an expert research coordinator. You excel at breaking down 
            research questions and delegating web browsing tasks to gather information. 
            You synthesize findings into clear, actionable summaries.""",
            llm="gpt-4o",
            verbose=True,
            a2a=A2AConfig(
                endpoint=RETOOL_AGENT_ENDPOINT,
                timeout=300,
                max_turns=10,
                trust_remote_completion_status=True,
                auth=APIKeyAuth(
                    api_key=RETOOL_API_KEY,
                    location="header",
                    name="X-API-Key",
                ),
            ),
        )

        research_task = Task(
            description=f"""Research the following topic thoroughly: {topic}
            
            Use your web browsing capabilities to:
            1. Find recent and relevant information about this topic
            2. Identify key facts, trends, and insights
            3. Note any important sources or references
            
            Provide a comprehensive summary of your findings.""",
            expected_output="""A detailed research summary including:
            - Key findings and facts
            - Recent trends or developments
            - Important sources referenced
            - Actionable insights""",
            agent=research_coordinator,
        )

        return Crew(
            agents=[research_coordinator],
            tasks=[research_task],
            verbose=True,
        )

    def main():
        # Get topic from command line or use default
        topic = (
            " ".join(sys.argv[1:])
            if len(sys.argv) > 1
            else "latest developments in AI agents"
        )

        print(f"\n{'='*60}")
        print("Web Research Assistant")
        print(f"{'='*60}")
        print(f"Topic: {topic}\n")

        crew = create_crew(topic)
        result = crew.kickoff()

        print(f"\n{'='*60}")
        print("RESEARCH COMPLETE")
        print(f"{'='*60}")
        print(result.raw)

    if __name__ == "__main__":
        main()
    ```
5. Replace the `RETOOL_AGENT_ENDPOINT` and `RETOOL_API_KEY` with the values provided in your A2A trigger (in [Step 2](./a2a-tutorial#2-turn-on-a2a)) and save the file. 

## 4. Trigger your agent with the external agent
From your terminal, run `python my_script.py "What are the top 5 AI models in 2025"` to view the external agent interacting with your Retool agent. 

```python
((venv) )  yourname@Retool  ~/repo/folder  python my_script.py "What are the top AI models of 2025"

============================================================
Web Research Assistant
============================================================
Topic: What are the top AI models of 2025

╭──────────────────────────────────────────────────────────────────────────────────── Crew Execution Started ─────────────────────────────────────────────────────────────────────────────────────╮
│                                                                                                                                                                                                 │
│  Crew Execution Started                                                                                                                                                                         │
│  Name: crew                                                                                                                                                                                     │
│  ID: id_number                                                                                                                                                       │
│  Tool Args:                                                                                                                                                                                     │
│                                                                                                                                                                                                 │
│                                                                                                                                                                                                 │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯

🚀 Crew: crew
└── 📋 Task: task_id_number
    Status: Executing Task...
╭─────────────────────────────────────────────────────────────────────────────────────── 🤖 Agent Started ────────────────────────────────────────────────────────────────────────────────────────╮
│                                                                                                                                                                                                 │
│  Agent: Research Coordinator                                                                                                                                                                    │
│                                                                                                                                                                                                 │
│  Task: Research the following topic thoroughly: What are the top AI models of 2025                                                                                                              │
│                                                                                                                                                                                                 │
│          Use your web browsing capabilities to:                                                                                                                                                 │
│          1. Find recent and relevant information about this topic                                                                                                                               │
│          2. Identify key facts, trends, and insights                                                                                                                                            │
│          3. Note any important sources or references                                                                                                                                            │
│                                                                                                                                                                                                 │
│          Provide a comprehensive summary of your findings.                                                                                                                                      │
│                                                                                                                                                                                                 │
│  IMPORTANT: You have the ability to delegate this task to remote A2A agents.                                                                                                                    │
│                                                                                                                                                                                                 │
│                                                                                                                                                                                                 │
│                                                                                                                                                                           │
│                                                                                                                                                                                                 │
│  {                                                                                                                                                                                              │
│    "description": "Retool A2A web research assistant",                                                                                                                                          │
│    "skills": [                                                                                                                                                                                  │
│      {                                                                                                                                                                                          │
│        "description": "Perform a web search and retrieve a list of relevant results based on a natural language query.",                                                                        │
│        "id": "tool_id_number",                                                                                                                                            │
│        "name": "Search Web",                                                                                                                                                                    │
│        "tags": []                                                                                                                                                                               │
│      },                                                                                                                                                                                         │
│      {                                                                                                                                                                                          │
│        "description": "Fetch the contents of a webpage and extract the main text content for analysis or processing.",                                                                          │
│        "id": "tool_id_number",                                                                                                                                            │
│        "name": "Get Webpage Content",                                                                                                                                                           │
│        "tags": []                                                                                                                                                                               │
│      }                                                                                                                                                                                          │
│    ],                                                                                                                                                                                           │
│    "url": "https://your-org.retool.com/api/agents/a2a/YOUR-AGENT-UUID/jsonrpc"                                                                                            │
│  }                                                                                                                                                                                              │
│                                                                                                                                                                                                 │
│                                                                                                                                                                          │
│                                                                                                                                                                                                 │
│                                                                                                                                                                                                 │
│                                                                                                                                                                      │
│                                                                                                                                                                                                 │
│                                                                                                                                                                     │
│                                                                                                                                                                                                 │
│                                                                                                                                                                                                 │
│                                                                                                                                                                                                 │
│                                                                                                                                                                                                 │
│                                                                                                                                                                                                 │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯

🚀 Crew: crew
└── 📋 Task: task_id_number
    Status: Executing Task...
    └── 🔗 Delegating to A2A Agent (https://your-org.retool.com/api/agents/a2a/YOUR-AGENT-UUID/.well-known/agent-card.json)
╭─────────────────────────────────────────────────────────────────────────────────────── 🔗 A2A Delegation ───────────────────────────────────────────────────────────────────────────────────────╮
│                                                                                                                                                                                                 │
│  A2A Delegation Started                                                                                                                                                                         │
│                                                                                                                                                                                                 │
│  Agent ID: https://your-org.retool.com/api/agents/a2a/YOUR-AGENT-UUID/.well-known/agent-card.json                                                                         │
│  Endpoint: https://your-org.retool.com/api/agents/a2a/YOUR-AGENT-UUID/.well-known/agent-card.json                                                                         │
│                                                                                                                                                                                                 │
│  Task Description:                                                                                                                                                                              │
│  Please perform a web search to find recent and relevant information about the top AI models of 2025. I'm interested in identifying key facts, trends, insights, and important sources related  │
│  to this...                                                                                                                                                                                     │
│                                                                                                                                                                                                 │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯

🚀 Crew: crew
└── 📋 Task: task_id_number
    Status: Executing Task...
    ├── 🔗 Delegating to A2A Agent (https://your-org.retool.com/api/agents/a2a/YOUR-AGENT-UUID/.well-known/agent-card.json)
    └── 💬 Multiturn A2A Conversation (https://your-org.retool.com/api/agents/a2a/YOUR-AGENT-UUID/.well-known/agent-card.json)
        └── 💬 Turn 1
            ├── user 👤 :   "Please perform a web search to find recent and relevant information about the top AI models of 2025...."
            └── A2A test 🤖:  ✓ "Here are the most recent and relevant sources about the top AI models of 2025, along with key facts,..."
╭──────────────────────────────────────────────────────────────────────────────────────── ✅ A2A Success ─────────────────────────────────────────────────────────────────────────────────────────╮
│                                                                                                                                                                                                 │
│  A2A Delegation Completed                                                                                                                                                                       │
│                                                                                                                                                                                                 │
│  Result:                                                                                                                                                                                        │
│  Here are the most recent and relevant sources about the top AI models of 2025, along with key facts, trends, and insights:                                                                     │
│                                                                                                                                                                                                 │
│  - [Top AI Models Ranked (November 2025) – Synergy Online](https://www.synergyonline.com/post/top-ai-models-ranked-november-2025-the-executive-perspective):                                    │
│    - Highlights ChatGPT-5, Claude 4.5, Perplexity AI, Gemini 2.5, DeepSeek, and Grok 4 as leading models.                                                                                       │
│    - Discusses how organizations blend models for creativity, compliance, real-time insights, and operational flo...                                                                            │
│                                                                                                                                                                                                 │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
🚀 Crew: crew
└── 📋 Task: task_id_number
    Assigned to: Research Coordinator
    Status: ✅ Completed
    ├── 🔗 Delegating to A2A Agent (https://your-org.retool.com/api/agents/a2a/YOUR-AGENT-UUID/.well-known/agent-card.json)
    └── 💬 Multiturn A2A Conversation (https://your-org.retool.com/api/agents/a2a/YOUR-AGENT-UUID/.well-known/agent-card.json)
        └── 💬 Turn 1
            ├── user 👤 :   "Please perform a web search to find recent and relevant information about the top AI models of 2025...."
            └── A2A test 🤖:  ✓ "Here are the most recent and relevant sources about the top AI models of 2025, along with key facts,..."
╭──────────────────────────────────────────────────────────────────────────────────────── Task Completion ────────────────────────────────────────────────────────────────────────────────────────╮
│                                                                                                                                                                                                 │
│  Task Completed                                                                                                                                                                                 │
│  Name: task_id_number                                                                                                                                                     │
│  Agent: Research Coordinator                                                                                                                                                                    │
│  Tool Args:                                                                                                                                                                                     │
│                                                                                                                                                                                                 │
│                                                                                                                                                                                                 │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯

============================================================
RESEARCH COMPLETE
============================================================
Here are the most recent and relevant sources about the top AI models of 2025, along with key facts, trends, and insights:

- [Top AI Models Ranked (November 2025) – Synergy Online](https://www.synergyonline.com/post/top-ai-models-ranked-november-2025-the-executive-perspective):
  - Highlights ChatGPT-5, Claude 4.5, Perplexity AI, Gemini 2.5, DeepSeek, and Grok 4 as leading models.
  - Discusses how organizations blend models for creativity, compliance, real-time insights, and operational flow.

- [10 Most Popular AI Models of 2025 – Orca Security](https://orca.security/resources/blog/most-popular-ai-models-2025/):
  - Lists the 10 most widely adopted AI models in cloud environments, noting a sharp increase in organizational AI adoption (from 56% in 2024 to 84% in 2025).
  - OpenAI models are particularly dominant in cloud usage.

- [The Best AI Models for Your Business (March 2025) – FlexOS](https://www.flexos.work/learn/best-ai-models):
  - Focuses on business integration, with Gemini Pro and Copilot enhancing Google Workspace and Microsoft 365.
  - Emphasizes custom AI workflows and team collaboration.

- [Top 9 Large Language Models as of December 2025 – Shakudo](https://www.shakudo.io/blog/top-9-large-language-models):
  - Provides a detailed ranking and analysis of the top large language models, including use cases across industries.
  - Offers white papers and case studies for deeper insights.

- [LLM Leaderboard 2025 – Vellum AI](https://www.vellum.ai/llm-leaderboard):
  - Features benchmark results for Claude Sonnet 4.5, Grok 4, and other leading models, with data on adaptability and performance across tasks.

- [YouTube: I Tried Every AI So You Don't Have To — Here are the Best of 2025](https://www.youtube.com/watch?v=-AJoByRGkgU):
  - Video review comparing ChatGPT, Claude, Gemini, and Grok, highlighting their strengths and weaknesses in real-world scenarios.

- [Reddit: Which AI model has the freshest, most reliable knowledge?](https://www.reddit.com/r/AgentsOfAI/comments/1mqxhhj/which_ai_model_has_the_freshest_most_reliable/):
  - Community discussion on knowledge cutoffs and real-time capabilities, with mentions of Claude Opus 4.1 and web search integration.

**Trends & Insights:**
- ChatGPT-5, Claude 4.5, Gemini 2.5, Perplexity AI, and Grok 4 are consistently named as leading models in 2025.
- Organizations are increasingly combining multiple models for specialized tasks (reasoning, real-time data, creativity).
- AI adoption in business and cloud environments is rapidly increasing, with OpenAI models leading in popularity.
- Customization, real-time knowledge, and seamless integration into business tools are key differentiators among top models.

These sources provide a comprehensive overview of the current AI model landscape, including rankings, business applications, and technical benchmarks.
╭─────────────────────────────────────────────────────────────────────────────────── Trace Batch Finalization ────────────────────────────────────────────────────────────────────────────────────╮
│ ✅ Trace batch finalized with session ID: id_number                                                                                                                  │
│                                                                                                                                                                                                 │
│ 🔗 View here: https://app.crewai.com/crewai_plus/ephemeral_trace_batches/id_number?access_code=TRACE-trace_id                                                      │
│ 🔑 Access Code: id_number                                                                                                                                                               │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────── Crew Completion ────────────────────────────────────────────────────────────────────────────────────────╮
│                                                                                                                                                                                                 │
│  Crew Execution Completed                                                                                                                                                                       │
│  Name: crew                                                                                                                                                                                     │
│  ID: id_number                                                                                                                                                       │
│  Tool Args:                                                                                                                                                                                     │
│  Final Output: Here are the most recent and relevant sources about the top AI models of 2025, along with key facts, trends, and insights:                                                       │
│                                                                                                                                                                                                 │
│  - [Top AI Models Ranked (November 2025) – Synergy Online](https://www.synergyonline.com/post/top-ai-models-ranked-november-2025-the-executive-perspective):                                    │
│    - Highlights ChatGPT-5, Claude 4.5, Perplexity AI, Gemini 2.5, DeepSeek, and Grok 4 as leading models.                                                                                       │
│    - Discusses how organizations blend models for creativity, compliance, real-time insights, and operational flow.                                                                             │
│                                                                                                                                                                                                 │
│  - [10 Most Popular AI Models of 2025 – Orca Security](https://orca.security/resources/blog/most-popular-ai-models-2025/):                                                                      │
│    - Lists the 10 most widely adopted AI models in cloud environments, noting a sharp increase in organizational AI adoption (from 56% in 2024 to 84% in 2025).                                 │
│    - OpenAI models are particularly dominant in cloud usage.                                                                                                                                    │
│                                                                                                                                                                                                 │
│  - [The Best AI Models for Your Business (March 2025) – FlexOS](https://www.flexos.work/learn/best-ai-models):                                                                                  │
│    - Focuses on business integration, with Gemini Pro and Copilot enhancing Google Workspace and Microsoft 365.                                                                                 │
│    - Emphasizes custom AI workflows and team collaboration.                                                                                                                                     │
│                                                                                                                                                                                                 │
│  - [Top 9 Large Language Models as of December 2025 – Shakudo](https://www.shakudo.io/blog/top-9-large-language-models):                                                                        │
│    - Provides a detailed ranking and analysis of the top large language models, including use cases across industries.                                                                          │
│    - Offers white papers and case studies for deeper insights.                                                                                                                                  │
│                                                                                                                                                                                                 │
│  - [LLM Leaderboard 2025 – Vellum AI](https://www.vellum.ai/llm-leaderboard):                                                                                                                   │
│    - Features benchmark results for Claude Sonnet 4.5, Grok 4, and other leading models, with data on adaptability and performance across tasks.                                                │
│                                                                                                                                                                                                 │
│  - [YouTube: I Tried Every AI So You Don't Have To — Here are the Best of 2025](https://www.youtube.com/watch?v=-AJoByRGkgU):                                                                   │
│    - Video review comparing ChatGPT, Claude, Gemini, and Grok, highlighting their strengths and weaknesses in real-world scenarios.                                                             │
│                                                                                                                                                                                                 │
│  - [Reddit: Which AI model has the freshest, most reliable knowledge?](https://www.reddit.com/r/AgentsOfAI/comments/1mqxhhj/which_ai_model_has_the_freshest_most_reliable/):                    │
│    - Community discussion on knowledge cutoffs and real-time capabilities, with mentions of Claude Opus 4.1 and web search integration.                                                         │
│                                                                                                                                                                                                 │
│  **Trends & Insights:**                                                                                                                                                                         │
│  - ChatGPT-5, Claude 4.5, Gemini 2.5, Perplexity AI, and Grok 4 are consistently named as leading models in 2025.                                                                               │
│  - Organizations are increasingly combining multiple models for specialized tasks (reasoning, real-time data, creativity).                                                                      │
│  - AI adoption in business and cloud environments is rapidly increasing, with OpenAI models leading in popularity.                                                                              │
│  - Customization, real-time knowledge, and seamless integration into business tools are key differentiators among top models.                                                                   │
│                                                                                                                                                                                                 │
│  These sources provide a comprehensive overview of the current AI model landscape, including rankings, business applications, and technical benchmarks.                                         │
│                                                                                                                                                                                                 │
│                                                                                                                                                                                                 │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────
```

The output from the LLM and tool calls will be displayed in your agent's [log output](../quickstart.mdx#logs), or the [monitoring page](../quickstart.mdx#monitor). 

  A2A-triggered agent run

## Wrap up
You should now be able to call an agent in Retool from an external agent using A2A. 

To continue learning about A2A, explore the following resources:

* [Agent-to-agent communication](../concepts/a2a.mdx)
* [What is A2A Protocol?](https://a2a-protocol.org/dev/)
* [Set up an A2A trigger](../guides/triggers/trigger-with-a2a.mdx)
* [A2A endpoints](../reference/a2a-endpoints.mdx)

---

## Retool Agents tutorial

import Connectsvg from "/img/icon-packs/bold/interface-geometric-circle-alternate.svg";

[Retool Agents](../concepts/overview) enable you to create AI agents that can think, reason, and call tools independently. They take actions and complete or delegate tasks that you assign them during configuration.

This tutorial walks you through the process for building an agent that aggregates new Retool changelog posts and release notes for a specified date range and sends you a digest email.

## 1. Create a new agent
To create a new agent, sign in to your Retool organization, and select the **Agents** tab in the top navigation bar.

1. From the **All agents** page, click the **+ Agent** button.
2. Select **Start from scratch** and click **Create**.
3. In the **Agent name** field, enter `Retool Digest`.
4. In the **Description** field, enter `Retool release notes and changelog updates` and click **Create**.

export function ArcadeEmbed_CN() {
  return (
    
      
    
  )
}

## 2. Configure your agent

The **Configuration** tab is where you input the **Instructions** your agent uses to help the AI **Model** you select think and reason as it calls tools.

:::note
When creating a new agent, you can pass references to [current_user](../reference/current-user.mdx), `{{ timezone }}`, and `{{ new Date() }}` into the instructions using embedded expressions. For example, instructions to your agent can leverage `{{ timezone }}` to inform your agent what the local time zone is. This embedded expression evaluates to the [IANA time zone name](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Temporal/ZonedDateTime#time_zones_and_offsets).
:::

For this tutorial, replace the default text in the **Instructions** field with the following:

```
You are an assistant that provides Retool updates. Summarize all of the new release notes and changelog entries at Retool for a given date range and send an email.

1. Collect and summarize:
- Release notes
- Changelog entries

2. Format the email digest as follows:
The subject line: Retool Updates

The Date Range provided by the user.

The body of the email should contain the following sections:
📦 New Releases
- Provide a bulleted list of updates for Edge and Stable Release Notes and include direct links to the full content.
- Links for Edge Release Notes should link to this page: https://docs.retool.com/releases/edge/all
- Links for Stable Release Notes should link to this page: https://docs.retool.com/releases/stable/all
- Each bulleted list item should have a title, a summary of the release notes, and the date the release notes were published.
- If there are no release notes for Edge or Stable for a given week, say `No new items this week`.

📝 Changelog
- Provide a bulleted list of changelog entries, and include direct links to the full content.
- Each bulleted list item should have a title, a summary of changelog item, and the date of the changelog.
- If there are no changelog entries for a given week, say `No new items this week`.

3. Always include:
- Links to the Release Notes: https://docs.retool.com/releases and the Changelog: https://docs.retool.com/changelog at the bottom of every email

4. Always send an email to {{ current_user.email }}

Keep summaries concise and highlight breaking changes or major features.
```
Retool's [Best Practices](../concepts/best-practices) page offers additional guidance about creating clear instructions for your agent to follow.

In the **Model** setting, select the AI model you want to use. For this tutorial, use the Retool-managed Anthropic model: `Claude 3.7 Sonnet`. Results may differ if you select a different model.

You must have [Retool AI](../../../queries/concepts/actions) enabled, and the **Retool-managed Anthropic key** must be enabled by an admin of your organization for Anthropic models to appear in the model selection dropdown.

:::note
You can interact with [AI models](../../data-sources/concepts/models.mdx) using either a Retool-managed key or with your own credentials. Retool recommends using Retool-managed keys for testing and development purposes.

:::

## 3. Connect tools to your agent
There are several kinds of tools that Retool Agents can consume and use. For this tutorial, you're going to add prebuilt tools, and create custom tools.

For more information about tools, refer to the [Tools](../concepts/tools) conceptual guide.

:::note
You can also chat with the **Config Assistant**, which helps you configure your agent by suggesting tools and automatically populating your configuration with them if you accept the suggestion. Depending on the AI model used, you may have varying results, and automatically generated tools may need to be refined.
:::

### Add core tools
Core tools are created by Retool to provide you out-of-the-box tool functionality for common tasks, like updating a Google Calendar or Executing Code.

To add core tools:
1. Click **Add Tool** and click the **+** on the **Send Email** tool and the **Get Webpage Content** tool. A green check mark will appear to notify you that the tools have been selected.
2. Click the **Add 2 tools** button. The number changes depending on how many tools are selected.
3. The **Send Email** and **Get Webpage Content** tools are displayed in the **Tools** section of the **Configuration** tab.

export function ArcadeEmbed_CT() {
  return (
    
      
    
  )
}

### Convert core tool to custom tool
When you edit a core tool, Retool Agents automatically converts it to a custom tool, and you can edit the **Function Logic**. You will be prompted with a warning message when converting a core tool.

1. Click  to expand the **Get Webpage Content** tool, and click the **Edit** () icon.
2. Click **Continue** on the warning message that pops up.
3. Select **Edit function** in the **Function Logic** section.
4. In the  block labeled `getContent`, replace `{{ params.url }}` with the Edge Release Notes text-only URL: `https://docs.retool.com/releases/edge/all`.
5. Add another  block in between `getContent` and `parseHTML`. Choose the **REST API** resource query type, and `GET` the Stable Release Notes text-only URL: https://docs.retool.com/releases/stable/all.
6. Replace the JavaScript in the `parseHTML` block with the following:
    ```javascript
    function cleanHtmlWithHeaderLinks(rawHtml) {
    // 1. Remove , , ,  and their content
    let html = rawHtml
        .replace(//gi, "")
        .replace(//gi, "");

    // 2. Find headers and replace with markdown links
    // Matches Bar or Bar
    html = html.replace(/]*)>([\s\S]*?)/gi, (m, level, attrs, content) => {
        // Try to extract id attribute
        let idMatch = attrs.match(/\sid=["']?([^\s"'>]+)["']?/i);
        let id = idMatch ? idMatch[1] : null;
        // If no id, generate from content
        let text = content.replace(/]+>/g, '').trim();
        let anchor = id || text.toLowerCase().replace(/[^\w\- ]+/g, '').replace(/\s+/g, '-');
        // Markdown header link: [Header Text](#anchor)
        return `\n[${text}](#${anchor})\n`;
    });

    // 3. Mark block-level tags as line breaks
    const blockTags = [
        "address","article","aside","blockquote","canvas","dd","div","dl","dt","fieldset",
        "figcaption","figure","footer","form","hr","li","main","nav",
        "noscript","ol","p","pre","section","table","tfoot","ul","video","br","tr","td","th"
    ];
    const blockRegex = new RegExp(`]*>`, "gi");
    html = html.replace(blockRegex, "\n");

    // 4. Strip all remaining tags
    html = html.replace(/]+>/g, "");

    // 5. Decode numeric entities (decimal & hex)
    html = html
        .replace(/&#(\d+);/g, (_, dec) => String.fromCharCode(dec))
        .replace(/&#x([0-9A-Fa-f]+);/g, (_, hex) => String.fromCharCode(parseInt(hex, 16)));

    // 6. Decode common named entities
    const entityMap = {
        nbsp: " ", lt: "", amp: "&", quot: '"', apos: "'",
        mdash: "-", ndash: "-", hellip: "…", rsquo: "’", lsquo: "‘",
        ldquo: "“", rdquo: "”"
    };
    html = html.replace(/&([a-zA-Z]+);/g, (_, name) =>
        name in entityMap ? entityMap[name] : `&${name};`
    );

    // 7. Collapse whitespace and blank lines
    const text = html
        .split("\n")
        .map(line => line.replace(/\s+/g, " ").trim())
        .filter(line => line.length > 0)
        .join("\n");

    // 8. Merge short lines
    const threshold = 80;
    const lines = text.split("\n");
    const merged = [];

    for (const line of lines) {
        const trimmed = line.trim();
        if (!trimmed) continue;

        if (merged.length === 0) {
        merged.push(trimmed);
        } else {
        const prev = merged[merged.length - 1];
        if (trimmed.length 
      
    
  )
}

### Create a custom tool
In this section, you'll create a custom tool to fetch the Changelog JSON feed. You can make a custom tool by creating a function. For more information about functions, refer to the [Functions](../../../workflows/guides/functions) page.

1. From the **Configuration** tab, click **Add Tool**.
2. Select **Create new custom tool**.
3. In the **Name** setting, enter `fetchFromChangelog`
4. In the **Description** setting, enter `Searches for and filters changelog entries by user-provided date range.`
5. Click **Add parameter**  twice. Click  to update it. Configure the following parameters:
    | Name          | Type         | Description                                                             | Required |
    |---------------|--------------|------------------------------------------------------------------------ | ---------|
    | `startDate`   | String       | The start date (inclusive) for filtering entries, in YYYY-MM-DD format. | Yes      |
    | `endDate`     | String       | The end date (inclusive) for filtering entries, in YYYY-MM-DD format.   | Yes      |

6. Select **Edit function** in the **Function Logic** section.
7. Delete the `code1` block. Click and drag  from the Parameters block. Create a  block with the **REST API** resource type to `GET` the JSON feed for the Changelog: `https://docs.retool.com/changelog/feed.json`. Name it `getChangelogEntries`.
    :::note
    You can also message the **Function Generator** and @ mention the **Changelog** resource. The function generator will automatically create the function and the parameters for your tool, but depending on the model you use you may have varying results and need to troubleshoot the code that's generated.
    :::
8. From `getChangelogEntries`, click and drag  to add a  block. Replace the default code with the following JavaScript:
    ```javascript
    return getChangelogEntries.data.items
    ```
9. From the  block, click and drag  to add a  block with the following **Expression** to use the moment() date library to match any posts within the specified range:
    ```json
    moment(value.date_modified).isBetween(moment(params.startDate), moment(params.endDate))
    ```
10. From the  block, click and drag  to add a  block with a **Status code** of `200` and the following **Return body**:
    ```json
    filter1.data
    ```
11. Click **Done**.
12. On the **Edit Tool** page, click **Save**.

export function ArcadeEmbed_custom() {
  return (
    
      
    
  )
}

## 4. Deploy your agent
Now that you've configured your first agent, it's time to deploy it.

1. On the **Configuration** tab, click the **Deploy** button.
2. Select the **Major** version radio button and add a **Description**.
3. Click **Deploy**.

## 5. Test your agent
To test your agent and ensure it's working as intended, chat with it.
1. Select the **Chats** tab.
2. Message your agent with the following, changing the date as needed. Ensure you include the correct year.
    ```
    What's my weekly digest for April 28th through May 2nd, 2025?
    ```
3. Your agent will display thoughts and provide *Tool chips* in the chat thread and in the side bar as it runs so you can see which tools were called, the parameters that used, and the result. You can toggle **Hide** or **Show thinking** for the tool chips in the side bar, depending on your preference.
4. When your agent has finished running and provided a final answer, you should have an email in your inbox with your weekly digest, and it will also display the results in the message thread, and should look similar to the below.
    ```
    I've sent your Retool Weekly Digest for April 28 - May 2, 2025 to your email. The digest includes:

    One Edge version released on April 30, 2025

    Five changelog entries covering new features and improvements, including:
    Record user sessions with Fullstory (May 1)
    Backend runtime upgrade to Node.js v20.18 (April 30)
    Disable catch-up commits in Source Control (April 29)
    Multi-step functions now generally available (April 28)
    Error reporting for Retool Workflows (April 28)

    Your digest has been delivered successfully. Let me know if you need anything else!
    ```
5. To make your thread public and share it with another user, click **Share thread** and then click **Publish link**.

You can continue chatting with your agent, and check the **Logs** to test any modifications you make to the tools or agent configuration, or you can revert to previous deployed versions from the version history displayed next to the name of your agent.

## Wrap up
At this point, you should be able to configure an agent, add prebuilt and custom tools to an agent, deploy an agent, and chat with an agent to test how it performs.

To continue learning about agents, explore the following resources:

* [Retool Agents](../concepts/overview)
* [Best Practices](../concepts/best-practices)
* [FAQ](../concepts/faq)
* [AI models](../../../data-sources/concepts/models)
* [Tools](../guides/tools)

---

## Retool Agents tutorials



---

## AI in app building

You can use AI in various ways throughout the app building and editing experience.

:::note

To use the following AI features in Retool, **Retool AI** must be enabled in **Settings** > **AI**. On this page, admins can also toggle each individual feature on or off.

:::

## Assist

_Assist_ is an app generation assistant within the [app IDE](./ide.mdx) that helps you interact with and build apps. Assist can perform the following tasks:

- Generate apps from scratch.
- Edit existing apps.
- Tell you about the purpose and functionality of an app you're editing.
- Answer questions about Retool.

[Learn more about Assist](../guides/assist/index.mdx).

## Ask AI

_Ask AI_ is an assistant that is scoped specifically to queries.

import Ask from '../../_shared/_ask-ai.mdx';

[Read more about Ask AI](../../queries/concepts/ask.mdx).

## AI-Generated README

Instead of manually writing a README, you can use AI to generate one. The LLM evaluates the purpose and functionality of the current app and writes a detailed and fully-formatted README that is added as a page in your app.

[Read more about AI README generation](../guides/app-management/app-documentation.mdx).
 
## Queries and components

You can also use AI as part of your app functionality, enabling users of your app to interact with AI.

### AI Actions

import Actions from '../../_shared/_actions.mdx'

[Read more about AI actions](../../queries/concepts/actions.mdx).

### Components

import Chat from '../../_shared/_chat-components.mdx';

[Read more about the chat components](../guides/forms-inputs/chats/index.mdx).

---

## Web app best practices

import Shared from '/docs/_shared/_app-performance-best-practices.mdx';
import Modules from '/docs/_shared/_module-best-practices.mdx';

## Best practices for using modules

---

## Command Palette

import Shared from '/docs/_shared/_command-palette.mdx';

---

## Components

Retool's components are functionally similar to React components. They are designed to be modular and reusable, and have internal state. Each component is represented by a JavaScript object that contains all of its properties and their current values. The following is an example of a Text Input component:

```json
{
  "pluginType": "TextInputWidget2",
  "spellCheck": false,
  "readOnly": false,
  "iconAfter": "",
  "showCharacterCount": false,
  "autoComplete": false,
  "maxLength": null,
  "hidden": false,
  "customValidation": "",
  "patternType": "",
  "hideValidationMessage": false,
  "textBefore": "",
  "value": "Jenny Rosen",
  "_validate": false,
  "required": false,
  "disabled": false,
  "minLength": null,
  "pattern": "",
  "validationMessage": "",
  "textAfter": "",
  "showInEditor": false,
  "showClear": false,
  "tooltipText": "",
  "labelAlign": "left",
  "id": "textInput1",
  "formDataKey": "textInput1",
  "labelCaption": "Enter your username",
  "labelWidth": 33,
  "autoFill": "",
  "placeholder": "Enter value",
  "label": "Username",
  "labelWidthUnit": "%",
  "invalid": false,
  "iconBefore": "",
  "inputTooltip": "",
  "autoCapitalize": "none",
  "loading": false,
  "labelPosition": "left",
  "labelWrap": false,
  "maintainSpaceWhenHidden": false
}
```

Similar components often share characteristics, allowing you to switch a component from one to another with little to no change. This makes it possible to switch components as your needs grow without having to rebuild your UI from scratch.

## Configuration and properties

You can [write JavaScript](../../../queries/quickstart.mdx) almost anywhere in Retool using `{{ }}` and component property values are available globally. This makes it possible to reference other properties when configuring a value.

For example, you can configure a [Text](https://retool.com/components/text) component to display the value of a [Text Input](https://retool.com/components/text-input) component with `{{ textInput1.value }}` in the app IDE. This also makes it possible to control behavior through truthy or falsy values. You can use expressions like a [ternary operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_Operator) to use different values based on a condition, such as the value of a [Checkbox](https://retool.com/components/checkbox) component.

## Style options

:::note

Components inherit style options from either a parent component (if nested) or the current app theme. You can override style options directly as needed.

:::

You can customize the style of each component, or the [Header and Main frames](../ide.mdx#canvas) in the canvas. Select the component or frame to customize, then use the **Appearance** section in the **Inspect** tab of the right panel. There are different style options, such as color or border radius, depending on the type of component or the frame.

Color is one of the most effective ways to communicate status or severity to your users. You can set custom color options using the color picker or entering a valid [CSS color value](https://developer.mozilla.org/en-US/docs/Web/CSS/color). You can also select a color from one of the current theme's default colors.

As with other settings, you can [write JavaScript](../../../queries/quickstart.mdx) to conditionally set style options. For example, you can customize the background color of a [Table](https://retool.com/components/table) component column based on whether its quantity is less than or greater than `1000` using `{{ currentSourceRow.quantity > 1000 ? '9ed692' : 'd68b7c' }}`.

## Events

Many components trigger events based on certain user interactions, such as clicking a button or selecting a value. [Event handling](../../guides/interaction-navigation/event-handlers.mdx) enables you to trigger queries or perform actions based on the type of event.

Retool's approach with components makes it possible for you to build complex UIs that reflect changes immediately and dynamically adjust based on any conditions you need.

## Methods

The majority of components include JavaScript _methods_ that control their behavior. Component methods make it possible to write complex JavaScript statements to interact with components and change their state in ways that cannot be achieved with references or inline JavaScript using `{{ }}`.

Similar components often share the same methods. For example, `setValue()` is commonly supported by most inputs as a method to set the value of the component.

```js
textInput1.setValue("Hello World");
```

## Presets

A _preset_ is a preconfigured version of an existing component. Retool's component library includes a number of presets for commonly used configurations. For instance, the URL component is a [Text Input](https://retool.com/components/text-input) component that is preconfigured with URL pattern matching and prefix text. The URL component has the same internal state as Text Input, but configured for URL inputs.

## Custom components

If you have a use case that isn't handled by Retool's built-in components, you can build your own [custom component libraries](../../guides/custom/custom-component-libraries/index.mdx) using React and Typescript. Custom components are complex but enable you to develop a component that meets your exact needs.

## Bulk editing

You can select multiple components and edit them at the same time using the Inspector. Select multiple components by clicking and dragging a selection box around them, or by using cmd/ctrl + click.

export function ArcadeEmbed() {
  return (
    
      
    
  )
}

You can bulk edit components of the same type and components of different types. The Inspector shows only settings supported by all of the selected components. Properties that differ between components are identified as `Mixed` in the Inspector.

:::note

Not all properties are available for bulk editing. For example, **Content** settings for Tables and Charts cannot be bulk edited.

:::

---

## Legacy and deprecated components

Retool continually updates UI components for web and mobile apps. In most cases, no user action is required. There is no disruption to your apps and you can benefit from newer functionality whenever it's added.

While Retool makes every effort to develop components in such a way that they can evolve without disruption, there may be instances where it is not possible to update an existing component. There may also be newer functionality that makes an existing component redundant. If this occurs, you need to update existing apps and migrate the older component to the newer version.

## Legacy components

A legacy component is one that has been superseded by a newer, separate component, but still available for use. The newer component provides the same general functionality but works differently. Because of this, Retool continues to support legacy components alongside their newer versions so that customers can become familiar with the newer version and start using it. Going forward, only the newer component receives feature updates. 

Each legacy component remains available for an indefinite period before being deprecated.

## Deprecated components

A deprecated component is one that is no longer supported by Retool. It continues to work in existing apps but should not be used in newer ones.

Deprecated components are hidden by default. Admins can enable the **Deprecated components** option in the **Beta** organization settings allow the use of older components, but this is not recommended.

## Upgrades and migrations

Whenever you add a component to an app, the app uses the version current at the time. For example, if you built an app in 2022 and open it today, it would use the component versions from that time. Any existing apps with legacy or deprecated components will continue to function.

In general, you must migrate from an existing legacy or deprecated component to use a newer version. This requires updating your apps to use the newer component version. Occasionally, Retool may be able to automatically upgrade a component. If this is possible, the **Upgrade component** option will be present in the Inspector.

---

## Custom CSS styles

:::note

Retool recommends using the built-in style and theme options whenever possible. Class names and DOM structure may change as features are added that could break custom style overrides.

:::

You can provide custom CSS to override Retool's default style rules on a per-app basis. Within the app IDE, click the gear icon on the left and select **Custom CSS**.

You can also provide custom CSS that applies to all apps from the **Advanced** section in your organization settings. Navigate to your organization's settings, then click on your **User** menu on the upper-right and select **Settings**.

Retool component class names are unique and use the format `_retool-[component name]`. For example, the class name of the `textInput1` component would be `_retool-textInput1`.

---

## Debug Tools

import Shared from '/docs/_shared/_debug-tools.mdx';

---

## App IDE

The app IDE is the interface you use to build Retool apps. It is made up of these primary areas:

- [Canvas](#canvas): Arrange components to build your app's interface.
- [Navbar](#navbar): Configure, preview, share and manage your app.
- [Left panel](#left-panel): Explore components, queries, transformers, and constants.
- [Right panel](#right-panel): Create and edit components.
- [Status bar](#status-bar): Select the app environment, releases, runtime, and debug apps.

## Canvas

The canvas is where you build the interface for your app. You drag and drop components from the left panel.

The canvas contains frames in which you can place components.

### Canvas max width

To adjust the maximum width of the canvas, open the [App Inspector](#app-inspector) and update the **Max width** setting. This setting accepts pixel and percentage values, or you can set it to `none` so that the app uses 100% of the viewport. On desktops, regardless of the value, an 800px minimum is enforced.

### Grid layout

Canvas frames use a 12-column grid layout. As you arrange or resize components, the grid becomes visible and component edges snap into position. Each frame automatically grows as you add or resize components by adding more rows to the grid.

All frames use the same fixed-height rows to ensure consistent vertical arrangement. The Main and Header frames dynamically adjust column width based on the size of the viewport, with a maximum width of 1560px. The Sidebar uses a single-column grid only so you cannot place components horizontally next to each other.

## Grouping components

Retool also provides flexible components to [group other components together](../guides/layout-structure/), such as [Container](../reference/components/containers-forms/container.mdx) and [Form](../reference/components/containers-forms/form.mdx). These components extend the 12-column grid layout so you can drag components directly into a container. This creates a group of _nested_ components. All components can be nested in this way.

## Navbar

The navbar is where you customize the IDE environment and configure high-level app settings. From here you can:

- Access the Retool navigation menu to browse apps and access other areas of Retool.
- Toggle the visibility of panels to provide more space when working in the canvas.
- Change zoom size to increase or decrease the canvas size.
- Set the name and description of your app.
- Write [app documentation](../guides/app-management/app-documentation.mdx) for users.
- Search and execute actions from the Command Palette.
- Access the [App actions](#app-actions) menu to configure app settings.
- [Preview and share apps](../guides/app-management/share.mdx) with users.

### App actions

The  menu contains various actions and settings for your app. Some available options include:

- [Import or export an app](../guides/app-management/import-export.mdx) as JSON.
- Duplicate an app or [clone it as a module](../guides/layout-structure/modules.mdx).
- Manage [releases and history](../guides/app-management/releases-history.mdx).
- Configure app settings such as [themes](../guides/presentation-styling/themes.mdx) and [custom branding](../../org-users/concepts/branding.mdx).
- [Manage scripts and styles](../../queries/guides/javascript/custom.mdx#configure-custom-libraries).
- Configure [URL query parameters](../guides/app-management/customize-app-urls.mdx).
- Set [custom keyboard shortcuts](../reference/keyboard-shortcuts.mdx).

## Left panel

The left panel contains several tabs for working with components, writing code, managing releases, and changing app settings.

### Add UI tab

The  **Add UI tab** allows you to search for and add components to your app. You can also add modules.

### Pages tab

The  **Pages tab** allows you to view and manages the pages in your app. You can drag and drop pages to reorder them.

### Component tree tab

The  **Component tree** tab contains a hierarchical tree from which you can select, rename, switch, or delete components. You can view and select components regardless of visibility including those within multiview containers, such as [Tabbed Container](https://retool.com/components/container) component views. Selecting a component makes it visible and, where necessary, switches a container's view to make it active.

### Code tab

The  **Code tab** contains all of your app's [resource queries](../../queries/quickstart.mdx#resource-queries), [JavaScript](../../queries/guides/javascript/index.mdx), [transformers](../../queries/guides/javascript/index.mdx), and [variables](../../queries/reference/objects/variable.mdx). Selecting an item in the list opens a code editor where you can make changes. When a query is selected, there are three additional tabs displayed in the code editor.

### Code search

The  **Code Search** tab includes various options for searching through code in your apps. You can search within JavaScript, queries, event handlers, properties, custom CSS, URL parameters, etc. You can also configure case matching or use regular expressions to refine your searches.

#### General

The **General** tab is where you write and configure general settings for a query. Queries can typically **run automatically when inputs change** or **run only when manually triggered**.

You can write [SQL queries](../../queries/quickstart.mdx#resource-queries) using either **SQL mode** for reading data or **GUI mode** to write data using an interactive query builder. You can also configure query event handlers that trigger when a query runs or fails to run successfully.

To protect your data, queries that perform write or delete operations (e.g., **POST** API requests or **GUI mode** SQL queries) are set to manually triggered by default.

#### Response

The **Response** tab allows you to configure actions and conditions once a query is run. You can configure notifications or customize failure conditions.

#### Advanced

The **Advanced** tab expands on the previous tab's settings. You can configure confirmation requests, timeouts, and disable queries under certain conditions. If you configure a query to run automatically on input change, you can specify which inputs to watch. This triggers the query only when a relevant input changes.

All components appear on the desktop layout by default. The mobile layout is enabled when you configure at least one component to show on mobile. Apps automatically switch to the mobile layout when the viewport width is less than 600px wide.

### State tab

The  **State** tab contains details on components, queries, transformers, and global objects in your app. You can see more details from the sidebar by selecting individual objects. For example, component state contains its current value and all its properties.

The bottom of the window also shows the queries that a component depends on, and vice versa, which can be useful for identifying dependencies in your app.

### Releases and history tab

The  **Releases and history** tab allows you to view and create releases. You can also view your app's history, and revert to previous versions.

### App settings tab

The  **App Settings tab** allows you to change general settings like the mobile layout and user menu branding. There are additional sections for:

- Custom components
- Custom CSS
- Preloaded JavaScript
- Libraries
- App theme
- Notifications
- Localization

### Assist tab

import ChatIcon from "/img/icons/apps/assist.svg";

The  **Assist** tab allows you to use AI to generate apps, make changes to existing apps, and ask questions about Retool.

For more information, visit the [Assist](../guides/assist/index.mdx) guide.

## Inspector

The Inspector, located in the right panel, contains app and component settings. This is the panel you most interact with when building apps. When a component is selected, this is where you set values, update component names, create event handlers, etc.

Settings are organized into different sections, such as **Content**, **Interaction**, and **Appearance**. As some components have many configurable properties, some optional and less frequently used settings are grouped into subsections to reduce clutter. For instance, the **Add-ons** section contains settings for prefix and suffix text.

### App Inspector

The App Inspector appears when you don't have a specific component selected. It contains settings related to the app as a whole, such as URL, shortcut, and max width settings. Open the App Inspector with one of the following actions:

- Click on the dark grey border around the canvas.
- Click on blank parts of the Component Tree or Pages panel.
- Clicking on the Esc key when a component on the canvas is selected.  

export function AppInspector() {
  return (
    
      
    
  )
}

## Status bar

The status bar contains options to:

- [Switch environments](../../org-users/guides/configuration/environments.mdx) to change the data in use.
- [View releases](../guides/app-management/releases-history.mdx).
- [Access Debug Tools](./debug-tools.mdx) to troubleshoot issues.
- Get help and submit breakage reports.

---

## Multiplayer

Multiplayer is a feature of the [IDE](./ide.mdx) that enables multiple users to make changes to the same app simultaneously. Similar to collaborative editing tools like Google Docs, users can see what others are working on and changes are reflected in real-time.

Multiplayer is best suited for development teams who work on features independently. For example, a user works on queries while another makes changes to the UI. It is not designed for collaborative prototyping where users are making frequent changes in close proximity.

:::note

Multiplayer on Self-hosted Retool requires additional configuration and infrastructure changes. Refer to the [configuration guide](../../self-hosted/guides/multiplayer.mdx) for instructions.

:::

## How it works

Apps have internal state. Retool uses the concept of plugins to represent each aspect of an app, such as queries and components. Whenever a user makes a change, such as the position of a component, the app state changes. Retool syncs these changes automatically across all users by keeping the app state current.

Multiplayer leverages conflict-free replicated data types (CRDTs) to ensure consistent app state across users. Retool uses WebSockets to continuously stream app state between users. This approach allows the app state to sync across all users in a matter of milliseconds, providing a real-time collaborative experience.

## Conflict handling

CRDTs help reduce the number of conflicts due to the speed at which app state syncs. If a conflict does occur, Retool uses the Last Write Wins (LWW) principle and uses the change with the most recent timestamp. This approach provides a consistent conflict resolution method and avoids the need for users to manually manage conflicts.

## Indicators

There are a number of indicators within the IDE to visualize multiplayer users and edits.

### Avatars

The avatar for each user appears the IDE toolbar. Avatars are also displayed when editing queries or code in the **Code** pane.

### Cursors

Retool displays a cursor for users when making edits on the canvas (e.g., moving a component).

## Change history

Retool also keeps track of only the changes you make. You can safely undo or redo your own changes as these do not apply to other users' changes.

---

## Notifications

There are two core notification types in Retool:

- Notifications displayed when using apps.
- Notifications displayed in the app IDE when editing apps.

## Internal user notifications

App notifications are for displaying important information to users while they interact with your app. They're displayed automatically after queries run, but you can also configure them using [event handlers](../guides/interaction-navigation/event-handlers.mdx) and the [utils.showNotification](../../queries/reference/libraries/utils.mdx#utilsshownotification) method. Internal user notifications are also displayed while editing apps so they can be configured.

## IDE notifications

IDE notifications are displayed automatically while editing apps (e.g., after deleting a component or undoing an edit). These notifications are for app editors and aren't visible to users.

## Global notification settings

Global notification settings are accessed from the **App settings** tab.

Global settings apply to app notifications. You can override these settings at the individual [query](../../queries/guides/advanced-options.mdx#configure-query-specific-notifications) or notification level. For example, you can set the duration on a notification triggered by an event handler to exceed the global value.

---

## Programming paradigms at Retool

import Shared from '/docs/_shared/_programming-paradigms.mdx';

---

## Embedded apps

You can embed Retool apps within your existing web applications with support for user authentication. Your users can then access these Retool apps directly in the applications they use already and seamlessly authenticate. Refer to the [how-to guide](../../guides/app-management/embed-apps.mdx) for more information and instructions.

## Use cases

Retool enables you to build apps that can add new features or tools faster while keeping data access secure. Building additional CRUD functionality, like forms, settings pages, or onboarding flows, can take weeks with only code, but takes far less time with Retool.

## SDKs

You embed apps using Retool's [React](https://www.npmjs.com/package/react-retool) or [JavaScript](https://npmjs.com/package/@tryretool/retool-embed) SDKs.

## Authentication

There are two authentication processes for embedded apps that provide a seamless experience: SSO and custom authentication with Retool API.

### SSO

If your parent application uses [SSO](../../../sso/index.mdx) with an identity provider (IdP) that Retool supports, you can configure your Retool organization to use the same IdP and allow users to seamlessly authenticate with embedded apps. Since authentication is handled by the IdP, both the parent application and Retool organization share the same authentication state.

### Custom authentication with Retool API

:::note

Available on a Business or an Enterprise plan only.

:::

Custom authentication with Retool API lets you use any authentication solution to give users access to embedded apps. This means users don't have to go through Retool’s login flow. Instead, users log in through your product using your in-house solution (or with another mechanism like SMS, AWS Cognito, or Firebase), and seamlessly interact with data through embedded Retool apps. Your product's backend makes an API call to complete authentication with Retool, so the user doesn't have to go through Retool's login flow.

When your web application authenticates a user, using your preferred authentication method, your backend must make a request to Retool to generate an embed URL. This embed URL is a secure, single-use link that can be used anywhere in your product. To generate and use the embed URL to securely embed Retool apps inside your web app, you need to make some small updates to the frontend and backend parts of your codebase. The following diagram illustrates the authentication flow.

## Getting started

To get started embedding a Retool app, [refer to the guide](../../guides/app-management/embed-apps.mdx).

---

## External apps

Use external apps (sometimes referred to as _custom portals_ or _Retool Portals_) to deliver a fully white-labeled Retool app to internal and external users, such as customers, vendors, or partners. Retool can manage user email invitations, signup, permissions, the app experience, and more.

## Use cases

Organizations that build internal apps (e.g., bulk CSV uploads, customer onboarding flows, or revenue dashboards) and want to expose them to external users would be a good fit for these features. You can create a white-labeled experience and invite your external users directly into your organization to access these apps.

## Custom pages

Organizations can customize the user journey by replacing [Retool’s login, reset password, signup, and invitation claims pages with Retool web apps](../../guides/app-management/external-apps/custom-pages.mdx). This makes it possible to build a fully custom experience for external users, provide you with complete control over branding, and develop custom functionality.

## Branding

You can configure organization [branding](../../guides/app-management/external-apps/index.mdx#configure-branding) to customize headers, sign up and login pages, email invites to users, the Retool user menu, and more.

Branding options include organization and domain name, logo, favicon, and accent and header colors.

## Themes

You can create and manage themes to apply a consistent style across your organization.

Refer to the [theming guide](../../guides/presentation-styling/themes.mdx) for more information.

## Landing pages

Organizations can route external users to a specific app using the [landing page](../../guides/app-management/external-apps/landing-pages.mdx) option. When an external user logs in, Retool automatically routes them to the specified app. For example, you could route all external vendors to a vendor dashboard app that contains links to all the apps they might need to use.

## Retool Events

[Retool Events](../../../workflows/guides/retool-events.mdx) allows organizations to build custom automations using [Retool Workflows](../../../workflows/index.mdx). These trigger in response to actions taken in Retool. You can create workflows to:

- Send custom onboarding emails to new users joining your organization.
- Set up alerts and notifications for actions taken within Retool.
- Fully customize transactional emails (e.g., user invite and password reset emails).

## External users

External apps are unique because they enable external users to access your Retool app. External users include those whose email domains fall outside of your recognized internal domains. External users are [billed at a lower rate](https://retool.com/pricing) than builders.

For more information, read more about [external users](../../../org-users/concepts/external-users.mdx).

---

## Share your apps externally

If you've built internal apps in Retool, you can share those tools with customers, partners, or other external users. Retool offers three primary ways to do so. These options let you securely expose Retool apps to internal users while maintaining full control over the user experience. This guide covers all approaches and helps you determine which best fits your use case.

## Public links

If your app does not contain any restricted information, and you want it to be easily accessible, you can generate a public link to the app. This makes the app available, without authentication, to anyone who has the URL.

:::note

If your instance is self-hosted, reach out to your account manager or the [support team](/support) and request access to public links.

:::

When to choose public links:

- You want anyone on the internet to be able to view your app.
- Your app doesn’t expose any user-specific data.

For more information, refer to [Preview and share web apps with users](../../guides/app-management/share.mdx#generate-a-public-link).

## Embedded apps

You can embed your Retool apps directly into your existing web applications. Retool supports both React and JavaScript SDKs to simplify the integration process.

With embedded apps, users can authenticate through the existing authentication system in which your app is embedded, so they don’t need to log in twice. The backend of your app uses the Retool API to generate a secure, single-use embed URL that grants access to the app. You can also pass metadata into each session to personalize the experience and manage access centrally.

Choose embedded apps when:

- You have an existing customer-facing product or web app, and you want to enhance it with new functionality.
- You want to ship new features fast, without building them from scratch.
- You want to modernize a legacy system.
- You want to bring multiple internal workflows into a single interface.

For more information, explore the [embedded apps conceptual overview](./embed.mdx), or [follow the guide to get started](../../guides/app-management/embed-apps.mdx).

## External apps

:::note

Available on a Business or an Enterprise plan.

:::

Retool also lets you fully white-label the Retool experience to deliver web applications to internal users in a controlled, branded environment, like a custom portal. You can create a standalone experience that reflects your brand, complete with custom domains, themes, and customizable product pages like login and user invites. Built-in navigation and permission controls make it easy to link multiple apps together into a unified, seamless interface.

:::note

External users are billed separately and
at lower prices. Find out more on the [external user](../../../org-users/concepts/external-users.mdx)
page.

:::

Choose external apps when:

- You want to launch a customer-facing portal with full control over the end-to-end user journey.
- You need to deliver multiple tools within a single, cohesive, branded interface.
- You don't have an existing product or want to launch a new standalone experience for your internal users.
- You want to pay a lower amount for external users.

For more information, explore the [external apps conceptual overview](./external.mdx), or [follow the guide to get started](../../guides/app-management/external-apps/index.mdx).

## App sharing options comparison

Use the following table to compare the available options for sharing your app:

| Sharing mechanism | Authentication method                                                 | Plan availability                     |
| ----------------- | --------------------------------------------------------------------- | ------------------------------------- |
| Public links      | No authentication supported.                                          | All plans. Must be requested for self-hosted instances. |
| Embedded apps     | Authentication for internal and external users through parent window. | All plans. Business or an Enterprise plan only when using the Retool API for authentication.                            |
| External apps     | Custom, white-labeled authentication for internal and external users. | Business or an Enterprise plan.        |

## Frequently asked questions

### Can my embedded app users log in with their existing username and password from the parent app?

Yes, you can authenticate users through your existing system using one of the following methods.

- **Using the Embed SDK:** Pass your user's authentication into Retool via the Platform API.
- **Using SSO:** Connect Retool to the same identity provider.
- **Other setups:** If you're not using the SDK or SSO, it depends on your architecture and whether authentication can be coordinated between systems. Contact Retool to discuss your options.

### Can I embed Retool apps without using the JavaScript or React SDKs?

Yes, [simple iFrame embeds are supported](../../guides/app-management/embed-apps.mdx#embed-apps-as-an-iframe), but they’re not compatible with authentication via the Retool API. To avoid double login and provide a secure user experience, Retool recommends using SSO with a shared identity provider when embedding with an iFrame.

### How do I embed a public Retool app that doesn't require a login?

If your apps don’t expose any user-specific data, use a [public link](#public-links) in an iFrame.

### Does Retool support connecting to multiple SSO providers?

Yes, Retool supports multiple SSO provider connections for external apps using [Spaces](../../../org-users/tutorials/spaces.mdx) or a multi-instance self-hosted deployment. [Contact the Retool team](https://community.retool.com) to learn more.

### What are the best practices for environments with external apps?

Please refer to Retool's [environment best practices](/education/coe/customer-resources/environments).

### How do I set up permission groups for external apps?

Retool recommends [removing all access](../../../permissions/guides.mdx#configure-access-rules-for-a-permission-group) (**Edit**, **Use**, **Own**) from the **All Users** group and using the [External User](../../../org-users/concepts/external-users.mdx) group as the primary permission group.

:::note

For organizations created after Retool version 3.259.0, the **All Users** group has no permissions by default. [Read more in the changelog entry](/changelog/updated-permissions-for-all-users)

:::

You can also specify a Retool app as a [landing page](../../guides/app-management/external-apps/landing-pages.mdx). Once set, users in that permission group will be directed to that landing page app after they log in.

### How do I hide internal organizational information from external users?

To prevent external users from seeing internal information, go to the **Permissions** page for the relevant permission group. Under **Additional** > **Settings page visibility**, uncheck options like **View account details**, **View users page with emails**, **Audit logs**, and **Usage analytics**. This ensures sensitive internal organizational data remains hidden from external users.

### Can I see examples of customer-facing apps built by Retool customers?

You can explore several examples on the [Customer Stories](https://retool.com/customers) page, which includes samples of external apps, including portals, net-new customer-facing features, and other interfaces designed for external users.

---

## Usability features

Retool includes a number of features to enhance the usability of your apps. These options include additional context or personalization, text and data formatting, notifications, and query confirmations.

## Input components

:::note

Refer to the [Component Library](https://retool.com/components) for a complete reference of all components and the settings they support.

:::

Most input components, such as [Text Input](https://retool.com/components/text-input), have settings that help you provide users with greater context.

- **Placeholder**: A _placeholder_ appears within the input when it doesn't have a value.
- **Label**: A _label_ appears next to the component. You can also include a _caption_ to provide further context.
- **Add-ons**: You can enhance inputs with _prefix_ and _suffix_ text or icons, _tooltips_ to display further context when the mouse hovers over the input, and _helper_ text that appears when an input is in focus.

## Formatted data types

Certain components, such as [Table](https://retool.com/components/table), allow you to format the contents based on the data it contains—such as currencies or email addresses. For example, you can set a column of dates to use the **Date** format. This allows you to customize the date formatting or even adjust the date shown to match the user's local time zone.

### Personalize apps for the current user

Retool apps have access to _global_ variables, such as `current_user`, which allow you to personalize the app. For example, you can include a welcome message that displays the user's name with `**Welcome, {{current_user.firstName}}!**`.

### Formatted text with Markdown and HTML

You can use Markdown or HTML across a number of surfaces to include rich text or images. Retool renders Markdown and HTML where available. Refer to Github's [Basic writing and formatting syntax
](https://docs.github.com/en/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax) guide for more information—Markdown in Retool uses the same conventions.

### Trigger notifications

You can set up notifications using [event handlers](../guides/interaction-navigation/event-handlers.mdx) that trigger in response to any supported event. Add an event handler in **Interaction** section, then select **Show notification** as the action.

In addition to the title and description, you can specify the **Type** of notification by selecting from the list or dynamically with JavaScript. This represents the severity of the message and changes the color used. You can also control the duration for which notifications are shown before being dismissed.

You can also trigger notifications with JavaScript using `utils.showNotification()` .

### Query prompts

Queries that write or delete data can display a confirmation message before they run. You can enable this in the **Advanced** tab of a selected query.

---

## Retool Apps concept guides

import Concept from '/docs/_partials/_doctypes/_concept.mdx';

:::tip Get started with web apps

If you are unfamiliar with Retool web apps and want to get started: 

- Read the [quickstart](./quickstart) to learn about the fundamental concepts.
- Follow a [tutorial](./tutorial/) to build your first web app.

:::

---

## Add documentation to web apps

You can add documentation to an app to provide guidance and context for other users. 

## Write a README

README files are an important part of any programming project. Their purpose is to introduce the codebase to new users and help share important project details with collaborators. All Retool apps include a built-in README file for you to edit.

For web apps, access the README in the **Pages** tab. There are two methods to create a README:

- (Cloud instances only) Click **Generate with AI** to automatically generate a README based on the components and logic in your app.
- Click anywhere on the README page and draft your README in Markdown.

When you're done, click **Preview** to view the rendered Markdown.

export function AIReadme() {
  return (
    
      
    
  )
}

The README is only visible to users with **Edit** or **Own** permissions on the app. When other editors open the **README** page, they’ll see the rendered Markdown, along with the last editor to update the text, and a timestamp. Editors can click **Edit** to update the README themselves.

To regenerate the README with AI, delete all the content and click **Generate with AI**.

import Shared from '/docs/_shared/_app-documentation.mdx';

---

## Customize app URLs

You can customize the URL of apps and their pages to create more discoverable links for users. Apps also support query strings and hash properties to sync property values and control behavior. 

## Configure a custom URL

:::info 
Retool Cloud organizations use the domain `{organization}.retool.com` by default. Organizations on a Business or an Enterprise plan can optionally configure a [custom domain](../../../org-users/guides/cloud/custom-domains.mdx).
:::

Apps include a unique identifier in their URL by default. You can specify a custom URL path and access an app at `{domain}/app/{custom-url}` instead. If you're [embedding the app as an IFRAME](./embed-apps.mdx#embed-apps-as-an-iframe), the app can be accessed at `{domain}/p/{custom-url}`.

Open the [App Inspector](../../concepts/ide.mdx#app-inspector). Enter a custom URL path to use for the app, and preview the full URL.

export function AppInspector() {
  return (
    
      
    
  )
}

## Configure page URLs

Each app page has a title and URL that you configure from the Inspector. The page URL is appended to the app URL and allows for deep-linking to specific pages. For example, a page with the URL of `customers` would be available at `https://example.retool.com/app/support-dashboard/customers`.

Open the  **Pages** pane and select a page to view its settings in the Inspector. Enter a custom page URL path to use. The Inspector displays a preview of the URL to the current page. 

Configure page settings.

:::warning

Disabling a custom URL makes all prior references invalid. You can disable a custom URL in **App Settings > Page Settings**.

:::

### Accessing apps with a custom URL

Apps with custom URLs always display the custom URL in the browser's address bar unless you're editing the app or using the mobile view. Even if you access the app from another app, publicly, or from the original link, the custom URL is displayed. 

If you have a custom domain, short links are accessible from both your custom domain and the Retool domain.

---

## Embed web apps

You can embed your Retool web apps within your existing web-based applications, such as an internal metrics dashboard or customer support tool. Retool provides React and JavaScript SDKs to make the process seamless, and lets you authenticate users in a variety of ways to make sure access to data is secure.

:::note

By default, users of embedded apps are billed as builders. If [external apps](./external-apps/index.mdx) are enabled in your organization, users of embedded apps are billed as external users if their email falls outside of the internal domain list. [Learn more about external users.](../../../org-users/concepts/external-users.mdx)

:::

## Prerequisites

Follow these recommendations to ensure a seamless experience.

### Use the same domain

Use the same top-level domain for your Retool organization as the parent app in which you want to embed. For example, `retool.example.com` and `app.example.com`.

- Retool Cloud: Refer to the [custom domain](../../../org-users/guides/cloud/custom-domains.mdx) guide for instructions on configuring DNS settings.
- Self-hosted Retool: Refer to your cloud provider for instructions on configuring your domain, if necessary.

### Use HTTPS for embed URLs

If you intend to use [custom authentication with Retool API](#custom-authentication-with-retool-api), ensure that all URLs use HTTPS.

## Install an SDK

You can embed apps using Retool's [React](https://www.npmjs.com/package/react-retool) or [JavaScript](https://npmjs.com/package/@tryretool/retool-embed) SDKs.

  

The following example demonstrates embedding an app using the React SDK. It includes some additional data that is passed to the embedded app.

```javascript
import React from 'react';
import Retool from "react-retool";

const sampleData = { name: 'Sample data' }
const url = 'your_app_url'

const App = () => {
  return
  
     mockFunction(data)}
    />
  
}
```

See the [react-retool](https://www.npmjs.com/package/react-retool) documentation for more information.

  
  

After including the JavaScript SDK library, you initialize an instance of your Retool app and embed it at the specified location using the `createRetoolEmbed()` function.

```javascript
const container = document.createElement('div')

app.appendChild(container)

const sampleData = { name: 'Sample data' }
const url = ''

embeddedRetool = createRetoolEmbed({
  src: url,
  data: sampleData,
  onData: (data) => {
      mockFunction(data)
  }
});

container.appendChild(embeddedRetool)
```

  

## Pass data between embedded and parent apps

Embedded Retool apps can use the `data` property and **Parent Window** queries to read values from the parent application. They can also use [JavaScript queries](../../../queries/guides/javascript/index.mdx) to pass data back to the parent app using the browser's `postMessage` API.

### Pass data to an embedded app

Data you pass using the `data`  property is made available to the embedded app using **Parent Window** queries. You add this query to your embedded app and reference the data key in the **Selector** field. If you aren't using either the React or JavaScript SDK, the selector can be a CSS property.

### Pass data to the parent app

To pass data to the parent app, add a JavaScript query and use the `postMessage` API to send the data. For example, a query that sends the email address of the `current_user` to the parent app might look like this.

On the parent application side, write a JavaScript statement to listen and handle these messages. The following example uses `window.addEventListener()` to log the received message to the console.

```javascript
window.addEventListener(
  "message",
  function (e) {
    console.log("Parent window received: ", e.data);
  },
  false,
);
```

The code to handle `postMessage` requests depends on your specific implementation.

## Authenticate users in embedded apps

Users within your Retool organization sign in to an embedded app as they would when accessing the app normally. If you currently use Retool authentication (i.e., you manage users directly in Retool), this can result in users needing to sign in to both the parent app and then Retool.

To avoid this double-authentication flow, you can implement SSO using a supported identity provider or a custom authentication flow using Retool API.

### SSO

If your parent application uses [SSO](../../../sso/index.mdx) with an identity provider (idP) that Retool supports, configuring your Retool organization to use the same idP will allow users to seamlessly authenticate with embedded apps. Since authentication is handled by the idP, both the parent application and Retool organization share the same authentication state.

You can also map groups and roles from your idP into Retool to centralize user management. An added benefit of this approach is that all of your users can also sign into the Retool organization on the web using SSO.

:::warning idP trusted origins

Certain Identity Providers like Okta prevent embedding of third-party applications. You may need to add the domain on which you're hosting Retool as a [trusted origin](https://help.okta.com/en-us/content/topics/api/trusted-origins-iframe.htm).

:::

#### Automatically sign in users

You can configure Retool to automatically sign users in without showing the login screen. This occurs whenever a user has an existing, authenticated session on the IdP.

To configure this, navigate to your organization's **Single Sign-On** settings and enable **Trigger Login Automatically**. Self-hosted organizations can also configure this by setting one of the following [environment variables](../../../self-hosted/reference/environment-variables/index.mdx#authentication) to `true` in the `docker.env` file.

- **SAML**: `TRIGGER_SAML_LOGIN_AUTOMATICALLY`
- **OIDC**: `TRIGGER_OAUTH_2_SSO_LOGIN_AUTOMATICALLY`

### Custom authentication with Retool API

:::note

Available on a Business or an Enterprise plan only.

:::

If your parent application uses a different authentication method, such as username and password, you can integrate custom authentication using the Retool API. When a user successfully authenticates, your backend makes an API request to Retool that generates a secure, single-use URL. Opening this URL then authenticates the user without the need for them to sign in again.

To perform custom authentication with Retool API, you need to:

1. [Generate an access token](#1-generate-an-access-token) so you can create sessions for embedding apps.
2. [Create permission groups for your users](#2-create-permission-groups-for-your-users) so you can give them access to apps.
3. [Create an embed URL](#3-create-an-embed-url) to use when embedding Retool apps into your parent app.
4. [Use the embed URL to display the app](#4-use-the-embed-url-to-display-the-app).

The process to generate the URL happens between your web app's and Retool's backend.

#### Authentication flow

When your web application authenticates a user, using your preferred authentication method, your backend must make a request to Retool to generate an embed URL. This embed URL is a secure, single-use link that can be used anywhere in your product. To generate and use the embed URL to securely embed Retool apps inside your web app, you need to make some small updates to the frontend and backend parts of your codebase. The following diagram illustrates the authentication flow.

See the [GitHub repository](https://github.com/tryretool/retool_external_template/tree/main) for a live demo.

#### 1. Generate an access token

To embed apps, you need to create an access token with the **Embed** scope. This token allows you to create sessions for embedding Retool apps.

import Tokens from "/docs/_partials/_tokens.mdx";

You can create API tokens with the **Embed** scope in the **API** settings for your organization.

#### 2. Create permission groups for your users

Permission groups determine the apps users can access. Depending on your use case, you might need to create more than one permission group.

To create a permission group:

1. Navigate to the Permission Groups page at `/settings/permissions`.
2. Click **Create new** in the top right and complete the form to create a group.
3. Optionally add internal users on the **Members** tab by clicking **+ Add new members**. External users are added later, in the [POST request to your embed URL](#3-create-an-embed-url).
4. On the **Apps** tab, enable **Use** access to the apps you want users to have access to.

Make sure to note down the group IDs you want to give access to. You can find a group's ID by hovering over the group, clicking the **•••** menu, and then selecting **Copy group ID**.

![Copying the group ID](/img/docs/accab16f-e7b1-4683-92fc-0cc12425674c.gif)

#### 3. Create an embed URL

The embed URL is a single-use link to a Retool app for an authenticated user. Your backend sends a POST request to `/api/embed-url/external-user` with a few parameters, and Retool returns the URL. This URL is then used by your frontend to display the app.

The table below outlines the parameters you can send, and whether they're required.

| Parameter                | Required | Description                                                                                                                                                                                                                                                                                     |
| ------------------------ | -------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `landingPageUuid`        | Yes      | A string to specify the page in the Retool app to render. You can find the `landingPageUuid` by opening the app and using the Command Palette (opened with ctrl k) to select **Copy app UUID**. |
| `groupIds`               | Yes      | An array of integers specifying the Retool group IDs to allow.                                                                                                                                                                                                                                  |
| `sessionDurationMinutes` | No       | The session token's duration, in minutes. If unset, defaults to 1440 (1 day). Values from 10 to 43200 (30 days) are accepted.                                                                                                                                                                   |
| `externalIdentifier`     | Yes      | A string or integer unique identifier for the external user. If the user's email is to be used, it must match what is passed in `userInfo.email`.                                                                                                                                                                                                                                    |
| `userInfo`               | No       | User profile information, necessary to leverage user fields in apps such as `{current_user.email}`. Can contain string fields for `email`, `firstName`, and `lastName`. If `email` matches an existing Retool user, the same account will be used.                                                                                                                                                                                                   |
| `metadata`               | No       | An object with additional metadata. Can be at most 1KB of JSON.                                                                                                                                                                                                                      |
| `environment`            | No       | A string to specify an [environment](../../../org-users/guides/configuration/environments.mdx) for the app to run in.                                                                                                                                                                                                 |
| `branch`                 | No       | A string to specify a [branch](../../../source-control/guides/manage-branches.mdx) to be displayed. You can't display both `releaseVersion` and `branch`.                                                                                                                                               |
| `releaseVersion`         | No       | A string to specify a [release](./releases-history.mdx#releases) to be displayed. Defaults to `latest` but you can pass version numbers too (e.g.,`1.0.0`). You can't display both `releaseVersion` and `branch`.                                                                    |

##### POST request examples

Below are a few example POST requests. Because frameworks vary, only cURL and Python examples are provided.

You need to replace `APP_UUID`, `GROUP_IDs`, and `UUID` in the cURL example for it to work. See the [request parameters](#post-request-parameters) section for more information.

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

```curl
// Replace APP_UUID, GROUP_IDs, UUID with
curl -X POST "https://retool.example.com/api/embed-url/external-user" \
  -H "Authorization: Bearer retool_01hn417x8zsaqfye58r995re18" \
  -H "Content-Type: application/json" \
  -d  '{ "landingPageUuid": APP_UUID, "groupIds": GROUP_IDs, "externalIdentifier": UUID}'
```

This example accepts a request from the client, builds and sends a POST request to `/api/embed-url/external-user`, receives the embed URL, and returns the URL to the client.

```python
@app.route('/embedUrl', methods=['POST'])
def embed_url():
  data = request.get_json()
  app_uuid = app_name_to_uuid[data['retoolAppName']]

  # userJwt is an example variable that the frontend could pass to your backend and is not required
  token, first_name, last_name, email = jwt.decode(data['userJwt'], secret_key)

  headers = {
    // The RETOOL_API_KEY is the token generated in the first step
    'Authorization': f"Bearer {os.environ['RETOOL_API_KEY']}",
    'Content-type': 'application/json',
  }
  body = {
    'landingPageUuid': app_uuid,
    'groupIds': [12, 13],
    'externalIdentifier': token,
    'userInfo': {
      'firstName': first_name,
      'lastName': last_name,
      'email': email,
    },
    'metadata': {
      'storeId': 5
    }
  }

  options = {
    'method': 'POST',
    'headers': headers,
    'body': json.dumps(body),
  }

  resp = requests.post(f"https://{os.environ['RETOOL_URL']}/api/embed-url/external-user", **options)
  if resp.ok:
    return resp.json()
  else:
    # Handle error
    pass
```

```javascript
router.post('/embedUrl', async (req, res) => {
  const data = req.body;
  const app_uuid = app_name_to_uuid[data.retoolAppName];

  // userJwt is an example variable that the frontend could pass to your backend and is not required
  const secret_key = process.env.SECRET_KEY;
  const decoded = jwt.decode(data.userJwt, secret_key);
  const { token, firstName, lastName, email } = decoded;

  const headers = {
    'Authorization': `Bearer ${process.env.RETOOL_API_KEY}`,
    'Content-type': 'application/json',
  };

  const body = {
    'landingPageUuid': app_uuid,
    'groupIds': [12, 13],
    'externalIdentifier': token,
    'userInfo': {
      'firstName': firstName,
      'lastName': lastName,
      'email': email,
    },
    'metadata': {
      'storeId': 5
    }
  };

  try {
    const response = await fetch(`https://${process.env.RETOOL_URL}/api/embed-url/external-user`, {
      method: 'POST',
      headers: headers,
      body: JSON.stringify(body),
    });

    if (!response.ok) throw new Error('Response not OK');

    const jsonResponse = await response.json();
    res.json(jsonResponse);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

```

:::note

If you need to make sure users can only see data specific to them, see the [Control access and app behavior with metadata](#control-access-and-app-behavior-with-metadata) section.

:::

#### 4. Use the embed URL to display the app

On your frontend, use the [Retool React component](https://www.npmjs.com/package/react-retool) or the [Retool Embed SDK](https://www.npmjs.com/package/@tryretool/retool-embed) to render the embed URL. Below is a sample request your frontend would make to your backend.

```javascript
const RetoolWrapper = ({ retoolAppName, userJwt }) => {
  const [retoolEmbedUrl, setRetoolEmbedUrl] = useState("");

  useEffect(() => {
    const options = {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ userJwt, retoolAppName }),
    };
    fetch("/api/embedUrl", options)
      .then((res) => res.json())
      .then((data) => {
        setRetoolEmbedUrl(data.embedUrl);
      });
  }, [retoolAppName]);

  return (
    retoolEmbedUrl && (
      
        
      
    )
  );
};
```

```javascript
const container = document.createElement('div')
app.appendChild(container)

const getEmbedUrl = async () => {...}

getEmbedUrl().then((retoolEmbedUrl) => {
    embeddedRetool = createRetoolEmbed({
        src: retoolEmbedUrl,
        style: "border: 1px solid blue; height: 100%; width: 100%;",
        data: {dataValue: false},
        onData: (data) => {
            mockFunction(data)
        }
    });
    container.appendChild(embeddedRetool)
});
```

#### 6. Control data access with metadata

You can pass information in the `metadata` object to dynamically control the data users see and behavior within an application. These variables are added to the `current_user.metadata` object when the embed URL is generated.

Because [Prevent Query Spoofing](../../../queries/quickstart.mdx#query-variable-spoofing-prevention) is turned on, the metadata associated with the current user cannot be spoofed. Retool will reject any requests if a bad actor alters any metadata values passed in via the POST request above.

#### 7. Testing

When generating the embed URL, Retool may create an additional user depending on the data that is passed into your POST request.

To avoid creating an extra user while testing, pass in the email associated with your Retool account in the `email` property of the `userInfo` object, as well as the IDs of the permission groups you’re in.

If an email is specified and it matches that of an existing Retool user, Retool will update the user, its metadata, and permission groups. Otherwise it will create a new user if this email does not exist.

If no email is specified, Retool updates the user if the `externalIdentifier` matches, or creates a new user if the `externalIdentifier` does not exist.

## Embed apps as an IFRAME

If you cannot use an SDK to embed apps, you can still embed an app as an IFRAME. You can do this with an embed code, or with a public link.

This method lacks some of the features available in the SDK but can allow users to authenticate by signing in.

1. Make sure that your app is published, and not in your **Drafts** folder.
2. Open your app, and click **Share**.
3. Click  **Copy embed code**.

If you don't need to add authentication because your apps do not surface user-specific data, you can [enable public links](./share.mdx#generate-a-public-link). You can share this link directly with users or embed the app in other web apps. These apps can be accessed by anyone on the internet and always reflect the production environment of the app.

:::note

If your instance is self-hosted, reach out to your account manager or the [support team](/support) and request access to public links.

:::

import Link from '../../../_shared/_public-links.mdx';

---

## Build custom pages

Organization admins can replace Retool’s login, reset password, signup, and invitation claim pages with Retool apps. This allows you to customize the entire user journey, which is valuable if you white-label Retool for external users outside your organization.

This guide covers how to set Retool applications as your custom pages and use user actions to control the user lifecycle (login, reset password, claiming an invite, etc.).

## Configurable custom pages

You can replace the following pages with Retool apps:

- Log in
- Confirm reset password
- Claim invitation
- 403 Error page
- 404 Error page

Each of these pages has a distinct route necessary for the user flow to work. For example, from an invite email, Retool needs to know which URL to open (e.g., that of a Retool-managed page or Retool app). Other flows, like how users input their passwords, or sign up for Retool, can be entirely defined by you.

## Generate custom pages

You can use either an existing app or a new app to use as a custom page. Retool recommends creating a new page through the following flow, because it generates template apps that are preconfigured with UI elements and the necessary [user actions](./user-actions.mdx).

1. Go to **Settings** > **Branding**.
2. From the **Preview** section, confirm the dropdown is set to the page you want to modify, such as **Log in**.
3. Click **Manage**.
4. Select **Create a new app**.
5. Set a custom URL for your app. Retool automatically generates the public link at `[your_domain].com/p/[custom_url]`.
6. Navigate to the **Apps** page, and locate your app.

:::warning

New apps created from this flow are placed in the root folder (found under **Published** on the Apps landing page). Ensure you restrict access to these apps by moving them to a more privileged folder, such as the **External apps** folder.

:::

## Customize custom pages

This section covers how to build custom custom pages using Retool apps.

:::warning

Because these apps deal with sensitive information, restrict their access to admins and developers with only the most privileged access.

:::

The [template apps generated](#generate-custom-pages) from **Branding settings** work with no additional configuration. Password reset and invite links automatically use the public, custom URL set.

These template apps also come prebuilt with [user actions](./user-actions.mdx). User actions are an easy-to-use wrapper on top of Retool’s public APIs for:

- Logging in
- Logging out
- Claiming invites
- Sending password reset links
- Confirming reset passwords

User actions are used the same as any other Retool query, except that they can only be called from within apps.

### Build your login page

The login page serves as the default landing page for unauthenticated users. When users log out of Retool, they are automatically redirected to this page, though you can still access the Retool-managed login page at `[your_domain].retool.com/auth/login`. You can use this single page with user actions to support login, password reset, and signup.

When building your login page, use the **Login** user action.

The **Login** user action supports the following login methods:

- Email and password
- Google SSO
- SAML SSO, when already configured in **Settings > SSO**
- OIDC SSO, when already configured in **Settings > SSO**

To ensure users are routed to the Retool home page or a workspace, add an event handler. When you specify `/` as the path, Retool routes the user to the home page, or if they have a [workspace](./landing-pages.mdx) set for their permission group, to their workspace app.

### Build password reset and invite flows

You can use the **Send reset password email** user action to support password reset flows. You can use these actions within your same login app, e.g., by adding a new view to your [container](../../layout-structure/container.mdx#multiple-views), or by creating a dedicated page for password resets and linking to it from your login page.

The **Send reset password email** user action automatically validates the password reset token and email address passed as URL parameters. You can similarly build additional apps and functionality for claiming invites and confirming password resets using the **Claim invitation** and **Confirm password reset** flows.

### Build a signup flow

You can use the [Retool API](../../../../api/index.mdx) to build a self-service signup flow for your users.

In the example login page above, when a user completes the onboarding questionnaire, the form triggers a query calling `POST /user_invites` with the form inputs in the `metadata` field, as well as the default permission groups.

When the user is created upon claiming the invitation, the `companyName` value will be stored on the user object. As an editor, you can access this value by referencing `{{ current_user.metadata.companyName }}`.

## Assign custom pages

For each custom page you created, ensure that each app has a [public link](../share.mdx#generate-a-public-link). Then, return to the **Settings** > **Branding** page, and complete the following steps:

1. From the **Preview** section, confirm the dropdown is set to the page you want to modify, e.g., **Login**.
2. Select **Manage**.
3. Select the app that you want to use as the custom page.

## Security

Because these apps touch the core user lifecycle, it's important to build these applications with security best practices in mind. User actions do not make Retool any less secure, since these endpoints do not require authentication and are publicly accessible—anyone can attempt to reset the password for any email address.

Retool relies on the security of the reset password and invitation process, meaning the links are only accessible from the user’s or admin's email inbox.

---

## Create external apps

You can use [external apps](../../../concepts/share-externally/external.mdx) to white-label your instance and deliver web applications to external users in a controlled, branded environment. This guide covers how to enable external apps (sometimes called Retool Portals) and cutomize the experience for [external users](../../../../org-users/concepts/external-users.mdx), such as customers, vendors, and partners.

## Enable external apps

In your organization settings, navigate to **Settings** > **External apps**, and click **Enable external apps**.

### Set your internal domain list

In order for Retool to determine whether a user is internal or external (and bill accordingly), you must specify an internal domain list. By default, the domains of all admins within your organization are included. Add additional domains as needed.

Once you agree to the terms, Retool automatically creates an **External Users** permission group. This group cannot be deleted, and users with domains outside of the internal domain list are automatically added to it.

export function InternalDomain() {
  return (
    
      
    
  )
}

## Configure branding

Customize branding options for your organization, including the organization name, logo and favicon, and accent and header colors.

These options allow you to remove Retool branding and replace it with your own to customize the experience for both internal and external users. Click **Configure branding and pages** on the **External apps** page, or navigate to **Settings** > **Branding** to get started.

### Set your organization name

On the **Branding and customization** page, click **Edit** to change your organization name. Next, enable **Remove extra references to Retool**. This replaces Retool with your organization's name throughout the product experience, such as on the login page.

### Configure a custom domain

You can configure a custom domain for Cloud or Self-hosted Retool:

Retool Cloud organizations initially start with a URL in the format: `[organization].retool.com`. To change your Retool domain, first follow the instructions in the [Configure a custom domain for Retool Cloud](../../../../org-users/guides/cloud/custom-domains.mdx) guide.

If your organization uses [Self-hosted Retool](../../../../self-hosted/index.mdx), configure your custom domain in your cloud provider's settings.

Navigate back to **Settings** > **Branding**, and click **Edit** in the **Domain name** section. Enter the domain name you configured. After your domain is verified, users can log into your organization at `[mydomain.com]/auth/login`.

Log out and back in using your custom domain, and continue.

### Customize logo and favicon

You can replace Retool's logo and favicon with your own by uploading a logo image in `.jpg` or `.png` format, or a favicon in `.ico` format. You can also enable **Show logo in app headers** to automatically include your logo in the Header frame of all apps, if present.

### Accent and header colors

Set the **Accent color** and **Header background color** to match your company branding. These colors apply to login pages, email pages, and the header for the app editing experience.

### Customize emails

To remove all references to Retool in [Retool Emails](../../../../data-sources/quickstarts/retool-email.mdx), enter a **From name** and a **Reply-to address**. Emails are sent from `email.retool.com` by default. You can alternatively set up [Retool Events](../../../../workflows/guides/retool-events.mdx) to send emails from your own email provider with Retool Workflows.

### Create a theme

Create a [default, organziation-wide theme](../../presentation-styling/themes.mdx) that applies to all apps in your organization.

## Configure permissions

Configure permissions for external users by managing the **External Users** permission group, or by adding external users to other groups. By default, the **External Users** group has **Use** access to the **External apps** folder and all apps inside of it. In the group's additional settings, the Retool app created from the above step is also automatically set as the group's landing page.

:::note

To ensure that external users can only navigate between Retool applications and not access native parts of Retool, the **All Users** permission group must also have default permissions set to **Define specific access**. This ensures that new users only inherit the permissions based on the groups they belong to.

For organizations created after version 3.259.0, the **All Users** group does not have universal access permissions by default. [Read more in the changelog entry](/changelog/updated-permissions-for-all-users).

:::

Refer to the [external users documentation](../../../../org-users/concepts/external-users.mdx) for more information.

## Add Retool Events

If your organization is on an Enterprise plan, you can also configure [Retool Events](../../../../workflows/guides/retool-events.mdx) to help customize bespoke user experiences when new events occur, like **User Created** or **Login Attempted**.

## Next steps

Next, follow the other guides in this section to fully white-label your external apps:

1. [Create a landing page.](./landing-pages.mdx)
2. [Create custom pages.](./custom-pages.mdx)
3. [Utilize user actions.](./user-actions.mdx)

---

## Build a landing page

Admins can configure landing pages for specific [permission groups](../../../../permissions/guides.mdx). Users without **Edit** access who are members of a group with an associated landing page are automatically routed to a specific Retool app when they log in. For example, you can route all Customer Support representatives automatically to a Customer Support Retool app that contains links to all the apps they might need to use.

## Create a landing page

First, create a new app and place it in the **External apps** folder. This folder was automatically created when you [enabled external apps](./index.mdx#enable-external-apps).

An example app might look like this:

This example app contains links to other Retool apps. You can filter which links are available for the user based on their permission groups using JavaScript. For example, you can use the **Hidden** property to hide certain tiles if the current user isn't in the `Pharmacist Manager` permission group:

```
!current_user.groups.includes("Pharmacist Manager")
```

## Configure a landing page

Navigate to **Settings** > **External apps**. Find the **Create a landing page** section, and select your app from the dropdown.

## Landing page routing

Users with **Edit** access to any apps are routed to the Retool homepage when they log in, even if a landing page is set for their groups. Users who are members of multiple groups with landing pages can switch between landing pages using their profile menu in the top right hand corner of the page.

---

## Configure user actions for users

Use the **User Action** resource to write queries in custom page apps that enable users to authenticate. Users can also perform additional actions, such as resetting their password or claiming an invitation. The **User Action** resource can also retrieve a list of apps and folders for which the user has access.

## Create a resource query

You create user action queries in the same way as other resource queries:

1. Click  in the app IDE to open the **Code** panel.
2. Click **+** and select **Resource query**.
3. Select the **User Action** resource.

## Select the action to perform

The **User Action** resource supports the following actions:

- Log in.
- Log out.
- Claim invitation.
- Send password reset email.
- Confirm reset password.
- Get user apps and folders.

Supported actions for the **User Action** resource.

The query displays additional options for you to configure when selecting an action.

### Log in

The **Log in** action authenticates the user. The **User Action** resource supports username and password credentials and any configured single sign-on (SSO) identity provider. Select the method to use for authentication.

SSO authentication is handled by your identity provider and no additional configuration is needed. If you select **Username and password**, reference input component values for these credentials.

For example, if your app has an [Email](../../../reference/components/text-inputs/email.mdx) component (`usernameInput`) and a [Password](../../../reference/components/text-inputs/password.mdx) component (`passwordInput`), you would reference these values using `usernameInput.value` and `passwordInput.value` respectively.

### Log out

The **Log out** action logs the current user out. The user must log in again.

### Claim invitation

The **Claim invitation** action enables invited users to create an account. The action automatically validates the invite token that is included as a URL parameter in the invite link.

The action includes a number of options the user provides to claim their invite. You must add the necessary input components and reference their values so the user can provide this information.

| Input field     | Description                                                                                                            |
| --------------- | ---------------------------------------------------------------------------------------------------------------------- |
| First name      | The first name of the user.                                                                                            |
| Last name       | The last name of the user.                                                                                             |
| Password        | The password to use.                                                                                                   |
| User attributes | Key-value pairs of additional information you can store for users. Learn more about [user attributes](../../../../org-users/guides/user-management/user-attributes.mdx). |

Configure the **Claim invitation** action.

### Send password reset email

You can use the **Send reset password email** action to support password reset flows. You can use these actions within your same login app, e.g., by adding a new view to your [container](../../../../apps/guides/layout-structure/container.mdx#multiple-views), or by creating a dedicated page for password resets and linking to it from your login page.

The **Send reset password email** user action automatically validates the password reset token and email address passed as URL parameters.

### Confirm reset password

Use the **Confirm reset password** action to allow users to change their password after requesting a password reset.

This action automatically validates the password reset token and email address that were included as URL parameters in the reset password link. Reference a Password component for the **New password** option so that the user can input their new password.

### Get user apps and folders

The **Get user apps and folders** action retrieves a list of all apps and folders for which the authenticated user has access. This is useful for providing users with a list of relevant apps to access.

The query results include two arrays of objects, `apps` and `folders`, with details about apps and folders. You can reference either of these arrays from a component that supports mapped options. For example, you could use the [Navigation](../../../../apps/reference/components/navigation/navigation.mdx) component to automatically display a list of all accessible apps for the current user.

A Navigation component with mapped options from available apps.

## Configure event handlers

User action queries do not automatically run. You must configure [event handlers](../../interaction-navigation/event-handlers.mdx) to trigger them in response to an [event](../../../reference/event-handlers.mdx#events), such as clicking a button.

---

## Import and export apps

import Shared from '/docs/_shared/_import-export-apps.mdx';

## Import other apps as pages

You can import legacy single-page apps or pages from existing multipage apps as pages in your new app. This eliminates the need for rebuilding an app from scratch. Click **+** >  **Copy page from app**, and select the app you want to import. If you are importing a page from an existing multipage app, select which page you want to use.

export function CopyApp() {
  return (
    
      
    
  )
}

When you import an existing app as a page:

- Header and Sidebar frame conflicts must be handled. You can choose to retain the current app's existing frames or override them with the incoming app.
- All code is page-scoped.
- Any app settings are ignored. 

If you override the Header or Sidebar frames using the imported app, value reference errors may occur. You must verify and update any code or components that rely on values within these frames, such as accounting for globally scoped and page-scoped value changes.

:::info 
Apps have a global Header and Sidebar frame. If you have a collection of apps that share the same Header or Sidebar frame content using a module (e.g., shared navigation), import each app and create the necessary Header or Sidebar frame content.
:::

---

## App management



---

## Localize web apps

## Set up internationalization

To localize your Retool apps, you must first set up internationalization in your organization settings. Visit the [Internationalization guide](../../../org-users/concepts/internationalization.mdx) to learn more.

## Enable localization

You must enable localization from the app IDE in **App Settings > Localization**. By default, localization is not enabled to preserve app performance.

When enabled, your application use translations uploaded at the organization level. To improve performance and make sure your app is only using the translations it needs, you can specify specific files to use in the app. When selected, you can preview the locales these files support—this is why it's important you keep the file names consistent.

## Access translations

Once localization is enabled, translations are available in the `{{ retoolContext.translations }}` object. Note that only translations in your current browser locale are shown. You can preview different locales in the **App Settings** tab, or change your browser locale (e.g., go to `chrome://settings/languages` on Chrome)  to see translations for different languages.

The current user's locale can be referenced through `{{ current_user.locale }}`.

### Localize your app

Retool provides helpful utility functions through a built-in `i18n` JavaScript library, which leverages [i18next](https://www.i18next.com/).  This means interpolation, plurals, date, and number formatting are automatically available.

#### Switch locales

To allow end-users to switch locales in your app, or test your localization, use the built-in utility function `utils.changeLocale` to simulate the app in different locales. Pass in the [two-character BCP 47 language tag](https://developer.mozilla.org/en-US/docs/Glossary/BCP_47_language_tag) as a parameter. For example, use `utils.changeLocale(de)` to change the language to German.

You can add a Select component to allow users to switch locales. This can be implemented adding an event handler which calls `utils.changeLocale` when a locale is selected.

### Formatting

You can use built-in functions provided by [i18next](https://www.i18next.com/) for formatting.

#### Static text

Translate static text by calling `{{ i18n.t('your_translation_key') }}`. See the [i18next documentation](https://www.i18next.com/translation-function/essentials#overview-options) for additional options, like fallback text.

#### Dynamic data

If you're translating dynamic data returned from a query, Retool recommends using [interpolation](https://www.i18next.com/translation-function/interpolation) in your translations.

For example, let's take a translation JSON uploaded for `en-US`:

```JSON
{
  "viewingExpenses": "{{viewing}} out of {{total}} expenses"
}
```

In your Retool application, use:

 ```Javascript
 {{ i18n.t('viewingExpenses', { viewing: filteredData.value.length, total: allData.value.length}) }}
```
#### Currency

You can format numbers and currencies with built-in currency translations.

```JSON
 {
  "formatCurrency": "{{val, currency(USD)}}"
 }
```

In your Retool application, use:

 ```Javascript
 // Item is a value returned from a query
 {{ i18n.t('formatCurrency', { val: item }) }}
```

See [i18next documentation](https://www.i18next.com/translation-function/formatting#number) on formatting currencies for more.

#### Dates

Specify the interpolation below to format dates.

```JSON
 {
    "formatDate": "{{val, datetime}}"
 }
```

In your Retool application, you can use either `i18n` or the built in [moment](https://momentjs.com/) library for datetime translations.

 ```Javascript
 // Using i18n
{{ i18n.t('formatDate', { val: item.created_at })}}

// Using moment
{{ moment(item.created_at).locale(current_user.locale).format("LL") }}
```

### Components

Retool supports localization of most components with the following languages:

* English (EN)
* Spanish (ES)
* French (FR)
* Portuguese (PT)
* Japanese (JA)
* German (DE)
* Danish (DA)

When localization is enabled, the default value for supported components is automatically set to `{{ i18n.default }}`. This only applies to new components added to apps—existing component default values are not changed.

The following do not currently support localization:

* Retool Mobile and mobile components
* The Rich text Editor component
* The Microphone component
* The Scanner component
* The Auth Login component
* The Stripe Card Form component
* Custom components

---

## Version and release apps

import Shared from '/docs/_shared/_releases-history.mdx';

---

## Preview and share web apps with users

import Share from "../../../_shared/_share.mdx";

---

## Configure URL parameters

You can include URL query strings and hash parameters when linking to an app page and reference their values, such as passing a search term or setting the current view of a container. 

:::tip 
Retool also includes a number of [built-in URL parameters](../../reference/url-parameters.mdx) to control certain characteristics of an app.
:::

## Configure URL parameters

You can include any hash or query string parameters within an app's URL. URL parameters are page-scoped and only accessible from the page specified in the URL. If no page is specified, URL parameters are available within the app's default page. 

You can configure page-specific URL parameters that reference values and update the URL whenever they change. This allows users to link to an app's current state, such as a selected table row, or sync values between different pages and apps.

Open the  **Pages** pane and select a page to view its settings in the Inspector. You can set each page's URL search and hash parameters to reference any globally or page-scoped value. Any changes to referenced values are then automatically reflected in the current URL and in the `url` object.

You cna also configure URL parameters programmatically using the [utils.setUrlParameters](../../../queries/reference/libraries/utils.mdx#method-setUrlParameters) method.

### Search query parameters

You can provide search query parameters by appending `?` to the URL and using the format `key=value`. Use the `&` symbol as a separator to provide multiple key-value pairs.

```
https://example.retool.com/app/users?role=viewer&team=workplace&q=chic
```

### Hash parameters

You can also provide hash parameters by appending `#` to the URL using the format `key=value`. Use the `&` symbol as a separator to provide multiple key-value pairs.

```
https://example.retool.com/app/users#enabled=true
```

If you need to include both types of parameters, hash parameters must be after query strings.

```
https://example.retool.com/app/customer-dashboard?q=chic&role=viewer&team=workplace#enabled=true
```

## Reference URL parameters

You can use URL parameters in the app by referencing the [url](../../reference/objects/url.mdx) object. Both `hashParams` and `searchParams` contain key-value pairs that represent their respective parameters within the current URL.

```
{
  "hashParams": {
    "enabled": true
  },
  "searchParams: {
    "role": "viewer",
    "q": "chic",
    "team": "workplace"
  }
}
```

For example, you would reference these parameters using `{{ url.hashParams.enabled }}` and `{{ url.searchParams.q }}`. You can use these almost anywhere within the app, such as populating an input component or query parameter.

You can also include URL query parameters when configuring the **Open page** or **Open app** [event handlers](../interaction-navigation/event-handlers.mdx).

Configure URL parameters when linking to other pages or apps.

## Persist URL parameters

You can chose whether all "Go to page" event handers should have the **Persist URL Params** setting enabled by default. When enabled, [search query parameters](#search-query-parameters) and [hash parameters](#hash-parameters) persist during page navigation and when switching pages with the “Go to Page” event handlers.

Turn on this setting by navigating to the [App Inspector](../../concepts/ide.mdx#app-inspector), and enable **Persist URL Parameters**.

If enabling this setting would override a specific “Go to Page” handler’s settings, a confirmation popup appears, asking the user to confirm the override.

---

## Configure your organization for Assist

An organization admin must complete the steps in the following sections to make sure your organization is ready to use Assist.

:::note

To learn how to prompt Assist, visit the [prompting guide](./prompt.mdx).

:::

## Configure organization settings

Ensure that Assist is enabled and that it has access to the proper resources. These steps differ slightly depending on your plan.

1. To ensure your users can access Assist, navigate to **Settings** > **AI**.
   1. Verify that the **Retool AI** and **Assist Tab** settings are toggled on. 
   2. Choose whether to show the Assist chat on the apps landing page.
2. Navigate to **Resources** > **Retool AI**. Ensure that _both_ OpenAI and Anthropic are enabled in the **Retool managed** section.

1. To ensure your users can access Assist, navigate to **Settings** > **AI**.
   1. Verify that the **Retool AI** and **Assist Tab** settings are toggled on. 
   2. Choose whether to show the Assist chat on the apps landing page.
2. Navigate to **Resources** > **Retool AI**. Ensure that _both_ OpenAI and Anthropic are enabled in the **Retool managed** section.

Configure role-based access controls

Organization admins on the Business and Enterprise plans can use Retool's [role-based access controls](../../../permissions/guides/roles-permissions.mdx) to restrict a [group's](../../../permissions/quickstart.mdx#permission-groups) permissions for Assist to **Ask** mode only or to prevent Assist usage entirely. For example, admins might wish to restrict Assist usage to user groups who do not have access to sensitive data or PII. Alternatively, admins could restrict access to all user groups except for a pilot group that has approval to test AI tools.

By default, all builders have access to Assist and both **Ask** and **Build** mode through a preconfigured role. This role is called `Assist Role` or `Editor`, based on when your organization was created. Organization admins can edit these roles, or they can create new roles with more restrictive permissions using the following steps:

1. Navigate to **Settings** > **Roles & Permissions**. 
2. Select an existing role, or click **Create Role** to create a new custom role.
3. Locate the **Assist** section.
   1. Select **Use Assist with Ask mode only** to restrict the role from being able to use **Build** mode.
   2. Deselect both settings to restrict the role from being able to access Assist at all.
4. Click **Save changes**.
5. If you're creating a new role, reopen the role and switch to the **Assignment** tab. Click **+ Add group assignment** to assign a group to this role.
6. Click **Save changes**.

export function RBAC() {
  return (
    
      
    
  )
}

1. To ensure your users can access Assist, navigate to **Settings** > **AI**. 
   1. Verify that the **Retool AI** and **Assist Tab** settings are toggled on.
   2. Optionally, [configure a single model provider](#optional-configure-model-provider).
   3. Choose whether to show the Assist chat on the apps landing page.
2. Navigate to **Resources** > **Retool AI**. Ensure that each AI provider that you will use is enabled. You can choose to use Retool-managed keys or self-managed keys.
3. If required, configure your [roles and permissions](#configure-role-based-access-controls) to limit Assist access to certain groups.

Optional: Configure model provider

Retool designed Assist to use two AI providers by default: OpenAI and Anthropic. Using both providers enables Assist to optimize for speed and quality.

However, some customers may need to consolidate AI services with a single model provider. To accommodate these customers, admins on the Enterprise plan can configure Assist to work with a single model provider.

Retool currently supports the following options for Assist model providers:

:::note
If **Anthropic + OpenAI** is selected, Retool will first attempt to use the Anthropic resource for Anthropic requests. If the Anthropic resource is not enabled, Retool will attempt to send requests to Anthropic through Amazon Bedrock.
:::

- (Default) Anthropic + OpenAI.
- Only Anthropic.
- Only Amazon Bedrock.
- Only Azure OpenAI.

:::note

To enable the use of Amazon Bedrock or Azure OpenAI as a single model provider, reach out to your account manager.

:::

1. Navigate to **Settings** > **AI**.
2. Under **Assist Tab**, change the **Choose Assist provider** setting to your selected single model provider.

  AI settings page

:::note

App generation results may not be optimized when using a single model provider. Retool recommends setting **Choose Assist provider** to **Default: (Anthropic + OpenAI)**.

:::

Configure role-based access controls

Organization admins on the Business and Enterprise plans can use Retool's [role-based access controls](../../../permissions/guides/roles-permissions.mdx) to restrict a [group's](../../../permissions/quickstart.mdx#permission-groups) permissions for Assist to **Ask** mode only or to prevent Assist usage entirely. For example, admins might wish to restrict Assist usage to user groups who do not have access to sensitive data or PII. Alternatively, admins could restrict access to all user groups except for a pilot group that has approval to test AI tools.

By default, all builders have access to Assist and both **Ask** and **Build** mode through a preconfigured role. This role is called `Assist Role` or `Editor`, based on when your organization was created. Organization admins can edit these roles, or they can create new roles with more restrictive permissions using the following steps:

1. Navigate to **Settings** > **Roles & Permissions**. 
2. Select an existing role, or click **Create Role** to create a new custom role.
3. Locate the **Assist** section.
   1. Select **Use Assist with Ask mode only** to restrict the role from being able to use **Build** mode.
   2. Deselect both settings to restrict the role from being able to access Assist at all.
4. Click **Save changes**.
5. If you're creating a new role, reopen the role and switch to the **Assignment** tab. Click **+ Add group assignment** to assign a group to this role.
6. Click **Save changes**.

export function RBAC2() {
  return (
    
      
    
  )
}

## Self-hosted configuration

Complete the steps in the following sections if your deployment is self-hosted. Skip these steps if you use Retool Cloud.

### Configure environment variables

:::important

The following section is required only if your instance is self-hosted and you use [Retool-managed keys](../../../data-sources/concepts/models.mdx#retool-managed-and-self-managed-models). If you are using your own key, you can skip this section.

:::

import Partial from "../../../_shared/_retool-managed-self-hosted.mdx";

### Configure AI proxy

:::important

The following section is required only if your instance is self-hosted and you [use your own key](../../../data-sources/concepts/models.mdx#retool-managed-and-self-managed-models). If you are using a Retool-managed key, you can skip this section.

:::

If you use a proxy to make calls to LLM providers (such as [LiteLLM](https://www.litellm.ai/) or [LLM Proxy Server](https://pypi.org/project/llm-proxy-server/)), you must to configure the models for each provider that Assist uses.

Retool uses the following models for app generation with Assist:

| Provider       | Models                                                                                                |
| -------------- | ----------------------------------------------------------------------------------------------------- |
| OpenAI         | GPT-5.1GPT-5GPT-5-miniGPT-5-nanoGPT-4.1GPT-4.1-nano                          |
| Anthropic      | Claude Sonnet 4.5Claude Sonnet 4Claude Haiku 4.5 |
| Amazon Bedrock | Claude Sonnet 4.5Claude Sonnet 4Claude Haiku 4.5 |
| Azure OpenAI   | GPT-5.1GPT-5GPT-5-miniGPT-5-nanoGPT-4.1GPT-4.1-nano                          |

:::note

Enterprise customers can [select a single model provider](#configure-model-provider), but it is not possible to configure which models Assist uses. You must configure your proxy to use all the models associated with your chosen provider.

:::

## Choose a change management strategy

Assist includes an integrated versioning strategy, which identifies an initial version of your app and creates updated versions that it saves to history as users prompt. Users can view the versions in the  **Releases and history** tab.

As an admin, consider whether you would like to recommend a particular change management strategy to isolate Assist changes:

- **Releases**: Organizations on the Team, Business, and Enterprise plan can use [releases](../app-management/releases-history.mdx) to manage changes. Users can create a "before" version of the app, and roll back changes to that version if necessary.
- **Source Control**: Organizations on the Enterprise plan can use Source Control to [protect apps](../../../source-control/guides/protect/apps.mdx) before prompting Retool to make changes. Consider advising that users create a new branch to experiment with Assist.

## Track usage

Organization admins can monitor Assist usage in **Settings** > **Plans & Billing** under the **Assist billing** tab.

  Assist usage interface.

For more information about usage and billing, refer to the [pricing page](https://retool.com/pricing).

---

## AI-assisted app generation with Assist

Prompt Assist with natural language to generate apps, make changes to existing apps, and ask questions about Retool.

This guide provides an overview of Assist's features and frequently asked questions. Visit the [Configuration](./configure.mdx) or [Prompting](./prompt.mdx) guides to get started.

## Features

The following sections include information about Retool's app generation capabilities and limitations.

With Assist, Retool can create or edit apps:
  - Create all the UI and logic elements needed to create a functional multipage app, including components, pages, queries, code, and event handlers.
    
    Assist can _add_ the following components to the canvas. Retool can _edit_ any component on the canvas.
    - Buttons
      - Button Group
      - Button
      - Close Button
      - Dropdown Button
      - Link List
      - Link
      - Outline Button
      - Split Button
      - Toggle Button
    - Charts
      - Bar Chart
      - Heat Map
      - Line Chart
      - Pie Chart
      - Scatter Chart
      - Sparkline
      - Sunburst Chart
      - Treemap
    - Containers and forms
      - Collapsible Container
      - Container
      - Form
      - JSON Schema Form
      - Link Card
      - Stack
      - Stepped Container
    - Custom
      - HTML
      - IFrame
    - Data
      - Filter
      - JSON Explorer
      - Key Value
      - Reorderable List
      - Table
    - Date and time inputs
      - Calendar Input
      - Date Range
      - Date Time
      - Date
      - Day
      - Month
      - Time
      - Year
    - Integrations
      - AuthLogin
      - Mapbox Map
    - Navigation
      - Breadcrumbs
      - Navigation
      - Tabs
    - Number inputs
      - Currency
      - Editable Number
      - Number Input
      - Percent
      - Phone Number Input
      - Range Slider
      - Rating
      - Slider
    - Presentation
      - Alert
      - Avatar
      - Calendar
      - Circular Image
      - Divider
      - Event List
      - Icon Text
      - Icon
      - Image Grid
      - Image
      - PDF
      - Progress Bar
      - Progress Circle
      - QR Code
      - Spacer
      - Statistic
      - Status
      - Tags
      - Text
      - Timeline
      - Video
    - Repeatables
      - Container List View
      - Grid View
      - List View
    - Select inputs
      - Cascader
      - Checkbox Group
      - Checkbox Tree
      - Checkbox
      - Listbox
      - Multiselect
      - Radio Group
      - Segmented Control
      - Select
      - Switch
    - Special inputs
      - Agent Chat
      - Annotated Text
      - File Input
      - Signature
      - Timer
    - Text inputs
      - Email
      - JSON Editor
      - Password
      - Rich Text Editor
      - Text Area
      - Text Input
      - URL
    
  - Make changes to an existing multipage app, including existing components and queries.
  - (Cloud instances only) Write and edit [READMEs](../app-management/app-documentation.mdx#write-a-readme), or use an existing README for context about your app.
  - Intelligently apply [app-level or organization-level theming](../../guides/presentation-styling/themes.mdx) based on your input.
  - Remember conversation context so that you can iterate with follow-up requests and revert changes.

With Assist, Retool can interact with resources:
  - Generate, edit, and run queries for the most commonly used resources.
    
    - Analytics  
      - Databricks  
      - Datadog  
      - Google Search Console  
    - API  
      - GraphQL  
      - OpenAPI  
      - REST API  
      - SOAP API  
    - CRM  
      - BigID  
      - Close  
      - Front  
      - Salesforce  
    - Database  
      - AlloyDB  
      - Amazon DynamoDB  
      - Amazon Redshift  
      - BigQuery  
      - CosmosDB  
      - Google Cloud Datastore  
      - Google Sheets  
      - Microsoft SQL Server  
      - MongoDB  
      - MySQL  
      - Oracle Database  
      - PostgreSQL  
      - Presto  
      - SAP Hana  
      - Snowflake  
      - Vertica  
    - Development  
      - AWS Lambda  
      - CircleCI  
      - Firebase  
      - GitHub  
      - Google Maps  
      - gRPC  
    - Finance  
      - Stripe  
    - Messaging  
      - Microsoft Teams  
      - OneSignal  
      - SendGrid  
      - Slack  
      - SMTP  
    - Object and file store  
      - Amazon S3  
      - Google Cloud Storage  
    - Project management  
      - Asana
      - Google Calendar
      - Jira  
      - Notion
    
  - Generate a [Retool Database](../../../data-sources/quickstarts/retool-database.mdx) schema and populate the table with sample data.
  - Infer the intended resource from the prompt contex and surface it so that you can add it to the [Assist data access list](./prompt.mdx#prepare-resources).
  - Interact with resources using the permissions of the [current_user](../../reference/objects/current-user.mdx).

Assist can answer questions, including:
  - Answer questions about Retool, and provide links to documentation and the [Community Forum](https://community.retool.com/) for more information.
    :::note

    This capability is only supported on Retool Cloud. It is not yet available for self-hosted organizations.

    :::
  - Answer questions about an existing app, including about the purpose of the app and how it works.
  - Use the dedicated **Ask** mode to provide a safe, read-only environment to explore the app, troubleshoot, and ask questions.

In response to a user prompt, you cannot currently use Assist to perform certain tasks:

- Operate on other objects in your organizations, such as workflows, agents, folders, or mobile apps. Assist also can't modify organization settings, like permission groups.
- Create or edit [modules](../../guides/layout-structure/modules.mdx) or [custom components](../../guides/custom/custom-component-libraries/index.mdx).
- Style custom and legacy component, write custom CSS, or independently style dark and light modes.
- Generate apps that are mobile-responsive.
- Accept inputs that are not formatted as natural language (such as PDFs, spreadsheets, or images).
- Manage [releases](../../guides/app-management/releases-history.mdx).
- Leverage [preloaded or built-in JavaScript libraries](../../../queries/guides/javascript/custom.mdx).
- Selectively roll back some changes and keep others. Instead, [use the Assist checkpoints](./prompt.mdx#manage-changes) to revert the app back to a previous version.
- Add certain less common components to the canvas. Assist can add most components to the canvas, but there are a some less-common components that Assist cannot currently add to the canvas. If you prompt Assist to add one of these components, Assist can provide recommendations for other components to use.
  
    - Avatar Group  
    - Bounding Box  
    - Bubble Chart  
    - Color Input  
    - Comment Thread  
    - Editable Text  
    - Editable Text Area  
    - File Button  
    - File Dropzone  
    - Funnel Chart  
    - LLM Chat  
    - Looker  
    - Microphone  
    - Mixed Chart  
    - Multiselect Listbox  
    - Page Input  
    - Pagination  
    - Plotly JSON Chart  
    - Sankey Chart  
    - Scanner  
    - Stacked Bar Chart  
    - Steps  
    - Stripe Card Form  
    - Switch Group  
    - Tabbed Container  
    - Tableau  
    - Toggle Link  
    - Waterfall Chart  
    - Wizard
  
- Generate or edit queries for certain less common resources.
  
  - Amazon Athena
  - Amazon SQS
  - Amazon SNS
  - CouchDB
  - Elasticsearch
  - Google Analytics
  - Google Docs
  - Google Slides
  - Hubspot
  - Kafka
  - RethinkDB
  - Retool RPC
  - Retool AI
  - Tavily
  - Twilio
  

## Frequently asked questions

Refer to this section for commonly-asked questions.

### What AI models are required?

Organizations on the Free, Team, and Business plans must have *both* OpenAI and Anthropic AI providers enabled in the **Retool AI** resource, and they must use Retool-managed keys.

Admins on the Enterprise plan can [configure Assist to work with a single provider](./configure.mdx?plan=ent#optional-configure-model-provider). The currently supported options are OpenAI, Anthropic, Amazon Bedrock, and Azure OpenAI. Enterprise customers are also permitted to use self-managed models. For more information, refer to [Retool AI providers and models](../../../data-sources/concepts/models.mdx).

### Is there any charge for using Assist?

Usage of Assist is free for a limited time. Refer to the [Usage and billing](/support/billing-usage/assist) documentation for more information.

### My Retool deployment is Self-hosted. Can I use Assist?

Assist is available to all cloud organizations. Assist is available to self-hosted organizations on edge version 3.283 and later, and stable version 3.284.0 and later.

### Is Assist available for mobile apps, workflows, or agents?

No, Assist is currently available for web apps only.

### Does Retool store my prompts?

Yes, Retool stores your prompts and Assist's responses in an internal database. For more information, refer to the [Assist Beta Terms](/legal/assist-beta-terms#3-proprietary-rights).

### Can I enable Assist for a subset of my users, instead of all?

Retool does not currently support enabling Assist for only a subset of users in an organization. Instead, you can create a new [space](../../../org-users/tutorials/spaces.mdx) and invite only the users who you want to have access to Assist, and [enable Assist](./configure.mdx) in that space. Each space has its own user accounts, settings, and permissions.

### How do I provide Retool with my feedback or ask questions?

Please provide feedback in one of the following formats:

- Create a new topic on the [Community Forum](https://community.retool.com).
- Leave feedback in the Assist interface:
  - Click the  **Feedback** button at the top of the **Assist** tab to leave general feedback about Assist.
  - Label output with the  **Thumbs up** or  **Thumbs down** reaction, and submit feedback to Retool. 
  - As part of this feedback, Retool also receives your chat history and your user email address so that Retool can follow up with any questions.

---

## Prompt with Assist

import ChatIcon from "/img/icons/apps/assist.svg";

When you're ready to use Assist, open a new or existing app and locate the  **Assist** panel at the bottom of the [left panel of the IDE](../../concepts/ide.mdx#left-panel). You can also use cmd/ctrl i to toggle the panel.

:::note

This guide outlines the Assist interface, prompting experience, and best practices. For admins who need to configure their organization to use Assist, visit the [Configuration guide](./configure.mdx).

:::

The following video provides a demo and best practices for prompting Assist:

## Assist interface

:::note

The first time you use Assist, you may be prompted to accept some [Terms and Conditions](/legal/assist-beta-terms).

:::

The Assist interface has several important controls:

- The welcome screen includes a series of examples that demonstrate prompts that you could use with Assist.
- Write your prompt in the input box at the bottom of the panel. 
  - [Add resources](#prepare-resources) with the  icon.
  - Assist is in [**Build** mode](#build-and-ask-mode) by default. Click  to switch to **Ask** mode.
  - Click  or press Enter/Return to submit your prompt.
- Use a series of icons at the top of the panel to manage your Assist interactions:
  -  **Feedback**: Leave general feedback about Assist. As part of this feedback, Retool also receives your chat history and your user email address so that Retool can follow up with any questions. 
  -  **View history**: View and manage chat threads. You can view, rename, and delete chat threads.
  -  **New thread**: Create a new chat thread.
  -  **Usage**: View and manage usage. Refer to the [pricing page](https://retool.com/pricing) for information about Assist pricing. This icon is not present for users on an Enterprise plan. Instead, admins in these organizations can view usage information in their organization settings.
- Scroll, or use the up and down keys on your keyboard to navigate the message history.

export function Tour() {
  return (
    
      
    
  )
}

## Prepare resources

You retain full control over your resources, and Assist cannot create or modify them independently. Before prompting with Assist, [create or configure all resources](../../../data-sources/quickstarts/resources.mdx) that you want your app to use.

:::note

When configuring your resource, be as detailed as possible in the **Description** setting on the **Resource configuration** page. This information is passed to Assist, and it provides valuable context on when or how the resource should be used.

:::

When working with apps, Assist uses a **Resource access** list that identifies which resources in your organization it can use to write and modify queries. Assist can suggest adding other resources to this list, but you control what the **Resource access** list contains. Add resources to this list while prompting by **@** mentioning them or describing them. You can also add them explicitly.

To manually add resources to the **Resource access** list:

1. Open the  **Assist** panel in the app you want to create or edit.
2. Click  **Resource access** in the input field to open the **Assist resource access** window.
3. Identify the resources that you want to use while prompting. 

export function ResourceContext() {
  return (
    
      
    
  )
}

Once you're done, the  **Resource access** icon shows the number of resources you added. You can add or remove resources at any point. 

## Build and Ask mode

Retool supports two modes for prompting Assist:

* **Ask**: Assist cannot modify your app. Use this mode to brainstorm solutions, explore the app without making changes, and ask questions about Retool functionality.
* **Build**: Assist can create and edit apps. Use this mode when you want Assist to modify the app on your behalf. **Build** mode also includes all the abilities and knowledge of **Ask** mode.

  Toggle between **Ask** and **Build** mode.

Assist defaults to using **Build** mode. You can switch between modes at any time.

:::note

Organization admins can configure permission groups to have access to **Ask** and **Build**, or just **Ask** using role-based access controls. [Learn more](./configure.mdx#configure-role-based-access-controls).

:::

## Configure theme

You can also set or change your app theme using Assist. The experience of doing so depends on your organization's plan.

During app generation, Assist guides you through selecting a theme for your app. Choose between light or dark mode and select an accent color.

You can also set an app theme in your prompt. Be very clear and specific about your design intent. For example, "Create a dark mode theme with blue accent colors", or "Update the theme to match the Acme brand colors and style."

export function AppTheme() {
  return (
    
      
    
  )
}

The Business and Enterprise plans support [organization-level theming](/apps/guides/presentation-styling/themes#create-organization-level-themes). Assist will help you set a theme for your app in one of the following ways:

- If you haven't created any organization-level themes, Assist shows a theme selector to help you choose an app-level theme.
- If you have organization-level themes, but no default, Assist shows a list of your organization-level themes to choose from, or you can choose an alternative theme.
- If you have organization-level themes with a default set, Assist uses the default automatically.

You can also set an app theme in your prompt. Be very clear and specific about your design intent. For example, "Create a dark mode theme with blue accent colors", or "Update the theme to match the Acme brand colors and style."

export function OrgThemes() {
  return (
    
      
    
  )
}

## Prompting experience

Use the text input at the bottom of the **Assist** panel to enter your natural language prompt. When prompting, enter the **@** symbol to explicitly reference a resource, query, or component that you want Assist to use. Refer to the [best practices](#prompting-best-practices) for more guidance on how to prompt Assist.

Click  or press Enter/Return to submit your prompt.

Once you prompt, Assist proceeds through several planning steps. Assist might ask clarifying questions about your prompt, such as whether you'd like to connect Retool Database or use client-side mock data.

  Assist's initial planning phase.

Once Assist is done planning, it proceeds with creating or editing the code, components, and styling that you requested.

Assist asks you for permission to run and save queries. You can choose to be prompted every time, or you can auto-approve queries.

  Configure how you want to approve query runs.

When it's done building, Assist sometimes provides options for what to do next. You can select one of these options, or you can write another prompt.

  Choose what you'd like to do next.

The amount of information sent to the AI provider (the _context window_) increases as you build. Assist automatically summarizes long threads in order to prevent errors from a context window that is too large.

  Assist summarizes long threads.

## Manage changes

Assist includes an integrated versioning strategy, which identifies an initial version of your app and creates updated versions that it saves to [history](../app-management/releases-history.mdx#history) as you prompt. You can view the versions in the  **Releases and history** tab.

At any time while prompting, use the  **Revert to version** button to undo the changes made after that point. This makes it easy to roll back changes if you change your mind.

If you are on a Business or an Enterprise plan, you can also click  **Create release** to [create a new release](../app-management/releases-history.mdx) incorporating those changes.

Your organization admin may alternatively recommend using [Source Control](../../../source-control/index.mdx) for change management. 

## Prompting best practices

Consider the following best practices for writing effective [Assist](./index.mdx) prompts.

### Reference content from your organization

You can **@** mention resources, code, and components in your prompt. For example: `Update the data source for @supportTable to utilize the @Customer Support Tickets Database resource.`

### Give as much context as possible

Be as specific as you can about the type of app you want to create or the edits you want to make. The more detail you include about what you’re trying to build, the better Assist can do on the first pass. For example, instead of `Build me a dashboard of movies`, try `Build me a dashboard of movies released in the 1980s with search and filters by genre. I want to be able to add movies and provide my own rating.`

### Iterate and refine

If the first output isn't exactly what you expected, add more info or adjust your prompt. You can also manually edit your app and come back to Assist to continue where you left off. Working with Assist is designed to be an iterative process.

### Ask Assist to explore

If you're editing an existing app, ask Assist to explore what's currently on the page without making any changes. If you're introducing a new resource, ask Assist to tell you what information is available using that resource.

### Be specific about resource nuances

Databases (Retool Database, Postgres, MySQL, etc.) can be queried or modified using similar patterns, so Assist can reliably generate SQL queries. On the other hand, API request structures and specifications can vary widely between endpoints. Giving details about how your system is configured, or pasting API documentation into your prompt helps Assist understand the structure.

When configuring your resource, be as detailed as possible in the **Description** setting on the **Resource configuration** page. This information is passed to Assist, and it provides valuable context on when or how the resource should be used.

### Use references when available

When you can, paste schema details, API docs, or example data into your prompt. This helps Assist understand the shape of your data and the actions you want to take.

---

## Build custom React components

:::note Custom components libraries

Custom components libraries are distinct from the [legacy custom component feature](../legacy-custom.mdx). Retool does not recommend creating custom components using the legacy feature.

:::

If Retool's built-in components don't work for your use case, you can build custom components in React. Custom components can leverage public or private npm packages, as they are written locally in your development environment and then deployed to Retool. After deploying, you can drag and drop components into apps as you would any other component.

To allow custom components to interact with your Retool app, Retool provides a [TypeScript API](./typescript-api.mdx). This API lets you define events that trigger event handlers and add properties to the Inspector for your component.

Custom components are contained within libraries, and each library has a unique name. Custom components deployed to Retool are automatically shown in the Component Library, in a section that matches the library's label.

## Prerequisites

To build a custom component library, you need:

- [Node.js](https://nodejs.org/) v20 or later installed in your development environment.
- [Admin permissions](../../../../permissions/guides/configure-permission-groups#default-permission-groups) in Retool.
- [Optional] If you are running self-hosted Retool, setting the [`ALLOW_SAME_ORIGIN_OPTION`, and `SANDBOX_DOMAIN` environment variables](../../../../self-hosted/guides/origin-sandbox.mdx) is recommended.

The following steps guide you through the development flow to create and use a custom component. The example component contains a **Name** property and displays a message with the provided name. The code will look something like this:

```javascript
export const HelloWorldComponent: FC = () => {
  // Allows the builder to specify a "name" property on each component they build with.
  // The builder can then pass data from their Retool app into the component by setting a value
  // for the "name" property.
  const [name, setName] = Retool.useStateString({
    name: "name",
  });

  return (
    
      Hello {name}!
    
  );
};
```

After building the component, you can drag it to the canvas like any other component.

## 1. Clone the template repository

Clone the [custom-component-collection-template](https://github.com/tryretool/custom-component-collection-template) GitHub repository.

```bash
git clone https://github.com/tryretool/custom-component-collection-template new-custom-component
```

```bash
git clone git@github.com:tryretool/custom-component-collection-template.git new-custom-component
```

## 2. Install dependencies

Change your directory to `new-custom-component` and run:

```bash
npm install
```
:::tip 

It's possible to use almost any `npm` packages that support being run in the browser, including from private `npm` repositories.

:::

## 3. Log in to Retool

Log in using the following command. You need to provide an API access token with read and write scopes for **Custom Component Libraries**. See the [Retool API authentication documentation](../../../../org-users/guides/retool-api/authentication.mdx#create-an-access-token) for instructions on generating an access token.

```bash
npx retool-ccl login
```

## 4. Create a component library

Create a component library for your component.

```bash
npx retool-ccl init
```

This command guides you through picking a name and description for your library. It then adds those and other metadata to your local `package.json` file and calls Retool to construct the library.

## 5. Rename your component

Rename the `HelloWorld` component as needed. All components exported from `src/index.tsx` are synced to Retool.

## 6. Start dev mode

Use [dev mode](./retool-ccl.mdx#dev-mode) to test changes as you build your component:

```bash
npx retool-ccl dev
```

This syncs changes to Retool every time you change a file. You can then test component changes in any Retool app.

## 7. Add components to the canvas

Select the custom component from the **Add components** panel, and drag it into your app. The name of the custom component is the same as the name of your exported React component. The component is displayed in a section titled with the label of your library. You may need to refresh the page for new components to show up in the **Add components** panel.

## 8. Develop your component

Write code for your component in your preferred editor. See the [TypeScript API](./typescript-api.mdx) section for more information about how to develop your component.

## 9. Deploy your component

When you're done creating your component, deploy it with the following command:

```bash
npx retool-ccl deploy
```

This pushes an immutable version of the component to Retool.

Now your component library is ready for production use. If you want to use your component library in public apps, then you need to go to **Settings > Custom Component Libraries** and set it to be public as well. This will expose the component library to anyone who has access to the public app URL.

If you want to [avoid interactively](./retool-ccl.mdx#non-interactive-mode) providing arguments while running `npx retool-ccl`, you can instead provide them on the command line.

## 10. Switch component versions

To pin your app to the component version you just published, navigate to the **Custom Component** settings in your Retool app and change `dev` to the latest version. This may require you to refresh the page to see the newly published version.

## Examples

Refer to the `custom-component-examples` [GitHub repository](https://github.com/tryretool/custom-component-examples/tree/main/src) for custom component examples.

## Limitations
There are some limitations on how custom component libraries can be used. 

- Custom component libraries aren't supported in Retool Mobile.
- Custom component library descriptions cannot be edited.
- Individual library revisions cannot be larger than 10MB, or 30MB in dev mode.
- Custom component libraries only load JavaScript and CSS files at runtime. Any other file included in the revision bundle is ignored.
- [Node.js](https://nodejs.org/) v20 or later is required for your development environment.
- [Admin permissions](../../../../permissions/guides/configure-permission-groups#default-permission-groups) in Retool are required.
- Custom components must be written in React and Typescript.
- When you [download a page](../../../../queries/guides/generate-pdfs.mdx) in PDF format, custom components are not included.

:::note
For Retool Cloud organizations, there is a 5GB limit on the total size of all custom component libraries within an organization. If you need to deploy new revisions and have reached this limit, you can free up space by visiting the **Custom Components** settings page and deleting some existing libraries.

:::

---

## Use Retool custom component library

When developing custom components, Retool recommends you use the Retool custom component library (`retool-ccl`) utility's `dev` function (dev mode). Dev mode updates your component in Retool as you make edits, which means you don't have to constantly deploy new versions and update your app in Retool. 

Each developer (identified by the access key supplied at `npx retool-ccl login`) has their own `dev` revision of the component library.

## Dev mode
Run the following command to use dev mode. The first time you run this command for a library it creates your `dev` version in Retool.

```bash
npx retool-ccl dev
```
This command continues to run and watch for file changes. Whenever you save your component files, they're automatically reflected in your Retool app. 

:::note

When you're ready to publish an app with a custom component, be sure to change your app to use a published version of the component instead of a `dev` version.

:::

The `dev` mode branch to use is determined by the creator of the access token being used to authenticate with retool-ccl. For example, if user **admin@yourdomain.com** uses an access token they created to sign in with retool-ccl, each time they use dev mode it will create/update the dev mode version on the **admin@.yourdomain.com** branch.

Multiple developers can safely use `dev` mode with the same library concurrently by using separate `dev` mode branches. Ensure that each developer has their own unique access token to work on the same library at the same time and prevent overwriting other changes.

Once you create a `dev` version, you can use it in a Retool app for testing during development of a custom component. You can also switch between any published or `dev` version from **••• App settings** > **Custom Components**. Each `dev` version is listed with the access token creator's email address.

## Update your component

To update your component, run `npx retool-ccl dev`, and then navigate to your app's **Custom Component** settings to change the version back to `dev`. When you're finished, follow the same steps to deploy your component and pin the app to the latest version.

:::warning

To delete a library, sign in to your Retool organization and navigate to **Settings > Custom Component Libraries**. Removing a custom component library deletes all components in the library from your app.
:::

## Debug your components

As you build a custom component, you may need to troubleshoot issues that arise. When using dev mode, Retool includes source maps for your components, so you can use your browser's step-by-step debugging tools to debug any issues that come up.

:::note

You can add the `-v` option to the `deploy` and `sync` commands to print more detailed errors for help with debugging.

:::

## Expand your library

You can add multiple custom components to your library by exporting more React components from `src/index.tsx` (only components exported from this file are detected). You can also create multiple libraries by creating a separate TypeScript project and following the steps in the [Create a custom component](./index.mdx) guide.

## Use custom component libraries across multiple instances or Spaces

If you deploy applications to [multiple instances](../../../../self-hosted/concepts/multi-instance-deployment.mdx) or to [Retool Spaces](../../../../org-users/tutorials/spaces.mdx), additional steps are required to use custom component libraries across them. When deploying the same custom component library to multiple instances or Spaces, choose a primary instance or Space for your components. This is the only instance or Space that you should ever [log in](./index.mdx#3-log-in-to-retool) or [deploy](./index.mdx#9-deploy-your-component) your components to.

To use your components on other instances or Spaces, sync them from your primary instance or Space with the following command:

```bash
npx retool-ccl sync
```

This command guides you through configuring a sync target, and then copies over the library and all available versions. When new versions are available in the primary instance or Space, re-run the sync command to copy them to any others. Any applications that reference these components automatically use the recently synced version.

## Send custom HTTP headers or cookies 

If you have a self-hosted Retool deployment, you can use `npx retool-ccl` to send additional custom headers or cookies with each HTTP request. This can be helpful if there is an application load balancer that:

 - Is between where you develop your custom components and the deployment instance.
 - Blocks HTTP requests that are missing certain authentication headers or cookies. 

To send custom HTTP headers or cookies, use the `--header 'header-name: header_value'` option when using `npx retool-ccl`.

Every command supports this option. You can also include it multiple times for each header to include.

```bash
npx retool-ccl login --header 'header-name: header_value' --header 'header-name-2: header_value_2'
```

When using the `sync` command, include `--target-header` to specify headers for the target instance of Retool. `--header` sends headers to the origin instance of Retool.

```bash
npx retool-ccl sync --header 'origin-header-name: value_1' --target-header 'target-header-name: value_2'
```

You can also send multiple cookies using a header name of `Cookie`.

```bash
npx retool-ccl deploy --header 'Cookie: cookie_one=cookie_value_one; cookie_two=cookie_value_two'
```

## Non-interactive mode

Some uses of `npx retool-ccl` involve asking the user for arguments, such as the access token they want to use. It is possible to instead provide these arguments in the original invocation of the command, if you want to avoid providing them interactively. For example, you can deploy a new revision by running the following command, without needing to run `npx retool-ccl login` first. 

```bash
npx retool-ccl deploy --url http://yourretoolinstance.com --access-token retool_01...8cp
```

Provide access tokens and URLs using the arguments `--access-token` and `--url`. For the `sync` command, you can also use `--target-access-token` and `--target-url` for the target Retool instance.

All arguments can also be provided as environment variables, including access token and URL arguments, using the format `RETOOL_CCL_${argument_name_capitalized}`. For example:

```bash
RETOOL_CCL_URL=http://yourretoolinstance.com RETOOL_CCL_ACCESS_TOKEN=retool_01...8cp npx retool-ccl deploy
```

---

## Use TypeScript API to configure custom components

You can use the TypeScript API to add properties, pass data, and set up event handlers for your custom components. You can also enhance your custom component library, designate a primary instance or Space for deployment, and include custom headers or cookies in self-hosted Retool deployments.

## Add properties to custom components
You can add properties to custom components that pass data to and from the Retool app using the [TypeScript API](#typescript-api). 

```javascript
export const HelloWorldComponent: FC = () => {
  // Allows the builder to specify a "name" property on each component they build with.
  // The builder can then pass data from their Retool app into the component by setting a value
  // for the "name" property.
  const [name, setName] = Retool.useStateString({
    name: "name",
  });

  return (
    
      Hello {name}!
    
  );
};
```

The above component has a `name` property that any builder can then pass data into, like any other Retool component. For example, you can assign the value of `name` to be `{{query[0].name}}`, which sets `name` to be the result of a query in your Retool app. In the below example, `{{query[0].name}}` resolves to `Daniel`, which the custom component then displays.

![Setting name to query[0].name](https://d3399nw8s4ngfo.cloudfront.net/docs/18682e16bb803fb0f728ce286c67047f-1800.webp)

To pass data from the component back to your Retool app, you can use the `setName` method to set the value of `name` from within your custom component, and then reference this value in the rest of your Retool app using `{{yourCustomComponentId.name}}`.

## TypeScript API

Custom components can interact with the Retool app they are added to. They can fetch their state from Retool, set their default size when dragged onto the canvas, or tell Retool that one of their events has fired. There are separate TypeScript methods for each of these actions.

### Pass data into a custom component

The following `useState` functions allow you to pass data from your Retool app into your custom component. Each function is for a different type of data.

```javascript title="Method signature"
/**
  * This method allows you to add boolean state to your component.
  * Like any other component in Retool, custom components can have their own state, which you can then edit using the inspector.
  *
  * @param {string} name The name of the state used internally, and the label that will be used in the Inspector to identify it.
  *   This should be an alphanumerical string with no spaces.
  * @param {boolean} [initialValue] The initial value for the state when the component is dragged onto the canvas.
  * @param {('text' | 'checkbox' | 'hidden')} [inspector] What kind of Inspector will be used when a builder is editing this state.
  * @param {string} [description] What will be displayed in the tooltip of the Inspector for this state.
  * @param {string} [label] An override for the label used in the Inspector for this state.
  *
  * @return {[boolean, (newValue: boolean) => void]} The value of the state, and a function to update it.
  */
function useStateBoolean({
  name,
  initialValue,
  inspector,
  description,
  label,
}: {
  name: string
  initialValue?: boolean
  label?: string
  description?: string
  inspector?: 'text' | 'checkbox' | 'hidden'
}): readonly [boolean, (newValue: boolean) => void]

/**
  * This method allows you to add number state to your component.
  * Like any other component in Retool, custom components can have their own state, which you can then edit using the Inspector.
  *
  * @param {string} name The name of the state used internally, and the label that will be used in the Inspector to identify it.
  *   This should be an alphanumerical string with no spaces.
  * @param {number} [initialValue] The initial value for the state when the component is dragged onto the canvas.
  * @param {('text' | 'hidden')} [inspector] What kind of Inspector will be used when a builder is editing this state.
  * @param {string} [description] What will be displayed in the tooltip of the Inspector for this state.
  * @param {string} [label] An override for the label used in the Inspector for this state.
  *
  * @return {[number, (newValue: number) => void]} The value of the state, and a function to update it.
  */
function useStateNumber({
  name,
  initialValue,
  inspector,
  description,
  label,
}: {
  name: string
  initialValue?: number
  label?: string
  description?: string
  inspector?: 'text' | 'hidden'
}): readonly [number, (newValue: number) => void]

/**
  * This method allows you to add string state to your component.
  * Like any other component in Retool, custom components can have their own state, which you can then edit using the Inspector.
  *
  * @param {string} name The name of the state used internally, and the label that will be used in the Inspector to identify it.
  *   This should be an alphanumerical string with no spaces.
  * @param {string} [initialValue] The initial value for the state when the component is dragged onto the canvas.
  * @param {('text' | 'hidden')} [inspector] What kind of Inspector will be used when a builder is editing this state.
  * @param {string} [description] What will be displayed in the tooltip of the Inspector for this state.
  * @param {string} [label] An override for the label used in the Inspector for this state.
  *
  * @return {[string, (newValue: string) => void]} The value of the state, and a function to update it.
  */
function useStateString({
  name,
  initialValue,
  inspector,
  description,
  label,
}: {
  name: string
  initialValue?: string
  label?: string
  description?: string
  inspector?: 'text' | 'hidden'
}): readonly [string, (newValue: string) => void]

/**
  * This method allows you to add enumeration state to your component. This is state that can have a value drawn from a limited set of strings.
  * Like any other component in Retool, custom components can have their own state, which you can then edit using the Inspector.
  *
  * @param {string} name The name of the state used internally, and the label that will be used in the Inspector to identify it.
  *   This should be an alphanumerical string with no spaces.
  * @param {T} enumDefinition An array of string literals describing the possible enum values. The strings must be alphanumeric with no spaces.
  * @param {T[number]} [initialValue] The initial value for the state when the component is dragged onto the canvas.
  * @param {{[K in T[number]]: string}} [enumLabels] Alternative labels to use for enums when displaying them.
  * @param {('segmented' | 'select')} [inspector] What kind of Inspector will be used when a builder is editing this state.
  * @param {string} [description] What will be displayed in the tooltip of the Inspector for this state.
  * @param {string} [label] An override for the label used in the Inspector for this state.
  *
  * @return {[T[number], (newValue: T[number]) => void]} The value of the state, and a function to update it.
  */
function useStateEnumeration({
  name,
  enumDefinition,
  initialValue,
  enumLabels,
  inspector,
  description,
  label,
}: {
  name: string
  initialValue?: T[number]
  enumDefinition: T
  enumLabels?: {
    [K in T[number]]: string
  }
  inspector?: 'segmented' | 'select' | 'hidden'
  description?: string
  label?: string
}): readonly [T[number], (newValue: T[number]) => void]

/**
  * This method allows you to add serializable object state to your component.
  * Like any other component in Retool, custom components can have their own state, which you can then edit using the Inspector.
  *
  * **NOTE:** Due to the internal mechanism used, the setter will apply new values as a partial update of the current state, similar to `Object.assign()`.
  *
  * @param {string} name The name of the state used internally, and the label that will be used in the Inspector to identify it.
  *   This should be an alphanumerical string with no spaces.
  * @param {SerializableObject} [initialValue] The initial value for the state when the component is dragged onto the canvas.
  * @param {('text' | 'hidden')} [inspector] What kind of Inspector will be used when a builder is editing this state.
  * @param {string} [description] What will be displayed in the tooltip of the Inspector for this state.
  * @param {string} [label] An override for the label used in the Inspector for this state.
  *
  * @return {[SerializableObject, (updates: SerializableObject) => void]} The value of the state, and a function to update it.
  */
function useStateObject({
  name,
  initialValue,
  inspector,
  description,
  label,
}: {
  name: string
  initialValue?: SerializableObject
  inspector?: 'text' | 'hidden'
  description?: string
  label?: string
}): readonly [SerializableObject, (updates: SerializableObject) => void]

/**
  * This method allows you to add serializable array state to your component.
  * Like any other component in Retool, custom components can have their own state, which you can then edit using the Inspector.
  *
  * @param {string} name The name of the state used internally, and the label that will be used in the Inspector to identify it.
  *   This should be an alphanumerical string with no spaces.
  * @param {SerializableArray} [initialValue] The initial value for the state when the component is dragged onto the canvas.
  * @param {('text' | 'hidden')} [inspector] What kind of Inspector will be used when a builder is editing this state.
  * @param {string} [description] What will be displayed in the tooltip of the Inspector for this state.
  * @param {string} [label] An override for the label used in the Inspector for this state.
  *
  * @return {[SerializableArray, (newValue: SerializableArray) => void]} The value of the state, and a function to update it.
  */
function useStateArray({
  name,
  initialValue,
  inspector,
  description,
  label,
}: {
  name: string
  initialValue?: SerializableArray
  inspector?: 'text' | 'hidden'
  description?: string
  label?: string
}): readonly [SerializableArray, (newValue: SerializableArray) => void]
```

```javascript title="Example"
export const HelloWorldComponent: FC = () => {
  // Allows the builder to specify a "name" property on each component they build with.

  const [showBorder, _setShowBorder] = Retool.useStateBoolean({
    name: "showBorder",
    initialValue: false,
    label: "Show Border",
    inspector: "checkbox",
  });

  return (
    
      Hello!
    
  );
};
```

### Trigger event handlers

The `Retool.useEventCallback` method allows you to notify Retool of component events, which can then be used to trigger event handlers within Retool.

```javascript title="Method signature"
/**
  * Defines an event callback for your component. While building with the component you will be able to create event handlers that are triggered
  * whenever this event callback is called.
  *
  * For example, you could create an event callback which is triggered whenever a user clicks on a button in your component.
  *
  * The event cannot contain any data or context.
  *
  * @param {string} name The name of the label that the event callback will be given in the Inspector.
  */
function useEventCallback({ name }: { name: string }): () => void

```

```javascript title="Example usage"
export const ButtonComponent: FC = () => {
  // Allows the custom component to inform Retool when a click event
  // happens on the component. You can then add event handlers to any ButtonComponent
  // that is triggered when onClick is called.
  const onClick = Retool.useEventCallback({ name: "click" });

  return (
    
       A button 
    
  );
};
```

#### Passing data with an event

Data from a custom component can't be included inside an event. To access this kind of data in an event handler, set state in the component before firing the event (in this example `text`), and then access that state as you normally would in the event handler.

```javascript title="Accessing component data in an event handler"
export const CustomInput: FC = () => {
  const [text, setText] = Retool.useStateString({
    name: "text",
    inspector: "hidden",
  });

  const clickEvent = Retool.useEventCallback({ name: "click" });
  return (
    
       {
          setText(change.target.value);
        }}
      />
       clickEvent()}>submit
    
  );
};
```

In your event handler, you can then access the value of `{{componentId.text}}`.

![Event handler that references the text property](https://d3399nw8s4ngfo.cloudfront.net/docs/929f79aa890fc2f3089465aeb03045cd-1800.webp)

### Set the component size

`Retool.useComponentSettings` allows you to set the size of the component when it is first dragged onto the canvas.

```javascript title="Method signature"
 /**
  * Allows configuration of various settings on your component.
  *
  * @param {string} defaultWidth Sets the default width in columns of the component when you drag it onto the canvas.
  * @param {string} defaultHeight Sets the default height in rows of the component when you drag it onto the canvas.
  */
function useComponentSettings({
  defaultWidth,
  defaultHeight,
}: {
  defaultWidth?: number
  defaultHeight?: number
}): void
```

```javascript title="Example usage"
export const HelloWorldComponent: FC = () => {
  // Sets the default height and width when HelloWorldComponent is
  // dragged onto the canvas.
  // dragged onto the canvas. Note that the rows are much shorter than the columns.
  Retool.useComponentSettings({
    defaultHeight: 50,
    defaultWidth: 5,
  });

  return Hello!;
};
```

---

## Getting started with the IFrame component

The [IFrame component](../../reference/components/custom/iframe.mdx) provides a content area in which you can embed a web page via URL.

import WebPlayground from '/docs/_partials/_components/_web-playground.mdx';
 

:::note

Use an [HTML](../../reference/components/custom/html.mdx) component to include custom HTML and CSS instead of an embedded web page. You can also use a [Custom Component](./custom-component-libraries/index.mdx) to include custom React, HTML, and JavaScript.

:::

## Features

Key features of the IFrame component include:

- Permissions to allow or deny downloads.
- Form submissions.
- Microphone and camera access.
- Customizeable style.

## Specify content options

The **Content** section of the Inspector contains settings that control the content of the IFrame component. Add the web page **URL**, and configure tooltips in the **Add-ons** section.

You can use embedded expressions to dynamically populate all or part of the URL. For example, you could use an IFrame component to display the Retool Self-hosted release documentation. If you had a Select component that enabled a customer to select "Stable" or "Edge", you could set the IFrame component **URL** to `https://docs.retool.com/releases/{{ select1.selectedItem.value }}`.

### Set HTTP headers

If you are embedding a web page that you host yourself, you might need to set [HTTP headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers) in order for your content to appear properly.

Retool recommends applying the following settings:

```
Access-Control-Allow-Origin: https://.retool.com;
Content-Security-Policy: frame-ancestors https://.retool.com;
```

## Configure user interaction

The **Interaction** section of the Inspector contains settings that control user interaction. The IFrame component does not support [event handlers](../interaction-navigation/event-handlers.mdx), but it supports a variety of interaction options that you can turn on or off depending on your needs.

import FxSvg from '/img/icons/fx.svg';

To dynamically set these values, toggle  next to the checkbox and use JavaScript to set a truthy value.

Many sites require the **Storage and cookies** setting to be enabled. Toggling on this component enables the `allow-same-origin` flag on the IFrame component. If your deployment is self-hosted, you must also [configure your environment variables appropriately](../../../self-hosted/guides/origin-sandbox.mdx#update-environment-variables).

:::note

If your web page requires authentication, Retool cannot handle this authentication process. You can allow authentication via URL (using a temporary password), or users must authenticate the web page inside the component.

:::

import Appearance from "/docs/_shared/_appearance.mdx";

**Show top bar** displays the title of the IFrame component and UI controls that refresh the page or open it in full screen.

:::note

The **Fullscreen** and **Top level navigation** settings must also be enabled in order for the top bar UI controls to function.

:::

---

## Custom and embedded content



---

## Configure custom keyboard shortcuts for web apps

In addition to Retool's built-in [keyboard shortcuts](../../reference/keyboard-shortcuts.mdx), you can define custom keyboard shortcuts on a per-app basis. Custom shortcuts can be a single character, combination of keys, or a sequence of key presses. You configure the action to trigger with [JavaScript](../../../queries/quickstart.mdx) and can use many of the available methods in Retool to control components, queries, and more.

Click the gear icon in the left panel to open the **App Settings** tab and select **Custom shortcuts**.

### Define shortcut keys

To add a shortcut, navigate to the [App Inspector](../../concepts/ide.mdx#app-inspector) and click **+** in the **Custom shortcuts** section. Specify the shortcut keys to use and the JavaScript to run.

export function CustomShortcut() {
  return (
    
      
    
  )
}

#### Available shortcut keys

A custom shortcut can include almost any keyboard character or symbol, such as a or $, and optional modifier keys, such as ctrl.

:::note

Shortcuts that use a single uppercase letter or secondary character, such as `A` or `@`, automatically require Shift—you don't need to include it in the shortcut.

:::

You can include modifier keys in custom shortcuts. Modifier keys are commonly used for keyboard shortcuts but are not required. Modifiers, named keys, and reserved symbols must be explicitly named when used in a shortcut.

| Modifier    | Key                                              |
| ----------- | ------------------------------------------------ |
| `shift`     | Shift (PC and Mac)                    |
| `ctrl`      | ctrl (PC and Mac)                     |
| `alt`       | Alt (PC) or Option (Mac)   |
| `mod`       | ctrl (PC) or Command (Mac) |
| `command`   | Command (Mac only)                    |
| `super`     | Windows (PC only)                     |
| `backspace` | Backspace (PC and Mac)                |
| `space`     | Space (PC and Mac)                    |
| `esc`       | Escape (PC and Mac)                   |
| `plus`      | + (PC and Mac)                        |

Certain modifiers automatically change based on the user's platform (e.g., `mod`) or you can explicitly define modifiers be the same (e.g., `ctrl`).

#### Key combination or sequence

You can define a combination or sequence of keys to trigger a shortcut.

- **Combination**: Separate the keys with `+` (e.g., `alt+5`). You must press the keys simultaneously to trigger the shortcut. Key combinations do not require a modifier key and you could use a combination of character keys.
- **Sequence**: Separate keys with a space (e.g., `w a s d`). You must press the defined keys in sequential order to trigger the shortcut.

:::note

Sequence or combination shortcuts that contain Command or ctrl will apply anywhere in an app. Other modifier keys such as Shift, Alt, or Option will not trigger inside inputs, as they are needed for special characters and capitalization.

:::

### Configure JavaScript actions

You can [write JavaScript](../../../queries/quickstart.mdx) actions for custom shortcuts that interact with almost every aspect of an app. The following examples trigger actions using Retool's built-in [JavaScript utility methods](../../../queries/reference/libraries/utils.mdx).

| Keys     | JavaScript                                                 | Shortcut                                                                              |
| -------- | ---------------------------------------------------------- | ------------------------------------------------------------------------------------- |
| `j`      | `utils.confetti()`                                         | j to show confetti.                                                        |
| `J`      | `utils.showNotification({title: 'Hello, World!'})`         | Shift j to display a notification.                              |
| `ctrl+j` | `utils.copyToClipboard(moment().format('dddd'))`           | ctrl j to copy the current day to the clipboard.                |
| `r e`    | `utils.openUrl('https://retool.com', { newTab: 'true', })` | r then e to open [retool.com](https://retool.com) in a new tab. |

You can also use write shortcuts with complex logic to conditionally perform actions or chain together multiple actions. For example, you can define a single shortcut to cycle through all views in a Tabbed Container component.

```javascript title="Cycle through views"
tabbedContainer1.views.length === tabbedContainer1.currentViewIndex + 1
  ? tabbedContainer1.setCurrentViewIndex(0)
  : tabbedContainer1.showNextVisibleView();
```

---

## Build custom components

:::danger Use custom component libraries

This method for building custom components is deprecated. Use [custom component libraries](./index.mdx) feature for developing custom components.

:::

If Retool's built-in components don't work for your use case, you can build your own custom component in React or JavaScript.

:::note You may not need a custom component

Check Retool's [Component Library](https://retool.com/components) before you start to build a custom component to see if any existing components are suitable. If your component serves a common use case, consider submitting a feature request to Retool.

:::

## Overview

A custom component consists of:

- A place to put the HTML, CSS, and JavaScript which governs the appearance and behavior of the component. You enter this in the **IFrame Code** field of the Inspector, and Retool puts this code in an iFrame in the outer Retool app.
- An interface for passing data back and forth between the Retool app and the custom component code.

You can also enable additional custom component features, such as the ability for your component to download files, in the **Interaction** menu of the Inspector.

## Interface

The following methods and objects are used to pass data and state between your Retool app and your custom component. These methods are available for both React and non-React JavaScript custom components.

| Name           | Type        | Parameter | Description                                                                                                                                                                                                                                                                                           |
| -------------- | ----------- | --------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `triggerQuery` | function    | string    | Triggers the specified Retool query.                                                                                                                                                                                                                                                                  |
| `model`        | JSON object | N/A       | Represents the data to pass from your app to your custom component.                                                                                                                                                                                                                                   |
| `modelUpdate`  | function    | object    | Updates the custom component's `model` to the specified fields. This allows the custom component to update its own state, which is available to the rest of the Retool app. You can think of `modelUpdate` as analogous to [setState in React](https://react.dev/reference/react/Component#setstate). |

## Connect interface for React components

Connect your React component to Retool by calling `Retool.connectReactComponent(customComponentName)`. This exposes the `triggerQuery`, `model`, and `modelUpdate` variables. You can then access them in your component.

## Connect interface for non-React components

For non-React components, Retool also exposes the `subscribe` method, in addition to `triggerQuery`, `model`, and `modelUpdate`.

To access `triggerQuery`, `modelUpdate`, and `subscribe`, use the `window.Retool` prefix.

```javascript
function buttonClicked() {
  window.Retool.triggerQuery("query1");
}
```

You can only access `model` and its keys within `window.Retool.subscribe`.

```javascript
window.Retool.subscribe(function (model) {
  console.log(model.name);
});
```

## Minimum custom component with React

`boilerplate.html` below shows the minimum code needed to create a functional custom component with React.

```html title="boilerplate.html"

  const MyCustomComponent = ({ triggerQuery, model, modelUpdate }) => (
    Hello, Retool!
  );
  const ConnectedComponent = Retool.connectReactComponent(MyCustomComponent);
  const container = document.getElementById("react");
  const root = ReactDOM.createRoot(container);
  root.render();

```

## Minimum custom component with JavaScript

`boilerplate_basic.html` shows an example of a custom component without React.

```html title="boilerplate_basic.html"

  
    
      function updateName(e) {
        window.Retool.modelUpdate({ name: e.target.value });
      }
      function buttonClicked() {
        window.Retool.triggerQuery("query1");
      }
      window.Retool.subscribe(function (model) {
        // subscribes to model updates
        // all model values can be accessed here
        document.getElementById("mirror").innerHTML = model.name || "";
      });
    
    
    Trigger Query
    
  

```

```json title="model.json"
{
  "name": "Default name"
}
```

## Pass data to your custom component

To pass the data from components or queries to your custom component, set the data as the value of the custom component object in the **Model** field. In the following example, `model.name` updates whenever the value of `textInput1` updates.

```html title="inflow.html"

  const MyCustomComponent = ({ triggerQuery, model, modelUpdate }) => (
    Hello, {model.name}!
  );
  const ConnectedComponent = Retool.connectReactComponent(MyCustomComponent);
  const container = document.getElementById("react");
  const root = ReactDOM.createRoot(container);
  root.render();

```

```json title="model.json"
{
  "name": {{textInput1.value ? textInput1.value : 'World'}}
}
```

## Pass data to your app from your custom component

You can also access data from your custom component in other components and queries in your app. In the following example code, `modelUpdate` sets the value of `model.name` to the custom component's `Input` value when it updates, similar to `setState` in React. The value can be accessed in your app using `{{ customComponent.model.name }}`.

```html title="outflow.html"

  body {
    border: 5px solid red;
  }
  #react {
    display: flex;
    justify-content: center;
    align-items: center;
  }

  const { Input } = window["material-ui"];
  const MyCustomComponent = ({ triggerQuery, model, modelUpdate }) => (
     modelUpdate({ name: e.target.value })}
    />
  );
  const ConnectedComponent = Retool.connectReactComponent(MyCustomComponent);
  const container = document.getElementById("react");
  const root = ReactDOM.createRoot(container);
  root.render();

```

## Trigger queries from your custom component

Use the `triggerQuery` function to trigger a query from your custom component.

In the following example, `searchProducts` is triggered when the user clicks the Search button and optionally enters a search term, handled by the `onClick` event listener of the `Button` component. The component's `model` and `modelUpdate` default to `%` in order to return all products when no search term is present.

```html title="triggerquery.html"

  body {
    border: 5px solid red;
  }
  #react {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100%;
  }
  .button {
    margin-left: 1em;
  }

  

  const { Input, Button } = window["material-ui"];
  const MyCustomComponent = ({ triggerQuery, model, modelUpdate }) => (
    
      
          modelUpdate({ name: e.target.value ? e.target.value : "%" })
        }
      />
       triggerQuery("searchProducts")}
      >
        Search
      
    
  );
  const ConnectedComponent = Retool.connectReactComponent(MyCustomComponent);
  const container = document.getElementById("react");
  const root = ReactDOM.createRoot(container);
  root.render();

```

```sql title="searchProducts.sql"
SELECT
  *
FROM
  products
WHERE
  name ILIKE {{ '%' + customcomponent1.model.name + '%' }}
```

```json title="model.json"
{
  "name": "%"
}
```

## Quirks vs no-quirks rendering 

Custom components are rendered inside of an iframe. When HTML documents, such as iframes, are rendered in a browser, this is done using [quirks or no-quirks mode](https://developer.mozilla.org/en-US/docs/Web/HTML/Quirks_Mode_and_Standards_Mode). The rendering behavior is slightly different with each mode.

Custom components are rendered in no-quirks mode by default. You can switch between modes on a per-custom component basis by toggling "Enable quirks rendering mode" in the IDE.

---

## Getting started with charts

:::info

This guide covers a set of new chart components, which are distinct from the legacy [Chart](./legacy/charts.mdx) component. The new chart components are available on Retool Cloud and on Self-hosted Retool version 3.111 and later.

:::

Chart components allow you to visualize data as graphs and charts. There are various types of charts and graphs available, and each type offers customization options. 

Retool also provides a Plotly JSON Chart that you can customize to fit your needs. All charts are built using [Plotly.js](https://plotly.com/javascript/) version 2.34.

## Chart types

Retool provides the following chart types:

- [Bar Chart](../../reference/components/charts/bar-chart.mdx)
- [Bubble Chart](../../reference/components/charts/bubble-chart.mdx)
- [Funnel Chart](../../reference/components/charts/funnel-chart.mdx)
- [Heat Map](../../reference/components/charts/heat-map.mdx)
- [Line Chart](../../reference/components/charts/line-chart.mdx)
- [Mixed Chart](../../reference/components/charts/mixed-chart.mdx)
- [Pie Chart](../../reference/components/charts/pie-chart.mdx)
- [Plotly JSON Chart](../../reference/components/charts/plotly-json-chart.mdx)
- [Sankey Chart](../../reference/components/charts/sankey-chart.mdx)
- [Scatter Chart](../../reference/components/charts/scatter-chart.mdx)
- [Sparkline](../../reference/components/charts/sparkline.mdx)
- [Stacked Bar Chart](../../reference/components/charts/stacked-bar-chart.mdx)
- [Sunburst Chart](../../reference/components/charts/sunburst-chart.mdx)
- [Treemap](../../reference/components/charts/treemap.mdx)
- [Waterfall Chart](../../reference/components/charts/waterfall-chart.mdx)

## Specify content options 

In the **Content** section of the Inspector, add your data source. Series-based charts enable you to add one or more series, each with a different data source. Series-based charts include Bar Chart, Bubble Chart, Funnel Chart, Line Chart, Scatter Chart, Sparkline, and Waterfall Chart.

### Choose your data

You can use [queries](../../../queries/index.mdx), [transformers](../../../queries/guides/transformers.mdx), or [JavaScript](../../../queries/concepts/javascript.mdx) to build charts.

You can choose to manually add your data, or select a query or transformer in the **Data source** field, which automatically populates the chart with data.

Once you select the data source, you can choose what fields to display. Some charts have **X data** and **Y data**, and others have **Labels** and **Values**.

### Group and aggregate data

Retool supports two transformation types:

- **Group by**: Group the data by a specific dimension.
- **Aggregation**: Summarize the y-values for a specific x-value.

:::note

These transformations are available for series-based charts only.

:::

#### Group by

You can aggregate serial data for a dynamic number of groups. For example, you can create charts that visualize data over time and group that data, such as grouping revenue by product or headcount by team. Use the **Group by** property to choose a field from your data source to group and display this kind of data.

To see an example of this, create a JavaScript [transformer](../../../queries/guides/transformers.mdx) using the code below, which represents a list of employee expenses. Make sure to save and run it before continuing.

```javascript
const data = [
  { "Name": "David Wilson", "Category": "Travel", "Amount": 450.00, "Date": "2024-09-02" },
  { "Name": "Sarah Johnson", "Category": "Technology", "Amount": 475.00, "Date": "2024-09-05" },
  { "Name": "James Moore", "Category": "Meals", "Amount": 56.00, "Date": "2024-09-06" },
  { "Name": "Emily Davis", "Category": "Travel", "Amount": 300.00, "Date": "2024-09-11" },
  { "Name": "James Moore", "Category": "Travel", "Amount": 275.00, "Date": "2024-09-22" },
  { "Name": "Daniel Lee", "Category": "Meals", "Amount": 60.00, "Date": "2024-09-22" },
  { "Name": "Laura Taylor", "Category": "Technology", "Amount": 250.00, "Date": "2024-09-24" },
  { "Name": "James Moore", "Category": "Meals", "Amount": 45.00, "Date": "2024-09-30" },
  { "Name": "Laura Taylor", "Category": "Meals", "Amount": 85.00, "Date": "2024-09-31" }
];

return data;
```

Add a Line Chart component to the canvas. Select the primary series, and set the **Data source** to the transformer you created. Set the **X data** to `Date` and the **Y data** to `Amount`. Set **Group by** to `Category`. The chart now shows three lines, one for each of the categories. If you add more data points to the transformer, the chart updates automatically.

#### Aggregation

In addition, you can use the following methods to aggregate data when you have multiple Y values for a single X data point.

| Method             | Description                                            |
| ------------------ | ------------------------------------------------------ |
| Sum                | Returns the summation of all numeric values.           |
| Average            | Returns the average of all numeric values.             |
| Count              | Returns the quantity of items for each group.          |
| Count distinct     | Returns the quantity of distinct items for each group. |
| Min                | Returns the minimum numeric value for each group.      |
| Max                | Returns the maximum numeric value for each group.      |
| Median             | Returns the median of all numeric values.              |
| Mode               | Returns the mode of all numeric values.                |
| Standard deviation | Returns the standard deviation of all numeric values.  |
| First value        | Returns the first numeric value for each group.        |
| Last value         | Returns the last numeric value for each group.         |

:::note

You can edit the `data` value for a Plotly JSON Chart directly to use the `filter` and `sort` transformation methods.

:::

### Include add-ons

The **Add-ons** setting enables you to add additional information to your chart component.

Common add-ons include:

- **Title**: Add a title that appears at the top of the chart.
- **Toolbar**: Add a configurable list of controls that allow a user to interact with the chart by selecting components, zooming in or out, and other functions.
- **Legend**: Add a legend to the chart and configure where the legend appears.
- **Data labels**: For Pie Chart, Treemap, and Sunburst Chart, add labels to display on categories and subcategories.
- **Tooltip**: For Pie Chart, Treemap, and Sunburst Chart, add labels that appear when you hover over categories and subcategories.

:::note

Each component has a slightly different set of add-ons.

:::

### Axis tick formats

import FxSvg from '/img/icons/fx.svg';

Use the **Axis controls** setting to customize tick labels. Click on the axis you want to edit, and Retool provides various appearance settings to customize the ticks. For full control over the tick labels, click the  button and input a valid d3-format specifier. 

Refer to [d3-time-format](https://github.com/d3/d3-time-format#locale_format) for a list of date-time formatters and [d3-format](https://github.com/d3/d3-format#api-reference) for a list of numerical formatters. Here are a few examples of commonly used formats.

| Specifier | Example                    | Description                                                              |
| --------- | -------------------------- | ------------------------------------------------------------------------ |
| `%I:%M%p` | 12:00 PM                   | Uses `%I` for 12-hour clock hour, `%M` for minute and `%p` for AM or PM. |
| `Q%q %Y`  | Q2 2020                    | Uses `%q` for quarter of the year and `%Y` for the year with century.    |
| `%`       | _Input_: 0.05 _Output:_ 5% | `%` multiplies by 100, and then decimal notation with a percent sign.    |

### Add multiple y-axes

Series-based charts support multiple y-axes. This is useful when working with both absolute numbers and percentages, you might want to show additional y-axes on your chart. For example, you could chart the total number of visits to a website, and the percentage of those visits split between new and existing users. The left y-axis would map to a count, and the right one would map to a percentage.

The Mixed Chart component automatically includes two y-axes, with some sample data to demonstrate the abilities of the chart.

Alternatively, you can add an additional y-axis to other kinds of series-based charts using the **Axis controls** section of the inspector. Click **+** to add a right y-axis to a chart, and select the new axis to edit axis-specific settings.

## Configure user interaction

When you select points on a chart, Retool exposes the underlying data in the `.selectedPoints` array property on the chart. This means you can filter, transform, or update your app by referencing the `chartName.selectedPoints` array property in any component, query, or JavaScript function.

For example, to use the `x` values of selected points on a Scatter Chart to filter a query, you can write `{{ scatterChart1.selectedPoints.map(d => d.x) }}`. Here is an example in a [BigQuery](../../../data-sources/guides/integrations/database/bigquery.mdx) SQL query:

```sql title="BigQuery"
SELECT id, event, timestamp, value, trigger
FROM big_query.event_table
WHERE timestamp IN UNNEST( {{chart.selectedPoints.map(d => d.x) }})
```

Retool also exposes event handlers on charts for the following events:

- Select
- Clear
- Legend click
- Legend double click
- Hover
- Unhover

import Appearance from "/docs/_shared/_appearance.mdx";

## Advanced use cases

A few more advanced use cases require additional configuration or knowledge of Plotly.

### Plotly JSON Chart

If you have an advanced use case that isn't covered by one of the chart presets, you can use the **Plotly JSON Chart** component to build charts with raw Plotly JSON structured data. Retool exposes chart information (chart type, aggregation methods, axes names, etc.) as JSON passed to the `data` and `layout` properties. 

:::note

Retool provides a repository of [data visualization examples](https://github.com/tryretool/data_visualizations) on GitHub that you can reference and duplicate.

:::

The **Data** setting in Retool populates the Plotly `data` property. Use this to define a list of traces (datasets) to chart. The schema of each trace is dependent on the type.

In the **Appearance** section, the **Layout** setting in Retool populates the Plotly `layout` property. Use this property to control positioning and to set the title, axes, colors, and legend.

Visit the [Plotly API reference](https://plotly.com/javascript/reference/index/) to read more about the data structure that the Plotly library operates on.

The following examples show the **Data** and **Layout** values for a bar chart.

Common **Data** options:

```json
[
  {
    "name": "id",
    "x": ["2020-01-01","2020-01-02","2020-01-03","2020-01-04","2020-01-03"],
    "y": [4,8,3,12,7],
    "type": "bar",

    "marker": { // Used to customize how data points are displayed on chart.
      "color": "#3c92dc",
      "size": 3,
     "symbol": "circle"
    },
    "line": {  // Used to customize how data lines are drawn on chart.
      "color": "#3c92dc",
      "width": 3
    },
    "transforms": [
      {
        "type": "aggregate",
        "groups": ["2020-01-01","2020-01-02","2020-01-03","2020-01-04","2020-01-03"],
        "aggregations": [
          {
            "target": "y",
            "func": "sum",
            "enabled": true
          }
        ]
      }
    ]
  }
]

```

Common **Layout** options:

```json
{
  "title": "My Chart Title",
  "font": {
    "family": "Inter" // Default font for all chart labels.
  },
  "xaxis": {
    "title": "Date", // Text label for x-axis.
    "type": "-", // X-axis type.
    "tickformat": "YYYY-MM", // d3-format specifier. If empty or "", Plotly will attempt to guess format.
    "automargin": true,
    "fixedrange": true
  },
  "yaxis": {
    "title": "Count",
    "tickformat": "", // d3-format specifier. If empty or "" Plotly will attempt to guess format.
    "automargin": true,
    "fixedrange": true
  },
  "showlegend": true,
  "legend": {
    "xanchor": "left",
    "x": 1.05,
    "y": 0.5
  },
  "hovermode": "x unified",
  "margin": {
    "l": 75,
    "r": 25,
    "t": 80,
    "b": 75
  }
}
```

Paste these values into the Plotly JSON Chart component to test it out.

---

## Data



---

## Getting started with the Key Value component

Key Value components display key-value data and are often used to display data sourced from other components. For example, it's common to configure a Key Value component to display detailed information from a selected row in a table. Try out the app below for an example.

## Display key-value pairs

Retool seeds Key Value components with demo data when you add them to the canvas. You can also set the component's **Data** to any JavaScript object. This includes query results, table data, or JSON data.

## Edit properties and appearance

After you pass data to the Key Value component, Retool infers properties and their formats. These properties are initially listed in the **Dynamic** section, and you can save properties to customize and reorder them. You can also hide properties, configure their format, change their labels, and more.

There are also several appearance settings to choose from. You can change the label position, group layout, height, etc.

---

## Visualize data with the Chart component

:::info

This is a legacy component. Retool recommends using the [new chart components](../charts.mdx).

:::

The [Chart component](https://retool.com/components/chart) allows you to visualize data as graphs and charts. It's built using [Plotly.js](https://plotly.com/javascript/), so you can also customize charts to fit your needs.

## Demo

Check out the demo to see the Chart component in action.

## Choose your data

You can use [queries](//queries) and [transformers](../../../../queries/guides/transformers.mdx), or [JavaScript](../../../../queries/concepts/javascript.mdx) to build charts. You can reference an array or an object in the **Data source** field for a chart and Retool automatically detects the data type and transforms it for graphing. If your data source is an array and you enable **Use JavaScript**, Retool's built-in `formatArrayAsObject` function wraps the data source reference.

After you select a data source, Retool parses the data and populates the chart. By default, the first non-numeric column populates the **X-axis** but you can change this and other properties like **Chart type**, **Group by**, etc.

## Supported data structures

The Chart component requires data in a tabular format. This can either be an array of objects, where every object field is a column, or as an object where each key represents a column and the value is an array of values for that column.

```json title="Array of objects: typical data response from an API"
[
  { "date": "2022-03-01", "animal": "dog", "count": 4 },
  { "date": "2022-03-01", "animal": "cat", "count": 6 },
  { "date": "2022-04-01", "animal": "frog", "count": 10 },
  { "date": "2022-04-01", "animal": "cat", "count": 3 },
  { "date": "2022-04-01", "animal": "dog", "count": 2 }
]
```

```json title="Object with array fields: typical data  format returned by a SQL query"
{
  "date": [
    "2022-03-01",
    "2022-03-01",
    "2022-04-01",
    "2022-04-01",
    "2022-04-01"
  ],
  "animal": ["dog", "cat", "frog", "cat", "dog"],
  "count": [4, 6, 10, 3, 2]
}
```

## Group data

One common use case is to chart time series data for a dynamic number of groups. For example, grouping revenue by product or headcount by team. Use the **Group by** property to choose a field from your data source to group and display this kind of data.

To see an example of this, create a transformers using the code below. Make sure to save and run it before continuing.

```javascript
const data = [
  { date: "2022-03-01", animal: "dog", count: 1 },
  { date: "2022-03-01", animal: "cat", count: 6 },
  { date: "2022-04-01", animal: "frog", count: 10 },
  { date: "2022-04-01", animal: "cat", count: 3 },
  { date: "2022-04-01", animal: "dog", count: 2 },
  { "date": "2022-03-01", "animal": "bird", "count": 4 },
  { "date": "2022-04-01", "animal": "bird", "count": 2 },
  { "date": "2022-03-01", "animal": "frog", "count": 6 },
  { date: "2022-05-01", animal: "dog", count: 7 },
  { date: "2022-05-01", animal: "cat", count: 4 },
  { date: "2022-05-01", animal: "frog", count: 1 },
  { "date": "2022-05-01", "animal": "bird", "count": 8 },
];

return data;
```

Add a Chart component to the Canvas and set its **Data source** to the transformer you created. Change the chart type to **Line chart** and set **Group by** to `animal`. The chart now shows the number of animals over time. If you add more data points to the transformer, the chart updates automatically.

## Transformation types

Retool supports two transformation types:

- **Group by**: Group the **data** by a specific column.
- **Aggregation**: Summarize the values for a group.

  You can use the following methods to aggregate data.

| Method | Description                                           |
| ------ | ----------------------------------------------------- |
| count  | Returns the quantity of items for each group.         |
| sum    | Returns the summation of all numeric values.          |
| avg    | Returns the average of all numeric values.            |
| median | Returns the median of all numeric values.             |
| mode   | Returns the mode of all numeric values.               |
| rms    | Returns the rms of all numeric values.                |
| stddev | Returns the standard deviation of all numeric values. |
| min    | Returns the minimum numeric value for each group.     |
| max    | Returns the maximum numeric value for each group.     |
| first  | Returns the first numeric value for each group.       |
| last   | Returns the last numeric value for each group.        |

:::note

You can also edit the Plotly JSON for a Chart component directly to use the `filter` and `sort` transformation methods.

:::

## Customize the layout

Edit the chart's layout using the **Interaction** section in the right panel. Select **UI Form** to edit these settings directly or **Plotly JSON** to configure the layout using [Plotly layout JSON](https://plotly.com/javascript/reference/layout/) values.

### Axis tick formats

Use the **X-axis tick format** and **Y-axis tick format** fields to customize tick labels using a valid d3-format specifier. For a full list of numerical values, use d3-format specifier. See [d3-time-format](https://github.com/d3/d3-time-format#locale_format) for a list of date-time formatters and [d3-format](https://github.com/d3/d3-format#api-reference) for a list of numerical formatters. Here are a few examples of commonly used formats.

| Specifier | Example                    | Description                                                              |
| --------- | -------------------------- | ------------------------------------------------------------------------ |
| `%I:%M%p` | 12:00 PM                   | Uses `%I` for 12-hour clock hour, `%M` for minute and `%p` for AM or PM. |
| `Q%q %Y`  | Q2 2020                    | Uses `%q` for quarter of the year and `%Y` for the year with century.    |
| `%`       | _Input_: 0.05 _Output:_ 5% | `%` multiplies by 100, and then decimal notation with a percent sign.    |

## Add interactivity

When you select points on a chart, Retool exposes the underlying data in the `.selectedPoints` array property on the chart. This means you can filter, transform, or update your app by referencing the `chart.selectedPoints` array property in any component, query, or JavaScript function.

For example, to use the `x` values of selected points to filter a query, you can write `{{ chart.selectedPoints.map(d => d.x) }}`. Here is an example in a [BigQuery](../../../../data-sources/guides/integrations/database/bigquery.mdx) SQL query:

```sql title="BigQuery"
SELECT id, event, timestamp, value, trigger
FROM big_query.event_table
WHERE timestamp IN UNNEST( {{chart.selectedPoints.map(d => d.x) }})
```

## Advanced use cases

Retool exposes chart information (chart type, aggregation methods, axes names, etc.) as JSON passed to the `data` and `layout` attributes. If you have an advanced use case, you can enable **Plotly JSON** to edit JSON directly.

The **Data** field in Retool populates the Plotly `data` attribute. Use this attribute to define a list of traces (datasets) to chart. The schema of each trace is dependent on the type.

The **Layout** field in Retool populates the Plotly `layout` attribute. Use this attribute to control positioning and to set the title, axes, colors, and legend.

Visit the [Plotly docs](https://plotly.com/javascript/reference/index/) to read more about the data structure that the Plotly library operates on.

Common `data` options:

```json
[
  {
    "name": "id",
    "x": ["2020-01-01","2020-01-02","2020-01-03","2020-01-04","2020-01-03"],
    "y": [4,8,3,12,7],
    "type": "bar",

    "marker": { // Used to customize how data points are displayed on chart.
      "color": "#3c92dc",
      "size": 3,
     "symbol": "circle"
    },
    "line": {  // Used to customize how data lines are drawn on chart.
      "color": "#3c92dc",
      "width": 3
    },
    "transforms": [
      {
        "type": "aggregate",
        "groups": ["2020-01-01","2020-01-02","2020-01-03","2020-01-04","2020-01-03"],
        "aggregations": [
          {
            "target": "y",
            "func": "sum",
            "enabled": true
          }
        ]
      }
    ]
  }, ...}
]

```

Common `layout` options:

```json
{
  "title": "My Chart Title",
  "font": {
    "family": "Inter" // Default font for all chart labels.
  },
  "xaxis": {
    "title": "Date", // Text label for x-axis.
    "type": "-", // X-axis type.
    "tickformat": "YYYY-MM", // d3-format specifier. If empty or "", Plotly will attempt to guess format.
    "automargin": true,
    "fixedrange": true
  },
  "yaxis": {
    "title": "Count",
    "tickformat": "", // d3-format specifier. If empty or "" Plotly will attempt to guess format.
    "automargin": true,
    "fixedrange": true
  },
  "showlegend": true,
  "legend": {
    "xanchor": "left",
    "x": 1.05,
    "y": 0.5
  },
  "hovermode": "x unified",
  "margin": {
    "l": 75,
    "r": 25,
    "t": 80,
    "b": 75
  }
}
```

### Add multiple y-axes

If you're working on a chart that shows absolute numbers and percentages, you might want to show additional y-axes on your chart. For example, you could chart the total number of visits to a website, and the percentage of those visits split between new and existing users. The left y-axis would map to a count, and the right one would map to a percentage. You can do this by editing the Plotly JSON directly with the following steps.

#### 1. Add another y-axis to the Plotly Layout JSON

Select the chart and click **Plotly JSON** in the right panel. In the existing JSON, there's an entry for an existing y-axis with a `"yaxis"` key. Add a second entry named `"yaxis2"`, and configure it to show up on the right side of the graph using `side: right` and `overlaying: y`.

```json title="y axis JSON"
  "yaxis2": {
    "title": {
      "text": "an axis title",
      "standoff": 12,
      "font": {
        "size": 12
      }
    },
    "overlaying": "y",
    "side": "right",
    "type": "linear",
    "automargin": true,
    "fixedrange": true,
    "zerolinecolor": "#DEDEDE"
  }
```

You can also add some optional fields to format the axis as a percentage and restrict the range to `[0,1]`.

```json
"tickformat": "%",
"range": [0,1],
```

#### 2. Assign datasets to the axes

For each dataset that you want to assign to the additional y-axis, add this property:

```json
"yaxis": "y2"
```

## Additional resources

Check out these external resources for more information on building charts and using Plotly.

- [Data Visualization examples](https://github.com/tryretool/data_visualizations) on GitHub
- [Plotly.js](https://plotly.com/javascript/) documentation

### Building an operations dashboard

### Customer case study with JetFuel

---

## Legacy



---

## Configure columns in the Table component

:::tip 

Click  in the **Columns** settings to display a pop-out editor for columns. 

:::

Each table column has a designated format for its values which control how values are presented or edited. Retool attempts to infer this from the data source and sets the format automatically. 

To change a column's format:

1. Click on the column in the **Columns** section of the Inspector.
2. Change **Format** to the preferred format to use. 

export function ArcadeFormat() {
  return (
    
      
    
  )
}

The Table component supports the following column formats.

| Format               | Description                                                                  |
| -------------------- | ---------------------------------------------------------------------------- |
| **Avatar**           | An avatar with image and text.                                               |
| **BigInt**           | An integer value that represents a number too large for the **Number** type. |
| **Boolean**          | A checkbox that represents a boolean value.                                  |
| **Button**           | A clickable button.                                                          |
| **Currency**         | An amount in a specified currency.                                           |
| **Date**             | A date.                                                                      |
| **Datetime**         | A date and time.                                                             |
| **Email**            | An email address.                                                            |
| **HTML**             | Rendered HTML content.                                                       |
| **Icon**             | An icon.                                                                     |
| **Image**            | An image.                                                                    |
| **JSON**             | JSON data.                                                                   |
| **Link**             | A URL link.                                                                  |
| **Markdown**         | Rendered Markdown content.                                                   |
| **Multiline string** | A string of plain text that wraps to multiple lines.                         |
| **Number**           | A number.                                                                    |
| **Percent**          | A percentage amount that represents a number in the range 0-1.               |
| **Phone number**     | A phone number.                                                              |
| **Progress**         | A progress bar that represents a number in the range 0-100.                  |
| **Rating**           | A rating that represents a number value.                                     |
| **String**           | A single-line string of plain text.                                          |
| **Tag**              | A tag that represents a value.                                               |
| **Tags**             | One or more tags that represent an array of values.                          |
| **Time**             | A time.                                                                      |

## Regenerate columns

You can regenerate columns after your data source changes by selecting **Regenerate Columns** in the **Inspector**. This functionality parses a random sample of entries in your data and adds any missing columns to your table, removes the primary key, and resets the width of your columns. 

Regenerating columns does not remove any custom columns nor does it override other modifications to existing columns. If your entries have varied properties, the random sample of entries might not detect every column in your data. To avoid this issue, you can manually add your columns or transform your data into a consistent shape before passing it to the table.

export function ArcadeRegenerate() {
  return (
    
      
    
  )
}

## Configure editable columns

You can edit column cell values and save the changes back to the data source. To make a column editable, click  next to the column, then select **Make editable**. You can also select a column and click the **Editable** checkbox.

export function ArcadeEditable() {
  return (
    
      
    
  )
}

### Edit existing cell values

Click a cell to edit its value. All edited cell value changes, along with their respective primary keys, are temporarily stored in the table's `changesetArray` property.

```json
...
  "changesetArray": [
    {
      "verified": true,
      "id": 58
    }
  ],
...
```

:::tip 

The changeset only includes values for edited columns by default. If you need to include all column values, click  in the **Interaction** settings and enable **Include full rows in changeset array**.

:::

### Configure input validation

Editable columns with **Format** set to **Number** support inline cell input validation. Use the **Min** and **Max** settings to configure a minimum and maximum input value. The user input is automatically updated to the relevant minimum or maximum value upon edit.

### Write a query to save changes

To save changes, you must first write a query that references `changesetArray` and updates the existing data source. For example, to save changes back to a PostgreSQL table, write a query that uses the [bulk update via a primary key](../../../../queries/guides/sql/writes.mdx#2-select-the-action-type) action.

import Spread from "./_spread.mdx"

## Add custom columns

:::tip 
You can use `{{ currentRow }}` and `{{ currentSourceRow }}` to reference other column values from the same table row or data source row respectively.
:::

You can add custom columns to tables using the  button above the list of columns. Custom columns are often used to calculate data based on other values in your app.

Custom columns have the same properties as regular table columns, such as the format and value. You can optionally specify an existing column to use for data, then reference it with `item`.  For example, to display a future relative date (e.g., "In two days") for a column with date values:

1. Select a column with date values (e.g., `expiration`) to use as the source column. 
2. Set the column format to **String**.
3. Use `item` to reference the mapped value and the preloaded moment library to convert it to a relative date. You can also use the preloaded lodash library to format the string using start case. For example:

```js
{{ _.startCase(moment(item).fromNow()) }}
```

export function ArcadeCustom() {
  return (
    
      
    
  )
}

## Configure dynamic columns

You can dynamically configure columns based upon mapped values from the data source, such as column labels and formats. Using dynamic column settings is particularly useful if the data source's schema changes which would change the columns available or if you need greater flexibility over columns.

For example, a Table component might reference data from a query that returns employee information. The data source includes a balance of their vacation days, which you only want to display to managers. Use dynamic column settings to display that property as a column only if the `current_user` is part of the `managers` user group.

Click  in the **Content** settings and enable **Use dynamic column settings**. 

export function ArcadeDynamic() {
  return (
    
      
    
  )
}

You then configure the following settings. In these settings, you can either set a value explicitly, or dynamically reference mapped values using `item`, which corresponds to the unused keys (columns) in the data source. 

- **Label**: The label of the dynamic column.
- **Format**: The format of the dynamic column. If you will have more than one dynamic column, click **FX** to set this value dynamically, or **Auto** predicts the appropriate format based on data for that column. For example: `{{ item === 'discontinued' ? 'boolean' : 'string' }}` 
- **Hidden**: Whether the column should be hidden. For example: ` {{ !current_user.groups.map(group => group.name).includes('managers') }}` hides the column if the current user is not in the `managers` group.
- **Editable**: Whether the column should be editable.
- **Column Properties**: The properties of the dynamic column. You can configure appearance options for each **Format** that your dynamic column might have. For example, if the column could have a format of either `boolean` or `string`, add **Column Properties** for **Boolean** and **String**.

Expand the following section for a full list of the valid values for the **Format**:

- Auto (`auto`)
- String (`string`)
- Multiline String (`multilineString`)
- Number (`decimal`)
- Percent (`percent`)
- Progress (`progress`)
- Currency(`currency`)
- Phone Number(`phoneNumber`)
- Date (`date`)
- Datetime (`datetime`)
- Time (`time`)
- Boolean (`boolean`)
- Tag (`tag`)
- Tags (`tags`)
- Icon (`icon`)
- Avatar (`avatar`)
- Image (`image`)
- Link (`link`)
- BigInt(`bigint`)
- Button (`button`)
- Markdown (`markdown`)
- HTML (`html`)
- Rating (`rating`)
- JSON (`json`)
- Email (`email`)

## Sort columns

You can sort table rows by one or more columns directly from the table's header or using JavaScript.

Click on a column header to sort rows in ascending or descending order. When sorting is active, the header by which the table sorts displays an **↓** or **↑** arrow to denote sort order.

Shift-click additional columns to include them for sorting.

export function ArcadeSortHeader() {
  return (
    
      
    
  )
}

The [sortArray](../../../reference/components/data/table.mdx#property-filterStack) property contains all sorting options currently applied to the table. You can use the following JavaScript methods to configure sorting:

| Method                                                                     | Description                                       |
| -------------------------------------------------------------------------- | ------------------------------------------------- |
| [clearSort](../../../reference/components/data/table.mdx#method-clearSort) | Clear all sort options applied to the table.      |
| [setSort](../../../reference/components/data/table.mdx#method-setSort)     | Sort rows by the specified columns and direction. |

```js title="Example usage"
// Clear Sort
table1.clearSort();

// Set Sort
table1.setSort([{ columnId: "date", sortDirection "desc" }, { columnId: "lastName", sortDirection "asc"}]);
```

### Default sorting

Tables do not automatically sort rows by default. You can configure default sort options that apply whenever a user opens the app. Click  in the **Interaction** settings and specify the columns and orders with which to sort.

export function ArcadeDefaultSort() {
  return (
    
      
    
  )
}

### Sort modes

You can fine-tune how each column sorts values. This can be useful if columns contain multiple values, or when sorting by ascending or descending values doesn't meet your requirements. There are four sort modes.

| Mode     | Description                                                                           |
| -------- | ------------------------------------------------------------------------------------- |
| Default  | Sorts based on the mapped value. If the mapped value is unset, the raw value is used. |
| Raw      | Sorts based on the raw value, regardless of the mapped value.                         |
| Options  | Sorts based on a list of options you create manually.                                 |
| Disabled | Disables column sort modes.                                                           |

---

## Customize the appearance of the Table component

The Table component includes a range of options to customize the appearance and user experience.

## Demo

The following demo app uses a toolbar with custom buttons. It also includes a summary row to summarize column values.

## Configure the toolbar

The Table component's *toolbar* is enabled by default and contains buttons to perform different actions, such as filtering. It also includes navigation controls for paginated data, if enabled. Select the **Toolbar** add-on to configure toolbar options.

### Toolbar position

You can toggle the **Position** setting to change where the toolbar appears. 

export function ArcadePosition() {
  return (
    
      
    
  )
}

### Customize buttons

The toolbar includes a selection of buttons by default. You can customize the toolbar buttons and configure custom ones that perform actions when clicked.

| Button Type | Description                                                |
| ----------- | ---------------------------------------------------------- |
| Filter      | Filter table data by column values.                        |
| Sort        | Sort table data by the specified columns.                  |
| Group by    | Group rows by the specified column value.                  |
| Add Row     | Add new rows of data that can be saved to the data source. |
| Custom      | Trigger event handlers when clicked.                       |

export function ArcadeCustomButtons() {
  return (
    
      
    
  )
}

## Configure row height

You can use the **Row height** setting to adjust the height of table rows. The Table component can also dynamically adjust the height of each row based on cell values.

| Value   | Height                                                           |
| ------- | ---------------------------------------------------------------- |
| X-Small | `20px`                                                           |
| Small   | `32px`                                                           |
| Medium  | `48px`                                                           |
| Large   | `60px`                                                           |
| Dynamic | Dynamically adjusts the height of each row based on its content. |

export function ArcadeRowHeight() {
  return (
    
      
    
  )
}

## Summarize columns

The **Summary row** add-on summarizes values from the specified columns using different aggregation methods. 

1. Click **+** in the **Add-ons** settings and select **Summary row**.
2. Specify the columns to summarize.
3. Select the default aggregation method to use.

You can use the following methods to summarize column values. The methods available depend on the column format.

| **Method**         | **Description**                                |
| ------------------ | ---------------------------------------------- |
| **Min**            | The smallest value in the column.              |
| **Max**            | The largest value in the column.               |
| **Average**        | The average (mean) of the column's values.     |
| **Sum**            | The total sum of all the values in the column. |
| **Count Distinct** | The number of unique values in the column.     |

export function ArcadeSummary() {
  return (
    
      
    
  )
}

import Appearance from "../../../../_shared/_appearance.mdx";

## Dynamic row and column colors

You can also use conditional logic to customize row and column background colors. 

- Use the **Row color** setting to control the background color of rows.
- Select a column in the Inspector and use the **Background color** setting.

You can use a ternary operator set the color based on certain conditions. The following example sets the background color of active users to `theme.success` (green) and inactive users to `theme.warning` (amber).

```js
{{ currentRow.enabled ? theme.success : theme.warning }}
```

To set background colors on individual columns, select the column and edit the background color. You can reference column values with `item` for conditional logic. 

```js
{{ item ? theme.success : theme.warning }}
```

export function ArcadeBackgroundColors() {
  return (
    
      
    
  )
}

---

## Filter data in the Table component

The Table component has built-in filter and search options. You can configure default filters, combine multiple filters together, and connect an input component to search through table rows.

## Apply filters

import ServerSideFiltering from './_server-side-filter.mdx'

Table filters are comprised of *rules* and *groups*. You can create and edit table filters directly from the table's toolbar, with the Filter component, or using JavaScript.

- Filter rules compare column values for each row to the operator and value you specify.
- Filter groups combine filter rules for each row and returns results based on the **And** or **Or** logical operator.

The following operators are available for use in table filters. The operator you use depends on the type of data used in the specified column. 

| Operator           | Description              | Data Type           |
| ------------------ | ------------------------ | ------------------- |
| ``                | Greater than             | Number, Date        |
| `>=`               | Greater than or equal to | Number, Date        |
| `=`                | Equal to                 | Number, Text        |
| `!=`               | Not equal to             | Number, Text        |
| `Is`               | Is                       | Boolean, Text       |
| `Is Not`           | Is not                   | Boolean, Text       |
| `Includes`         | Includes                 | Text, Array         |
| `Does Not Include` | Does not include         | Text, Array         |
| `Is True`          | Is true                  | Boolean             |
| `Is False`         | Is false                 | Boolean             |
| `Is Empty`         | Is empty                 | Text, Array         |
| `Is Not Empty`     | Is not empty             | Text, Array         |
| `Intersects`       | Intersects               | Array               |
| `Is One Of`        | Is one of                | Text, Number, Array |
| `Is None Of`       | Is none of               | Text, Number, Array |
| `Is Before`        | Is before                | Date                |
| `Is After`         | Is after                 | Date                |

Click  in the table toolbar to set filters. This displays a popup filter editor where you can specify filter rules and groups.

Filter table data from the toolbar.

The [Filter](../../../reference/components/data/filter.mdx) component provides a persistent interface for the filter editor accessible from the toolbar. Once you add a Filter component to the canvas, click **Link to a table** and select the table to filter.

export function ArcadeFilterComponent() {
  return (
    
      
    
  )
}

The [filterStack](../../../reference/components/data/table.mdx#property-filterStack) property contains all filters currently applied to the table. You can use the following [JavaScript](../../../../queries/concepts/javascript.mdx) to configure filters:

| Method                                                                                   | Description                                                                 |
| ---------------------------------------------------------------------------------------- | --------------------------------------------------------------------------- |
| [setFilterStack](../../../reference/components/data/table.mdx#method-setFilterStack)     | Set filters and operators for the table.                                    |
| [clearFilterStack](../../../reference/components/data/table.mdx#method-clearFilterStack) | Clear all filters applied to the table.                                     |
| [resetFilterStack](../../../reference/components/data/table.mdx#method-resetFilterStack) | Reset the filter stack to the default filters.                              |
| [setFilter](../../../reference/components/data/table.mdx#method-setFilter)               | Add a filter to the table or update an existing filter with a specified ID. |
| [clearFilter](../../../reference/components/data/table.mdx#method-clearFilter)           | Remove the filter with the specified ID.                                    |

```js title="Set filter stack"
table1.setFilterStack({
  filters: [
    {
      filters: [
        { columnId: "id", operator: ">", value: 1 },
        { columnId: "id", operator: "", value: 6 },
        { columnId: "id", operator: "

The following examples filter different types of data based on the column value and format. 

| **Column** | **Operator**  | **Value**               | **Description**                                                    |
| ---------- | ------------- | ----------------------- | ------------------------------------------------------------------ |
| **Age**    | **>**         | `30`                    | Filters rows where the **Age** is greater than 30.                 |
| **Name**   | **Includes**  | `John`                  | Filters rows where the **Name** includes the string "John".        |
| **Status** | **Is One Of** | `["Active", "Pending"]` | Filters rows where the **Status** is either "Active" or "Pending". |
| **Date**   | **Is Before** | `2024-01-01`            | Filters rows where the **Date** is before January 1, 2024.         |

## Configure default filters

Use the **Default filters** settings to configure filter rules that are active by default. Each To configure a filter:

1. Click **+** to add a filter.
2. Select the **Column** by which to filter.
3. Select the **Operator** for comparison, such as **Includes** or **Is not empty**.
4. Specify the value with which to compare.

 

Default filter rules are applied to the root level of filters. You cannot configure default filter groups with nested rules.

## Search table data

The **Search** and **Search term** settings enable you to add search functionality to tables without the use of filters. You can reference any value to use as the search term, such as an input component. To add a search field:

1. Add a Text Input component to the canvas.
2. Update the table's **Search term** setting to reference the Text Input component value, such as `{{ textInput1.value }}`. 

export function ArcadeSearch() {
  return (
    
      
    
  )
}

The search term applies to all column values and the table instantly updates as the input value changes. You can configure the **Search** setting to change the type of search to perform, such as **Fuzzy match** or **Exact**.

---

## Getting started with the Table component

Tables are a common way to view and interact with your data. The [Table](../../../reference/components/data/table.mdx) component enables users to sort, filter, paginate, and download rows of information. It also supports row selection and insertion, server-side pagination, and custom columns.

import Demo from "./_demo.mdx";

## Features

Key features of the Table component include:

- [Column formats](./columns.mdx), such as tags and checkboxes.
- [Editable columns](./columns.mdx#edit-existing-cell-values) and [adding new rows](./rows.mdx#add-new-rows).
- [Row grouping](./rows.mdx#group-rows-by-column) by column.
- [Expandable rows](./rows.mdx#expand-rows-with-additional-content) that can contain other components.
- [Filter](./filters.mdx), [sorting](./columns.mdx#sort-columns), and [search](./filters.mdx#search-table-data) options.
- [Server-side pagination](./pagination.mdx).
- Customizable [toolbar](./customization.mdx#configure-the-toolbar) and [row action](./rows.mdx#configure-row-actions) buttons.

## Configure content options

When you add a Table component to an app, it attempts to display data from the most recently created query. If your app doesn't have a query, the component includes demo data instead.

The data source needs to be an array of objects. Table creates columns for each key and its rows map to array items.

### Specify the data source

You can change the data displayed in a table using the **Data source** setting. From the dropdown, you can select a resource or JavaScript query, transformer or variable, or an array.

export function ArcadeDataSource() {
  return (
    
      
    
  )
}

The Table component supports both client-side and server-side [pagination](./pagination.mdx). You can specify the number of rows to display and the table automatically paginates the current data. With server-side pagination, you can write performant queries that retrieve only the required data to display in the table.

### Set the primary key

Retool recommends you select a primary key column to uniquely identify each row of data. If your data already has an ID column, Retool automatically uses it for the primary key. You can also manually set it to any column that is guaranteed to be unique.

:::tip title
If you don't want to show the primary key in your table, click  to open the contextual menu for the column and select **Hide column**.
:::

Set the primary key.

### Configure columns

Retool automatically generates [columns](./columns.mdx) from the specified data source. You can configure columns with a number of options, available by clicking on each column in the Inspector.

When you add tables to the canvas, Retool automatically attempts to configure the options for each column, such as their type. Each column has a _source key_ that maps to the data source. You can optionally specify a source key for [custom columns](./columns.mdx#add-custom-columns), should you want to use it for column values.

export function ArcadeFormat() {
  return (
    
      
    
  )
}

The Table component can also [summarize column values](./customization.mdx#summarize-columns) using different aggregation methods.

### Configure rows

You can add [row actions](./rows.mdx#configure-row-actions) buttons that appear for each row on mouse hover and trigger event handlers when clicked. The Table component also includes a number of additional interface features which you configure in the **Add-ons** section, such as [expandable rows](./rows.mdx#expand-rows-with-additional-content) that can contain components.

export function ArcadeExpandable() {
  return (
    
      
    
  )
}

## Configure user interaction

The **Interaction** section of the Inspector contains settings that control user interaction, such as:

- [Row and cell selection](./rows.mdx#select-rows) that control how users select values.
- [Event handlers](../../interaction-navigation/event-handlers.mdx) that listen for and handle interactions with your components.
- [Default filters](./filters.mdx#) that initially filter data based on specified criteria.
- [Search options](./filters.mdx#search-table-data) that enable users to search within the table.

export function ArcadeRowSelect() {
  return (
    
      
    
  )
}

## Customize appearance

You can [customize](./customization.mdx) the appearance of tables. The Table component supports automatic and fixed height so it can automatically expand based on the row count or remain a fixed height and scroll. It also supports fixed or dynamic [row height](./customization.mdx#configure-row-height) that expands to fit cell content.

export function ArcadeRowHeight() {
  return (
    
      
    
  )
}

All components have a **Hidden** setting, which you can dynamically control with a truthy value that evaluates to `true` or `false`. You can also control the `hidden` property for a component using the `.setHidden()` method from event handlers and JavaScript queries.

You can also create custom style rules using the **Styles** setting. Each component has different styles that you can configure, but common ones include colors, fonts, and text styles. Use [app-level or organization-level themes](../../presentation-styling/themes.mdx) to set these styles across all components.

## Next steps

Learn more about using the Table component.

---

## Configure server-side pagination for the Table component

import ServerSidePagination from "../../../../_shared/_server-side-pagination.mdx";

The Table component supports [Limit-Offset](#configure-limit-offset-pagination), [Cursor](#configure-cursor-based-pagination), and [GraphQL Relay](#configure-graphql-relay-cursor-pagination) server-side pagination.

import Demo from "./_demo.mdx";

## Enable server-side pagination

import ServerSideFiltering from './_server-side-filter.mdx'

In the **Add-on** settings, click **+** and select **Pagination**. The Table component uses client-side pagination by default. Click **Enable server-side pagination** to display the relevant settings.

Whichever pagination method you use, you must specify the **Page size**—the number of rows you want each page to use—for the table. Once enabled, the table's `pagination` property contains information for you to use in paginated queries.

:::tip

The Table component uses zero-based numbering for pagination values (e.g., `pageNumber` and `offset`).

:::

## Configure Limit Offset pagination

**Limit offset based** pagination uses a *limit* to define the number of records to return and an *offset* to specify the starting point. 

| Parameter | Value                 | Description                                                                                                                 |
| --------- | --------------------- | --------------------------------------------------------------------------------------------------------------------------- |
| Limit     | `pagination.pageSize` | The page size of the table.                                                                                                 |
| Offset    | `pagination.offset`   | The offset from which to start. The table automatically calculates this based on the page size and currently selected page. |

You can optionally configure the **Total row count**, if available, so that the table displays numbered pagination controls.

export function ArcadeLimitOffset() {
  return (
    
      
    
  )
}

### Write a query to paginate results

After you enable server-side pagination, write a query that paginates results. Limit Offset-based pagination is commonly used in SQL queries or with APIs that allow basic control over paginated data.

To retrieve table data with server-side pagination, you first configure a query to reference the table's `pagination` properties using the `limit` and `offset` SQL clauses.

```sql title="Server-side pagination example"
select
  id,
  first_name,
  last_name,
  email
from
  customer
where
  first_name ilike {{ '%' + textInput1.value + '%' }}
order by
  id
limit
  {{ table1.pagination.pageSize }} 
offset 
  {{ table1.pagination.offset }}
```

### Update the table's pagination settings

The Table component automatically triggers the query whenever the page is changed. If you wrote a separate query to get a total count of records, you can reference this in the **Total row count** setting. 

For example, you can get the total number of all records for a database table with a separate query that uses `count()`. You can then reference this query and set **Total row count**.

```sql title="Get total row count"
select
  count(*)
from
  customer
```

If set, users can jump to specific pages of data when using the table.

Many APIs include support for limit and offset pagination. For example, the NASA Image and Video Library API supports `perPage` to limit the number of results and `page_size` to use as the offset.

```bash title="Server-side pagination example"
https://images-api.nasa.gov/search?q=artemis&page_size={{ table.pagination.pageSize }}&page={{ table.pagination.currentPage + 1 }}
```

| Parameter   | Value                                    |
| ----------- | ---------------------------------------- |
| `page_size` | `{{ table.pagination.pageSize }}`        |
| `page`      | `{{ table.pagination.currentPage + 1 }}` |

### Configure the table's pagination settings

The Table component automatically triggers the query whenever the page is changed. The NASA Image and Video Library API also returns the total number of results, `collection.metadata.total_hits` to use for the total row count.

## Configure Cursor-based pagination

**Cursor based** pagination uses a unique identifier, such as an ID, that represents a specific position in the data set. This cursor changes with each page change and is referenced by the query to move through the data set. How you configure pagination settings is dependent on the data source.

| Setting       | Description                                                                            |
| ------------- | -------------------------------------------------------------------------------------- |
| Next cursor   | The identifier to use for the next set of results.                                     |
| Has next page | Whether there is another page of results. If `false`, the **Next** button is disabled. |

export function ArcadeCursor() {
  return (
    
      
    
  )
}

### Write a query to paginate results

After you enable server-side pagination, write a query that paginates results. For example, the Stripe API supports cursor-based pagination with the `limit` and `starting_after` parameters. To retrieve a list of customers with server-side pagination, you first configure a query to reference the table's `pagination` properties.

1. Add a resource query for the **Stripe** resource.
2. Select the **GET /v1/customers** operation.
3. Set the `limit` parameter to `{{ table1.pagination.pageSize }}`.
4. Set the `starting_after` parameter to `{{ table1.pagination.afterCursor }}`.

### Update the table's pagination settings

Next, update the table configuration to reference the query's pagination data. Stripe uses an object ID as the cursor so you would reference the last ID in the query's results to use as the cursor. 

1. Select the table and open the **Pagination** settings.
2. Set **Pagination type** to **Cursor-based**.
3. Set **Next cursor** to the ID for the last item of the query results. You can use the [preloaded lodash library](../../../../queries/reference/libraries/preloaded.mdx) and `_.last` to reference the ID for the last item in the array, such as `{{ _.last(query.data.data).id }}`.
4. Stripe also returns the `has_more` property which indicates whether there are more pages of results. Set **Has next page** to `{{ query.data.has_more }}`.

## Configure GraphQL Relay Cursor pagination

Retool supports cursor-based pagination using [Relay's GraphQL server specification](https://relay.dev/docs/guides/graphql-server-specification/). Paginated GraphQL queries accept the `first`, `last`, `after`, and `before` parameters to identify the data to retrieve.

export function ArcadeGraphql() {
  return (
    
      
    
  )
}

### Write a query to paginate results

After you enable server-side pagination, write a query that paginates results. For example, the GitHub GraphQL API supports Relay cursor-based pagination. To retrieve a list of public repositories for the `github` prganization with server-side pagination, you first configure a query to reference the table's `pagination` properties.

```graphql title="Get public repositories"
query GetOrganizationRepositories($first: Int, $after: String, $before: String) {
  organization(login: "github") {
    repositories(first: $first, after: $after, before: $before, privacy: PUBLIC) {
      edges {
        node {
          name
          description
          url
        }
        cursor
      }
      pageInfo {
        startCursor
        endCursor
        hasNextPage
        hasPreviousPage
      }
    }
  }
}
```

GraphQL queries use variables for referenced values.

| Variable | Value                                 | Description                                                                   |
| -------- | ------------------------------------- | ----------------------------------------------------------------------------- |
| first    | `{{ table.pagination.pageSize }}`     | The page size of the table.                                                   |
| after    | `{{ table.pagination.afterCursor }}`  | The cursor from which to start when navigating to the next page.              |
| before   | `{{ table.pagination.beforeCursor }}` | The previous cursor from which to start when navigating to the previous page. |

### Update the table's pagination settings

Next, update the table configuration to reference the query's pagination data. GitHub returns both next and previous cursors with which to paginate.

1. Select the table and open the **Pagination** settings.
2. Set **Pagination type** to **GraphQL Relay cursor based**.
3. Set **Previous cursor** the cursor for the first item in the query results. You can use the [preloaded lodash library](../../../../queries/reference/libraries/preloaded.mdx) and `_.first` to reference the cursor for the last item in the array, such as `{{ _.first(query.data.organization.repositories.edges).cursor }}`.
4. Set **Next cursor** to the cursor for the last item in the query results. You can use `_.last` to reference the cursor for the last item in the array, such as `{{ _.last(query.data.organization.repositories.edges).cursor }}`.
5. GitHub also returns the `hasNextPage` property which indicates whether there are more pages of results. Set **Has next page** to `{{ query.data.organization.repositories.pageInfo.hasNextPage }}`.

Since the query uses a fixed page size and the GitHub GraphQL API returns both next and previous cursors, `last` is not required.

---

## Configure rows in the Table component

The Table component has a number of row-related features and supports adding new rows of data. 

## Configure row actions

A _row action_ is a button that appears when the cursor hovers over a row. You configure row actions with event handlers that perform an action or trigger a query when clicked. 

Row actions are useful for performing an action with a specific row, such as deleting it. To configure an row action:

1. Click  in the **Row actions** section to add a row action. 
2. Specify a label and icon for the row action.
3. Configure the event handler with the action to perform when clicked. 

export function ArcadeRowAction() {
  return (
    
      
    
  )
}

## Select rows

The Table component supports single and multiple row selection, or you can disable selection entirely. Use the **Row selection** settings in the **Interaction** section of the Inspector to specify the row selection option to use. 

export function ArcadeRowSelect() {
  return (
    
      
    
  )
}

The **Default row** option controls whether the table selects a row by default. If enabled, you can specify the default row index (or indexes) to select.

You can enable **Persist row selection** if you want the table to maintain the selected row even if they are no longer present in the data source This is useful if the data is filtered outside of the table. This option requires that the **Primary key** be set for the table. 

## Expand rows with additional content

Expandable rows enables you to assemble a repeatable set of components that appear when a user expands a row. Click  in the **Content** settings and toggle **Enable expandable rows** on.

When enabled, you can add components directly to the first row instance. These appear in all row instances.

Expandable rows can use the `currentRow` and `currentSourceRow` properties to reference column values.

export function ArcadeExpandable() {
  return (
    
      
    
  )
}

## Group rows by column

:::tip

You can provide users with controls to group rows using the **Group by** [toolbar button](./customization.mdx#customize-buttons)

:::

You can group rows by column value to provide an additional method of organizing data. Click  in the **Content** settings and use **Group rows by** to specify columns with which to group. 

When grouping is enabled, the Table component groups unique column values into expandable sections. You can click a group to reveal all of its grouped rows. 

:::info 

You cannot group rows using editable columns. Instead, add a [custom column](./columns.mdx#add-custom-columns) that references the editable column value and use that for grouping.

:::

export function ArcadeGrouped() {
  return (
    
      
    
  )
}

## Add new rows

In addition to [editing column cell values](./columns.mdx#configure-editable-columns), you can enable the **Add Row** add-on to insert new table rows and save them to your data source. Any columns for which you want to provide values must either be editable or editable for new rows only.

export function ArcadeNewRows() {
  return (
    
      
    
  )
}

### Enable the add-on

1. Click **Toolbar** in the **Add-ons** section of the Inspector.
2. Click  to add a new toolbar button. 
3. Select **Add Row**.

### Add a row

Click the  button in the toolbar to display a pop-up row editor for you to add a new row of data. New row data is temporarily stored in the table's `newRows` property.

### Write a query to save changes

To save changes, you must first write a query that references `newRows` and saves them to the existing data source. For example, to save changes back to a PostgreSQL table, write a query that uses the [bulk insert](../../../../queries/guides/sql/writes.mdx#2-select-the-action-type) action.

import Spread from "./_spread.mdx"

---

## Getting started with boolean inputs

import Interaction from "/docs/apps/guides/forms-inputs/_partials/_interaction.mdx";
import Appearance from "/docs/_shared/_appearance.mdx";
import Content from "/docs/apps/guides/forms-inputs/_partials/_content.mdx";

You can use the following components to accept boolean user inputs:

* [Checkbox](../../reference/components/select-inputs/checkbox.mdx)
* [Checkbox Group](../../reference/components/select-inputs/checkbox-group.mdx)
* [Checkbox Tree](../../reference/components/select-inputs/checkbox-tree.mdx) (a preset of Checkbox Group)
* [Switch](../../reference/components/select-inputs/switch.mdx)
* [Switch Group](../../reference/components/select-inputs/switch-group.mdx)

import WebPlayground from '/docs/_partials/_components/_web-playground.mdx';

## Features

Key features of boolean inputs include:

- Manual or mapped option lists in Checkbox Group, Checkbox Tree, and Switch Group.
- Nested option lists in Checkbox Group, Checkbox Tree, and Switch Group.
- Input validation, including marking components as required or creating custom rules.
- Event triggering based on status of the boolean input.
- Style configuration.

## Specify content options

The **Content** section of the Inspector contains settings that control the content of an input field, such as:

- **Default value**: Pass in a single value or an array of values that correspond to the items you want checked or switched "on" by default.
- **Check strictly**: When checked, removes the association between parent and child. For example, checking the parent option does not automatically check the nested child options.
- **Delimiter**: The string delimeter to use on nested items in the `checkedPathStrings` and `leafPathStrings` properties. For example, setting this value to `-` would result in a string formatted as follows: `"Shoes-Sandals-Flip-Flop"`.

All boolean components include an **Add ons** section, which enables you to add a label or tooltip to the component.

### Define options

You can define the options for Checkbox Group, Checkbox Tree, and Switch Group either manually or by mapping data. Refer to the [Define option lists](./option-lists.mdx) guide for more information.

If you're mapping data for Checkbox Group, Checkbox Tree, or Switch Group, your data must be in a flat array format.

### Identify parent

Checkbox Tree uses the **Parent label** setting to identify where each option should sit in the nested option list. This setting must correspond to the value of another key in the dataset, which identifies the parent of the item. Items without a parent label appear at the top level.

For example, to create a Checkbox Tree, you could have a JavaScript query, `query1`, that includes the following code: 

```JavaScript
const jobs = [
  {label: 'Engineering', value: 'eng'},
  {label: 'Software Developer', value: 'dev', department: 'Engineering'},
  {label: 'QA Tester', value: 'qa', department: 'Engineering'},
  {label: 'Product', value: 'prod', },
  {label: 'Product Manager', value: 'pm', department: 'Product'},
];

return jobs;
```

Set the **Data source** to `query1`, and set **Parent label** to `{{ item.department }}`. The Checkbox Tree appears as follows:

- Engineering
  - Software Developer
  - QA Tester
- Product
  - Product Manager

### Configure group layout

Checkbox Group and Switch Group each support different **Group layout** settings.

:::note

When using Checkbox Tree or the component has a nested option list, Retool enforces the **Tree** group layout.

:::

The following screenshots show the different layout options available.

## Create a dark mode switch

A common use for Switch is it create a dark mode toggle. This example also demonstrates how to set the default value of the component and add event handlers. Use the following instructions to add a dark mode toggle to your app.

:::note

Organization-level themes are available on a Business or an Enterprise plan only.

:::

1. Create an [organization-level theme](../presentation-styling/themes.mdx) with a light mode and a dark mode.
2. Navigate to your app's settings, and select the theme you just created.
3. Add a Switch component to the canvas. Update the label to `Dark mode`.
4. Set default value to `{{ theme.mode === "Dark" }}`. This ensures that the switch position corresponds to the current state of the mode.
5. Add a new event handler with the following settings:
   1. **Event:** True
   2. **Action:** Set theme mode
   3. **Mode name:** Dark
   4. **Persist:** Checked
6. Add a new event handler for when the Switch is set to False.
7. Test out your dark mode toggle.

---

## Getting started with Agent Chat

The [Agent Chat](../../../reference/components/special-inputs/agent-chat.mdx) component provides an interface for users to interact with [Retool Agents](../../../../agents/index.mdx). Use the chat interface to ask questions or make requests, and the agent uses tools to respond to the request. The Agent Chat component functions similarly to the **Chats** tab available inside a Retool Agent.

:::note

The Agent Chat functionality cannot be used from public apps, as calling an agent requires a logged-in user.

:::

## Features

Key features of Agent Chat include:

- An automatically-created query that triggers a run of the agent you choose.
- Inputs pulled directly from your agent, no configuration needed.
- Customizeable styles.

## Prerequisites

Before you get started with an Agent Chat component, you must first create an agent. Refer to the [Retool Agents](../../../../agents/index.mdx) documentation for more information.

## Specify content options

The **Content** section of the Inspector contains settings that control the content of Agent Chat, including:

- **Title**: The title of your agent. Note that you must check the **Show header** setting in the **Appearance** section for the title to appear.
- **Query to trigger**: The query triggered when a user sends a message.

Agent Chat configuration.

When you add the Agent Chat component to the canvas, Retool automatically generates a query that accesses a Retool Agent. You can customize this query as necessary.

export function ArcadeEmbed() {
  return (
    
      
    
  )
}

You can also manually create a resource query that calls an agent using the **Retool Agent** resource.

:::note

Consider using [Text](../../../reference/components/presentation/text.mdx) or another component to explain the purpose of your agent and the kinds of requests that it can handle.

:::

import Appearance from "/docs/_shared/_appearance.mdx";

## Query an agent with Agent Chat

When querying an agent with the Agent Chat component, the queries must use JSON mode, and provide inputs with the following structure:

```json
{
  "action": "invoke",
  "messages": [
    {
      "role": "user",
      "content": "hello world"
    }
  ]
}
```
### Agent Inputs
All Agent Chat components are automatically connected to a preconfigured query, which sends the [agentInputs](../../reference/components/agent-chat#property-agentInputs) property to the agent in the structure outlined above. This allows you to use an Agent Chat with an agent query with no configuration. 

Agent Inputs

The agent query must be able to do two things: 
1. Trigger the agent.
2. Poll for the result of the agent execution. 

The Agent Chat component achieves this by modifying the shape of `agentInputs` depending on whether it is triggering a query or waiting on the response. 

Retool dynamically changes the structure of `{{ agentChat1.agentInputs }}` between the following two payloads:

```json
{
  "action": "invoke",
  "messages": [
    {
      "role": "user",
      "content": "hello world"
    }
  ]
}
```

```json
{
  "action": "getLogs",
  "agentRunId": "uuid..."
}
```

### Pass additional parameters from app to agent
To pass additional parameters from your app into the agent, modify the `agentChat.agentInputs` object. 

Append one (or more) `user` messages to the `messages` array with the parameters from the app that you want to pass in. 
```json title="User message example"
{{ {
  ...agentChat1.agentInputs,
  messages: [
    ...(agentChat1.agentInputs.messages || []),
    { role: 'user', content: `Name of select: ${select1.value}` }
  ]
} }}
```

For example, in an app that allows users to select a customer via a [Select](../../reference/components/select) component, add the user message example above to the **Agent Inputs** field in your agent query to pass the customer ID into an agent. 

export function ArcadeEmbed_agentInput() {
  return (
    
      
    
  )
}

To create an object with additional parameters (like those from other in-app components), add them to the `messages` array while preserving the overall shape. For example, you can use the following structure to send more than one input to an agent:

```json
{{ {
  ...agentChat1.agentInputs,
  messages: [
    ...(agentChat1.agentInputs.messages || []),
    { role: 'user', content: hereYouCanReferenceAnyComponentProperty.value }
    { role: 'user', content: youCanAddAsManyOfTheseAsYouLike.value }
    { role: 'user', content: `You can prepend values with text: ${likeThis.value}` }
  ]
} }}
```

---

## Getting started with chat components

import Intro from '../../../../_shared/_chat-components.mdx';

The following tabs outline the differences between the chat types.

:::note

To enable comments and discussion between users of your app, choose the [Comment Thread](../comment-thread.mdx) component instead.

:::

Use the Agent Chat component to enable users to chat with one of your [agents](../../../../agents/index.mdx). When you add Agent Chat to your canvas, Retool generates an `Invoke Agent` query that allows you to select the agent you want to call, with no additional configuration needed. Messages to Agent Chat with questions or requests trigger a run of your selected agent.

Agent Chat configuration.

Use the LLM Chat component to enable users to send messages to an LLM. When you add LLM Chat to your canvas, Retool generates a [Retool AI query](../../../../queries/concepts/actions.mdx#chat-actions). In this query, you can configure the model you want users to chat with and the [Retool Vectors](../../../../data-sources/quickstarts/retool-vectors.mdx) that can add more context to your queries.

---

## Getting started with LLM Chat

The [LLM Chat](../../../reference/components/special-inputs/llm-chat.mdx) component provides an interface for users to interact with AI. You can choose how the AI model behaves and the actions it takes in response to user messages.

import WebPlayground from '/docs/_partials/_components/_web-playground.mdx';

## Features

Key features of LLM Chat include:

- An automatically-generated [Retool AI query](../../../../queries/concepts/actions.mdx#chat-actions).
- Configurable [AI models](../../../../data-sources/concepts/models.mdx).
- [Retool Vectors](../../../../data-sources/quickstarts/retool-vectors.mdx) to add more context to your queries.
- Event handlers.
- Customizeable styles.

The following video also provides an exploration of the LLM Chat features.

## Specify content options

The **Content** section of the Inspector contains settings that control the content of LLM Chat, such as:

- **AI name** and **Sender name**, which define the name of the user and the AI in the chat.
- **Actions**, which enable the user to copy AI responses.
- **Add-ons**, which customize the layout of the content in the AI chat, including **Avatar** and **Header**.

### Configure Retool AI

When you add the LLM Chat component to the canvas, Retool automatically generates a query that accesses [Retool AI](../../../../queries/concepts/actions.mdx#chat-actions). You can customize this query as necessary.

The query uses your default [Retool AI model](../../../../data-sources/concepts/models.mdx). If you haven't set one up, this is a Retool-managed OpenAI configuration. Click **Configure more models** to [set up a different AI model](../../../../data-sources/guides/integrations/ai/index.mdx) to use in your LLM Chat.

### Add context to answers

In the Retool AI query, you can update the **Input**, **Message history**, and **System Prompt** to reference components and queries in the app. Otherwise, the AI does not have access to the contents of the app. For example, set **System Prompt** to `You are a helpful assistant. Use {{ customersTable.data }} to answer questions about customers, and {{ billingTable.data }} to answer questions about billing.`

Optionally toggle the **Use Retool Vectors to provide more context to your query** setting. [Retool Vectors](../../../../data-sources/quickstarts/retool-vectors.mdx) enables you to use a vector database to store unstructured text from documents and web pages for use with Retool AI. If you enable this setting, the LLM Chat component incorporates information from your the selected vector in responses to users.

### Configure data streaming

[Data streaming](../../../../data-sources/concepts/streaming.mdx) is enabled by default on queries that use the **Generate chat response** action type. Streaming enables LLM Chat to incrementally update the user interface as soon as a row or chunk of data arrives, and the `data` property continuously updates.

To turn off data streaming for LLM Chat, open the **Advanced** settings of your Retool AI query and uncheck the **Stream response data and update app model incrementally** setting. 

## Configure user interaction

The **Interaction** section of the Inspector contains settings that control user interaction, such as:

- **Query to trigger**, which identifies which query to trigger when a user sends a message. You can update this setting to trigger any other [Retool AI query](../../../../queries/guides/ai/chat.mdx).
- **Disable send**, which disables the input field and send button.
- **[Event handlers](../../interaction-navigation/event-handlers.mdx)**, which listen for and handle interactions with your components.

As with other components, you can access LLM Chat component properties using [JavaScript](../../../../queries/concepts/javascript.mdx). For example, LLM Chat components have a `messageHistory` property that contains all messages in the chat log. You can reference specific messages using `{{ chat1.messageHistory[0].content }}`.

import Appearance from "/docs/_shared/_appearance.mdx";

---

## Getting started with Comment Thread

The [Comment Thread](../../reference/components/special-inputs/comment-thread.mdx) component enables users to post comments and start discussions directly within your apps. All users who have access to an app that contains Comment Thread can use the component. Each user's comment appears with their name and avatar image.

import WebPlayground from '/docs/_partials/_components/_web-playground.mdx';

## Features

Key features of the Comment Thread component include:

- Dynamic comment threading to associate comments with Table rows or List View items.
- Configurable title, placeholder, and other information.
- Event handlers triggered on submit or click.
- Action buttons to copy or delete messages.
- Granular control over the refresh period.
- Customizeable styles.

## Specify content options

The **Content** section of the Inspector contains settings that control the content of the Comment Thread, such as:

- **Thread ID**: A unique thread ID with which to associate comments. This can be a dynamic value so that comment threads dynamically change based on user interactions. For example, setting the thread ID to `{{ table1.selectedRow.id }}` associates comments to whichever row is currently selected.
- **Title**: A title that appears in the Comment Thread header when **Show title** is toggled on.
- **Placeholder**: A message that appears in the input field before a user types a message.

Use the **Add-ons** section to [configure user avatars](../presentation-styling/avatar.mdx) and the message that appears in the empty state.

export function AddThread() {
  return (
    
      
    
  )
}

:::note

Thread IDs are used across all of your Retool apps. For example, Comment Threads with a Thread ID `thread_123` all display the same thread, no matter which app the Comment Thread component is in.

:::

Retool does not implement comment retention time limits; comments are preserved in their threads indefinitely.

## Configure user interaction

The **Interaction** section of the Inspector contains [event handlers](../interaction-navigation/event-handlers.mdx), which listen for and handle interactions with your components. For the Timeline component, events trigger when users send a message or click a message action.

Use the **Actions** setting to configure the actions available for each message in the thread. All Comment Threads automatically include the   message action, which you cannot delete. The  message action is also automatically included and can be edited in the Inspector.

The **Interaction** section also enables you to configure the refresh interval of the comment thread and disable message sending. For example, if you only want admins to be able to leave comments, you can set **Disable send** to `{{ Object.keys(current_user.groups.find((g) => g.name === "admin")).lenth === 0 }}`.

### Save comments in Retool Database

You can choose to log comments to [Retool Database](../../../data-sources/quickstarts/retool-database.mdx) to preserve them for use in other apps. For example, you can store user feedback or persist team discussions.

:::note

Without completing these steps, comments are not otherwise retrievable or downloadable from Retool.

:::

First, [create a new table in Retool Database](../../../data-sources/guides/retool-database/manage-data.mdx), titled `comments`, with the following columns:

- `id` as a primary key.
- `body` for the content of the message.
- `name` for the name of the sender.
- `user_id` to uniquely identify the user.

In your app, create a new Retool Database query that inserts a record into the `comments` table. Pass in the current user's ID and name, and send the comment's body with `{{ body }}`.

Finally, add an event handler for the Comment Thread that triggers on the `Submit` event. Set the event handler to run the following script, which sends the comment body using `additionalScope`:

```JavaScript
query1.trigger({
  additionalScope: {
    body: commentThread1.value
  }
})
```

:::note

While you can delete or edit comments at the database level, these changes are not reflected in the actual Comment Thread component. The component does not support editing comments or triggering events when a comment is deleted.

:::

import Appearance from "/docs/_shared/_appearance.mdx";

---

## Getting started with date and time components

import Interaction from "/docs/apps/guides/forms-inputs/_partials/_interaction.mdx";
import Appearance from "/docs/_shared/_appearance.mdx";
import Content from "/docs/apps/guides/forms-inputs/_partials/_content.mdx";

You can use the following components to accept date or time inputs:

- [Calendar Input](../../reference/components/date-time-inputs/calendar-input.mdx)
- [Date Range](../../reference/components/date-time-inputs/date-range.mdx)
- [Date Time](../../reference/components/date-time-inputs/date-time.mdx)
- [Date](../../reference/components/date-time-inputs/date.mdx)
- [Day](../../reference/components/date-time-inputs/day.mdx)
- [Month](../../reference/components/date-time-inputs/month.mdx)
- [Time](../../reference/components/date-time-inputs/time.mdx)
- [Year](../../reference/components/date-time-inputs/year.mdx)

import WebPlayground from '/docs/_partials/_components/_web-playground.mdx';

## Features

Key features of date and time inputs include:

- First day configuration.
- Manual or mapped data sources.
- Time zone management.
- Input validation, including minimum and maximum values.
- Style configuration.

### Define date and time format

For the Date, Date Time, Time, and Date Range components, you can define the **Format** setting of the user input component. This setting accepts a string in Unicode Locale Data Markup Language. Refer to the [Unicode symbol reference](https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table) for more information.

:::note

Regardless of the **Format** setting, the **Default value** of Date and Date Time must adhere to the [ISO 8601 format](https://www.iso.org/standard/70907.html). For example, `"2024-01-01T12:00:00.555Z"` would be an acceptable value.

:::

### Manage time zones

import Shared from '/docs/_shared/_time-zones.mdx';

### Define mapped date values

The Day, Month, and Year components each include a **Mode** setting, which enables you to choose between **Manual** and **Mapped** data to define your input choices. When using the **Mapped** option, you can set the **Data source** to a [query](../../../queries/index.mdx), [transformer](../../../queries/guides/transformers.mdx), or [JavaScript](../../../queries/concepts/javascript.mdx).

For example, create a transformer with the following code, which defines the months of the year in Spanish. Save and run your transformer before continuing.

```javascript
const spanishMonths = ["Enero", "Febrero", "Marzo", "Abril", "Mayo", "Junio", "Julio", "Agosto", "Septiembre", "Octubre", "Noviembre", "Diciembre"];

return spanishMonths;
```

Then, drag the Month component onto the canvas. Change the **Mode** to **Mapped**, and set the **Data source** to the transformer you just created. The Month component now enables you to choose between the months in Spanish.

---

## Getting started with file inputs

import Interaction from "/docs/apps/guides/forms-inputs/_partials/_interaction.mdx";
import Appearance from "/docs/_shared/_appearance.mdx";

Retool provides a number of components that enable users to upload files in web apps:

- [File Button](../../reference/components/special-inputs/file-button.mdx)
- [File Dropzone](../../reference/components/special-inputs/file-dropzone.mdx)
- [File Input](../../reference/components/special-inputs/file-input.mdx)

## Features

Key features of file inputs include:

- Configuration of file types permitted.
- Configuration of the number of files permitted.
- Automatic file parsing.
- Input validation, including file size and number of files.
- Style options.

To see it in action, add one of these components to the canvas. This enables users to upload files from the web app.

## Specify content options

The **Content** section of the Inspector contains settings that control the content of an input field, such as:

- File types.
- Selection type.
- Parse files.

### Accepted file types

Use the **File types** setting to specify an array of RFC2046 media types to allow for upload. The following examples are for common use cases.

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

The following list contains RFC2046 media types for commonly used files, such as PDFs and Microsoft Word documents.

```json Document media types types
[
  "text/*",
  "application/*",
  "application/pdf",
  "application/msword",
  "application/vnd.ms-excel",
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
  "application/json",
  "application/rtf",
  "application/xml"
]
```

Use `['image/*']` to allow the upload of any image.

Leave the **File types** setting empty to allow the upload of any file.

Refer to the [RFC2046 reference](https://www.iana.org/assignments/media-types/media-types.xhtml) for the full list of media types.

### Single or multiple selection

Use the **Selection type** setting to specify whether users can upload a single file, multiple files, or a directory of files. If you allow multiple files, you can also specify a minimum or maximum number of files to allow.

### Parse text files

Retool can parse uploaded text files (any file with a `text/plain` [media type](#accepted-file-types)) and make the content available for use in the app. Enable the **Parse files** setting in the Inspector.

When enabled, the component's `parsedValue` property contains an array of strings for parsed text. The index of each item corresponds to the index of the uploaded file in `value`.

:::caution

While Retool does not limit the size of file uploads, we recommend defining a maximum file size using the **Validation rules** setting to prevent the browser from crashing.

:::

### Save uploaded files and images

You can reference `value` in queries to [store files in a data store](../../../queries/guides/files.mdx), such as Retool Storage or [Amazon S3](../../../data-sources/guides/integrations/object-file-store/amazon-s3.mdx).

:::tip Save files directly to Retool Storage

You can enable the **Upload file to Retool Storage** setting for the component to automatically store the file in Retool Storage. Retool Storage has a file size limit of 40 MB. For more information, refer to the [Retool Storage quickstart](../../../data-sources/quickstarts/retool-storage.mdx).

:::

## Reference uploaded file data

Uploaded files are Base64-encoded. The component's [value](../../reference/components/special-inputs/file-input.mdx#property-value) property contains an array of `file` objects that represent each uploaded file.

`value` is always an array of file objects, regardless of whether a user uploads a single file or multiple files. Single-file uploads are accessible using `value[0]`.

You can reference Base64-encoded values anywhere in Retool that accepts a string value, including URLs. For example, you can set the URL of an Image component to `{{ fileInput1.value[0] }}` to display an uploaded image.

---

## Getting started with the Form component

import FormIntro from '/docs/apps/guides/forms-inputs/_partials/_form.mdx';

This guide walks you through building an app and form using the Form component. You can fill in the form to create a record or update existing data by selecting a record from a table and populating the form. The form also increments IDs automatically.

Try out the app to see the form in action (submissions are disabled).

## Features

Key features of Form include:

- Automatically generate a form schema from a database or table.
- Manually add any component to the form.
- Input validation of the form.
- Customizeable styles.

## Specify content options

The **Content** section of the Inspector contains settings that control the content of your form, including **Data source** and **Add-ons**.

### Generate the inputs

You can manually add form inputs or generate them from a resource or table. To generate inputs, add a form to the canvas and click **Generate from database**. This opens a modal where you can select a resource or table, along with the inputs.

:::note

If your app already includes a table, your new Form includes a **Generate from table** option, instead of **Generate from database**.

:::

Retool evaluates each column to set an appropriate label and input type, but you can edit these properties as well. You can uncheck individual columns to exclude them from the form. This is useful if you don't want users to provide certain information, such as IDs or timestamps. You can also change the generated input type or label, and whether the field should be required.

Each input is generated with a value for **Form data key**—shown in the **Interaction** section of the Inspector—that corresponds to the column name from the table. The **Form data key** is the key used to identify data in the `form.data` object.

import Interaction from "/docs/apps/guides/forms-inputs/_partials/_interaction.mdx";

### Set the form title

Update the form's title so it's clear to the user if they are creating a record or updating an existing one. Select the form's title and change the **Value**:

```javascript
#### {{ table1.selectedRow ? 'Edit' : 'Create new' }} product
```

This displays either **Edit product** or **Create new product**, depending on whether a table row is selected or not.

### Validate submissions

Forms can check the validation status of inputs. For more information, refer to the [Input validation guide](../input-validation.mdx#validate-form-submissions).

### Clear the form

To clear values from the form after submissions, enable **Reset after successful submit** in the **Interaction** section of the form's Inspector. This setting resets the values to those in the form's **Data source** field.

import Appearance from "/docs/_shared/_appearance.mdx";

### Create a query to update the dataset

When you generate a Form using the **Generate from database** option, Retool automatically creates a query (`form1SubmitToProducts` in the screenshot) to insert new records into the database when the form is submitted. 

If your form is generated from a table or manually, you must create this query manually and attach it to the form as an [event handler](../../interaction-navigation/event-handlers.mdx).

### Use the form to update existing records

You can also use this form to make changes to an existing record. A common approach is to populate a form with data from a selected table row and then submit changes to update the record.

Use the **Data source** property to automatically populate the form's inputs using the selected table row data. The Form component matches each input's **Form data key** to a corresponding column name from the table to determine where values should go.

For example, this ternary operator sets the form's initial data only if a table row is selected:

```javascript
{{ table1.selectedRow ? table1.selectedRow : null; }}
```

If set, a form's **Data source** overrides any default values for nested components.

#### Change the query action type

The form's [existing query](#create-a-query-to-update-the-dataset) only creates new records. However, you can update the existing query to update records when the form is submitted. Select the existing query, `form1SubmitToProducts`, and change the **Action type** to **Bulk upsert via primary key**.

:::warning

Remember to save changes to your queries by clicking **Save**.

:::

This action requires a **Primary key** column in the Table so the query knows which record to update. This should be a unique identifier to avoid incorrect changes. In this case, set the value to `id`.

When the form is submitted, the query looks for an existing record using the provided ID. If there's a match, that record is updated. If not, the query creates a new record instead.

#### Include the form data

The form data isn't included in the new action type. Set the **Array of records to update** to `{{ [form1.data] }}`. Note that the form data is wrapped in brackets to provide it as an Object.

### Refresh the table after submission

You might want to automatically update other components in your app (like a Table) based on the database changes. You can create an [event handler](../../interaction-navigation/event-handlers.mdx) to refresh the table to show the changes automatically:

1. Add a new event handler for a **Success** event.
2. Select **Trigger query** as the action to perform.
3. Select **query1**. Triggering this query retrieves the dataset, including your additions, and updates the table.

The **Styles** setting updates the style of the Form component as a whole. The **Nested styles** setting applies changes across all components inside the Form.

## Customize the form

The following section includes additional ways that you can consider customizing your form.

### Increment IDs automatically

The form in this example currently allows users to specify an ID. Since this form also creates and updates records, users could accidentally overwrite a record if they provide an existing ID. Instead, you should automatically increment the ID and prevent users from providing one in the form.

:::warning

The following guidance is provided for demonstration purposes. Retool recommends using your database's auto-increment feature to create unique identifiers automatically.

:::

For this guide, use `Math` to find the highest ID number and use it to increment to the next ID automatically:

```javascript
Math.max(...query1.data.id) + 1;
```

First, disable the ID input by setting the value for **Disabled** to `true` in the **Interaction** section of the Inspector. Next, update the form's Initial data to provide a new ID if a row isn't selected:

```javascript
{
  {
    table1.selectedRow
      ? table1.selectedRow
      : { id: (Math.max(...query1.data.id) + 1).toString() };
  }
}
```

### Display image preview

The Form component can contain any other components, not just inputs. You can include an optional image preview using the provided image URL.

#### Add toggle

1. Drag a [Toggle Link](../../../reference/components/buttons/toggle-link.mdx) component and position it below the input fields. This toggle is used to show or hide the image preview.
2. Update the value for **Text** to `{{ self.value ? 'Hide' : 'Show' }} image preview`.
3. Set the value for **Disabled** using the value of the image URL input, such as `{{ !textInput2.value }}`. This disables the toggle if the input doesn't have a value.

Toggle Link has a value of `false` when in a closed state and displays the text **Show image preview**.

#### Add image

1. Drag an [Image](../../../reference/components/presentation/image.mdx) component and position it below the toggle.
2. Set the **Image source** using the value of the input, such as `{{ textInput2.value }}`.
3. Set the value for **Hidden** to `{{ !toggleLink1.value || toggleLink1.disabled }}`. This hides the image preview if Toggle Link is either disabled or returns a value of `false`.

The image preview can now be toggled but is hidden automatically if no image URL is present.

---

## Getting started with the Form and JSON Schema Form components

Retool provides two components that enable you to gather user input from within an app: [Form](./form-component.mdx) and [JSON Schema Form](./json-schema-form.mdx).

:::warning

This section covers only in-app forms. You can also create standalone forms using [Retool Forms](../../../../forms/index.mdx).

:::

The following tabs outline the differences between the form types.

import WebPlayground from '/docs/_partials/_components/_web-playground.mdx';
import FormIntro from '/docs/apps/guides/forms-inputs/_partials/_form.mdx';
import JsonSchemaFormIntro from '/docs/apps/guides/forms-inputs/_partials/_json-schema-form.mdx';

:::note

Retool recommends using the Form component instead of the JSON Schema Form component in most cases.

:::

The Form component includes the following features:

- Drag-and-drop of input components.
- Full control over layout. Supports all components, with control properties in the editor.
- Manually make changes and updates. Use the editor to update inputs and properties.
- Generate forms from an SQL database schema. Automatically adds inputs to the form and creates a query to insert records. 

The JSON Schema Form component includes the following features:

- Inputs defined using JSON.
- Single-column layout, and you cannot manually add additional components. Control properties using JSON.
- Changes and updates are mostly programmatic. Edit JSON to update inputs and properties.
- Generate forms from an SQL database schema. Automatically generates the JSON and UI schema. 

You should consider using JSON Schema Form if:

- **You already use JSON schema-based forms**. You can reuse your existing schema rather than build forms from scratch.
- **You need more flexibility**. You can create programmatic workflows for your forms that would otherwise not be possible or need to be done manually with the Form component (e.g., complex validation needs or granular control of inputs with custom schema).

---

## Getting started with the JSON Schema Form component

import JsonSchemaFormIntro from '/docs/apps/guides/forms-inputs/_partials/_json-schema-form.mdx';

:::info

Retool recommends using the [Form](./form-component.mdx) component as it's more versatile for most use cases. Use the JSON Schema Form component only if your use case requires it. Refer to the [comparison of form components](./index.mdx) for more details.

:::

Try out the demo below to see the form in action (submissions are disabled).

The following guide outlines how to create a JSON Schema Form that enables a user to either edit or create a new entry in a database of sales deals.

## Features

Key features of JSON Schema Form include:

- Automatic form generation from a database.
- The ability to make programmatic updates to the form schema.
- Configurable default form data.
- Input validation and event handlers.
- Customizeable title, description, and submission button text.

:::note
JSON Schema Form does not support Markdown formatting for labels and captions.
:::

## Specify content options

The **Content** section of the Inspector contains settings that control the content of your form:

- **JSON Schema**: The JSON schema for the form, which uses [react-jsonschema-form](https://github.com/rjsf-team/react-jsonschema-form).
- **UI Schema**: The [UI schema](https://rjsf-team.github.io/react-jsonschema-form/docs/api-reference/uiSchema/) for the form, which provides information on how the form should be rendered.
- **Default Form Data**: The default form data, which is displayed inside the input fields.

### Generate the inputs

You can create a JSON schema from scratch or by using the **Generate schema from a database** option. Use this option to select a connected PostgreSQL, MySQL, or MS SQL database and corresponding table, and Retool generates a **JSON Schema** and **UI Schema** for your JSON Schema Form. You can then manually edit the schemas.

This example shows how to connect the JSON Schema Form to a `deals` table in the `onboarding_db`, a PostgreSQL database.

### Define default data

Use the **Default Form Data** setting to display a certain set of default form data. You can set this manually or define it programmatically. For example, you could set the default values to be the values of the currently selected row. The following code snippet shows an example of how you use data from a row if one is selected or provide default values if one is not:

```json
{
  "email": {{ table1.selectedRow ? table1.selectedRow.email : "email@example.com" }},
  "amount": {{ table1.selectedRow ? table1.selectedRow.amount : 1000 }},
  "stage": {{ table1.selectedRow ? table1.selectedRow.stage : "Lead, Opportunity, or Customer" }},
  "deal_name": {{ table1.selectedRow ? table1.selectedRow.deal_name : "Company Name" }}
}
```

### Set the form title

Update the form's title so it's clear to the user if they are creating a record or updating an existing one. In the **JSON Schema** setting, update the form's title to `"title": "{{ table1.selectedRow ? 'Edit' : 'Create new' }} deal"`.

This displays either **Edit deal** or **Create new deal**, depending on whether a table row is selected or not.

## Configure user interaction

You can configure the user's interaction with the JSON Schema Form through input validation, event handlers, and other mechanisms in the **Interaction** section of the Inspector.

### Input validation

You can apply [validation rules](https://rjsf-team.github.io/react-jsonschema-form/docs/usage/validation/) in the JSON schema to limit what values your form can accept and which fields are required. For more information, refer to the [Input validation](../input-validation.mdx#validate-form-submissions) guide.

### Add an entry to the database

When the user clicks **Submit**, you need to add their responses to the database. Create a new query that adds the deal information to the database.

In this example, you can create a SQL query that accesses the `deals` table in the `onboarding_db` resource. Set **Action type** to **Update a record, or create a new record if it doesn't exist**. Filter by the `deal_name`. 

Add the key-value pairs that you want to include in the new or updated entry. For example, set `amount` to `{{ jsonSchemaForm1.data.amount }}` to use the submission details.

Next, configure the JSON Schema Form's event handler to run this query when the **Submit** button is pressed.

### Refresh the table after submission

You might want to automatically update other components in your app (like a Table) based on the database changes. Create an [event handler](../../interaction-navigation/event-handlers.mdx) to refresh the table and show the changes automatically:

1. Return to the query you created. Add a new event handler for a **Success** event.
2. Select **Trigger query** as the action to perform.
3. Select **getDeals**. Triggering this query retrieves the dataset, including your changes, and updates the table.

## Customize appearance

Customize the appearance of your form using the **UI schema** setting. Explore the [uiSchema object documentation](https://rjsf-team.github.io/react-jsonschema-form/docs/api-reference/uiSchema/) for more information about the customizations available.

You can also customize the presentation of your component in the **Spacing** and **Appearance** sections of the Inspector, although these settings are limited.

---

## Forms and inputs



---

## Validate inputs and forms

Many input components support validation rules. These rules enforce certain requirements on user inputs, such as minimum or maximum length. Configure validation settings in the **Interaction** section of the Inspector.

The validation rules available depend on the type of component you're using. The following lists include common rules:

Validation rules common across [number input](./number-inputs.mdx) components:

| Rule       | Description                                                                                 |
| ---------- | ------------------------------------------------------------------------------------------- |
| Allow null | Whether to allow a null value. If true, the input's cleared state is `null` instead of `0`. |
| Minimum    | The minimum value to accept.                                                                |
| Maximum    | The maximum value to accept.                                                                |
| Required   | Indicates that a value must be provided for this input.                                     |

Validation rules common across text input components:

| Rule       | Description                                                                                 |
| ---------- | ------------------------------------------------------------------------------------------- |
| Pattern    | A limitation on the type of string to accept. Options are **Email**, **Regex**, or **URL**. |
| Min length | The minimum number of characters to accept.                                                 |
| Max length | The maximum number of characters to accept.                                                 |
| Required   | Indicates that a value must be provided for this input.                                     |

Validation rules common across [file input](./file-inputs.mdx) components:

| Rule      | Description                                                                                         |
| --------- | --------------------------------------------------------------------------------------------------- |
| Min files | The minimum number of files that can be uploaded.                                                   |
| Max files | The maximum number of files that can be uploaded.                                                   |
| Min size  | The minimum size of uploaded files with optional file size units. Without units, measured in bytes. |
| Max size  | The maximum size of uploaded files with optional file size units. Without units, measured in bytes. |
| Required  | Indicates that a value must be provided for this component.                                         |

Validation rules common across [date and time input](./dates.mdx) components:

| Rule             | Description                                             |
| ---------------- | ------------------------------------------------------- |
| Min date or time | The minimum allowed date or time.                       |
| Max date or time | The maximum allowed date or time.                       |
| Required         | Indicates that a value must be provided for this input. |

Validation rules common across special input components:

| Rule     | Description                                             |
| -------- | ------------------------------------------------------- |
| Required | Indicates that a value must be provided for this input. |

:::note

These lists are not comprehensive. Check the **Validation rules** of your component for the full list.

:::

## Apply custom validation rules

You can also create a **Custom rule**. Custom rules support any JavaScript expression that evaluates to a truthy value.

Optionally, set this field to evaluate to a string, which the component displays as an error message.

For example, you could create a custom rule with the following value: `{{ new Date().getDay() === 1 ? 'This input is invalid on Mondays' : '' }}`. This rule triggers an error message to display on Mondays. No error message is displayed on all other days.

## Validate form submissions

[Forms](./forms/form-component.mdx) can check the validation status of inputs—enable **Validate inputs on submit** in the **Interaction** section of the Inspector. Each input component supports several validation options. Validation for a selected input is configured in the **Validation** section of the Inspector.

:::note

If any single input fails validation, the form fails validation.

:::

For [JSON Schema Form](./forms/json-schema-form.mdx) components, you define [validation rules](https://rjsf-team.github.io/react-jsonschema-form/docs/usage/validation/) in the JSON schema. You can also enable automatic validation by enabling **Live validation** in the Inspector.

You can also modify input properties of JSON Schema Form components by updating the [type](https://rjsf-team.github.io/react-jsonschema-form/docs/usage/single#field-types) field. This can be useful if fields need to accept null values or you need to modify your form to more closely match your data.

---

## Getting started with number inputs

import Interaction from "/docs/apps/guides/forms-inputs/_partials/_interaction.mdx";
import Appearance from "/docs/_shared/_appearance.mdx";
import Content from "/docs/apps/guides/forms-inputs/_partials/_content.mdx";

You can use the following components to accept number-based user inputs:

- [Currency](../../reference/components/number-inputs/currency.mdx)
- [Editable Number](../../reference/components/number-inputs/editable-number.mdx)
- [Number Input](../../reference/components/number-inputs/number-input.mdx)
- [Percent](../../reference/components/number-inputs/percent.mdx)
- [Phone Number Input](../../reference/components/number-inputs/phone-number-input.mdx)

## Features

Key features of number inputs include:

- Stepper arrows.
- An optional "clear" button.
- Informational icons for currency code and country.
- Decimal rounding.
- Input validation, including minimum and maximum values.
- Style configuration.

### Format presets

Configure the format of your input using the **Format** setting.

:::tip
Currency and Percent components are presets of the Number Input component with preconfigured **Format** settings.
:::

### Decimal places

The Number Input component and its [presets](#format-presets) accept integers (numbers without a decimal place) and floating-point numbers (numbers with a decimal place).

Use the **Decimal places** setting to configure the maximum number of digits after the decimal. Retool rounds numbers to adhere to the configured decimal places when the input exceeds this limit.

The following defaults apply to numeric user inputs:

- **Standard format** defaults to up to three decimal places.
- **Percent format** defaults to up to three decimal places. The user's input is converted to a floating-point number `value` between 0 and 1.
- **Currency format** defaults to the standard number of decimal places for that currency.

:::note

JavaScript uses the IEEE 754 double-precision floating-point format, which allows for up to 16 significant decimal digits.

:::

Checking the **Pad decimal places** setting includes trailing zeros to match the specified number of decimal places.

### Currency code

The Currency component requires the **Currency code** setting. This setting accepts three-letter country codes defined by [ISO 4217](https://www.iso.org/iso-4217-currency-codes.html). Retool updates the icon to the left of the input field with the corresponding code or icon.

The **Currency code** setting defaults to USD.

---

## Define option lists

Many components present a list of options, such as the dropdown in a [Select](https://retool.com/components/select) or the menu of a [Split Button](https://retool.com/components/split-button). Each option contains a number of settings depending on the component—`value`, `label`, `caption`, `tooltip`, and `disabled`, and more.

import Shared from '/docs/_shared/_define-option-lists.mdx';

import Nested from '/docs/_shared/_nested-option-lists.mdx';

---

## Getting started with select inputs

import Interaction from "/docs/apps/guides/forms-inputs/_partials/_interaction.mdx";
import Appearance from "/docs/_shared/_appearance.mdx";
import Content from "/docs/apps/guides/forms-inputs/_partials/_content.mdx";

You can use the following components to present a set of options from which users can select:

- [Cascader](../../reference/components/select-inputs/cascader.mdx)
- [Listbox](../../reference/components/select-inputs/listbox.mdx)
- [Multiselect](../../reference/components/select-inputs/multiselect.mdx)
- [Multiselect Listbox](../../reference/components/select-inputs/multiselect-listbox.mdx)
- [Radio Group](../../reference/components/select-inputs/radio-group.mdx)
- [Segmented Control](../../reference/components/select-inputs/segmented-control.mdx)
- [Select](../../reference/components/select-inputs/select.mdx)

import WebPlayground from '/docs/_partials/_components/_web-playground.mdx';

Most select input components include an **Add ons** section, which enables you to add items such as a label or tooltip to the component.

### Define options

You define the options for most select input components manually or dynamically by mapping to an array of data. Refer to the [Define option lists](./option-lists.mdx) guide for more information.

### Identify parent

Cascader uses the **Parent value** setting to identify where each option should sit in the nested option list. Items without a parent value appear at the top level. The value of the **Parent value** setting must correspond a key in the dataset, which identifies the parent of the item. The value of this key must correspond to the `value` of the parent item.

For example, to create a Cascader, you could have a JavaScript query, `query1`, that includes the following code: 

```JavaScript
const jobs = [
  {label: 'Engineering', value: 'eng'},
  {label: 'Software Developer', value: 'dev', department: 'eng'},
  {label: 'QA Tester', value: 'qa', department: 'eng'},
  {label: 'Product', value: 'prod', },
  {label: 'Product Manager', value: 'pm', department: 'prod'},
];

return jobs;
```

Set the **Data source** of the Cascader to `query1`, and set **Parent value** to `{{ item.department }}`. Note that the `eng` department corresponds to the `value` of another item in the array.

The Cascader is structured as follows:

- Engineering
  - Software Developer
  - QA Tester
- Product
  - Product Manager

export function Cascader() {
  return (
    
      
    
  )
}

You can set the value of a selection component programmatically using the `.setValue()` method.

### Select all options

Multiselect and Multiselect Listbox both enable a user to select all options in the list using the UI, or programmatically with the `.values` property or `.setValues()` method.

For example, you could add a Checkbox component that, when checked, selects all values for the Multiselect component. To accomplish this, add a Multiselect component and a Checkbox component to the canvas.

In the Checkbox inspector, add an event handler with the following settings:

- **Event:** True
- **Action:** Control component
- **Component:** `multiselect1`
- **Method:** Set value
- **Value:** `{{ multiselect1.values }}`

Use the **Show clear button** setting to show an icon that lets the user clear the input field and return it to the **Placeholder** text. Multiselect Listbox includes **Show footer** setting instead, which displays **Select all** and **Clear** options in the footer.

---

## Getting started with sliders and ratings

Sliders and ratings are components that enable a user to define a number value or a range of number values between a minimum and a maximum. Use these components in [forms](../forms-inputs/forms/index.mdx) to collect user feedback or as controllers for other components.

Retool provides the following range and rating components:

- [Range Slider](../../reference/components/number-inputs/range-slider.mdx), which enables a user to select a range of number values using a slider.
- [Rating](../../reference/components/number-inputs/rating.mdx), which enables a user to select a number value on a scale using icons.
- [Slider](../../reference/components/number-inputs/slider.mdx), which enables a user to select a number value using a slider.

import WebPlayground from '/docs/_partials/_components/_web-playground.mdx';

## Features

Key features of sliders and ratings include:

- Configurable start values and minimum and maximum.
- Optional icons, labels, and tooltips.
- Event handlers triggered on change.
- Input validation.
- Customizeable styles.

## Specify content options

The **Content** section of the Inspector contains settings that control the content of a component, such as:

- **Default value**, which defines the initial value of the component. This is **Start value** and **End value** for Range Slider.
- **Minimum** (if applicable) and **Maximum**, which define the bounds of the input component.
- **Add-ons**, which define any labels, icons, and tooltips.

import Interaction from "/docs/apps/guides/forms-inputs/_partials/_interaction.mdx";

Event handlers are triggered on changes to the value of the component. Use event handlers to call queries, control components, or perform another action.

For example, you can use a Range Slider to dynamically filter a Table. Set the event hander **Action** to **Control component**. Select the table, and update the **Method** to **Set filter stack**. Enter a [list of filters](../../reference/components/data/table.mdx#property-filterstack) that you want to apply to the table. In this case, use the `value.start` and `value.end` of the Range Slider to define a minimum and maximum value for a column:

```json
[ { columnId: "amount", operator: ">", value: {{ self.value.start }} }, { columnId: "amount", operator: "

import Appearance from "/docs/_shared/_appearance.mdx";

The Rating component also includes several **Icon** options in this section.

---

## Getting started with buttons and links

Buttons and links enable users to navigate throughout or interact with your app. You configure these components with event handlers. When clicked, they can trigger a query, control a component, or perform another action.

The [Button](../../reference/components/buttons/button.mdx) component has a variety of presets and variations. Explore the following playgrounds to discover each of them.

import WebPlayground from '/docs/_partials/_components/_web-playground.mdx';

[Button Group](../../reference/components/buttons/button-group.mdx) is a group of individually configurable Button components.

[Close Button](../../reference/components/buttons/close-button.mdx) is a Button preset with a smaller size and a configured **Prefix icon** add-on.

[Dropdown Button](../../reference/components/buttons/dropdown-button.mdx) is a combination of Button and [Select](../../reference/components/select-inputs/select.mdx). When you click the button, a dropdown menu appears. Clicking an option in the menu performs the associated action.

[Outline Button](../../reference/components/buttons/outline-button.mdx) is a Button preset with **Variant** set to **Outline**.

[Split Button](../../reference/components/buttons/split-button.mdx) is a combination of Button and [Select](../../reference/components/select-inputs/select.mdx). When you click the icon next to the button, a dropdown menu appears. Selecting an option from the menu changes the button, and pressing the button performs the associated action. 

[Toggle Button](../../reference/components/buttons/toggle-button.mdx) is a Button preset with the **Text** setting configured to a truthy value. The default for this component has **Show** and **Hide** states.

The [Link](../../reference/components/buttons/link.mdx) component has a variety of presets and variations. Explore the following playgrounds to discover each of them.

[Link List](../../reference/components/buttons/link-list.mdx) is a group of Link components.

[Toggle Link](../../reference/components/buttons/toggle-link.mdx) is a Link preset with the **Text** setting configured to a truthy value. The default for this component has **Show** and **Hide** states.

:::note

The [Table](../data/table/columns.mdx) component supports the **Button** column type, enabling you to use buttons within a table.

:::

## Features

Key features of buttons and links include:

- Configurable icons, text, and accessible names.
- Input validation.
- Event handlers triggered on click.
- Customizeable styles.

## Specify content options

The **Content** section of the Inspector contains settings that control the content of the button or link, such as:

- **Text**, which is displayed on the Button or as the Link text.
- **Accessible name**, which is the name for a Button so that it can be identified via screen reader.
- **Add-ons**, which include icons and tooltips.
- **Actions**, which define a list of options for buttons or links that feature a list, including Dropdown Button, Split Button, and Link List.

You can choose to set the **Text** setting to a string or to a JavaScript snippet, which is useful if you want the text to be dynamic. For example, you could set the **Text** of a logout button to ` Log out {{ current_user.firstName }} `.

### Define options

Dropdown Button, Split Button, and Link List all feature a list of buttons or links. You [define the list of options](../forms-inputs/option-lists.mdx) manually or dynamically map them from an array of data.

## Configure user interaction

The **Interaction** section of the Inspector contains settings that control user interaction, such as:

- **Disabled**, a truthy value that disables the button or link when evaluated to `true`.
- **[Event handlers](../interaction-navigation/event-handlers.mdx)**, which listen for and handle interactions with your components.

Event handlers determine what happens when you click a button or link. Common actions are **Control query**, **Control component**, and **Go to URL**.

:::note

Button and link clicks are non-programmatic, and clicks can only be triggered by direct user action.

:::

### Configure option interactivity

Define interaction for Dropdown Button, Split Button, and Link List on a per-option basis. Select the option you want to edit, and add an event handler in the **Interaction** section of the pop-up.

### Use buttons with forms

Buttons are automatically included with Forms, but you can configure standalone buttons to configure forms, too. Change the **Type** to **Submit**, and select the form that you want to submit. 

import Appearance from "/docs/_shared/_appearance.mdx";

---

## Configure event handlers

import Shared from '/docs/_shared/_event-handlers.mdx';

---

## Interaction and navigation



---

## Getting started with navigation components

Use navigation components to help users quickly find the information they need and move between pages and apps. The following components are helpful:

- [Navigation](../../reference/components/navigation/navigation.mdx): A primary menu to help users quickly move between pages and apps. The Navigation component is automatically included in headers and sidebars when adding using multiple pages. 
- [Breadcrumbs](../../reference/components/navigation/breadcrumbs.mdx): A hierarchical list of links to help users trace their path through an app.

import WebPlayground from '/docs/_partials/_components/_web-playground.mdx';

## Features

Key features of navigation components include:

- Automatic configuration of Navigation when there are multiple pages.
- Manual or mapped menu items.
- Event handlers that navigate users to another app, page, or URL.
- Optional icons for each menu item.
- Customizeable style, including horizontal or vertical orientation for Navigation.

### Alternative navigation options

Retool provides a few other types of components that you can also use to help users navigate through steps or flows on a single page. These components are covered by other guides:

- [Steps](../../reference/components/navigation/steps.mdx): Create a [linear step-by-step flow](../layout-structure/container.mdx#stepped-containers).
- [Tabs](../../reference/components/navigation/tabs.mdx): Create a [set of tabbed options](../layout-structure/container.mdx#tabbed-containers).
- [Wizard](../../reference/components/containers-forms/wizard.mdx): Create step-by-step flows that can [branch into different paths](../interaction-navigation/wizard.mdx).
- [Page Input](../../reference/components/navigation/page-input.mdx), and [Pagination](../../reference/components/navigation/pagination.mdx): Create [options for paginating large amounts of information](./pagination.mdx).

## Specify content options

The **Content** section of the Inspector contains settings that control the content of the navigation components, such as:

- **Mode**, which controls whether the Navigation uses **Manual** or **Mapped** data
- **Menu items** or **Breadcrumbs**, which define the items in the navigation components.
- **Add-ons**, which enable you to add and configure a logo and tooltips. 

You define the options for these components manually or dynamically by mapping to an array of data. Refer to the [Define option lists](../forms-inputs/option-lists.mdx) guide for more information.

### Use Navigation with multiple pages

When you use a Navigation component in a an app with multiple pages, the menu items automatically populate. The **Data source** defaults to `{{ retoolContext.pages }}`, and item **Label** defaults to the page's title, if available.

New _headers_ and _sidebars_ are also automatically populated with a pre-configured Navigation component.

### Manually configure menu items

You can manually configure navigation options in the **Menu items** or **Breadcrumbs** section to configure menu items. Click on a menu item to configure it using the **Edit menu item** settings. Set the **Type** to identify the destination of each menu item. 

For Navigation, you can configure menu items to appear highlighted using the **Highlight** boolean setting. This is useful to visually highlight a menu item for the current page or app.

#### Add dropdown menu items

In Navigation components, you can group menu items together as _nested_ dropdown menus. Each _parent_ menu item contains _child_ menu items (submenu items) that appear within the dropdown menu. Dropdown menu items support one level of nesting—child menu items cannot also be parent menu items.

:::note

Parent menu items cannot be configured to trigger actions on click. This event is used to expand or collapse the menu.

:::

To nest a menu item, drag it below and to the right of the menu item you want to nest it under. A blue line appears as you drag menu items around and indents to the right when nesting.

Parent menu items include a count of all nested items.

## Configure user interaction

The **Interaction** section of the Inspector enables you to set [event handlers](../interaction-navigation/event-handlers.mdx), which listen for and handle interactions with your components.

### Perform actions on click

:::note

Event handlers for Breadcrumbs with a **Type** of **App** or **Custom** are automatically defined. Breadcrumbs must be a **Custom** type if you want to create your own event handlers.

:::

Configure menu items to perform specific actions when clicked. You can create menus that export data, link to other apps or URLs, copy content to the clipboard, or run queries.

When configuring menu items to **Open another Retool Page**, you can optionally include [URL query and hash parameters](../app-management/customize-app-urls.mdx) to pass data to, or configure certain characteristics of, other apps.

You can also configure event handlers to trigger when you click the logo. Select the logo in the Navigation component, and click **+** to add an event handler

### Add a logout button 

To allow users to log out of Retool directly from your app, you can add a logout button.

Add a Button or Icon component and attach a **Click** [event handler](../interaction-navigation/event-handlers.mdx) to it. Set the **Action** to **Go to URL**, and in the **URL** field, append `/logout` to your organization's base URL. After they click the button, users are sent to your organization's login page.

import Appearance from "/docs/_shared/_appearance.mdx";

### Orientation

The Navigation component defaults to horizontal orientation, but it also supports vertical orientation to display a navigation menu alongside content, such as within the [Sidebar frame](../../concepts/ide.mdx#sidebar-frame).

### Mobile layout navigation

If you configure your app with a mobile layout, Retool can automatically configure a slide-in Navigation menu using the Sidebar frame. When viewed on mobile, the Header frame contains a menu button to show or hide the menu.

---

## Getting started with pagination components

Pagination enables you to present large amounts of data in a more manageable way for your users. Retool provides several components that can help users navigate through pages of data or information:

- [Page Input](../../reference/components/navigation/page-input.mdx): An input field to jump to a specific page of data.
- [Pagination](../../reference/components/navigation/pagination.mdx): A sequential set of numbered links to navigate through pages.

import WebPlayground from '/docs/_partials/_components/_web-playground.mdx';

:::note

These components are independent from the [Navigation](../../reference/components/navigation/navigation.mdx) and [Breadcrumbs](../../reference/components/navigation/breadcrumbs.mdx) components, which are primarily used to [navigate between apps or between pages](./navigation.mdx).

:::

## Features

Key features of pagination components include

- Default page and range.
- Automatic adjustment of page numbers to fit width.
- Event handlers to perform actions when a page is clicked.
- Customizeable style.

:::tip

The [Table](../../reference/components/data/table.mdx) component automatically paginates tabulated data and has built-in support for [server side pagination](../data/table/pagination.mdx).

:::

## Specify content options

The **Content** section of the Inspector contains settings that control the content of the pagination components, such as:

- **Default page**.
- **Page count**.
- **Add-ons**.

You can set the **Default page** and **Page count** to an integer or a JavaScript value. The `Math.ceil()` function is useful for determining the number of pages—for example, you could set the **Page count** to `{{Math.ceil(query1.data.count / 5)}}` if you want each page to have five entries.

Page Input enables you to customize the component text using **Prefix text** and **Suffix text** add-ons.

## Configure user interaction

The **Interaction** section of the Inspector enables you to set [event handlers](../interaction-navigation/event-handlers.mdx), which listen for and handle interactions with your components.

import Appearance from "/docs/_shared/_appearance.mdx";

## Pagination example

This guide walks you through an example use case of Pagination, in which a [List View](../../reference/components/repeatables/list-view.mdx) displays a custom-built list view of users with the [Avatar](../../reference/components/presentation/avatar.mdx) component. The list displays information about three users at a time and uses the Pagination component to navigate.

### Create queries

A `getUsers` query retrieves a list of user information from a PostgreSQL database:

```sql title="getUsers"
select * from users
order by id asc
limit 3 offset {{(pagination1.value - 1) * 3}}
```

This query returns information from 3 users at a time. It utilizes the value of a Pagination component (which we will create in a moment) to identify the offset for the query. If `pagination1.value` is `2`, then the query returns users with an `id` of `4`, `5`, and `6`.

An additional query, `getCount`, retrieves the number of entries in the table:

```sql title="getCount"
select count(*) from users
```

### Add a Pagination component

Add a Pagination component to the canvas. In this example, each page should contain a list of three users. Set the **Page count** to `{{ (Math.ceil((getCount.data.count)/3)) }}`.

- `(getCount.data.count)/3` calculates the number of pages by dividing the total count by the number of users to include per page.
- `Math.ceil()` rounds this number up to the nearest whole number. This allows the last page to contain fewer than three users. The `users` table has 13 users, so there are five pages.

### Add a List View component

Next, add a List View component to the canvas, and update the **Data source** to `getUsers`. Add an Avatar component to the first instance of the List View. Update the following settings:

- **Fallback text**: `{{ getUsers.data.name[i] }}`
- **Label**: `{{ getUsers.data.name[i] }}`
- **Caption**: `{{ getUsers.data.email[i] }}`

Now, you have a List View component with an Avatar for each user in the database. Entries are organized into three pages,

---

## Getting started with the Wizard component

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

The [Wizard](https://retool.com/components/wizard) component allows you to group components into a series of steps that follow a linear path or branch into multiple ones. It supports running queries on step change or reset, [virtual steps](#add-virtual-step) that display a loading screen, and setting the initial step dynamically. The Wizard component also includes a workflow editor to add or remove steps and define transitions between them.

This guide walks you through building a wizard to deactivate a user. Before doing so, the wizard checks that the user's account is in good standing. If not, you have the option of sending the user an invoice to collect an outstanding balance. The wizard also requires you to provide a reason before you deactivate the user.

## Generate user data

For the purpose of this guide, your app uses sample user information that's generated from our [REST API generator](https://retool.com/api-generator/). This online tool creates a REST API endpoint with a custom dataset for you to interact with.

:::warning Generated APIs are for test purposes only

Generated API endpoints require no authorization and are limited to 150 rows of data. Retool may delete APIs that have not been used in the last 30 days.

:::

Launch the [REST API generator](https://retool.com/api-generator/) and create a new dataset with the following information:

| Column name | Data type                                                 |
| ----------- | --------------------------------------------------------- |
| user        | Email address                                             |
| active      | Boolean                                                   |
| balance     | Random number (set the minimum and maximum range of 0—10) |

Set the **API Name** to `wizard` and **# Rows** to `25`, then click **Generate API**.

Retool automatically generates a custom API and outputs details of the endpoint.

## Query user data

First, create a new app. Retool automatically creates a new query (**query1**) to get started. Select the query and change its **Resource** to **RESTQuery**, then configure it to perform a **GET** request from your generated API endpoint URL (e.g., `https://retoolapi.dev/cZQzL3/wizard`). Click **Save & Run** to save the query and run it.

This API returns sample data with the following structure:

```json
[
  {
    "id": 1,
    "user": "sbrito2q@posterous.com",
    "active": true,
    "balance": 9
  },
  {
    "id": 2,
    "user": "vkubach6t@smh.com.au",
    "active": true,
    "balance": 9
  },
...
]
```

Click the query's name and rename it `getUsers`.

## Build the wizard

Drag a Wizard component onto the Retool canvas. Wizard functions like the [Container](https://retool.com/components/container) component and groups other components together. Next, drag a [Table](https://retool.com/components/table) component onto the Wizard. The table automatically uses the most recent query as a data source to display the API data.

Right click the table and select **Rename**. Rename it to `selectUser`.

### Create additional steps

Select the wizard and click **Edit workflow** in the **Edit** section of the right panel to open the **Workflow editor**. You use this to add additional steps and define paths through the wizard.

:::note Navigate the Workflow editor

You can pan and zoom around the Workflow editor as you build out additional steps.

:::

Rename this first step to **Select user** and add two new steps for **Payment reminder** and **Deactivate user**. Connect **Select users** to both new steps by holding the **Shift** key as you click-and-drag.

### Define paths

The wizard can follow different paths depending on _truthy_ conditions. If the path's **Enable if** value evaluates to **true**, the wizard presents this as a next step. If it evaluates to **false**, the step is not available. Set the value of **Enable if** between **Select user** and each path of the following:

1. **Send payment reminder**: `{{ selectUser.selectedRow.balance > 0 }}`. This enables the path to the **Send payment reminder** step only if there's a balance remaining.
2. **Deactivate user**: `{{ selectUser.selectedRow.balance === 0 }}`. This enables the path to the **Deactivate user** step only if the balance is zero.

### Customize payment reminder step

Each step of a wizard is independent and can contain different components. Click on the **Edit step** dropdown in the **Edit** section of the right panel, then select **Payment reminder**.

To create a form that can be used to send a payment reminder:

1. Drag a [Form](https://retool.com/components/form) component to the wizard and update its title to `Reminder form`.
2. Drag an Email component to the form. Set its value to `{{ selectUser.selectedRow.user }}`.
3. Drag a Currency component to the form. Set its value to `{{ selectUser.selectedRow.balance }}`.

The form automatically uses the email address and the balance as values for the inputs. You could use these fields within a query to send emails using the [Retool Email](../../../data-sources/quickstarts/retool-email.mdx) resource. For the purpose of this guide, you won't configure the form to perform any further action.

### Customize the deactivation step

The last step in the wizard is to deactivate the selected user. Select **Deactivate user** in the **Edit step** dropdown of the Inspector, then drag a [Select](https://retool.com/components/select) component on to the step and rename it to `reasonSelect`. Update its list of options to include:

| Value   | Label                 |
| ------- | --------------------- |
| stopped | Stopped using service |
| cost    | Too expensive         |
| other   | Other reason          |

### Configure a virtual step to deactivate user

You can use a _virtual step_ to automatically trigger a query or conditionally route to a different step. In this case, to deactivate a user and submit the reason.

#### Create deactivation query

First, create a new **RESTQuery (restapi)** query with the following information:

- Action type: **PATCH**
- URL: `[endpoint-path]/{{ selectUser.selectedRow.id }}`
- Body:
  - `reason`: `{{ reasonSelect.value }}`
  - `active`: `false`

Save the query, then rename it to `deactivateUser`.

This query performs a PATCH request with the selected user's ID. It includes the `reason` from the dropdown menu and sets `active` to `false`, disabling the user.

#### Add virtual step

Add a virtual step to the workflow editor named **Reason selected** and toggle **Virtual step** on. Set **On enter query** to the PATCH query you just created. Next, create a path from the **Deactivate user** step to this new virtual step. To ensure that a reason is selected, set this path's **Enable if** to `{{ reasonSelect.value !== null }}`.

Selecting a reason enables the virtual step. As you progress to it, the virtual step triggers the query and deactivates the user.

### Add a final step to verify the changes

Virtual steps appear as loading screens and automatically progress to another step once a query is run. The final step of this wizard verifies the changes have been made.

Create another query to perform a **GET** request that retrieves the deactivated user from the API:

- Action type: **GET**
- URL: `[endpoint-url]/{{ selectUser.selectedRow.id }}`

Update the query's name to `verifyUser`.

Add another step to the wizard and name it **Verification**. Connect a path from the **Reason selected** step and set **Trigger if** to `{{ deactivateUser.data }}`, so it immediately moves to the next step after triggering the deactivation query.

Select the **Verification** step and drag a [Text](https://retool.com/components/text) component to it. Update its value to display the query's results.

```
User: {{ verifyUser.data.user }}
Active: {{ verifyUser.data.active }}
```

Your wizard is now ready and can deactivate users. If a user has an outstanding balance, it presents the option to send a reminder instead.

---

## Group components with containers

You can group related components together in a card using the container components. Containers also support multiple views that allow you to separate content into distinct views that users can switch between.

Containers function like any other component. Once added, you can group components within them by dragging them onto the Container.

You can use the following components as containers:

- [Collapsible Container](../../reference/components/containers-forms/collapsible-container.mdx)
- [Container](../../reference/components/containers-forms/container.mdx)
- [Link Card](../../reference/components/containers-forms/link-card.mdx)
- [Stack](../../reference/components/containers-forms/stack.mdx)
- [Steps](../../reference/components/navigation/steps.mdx) and [Stepped Container](../../reference/components/containers-forms/stepped-container.mdx)
- [Tabs](../../reference/components/navigation/tabs.mdx) and [Tabbed Container](../../reference/components/containers-forms/tabbed-container.mdx)
  

import WebPlayground from '/docs/_partials/_components/_web-playground.mdx';

## Features

Key features of containers include:

- The ability to group related components together.
- Multiple views and the ability to switch between them.
- Event handlers and other opportunities for interaction.
- Customizeable style options.

## Specify content options

The **Content** section of the Inspector contains settings that control the content in the container, such as:

- Views (if more than one view exists).
- Default view.
- Add-ons.

### Customize the container layout

Containers contain three sections in which you can place components:

- **Header**: The top area that initially contains a Text component for use as a title.
- **Body**: The main area for you to place components. If you enable multiple views, switching views changes the content shown in the body.
- **Footer**: The bottom area that is useful for optional footnotes and supplementary content.

You can show or hide headers and footers using **Add-ons** in the container's **Inspector**.

### Configure multiple views

Containers support multiple views for grouping content. Only one view is visible at a time and users switch between them by changing the current view of the Container component. Switching views applies only to the body of a Container—the header and footer areas are shared across all views.

Select or drag a Container on the canvas and click **+ Enable multiple views** in the **Content** section of the **Inspector**. Once enabled, you manage views and select which view is visible using the option list editor.

To add components to the selected view, select **Add component**. Each component is associated with the view in which it's contained. As you switch between views, only components associated with the current view appear.

### Link to Steps or Tabs

You can link a [Steps](../../reference/components/navigation/steps.mdx) or [Tabs](../../reference/components/navigation/tabs.mdx) component to a Container with multiple views, creating a Stepped or Tabbed Container. Toggle the **Link to a Container** setting and select a Container to link with. To unlink, toggle the option off.

In general, Retool recommends using the preconfigured Stepped or Tabbed Containers.

### Stepped Containers

The [Stepped Container](../../reference/components/containers-forms/stepped-container.mdx) component combines the [Steps](../../reference/components/navigation/steps.mdx) component with a Container, allowing you to create a step-by-step flow through the Container's views. This is useful if you have a multi-step process that users must complete.

You can drag Stepped Containers directly to the canvas. The Container automatically includes a Steps component that maps to views. As you make changes to views, the steps update automatically.

You can use conditional logic to prevent users from progressing to the next step, such as an incomplete selection or missing input, or mark steps as complete.

### Tabbed Container

The [Tabbed Container](../../reference/components/containers-forms/tabbed-container.mdx) combines the [Tabs](../../reference/components/navigation/tabs.mdx) component with a Container, allowing you to create tabbed navigation for the Container's views.

You can drag Tabbed Containers directly to the canvas. The Container automatically includes a Tabs component that maps to views. As you make changes to views, navigation options update automatically.

## Configure user interaction

The **Interaction** section of the Inspector contains settings that control user interaction, such as:

- **Transition**, which customizes the animations upon view change.
- **Hoist loading state**, which shows a loading state when inner components are loading.
- **[Event handlers](../interaction-navigation/event-handlers.mdx)**, which listen for and handle interactions with your components.

### Disable interaction

You can disable interaction with a Container by setting **Disabled** to a truthy value. Disabling a Container also prevents user interaction with any nested components it contains.

### Switch between views

In addition to using Stepped or Tabbed Containers, you can select a Container's current view using event handlers, JavaScript, or a linked Steps or Tabs component.

#### Event handler

Use the **Control component** action and select either the **Set current view key** or **Set current view index** method.

#### Set views with JavaScript

You can write JavaScript (e.g., **JavaScript queries** or **Run script** [event handlers](../../guides/interaction-navigation/event-handlers.mdx)) to select a view. Use `setCurrentView()` with the key for the view or `setCurrentViewIndex()` with the index of the view:

```javascript
container1.setCurrentView("View 1");
container1.setCurrentViewIndex(0);
```

import Appearance from "/docs/_shared/_appearance.mdx";

### Width and height

You have manual control over the width of a Container. You can configure its **Height** to either **Auto** or **Fixed**:

- **Auto**: The height grows automatically based on the content.
- **Fixed**: The height is a fixed size that you manually control. Scroll bars appear if the content exceeds the height.

### Group components with flexible box layouts {#stacks}

The [Stack](../../reference/components/containers-forms/stack.mdx) component is a container with [Flexbox](https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Flexbox)-like controls. Rather than use with the 12-column grid layout, Stack arranges nested components horizontally or vertically, and provides additional controls over the layout.

The **Direction** setting specifies the direction that components follow within the container. Select **→** to arrange components horizontally or **↓** to arrange components vertically.

Stack components have additional settings for **Layout** and **Spacing**, including:

- Distribute
- Align
- Gap
- Allow wrap

---

## Getting started with frames

Frames are special containers that enable you to divide and manipulate the app viewport in different ways.

All apps contain a Main frame, which takes up the entire canvas area by default. 

import Frames from '/docs/_shared/_frames.mdx';

## Frame scopes

The [Header](#header-frame) and [Sidebar](#sidebar-frame) frames are globally scoped and persist across all pages. Any components within these frames inherit this behavior and are globally scoped. All other frames (e.g., Modal and Drawer) are page-scoped and only available within the app in which they reside. Find more information about scopes in the [Quickstart](../../quickstart.mdx#global-and-page-scopes).

## Features

- Optional headers and footers for certain frames.
- The ability to group related components together within a frame.
- Event handlers and other opportunities for interaction.
- Customizeable styles.

## Specify content options

The **Component tree** tab of the [IDE](../../concepts/ide.mdx) contains two sections: **Frames** and **Components**. Select a frame to view the components that are nested inside it. 

Some frames (Sidebar, Modal and Drawer) support a header and footer within the frame itself. Enable these using the **Add-ons** setting in **Content** section of the Inspector.

In the following image, you can see all the components that are nested within the **Header** and **Body** of the Drawer component. Note that the **Header** setting is enabled in the Inspector on the right side of the screen.

Main, Header, and Split Frame have no settings in the **Content** section of the Inspector because all settings are applied at the component level.

## Configure user interaction

[Event handlers](../interaction-navigation/event-handlers.mdx) which listen for and handle interactions with your components. You configure these in the **Interaction** section of the Inspector.

The **Show** and **Hide** events enable you to trigger actions when a user opens or closes a frame. For example, in the following screenshot, a **Hide** event handler turns off the **Modal** toggle in the Switch Group by setting the value to `{{ switchGroup1.value.filter(item => item !== 'modal') }}`.

You can also close a Modal or Drawer using the **Close when clicking outside** or **Close when pressing Escape** settings.

import Appearance from "/docs/_shared/_appearance.mdx";

The following settings are useful for customizing frames:

- **Show overlay**: Show an overlay behind a Drawer or Modal component that darkens the rest of the app. Turn off this setting to be able to drag content from Main to a Drawer or Modal frame.
- **Expand content to fit**: Removes all padding and margin, and causes the frame to take up the entire screen. Can only be used when there is a single component in the frame.
- **Hidden**: A truthy value that shows the frame when set to `true`. The `.setHidden` method is also useful for dynamically hiding a frame.
- **Styles**: Updates the style of the frame as a whole.
- **Nested styles**: Applies style changes across all components inside the frame, but not to the frame itself.

---

## Layout and structure



---

## Assemble mobile layouts for web apps

Retool apps are responsive and support different viewport widths. You can configure separate desktop and mobile layouts to customize your app for mobile web users. To do this, you optionally show or hide components on the mobile layout and arrange them as needed. The mobile layout also uses a narrower [12-column grid layout](../../concepts/ide.mdx#grid-layout) to accommodate the smaller viewport size.

Both desktop and mobile layouts use the same component but allow you to change their position independently. Any changes you make to a component's settings, such as labels or event handlers, apply to both views.

## Switch between desktop and mobile layouts

No components are included in the mobile layout by default. Once you add a component, the app IDE [navbar](../../concepts/ide.mdx#navbar) displays a toggle to switch between desktop and mobile layouts.

Use the layout controls to switch between **Desktop** and **Mobile** layouts. Components you add to either layout appear only in the layout you're currently viewing. For example, if you add a component while viewing the mobile layout, it does not appear in the desktop layout until you enable it.

## Add components to the mobile layout

Use the Inspector in the right panel to add selected components to the mobile layout. Click the **Advanced settings** icon in the **Appearance** section, then enable **Show on mobile**.

Retool initially positions components in the mobile layout similar to the desktop layout. If another component is already in the same position on the mobile layout, the app IDE notifies you. Should this occur, reposition any existing components on the mobile layout first to allow for the addition of the other component.

## Arrange components in the mobile layout

You can customize the arrangement of components for each layout separately—repositioning a component in the desktop layout does not alter its position for the mobile layout. Switch to the mobile layout and then position or resize components as needed.

---

## Build modules to reuse queries and components

import Modules from '/docs/_shared/_module-best-practices.mdx';

A module is a collection of components and code that you can build and embed within other apps. Modules enable you to reuse components and code in multiple apps, and modules can pass data to and from the parent app. This can help reduce app maintenance as you only need to update a module; any parent apps immediately reflect the changes.

Common uses for modules include:

- Sharing specific functionality across different apps. For example, a module to send SMS notifications using Twilio could be used in apps used by different teams rather than rebuilding the same functionality multiple times.
- Splitting large or complex apps into smaller, more maintainable parts. Multiple app builders and teams can then maintain their own functionality without making changes to the parent app.

As modules are a type of app, they support many of the same features. You can [import or export modules using JSON](../app-management/import-export.mdx), [set permissions](../../../permissions/guides.mdx) to restrict access, and [create new releases](../app-management/releases-history.mdx).

## Best practices

### Limitations

Modules have the following limitations:

- Modules inherit custom CSS and preloaded custom JavaScript from the parent app, and these settings are unsupported for modules themselves.
- User permissions for modules must be the same as those for the parent app.
- Using modules inside List Views is not supported.
- While it is possible to [create new releases](../app-management/releases-history.mdx) of a module, all apps that contain the module use the live version. Different apps cannot use different versions of the same module.

## Build a module

You can create a module from scratch, by cloning a module from an app, or by copying components to a module.

### Create a new module

To create a new, empty module, navigate to the **Apps** tab in your organization and select **Create new > Module**.

After creating a module, assemble components using the same methods you would use to build an app.

### Add the module to an app

Add a module to your app in the same way you would add a component. Just like with components, you can  reposition and resize modules on the canvas.

Click **+** in the left sidebar to open the **Add UI tab**. Switch to the **Modules** tab and then drag the module onto the canvas.

Once embedded within your app, you can return to editing the module by right-clicking on the module and clicking **Edit module**.

### Export components to modules

You can also select one or more components and export them to a module from within the app editing experience. All the related logic, such as queries, variables, and transformers, are automatically included in the exported module.

To copy components to a module, select the components—click and drag or ctrlcmd + click—and select **Export to module**.

export function Export() {
  return (
    
      
    
  )
}

Once the export is complete, Retool automatically replaces the selection with the newly created module.

## Send data to and from the module

Once you've created your module, you can define it further with inputs and outputs. These enable your module to exchange data with the parent app and other modules.

### Add inputs

You can pass in **data inputs** and **query inputs** to your module from parent apps or other modules.

For example, you could build a module that simplifies how hiring managers review job applicants. The parent app contains a Select component with the list of applicants. Then, add modules that enable the manager to view the total number of applicants, or view each person's portfolio. The modules can be reused in multiple apps without rebuilding the UI and logic. The examples in the following sections explain how to build this app and configure the data inputs and query inputs.

A data input is a property that apps can pass into modules. Use a data input when you want your module to reference a component on the screen, a variable, or a certain value.

From the module editor, add an input using the **Module settings**, found within the Inspector. Set the **Type** to one of the following values:

- **Any**
- **String**
- **Number**
- **Boolean**
- **Enum**

Choose from **String**, **Number**, **Boolean**, or **Enum** for type validation on your module input. Selecting a **Type** enforces stricter validation rules and displays a warning if the input type does not match what you selected. You can also define additional characteristics about the input, such as options for **Enum**, and default values for all types.

:::note

Changing the type of the module input does not alter the actual value passed into the module—invalid values are still passed through as-is. The validation only affects how the input fields behave and display warnings.

:::

If you set the **Type** to **Any**, Retool performs no validation on the module input.

Once your module is configured, navigate to the app editor. Click on the module and add the corresponding input in the **Content** section of the module Inspector.

Example

For example, you could create a module for your applicant review app that displays a preview of a selected candidate's portfolio by using an [IFrame](../../reference/components/custom/iframe.mdx) component.

To create this module, complete the following steps in the module editor:

1. Add an IFrame component to the canvas.
2. Open the **Module settings** and add an input.
3. Update the **Type** to **String**. Optionally set the input **Description** and **Default value**. If the **Default value** is not of the correct type, you will see an error.
4. Select the IFrame, and set the URL to `{{ input1.value.website }}`.

export function DataInput() {
  return (
    
      
    
  )
}

To add this module to the parent app, complete the following steps in the app editor:

1. Drag the module onto the canvas.
2. Set the module's input to `{{ select1.selectedItem }}`.

Query inputs allow you to pass queries into modules from parent apps. The module can then trigger these queries directly, calling them in event handlers and as success and failure trigger queries.

Though query inputs are not defined in modules, you can view them in the query editor and add [event handlers](../interaction-navigation/event-handlers.mdx) to them.

From the module, add a query input using the **Module settings**, found within the Inspector. From the app, click on the module and add the corresponding input in the **Content** section.

Example

For example, you could create a module for your applicant review app that queries a dataset of job applicants to find the total number and display that number to the user using a Statistic component.

To create this module:

1. Create a query that finds the total number of applicants.
2. In **Module settings**, add a query input, which automatically creates a query that is triggered upon the input of the parent app. Set the success event of `input1` to `query1`.
3. Add a Statistic component to the canvas.
4. Update the Statistic component settings to use `{{ query1.data.id }}` as the value.

To add this module to the parent app:

1. Drag the module onto the parent app's canvas.
2. Set the module's input to `getApplicants`, a query that retrieves the full list of applicants.

#### Trigger module queries from parent apps

Use query inputs to trigger queries within a module, not from the parent app defining the query. If you need to trigger a module's query from its parent app, you can use data inputs.

1. In your module, create a data input. You'll use this input to watch for changes from the parent app.
2. In your module, use the **Query JSON with SQL** resource to write a query which runs automatically when your data input changes. The result of this query won't be used. For example, given `input1` as a data input, the query could be:

```sql
select id from {{ input1.value }}
```

3. In your module, define the query you want the parent app to trigger. In the **Query JSON with SQL** query, trigger this query as a **Success** event handler.
4. In the Inspector of your parent app, pass data to the module's data input. To trigger the module query based on the result of a query in the parent app, set the data input to `{{ parentQuery.data }}`. The module then watches for changes to `parentQuery.data`.

To test out this behavior, [download and import the JSON](/img/docs/8ee48756-c6db-48f7-966f-a9049f3c8d04.json) of an example module using data inputs.

#### Test inputs with sample values

Because module inputs are controlled by the parent app, you can pass through test values to preview your module. When you select the module container, the right panel of the app IDE shows a **Test inputs** section. There, you can test your module's behavior by giving expected values for each of your inputs.

### Add outputs

Outputs are properties that parent apps can reference. Outputs are the only way to pass information from your module to a parent app—no other data from within your module is accessible to it. Module outputs must be formatted as strings.

From the module, add an output using the **Module settings**, found within the Inspector.

For example, imagine creating a search field that can be reused between all your apps. To do so, create a module and add a text input field. Create an output, and set the `output1` value to `{{ textInput1.value }}`.

To use the module to search a table within a parent app, drag the module onto the canvas. Select the Table, and set the **Search term** to `{{ moduleSample1.output1 }}`.

## Customize layout

You can also configure the layout of your module using the **Spacing** and **Appearance** sections of the Inspector:

- **Height**: Whether the height of the module is automatic or fixed.
- **Margin**: Whether the module should have a normal margin or none.
- **Overflow**: Whether overflow content in the module is hidden or accessible via scroll.

When you configure these settings inside the module editor, the settings apply as the default values only to new module instances. Existing module instances are unchanged. You can also override these settings for a single module instance by changing them in the Inspector of the app that contains the module.

---

## Build custom views using repeatable components

A repeatable component maps an array of data to repeating instances. Visually, a repeatable component is made up of a series of instances—each instance contains one or multiple components. Assemble components to display within the first instance, and configure them to reference your data source. A series of instances appears, each one corresponding to one item in your array.

[List View](../../reference/components/repeatables/list-view.mdx) is the main repeatable component for apps. The initial state of this component is a vertically-scrolling list of instances, each of which include a Container and are connected to demo data.

The following components are presets of List View:

- [Container List View](../../reference/components/repeatables/container-list-view.mdx), which is a [Container](./container.mdx) that includes a List View component.
- [Grid View](../../reference/components/repeatables/grid-view.mdx), which is a preset of List View with **Layout Type** set to **Grid**.

In the following demo, the underlying configuration for displaying user names, emails, avatars, and other charateristics is only done once. The configuration is then repeated for every user in the data source, resulting in the grid-like view.

## Features

Key features of repeatable components include:

- One-time configuration of repeatable components.
- Dynamic loading of source data.
- The ability to add several nested components in each instance.
- Configurable user interaction.
- Custom styles.

## Specify content options

The **Content** section of the Inspector contains settings that control the content in the repeatable components, such as:

- The data source.
- The primary key.

### Select the data

Add a List View component to the canvas and select a **Data source**. You can write [JavaScript](../../../queries/guides/javascript/index.mdx), pass an array, or use [query data](../../../queries/quickstart.mdx) as your data source. The only requirement is that the data source is an array (primitive and object arrays both work).

:::note Set a primary key

Retool tries to set a primary key for List View components when you select a data source. If your app has multiple user input components, make sure the primary key is set correctly. This ensures your app state is correct after users make changes like adding or sorting data.

:::

After selecting a data source, Retool seeds the component with containers for each item in your data source. Add components to the first container, and they're automatically propagated to the other containers. Retool sets some default values, but you use the `item` and `i` variables to display data in each component.

#### The `item` variable

The `item` variable corresponds to the value of an entry in your data source. It's equivalent to referencing `listView1.data[i]`. You can use `item` to access values in your data source, such as `{{ item.id }}` or `{{ item.value }}`.

#### The `i` variable

The `i` variable is a number that represents the index of an entry in your data source. Since a list view is a repeatable component, each repeated instance has a different index which you can use to render and access unique values.

`i` is often used to iterate over a set of values and perform some kind of action. For example, you could iterate over an entire list view to update values, make API requests, send emails, etc. For example, this JavaScript [transformer](../../../queries/guides/transformers.mdx) iterates over all the entries in `listView1`, and returns each sales person with over 200 sales.

```javascript Transformer
var salesPerson = {{ listView1.data }};
var highSales = salesPerson.filter(i => i.sales > 200);
return highSales;
```

## Configure user interaction

The **Interaction** section of the Inspector contains settings that control user interaction. These settings are limited for repeatable components – to configure [event handlers](../interaction-navigation/event-handlers.mdx) and other interactions, select the first Container and make your changes in the Inspector.

### Aggregate form components

If you need to access the value of an input component within a repeatable component, toggle **Enable instance values** on. When enabled, the repeatable component attempts to evaluate all input values and make them available in the `instanceValues` property. 

`instanceValues` is an array of objects for every instance of the component, where each object is a mapping of an input's `formDataKey` to its `value`. This also includes the `primaryKey` of the list item.

For example, you can use a [transformer](../../../queries/guides/transformers.mdx) to iterate over a list of Number Input components and return the sum total:

```javascript title="Reference instance values"
const formData = {{ listViewName.instanceValues }}
const sum = formData.reduce((sum, data) => sum += data.numberInput1, 0)
return sum
```

:::tip Reset or clear instance values

Use `resetInstanceValues()` or `clearInstanceValues()` to reset or clear input values for a List View or Grid View component anywhere in the app. 

:::

import Appearance from "/docs/_shared/_appearance.mdx";

You can customize the overall appearance of repeatable components. Select the component and modify appearance settings like height, layout type, etc.

### Height configuration

Retool recommends using a fixed height for List View cmoponentss. However, you might use auto height when your dataset is less than 25 items or when fixed heights don't otherwise fit your use case. For the latter, Retool recommends using the auto height setting with server side pagination. This requires some additional code to function.

For example, you can use a [ transformer](../../../queries/guides/transformers.mdx) and a [Page Input](../../reference/components/navigation/page-input.mdx) component to return only a subset of values from your data source.

```javascript
const currentPage = {{ pageInput1.value }} - 1
const pageSize = 5
const pageStart = currentPage * pageSize
const pageEnd = pageStart + pageSize

return {{filteredTableData.value}}.slice(pageStart, pageEnd)
```

After you set the List View's data source to the transformer value, you add a **Page Input** component. Page Input components include a **Page count** value that you can set manually, or you can write JavaScript to display the page count dynamically. For example, `{{Math.ceil(filteredTableData.value.length / 5)}}` divides the number of items returned to calculate the page count where each page contains five items. See the demo below for a walkthrough.

## Nest repeatable components

You can nest a repeatable component within another repeatable component. This nesting dynamically generates UI elements based on multidimensional arrays and tree-like data structures—for example, org charts or threaded comments. Nested repeatable components support up to three levels of depth and can also reference nested components using `componentName.item`.

### Access items via namespace

Each List View can access its items and those of its parent and child using namespaces. For example, imagine the following set of nested List Views:

```
listView1
  listView2
    listView3
```

In this example:

- `listView1` can access its item via `item` or `listView1.item`.
- `listView2` can access its item via `item` or `listView2.item`. It can access its parent's item via `listView1.item`.
- `listView3` can access its item via `item` or `listView3.item`. It can access its ancestor's item via `listView1.item` and `listView2.item`.

### Reference nested components

You can reference nested components from other nested components within the same repeatable instance (e.g., `{{ componentName.value }}`). Nested components cannot be referenced outside of a given repeatable. If you need to reference the source data of a list item, you can reference the `data` or `instanceValues` of List View. 

### Demo nested List View

The following demo app uses two List View components. The first contains the teams: Engineering, Marketing, and Sales. The second is nested inside the first and contains the team members.

The `transformedDataJS` and `transformedDataSql` queries convert `sampleData` into objects that you can use in a nested List View.

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

  

  Create a JavaScript query named `sampleData` with the following:

```js title="sampleData"
return {
  name: ["Bob", "Kate", "Sarah", "Ali", "Joe", "Lisa", "Lenny"],
  team: [
    "Engineering",
    "Engineering",
    "Marketing",
    "Sales",
    "Engineering",
    "Sales",
    "Marketing",
  ],
};
```

  
  

  Create a transformer named `transformedDataJS` with the following:

```js title="transformedDataJS"
function aggregateSampleData() {
  const teams = _.uniq({{ sampleData.data.team }});
  const aggregated = teams.map(team => ({
    team,
    members: {{ sampleData.data.name }}.filter(name => 
      {{ sampleData.data.team }}[{{ sampleData.data.name }}.indexOf(name)] === team
    )
  }));
  return aggregated;
}

return aggregateSampleData();
```

  
  

  Create a Query JSON with SQL resource query named `transformedDataSQL` with the following:

```sql title="transformedDataSQL
select team, array(name) as members from {{sampleData.data}} group by team
```

  

To configure the demo app, set the parent List View component to use the `transformedDataJs` transformer as its data source. Set the **Value** of the container title to `{{ item.team }}`, which displays the team names. Set the nested List View's data source to `{{ item.members }}`, and set the value of the container title to `{{ item }`, which displays the members of each team. 

You could also transform the data with SQL instead. The demo shows an additional container view that uses `transformedDataSQL` as the data source.

Click through the following Arcade to view the configuration process.

---

## App error reporting and observability

import Observability from "../../../_shared/_observability.mdx";
import Errors from "../../../_partials/_app-errors.mdx";
import Filtering from "../../../_shared/_filtering-routing.mdx";

---

## Observability



---

## App performance monitoring

Use Retool's performance monitoring integration to send page load and query traces to Datadog or Sentry. Once enabled, you can view detailed performance information that helps provide context on potential performance issues on which you can improve.

Queries and page loads that occur while editing an app are not reported.

## 1. Configure observability provider

Perform the following steps to configure your chosen observability provider.

To configure Datadog:

1. [Create a Datadog pipeline](https://docs.datadoghq.com/logs/log_configuration/pipelines/?tab=source#create-a-pipeline) to consume traces. Retool spans will stream from `service:retool_performance_monitoring`.
2. [Create a Datadog API key](https://docs.datadoghq.com/account_management/api-app-keys/) to use in the next step. Note your organization's [Datadog Site](https://docs.datadoghq.com/getting_started/site).
3. Contact your Datadog account manager for access to the [Datadog OTLP Traces Intake Endpoint](https://docs.datadoghq.com/opentelemetry/setup/intake_endpoint/otlp_traces/?tab=javascript), which is in preview.

To configure Sentry:

1. [Create a Sentry project](https://docs.sentry.io/product/sentry-basics/integrate-frontend/create-new-project/) for Retool performance monitoring.
2. Navigate to the Client Keys (DSN) section of your Sentry project's settings. Copy the DSN key to use in the next step.

## 2. Connect providers to Retool

Next, configure your Retool organization to connect to your observability provider. You can configure the connection by either:

- Navigating to **Settings > Observability**.
- Using the [Retool API](../../../api/index.mdx) to programmatically configure observability provider connections.

Configure the **API key** setting with the Datadog API key you created in the previous step. Make sure you specify the correct [Datadog Site](https://docs.datadoghq.com/getting_started/site)

Configure the **DSN key** setting with the Sentry DSN key you created in the previous step.

## Traces

Retool sends traces to Sentry and Datadog, where they appear in the form of a flame graph. Traces are primarily made up of query spans. A query span includes raw query duration and the time that Retool takes to process the result and update the app model. Child spans are included only if they take longer than 10 ms.

- For resource queries, the raw query duration measures the time spent retrieving the result from an external service.
- For JavaScript queries, the raw query duration measures the time spent executing the code (including waiting on async functions called from JavaScript).

Refer to the [Query best practices documentation](../../../queries/concepts/best-practices.mdx) for more information on how to optimize your queries. Retool provides traces in the following categories:

- [Page initialization](#page-initialization)
- [Page navigation](#page-navigation)
- [User interaction](#user-interaction)

### Page initialization

Page initialization traces show how your app performs from initial page load until all initialization queries are completed. Page initialization is broken down into the following metrics:

- **Init:** Time from when the app is opened to when all queries that were triggered on load have completed or the end of Time to Productivity, whichever is longest.
- **Time to First Query (TTFQ):** Time from when the app is opened to when the first query is run. Can be affected by app size, number of plugins, and complexity of custom Javascript.
- **Time to Productivity (TTP):** Time from when the first query is run to when the first [long task](https://developer.mozilla.org/en-US/docs/Glossary/Long_task) (longer than 50 ms) has been completed. This is a proxy for when the app is ready to interact.

The rest of the span shows traces of initialization queries and any dependent queries.

### Page navigation

Page navigation traces show how your app performs when switching pages. Page navigation is broken down into the following metrics:

- **Time to First Query (TTFQ):** Time from when the user initiates a page transition to when the first query on the new page runs.
- **updatePreloadedJS:** Time to run the preloaded JS of the items on the new page. Subset of TTFQ.
- **batchedUpdateTemplate:** Time to load the components on the page. Subset of TTFQ.
- **Time to Productivity (TTP):** Time from when the first query is run to when the first [long task](https://developer.mozilla.org/en-US/docs/Glossary/Long_task) (longer than 50 ms) has been completed. This is a proxy for when the page is ready to interact.

This trace also includes the `previousPage` and `currentPage` attributes, which help identify the pages that the user navigated between.

### User interaction

User interaction traces are triggered when a user performs an [action](../../reference/event-handlers.mdx), such as clicking a Button or typing into a Text Input, that triggers query runs.

## Query subspans

_Query subspans_ are portions of the query run that show a breakdown of what the different actions Retool takes when executing a query.

| Metric            | Definition                                                                                                                                                                         |
| ----------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Prepare           | Measures the time to calculate all query inputs, format them, and send requests to the Retool backend.                                                                             |
| Backend           | For resource queries only. Measures the time to execute the query and transfer data to and from the Retool backend. This usually makes up the majority of the query duration.      |
| Response handling | Measures the time to handle the raw query response by downloading a file containing query data, or uploading a file to a cloud provider (as in S3 and GCS queries).                |
| Frontend          | For JavaScript queries, parentWindow queries, and Query JSON with SQL. Measures the duration of the JavaScript function. This usually makes up the majority of the query duration. |
| Transformer       | If the query transforms data, measures the time to transform the data.                                                                                                             |
| Post-processing   | Measures the time for Retool to process the data and update the app state.                                                                                                         |

## Tags

Retool provides tags on traces and individual spans to provide additional context around the conditions that generated a specific measurement.

### Trace tags

| Tag              | Definition                               | Example                                                                      |
| ---------------- | ---------------------------------------- | ---------------------------------------------------------------------------- |
| `appName`        | The name of the app.                     | `Pets`                                                                       |
| `appUuid`        | The app identifier.                      | `16423e12-eef4-11ef-b170-eb7362451ab0`                                       |
| `browser`        | The browser type.                        | `chrome`                                                                     |
| `browserVersion` | The browser version.                     | `133.0.0`                                                                    |
| `environment`    | The app environment.                     | `production`                                                                 |
| `os`             | The host operating system.               | `Mac OS`                                                                     |
| `release`        | The Retool version.                      | `3.165.0`                                                                    |
| `traceType`      | The type of action the trace represents. | `init`                                                                       |
| `url`            | The page URL.                            | `http://localhost:3000/apps/16423e12-eef4-11ef-b170-eb7362451ab0/Pets/page1` |
| `user`           | The user info.                           | `username:Alex Wang`                                                         |
| `viewMode`       | The app view mode.                       | `presentation`                                                               |

### Span tags

| Tag                  | Context                                                 | Example                                |
| -------------------- | ------------------------------------------------------- | -------------------------------------- |
| `appName`            | The name of the app.                                    | `Store Manager`                        |
| `appTemplatePlugins` | The number of components.                               | `22` (number)                          |
| `currentPage`        | The current page.                                       | `franchises`                           |
| `dbconnectortime`    | The time to execute resource on backend.                | `600.00ms`                             |
| `isEmbedded`         | Whether the app is embedded.                            | `false`                                |
| `isFirstPageLoad`    | Whether the user navigated to the page directly.        | `true`                                 |
| `javaScriptLinks`    | The number of pre-loaded JS queries.                    | `3` (number)                           |
| `operation`          | The type of action the span represents.                 | `pageload`                             |
| `previousPage`       | The previous page.                                      | `home`                                 |
| `queryId`            | The query identifier.                                   | `dogAPI`                               |
| `queryParams`        | The additional query parameters.                        | `{}`                                   |
| `resourceId`         | The resource identifier.                                | `92c3cbec-bf16-4872-a859-2a8975dd4cf3` |
| `resourceType`       | The type of resource.                                   | `restapi`                              |
| `responsesize`       | The query response size.                                | `3.1 KiB`                              |
| `servedFromCache`    | Whether the result was served from a cache.             | `false`                                |
| `status`             | The query completion status.                            | `Success`                              |
| `traceType`          | The type of action the trace represents.                | `init`                                 |
| `truncated`          | Whether the trace ended before the span could complete. | `false`                                |

## Troubleshooting performance monitoring metrics

Use the recommendations in this section to address issues that you identify with your app performance. Refer to the [web app best practices](../../concepts/best-practices.mdx) and [query best practices](../../../queries/concepts/best-practices.mdx) guides for more general recommendations.

### Time to First Query (TTFQ)

Most of the TTFQ value can be attributed to Retool's initialization process, but there are some areas where the app itself can affect load times. To improve your TTFQ metric, Retool recommends investigating the following spans:

| Span                      | Recommendations                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| ------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `generateDependencyGraph` | This reflects how long it took for Retool to initialize the app’s [dependency graph](../../quickstart.mdx#connect-the-interface-and-code-together). If this span is long, consider reducing the number of app plugins across all pages. You can also simplify complex and deep dependency chains by pulling logic from components into JavaScript queries, calculating iterative values only once, and removing nested modules and containers.Complex [modules](../layout-structure/modules.mdx) should be used sparingly as they can quickly bloat the dependency graph. It is better to use a module once and populate the data dynamically rather than reusing a module multiple times with different data. |
| `fetchScripts`            | This reflects the time spent running your org’s [pre-loaded JavaScript](../../../queries/guides/javascript/custom.mdx). If this span is long, consider reducing complexity or removing unnecessary functions in pre-loaded JavaScript.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |

### Time to Productivity (TTP)

To improve your TTP metric, Retool recommends investigating the following:

- **Identify the bottleneck query:** Look for the query or query chain in the flamegraph that extends TTP the furthest. Reducing the run time of this query or its downstream events will shorten TTP.
- **Find opportunities to parallelize queries:** If a chain of queries is extending TTP, consider re-architecting the app to run more queries in parallel.

### Query run times

To improve your query run times, Retool recommends investigating the following:

- **Consider whether the query needed to run:** By default, many queries run on page load or when referenced values change. If the query was not needed at the time it ran, you could modify your query’s [run behavior](../../../queries/guides/run-behavior.mdx) to be more controlled.
- **Use the run time breakdown:** If a lot of time is spent on the backend, this suggests the query itself needs to be more performant. If a lot of time is spent on the frontend, this suggests that the dependencies downstream of the query need to be simplified.
- **Look at query response size:** A large payload slows down both backend and frontend processing. Modify the query or use pagination to reduce response size.
- **Check the servedFromCache tag:** If the query hasn’t been cached yet and the app doesn’t need immediate data updates, consider [caching the query](../../../queries/concepts/caching.mdx).

---

## Native app testing

Use native testing to create, edit, and run tests from within the **Code** tab of the app IDE. Use this guide to learn more about native testing and how to use it to ensure that your app runs as expected in any scenario.

## Create tests

In the **Tests** section of the **Code** tab, click  to create a new test. Name your test, and choose the method that you want to use:

- **Manual**: Add an empty test and configure each step manually.
- **Record**: Record interactions with your app and automatically generate a test based on your actions.

### Record tests

Retool's test recording mechanism enables you to write tests more quickly than you could from scratch. The recording works by capturing your activity in the editor and translating that into a test.

Use the **Record** button to begin a recording. Start a recording at any point where you want to validate behavior. Each recording automatically captures the app state at the time the recording starts, so you don't need to include setup steps unless you wish to have tests for those events. 

:::note

When a recording is running, the Retool editor behaves the same way it would if you were manually testing it. Be sure that any actions you take during the recording are safe for your app and data.

:::

As you record, you’ll see the actions that Retool captures on the left sidebar. This gives you an indication of how long the generated test will be.

Click **Stop** to conclude the recording. Retool automatically creates a test based on the events that occurred during the recording. You may edit any generated test post-recording so that it is most useful to you.

Each test runs in isolation, and doesn’t make network calls. This means you do not need to worry about any live resources being run or app state being changed when you run tests. This also means you do not need to write any “tear down” logic for your tests.

In order to ensure a good recording output, use the following best practices:

- Do not start a recording while the app has queries in progress.
- Wait for queries to complete before ending a recording.

## Test composition

Each _test_ is composed of a series of _steps_ that are run together to represent a series of user actions and resulting changes to the app state.

You can edit any part of a test, including the following:

- Rename a test by double clicking on its name.
- Edit the steps executed in a test by clicking the  icon next to a step.
- Delete a step from a test by clicking its  icon. 
- Delete an entire test by hovering over the name and clicking the  icon.

Changes are autosaved.

### Global app state

The first step in each test is the **Global app state**. This step is made up of a set of _preconditions_, which define the app state before you started the test.

You can edit preconditions in the following ways:

- Add preconditions by clicking the  icon at the top of the preconditions list.
- Remove preconditions by hovering over the name and clicking the  icon.
- Edit precondition values by clicking the precondition name and opening up the value field. You can type directly in the value field to change it.

### Steps

Each step corresponds with an action either directly taken by a user or indirectly triggered by their behavior. Click the  icon to add a new step. You can test the following actions:

- **Component event trigger**: Configure the **Component** and **Event** that you want to trigger.
- **Resource query run**: Configure the **Component** and **Event** that you want to trigger.
- **JS query run**: Configure the **Component** and **Event** that you want to trigger.
- **Value change**: Configure the **Component**, **Field**, and **Value** that you want to change.

Each step is tested using the validation of _assertions_ and _mocks_.

#### Assertions

_Assertions_ are statements that evaluate as `true` once the original action in the step is complete. For example, a **Resource query run** action might result in updated component or variable values, so an assertion would represent the updated value.

If one or more assertions evaluate as `false`, the step fails.

You can create the following types of assertions:

- **Custom**: A custom assertion using the [Jest testing framework](https://jestjs.io/docs/expect).
- **Model update**: An update to the app state.
- **Run query**: A query was triggered.
- **Utils API**: A method from the [Utils API](../../../queries/reference/libraries/utils.mdx) was called.

You can edit assertions in the following ways:

- Add an assertion by clicking the  button at the top of the assertions list.
- Edit an assertion by changing dropdown values or text input values.
- Delete an assertion by hovering over the assertion and clicking the  icon on the right side.
- Write an assertion using the [JEST framework](https://jestjs.io/docs/expect) by creating a **Custom** assertion from the  dropdown options.

#### Mocks

_Query mocks_ represent any network calls that are run as a result of user action. When you record a test, these calls are executed. During any subsequent test runs, these calls are mocked in order to prevent changes to your data.

You can edit query mocks in the following ways:

- Add query mocks by clicking the  icon at the top of the **Mocks** list.
- Remove query mocks by hovering over the name and clicking the  icon.
- Edit mocked responses by clicking the query name and opening up the value field. You can type directly in the value field to change the mocked response.

## Run tests

Tests must be run manually. At the top of your list of steps, click **Run all** to run each step.

## Known limitations

This feature is still in development and there are several known limitations, which are listed below. If your app contains one of the known limitations or bugs, the recording will likely generate assertions that fail. Retool recommends deleting these assertions from your tests.

- Tests do not currently support mocking any calls to workflows from apps. Workflows will be called rather than being mocked if they are in a test flow.
- Tests do not currently support mocking for AI Action queries. Unexpected behavior may occur if AI queries are in a test flow.
- Tests may not evaluate correctly on apps that use certain beta features, such as app functions.
- Tests using non-deterministic Javascript (e.g. `Math.random`) are not currently supported.
- Date mocking is not available for `Date` calls in user-imported JS libraries. Retool recommends either using custom assertions to rewrite assertions so that they do not use dates, or using the `Date` library directly so that dates can be mocked.
- JS code that uses `fetch()` calls are not supported. Retool recommends re-writing `fetch()` calls to use a Retool query.
- Queries that are set to run periodically, and JS code that includes `setInterval` usage are not currently supported.
- Tests with deprecated or legacy components may cause unexpected behavior.
- Function calls to `window` from preloaded Javascript are not currently supported.
- For tests involving repeatable components (such as List Views), certain parts of generated assertions may not be editable post-recording.
- Tests do not support certain objects, such as localStorage.
- AlaSQL `NOW()` usage is not currently date-mocked.

## Source Control

Tests can also be protected with [Source Control](/source-control) and are stored alongside your app's code in the repository. Source Control support for tests is currently available on cloud instances and will be released for self-hosted instances in a future update.

## Best practices

Use the following best practices to ensure that Retool can successfully record tests on your app. In addition, refer to the [app best practices](../../concepts/best-practices.mdx) for general app building best practices that also apply to native app testing.

import LargeQueries from '/docs/_shared/_large-query-payload.mdx';

---

## Record app user sessions with Fullstory

Retool can record user behavior and interactions with apps using [Fullstory](https://fullstory.com/). When enabled, data about user interactions with apps are reported directly to Fullstory for you to review in detail. You can then analyze app analytics, evaluate impact, and review interactions with [session replay](https://www.fullstory.com/platform/session-replay/).

## Considerations

A [user session](https://help.fullstory.com/hc/en-us/articles/360020624614-What-defines-a-session-in-Fullstory) contains behavioral data, such as interactions, that occur with an app during a period of activity. Retool captures user session data for production apps that are accessed in user mode. This includes any external apps your organization may have.

A new session starts whenever a user launches an app. The session ends when a user leaves the app (such as closing the browser or navigating to a different page). Sessions may also end after a period of inactivity. Refer to [Fullstory's session documentation](https://help.fullstory.com/hc/en-us/articles/360020624614-What-defines-a-session-in-Fullstory) to learn more about session activities.

Retool automatically includes the user's email address for each user session. User-sensitive data is automatically [masked by Fullstory by default](https://help.fullstory.com/hc/en-us/articles/360044349073-Fullstory-Private-by-Default). If you need to display sensitive information in plain text within apps, Retool recommends using [configuration variables](../../../org-users/guides/configuration/config-vars.mdx) or [secrets](../../../self-hosted/guides/secrets/index.mdx) to prevent this information from being captured.

If required, you can also [configure data capture rules](https://help.fullstory.com/hc/en-us/articles/360020623574-How-do-I-protect-my-users-privacy-in-Fullstory#01F5DPW1AJSBTRBN12KFB54AQP) in Fullstory for specific elements using CSS selectors.

## 1. Enable user session recording

Gather the following information from your Fullstory account:

- A [Fullstory](https://app.fullstory.com/) organization. You can choose to create a new organization or use an existing one.
- Your Fullstory [Org ID](https://help.fullstory.com/hc/en-us/articles/360047075853-How-do-I-find-my-Fullstory-Org-Id). Retool uses this ID when sending user sessions to Fullstory.

Then, navigate to the [observability settings](https://login.retool.com/auth/login?source=docs&redirectOnLogin=settings/observability) in your organization and set the **Fullstory orgID**. Choose how you want to handle embedded apps. Once configured, Retool automatically captures and reports user sessions to Fullstory.

export function Fullstory() {
  return (
    
      
    
  )
}

### Embedded apps

import EmbeddedApps from "../../../_partials/_session-replay-embed.mdx";

## 2. Define session elements

Fullstory automatically tags certain Retool components to provide insights, such as elements clicked the most. You can define additional [elements](https://help.fullstory.com/hc/en-us/articles/360063014873-Naming-Elements-in-Fullstory) with Fullstory using [CSS selectors](../../concepts/custom-css.mdx) from Retool components.

---

## Write WebDriver tests

WebDriver tests are a great way to ensure that your Retool app is working as expected.
They can be run on your local machine, against a staging instance, or in a CI/CD pipeline against
your development branch to ensure that your app is working as expected.

The instance on which to run your tests depends on your use case. Since these tests use your
Retool resources, you should not run them against your production instance.

To write your tests in the same repository as your Retool app, put the tests and all WebDriver setup
code in a directory called `user/` in the root of your repository.

## Prerequisites

Before you get started, follow the setup instructions in the [Cypress](https://docs.cypress.io/app/get-started/install-cypress) or [Playwright](https://playwright.dev/docs/intro) documentation.

## Set up a testing account

Retool recommends that you configure a test account with limited permissions. Navigate to **Settings** > **User** in Retool to configure these permissions.

To use 2FA for this account, you need to use a library such as [otplib](https://www.npmjs.com/package/otplib) at the login step.

You might want to disable SSO for this account so that it's easier for your WebDriver to log in.
To use SSO, you need to use a library that works with your SSO provider to log in such as
[the Cypress Okta library](https://docs.cypress.io/guides/end-to-end-testing/okta-authentication).

:::info Billing

If you are concerned about increased costs associated with the additional test account, you can choose to run tests on an existing account.

:::

## Log in

1. Visit the login page at `.retool.com/auth/login` to programmatically log in. For self-hosted, use `/auth/login`.
2. Using your WebDriver, find the username and password inputs by placeholder text.
3. You may want to persist the session between tests so that you don't need to login for every test. See below for examples.

```js title="cypress/support/commands.js"
// Add Cypress Testing Library commands (https://testing-library.com/docs/cypress-testing-library/intro/)
import "@testing-library/cypress/add-commands";

Cypress.Commands.add("login", (username, password) => {
  cy.visit("http://localhost:3000/auth/login"); // Adjust this to your local app's login URL
  cy.get('input[placeholder="name@company.com"]').type(username); // Adjust the placeholder to match your username field
  cy.get('input[placeholder="*******************"]').type(password); // Adjust the placeholder to match your password field
  cy.contains(/^Sign in$/).click(); // Click the Sign in button
});

describe('Login Test', () => {
  it('should log in successfully and navigate to the home page', () => {
    cy.login("name@company.com", "password"); // Replace with actual username and password
    cy.url().should('eq', "http://localhost:3000/auth/login");
  });
});
```

In Playwright, you can configure a [global setup function](https://playwright.dev/docs/test-global-setup-teardown) to programmatically log in. The function should set an environment variable `process.env.COOKIES` containing the cookies from the authenticated session.

```ts title="playwright/global-setup.ts"
import { chromium } from "@playwright/test";

export default async function globalSetup() {
  const browser = await chromium.launch();
  const page = await browser.newPage();
  await page.goto("https:///auth/login");
  await page
    .getByPlaceholder("name@company.com")
    .fill(`${process.env.PLAYWRIGHT_USERNAME}`);
  await page
    .getByPlaceholder("*******************")
    .fill(`${process.env.PLAYWRIGHT_PASSWORD}`);
  await page.getByText(/^Sign in$/).click();
  await page.getByText("Welcome to Retool").click();
  const cookies = await page.context().cookies();
  process.env.COOKIES = JSON.stringify(cookies); // set this env var to store the authed page session
  await browser.close();
}
```

Then, create a [fixture](https://playwright.dev/docs/test-fixtures) that extends the base test by providing `authedPage`.

```ts title="playwright/fixtures/authedPage.ts"
import { test as base } from "@playwright/test";

export const test = base.extend({
  authedPage: async ({ page }, use) => {
    const deserializedCookies = process.env.COOKIES
      ? JSON.parse(process.env.COOKIES)
      : undefined;
    if (deserializedCookies) {
      await page.context().addCookies(deserializedCookies);
    }
    await use(page);
  },
});
```

This new `authedPage` can be used in multiple test files, and will be already logged into Retool.

```ts title="playwright/tests/example.spec.ts"
import { test } from "../fixtures/authedPage";

test("example test", async ({ authedPage }) => {
  authedPage.goto(url);
  // do things
});
```

:::warning Handling parallelization

In Playwright, tests run in parallel so having a single shared account for all tests may result in flakiness or unexpected behavior. You can use a single account for testing if you're positive your tests won't impact each other.

If your tests affect server-side state (for example, one test runs a query that updates a table, while another test checks the values of that table), or if you aren't sure that tests won't impact each other, then you may need multiple testing accounts. See Playwright's [documentation](https://playwright.dev/docs/auth#moderate-one-account-per-parallel-worker) for more information on setting up multiple testing accounts.

:::

## Writing E2E Tests

A solid Retool E2E test generally has 3 steps:

1. Visiting an app
2. Querying for elements on the page and interacting with them
3. Making assertions about the state of the app

Each of these steps map to Retool-specific code.

### 1. Visit an app

After setting up your WebDriver and [logging into your testing account](#log-in), navigate to the Retool app that you want to test.
We will use our [User Management app](https://docsdemos.retool.com/embedded/public/b4889e10-bead-4f30-876e-905e51b1616a) as an example.

To visit a page, we pass the URL we want to visit to the WebDriver-appropriate function.

```jsx title="cypress/e2e/userManagement.spec.cy.js"
describe("User Management", () => {
  it("opens the app", () => {
    cy.login("", "");
    cy.visit(
      "https://docsdemos.retool.com/embedded/public/b4889e10-bead-4f30-876e-905e51b1616a"
    );
  });
});
```

```ts title="playwright/tests/userManagement.spec.ts"
import { expect } from "@playwright/test";
import { test } from "../fixtures/authedPage";

test.describe("User Management", () => {
  test("opens the app", async ({ authedPage }) => {
    await authedPage.goto(
      "https://docsdemos.retool.com/embedded/public/b4889e10-bead-4f30-876e-905e51b1616a"
    );
  });
});
```

### 2: Query and interact with elements

Now that our app has loaded, we want to interact with it. Let's try to search for all the users with the name `'eva'`.

To type into the search bar, we need to query for it.

:::info Guidelines for querying elements

When deciding what selectors to use to find elements, we recommend
using [roles in the accessibility tree](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques#roles)
(like button, textbox) combined with label text as much as possible. Code-specific inputs like `data-testid` should only be used when
absolutely necessary.

Tests should ideally resemble how users interact with your app as much as possible. For more guidelines
on what types of queries to use, see [Testing Library's guidelines](https://testing-library.com/docs/queries/about#priority).

To make your testing experience smoother, we also highly recommend installing the appropriate
[Testing Library framework](https://testing-library.com/docs/cypress-testing-library/intro) for your
WebDriver.

:::

Using the element inspector, we can see that the accessibility role of the search bar is `"textbox"` and the name is `"Label"`.
Since the name `"Label"` is not very descriptive (Retool defaults to `"Label"` because there is no label text associated with
this text input), we can also use the placeholder text `"Search by name"` to make our query more specific.

We can use these attributes to query for our search bar.

```jsx title="cypress/e2e/userManagement.spec.cy.js"
describe("User Management", () => {
  it("opens the app", () => {
    cy.login("", "");
    cy.visit(
      "https://docsdemos.retool.com/embedded/public/b4889e10-bead-4f30-876e-905e51b1616a"
    );

    // findByRole is only available with Cypress Testing Library (https://testing-library.com/docs/cypress-testing-library/intro/)
    cy.findByRole("textbox", {
      name: /Label/,
      placeholder: /Search by name/,
    });
  });
});
```

```ts title="playwright/tests/userManagement.spec.ts"
import { expect } from "@playwright/test";
import { test } from "../fixtures/authedPage";

test.describe("User Management", () => {
  test("opens the app", async ({ authedPage }) => {
    await authedPage.goto(
      "https://docsdemos.retool.com/embedded/public/b4889e10-bead-4f30-876e-905e51b1616a"
    );
  });
  await authedPage.getByPlaceholder(/Search by name/);
});
```

:::tip Extend timeouts

If your WebDriver is timing out on element selector queries, it may be because your Retool app hasn't finished loading.
It can be useful to increase the default timeout for element selector queries to ensure they are running when your Retool
app fully loads.

```jsx
cy.findByRole("textbox", {
  name: /Label/,
  placeholder: /Search by name/,
  timeout: 10000,
});
```

```jsx
await authedPage
  .getByPlaceholder(/Search by name/)
  .fill("eva", { timeout: 5000 });
```

:::

Now that we have the search bar, we can find our users. Let's type `'eva'` in our search bar.

```jsx title="cypress/e2e/userManagement.spec.cy.js"
describe("User Management", () => {
  it("opens the app", () => {
    cy.login("", "");
    cy.visit(
      "https://docsdemos.retool.com/embedded/public/b4889e10-bead-4f30-876e-905e51b1616a"
    );

    cy.findByRole("textbox", {
      name: /Label/,
      placeholder: /Search by name/,
    }).type("eva");
  });
});
```

:::tip Force certain interactions

Because of how Retool handles overflow behavior, some interactions may throw errors warning that
an element is being covered by another element even when it is visible to users.

If your element is clearly visible, you can add `{force: true}` to these interactions to force Cypress to run.

```
element.click({ force: true });
```

:::

```ts title="playwright/tests/userManagement.spec.ts"
import { expect } from "@playwright/test";
import { test } from "../fixtures/authedPage";

test.describe("User Management", () => {
  test("opens the app", async ({ authedPage }) => {
    await authedPage.goto(
      "https://docsdemos.retool.com/embedded/public/b4889e10-bead-4f30-876e-905e51b1616a"
    );
  });
  await authedPage.getByPlaceholder(/Search by name/).fill("eva");
});
```

### 3. Add assertions

Finally, we can make assertions to ensure our app is working properly. In our example, we want to check that
when we search for `'eva'`, there are two people named `Eva` in the list and that they are the names we expect.

But how can we select all the elements within the users list? If we go into the element inspector, we see that the each card
has a title element that could be a good candidate for selection. The accessibility role is "heading" and the name is the name
of each individual person.

We could write a test that queries for all the `heading` roles that also contain the name `"Eva"`. We can then assert that
there should be two returned elements containing the names we expect: `"Eva Noyce"` and `"Eva Lu Ator"`.

:::danger

#### This is an example of what not to do

```jsx title="cypress/e2e/userManagement.spec.cy.js"
describe("User Management", () => {
  it("opens the app", () => {
    cy.login("", "");
    cy.visit(
      "https://docsdemos.retool.com/embedded/public/b4889e10-bead-4f30-876e-905e51b1616a"
    );

    cy.findByRole("textbox", {
      name: /Label/,
      placeholder: /Search by name/,
    }).type("eva");

    cy.findAllByRole("heading", { name: /Eva/i })
      .should("have.length", 2)
      .and("contain", "Eva Noyce")
      .and("contain", "Eva Lu Ator");
  });
});
```

```ts title="playwright/tests/userManagement.spec.ts"
import { expect } from "@playwright/test";
import { test } from "../fixtures/authedPage";

test.describe("User Management", () => {
  test("opens the app", async ({ authedPage }) => {
    await authedPage.goto(
      "https://docsdemos.retool.com/embedded/public/b4889e10-bead-4f30-876e-905e51b1616a"
    );
  });
  await authedPage.getByPlaceholder(/Search by name/).fill("eva");

  await expect(authedPage.getByRole("heading", { name: /Eva/i })).toHaveCount(
    2
  );
});
```

:::

However, there is a big problem with this test: **it passes even when the search bar doesn't work**!

This is because the test is specifically designed to look for user tiles that match the query `"Eva"`.
As long as those two users are correctly displayed, the test is considered successful, regardless of
any additional users shown in the list.

So how should we correctly write the assertions for this test?

We could simply find all elements with the role `heading`, but this requires us to filter out other `heading`
elements, like the `User Management` app title. More importantly, this makes our test more brittle, because if we
added another element with the `heading` role to our app, it would break.

The key is that we need to get the container that contains all the list elements. That way, we can query only within the
container for `heading` roles to get the users displayed by the search.

The list container has no accessibility roles or text associated with it, so we will need to use `data-testids` in our query.

To find the `data-testid` for the container, we need to know the name of the component in the Retool editor.
In our case, the component is named `listView1`.

Now, we can go into the element inspector and `ctrl-f` for our component name. We are looking for the `data-testid` field that corresponds
to the container and contains the name of our component, which in this case is `RetoolGrid:listView1`.

:::warning

#### Data test IDs

Always use the component name defined in the Retool editor, such as `RetoolGrid:myComponentName`, for `data-testid`. This is guaranteed by Retool to be unique. Other IDs may unexpectedly break when you change your app, For example, another `RetoolWidget:ListViewWidget2` `data-testid` is added when you add another ListView component.
:::

Now we can use our `data-testid` to get the list container element, and query by role within that to assert that there
are two `Eva`s displayed with the correct names.

```jsx title="cypress/e2e/userManagement.spec.cy.js"
describe("User Management", () => {
  it("opens the app", () => {
    cy.login("", "");
    cy.visit(
      "https://docsdemos.retool.com/embedded/public/b4889e10-bead-4f30-876e-905e51b1616a"
    );

    cy.findByRole("textbox", {
      name: /Label/,
      placeholder: /Search by name/,
    }).type("eva");

    cy.findByTestId("RetoolGrid:listView1")
      .findAllByRole("heading")
      .should("have.length", 2)
      .and("contain", "Eva Noyce")
      .and("contain", "Eva Lu Ator");
  });
});
```

```ts title="playwright/tests/userManagement.spec.ts"
import { expect } from "@playwright/test";
import { test } from "../fixtures/authedPage";

test.describe("User Management", () => {
  test("opens the app", async ({ authedPage }) => {
    await authedPage.goto(
      "https://docsdemos.retool.com/embedded/public/b4889e10-bead-4f30-876e-905e51b1616a"
    );
    await authedPage.getByPlaceholder(/Search by name/).fill("eva");

    const gridContainer = authedPage.getByTestId("RetoolGrid:listView1");

    await expect(gridContainer.getByRole("heading")).toHaveCount(2);
    await expect(gridContainer).toContainText("Eva Noyce");
    await expect(gridContainer).toContainText("Eva Lu Ator");
  });
});
```

Now our test works as expected!

:::warning

#### Assertions after Retool queries

If you make assertions on your Retool app after a Retool query is expected to run (for example,
the test clicks a button which runs a query to add a user to a table), you may need to add
wait calls after the query to ensure it completes.

There is currently no way to programmatically await Retool query completion.
:::

## Integrating with CI

Integrating with CI allows you to run your tests automatically on pull requests or pushes to your main branch. This ensures that
your app is always working as expected. You must use the same Retool instance for CI tests as you do for development.

### Run tests on Retool branches

You can run tests on branches created in Retool using the following URL format: `https://.retool.com/tree//apps/`.

```js
const branch = encodeURIComponent("..."); // get this from your CI environment
const baseUrl = "https://.retool.com";
let url = `${baseUrl}/tree/${branch}/apps/testable-app`; // your app URL in the branch preview
if (branch === "main") {
  url = `${baseUrl}/apps/7d2307d4-b4a2-11ee-bd77-73254f108a3d/testable-app`; // your app URL on preview mode in main
}
```

### Setting up your pipeline

Your CI pipeline will need to be able to access the Retool instance you are testing against. You will need to set up
your pipeline to install the appropriate WebDriver and run your tests.

---

## Getting started with avatars

Use the [Avatar](../../reference/components/presentation/avatar.mdx) and [Avatar Group](../../reference/components/presentation/avatar-group.mdx) components to display profile information, and configure [preloaded JavaScript libraries](../../../queries/quickstart.mdx#configure-custom-libraries) that enable you to retrieve profile images from [Gravatar](https://gravatar.com).

import WebPlayground from '/docs/_partials/_components/_web-playground.mdx';

## Features

Key features of avatar components include:

- Display profile image and details about a user or group of users.
- Access to the [Gravatar](https://gravatar.com) library.
- Event handlers triggered on click.
- Customizeable styles.

## Specify content options

The **Content** section of the Inspector contains settings that control the content of the component:

- **Image URL**: The avatar image that you want to display. This value defaults to `{{ current_user.profilePhotoUrl }}`.
- **Fallback icon**: The avatar icon content to use if the **Image URL** evaluates to `null`. Set a value dynamically, or select from Retool's library of icons.
- **Fallback text**: The text to include inside the avatar icon if **Image URL** and **Fallback icon** both evaluate to `null`. If this looks like a full name, Retool sets this to the user's initials. For example, if the value of **Fallback Text** is `Maya Chen`, Retool displays `MC` on the avatar. This value defaults to `{{ current_user.fullName }}` and has a maximum length of two characters.

For Avatar Group, provide the image URLs and fallback texts in an array format.

Use the **Add-ons** section to configure a label or tooltip to accompany the avatar. Avatar Group does not support labels.

### Reference current user information

You can reference the [current_user](../../reference/objects/current-user.mdx) object in any of the **Content** settings to retrieve details about the user currently interacting with an app. For instance, `{{ current_user.email }}` returns their email address. This can be useful for logging user actions, such as updating an order or applying a discount.

### Obtain profile images from Gravatar

[Gravatar](https://gravatar.com/) is a free service for hosting profile images that are associated with your email addresses. Websites can retrieve the avatar image using the [Gravatar API](https://en.gravatar.com/site/implement/images/) automatically without requiring users to upload profile images to multiple locations.

You can retrieve profile images from Gravatar using a URL and an MD5-hashed email address. You accomplish this by preloading the [blueimp-md5](https://github.com/blueimp/JavaScript-MD5) JavaScript library and using it to generate the hash.

#### Preload the MD5 JavaScript library

You can [preload JavaScript libraries](../../../queries/quickstart.mdx#preloaded-code-and-libraries) on a per-app basis or automatically for all apps within your organization. To preload a library within an app, open **App settings** and select **Libraries**.

Click **Add new** and enter the following URL: 

```
https://cdnjs.cloudflare.com/ajax/libs/blueimp-md5/2.19.0/js/md5.min.js
```

This URL is the minified, UMD build of the libarary, retrieved from the [blueimp-md5](https://cdnjs.com/libraries/blueimp-md5) listing. For more information, refer to [Preload custom JavaScript code and libraries](../../../queries/guides/javascript/custom.mdx).

#### Display the Gravatar profile image

Retrieve profile images using the URL `https://www.gravatar.com/avatar/[hashedEmail]`. You can generate the MD5 hash within the URL by calling `md5()` and providing an email address. For example, to obtain the current user's Gravatar profile image, use:

```
https://www.gravatar.com/avatar/{{ md5(current_user.email) }}
```

## Configure user interaction

:::note

Avatar Group does not support user interaction.

:::

The **Interaction** section of the Inspector contains [event handlers](../interaction-navigation/event-handlers.mdx), which listen for and handle interactions with your components. For the Avatar component, events trigger when users click the Avatar.

import Appearance from "/docs/_shared/_appearance.mdx";

## Use avatars in Tables

The Table component supports an **Avatar** column format, which is commonly used to identify users.

Set the **Mapped value** setting to the user's name. Optionally create a **Caption** add-on to include more user information.

Set the **Image** and **Fallback** text in the same way that you would do so for the Avatar component. Refer to [Specify content options](#specify-content-options) for more information.

---

## Getting started with the Calendar component

Use the [Calendar](../../reference/components/presentation/calendar.mdx) component to display dates and times on an interactive interface. Calendar uses the [FullCalendar](https://fullcalendar.io/docs/event-object) library.

import WebPlayground from '/docs/_partials/_components/_web-playground.mdx';

## Features

Key features of the Calendar component include:

- Calendar events manually listed or dynamically generated.
- Event handlers triggered on user interaction.
- Customizable format and style.

## Specify content options

The **Content** section of the Inspector contains settings that control the contents of the Calendar. Define the calendar events manually or dynamically by mapping to an array of data. Refer to the [Define option lists](../forms-inputs/option-lists.mdx) guide for more information.

### Use case: Integrate Google Calendar resource

You can show events from a Google Calendar on this component using [Retool's Google Calendar integration](../../../data-sources/guides/integrations/google/google-calendar.mdx). Use the instructions in this section to set up the Calendar component to display events from an external calendar.

:::note

The following method of integrating the Google Calendar API uses OAuth authentication and requires other Retool users to sign in to Google. Only users with whom you've shared a calendar will have access. 

:::

#### Create a Google Calendar resource

[Create a Google Calendar resource](../../../data-sources/guides/integrations/google/google-calendar.mdx). Authenticate the resource with an account that has access to the calendar that you want to use.

#### Create a resource query

Now you can update your app to use the Google Calendar data in the Calendar component.

Create a new resource query that accesses [your Google Calendar resource](#create-a-google-calendar-resource). Set the **Operation** to `GET /calendars/{calendarId}/events` to return a list of events for a given calendar. In the `calendarId` path parameter, enter the ID of your calendar, which you can find in the settings for your Google Calendar.

export function ResourceQuery() {
  return (
    
      
    
  )
}

#### Configure the Calendar component

Configure the following settings in the Inspector:

- **Mode**: Mapped
- **Data source**: `{{ getEvents.data.items }}`
- **Event id**: `{{ item.id }}`
- **Title**: `{{ item.summary }}`
- **Start**: `{{ item.start.date ? item.start.date : item.start.dateTime }}`
- **End**: `{{ item.end.date ? item.end.date : item.end.dateTime }}`
- **All day**: `{{ item.start.date }}`
- **Group id**: `{{ item.recurringEventId }}`

:::note

All-day events use `date` and time-bound events use `dateTime` to signify when the event begins and ends. This is why the ternary operation is necessary for the **Start** and **End** settings.

:::

### Display recurring events

To display recurring events, set **Group id** in the Inspector. Set the value of this setting to a shared identifier that is present for all recurring events. 

For Google Calendar, set **Group id** value to `{{ item.recurringEventId }}`. You also need to edit the `getEvents` query: Add a query parameter with a key of `showEvents` and a value of `true`. This ensures that the API returns each ocurrence as a separate event.

## Configure user interaction

The **Interaction** section of the Inspector contains settings that handle user interaction with the Calendar component.

The following settings are available in the **Interaction** section to configure the Calendar's behavior:

- **Default date**: The default date that the Calendar focuses on. Defaults to the current date.
- **Default view**: The default view of the Calendar. Possible options include **Month**, **Week**, **Day**, and **List**. Defaults to **Week**.
- **List type**: If the **Default view** is set to **List**, this setting controls how the events are categorized. Defaults to **Week**.
- **Advanced Setting** > **Timezone**: The timezone in which to display events. Defaults to local time.
- **Advanced Setting** > **Start week on**: The day of the week on which to begin the week. A number between 0 and 6, where 0 is Sunday and 6 is Saturday. Defaults to 0.

[Event handlers](../interaction-navigation/event-handlers.mdx) listen for and handle interactions with your components. The Calendar component supports **Create event**, **Click event**, **Change event**, and **Remove event** event handlers. Refer to the following sections for more information about internal user interaction with the calendar.

### Enable event creation

To enable users to create events, add a **Create event** event handler. This event triggers when a user selects a time interval on the Calendar interface. 

:::note

Retool immediately triggers **Create event** when a user completes a selection. There is no message appears to confirm or finalize the change.

:::

Selecting a time interval on the Calendar populates the values of the `selectedInterval` Calendar property. The following object shows an example:

```JSON
{ 
  "allDay": false,
  "end": "2025-03-27T10:00:00.000Z",
  "start": "2025-03-27T09:00:00.000Z"
}
```

Create a new query that accesses these properties and creates a new event on a connected calendar. Set the event handler's **Action** to trigger this query.

### Enable event changes

To enable users to change events, add a **Change event** event handler. This event triggers when a user selects and moves an existing event on the calendar. Moving an event populates the values of the `changeset` Calendar property. If the event is recurring, the `changeset` contains all of the recurrences. The following object shows an example `changeset`, which is identified by the event ID:

```JSON
{
   "6nt7smomc81s2jfsdsfvkkph88": {
      "allDay": false,
      "end": "2025-03-27T11:00:00.000Z",
      "id": "6nt7smomc81s2jfsdsfvkkph88",
      "start": "2025-03-27T10:00:00.000Z"
   }
}
```

Create a new query that accesses this property and edits an event on the connected calendar. Set the event handler's **Action** to trigger this query.

Changes to subsequent events overwrite the contents of `changeset`.

### Enable event deletion

To enable users to delete events, add a **Remove event** event handler. This event triggers when a user selects an existing event and presses Backspace or Delete.

Clicking an event populates the `selectedEvent` property. Create a new query that accesses the `selectedEvent.id` and deletes the event on the connected calendar. Set the event handler's **Action** to trigger this query.

import Appearance from "/docs/_shared/_appearance.mdx";

Click **•••** to open the **Advanced Settings** of the **Appearance** section to edit other settings, such as **Use 24 hour time**, **Show event times**, and **Show all-day slot**.

---

## Reference dates and times in components

You can reference a configured date and time in various components, preserving the user's selected time zone.

import Components from '/docs/_shared/_dates-in-components.mdx';

---

## Getting started with embedded media

Use embedded media components in your app to include content, via URL or upload, with which viewers can view and interact. Retool provides the following components:

- [PDF](../../reference/components/presentation/pdf.mdx), which enables you to embed a PDF via URL, uploaded file, or JavaScript object.
- [QR Code](../../reference/components/presentation/qr-code.mdx), which generates a QR code automatically based on a URL.
- [Video](../../reference/components/presentation/video.mdx), which embeds a video from popular video services.

import WebPlayground from '/docs/_partials/_components/_web-playground.mdx';

## Features

Key features of embedded media components include:

- Add-ons to provide users with additional information about the component via tooltips and top bars.
- Flexible content options for PDF components.
- Event handlers triggered on click, and playback settings for Video components.
- Customizeable styles.

## Specify content options

The **Content** section of the Inspector contains settings that control the content of the component. Use this section to define the source of your embedded content.

Use one of the following **PDF source** options to identify your PDF:

- **URL**: A publicly-accessible URL for your PDF.
- **Storage**: A file that you can upload from your computer. Uploaded files are stored using Retool Storage.
- **JS**: A file object, usually the output of a query.

:::note

When using a URL, the PDF component could display a **PDF could not be loaded** error, and the browser console displays a CORS error. This usually occurs because your PDF is hosted on another server and doesn't have the [appropriate CORS headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS). There are several solutions to resolve this error:

- Upload the file to Retool Storage and use the **Storage** option instead.
- If you host the PDF, update the `Access-Control-Allow-Origin` header to include `https://.retool.com`.
- Create a REST API query that retrieves the PDF URL. In the PDF component, set the **File URL** to `{{ query1.data.base64 }}`.

:::

The **Add-ons** setting defines features that you can add to the component, like a tooltip.

The PDF component includes a **Top bar** add-on that is enabled by default. You can add a **Rotate button** and **Title** that are displayed alongside the page and download controls.

Enter the URL that you want your QR Code to represent in the **Value** setting. Retool automatically generates a QR code for you based on the URL.

The **Add-ons** setting defines features that you can add to the component, like a tooltip.

Enter the URL for your video in the **Video URL** setting. Retool supports popular video players, including YouTube and Vimeo, as well as direct links to video file types commonly supported by browsers.

To embed YouTube Shorts using the Video component, use the following URL format: `https://www.youtube.com/embed/{identifier_string}`, where `identifier_string` is the identifier at the end of the YouTube Shorts URL.

The **Add-ons** setting defines features that you can add to the component, like a tooltip.

## Configure user interaction

The PDF and QR Code components do not enable any user interaction. 

:::note

Additionally, PDF does not support interactive elements, such as links or form filling. To retain PDF interactivity, consider using an [IFrame](../../reference/components/custom/iframe.mdx) to embed the PDF directly from a URL.

:::

The Video component includes an **Interaction** section in the Inspector, which contains settings that control user interaction. Use **[event handlers](../interaction-navigation/event-handlers.mdx)** to listen for and handle interactions with the Video component, including playing, pausing, loading, or ending the video.

Utilize the other settings—**Autoplay**, **Loop**, **Volume**, and **Playback rate**—to control the behavior of the video.

import Appearance from "/docs/_shared/_appearance.mdx";

---

## Getting started with icons

import Shared from '/docs/_shared/_icons.mdx';

---

## Getting started with images

You can display images in Retool apps in a variety of ways. Multiple components support images and can support different methods for providing an image source.

Add images with the following components:

- [Image](../../reference/components/presentation/image.mdx)
- [Circular Image](../../reference/components/presentation/circular-image.mdx)
- [Image Grid](../../reference/components/presentation/image-grid.mdx)
- [Bounding Box](../../reference/components/special-inputs/bounding-box.mdx)

import WebPlayground from '/docs/_partials/_components/_web-playground.mdx';

## Features

Key features of image components include:

- The option to provide an image from URL, Base64 string, Retool Storage, or JavaScript file object.
- Event handlers triggered on image click.
- Style configuration.
- Interactive and customizeable annotations through the Bounding Box component.

## Specify content options

For each Image or Circular image, you can provide a URL, Base64 string, Retool Storage object, or JavaScript image object.

Image Grid enables you to manually [display images from URL or Base64](#display-images-from-url-or-base64), or you can dynamically map images from a data source. Refer to [Define option lists](../forms-inputs/option-lists.mdx) for more on mapping data.

:::note

If you are using [Source Control](../../../source-control/index.mdx), large images uploaded to the Image component are _not_ committed and stored in Source Control in order to reduce file size and adhere to industry standard best practices. Instead, Retool recommends hosting the image on a public URL and using the **URL** option for the image source.

:::

### Display images from URL or Base64

For Image and Circular Image, set the **Image source** setting to **URL**  to reference an image via URL or Base64 string. You can use the direct string, or reference it using JavaScript with embedded expressions. For example, if you're working with a Table and you want to reference an image in the selected row, you could use `{{ table1.selectedRow.image }}` as the image source.

For Image Grid in **Manual** mode, click each image and add the URL or string to the **Source** field.

### Display images from Retool Storage

For Image and Circular Image, set the **Image source** setting to **Storage** to reference a file from [Retool Storage](../../../data-sources/quickstarts/retool-storage.mdx).

Select a file that already exists in Retool Storage, or upload a `bmp`, `gif`, `jpg`, `png`, `svg`, or `webp` file directly from the Inspector. Uploaded files are added to Retool Storage.

export function RetoolStorageImage() {
  return (
    
      
    
  )
}

### Display images with JavaScript

For Image and Circular Image, set **Image source** to **JS** to reference a hard-coded JavaScript file object or the output of a query.

The file object must have the following schema:

```json
{
  data: "image/*",
  sizeBytes: 30000,
  name: "sample image",
  base64Data: "iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAIAAAD/gAIDAAABYElEQVR4nOzSoU3cARyG4bvm79oBmtSermlS17SiphNU1FQRHISwA4KEHVAIcIQJMKBBMQGSCwZFmOFNfo7nGeATb77l38GyGvLt8O/U1PmXP1NTz0c3U1MfpobeA7ECsQKxArECsQKxArECsQKxArECsQKxArECsQKxArECsQKxArECsQKxArECsYL11er/1NbLw3pqav92Z2rq+93e1JRnBWIFYgViBWIFYgViBWIFYgViBWIFYgViBWIFYgViBWIFYgViBWIFYgViBWIFYgXLr9cfU1vbp09TU78vTqemrjeXU1OeFYgViBWIFYgViBWIFYgViBWIFYgViBWIFYgViBWIFYgViBWIFYgViBWIFYgViBUs98dnU1tftx+npnZ/fp6aejzZTE15ViBWIFYgViBWIFYgViBWIFYgViBWIFYgViBWIFYgViBWIFYgViBWIFYgViBWIFbwFgAA//8hwRgJea5fggAAAABJRU5ErkJggg=="
}
```

## Configure user interaction

The **Interaction** section of the Inspector contains settings that control user interaction. Use [event handlers](../interaction-navigation/event-handlers.mdx) to listen for and handle clicks on each image.

:::note

For Image Grids in **Manual** mode, click each image to configure event handlers on the individual image.

:::

import Appearance from "/docs/_shared/_appearance.mdx";

### Resize images

Images scale to the size of the component. Click and drag a corner of the component to resize it.

You can resize [images displayed in other components](#display-images-in-other-components) using the `img` HTML tag by setting `width` and `height` values:

```html

```

You can also use percentages:

```html

```

Percentage values are evaluated based on the size of the Text or Table component used to display the image.

## Display images in other components

You can insert images into several other components, including Text and Table, using an HTML `img` tag.

### Display images in Text components

You can also display images in [Text components](../../reference/components/presentation/text.mdx) using an HTML `img` tag.

Set the `src` of the image tag to either a URL or a Base64 string. If you include a Base64-encoded string, prepend the `src` string with the following: `data:image/jpeg;base64,`.

You can also reference strings from elsewhere in your app using `{{ }}` embedded expressions. For example, `` pulls an image from `query1`, and prepends the string with `data:image/jpeg;base64,`.

### Display images in Table components

You can display images in [Table components](../../reference/components/data/table.mdx) using the HTML column type and the `img` HTML tag. Add data to your table and then set the column type to **HTML** on the column that you want to render images in. Use the **Mapped value** property to pass in the `img` tag and the image's source.

## Display an image with the Bounding Box component

The Bounding Box component has additional functionality beyond the basics of the other image components. The user can draw green, transparent boxes around certain areas of the image, categorize the boxes, and delete boxes.

In the **Content** section of the Inspector, identify the image using the **Image src URL** setting. Other image source types are not supported. Identify the **List of possible labels** as the possible categories for the bounding boxes, and the **Initial Bounding boxes** to set the defaults.

Bounding boxes are defined as an array of objects in the following format:

```JSON
  {
    "x": 364.33285687062585,
    "y": 455.1241526664781,
    "height": 234.01870447637899,
    "width": 460.11987944778207,
    "label": "Car"
  }
```

Once created, bounding boxes are stored in the `boundingBoxes` property.

The **Interaction** section of the Inspector contains settings that control user interaction. Use [event handlers](../interaction-navigation/event-handlers.mdx) to listen for and handle changes to the bounding boxes.

---

## Presentation and styling



---

## Getting started with Mapbox Map

import WebPlayground from '/docs/_partials/_components/_web-playground.mdx';

Use [Mapbox Map](../../reference/components/integrations/mapbox-map.mdx) to display points of interest on an embedded map using [MapBox](https://www.mapbox.com/). It supports custom markers using emoji and symbols, default coordinates and zoom level, and [GeoJSON](https://geojson.org/) to render custom shapes for highlighting locations.

## Features

Key features of Mapbox Map include:

- Display markers and objects on the map.
- Select default coordinates and zoom level.
- Configure interaction on viewport change, selection, and hover.
- Customize marker and object appearance.

## Specify content options

The **Content** section of the Inspector contains settings that control the content of the Mapbox Map. Use the **Latitude** and **Longitude** settings to define the default center of the map. Use this section to define the markers or shapes that you want to appear on the map.

:::note

You can display both markers and shapes at the same time, but you must use the **Points** setting for markers and the **GeoJSON** setting for lines and shapes.

:::

### Display markers

To display markers on the map, use the following settings:

- **Latitude field name** and **Longitude field name**, which define the object keys that Retool uses for the latitude and longitude value.
- **Points**, an array of points to render. Each point is represented by an object with keys that match those defined in **Latitude field name** and **Longitude field name**. 

For example, you could create an SQL query `getLocations` that returns all franchise locations in Texas. This table includes ten entries, each with a `latitude` and `longitude` value.

Add a Mapbox Map to the canvas, and set the **Points** value to `{{ formatDataAsArray(getLocations.data) }}`. This ensures that the data is formatted as an array and that you can set the points dynamically.

export function AddPoints() {
  return (
    
      
    
  )
}

You can also create a query that gets your current location information using the [getCurrentPosition()](../../../queries/reference/libraries/utils.mdx#method-getCurrentPosition) method, and use this query to populate your coordinates on the map. Note that your browser must have access to your location information in order to use this method.

### Display shapes

To display shapes, use the **GeoJSON** setting. Data must be formatted in GeoJSON format, in accordance with [RFC 7946](https://datatracker.ietf.org/doc/html/rfc7946). You can use the online tool [geojson.io](https://geojson.io/) to place lines or shapes on an interactive map and generate the corresponding JSON that is accepted by the **GeoJSON** setting.

The following example shows how you can use GeoJSON to create a polygon on the map:

```json
{
  "type": "FeatureCollection",
  "features": [
    {
      "type": "Feature",
      "properties": {},
      "geometry": {
        "coordinates": [
          [
            [
              -77.26840246337339,
              39.03015226809225
            ],
            [
              -77.26840246337339,
              38.75986554487136
            ],
            [
              -76.80535320479785,
              38.75986554487136
            ],
            [
              -76.80535320479785,
              39.03015226809225
            ],
            [
              -77.26840246337339,
              39.03015226809225
            ]
          ]
        ],
        "type": "Polygon"
      }
    }
  ]
}
```

## Configure user interaction

The **Interaction** section of the Inspector contains settings that control user interaction. Mapbox Map supports a series of event handlers that enable you to trigger a query on each occurrence. Choose an existing query to trigger, or create a new one.

For example, you could create a map that displays a marker for each franchise of your business, and you want to display the name of the franchise owner when you click on a point. Create a JavaScript query called `getDetails` that contains the code `return mapboxMap1.selectedPoint`.

Add a [Text](../../reference/components/presentation/text.mdx) component to the screen, and set the **Value** to `## {{ getDetails.data.manager_name }}`. Finally, update the Mapbox Map component so that **On point select** triggers `getDetails`.

export function MapboxEvent() {
  return (
    
      
    
  )
}

Alternatively, you can control the Mapbox Map component using the event handler of another component. For example, you can use a [Table](../../reference/components/data/table.mdx) event handler to set the center of the map based on the selected row.

## Customize appearance

You can customize the presentation of your component in the **Spacing** and **Appearance** sections of the Inspector. 

You can dynamically control the **Hidden** setting with a truthy value that evaluates to `true` or `false`. You can also control the `hidden` property for the component using the `.setHidden()` method from event handlers and JavaScript queries.

The **Zoom** setting defines the scale of the map by default. You can also set this to a dynamic value (such as the value of a [Slider](../../reference/components/number-inputs/slider.mdx)). Users can also zoom and manipulate the map themselves.

You can apply **GeoJSON Layer Styling** to your GeoJSON data, if applicable. GeoJSON uses CSS styles. Refer to the [Mapbox Style Specification](https://docs.mapbox.com/style-spec/guides/) for more information.

---

## Getting started with presentation components

Retool provides a variety of componenets that help you display information, alerts, and statuses. These components include:

- [Alert](../../reference/components/presentation/alert.mdx)
- [Progress Bar](../../reference/components/presentation/progress-bar.mdx) and [Progress Circle](../../reference/components/presentation/progress-circle.mdx)
- [Statistic](../../reference/components/presentation/statistic.mdx)
- [Status](../../reference/components/presentation/status.mdx)
- [Tags](../../reference/components/presentation/tags.mdx)
- [Text](../../reference/components/presentation/text.mdx)

import WebPlayground from '/docs/_partials/_components/_web-playground.mdx';

 

## Features

Key features of presentation components include:

- Dynamic values using embedded expressions.
- Event handlers to define interaction.
- Customizeable styles.

## Specify content options

The **Content** section of the Inspector contains settings that control the content of the component, including:

- **Value**.
- **Default value**.
- **Indeterminate**, which shows a loading state with unknown progress for Progress Bar and Progress Circle.
- **States**, which defines the list of possible values for Alert and Status.
- **Add-ons**, which provide additional informational elements such as tooltips or icons.

To set the possible values for Status and Tags, [define an option list](../forms-inputs/option-lists.mdx) either manually or by dynamically mapping an array of data. The states for Alerts must be defined manually.

## Configure user interaction

Progress Bar, Progress Circle, Status, and Text do not support user interaction.

Alert, Statistic, and Tags support user interaction. The **Interaction** section of the Inspector contains settings that control user interaction. Use **[event handlers](../interaction-navigation/event-handlers.mdx)** to listen for and handle interactions with your components.

:::note

Event handlers for the Tags component apply to all tags shown. Retool does not support individual event handlers for each tag.

:::

Alert has several options for user interaction. You can add an event handler that triggers when the user closes the Alert, or you can add a link—called an action—to the Alert that triggers when clicked. To do so, select the state that you want to change. Then click the **Action** add-on, and add an event handler.

export function AlertAction() {
  return (
    
      
    
  )
}

import Appearance from "/docs/_shared/_appearance.mdx";

---

## Design organization and app themes

You can create and manage themes from your organization's [Themes](https://login.retool.com/auth/login?source=docs&redirectOnLogin=settings/themes) settings, or create custom themes that apply to individual apps. Organization-level themes are only available on a Business or an Enterprise plan. Custom themes are available on all plans.

:::info

Organizations on the Enterprise plan can manage organization level themes using the [Retool API](../../../api/index.mdx) and can utilize [Source Control](../../../source-control/index.mdx) to track changes.

:::

## Create organization-level themes

Navigate to **Settings** > **Themes** to create an organization-level theme. Click **Create new** > **Theme** and enter a name. You can then select an existing Retool theme and primary color from which to start. Retool's template themes are optimized for high-contrast use.

The theme editor displays a live preview of your style options and how they apply to your apps. Style options are broken down into different sections in the **Theme** menu on the right.

:::info

Use cmd/ctrl + z to undo changes in the theme editor. Use cmd/ctrl + Shift + z to redo changes.

:::

### Define theme modes

Organization-level themes have the ability to contain several _modes_. Access the modes with the drop-down in the **Theme** menu. Retool can create a preset template for Light mode, Dark mode, or both.

Access the mode from within an app using `theme.setMode(‘modeName’, { persist: true })`. This method makes it easy to change modes based on user interaction—for example, you can create a Switch component that toggles between light and dark mode. The `persist` parameter maintains the mode selection for a user's subsequent sessions.

### Create colors

import Tokensvg from "/img/icons/token.svg";

The **Colors** section defines the primary and additional colors for your app. **User colors** are _tokens_ that can be reused throughout your apps. These tokens take the place of the secondary and tertiary colors in [app-level themes](#configure-app-level-themes).

:::tip

The [Retool Theme Generator](https://www.figma.com/community/plugin/1388634061939245347/retool-theme-generator) plug-in for Figma enables you to easily migrate variables to use in Retool themes. This tool eliminates the need for manually creating many user colors.

:::

To add new colors, click the **+** in the **User colors** section. Edit the name and hex value of your new color. Open the color settings, and select **Set value in all modes**.

Use the token icon  next to a **Core color** to map the value to a **User color**. Open the color settings, and select **Set value in all modes**.

### Apply typography settings

Use the **Typography** section of the theme editor to change the font style, size, and weight for your app. In the **User typography** section, define typography presets that can be reused as _tokens_ throughout your apps.

You can also add new fonts from Google Fonts or from a custom CSS file.

To add a custom font, click the **+** button in the **Fonts** section. Select the **Custom** tab, and enter your font information. The **Import URL** must be a link to a CSS file with at least one `@font-face` rule. Choose the font weights you want to include, and optionally set the font as the default.

For example, to use the [Patua One](https://fonts.google.com/specimen/Patua+One) font from Google:

1. Set the **Font family** to `Patua One`
2. Set the **Import URL** to `https://fonts.googleapis.com/css2?family=Patua+One`.

### Define metrics

Set any size requirements in the **Metrics** section of the theme editor. You can edit the default **Border radius** to be applied to components. You can also add new settings in the **User metrics** section, which are reused as _tokens_ throughout your apps.

### Add shadows

Use the **Shadows** section of the theme editor to create and edit shadows. You can use the **Default shadows**, or add a new shadow in the **User shadows** section. Shadows can be reused as _tokens_ throughout your apps.

:::note

Shadows are available for most, but not all components.

:::

Shadow values use [CSS box-shadow syntax](https://developer.mozilla.org/en-US/docs/Web/CSS/box-shadow). For example, `12px 12px 2px 1px rgba(0, 0, 255, .2)` creates the custom purple shadow in the following image.

To remove a shadow—in situations where you want to override a theme—set the value to `none`.

### Apply component-level theme overrides

To edit the settings for a component, select the component from the canvas or from the **Components** menu on the left. The **Theme** editor updates to show component-specific settings that override the organizational-level theme. For each of the settings, choose a custom value or a token.

## Configure app-level themes

:::note

App-level themes are available to users on all plans.

:::

Within an app, you can apply organization level themes or create a custom theme. Open the **App Settings** tab to get started. You can choose to apply an organization-level theme, or apply a custom theme for this app.

Any theme changes apply to the current app only, and you can't edit organizational level themes from within an app. Note that you can't define custom color tokens, font tokens, or metric tokens for a custom app theme.

---

## Getting started with the Timeline component

import Appearance from "/docs/_shared/_appearance.mdx";
import WebPlayground from '/docs/_partials/_components/_web-playground.mdx';

Use the [Timeline](../../reference/components/presentation/timeline.mdx) component when you want to display events in a Gantt chart format. This component is useful for project tracking, planning, and visualizing dates and date ranges.

## Features

Key features of the Timeline component include:

- Manually or dynamically define the events that appear.
- Configurable color, metadata, and tooltips for each event.
- Meta events and milestones to add to the Timeline.
- Event handlers triggered on click.
- Customizeable format and style of the Timeline. 

## Specify content options

The **Content** section of the Inspector contains settings that control the content of the Timeline, including the **Data source** and **Add-ons**.

### Define the data source

You can define the **Data source** as an array of data either manually or dynamically. To manually define the data, select **JavaScript** from the dropdown and manually enter your array. To dynamically define the data, select a query from the dropdown list. Refer to [Define option lists](../forms-inputs/option-lists.mdx) for more information about dynamically referencing arrays.

Next, define the mapped events for each `item` in your array:

- **ID**: The identifier for the event.
- **Title**: The title of the event. This is displayed on top of event ranges, and to the right of single-date events.
- **Start date**: The start date of the event. This value is `null` for single-date events.
- **End date**: The end date of the event.
- **Color**: The color of the event in the Timeline. You can manually set the color, or you can [reference a theme color](./themes.mdx#create-colors), such as `{{ theme.tertiary }}`.
- **Properties**: Any metadata that you want to associate with events, formatted as an object. Use properties to [group events](#create-groups). To expose all fields for grouping, set this value to `{{ item }}`.
- **Tooltip**: The format for a tooltip, displayed on hover. When this setting is left blank, the default tooltip format is `Start Date -> End Date (Duration)`.

### Define add-ons

Use the **Add-ons** setting to provide additional information about the Timeline.

#### Create groups

Use the **Grouping** add-on to organize events based on one of the values defined in the **Properties** setting. You can optionally define the event groups that you want to be displayed by default. Nested groups are supported, and you can reorder the groups to define which should be applied first. App users can also choose to maniupulate the grouping using the icon in the top right corner of the component.
  
export function Grouping() {
  return (
    
      
    
  )
}

 

#### Define meta events and milestones

You can define additional sets of events that appear on your Timeline using the **Meta Events** and **Milestones** add-ons.

Meta events appear in a separate section above the main Timeline. For example, you could use meta events to make note of when certain employees will be out of the office.

Milestones are single-date events that appear as vertical lines layered over the main Timeline. For example, you could use milestones to make note of certain important dates or accomplishments. The **Title** of milestones is displayed on hover.

Defining the data for meta events and milestones works similarly to [defining the data source](#define-the-data-source), but these add-ons do not support tooltip label changes or properties.

## Configure user interaction

The **Interaction** section of the Inspector contains [event handlers](../interaction-navigation/event-handlers.mdx), which listen for and handle interactions with your components. For the Timeline component, events trigger when users click the Timeline.

This section is also where you customize Timeline-specific settings, such as the **Timescale**, intervals, and initial date of the Timeline. Open the **Advanced** settings to adjust the month and day on which the quarter starts.

---

## Share data between app pages

Apps use global and per-page scopes for components, frames, and code.

- Globally scoped objects can be referenced across multiple pages. Retool continually evaluates globally scoped objects regardless of the page currently in view.
- Page-scoped objects can only be referenced within the same page. Retool only evaluates page-scoped objects when the page is currently being viewed.

If you need to share data between pages, you can use globally scoped variables, localStorage, or URL parameters.

## Share data using global variables

[Variables](../../queries/guides/store-temporary-data.mdx) temporarily store data for the duration of the user's app session. They can also include an optional initial value. 

To create a global variable, navigate to the Code tab and click **+ > Variable**. As the variable is globally scoped, you can update its value from any page using [event handlers](./interaction-navigation/event-handlers.mdx), or with the `setIn()` and `setValue()` [JavaScript methods](../../queries/reference/objects/variable.mdx#methods).

Store page data in a global variable.

You can then reference the global variable from any screen.

 
Reference a global variable in a page.

For example, you can use the Table component's **Double Click Row** event handler to store the selected row data in a global variable. You can then reference the global variable in another page, such as a component value.

If a user closes the tab, navigates away from the app, or opens the app in another tab, the variable reverts to its initial value.

## Store page data in localStorage

:::warning

localStorage does not encrypt data. Only use localStorage to store nonsensitive information. 

:::

[localStorage](../../queries/guides/store-temporary-data.mdx) temporarily stores data in the browser's localStorage. Unlike variables, localStorage is a persistent data store. Provided the user continues to use the same browser and has not cleared their browsing history or cache, data remains available.

Use [event handlers](./interaction-navigation/event-handlers.mdx) or the `setValue()` [JavaScript method](../../queries/reference/objects/localstorage.mdx#methods) to store data in localStorage. You can also clear app-specific data using `clear()`. 

## Append data as URL parameters

:::caution

Do not use URL parameters for sensitive information. URL parameters are plain text and often included when sharing URLs.

:::

You can configure URL query parameters on a per-page basis. As with [URL queries for single-page apps](../guides/app-management/customize-app-urls.mdx#configure-custom-url-query-parameters), pages can store values in the URL.

To use URL query parameters, select a page and then configure its **URL search params** and **URL hash params** key-value properties. You reference property values, such as `textInput1.value`, which dynamically updates the URL parameter. You can also access URL parameters for the page using `url`, such as configuring the default value of a component to the initial URL parameter value when launching the app.

Configure URL parameters.

---

## Retool Apps how-to guides

import Howto from '/docs/_partials/_doctypes/_howto.mdx';

:::tip Get started with web apps

If you are unfamiliar with Retool web apps and want to get started: 

- Read the [quickstart](./quickstart) to learn about the fundamental concepts.
- Follow a [tutorial](./tutorial/) to build your first web app.

:::

---

## Retool Apps documentation

Retool Apps enables you to quickly build and deploy web apps for your business. Connect APIs and databases, assemble user interfaces with drag-and-drop components, write queries that read and write data, and perform complex logic and transformations using JavaScript.

---

## Retool apps quickstart

import Image from '@site/src/components/Image';

This guide serves as an introduction to Retool apps. It covers many of the concepts and terminology you will come across as you build apps using the web-based IDE. After reading this page, you should have a good understanding of the fundamentals for building Retool apps.

import Browsers from '/docs/_shared/_supported-browsers.mdx';

## Create and edit apps with AI

Retool provides several features that use AI to help you create and edit Retool apps. The following mechanisms enable you to use AI as a development assistant:

- [Assist](./guides/assist/index.mdx) (currently in Public Beta): Use AI to generate or edit whole apps from within the [app IDE](./concepts/ide.mdx).
- [Ask AI](../queries/guides/ask.mdx): Use AI to write [JavaScript, SQL, or GraphQL queries](#read-and-write-data-using-queries). You can instruct Ask AI to generate a new query, edit a query, explain a query, or fix errors.

[Learn more](./concepts/ai.mdx) about the various AI-powered features that you can use in apps.
  
:::note

If you prefer not to use AI features, you can turn them off entirely in **Settings** > **Retool AI**.

:::

## Assemble the interface

A Retool app's user interface is comprised of components, pages, and frames. These interface elements function as objects with internal state.

- [Components](#components) are interface elements, such as a [text input field](./reference/components/text-inputs/text-input.mdx) or a [table](./reference/components/data/table.mdx), with which users interact.
- [Pages](#pages) are separate sections that contain their own code, frames, and components. Users navigate between pages which are often used for distinct use cases. For example, a customer support app might have separate pages to retrieve order information, check inventory, and process refunds.
- [Frames](#frames) are distinct areas of the canvas in which you add components. They provide you with flexible layout options for arranging your app's user interface. You can add frames to pages or use them globally.

Retool exposes properties, methods, and events with which you can interact. As you interact with components, their properties change. For example:

- Entering text into a [Text Input](./reference/components/text-inputs/text-input.mdx) component changes its `value` property value.
- Closing a [Drawer](./reference/frames/drawer.mdx) frame sets its `hidden` property value to `true`.

You also write code that interacts with data, transforms values, or controls behavior using JavaScript methods. For example:

- Use `setValue('Jenny Appleseed')` to set the `value` property value of a Text Input component to **Jenny Appleseed**.
- Use `setHidden(true)` to set the `hidden` property value of a Drawer frame to `true`.

### Components

You use Retool's drag-and-drop [component library](./reference/components/components.mdx) in the IDE to assemble and configure an app's UI. You position components anywhere on the canvas of a selected page, and can adjust their position and size.

### Pages

Retool only evaluates a page's objects when the page is currently in view. This allows for apps to serve multiple functions without impacting performance.

The **Pages** tab contains a list of pages within the app. The default page is the one that first loads when launching the app. You can explore and manage all pages, change the default page, import pages from apps, and view more details.

Explore pages.

Each page has a title and URL that you configure from the Inspector. The page URL is appended to the app URL and allows for deep-linking to specific pages. For example, a page with the URL of `customers` would be available at `https://example.retool.com/app/support-dashboard/customers`. Accessing the app using this URL would then bypass the default page.

Configure page settings.

The [Navigation](./reference/components/navigation/navigation.mdx) component, when added to an app with multiple pages, dynamically generates navigation items for each page. If you want to switch pages using another method, you can configure any event handler with the **Go to page** action, such as a button click.

The Header or Sidebar frames contain a Navigation component by default that's configured for page navigation when enabled in an app with multiple pages.

### Frames

import Frames from '/docs/_shared/_frames.mdx';

### Global and page scopes

Apps use global and per-page scopes for components, frames, and code.

- Globally scoped objects can be referenced across multiple pages. Retool continually evaluates globally scoped objects regardless of the page currently in view.
- Page-scoped objects can only be referenced within the same page. Retool only evaluates page-scoped objects when the page is currently being viewed.

#### Globally scoped objects

You can create **Global** code (e.g., resource queries or variables), which all pages can reference. Each page can interact with globally scoped code to trigger queries, set variable values, etc. For example, if you were building a customer support app then you could use a single globally scoped query to retrieve customer information rather than duplicate the same query across multiple pages.

You can drag code to either the **Global** or **Page** section in the **Code** pane to change its scope. You can also move code across pages using the **Move to page** contextual menu action.

The [Header](./concepts/ide.mdx#header-frame) and [Sidebar frame](./concepts/ide.mdx#sidebar-frame) are also globally scoped and persist across all pages. Any components within these frames inherit this behavior and are globally scoped. All other frames (e.g., Modal and Drawer) are page-scoped and only available within the app in which they reside.

export function Scopes() {
  return (
    
      
    
  )
}

All pages and their contents can reference globally scoped objects. Globally scoped objects, however, can only reference other globally scoped objects. For instance, a globally scoped query cannot reference a property for a component in a page.

#### Page-scoped objects

All code and components within a page are page-scoped, and cannot be referenced by other pages. If a page contains code or event handlers that would run on page load, these run whenever you switch to the page.

import SideBySide from '@site/docs/_partials/_side-by-side.mdx';

## Connect interface elements together

Many page, component, and frame properties are editable. You configure them in the IDE with either static values (`string`, `number`, `boolean`, `array`, and `object`) or reference other property values using `{{ }}` embedded expressions, similar to the use of [template literals](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals).

You reference property values using [dot notation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Property_accessors#dot_notation). In the following example, The **Default value** setting in the IDE references `{{table1.selectedRow.name}}`. As a result, `{{textInput1.value}}` always corresponds to the name from the selected table row.

  

  
  
  

The Text Input component references `{{table1.selectedRow.name}}` to display the selected user.

  

## Use JavaScript expressions for values

Retool performs [string interpolation](https://en.wikipedia.org/wiki/String_interpolation) and evaluates `{{ }}` embedded expressions as JavaScript. As a result, you can write JavaScript code—that evaluates and returns a value synchronously—almost anywhere. This enables you to dynamically set property values using transformations or conditional logic to build complex apps.

import Embedded from '/docs/_shared/_quickstarts/_embedded-expressions.mdx';

## Connect your data using resources

A resource is a saved set of user-configured properties that determines how Retool connects to a data source, such as a [PostgreSQL](../data-sources/guides/integrations/database/postgresql.mdx) database or [REST API](../data-sources/guides/integrations/api/rest.mdx). You create a resource for each data source you want to use with Retool, then write queries to interact with them.

Each resource has configuration options that Retool uses when interacting with a data source. This simplifies how you query data sources while ensuring access is secure.

When a resource query is run, Retool proxies the request to the data source, server-side, using the resource's configuration settings. This means only Retool directly connects to a data source, not your users.

## Read and write data using queries

A query is a piece of code you write to interact with a resource and perform CRUD operations. As with components, queries maintain an internal state and expose properties. Queries can also perform asynchronous actions and run simultaneously with other queries.

Queries are not part of an app's user interface. You reference the query's `data` property to read and display data in components for which users can interact. Queries can also reference component input values and write them back to the data source.

The Table component's **Data source** (`data`) property in the IDE is set to **query1**. Running the query retrieves the specified data in the query statement, which is then displayed in the table.

  

  
  
  

A resource query to retrieve data from a table.

The Table component's **Data source** is set to reference the resource query.

  

**query2** is set to update or create a record into the **sample_users** table. It uses a specified `id` to determine which record to update. Running the query updates or creates a record using the input values available in `{{form1.data}}`.

  

  
  
  

A GUI mode query to update or create a record.

  

## Connect the interface and code together

Retool maintains a dependency graph for each app. This represents all property values and where they're referenced. Whenever a property changes, all downstream references using embedded expressions automatically update. This is similar to how spreadsheet formulas work when referencing cell values; if a referenced value changes then the formula instantly updates its result.

The **Component tree** and **Code** panels contain the **Graph** pane. This visualizes the dependency graph for a selected component or query. You can use the graph to view the relationship between the selected component or query and its immediate dependents.

export function ArcadeGraph() {
  return (
    
      
    
  )
}

:::tip

Hover the cursor over the connecting points to display a tooltip with a list of dependencies and dependents.

:::

You can chain embedded expressions together by referencing values that also use embedded expressions. Any input value changes automatically propagate through the entire app. This makes it possible to build powerful applications with very few lines of code.

:::info Dependency cycles
The dependency graph enables Retool to prevent you from creating circular dependencies, where two or more properties rely on each other to function. If you attempt to reference values that rely on one another, the IDE displays a warning.

A circular dependency warning.

:::

The following example demonstrates how the dependency graph connects components and queries together within an app. The resource query references `{{textInput1.value}}` and runs automatically whenever this value changes. The table references `{{query1.data}}` and displays updated results in real-time.

  

  
  
  

  The resource query references `{{textInput1.value}}` and runs whenever it changes.
  

  

## Control and run queries with event handlers

You configure event handlers to perform actions whenever a specific event occurs, such as a button click or query error. There are numerous actions available, such as setting component values and triggering queries.

The following example uses an event handler to display a notification whenever a Saturday or Sunday is selected in the date input field.

  

  
  

The event handler shows an error notification when a date is selected, but only runs if the specified day is a weekend.

  

## Transform data using transformers

While you can use JavaScript within `{{ }}` embedded expressions, you may need to manipulate data and implement complex logic to produce values, such as filtering or joining data sets.

A [transformer](../queries/guides/transformers.mdx) is a reusable block of JavaScript. You reference property values using embedded expressions and the results of the transformation are output on the transformer's `value` property using a `return` statement.

The following example uses a transformer to split a list of names into first and last names. The Listbox component references `{{transformer1.value}}`, which provides an array of last names.

  

 
  
  

  The resource query runs whenever the limit is changed.
  

The transformer references `{{query1.data.name}}`, splits the full name, and returns the last name. It updates whenever the query data changes.

  

Transformers are maintained by the dependency graph and continually output a transformed value. If you make changes to any values in the dependency chain, the transformer automatically updates.

If you only need to transform query data, you can include transformation code directly in the query. The transformed data is then made available in the query's `data` property.

## Script apps with JavaScript

  

You can write JavaScript code to control app behavior, set property values, and more. Components and queries are globally scoped and include built-in methods to control their state. These methods can accept supported parameters, such as string or index values. In either case, you only need to use standard JavaScript notation, not `{{ }}` embedded expressions.

  
  

:::note JavaScript output
JavaScript queries can output data using a `return` statement.
:::

  

The following example adjusts the selected date by a specified number of days, then sets this as the value for the calendar.

  

  
  
  

The JavaScript code adjusts the selected date by the specified number of days, then uses `setValue()` to set the value of `calendarInput`.

  

## Embed content and build custom components

Retool's component library contains over 100 UI components, from input fields to image grids. For complex use cases that require UI components not currently provided, you can embed custom content or build a custom component. These components also have state and you can use `{{ }}` embedded expressions.

- [HTML](./reference/components/custom/html.mdx): A container for custom HTML and CSS code.
- [IFrame](./reference/components/custom/iframe.mdx): An embedded web page that supports permissions to allow or deny downloads, form submissions, microphone and camera access, and popups.
- [Custom Component Libraries](./guides/custom/custom-component-libraries/index.mdx): A library of custom-built, embedded components using React and TypeScript. Build once and then deploy into any app.

The following example demonstrates the HTML component.

  

  
  
  

HTML component example.

  

## Wrap up

Using these fundamental concepts, you can build complex web apps that:

- Contain polished user interfaces that can adapt to your needs.
- Dynamically reference values anywhere using dependency chains.
- Connect with almost any API and database to interact with your data.
- Perform actions using conditional logic in response to user events or script apps to control behavior.

The following example combines these concepts to create a user subscription dashboard that can filter, search, and edit users. Selecting a user in the table opens the Drawer frame with input fields prefilled with the selected row data.

---

## The Button Group component for Retool Apps

import MoreInfo from "./_more-info.mdx";

## Properties

## Methods

## Events

---

## The Button component for Retool Apps

import MoreInfo from "./_more-info.mdx";

## Properties

## Methods

## Events

---

## The Close Button component for Retool Apps

:::info Preset component

{frontMatter.sidebar_label} is a preset version of [Button](./button.mdx). It has been preconfigured with an icon.

:::

import MoreInfo from "./_more-info.mdx";

## Properties

## Methods

## Events

---

## The Dropdown Button component for Retool Apps

import MoreInfo from "./_more-info.mdx";

## Properties

## Methods

## Events

---

## Button components for Retool Apps



---

## The Link List component for Retool Apps

import MoreInfo from "./_more-info.mdx";

## Properties

## Methods

## Events

---

## The Link component for Retool Apps

import MoreInfo from "./_more-info.mdx";

## Properties

## Methods

## Events

---

## The Outline Button component for Retool Apps

:::info Preset component

{frontMatter.sidebar_label} is a preset version of [Button](./button.mdx). The `styleVariant` proprety has been preconfigured to `outline`.

:::

import MoreInfo from "./_more-info.mdx";

## Properties

## Methods

## Events

---

## The Split Button component for Retool Apps

import MoreInfo from "./_more-info.mdx";

## Properties

## Methods

## Events

---

## The Toggle Button component for Retool Apps

import MoreInfo from "./_more-info.mdx";

## Properties

## Methods

## Events

---

## The Toggle Link component for Retool Apps

import MoreInfo from "./_more-info.mdx";

## Properties

## Methods

## Events

---

## The Bar Chart component for Retool Apps

The Bar Chart component renders data in vertical bars. Bar Chart is useful for visualizing categorical data.

import MoreInfo from "./_more-info.mdx";

## Properties

## Methods

## Events

---

## The Bubble Chart component for Retool Apps

The Bubble Chart component renders data on an x-axis and y-axis, with bubble size relative to value. Bubble Chart is useful for visually identifying relationships between three dimensions.

import MoreInfo from "./_more-info.mdx";

## Properties

## Methods

## Events

---

## The Funnel Chart component for Retool Apps

The Funnel Chart component renders data in a funnel shape, with sections of decreasing size. Funnel Chart is useful for visualizing data in different stages of a process.

import MoreInfo from "./_more-info.mdx";

## Properties

## Methods

## Events

---

## The Heat Map component for Retool Apps

The Heat Map component renders data on an x-axis and y-axis, with a value for each point on the map. Heat Map is useful for visualizing intensity and identifying patterns or correlations.

import MoreInfo from "./_more-info.mdx";

## Properties

## Methods

## Events

---

## Chart components for Retool Apps



---

## The Line Chart component for Retool Apps

The Line Chart component renders data as a line on an x-axis and y-axis. Line Chart is useful for visualizing data over time.

import MoreInfo from "./_more-info.mdx";

## Properties

## Methods

## Events

---

## The Mixed Chart component for Retool Apps

The Mixed Chart component renders data on an x-axis and multiple y-axes, and it can combine several different chart types. Mixed Chart is useful for visualizing the relationship between several different datasets.

import MoreInfo from "./_more-info.mdx";

## Properties

## Methods

## Events

---

## The Pie Chart component for Retool Apps

The Pie Chart component renders data in a circle, with percentage-based slices. Pie Chart is useful for visualizing how different parts make up a whole.

import MoreInfo from "./_more-info.mdx";

## Properties

## Methods

## Events

---

## The Plotly JSON Chart component for Retool Apps

Use the Plotly JSON Chart component to build charts with raw Plotly JSON structured data. Plotly JSON Chart is useful for visualizing data when you need full control over the data and layout of the chart.

import MoreInfo from "./_more-info.mdx";

## Properties

## Methods

## Events

---

## The Sankey Chart component for Retool Apps

The Sankey Chart component renders data as links between nodes. Sankey Chart is useful for visualizing how data moves between different stages or categories.

import MoreInfo from "./_more-info.mdx";

## Properties

## Methods

## Events

---

## The Scatter Chart component for Retool Apps

The Scatter Chart component renders data as points on an x-axis and y-axis. Scatter Chart is useful for visualizing how data moves between different stages or categories.

import MoreInfo from "./_more-info.mdx";

## Properties

## Methods

## Events

---

## The Sparkline component for Retool Apps

The Sparkline component renders data as a line on an x-axis and y-axis. Sparkline is useful for visualizing data over time. It is a simplified version of the [Line Chart](./line-chart.mdx) component.

Refer to the [charts guide](../../../guides/data/charts.mdx) for more information on building charts.

import MoreInfo from "./_more-info.mdx";

## Properties

## Methods

## Events

---

## The Stacked Bar Chart component for Retool Apps

The Stacked Bar Chart component renders data in vertical bars, with stacked segments representing different groups or subcategories. Stacked Bar Chart is useful for visualizing categorical data and comparing data across multiple groups.

import MoreInfo from "./_more-info.mdx";

## Properties

## Methods

## Events

---

## The Sunburst Chart component for Retool Apps

The Sunburst Chart component renders hierarchical data in a series of concentric rings. Sunburst Chart is useful for visualizing parent-child relationships and how parts make up a whole.

import MoreInfo from "./_more-info.mdx";

## Properties

## Methods

## Events

---

## The Treemap component for Retool Apps

The Treemap component renders hierarchical data as nested rectangles. Treemap is useful for visualizing data with many categories and comparing the size and relationship of those categories.

import MoreInfo from "./_more-info.mdx";

## Properties

## Methods

## Events

---

## The Waterfall Chart component for Retool Apps

The Waterfall Chart component renders data as a series of steps with sequential positive and negative values. Waterfall Chart is useful for visualizing how incremental values contribute to a total.

import MoreInfo from "./_more-info.mdx";

## Properties

## Methods

## Events

---

## Retool Apps components reference



---

## The Collapsible Container component for Retool Apps

:::info Preset component

{frontMatter.sidebar_label} is a preset version of [Container](./container.mdx). It has been preconfigured with a collapsible body and [Toggle Button](../buttons/toggle-button.mdx) component.

:::

---

## The Container component for Retool Apps

import MoreInfo from "./_more-info.mdx";

## Properties

## Methods

## Events

---

## The Form component for Retool Apps

Form can automatically generate input fields from a database or Table component, and populate nested input field values using default data.

:::tip
For more information about using the Form component, refer to the [forms guide](../../../guides/forms-inputs/forms/index.mdx).
:::

## Properties

## Methods

## Events

---

## Container and form components for Retool Apps



---

## The JSON Schema Form component for Retool Apps

JSON Schema Form is based on the [react-jsonschema-form](https://github.com/rjsf-team/react-jsonschema-form) library. You define which input fields to include and how they are rendered using JSON and UI schemas.

The component can also populate nested input field values using default data.

:::tip
For more information about using the Form component, refer to the [forms guide](../../../guides/forms-inputs/forms/index.mdx).
:::

## Properties

## Methods

## Events

---

## The Link Card component for Retool Apps

:::info Preset component

{frontMatter.sidebar_label} is a preset version of [Container](./container.mdx). It has been preconfigured with [Icon](../presentation/icon.mdx) and [Text](../presentation/text.mdx) components.

:::

---

## The Stack component for Retool Apps

import MoreInfo from "./_more-info.mdx";

## Properties

## Methods

## Events

---

## The Stepped Container mobile component

:::info Preset component

{frontMatter.sidebar_label} is a preset version of [Container](./container.mdx). It has been preconfigured with multiple views and the [Steps](../navigation/steps.mdx) component.

:::

---

## The Tabbed Container component for Retool Apps

:::info Preset component

{frontMatter.sidebar_label} is a preset version of [Container](./container.mdx). It has been preconfigured with multiple views and the [Tabs](../navigation/steps.mdx) component.

:::

---

## The Wizard component for Retool Apps

{frontMatter.sidebar_label} groups component into a series of steps that follow a linear path or branch into multiple ones. It supports running queries on step change or reset, virtual steps that display a loading screen, and setting the initial step dynamically.

:::tip
For more information about using the Form component, refer to the [forms guide](../../../guides/interaction-navigation/wizard.mdx).
:::

## Properties

## Methods

## Events

---

## HTML

HTML supports most HTML tags and presentational attributes. Scripting is not supported but [event handlers](#events) are available.

To embed web pages, use an [IFrame](./iframe.mdx) component. For functionality that isn't available in other components, or to use React or HTML and JavaScript, use a [Custom Component](../legacy/custom-component.mdx).

import WebPlayground from "/docs/_partials/_components/_web-playground.mdx";

## Properties

## Events

To attach an event handler to a specific element in the HTML, add a `data--target` attribute. For example:

```html title="Click event handler"
Trigger event
```

---

## IFrame

IFrame supports permissions to allow or deny downloads, form submissions, microphone and camera access, and popups.

Use an [HTML](./html.mdx) component to include custom HTML and CSS instead of an embedded web page. You can also use a [Custom Component](../legacy/custom-component.mdx) to include custom React, HTML, and JavaScript.

:::tip
For more information about using the IFrame component, refer to the [iframes guide](../../../guides/custom/iframe.mdx).
:::

## Properties

## Methods

---

## Custom components for Retool Apps



---

## The Filter component for Retool Apps

Filter connects to a [Table](./table.mdx) component to dynamically filter its displayed data.

## Properties

## Methods

## Events

---

## Data components for Retool Apps



---

## The JSON Explorer component for Retool Apps

## Properties

## Methods

## Events

---

## The Key Value component for Retool Apps

## Properties

## Methods

## Events

---

## The Reorderable List component for Retool Apps

## Properties

## Methods

## Events

---

## The Table component for Retool Apps

Table renders an array of data, such as database records, as a tabulated list. Refer to the [working with tables](../../../guides/data/table/index.mdx) guide to learn more about using the Table component.

## Properties

## Methods

## Events

---

## The Calendar Input component for Retool Apps

## Properties

## Methods

## Events

s

---

## The Date Range component for Retool Apps

import MoreInfo from "./_more-info.mdx";

## Properties

## Methods

## Events

---

## The Date Time component for Retool Apps

import MoreInfo from "./_more-info.mdx";

## Properties

## Methods

## Events

---

## The Date component for Retool Apps

import MoreInfo from "./_more-info.mdx";

## Properties

## Methods

## Events

---

## The Day component for Retool Apps

:::info Preset component

{frontMatter.sidebar_label} is a preset version of [Select](../select-inputs/select.mdx). It has been preconfigured with a list of values.

:::

## Properties

## Methods

## Events

---

## Date and time components for Retool Apps



---

## The Month component for Retool Apps

:::info Preset component

{frontMatter.sidebar_label} is a preset version of [Select](../select-inputs/select.mdx). It has been preconfigured with a list of values.

:::

## Properties

## Methods

## Events

---

## The Time component for Retool Apps

import Timezones from "/docs/_partials/_components/_timezones.mdx";

import MoreInfo from "./_more-info.mdx";

## Properties

## Methods

## Events

---

## The Year component for Retool Apps

:::info Preset component

{frontMatter.sidebar_label} is a preset version of [Select](../select-inputs/select.mdx). It has been preconfigured with a list of values.

:::

## Properties

## Methods

## Events

---

## The Auth Login component for Retool Apps

Auth Login enables users to authenticate with a resource configured to use [custom API authentication](../../../../data-sources/guides/authentication/custom.mdx).

## Properties

## Methods

## Events

---

## Integration components for Retool Apps



---

## The Looker component for Retool Apps

Looker embeds a [Looker](https://looker.com/) visualization dashboard.

## Properties

## Methods

## Events

---

## The Mapbox Map component for Retool Apps

An embedded map using [MapBox](https://www.mapbox.com/) to display latitude and longitude coordinates as points of interest. It supports custom markers using Emoji and symbols, default coordinates and zoom level, and GeoJSON to render custom shapes for highlighting locations.

Mapbox Map can trigger queries when panning or zooming the map, and on hover start or end for points.

Refer to the [Mapbox guide](../../../guides/presentation-styling/mapbox.mdx) for more information about using this component.

## Properties

## Methods

## Events

---

## The Stripe Card Form component for Retool Apps

An embedded payment form to securely submit collect and submit card information to [Stripe](https://stripe.com/). A token is returned that can be used to charge the card.

## Properties

## Methods

## Events

---

## The Tableau component for Retool Apps

Tableau embeds a [Tableau](https://www.tableau.com/) visualization dashboard.

## Properties

## Methods

## Events

---

## The Alert component for Retool Apps

import Legacy from "./_callout.mdx";

## Properties

## Methods

## Events

---

## The Button Group component for Retool Apps

import Legacy from "./_callout.mdx";

## Properties

## Methods

## Events

---

## The Legacy Cascader component for Retool Apps

:::note

This component is considered legacy and will be deprecated in the future. Use the newer version of the [Cascader component](./cascader.mdx), which has more features available.

:::

## Properties

## Methods

## Events

---

## The Chart component for Retool Apps

:::note

This component is considered legacy and will be deprecated in the future.  Use the newer [Chart components](../charts/index.mdx), which have more features available.

:::

## Properties

## Events

---

## Legacy Checkbox Tree component for Retool Apps

:::note

This component is considered legacy and will be deprecated in the future. Use the newer version of the [Checkbox Tree component](./checkbox-tree.mdx) which has more features available.

:::

## Properties

## Methods

## Events

---

## Custom Component

This is a legacy component that is no longer supported. Use [custom component libraries](../../../guides/custom/custom-component-libraries/index.mdx) if you want to build custom components for Retool apps.

Custom Component supports passing data to and from the Retool app. It can be granted permission for popups, link redirection, and camera access.

:::info Use cases

You should only build a custom component if you need functionality that isn't already available in an existing component. You can also use an [IFrame](../custom/iframe.mdx) component to embed web pages or the [HTML](../custom/html.mdx) component to include custom HTML and CSS.

:::

## Properties

## Methods

## Events

---

## The Key Value component for Retool Apps

import Legacy from "./_callout.mdx";

## Properties

## Methods

## Events

---

## The List View component for Retool Apps

import Legacy from "./_callout.mdx";

List View supports unique row keys and displays rows using dynamic or fixed height. Rows can contain any combination of components to customize how data is interacted with or presented.

## Properties

## Methods

## Events

---

## The Breadcrumbs component for Retool Apps

import MoreInfo from "./_more-info.mdx";

## Properties

## Methods

## Events

---

## Navigational components for Retool Apps



---

## The Navigation component for Retool Apps

Navigation supports both horizontal and vertical orientation, and can include an image to display a logo next to menu items.

The component supports linking an item directly to other apps or pages. Doing so will automatically highlight the item (or its parent) when currently viewing its linked app, and hide it for any users who do not have access to its linked app.

import MoreInfo from "./_more-info.mdx";

## Properties

## Methods

## Events

---

## The Page Input component for Retool Apps

Page Input displays the total number of pages and automatically updates to reflect the currently selected page. Use [Pagination](./pagination.mdx) for navigating pages of data using numbered links.

import MoreInfo from "./_more-info.mdx";

## Properties

## Methods

## Events

---

## The Pagination component for Retool Apps

Pagination adjusts the number of pages shown to fit its width and automatically updates to reflect the currently selected page. Use [Page Input](./page-input.mdx) for navigating to specific pages of data using an input field.

import MoreInfo from "./_more-info.mdx";

## Properties

## Methods

## Events

---

## The Steps component for Retool Apps

Steps is a set of UI elements that represent sequential steps. It can be linked to [Container](../containers-forms/container.mdx) to create [Stepped Container](../containers-forms/stepped-container.mdx).

## Properties

## Methods

## Events

---

## The Tabs component for Retool Apps

Tabs is a set of clickable UI elements to represent tabbed menu items. It can be linked to [Container](../containers-forms/container.mdx) to create [Tabbed Container](../containers-forms/tabbed-container.mdx).

## Properties

## Methods

## Events

---

## The Currency component for Retool Apps

:::info Preset component

{frontMatter.sidebar_label} is a preset version of [Number Input](./number-input.mdx). It has been preconfigured with common options for currency input.

:::

import MoreInfo from "./_more-info.mdx";

## Properties

## Methods

## Events

---

## The Editable Number component for Retool Apps

Editable Number functions similarly to [Number Input](./number-input.mdx) but renders as plain text until clicked.

import MoreInfo from "./_more-info.mdx";

## Properties

## Methods

## Events

---

## The Number Input component for Retool Apps

import MoreInfo from "./_more-info.mdx";

## Properties

## Methods

## Events

---

## Number input components for Retool Apps



---

## The Percent component for Retool Apps

:::info Preset component

{frontMatter.sidebar_label} is a preset version of [Number Input](./number-input.mdx). It has been preconfigured with common options for percentage input.

:::

import MoreInfo from "./_more-info.mdx";

## Properties

## Methods

## Events

---

## The Phone Number Input component for Retool Apps

import MoreInfo from "./_more-info.mdx";

## Properties

## Methods

## Events

---

## The Range Slider component for Retool Apps

import MoreInfo from "./_more-info.mdx";

## Properties

## Methods

## Events

---

## The Rating component for Retool Apps

import MoreInfo from "./_more-info.mdx";

## Properties

## Methods

## Events

---

## The Slider component for Retool Apps

import MoreInfo from "./_more-info.mdx";

## Properties

## Methods

## Events

---

## The Alert component for Retool Apps

For more information about this component, refer to the [Informational components](../../../guides/presentation-styling/presentation.mdx) guide.

## Properties

## Methods

## Events

---

## The Avatar Group component for Retool Apps

Avatar Group adjusts the number of avatars shown to fit within its width or according to the specified maximum number, whichever is smaller. If there are more, the final avatar is a count of user photos that cannot be shown.

## Properties

## Methods

## Events

---

## The Avatar component for Retool Apps

## Properties

## Methods

## Events

---

## The Calendar component for Retool Apps

Calendar uses the [FullCalendar](https://fullcalendar.io/docs/event-object) library.

For more information on using the Calendar component, refer to the [getting started guide](../../../guides/presentation-styling/calendar.mdx).

## Properties

## Methods

## Events

---

## The Circular Image component for Retool Apps

:::info Preset component

{frontMatter.sidebar_label} is a preset version of [Image](./image.mdx). It has been preconfigured with a 50% border radius.

:::

## Properties

## Methods

## Events

---

## The Divider component for Retool Apps

## Properties

## Methods

---

## The Event List web component

## Properties

## Methods

## Events

---

## The Icon Text component for Retool Apps

## Properties

## Methods

## Events

---

## The Icon component for Retool Apps

## Properties

## Methods

## Events

---

## The Image Grid component for Retool Apps

## Properties

## Methods

## Events

---

## The Image component for Retool Apps

## Properties

## Methods

## Events

---

## Presentation components for Retool Apps



---

## The PDF component for Retool Apps

For more information about this component, refer to the [Embedded media](../../../guides/presentation-styling/embedded-media.mdx) guide.

## Properties

## Methods

## Events

---

## The Progress Bar component for Retool Apps

For more information about this component, refer to the [Informational components](../../../guides/presentation-styling/presentation.mdx) guide.

## Properties

## Methods

## Events

---

## The Progress Circle component for Retool Apps

For more information about this component, refer to the [Informational components](../../../guides/presentation-styling/presentation.mdx) guide.

## Properties

## Methods

## Events

---

## The QR Code component for Retool Apps

For more information about this component, refer to the [Embedded media](../../../guides/presentation-styling/embedded-media.mdx) guide.

## Properties

## Methods

## Events

---

## The Spacer component for Retool Apps

Spacer preserves white space in a layout whenever components positioned above are collapsed, hidden, or resized.

## Properties

## Methods

---

## The Statistic component for Retool Apps

For more information about this component, refer to the [Informational components](../../../guides/presentation-styling/presentation.mdx) guide.

## Properties

## Methods

## Events

---

## The Status component for Retool Apps

For more information about this component, refer to the [Informational components](../../../guides/presentation-styling/presentation.mdx) guide.

## Properties

## Methods

## Events

---

## The Tags component for Retool Apps

For more information about this component, refer to the [Informational components](../../../guides/presentation-styling/presentation.mdx) guide.

## Properties

## Methods

## Events

---

## The Text component for Retool Apps

Text supports [Github Flavored Markdown](https://github.github.com/gfm/) and most presentation attributes, such as images, links, and text formatting.

For more information about this component, refer to the [Informational components](../../../guides/presentation-styling/presentation.mdx) guide.

## Properties

## Methods

## Events

---

## The Timeline web component

For more information about this component, refer to the [Timeline guide](../../../guides/presentation-styling/timeline.mdx).

## Properties

## Methods

## Events

---

## The Video component for Retool Apps

Video supports popular video services (e.g., YouTube and Vimeo) and direct links to video file types commonly supported by browsers.

For more information about this component, refer to the [Embedded media](../../../guides/presentation-styling/embedded-media.mdx) guide.

:::note

To embed YouTube Shorts using the Video component, use the following URL format: `https://www.youtube.com/embed/{identifier_string}`, where `identifier_string` is the identifier at the end of the YouTube Shorts URL.

:::

## Properties

## Methods

## Events

---

## Container List View

Refer to the [Repeatable components](../../../guides/layout-structure/repeatables.mdx) guide for more information about how to use the Container List View component.

:::info Preset component

{frontMatter.sidebar_label} is a preset version of [List View](./list-view.mdx). It has been preconfigured with a nested [Container](../containers-forms/container.mdx) component.

:::

---

## The Grid View component for Retool Apps

Refer to the [Repeatable components](../../../guides/layout-structure/repeatables.mdx) guide for more information about how to use the Grid View component.

:::info Preset component

{frontMatter.sidebar_label} is a preset version of [List View](./list-view.mdx). It has been preconfigured to use a grid layout.

:::

---

## Repeatable components for Retool Apps



---

## The List View component for Retool Apps

Refer to the [Repeatable components](../../../guides/layout-structure/repeatables.mdx) guide for more information about how to use the List View component.

## Properties

## Methods

## Events

---

## The Cascader component for Retool Apps

Refer to the [selection input guide](../../../guides/forms-inputs/select-inputs.mdx) for more information on using this component.

:::note

Retool recently released this [improved version of the Cascader component](/changelog/cascader-v2). Use of the [legacy Cascader component](../legacy/cascader.mdx) is discouraged.

:::

## Properties

## Methods

## Events

---

## The Checkbox Group component for Retool Apps

## Properties

## Methods

## Events

---

## Checkbox Tree component for Retool Apps

:::info Preset component

{frontMatter.sidebar_label} is a preset version of [Checkbox Group](./checkbox-group.mdx). It has been preconfigured with common options for a nested tree layout.

:::

Retool recently released this [improved version of the Checkbox Tree component](/changelog/checkbox-tree-v2), and use of the [legacy component](../legacy/checkbox-tree.mdx) is discouraged.

## Properties

## Methods

## Events

---

## The Checkbox component for Retool Apps

## Properties

## Methods

## Events

---

## Select input components for Retool Apps



---

## The Listbox component for Retool Apps

Refer to the [selection input guide](../../../guides/forms-inputs/select-inputs.mdx) for more information on using this component.

## Properties

## Methods

## Events

---

## The Multiselect Listbox component for Retool Apps

Refer to the [selection input guide](../../../guides/forms-inputs/select-inputs.mdx) for more information on using this component.

## Properties

## Methods

## Events

---

## The Multiselect component for Retool Apps

Refer to the [selection input guide](../../../guides/forms-inputs/select-inputs.mdx) for more information on using this component.

## Properties

## Methods

## Events

---

## The Radio Group component for Retool Apps

Refer to the [selection input guide](../../../guides/forms-inputs/select-inputs.mdx) for more information on using this component.

## Properties

## Methods

## Events

---

## The Segmented Control component for Retool Apps

Refer to the [selection input guide](../../../guides/forms-inputs/select-inputs.mdx) for more information on using this component.

## Properties

## Methods

## Events

---

## The Select component for Retool Apps

## Properties

## Methods

## Events

---

## The Switch Group component for Retool Apps

## Properties

## Methods

## Events

---

## The Switch component for Retool Apps

## Properties

## Methods

## Events

---

## Agent Chat component

Use the Agent Chat component to invoke a Retool Agent from within an web app.

:::note

The Agent Chat functionality cannot be used from public apps, as calling an agent requires a logged-in user.

:::

## Properties

## Methods

## Events

---

## The Annotated Text component for Retool Apps

## Properties

## Methods

## Events

---

## The Bounding Box component for Retool Apps

## Properties

## Methods

## Events

---

## The Color Input component for Retool Apps

## Properties

## Methods

## Events

---

## The Comment Thread component for Retool Apps

For more information about using this component, refer to the [Comment Thread guide](../../../guides/forms-inputs/comment-thread.mdx).

## Properties

## Methods

## Events

---

## The File Button component for Retool Apps

Refer to the [File inputs guide](../../../guides/forms-inputs/file-inputs.mdx) for more information on how to use this component.

## Properties

## Methods

## Events

---

## The File Dropzone component for Retool Apps

Refer to the [File inputs guide](../../../guides/forms-inputs/file-inputs.mdx) for more information on how to use this component.

## Properties

## Methods

## Events

---

## The File Input component for Retool Apps

Refer to the [File inputs guide](../../../guides/forms-inputs/file-inputs.mdx) for more information on how to use this component.

## Properties

## Methods

## Events

---

## Special input components for Retool Apps



---

## The LLM Chat component for Retool Apps

Refer to [Getting started with the LLM Chat component](../../../guides/forms-inputs/chats/llm-chat.mdx) for more information about this component.

## Properties

## Methods

## Events

---

## The Microphone component for Retool Apps

Recordings are Base64-encoded in WebM format, and audio playback displays a progress bar and elapsed time.

## Properties

## Methods

## Events

---

## The Scanner component for Retool Apps

## Properties

## Methods

## Events

---

## The Signature component for Retool Apps

## Properties

## Methods

## Events

---

## The Timer component for Retool Apps

## Properties

## Methods

## Events

---

## The Editable Text Area component for Retool Apps

Editable Text Area is a multi-line input field for text values. It functions similarly to [Text Area](./text-area.mdx) but renders as plain text until clicked.

## Properties

## Methods

## Events

---

## The Editable Text component for Retool Apps

Editable Text is a single-line input field for text values. It functions similarly to [Text Input](./text-input.mdx) but renders as plain text until clicked.

## Properties

## Methods

## Events

---

## The Email component for Retool Apps

:::info Preset component

{frontMatter.sidebar_label} is a preset version of [Text Input](./text-input.mdx). It has been preconfigured with common options for email address input.

:::

## Properties

## Methods

## Events

---

## Text input components for Retool Apps



---

## JSON Editor

## Properties

## Events

---

## Password

## Properties

## Methods

## Events

---

## The Rich Text Editor component for Retool Apps

## Properties

## Methods

## Events

---

## Text Area

## Properties

## Methods

## Events

---

## The Text Input component for Retool Apps

## Properties

## Methods

## Events

---

## The URL component for Retool Apps

:::info Preset component

{frontMatter.sidebar_label} is a preset version of [Text Input](./text-input.mdx). It has been preconfigured with common options for URL input.

:::

## Properties

## Methods

## Events

---

## App event handlers reference

## Events

Support for each event depends upon the component or object being configured.

## Actions

import Actions from '/docs/_shared/_event-handler-actions.mdx';

---

## The Drawer frame

The Drawer frame is a container that slides into view when visible. You can add multiple instances of the Drawer frame that operate independently.

## Properties

## Methods

---

## Retool Apps frames reference



---

## The Modal frame

The Modal frame is a container that appears as an overlay in the center of the app when visible. You can add multiple instances of the Modal frame that operate independently.

## Properties

## Methods

## Events

---

## The Sidebar frame

The Sidebar frame is a container that appears as next to the Main frame. Sidebar can automatically configure an optimized mobile layout when viewing web apps on devices with smaller screens. Only one instance of Sidebar can be used.

## Properties

## Methods

---

## The Split Pane frame

The Split Pane frame is a container that appears next to the Main frame. Only one instance of Split Pane can be used.

## Properties

## Methods

---

## Apps glossary

import SharedGlossary from '../../_partials/_glossary.mdx';

---

## App IDE keyboard shortcuts

Use Retool's built-in keyboard shortcuts to quickly perform certain actions or control the interface. You can also configure [custom keyboard shortcuts](./keyboard-shortcuts.mdx) on a per-app basis that can trigger queries, interact with components, and more.

---

## Modules

A module is a type of app you can build and embed within other apps. Modules enable you to reuse components and code in multiple apps, and modules can pass data to and from the parent app. This can help reduce app maintenance as you only need to update a module; any parent apps immediately reflect the changes.

Refer to the [modules guide](../guides/layout-structure/modules.mdx) for more information about creating and using modules.

## Properties

## Methods

---

## The Current User object

:::tip Not available in public apps

`current_user` is `null` for publicly accessible apps that do not require authentication.

:::

## Properties

---

## The Retool Context object

## Properties

---

## The Theme object

## Properties

## Methods

---

## The Url object

## Properties

---

## The Viewport object

## Properties

---

## Retool CLI reference

import Cli from "/docs/_shared/_retool-cli.mdx";

---

## Built-in URL parameters

:::warning

[Public apps](../guides/app-management/embed-apps.mdx#public-apps) do not support built-in URL parameters.

:::

Use built-in URL search parameters to control certain app characteristics when launched, such as loading a specific release or environment. Append `?` to the app's URL and include the parameters as `key=value` pairs. Separate multiple parameters with `&`.

Refer to the [URL parameters guide](../guides/app-management/url-parameters.mdx) for information on configuring custom parameters for use in apps.

---

## Retool Apps reference

import Reference from "/docs/_partials/_doctypes/_reference.mdx";

:::tip Get started with web apps

If you are unfamiliar with Retool web apps and want to get started:

- Read the [quickstart](./quickstart) to learn about the fundamental concepts.
- Follow a [tutorial](./tutorial/) to build your first web app.

:::

---

## Retool apps tutorial: Save changes to data

import GoBack from "../_go-back.mdx";

Now that the table displays customer data, you can configure the form to make changes. Submitting the form then triggers a query that writes the changes back to the API.

## 1. Generate input fields

Inside the Form component, click **Generate from table** and select the Table component in the **Source** dropdown.

The form generator modal displays a list of table columns to review. All columns are selected and set as required fields by default. For the purposes of this tutorial, uncheck all columns except **First** and **Last**, then click **Generate form**.

The generated form and its input fields are automatically configured as follows:

- The form's **Data source** setting is set to `{{ table1.selectedRow }}`. This references the selected row in the table.
- The **Form data key** setting for each input component references the column name. For instance, the key for `firstInput` is set to `first`. This enables the form to automatically populate its value from the selected row.

The form and its input fields update whenever you select a different table row.

export function ArcadeInputs() {
  return (
    
      
    
  );
}

## 2. Create a query to save changes

Navigate to the **Code** tab and add another resource query to the **customersPage** section. Update the query to reference the form's input values and save the changes back to the API.

1. Select the **Sample Customers** resource.
1. Change the query action to **PATCH**. This API method is commonly used to make changes to existing data.
1. Reference the currently selected customer in the query's URL. You interact with specific customers using the mock API by referencing the customer ID. To obtain this, set the URL path to `{{ table1.selectedRow.id }}`. This dynamically references the ID of the selected customer in the table.

Next, reference the form's input values in the request body. Add the following key-value information to the **Body** section of the query:

| Key     | Value                    |
| ------- | ------------------------ |
| `first` | `{{ firstInput.value }}` |
| `last`  | `{{ lastInput.value }}`  |

When run, the resource query performs a PATCH request with the specified customer and updates the `first` and `last` values.

Click **Save** to save the query. Click **Test** to preview the results of the query.

export function PatchQuery() {
  return (
    
      
    
  )
}

## 3. Add an event handler to the query

To ensure that the table continually displays the most current customer data, this query should refresh the table when it successfully runs. Refreshing the table triggers the first query that retrieves customers, which will now include any saved changes.

Add an event handler to the query that refreshes the table when it successfully runs.

1. In the **Event handlers** settings of the query, add a **Success** event handler.
1. Select the **Control component** event action.
1. Select the **table1** component.
1. Select the **Refresh** method.

Click **Save** to save the query.

export function EventHandler() {
  return (
    
      
    
  )
}

## 4. Update the form to trigger the query

Now you're ready to update the Form to trigger the new query. Select the Form and use the Inspector to add an event handler. The event handler needs to run on the **Submit** event, control the newly created query, and trigger it.

Now that the form and query are complete, you can now select a customer and edit their details. When you click **Submit**, the query runs automatically and updates the selected customer, then refreshes the table.

export function ArcadeSubmit() {
  return (
    
      
    
  );
}

## Next steps

You've now completed a fully working Retool app that reads and writes API data. Part two of this tutorial explains how to extend the functionality of your app.

---

## Retool apps tutorial: Connect and query data

import GoBack from '../_go-back.mdx';

A resource is a set of user-configured properties that determine how Retool interacts with a data source, such as an API. You create a resource for each data source you want to use with Retool. You can then select the resource when writing a query so you can interact with the data.

## 1. Generate a mock API with customer data

## 2. Create a resource query

First, add a resource query to retrieve customer data. Before the query can do this, you must create the necessary resource. In this example, you will create a resource directly from the **Code** tab.

Click  in the left panel to open the **Code** tab. In the **customersPage** section, click  and select **Resource query**.

`query1` populates with a list of suggested [resources](../../../data-sources/quickstarts/resources.mdx) in your Retool organization for which you have access. 

## 3. Create a REST API resource

Retool supports most databases and APIs, and you can use built-in [integrations](../../../data-sources/tutorials.mdx) to connect to popular data sources with minimal configuration. 

The [mock API](#1-generate-a-mock-api-with-customer-data) is a basic REST API with no authentication. To create a resource for it:

1. Click the **Resource** dropdown and select **+ Create a new resource**.
1. Select the **REST API** integration.
1. Set the resource name to **Sample Customers** and then paste the copied API URL into the **Base URL** field.
1. Click **Create resource**.

The resource query updates to perform a GET request with the newly created resource. Click **Save & Run** to save the resource query and run it. The query then retrieves the list of customers from the API.

export function ArcadeQuery() {
  return (
    
      
    
  )
}

## 4. Update the table to display customer data

The Table component's **Data source** is currently set to use its own demo data. Select the Table and, in the **Inspector**, change the data source to `query1`. 

Once updated, the table automatically updates to display the query results. It also attempts to configure the column formats for each field, such as `email` and `id`. 

You can rearrange the columns or update the specified format from the **Columns** section of the Inspector. For example, the **Postal** column should be formatted as a string. If it appears to use the **Number** format, select the column and update its **Format** setting.

export function ArcadeTable() {
  return (
    
      
    
  )
}

## Next steps

You've now created a resource and can read with data using queries. Move on to the next section and learn how write changes back to the data source.

---

## Retool apps tutorial: Fundamental concepts

import PartOne from "../_part1.mdx";

Learn how to assemble your app's user interface.

---

## Retool apps tutorial: Assemble the user interface

import AddUI from "/img/icons/apps/add-ui.svg";

Retool apps group code, components, and frames into pages. Apps can contain a single page or you can build more complex apps using multiple pages.

Part one of this tutorial uses a single page to display and edit customer data. In [part two](../part-two/index.mdx), you will add another page to view customer subscription data.

## Edit the default page

All apps initially start with a single page, **defaultPage**. Update the details for this page to use it for customers.

1. Click  in the left panel to open the **Pages** tab. 
2. Right-click **page1** in the **Pages** pane and select **Rename**.
3. Rename the page to `customersPage`. The page name is the unique identifier for this object within a Retool app.
4. In the **Inspector** on the right-side of the IDE, update the **Page title** to `Customers`. The title is what Retool displays in the browser and in navigation components.
5. Change the **Page URL** to `customers`. The URL is the path at which the page resides.

export function ArcadeEditPage() {
  return (
    
      
    
  )
}

## Add a table and form to the page

Components are interface elements with which users interact, such as input fields and buttons. You assemble the app's user interface by placing components anywhere on the canvas of a selected page, and can adjust their position and size.

### Add the table

The [Table](../../guides/data/table/index.mdx) component enables you to display and interact with data using a feature-rich table.

1. Click  in the left panel to open the **Add UI tab**.
1. Click-and-drag the Table component to the canvas area.

The Table component's **Data source** initially contains demo data. In the [next part](./data.mdx) of this tutorial, you will write a query to retrieve customer data and display it in the table. 

### Add the form

This app uses a [Form](../../guides/forms-inputs/forms/index.mdx) component to edit customer details. When configured, the form's input fields will display details of the customer selected in the table. A form can generate the necessary input fields from a table so you don't have to build it from scratch. You will configure this later on.

Repeat the steps above to add a Form component then place it next to the table.

export function ArcadeAdd() {
  return (
    
      
    
  )
}

## Next steps

You've now assembled the user interface for your Retool app. Move on to the next section and learn how to connect and query data.

---

## Retool apps tutorial: Advanced features

import PartTwo from "../_part2.mdx";

Learn how to extend your app's user interface with multiple pages.

---

## Retool app tutorial: Map and filter data

import GoBack from '../_go-back.mdx';

The Table component in the subscriptions page currently displays all subscription data. The next step is to filter the results by selecting a customer.

## 1. Map customers to select options

For components that support multiple options, such as Select, you can either manually configure each option or [dynamically map them](../../guides/forms-inputs/option-lists.mdx) from an array of data, such as query results. Retool evaluates each item in the array of data and makes it available as `item` to define option lists.

Navigate to the subscriptions page and map the customer data to the Select component's list of options.

1. Click on the Select component to view its settings in the **Inspector**. 
1. Set the component to **Mapped** mode and set the **Data source** to `query1`.

Configure the following in **Mapped options**:

- Value: `{{ item.id }}`
- Label: `{{ item.first }} {{item.last }}`
- Caption: `{{ item.email }}`

When set, each option value references the customer's ID. The label for each option is the customer's full name, with their email address appearing as the caption.

export function ArcadeMap() {
  return (
    
      
    
  )
}

## 2. Connect the subscriptions API and update the table

:::info

When generating the mock API for subscriptions, the number of items should be equal to, or greater than, the number previously used for the customers API.

:::

Next, add a resource query and create a resource for the subscriptions API. This is the [same process](../part-one/data.mdx) you used to connect the customers API.

Once you're done, set the **Data source** for your new table to `query3`.

export function ArcadeSubs() {
  return (
    
      
    
  )
}

## 3. Filter table results based on the selected customer

The Select component contains a list of customers from which to select. When you select a customer, the component's `value` property is set to the customer ID.

The subscription data that you just added contains a `customer_id` field. Configure the Table component with a default filter so that it only displays subscriptions that correspond ot the selected customer. The table then automatically updates whenever you select a different customer.

1. Click on the Table component to view its settings in the **Inspector**. 
2. In the **Default filters** settings, click .
3. Set the **Column** to the **Customer ID** by which to filter.
4. Select the **=** operator.
5. Set the filter value to `{{ select1.value }}`.

export function ArcadeFilter() {
  return (
    
      
    
  )
}

## 4. Disable selection of customers without a subscription

Although the table now displays subscription data for a selected customer, there are some customers without any subscriptions. Update the Select component so that customers with no descriptions are disabled. 

You can do so by setting a mapped option to an embedded expression that performs conditional logic. For instance, you can configure the **Disabled** mapped option for the Select component to disable any customer options where the customer has no subscription.

Click the Select component and set the **Disabled** setting to the following expression:

```js
{{ query3.data.filter(subscription => subscription.customer_id === item.id).length === 0 }}
```

This expression filters the subscription data and checks if the current customer ID matches any of the customer IDs. If there are no results, the expression returns `true` and disables the customer option.

export function ArcadeDisable() {
  return (
    
      
    
  )
}

## Next steps

You've now mapped query data to a component and configured a default table filter. Move on to the next section and learn how to temporarily store values.

---

## Retool apps tutorial: Configure multiple pages

import GoBack from '../_go-back.mdx';

The second part of this tutorial makes use of multiple pages to interact with both customer and subscription data. Once complete, the app will also display subscription data for a selected customer.

## 1. Add a subscriptions page

Retool apps group code, components, and frames into pages. Apps can contain a single page or you can build more complex apps using multiple pages.

The app currently has a single page to display and edit customer data. You can add another page to view a specific customer's subscription data.

Click  and select **Page** to create a new page with the following details:

- Name: `subscriptionsPage`
- Page title: `Subscriptions`
- Page URL: `subscriptions`

export function AddPage() {
  return (
    
      
    
  )
}

## 2. Add a header with navigation controls

Now that the app contains multiple pages, users need a way to navigate between them. 

Frames are distinct areas of the canvas in which you add components. The Header frame is a globally scoped frame that, when enabled, is visible across all pages.

Header frame contains a Navigation component by default. This component is preconfigured with navigation controls for pages and displays options for both **Customers** and **Subscriptions**.

export function ArcadeHeader() {
  return (
    
      
    
  )
}

## 3. Convert the customer query to global scope 

Apps use [global and per-page scopes](../../quickstart.mdx#global-and-page-scopes) for components, frames, and code.

- Globally scoped objects can be referenced in all pages. Retool continually evaluates globally scoped objects regardless of the page currently in view.
- Page-scoped objects can only be referenced within the same page. Retool only evaluates page-scoped objects when the page is currently being viewed.

At present, `getCustomers` is a page-scoped query in the customers page and isn't accessible from the subscriptions page. Before you can use this query on the subscriptions page, you must convert it to a globally scoped query so that it's available to all pages.

You can quickly access many parts of the IDE using the Command Palette in the toolbar. 

1. Click on the Command Palette or press ModK to open.
2. Enter `query1` to look up the query.
3. Click **Select in editor** to jump directly to it.

Click-and-drag the query from the **customersPage** section to the **Global** section. 

export function ArcadeScope() {
  return (
    
      
    
  )
}

## 4. Add a select field and table to the page

The Select component is a dropdown input field that can dynamically map data to generate a list of options from which to select. This component is used to select a customer for whom to view subscriptions.

1. Right-click on the canvas area to open the contextual menu.
1. Select **Add components**. This method enables you to quickly add multiple components.
1. Click the **Select** component to add it to the canvas.
1. While the contextual menu is open, click the **Table** component.
2. Update the **Label** of the Select component.

export function ArcadeComponents() {
  return (
    
      
    
  )
}

## Next steps

You've now configured your app to use multiple pages. Move on to the next section and learn how map data to components and use table filters.

---

## Retool app tutorial: Pass data between pages

import GoBack from '../_go-back.mdx';

Both the customer and subscription pages enable you to select a customer and either edit their details or look up a subscription. Since pages function independently, the customer you select in one is not reflected in the other.

When you build apps, you'll likely want to use values from one page in another. You can use a globally scoped variable to temporarily store values and make them available across all pages. In this case, the variable stores the selected customer ID. You then update both pages to reference this value so that both pages always use the same selected customer.

## 1. Create a variable

A [variable](../../../queries/guides/store-temporary-data.mdx) temporarily stores data for the current app session and resets whenever the user returns. Add a globally scoped variable to the app.

1. Navigate to the Code tab.
1. Click  within the **Global** pane and select **Variable**. 

Variables can be set or updated at any time using event handlers or JavaScript methods. You can also specify an initial value, if required.

export function ArcadeVariable() {
  return (
    
      
    
  )
}

## 2. Configure the Select component

You can set a default value for most input components, such as Select. You can reference the variable's value, `variable1.value`, so that the Select component uses the saved customer ID.

The Select component supports event handlers that run whenever its value changes. You can configure the event handler to update the variable with the selected customer ID.

1. Click on the Select component and set **Default value** to `{{ variable1.value }}`. 
1. Add an event handler and select the **Change** event.
1. Select the **Set variable** action and then set **State** to **variable1**.
1. Select the **Set value** method and set the value to `{{ self.value }}`.

export function ArcadeSelect() {
  return (
    
      
    
  )
}

## 3. Configure the customers table

You can configure a Table component with a **Default key** to automatically select a specific row. This key corresponds to the table's **Primary key**. As with the Select component, you can also configure an event handler to update the variable when changing the selected customer.

1. Switch to the **Customers** page.
1. Click on the Table component and set its **Default row** to **Key**.
1. Set the default key to `{{ variable1.value }}`.
1. Add an event handler and select the **Select row** event.
1. Select the **Set variable** action and then set **State** to **variable1**.
1. Select the **Set value** method and set the value to `{{ currentRow.id }}`.

:::tip 

You can use `currentRow` as shorthand when referencing table data.

:::

After configuring both components, the currently selected customer is stored in the variable. You can select a customer in one page and the change is automatically reflected in the other.

export function ArcadeTable() {
  return (
    
      
    
  )
}

## Next steps

You've now extended the functionality of your app. Move on and learn how to make use of other features in Retool apps.

---

## Retool apps tutorial

Retool enables you to build web apps using a drag-and-drop interface and component library. You can connect your apps to almost any database and API to Retool, allowing your users to interact with data.

This tutorial is split into two parts and uses sample data. You only need to complete the first part of this tutorial to build a fully working Retool app. 

## What you'll learn

import PartOne from "./tutorial/_part1.mdx";

import PartTwo from "./tutorial/_part2.mdx";

## Get started

:::info

Familiarity with common technologies like APIs and JavaScript is expected to complete this tutorial. If you need to learn more about these technologies, Retool recommends the following resources:

- [Freecodecamp: How to use REST APIs](https://www.freecodecamp.org/news/how-to-use-rest-api/)
- [Codecademy: JavaScript](https://www.codecademy.com/catalog/language/javascript)

:::

Every Retool user account is bound to an organization in which you create apps.

- If you already have a Retool account, sign in to your organization. 
  - Cloud-hosted organization users can sign in using [Retool's login page](https://login.retool.com/auth/login?source=docs?source=docs). 
  - Self-hosted organization users must sign in using the organization's login page URL (e.g., `https://retool.example.com/auth/login`).
- If you aren't yet using Retool, you can [sign up](https://login.retool.com/auth/signup?source=docs?source=docs) and create a cloud-hosted organization for free. The creator of an organization is automatically designated as its administrator.

Once you log in, navigate to the **Apps** section. then click **Create** > **App** and set the app name to **Retool app tutorial**.

---

## Resource authentication

Retool supports a number of authentication methods for authorizing connections to your data sources. As you create a new resource, you can select one of the methods available and provide the necessary credentials.

import ApiKey from '/docs/_partials/_integrations/_descriptions/_api-key.mdx';
import Auth0 from '/docs/_partials/_integrations/_descriptions/_auth0.mdx';
import Aws from '/docs/_partials/_integrations/_descriptions/_aws.mdx';
import AwsV4Region from '/docs/_partials/_integrations/_descriptions/_awsv4-region.mdx';
import AwsV4AccessKey from '/docs/_partials/_integrations/_descriptions/_awsv4-access-key.mdx';
import AwsV4SecretKey from '/docs/_partials/_integrations/_descriptions/_awsv4-secret-key.mdx';
import AwsV4Role from '/docs/_partials/_integrations/_descriptions/_awsv4-role.mdx';
import Basic from '/docs/_partials/_integrations/_descriptions/_basic.mdx';
import Bearer from '/docs/_partials/_integrations/_descriptions/_bearer.mdx';
import Digest from '/docs/_partials/_integrations/_descriptions/_digest.mdx';
import SessionBased from '/docs/_partials/_integrations/_descriptions/_session-based.mdx';
import GoogleServiceAccount from '/docs/_partials/_integrations/_descriptions/_google-service-account.mdx';
import Oauth1 from '/docs/_partials/_integrations/_descriptions/_oauth1.mdx';
import Oauth2 from '/docs/_partials/_integrations/_descriptions/_oauth2.mdx';
import Oauth2Custom from '/docs/_partials/_integrations/_descriptions/_oauth2-custom.mdx';
import Oauth2AuthUrl from '/docs/_partials/_integrations/_descriptions/_oauth2-auth-url.mdx';
import Oauth2AccessTokenUrl from '/docs/_partials/_integrations/_descriptions/_oauth2-access-token-url.mdx';
import Oauth2ClientId from '/docs/_partials/_integrations/_descriptions/_oauth2-client-id.mdx';
import Oauth2ClientSecret from '/docs/_partials/_integrations/_descriptions/_oauth2-client-secret.mdx';
import Oauth2SkipConsentScreen from '/docs/_partials/_integrations/_descriptions/_oauth2-skip-consent-screen.mdx';
import Oauth2Scopes from '/docs/_partials/_integrations/_descriptions/_oauth2-scopes.mdx';
import Oauth2Prompt from '/docs/_partials/_integrations/_descriptions/_oauth2-prompt.mdx';
import Oauth2Audience from '/docs/_partials/_integrations/_descriptions/_oauth2-audience.mdx';
import Oauth2EnableAuthEndpoint from '/docs/_partials/_integrations/_descriptions/_oauth2-enable-auth-endpoint.mdx';
import Oauth2TokenLifespan from '/docs/_partials/_integrations/_descriptions/_oauth2-token-lifespan.mdx';

## API keys and tokens

:::tip Additional credentials may be required

Certain integrations may require you to provide additional credentials with an API key or token, such as a user ID.

:::

```yaml title="Example credentials"
API Key: 1234567890abcdef1234567890abcdef
```

## Auth0

```yaml title="Example credentials"
Domain: your-app.auth0.com
Client ID: eKf3N2Bsdke3N5Bjf7JsK2dne
Client Secret: 8e2b1f5d3a4c7b9e1f6d5c3a7b8e9f4d
```

## AWS security credentials

```yaml title="Example credentials"
AWS Access Key ID: AKIAIOSFODNN7EXAMPLE
AWS Secret Access Key: wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY
Region: us-west-2
Role ARN: arn:aws:iam::123456789012:role/SampleRole
```

## Basic

```yaml title="Example credentials"
Username: sampleUser
Password: samplePass123
```

## Bearer

```yaml title="Example credentials"
Bearer Token: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.e30.y5T-dGVzZKjT6xZc2Z-s_hN5e_BjWe_u6nZ1P3Alw
```

## Digest

```yaml title="Example credentials"
Username: sampleUser
Password: samplePass123
```

## Google service account

```json title="Example credentials"
{
  "type": "service_account",
  "project_id": "sample-project-id",
  "private_key_id": "abcd1234efgh5678ijkl9012mnop3456qrst7890",
  "private_key": "-----BEGIN PRIVATE KEY-----\nMIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKkwggSlAgEAAoIBAQChK.......\n-----END PRIVATE KEY-----\n",
  "client_email": "sample-account@sample-project.iam.gserviceaccount.com",
  "client_id": "12345678901234567890",
  "auth_uri": "https://accounts.google.com/o/oauth2/auth",
  "token_uri": "https://oauth2.googleapis.com/token",
  "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
  "client_x509_cert_url": "https://www.googleapis.com/robot/v1/metadata/x509/sample-account%40sample-project.iam.gserviceaccount.com"
}
```

## OAuth 1.0

```yaml title="Example credentials"
Consumer Key: xvz1evFS4wEEPTGEFPHBog
Consumer Secret: L8qq9PZyRg6ieKGEKhZolGC0vJZ3Q1z0a4B6A8Zw
Access Token: 370773112-tk5k8d2gOUH2KB8f75xzG3Vr9P9fNrA3nURFPb11
Token Secret: kYjzVBB8Y0mklWf8bFS1C9Ln4J4reF9nnJj6lfF5
```

## OAuth 2.0

Some integrations, such as Google Sheets, include an option to share user credentials across an organization, allowing all users to interact with the resource as the user. This is known as _shared user credentials_.

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

OAuth-based authentication with individual user credentials. Each user is prompted to authenticate with Google using an OAuth flow, and API calls from Retool are made on behalf of the logged-in user. When using apps built using authenticated Google resources, users can only interact with APIs and data to which they have access.

For example, cloud-hosted Retool organizations can grant Retool either **Read and write** or **Read only** access to your [Google Sheets](../guides/integrations/google/google-sheets.mdx) data. This option determines the scopes passed with the OAuth request. Retool recommends **Read and write** so that Retool can read and write spreadsheet data (e.g., create new sheets or update cell rows).

To create other Google API resources, or to use Retool's Google integrations with self-hosted deployments, you create Google Cloud projects and OAuth 2.0 credentials with scopes you define.

OAuth-based authentication with shared user credentials. The user creating the resource is prompted to authenticate with Google using an OAuth authentication flow, and subsequent API calls from Retool are made on behalf of the user that completed authentication. When building apps on top of Google Sheets, _all users_ in a Retool organization can access and edit sheets that have been shared with the user who completed the authentication process.

## OAuth 2.0 custom application

```yaml title="Example credentials"
Client ID: 1234567890-abcdefghijklmnopqrstuvwxyz.apps.googleusercontent.com
Client Secret: ABCDEFGHIJKLMNOPQRSTUVWXYZ123456
Auth URL: https://accounts.google.com/o/oauth2/auth
Token URL: https://oauth2.googleapis.com/token
Redirect URI: https://yourapp.com/oauth2/callback
Scopes: ["https://www.googleapis.com/auth/userinfo.email", "https://www.googleapis.com/auth/userinfo.profile"]
```

### Include Authorization header with OAuth requests

You can also choose to include the client ID and client secret as a Base64-encoded string in the `Authorization` header.

## Session-based

---

## Data protection

To guard against risk, you must properly handle any potentially sensitive data. This includes:

- **Personally Identifiable Information** (PII). Such as:
  - Social security, driver’s license, state identification card, or passport number.
  - Racial or ethnic origin, political opinions, religious or philosophical beliefs, or union membership.
  - The contents of mail, email, and text messages unless a business is the intended recipient of the communication.
  - Genetic or biometric data. Data concerning health or data concerning a natural person’s sex life or sexual orientation.
  - Precise location information (e.g., geolocation data).
  - Any personal information that is not public.
- **Financial information**. Such as:
  - Account login credentials, including financial account, and in combination with any required security or access code, password, or credentials that would grant access to an account.
  - Debit or credit card information, including full card details.
- **Protected health information** (PHI). Such as:
  - Health records.
  - Confidential doctor or patient data.

Sensitive information can be, and often is, subject to strict legal requirements for handling and storage. Although Retool does not have a legal obligation to enforce this, storing these kinds of information may not comply with your own legal or compliance obligations.

Please refer to Retool's [terms and policies](/legal) for detailed information.

---

## Retool AI providers and models

import Support from "../guides/integrations/ai/_support.mdx";

AI providers use _models_ that are trained on specific types of data to make relevant decisions and perform tasks. For example, you would interact with one type of model to generate chat responses and a different model to generate images. AI models are also known as LLMs (large language models).

In general, a model is a collective group of model instances, each of which vary in terms of functionality or data. For example, there are different instances of OpenAI's GPT-4 model, such as `GPT-4o` and `GPT-4o-mini`. You can specify the exact model instance when configuring Retool AI.

Retool [supports a number of AI providers](#available-ai-providers-and-models) and their models for use with AI [actions](../../queries/quickstart.mdx#ai-actions) and [agents](../../agents/quickstart.mdx).

## AI tokens

:::tip Estimate token usage
Use OpenAI's [tokenizer tool](https://platform.openai.com/tokenizer) to calculate how many tokens would result from a passage of text.
:::

AI models use _tokens_, rather than characters or bytes, to represent the commonality of sequences and usage. In general, a single token can equate to approximately four characters.

The text you provide in an AI query is converted by the model into tokens, after which it can generate the necessary response.

## Retool-managed and self-managed models

LLM interactions work by making API requests with an AI provider. As with most other APIs, these requests require authorization credentials, such as an API key. Retool provides access to certain AI models using Retool-managed keys.

A Retool-managed LLM connection enables you to start building and testing with AI models straight away without needing any additional tools or services. Once you're ready to use your AI actions or agents in production, you then need to provide your own authorization credentials. The connection then becomes self-managed.

For instance, you can immediately start building an agent using `GPT-4o-mini` with the Retool-managed OpenAI connection. Once your agent is ready for use, you then update the OpenAI connection and provide your own OpenAI API key.

:::info
Some AI models are only available for use as self-managed connections.
:::

## Available AI providers and models

Retool supports a number of [AI providers](models.mdx) and their models for use with [AI actions](../../queries/concepts/actions.mdx) and [agents](../../agents/index.mdx). Agents only support models that allow tool creation. Refer to the following information to learn which models are supported with AI actions or agents.

### OpenAI

import OpenAi from "../../_partials/_ai/_models/_openai.mdx";

### Anthropic

import Anthropic from "../../_partials/_ai/_models/_anthropic.mdx";

### Google Gemini

import Gemini from "../../_partials/_ai/_models/_gemini.mdx";

### Azure OpenAI

Rather than selecting from a predefined set of models, you create and deploy an Azure OpenAI service with a [specific model](https://learn.microsoft.com/en-us/azure/ai-services/openai/concepts/models). You then provide the endpoint and model name when configuring the API credentials. Refer to [Connect to Azure OpenAI](../guides/connect/azure-openai) for how to get started.

Retool charges a flat-rate hourly fee with the self-managed LLM key [model price](#retool-agents-pricing) for Azure OpenAI.

### Amazon Bedrock

Amazon Bedrock is a managed service that can be configured for different AI models, such as Anthropic or Cohere models. The models available for use with Retool AI depend on the models you configure for Bedrock.

### Baseten

import Baseten from "../../_partials/_ai/_models/_baseten.mdx";

### Custom AI provider

You can connect a [custom AI provider](../../data-sources/guides/integrations/ai/custom-ai-provider.mdx) to Retool that adheres to an OpenAI, Anthropic, Google, or Cohere schema.

## AI usage rate limiting

Retool imposes the following rate limits on Retool-managed key usage. Rate limits are per organization, per hour (over a rolling time window).

| Feature                          | Hourly rate limit  |
| -------------------------------- | ------------------ |
| Retool Agents                    | 20,000,000 tokens  |
| Assist                           | 100,000,000 tokens |
| All other AI functionality [^ai] | 250,000 tokens     |

[^ai]: Including, but not limited to: [AI actions](../../queries/concepts/actions.mdx), [Ask AI](../../queries/concepts/ask.mdx), [AI-generated READMEs](../../apps/guides/app-management/app-documentation.mdx), [Retool Vectors](../quickstarts/retool-vectors.mdx), and the [LLM Chat component](../../apps/guides/forms-inputs/chats/llm-chat.mdx).

This rate limit is intended to prevent abuse of resources and to limit Retool-managed key usage to non-production instances. Each AI provider also imposes their own rate limits, which also apply to Retool users.

If you encounter a rate limit imposed by Retool or by an AI provider, you will receive a `429` error with a message describing the kind of rate limit that was hit.

Rate limits are cumulative, and they encompass all AI usage. For example, if you are using [Vectors](../guides/vectors/index.mdx), you may reach this limit very quickly. These rate limits apply to any customer using Retool-provided keys, regardless of deployment method or plan type. Retool is unable to make exceptions to or raise this rate limit.

If you do not wish to be subject to Retool-imposed rate limits, or are ready to use AI in production, [configure AI platforms](../guides/integrations/index.mdx) to use your own API credentials. Self-managed connections are not subject to Retool-imposed rate limits.

## Model usage and pricing

Retool's pricing for AI model usage differs between Retool features.

### Assist pricing

Refer to the [pricing page](https://retool.com/pricing) for information about Assist usage and pricing.

### Retool Agents pricing

Usage for [Retool Agents](../../agents/index.mdx) is measured by _hour_, and the hourly rate differs for Retool-managed LLMs and self-managed LLMs. Refer to the [Agents billing and usage](/support/billing-usage/agents) support documentation for more information.

Retool provides access to [OpenAI](https://openai.com), [Anthropic](https://www.anthropic.com), and [Baseten](https://www.baseten.co) AI models for Agents with a Retool-managed key.

Retool uses an hourly rate for billable usage of managed LLM connections. The exact cost varies depending on provider costs, as shown in the table below.

You can provide your own authorization credentials for each AI provider and the models supported by Retool. Retool also supports the use of [custom AI providers](#custom-ai-provider), allowing you to make use of many more models.

Once you are ready to use Retool Agents in a production environment, you must provide your own credentials. This ensures that your agents aren't restricted by the Retool-managed key limits.

To simplify billing, Retool charges a flat-rate hourly fee when using a self-managed LLM connection, as shown in the **Self-managed LLM/key** entry of the table below.

import Partials from "/docs/_partials/_agents-pricing.mdx";

:::note
Refer to [Agent usage](/support/billing-usage/agents) for more information about [Billing and usage](/support/billing-usage) for Retool Agents.
:::

---

## Retool Database usage and limits

Cloud-hosted organizations can store the equivalent of 5GB of PostgreSQL data, with unlimited tables and rows. The amount of storage space your data uses is dependent on how many records, fields, and tables you use, and the size of values. If you exceed your storage limits, reach out to Retool to request a limit increase.

For cloud-hosted organizations on the Free plan, Retool automatically pauses the Retool Database service after one month of inactivity. Any existing connection strings will no longer work. Once you start using Retool Database again, updated connection strings are available.

:::info
Retool Database is designed to be a convenient way to store data to use within or outside of Retool. It is not designed to be a highly-available, scalable database service, and you should use a separate managed database provider if your use case requires these guarantees.
:::

## Data redundancy

Retool Database uses multiple levels of redundancy, which include daily backups of all data in a PostgreSQL cluster managed by our cloud provider. Retool retains each of these backups for 7 days. Retool recommends implementing a secondary backup process that stores and retains data for a longer period of time as an additional guardrail.

If you have any questions or would like to know more, [contact Retool Support](/support).

## Staging data

Any changes you make with data in Retool Database cannot be reverted. Retool recommends using [multiple environments](../../org-users/guides/configuration/environments.mdx) with staging data to avoid accidental loss of data.

---

## Data streaming

Retool supports streaming data from resources for some data sources using [pull mechanisms](https://en.wikipedia.org/wiki/Pull_technology). When pulling data from resources, the Retool UI incrementally updates as soon as a row or chunk of data arrives. Without streaming, the entire data payload must be downloaded before it renders. Depending on network latency, bandwidth, and the size of the data, streaming can improve performance and user experience.

## Stream with Retool AI actions

Streaming is enabled by default for the [generate text](../../queries/concepts/actions.mdx#generate-text), [summarize text](../../queries/concepts/actions.mdx#summarize-text), and [generate chat response](../../queries/concepts/actions.mdx#generate-chat-response) actions. The `.data` properties of these Retool AI queries are continuously updated.

## Stream PostgreSQL responses

To enable streaming in PostgreSQL responses after you gain access, check the **Stream response data and update app model incrementally** checkbox in the **Advanced** tab of the query editor.

When streaming is enabled, a query's `.data` property updates one or more times, each with the latest partial download of the query response while it downloads. Each update is always a set of complete rows of data, so `.data` always spans from rows `1-N`, where `N` is the latest row received.

Without streaming, the `.data` property updates to the result of the query once, after the full download is complete.

---

## Resources concept guides

import Concept from '/docs/_partials/_doctypes/_concept.mdx';

:::tip Get started

If you want to connect your data to Retool:

- Read the [quickstart](./quickstart) to learn about the fundamental concepts.
- Follow a [tutorial](./tutorial/) to connect your data sources or use Retool's built-in solutions.

:::

---

## Configure API authentication

Retool supports many types of API authentication. You can use static authentication tokens or create auth that asks the internal user to provide credentials each time they access the application.

If none of the following options work for your API, you can use [custom API authentication](custom.mdx).

## API authentication

You can add authentication details for an API by navigating to the **Authentication** section of the Resource settings page.

This lists all the authentication types Retool support natively, and **Custom Auth** to create custom or multi-step flows.

### OAuth 2.0

Retool also supports the OAuth 2.0 authentication scheme. In OAuth 2.0, authentication details are _not_ shared between your internal users unless you enable the **Share OAuth2.0 credentials between users** option.

When the share credentials option is disabled, each of your internal users will be required to authenticate via the OAuth authentication flow. The Access/Refresh token that is returned by the OAuth identity provider will be encrypted and then associated with the user's current session with Retool. This allows you to delegate authorization and authentication to the OAuth Identity provider. If needed, you can set the token's lifespan in the **Advanced** > **Access token lifespan** field.

Here is a sample configuration of Retool connecting with Google's OAuth 2.0 API. Things to take note of:

- We added the header: `Authorization: Bearer OAUTH2_TOKEN` - the `OAUTH2_TOKEN` is a magic placeholder string that gets replaced with the access token at runtime. You can use this magic string in the header or in the URL parameters of the query.
- The OAuth callback URL is static and cannot be directly changed. Self-hosted organizations can dynamically set the callback URL, however, as the URL's domain corresponds to the value for the [BASE_DOMAIN](../../../self-hosted/reference/environment-variables/index.mdx#property-BASE_DOMAIN) environment variable.

### Cookie-based APIs

Retool also supports APIs that use cookies for authentication. In this scenario, the API authorizes a session by responding with a `Set-Cookie` header that contains an authorization token. The API then expects all future authenticated requests to send that same authorization token in the `Cookies` header.

Though Retool proxies all HTTP requests through the backend, Retool supports forwarding the cookies set by the API to the user's browser. This includes attributes such as the expiration date. The cookies are then stored in a `HTTPOnly` cookie in the user's browser, which is tied to the lifecycle of the user's current session. All future requests the user makes to the API have the same cookie added to their request.

To configure this, tell Retool the name of the cookie that should be forwarded onto the user's browser. You can also specify a URL to check the user's authentication status.

After you configure the cookies, you must create a login page in Retool that asks the user for authentication details and makes an API request to the login endpoint. After a successful login, the authentication cookie is parsed from the response and forwarded along onto the user's session.

#### Double cookie submit pattern

You can implement the double cookie submit pattern by passing a header with the prefix `COOKIE_`.

#### Forwarding cookies that are pre-set on your domain

:::note

Forwarding pre-set cookies is only available on [Self-hosted Retool](../../../self-hosted/index.mdx).

:::

You can automatically forward specific cookies that are pre-set on the domain you are running Retool on. For example, say you have Retool hosted on `retool.yourdomain.com` and you want to automatically forward cookies named `someCookie1` and `someCookie2` that are set on the `yourdomain.com` domain.

First, you'll need to add these cookies to an allow-list with an environment variable. If you want to allow forwarding for multiple cookies, add them as a comma-separated string as below.

```
FORWARDABLE_SAME_DOMAIN_COOKIES_ALLOWLIST=someCookie1,someCookie2
```

Next, in the resource settings page for the resource that should forward these cookies, add the cookies in the `List of cookies to forward` section, as below.

`someCookie1` and `someCookie2` will now automatically be forwarded for this resource whenever you make a request. If you want to include one of the cookies in a header, you can follow the double cookie submit pattern (`COOKIE_someCookie1`) described [above](./api.mdx#double-cookie-submit-pattern).

### Pass OpenID SSO provider tokens to API requests

If you use SSO with OpenID, Retool allows you to use the JWT obtained from the SSO process in your API requests. You can use environment variables that were set up when integrating Retool with your OpenID SSO provider by following the guide to [Custom OIDC SSO](../../../sso/tutorials/custom/oidc.mdx#reference-jwt-claims-in-retool-apps).

### AWS v4 signature-based authentication

You can also sign your API Requests using Amazon's v4 Signature Signing Process. To do that, you need to specify your AWS Region, Service Account Key, and Secret Key.

The AWS Service is an optional field that will be extracted from the base URL if left empty. Normally, the service corresponds to the subdomain of your API. For example, if you are making a request to a service hosted at `https://xyzabc.execute-api.us-east-1.amazonaws.com`, then your service should be `xyzabc.execute-api`.

For AWS v4, you can pass the authentication information in the query params or the `Authorization` header. By default, the **Authenticate using the HTTP Authorization header instead of query parameters** option is checked, as many AWS services only support authentication using the header.

---

## Custom API authentication

While Retool supports many [authentication standards](api.mdx) out of the box, you can also configure custom authentication flows with multiple steps for virtually any kind of API authentication.

All API resource authentication methods apply to [REST](../integrations/api/rest.mdx), [GraphQL](../integrations/api/graphql.mdx), [OpenAPI](../integrations/api/openapi.mdx), and [gRPC](../integrations/development/grpc.mdx) resources.

:::warning Custom authentication in public apps

Like OAuth 2.0 and other SSO based auth options, custom auth workflows store variables related to the authenticating user's Retool account. Because public app viewers do not use a Retool account, custom auth is not supported in public apps.

:::

This guide walks through building an example authentication flow. The API in the example returns an authentication token that's used in future requests. Users authenticate individually, so credentials aren't shared.

## 1. Create a REST API resource

On the **Resources** page in Retool, create a **REST API** resource, name it, and then click **Create resource**.

Navigate back to the resource configuration page after creating the resource.

## 2. Select an authentication method

At the bottom of the form, select **Custom Auth** as the authentication method.

## 3. Add a step to collect a username and password

Click the **Add new step to the auth workflow** and then select **Form (modal)**. By default, the step is configured for an email and password.

To test the step, click **Save changes** and then **Test auth workflow**.

Enter any email and password, and then submit the form. A debugging interface is displayed that shows the scope of what can be used in subsequent steps.

## 4. Add a step to retrieve an authentication token

Create another step and select **API Request**. Configure the step to make an API request to your server to obtain an authentication token.

This example sends a request to the `https://httpbin.org/post` endpoint, which returns the same data passed in the request.

When you save and click **Test auth workflow**, you'll see the new scope which includes the response payload from the API request.

:::note Error messages for invalid logins

If a user submits an invalid email and password combination, you should alert them that something went wrong. By default, Retool notifies the user with a stringified version of the JSON returned by your endpoint if your endpoint returns an error code. If your endpoint does not return valid JSON, Retool displays the returned data in the notification. For example, your endpoint could return something like `res.status(401).send({ error: 'Invalid username or password' })`.

:::

## 5. Define variables to include in requests

You can write JavaScript to interact with previous inputs in your custom auth flow. For example, you can pass variables defined in previous steps (e.g., `HTTP_BODY_MESSAGE`), as well as objects from the scope (e.g., `http1.headers`)

Create another step and select **JavaScript**.

Click **Save changes** and then click **Test auth workflow**. You can see the updated scope, response payload, and the JavaScript query results in the log.

:::note Custom authentication in workflows

If you intend to perform custom authentication using a workflow, you can only use [built-in JavaScript libraries](https://docs.retool.com/workflows/guides/blocks/javascript#available-libraries).

:::

## 6. Save the authentication token

Create a new step and select **Define a variable**. The **Variable name** is a string used to refer to the authentication token, and the **Value of the variable** is an expression that interpolates to the authentication token.

In this example, the `PASSWORD` variable is defined as the password that's echoed back by the server.

## 7. Pass the authentication token

Pass the defined variable from step five as a header. Scroll back up and then configure the **Headers** section like this:

Make sure to save the final configuration.

## 8. Use the resource in an app

There are a few different ways to use a resource with custom auth in an app.

### Add a login button

Create a new test app, and then add an **Auth Login** component. In the **Custom auth Resource** field, select the API resource you created.

Click the button to test the auth flow. Retool makes the API request using the resource you configured, and then securely associates the authentication token with your current session. All subsequent API requests will contain the authentication header.

### Use a login verification URL

You can also automatically prompt users to log in to your API. Navigate to the resource configuration page, and scroll down to the **Use a login test URL** checkbox. Enable the option, then set this to an endpoint that returns a response code in the 200-299 range when the user is authenticated, and a non-2xx status code (e.g., 401 Unauthorized) when the user is not authenticated.

When a Retool app that's connected to this resource first loads, it prompts the user to authenticate if they haven't already.

:::note Run auth automatically

If you set an auth login URL or a login timeout, users are prompted with a modal with the option to authenticate to any resources that have custom authentication enabled. If you want authentication to be triggered automatically instead, select the **Run this custom auth workflow without prompting the user** toggle on the resource configuration page.

:::

### Refresh auth workflow

You can configure a set of custom authentication steps that run automatically after any non-200 response when querying a resource. This is useful for refreshing a user's authentication session without them needing to refresh the page.

For example, if a user has been idle for some period of time and then attempts to query your resource, and their session has expired, the resource returns a 401 or 403 error code. Instead of returning an error, Retool can perform a refresh auth workflow that you define. If the refresh auth workflow is successful, Retool attempts to run the failed query again. Because the user now has a valid authentication session, the second attempt to run the query will succeed and the user can continue using the app without interruption.

You can also trigger this refresh auth flow based on a timeout (in seconds). Navigate to the resource configuration page, and scroll down to the **Refresh Auth trigger** dropdown. Select **Time-based expiration** and set the timeout value. Users are then prompted to login if they have not logged in within the amount of time you specify. This value can be set to a constant number or it can be set dynamically using a variable from a **Define variable** step.

Additionally, you have the option to trigger this refresh auth flow every time a query is run. In order to do so, select **Every query run** from the dropdown.

---

## Authenticate with Google APIs using OAuth 2.0

In some cases, you may need to use OAuth 2.0 credentials for a Google Cloud project. These can include:

- Accessing Google Sheets from a self-hosted deployment.
- Creating a resource to use a Google API for which Retool does not have a built-in integration.

If you are already using [Okta SSO using OpenID Connect](../../../sso/tutorials/okta/oidc.mdx) (OIDC), you can safely authorize Google SSO without presenting an additional sign in method. Retool only displays one SSO button on the login page and Okta has priority over Google when both are enabled.

## Prerequisites

This guide assumes you have an existing Google Cloud project. If not, [create a new project](https://console.cloud.google.com/projectcreate) first.

## Create OAuth 2.0 credentials

Follow Google's instructions on [creating OAuth client ID credentials](https://developers.google.com/workspace/guides/create-credentials#oauth-client-id). Use the following information to configure it for use with Retool. 

| Setting | Value |
| --- | --- |
| **Application type** | **Web application** |
| **JavaScript origin URI** | The base URL you use to access Retool (e.g., `https://example.retool.com` or `https://retool.mycompany.com` | 
| **Authorized redirect URIs** | `BASE_URL/oauth/oauthcallback` and `BASE_URL/oauth/user/oauthcallback`. `BASE_URL` is `http://oauth.retool.com` for Retool Cloud, and on Self-hosted Retool it is your organization's domain. | 

Once complete, Google displays the client ID and secret, and also makes it available for download in JSON format. You use these credentials to create Google API resources in Retool. 

## Enable APIs and define scope

Before you can create a resource in Retool, you must enable the desired APIs and define the scope of access that the credentials will request from users. 

First, enable any APIs you wish to use with this project from the [API library](https://console.cloud.google.com/apis/library). These will be accessible using the OAuth credentials once you define their scope.

Next, follow Google's guide to [configure the OAuth consent screen](https://developers.google.com/workspace/guides/configure-oauth-consent?hl=en) and define the scopes with which the OAuth credentials will request for any enabled APIs. For example, the `auth/calendar/events` scope for the Google Calendar API would allow Retool to view and edit all calendar events once a user completes authorization.

## Create a REST API resource

You can now create [REST API resources](../integrations/api/rest.mdx) for Google APIs, such as the [Google Calendar API](https://developers.google.com/calendar/api/guides/overview), with the following settings.

:::note

Google requires the URL parameter `access_type=offline` to obtain refresh tokens, so you should include these in your Authorization URL variable. Set the **Prompt** value to **Consent** to include `prompt=consent` in the URL automatically.

:::

| Setting | Value |
| --- | --- |
| **Base URL** | The base URL of the API (e.g., `https://www.googleapis.com/calendar/v3`). |
| **Headers** | A key-value pair set to `Authorization` and `Bearer OAUTH2_TOKEN`. |
| **Authentication type** | **OAuth 2.0**. |
| **Authorization URL** | `https://accounts.google.com/o/oauth2/v2/auth?access_type=offline` |
| **Access token URL** | `https://oauth2.googleapis.com/token` |
| **Client ID** | The client ID provided by Google. |
| **Client secret** | The client secret provided by Google. |
| **Scopes** | A space-separated list of scopes (e.g., `https://www.googleapis.com/auth/calendar.events`). |
| **Prompt** | **Consent**. |

---

## Configure resource authentication



---

## Use Kerberos authentication with Microsoft SQL Server resources

Self-hosted organizations can update their Retool deployments to use Kerberos authentication with Microsoft SQL Server resources. This requires creating the necessary Kerberos configuration file and making changes to the deployment configuration.

## 1. Prepare the Kerberos configuration file

This configuration file contains the required information to implement Kerberos authentication. Create a file named `krb5.conf` and use the following template, replacing placeholders with values for your environment.

```shell
[libdefaults]
    default_realm =                  # e.g., http://EXAMPLE.COM 
    dns_lookup_realm = false                      # optional
    dns_lookup_kdc = false                        # optional
    ticket_lifetime = 24h                         # optional
    renew_lifetime = 7d                           # optional
    forwardable = true                            # optional

[realms]
     = {                            # e.g., http://EXAMPLE.COM 
        kdc =               # e.g., kdc.example.com
        admin_server =      # e.g., kdc.example.com
    }

[domain_realm]
     =                 # e.g., corp.local = http://EXAMPLE.COM 
    . =                # e.g., .corp.local = http://EXAMPLE.COM 

[logging]
    default = FILE:/var/log/krb5.log            # Log file for Kerberos
    kdc = FILE:/var/log/kdc.log                 # Log file for KDC operations
    admin_server = FILE:/var/log/kadmind.log    # Log file for admin server
```

## 2. Add the configuration to your deployment

Update the deployment's `Dockerfile` to reference the Kerberos configuration file. 

```shell
FROM tryretool/backend:X.Y.Z

# section:begin - copy krb5.conf

# Switch to root to add Kerberos configuration
USER root

# Copy Kerberos configuration into the container
COPY krb5.conf /etc/krb5.conf  # Ensure the destination path is correct

# Switch back to the application user
USER retool_user

# section:end - copy krb5.conf

# Start the Retool API
CMD ./docker_scripts/start_api.sh
```

If you use a Kubernetes-based deployment, you must create a `Dockerfile` build the image, and push it to the registry.

Update the deployment's new `Dockerfile` to reference the Kerberos configuration file.

```shell
# section:begin - copy krb5.conf

# Switch to root to add Kerberos configuration
USER root

# Copy Kerberos configuration into the container
COPY krb5.conf /etc/krb5.conf  # Ensure the destination path is correct

# Switch back to the application user
USER retool_user

# section:end - copy krb5.conf
```

Once complete, restart your deployment for the changes to take effect.

## 3. Configure the SQL Server resource

A Kerberos _principal_ is the unique identity that represents a user, service, or host. It is comprised of three parts.

| Part | Description | Example |
| --- | --- | --- |
| Primary | The name of the user, service. | `jenny_appleseed` or `HTTP` |
| Instance | An optional part used to distinguish principals that share the same primary name. This is commonly used for specific services (e.g., the host for machine accounts). If omitted, it defaults to the primary user principal. | `admin` |
| Realm | The domain-like boundary that the principal belongs to, typically written in uppercase. | `EXAMPLE.COM` |

A complete principal is formatted as `primary/instance@REALM`. To use Kerberos authentication with SQL Server resource, set the **Database username** to the Kerberos principal. 

## Troubleshoot Kerberos authentication

Use the following guidance to troubleshoot connection issues to SQL Server resources when using Kerberos authentication.

### Verify Service Principal Name (SPN)

The SPN identifies the service instance within Kerberos. This must be the same value as the SQL Server's FQDN. You can use Powershell to verify the SPN on the SQL Server host machine.

```
setspn -L COM\
```

```title="Example output"
# Example output
# MSSQLSvc/sqlserver.example.com:1433 
```

### Check the credential cache

Kerberos uses a cache to store tickets for authentication. This cache is relied upon by other tools, such as `kinit` and `sqlcmd`.

#### Inspect tickets

Use `klist` to inspect the Kerberos ticket cache and default principal.

```
klist
```

```text title="Example output"
Ticket cache: FILE:/tmp/krb5cc_1000
Default principal: custom_user@EXAMPLE.COM
```

#### Clear the cache

Use `kdestroy` to clear the cache.

```
kdestroy
```

#### Set the cache location

You can specify a different location by updating the `KRB5CCNAMME` environment variable.

```
export KRB5CCNAME=/tmp/custom_kerberos_cache
```

### Enable trace logging

You can enable detailed trace logs to help troubleshoot Kerberos authentication issues with the `KRB5_TRACE` environment variable.

```
export KRB5_TRACE=/tmp/kerberos_trace.log
```

Trace logs are available using `kinit` and with other tools that use Kerberos.

To add these to the container, update the `Dockerfile` to include additional environment variables.

```
ENV KRB5CCNAME=/tmp/krb5cc_cache
ENV KRB5_TRACE=/dev/stdout
```

Once set, all trace logs output to container logs. Retool recommends this approach if you need to troubleshoot Kerberos issues.

---

## Import resources from AWS

You can import AWS resources into Retool to autogenerate their configurations. This includes:

- Amazon S3
- PostgreSQL
- MySQL
- Microsoft SQL

After importing, you complete the configuration form and create the resource in Retool.

## Requirements

To import resources from AWS, you need:

- IAM credentials (an AWS IAM access key and secret) that support listing S3 buckets and Amazon Relational Database Service (RDS) resources.
- An IAM policy that's attached to a user or group within AWS with proper access.

See [Creating IAM policies](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_create.html) and [Add or remove identity permissions](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_manage-attach-detach.html#add-policies-console) for details on obtaining this information.

When you create the IAM policy, make sure it includes the `rds:DescribeDBInstances` and `s3:ListAllMyBuckets` actions.

```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "VisualEditor0",
      "Effect": "Allow",
      "Action": ["rds:DescribeDBInstances", "s3:ListAllMyBuckets"],
      "Resource": "*"
    }
  ]
}
```

## 1. Add IAM credentials

The first time you import an AWS resource, you're prompted for AWS credentials. After adding your credentials, you don't need to enter them again to import other resources.

1. Navigate to the [Resources page](https://login.retool.com/auth/login?source=docs&redirectOnLogin=resources).
2. Click **Create new** > **From AWS**.
3. Enter your AWS IAM access key and your AWS IAM secret.
4. Click **Set up**.

## 2. Select the resource to import

After adding your AWS credentials, select the resource to import.

1. Select the resource type.
2. Select the **AWS Region** and the **S3 Bucket** or **Database** to import.
3. Click **Import**.

## 3. Create the resource

After importing the settings, Retool opens the resource configuration page with values populated by the import. Retool has resource-specific [connection guides](../index.mdx) if you need guidance on completing the configuration. After verifying the settings are correct, click **Create resource**. You can now query this resource from your apps.

## Use autofill to update resources

There is an **Autofill using** > **AWS** feature on resource configuration pages you can use to update the **AWS Region**, **S3 Bucket**, and **Database** fields. You can also use this option when creating a resource if you know the resource type you want to use ahead of time.

## Manage IAM credentials

You can manage IAM credentials on the [Settings](https://login.retool.com/auth/login?source=docs&redirectOnLogin=settings) page. Select **IAM credentials** in the sidebar, and then update or delete credentials as needed.

---

## Configure resource connections



---

## Configure Retool outbound regions for Retool Cloud

By default, traffic routes through the `us-west-2` region, based in Oregon, US. Retool’s European infrastructure is hosted in Frankfurt (AWS’s `eu-central-1` region), while our Asia-Pacific infrastructure is hosted in Singapore (AWS's `ap-southeast-1` region). You can select an outbound region that is closest to your resource and reduce query latency.

:::info

Outbound regions do not affect where Retool stores your applications or data. Queries run through Retool's primary region in `us-west-2` regardless of the outbound region you have set.

:::

## Update inbound firewall rules

import Ips from '../../../_partials/_retool-ips.mdx'

## Set a default outbound region

Use the following steps to set a default region from which Retool accesses your data sources.

1. Go to your organization's [Advanced](https://login.retool.com/auth/login?source=docs&redirectOnLogin=settings/advanced) settings.
2. In **Other Options** > **Default Retool outbound region**, select **Set Region**.
3. Choose your preferred default region. Confirm you've added the necessary IP addresses to your allowlist if your organization enforces inbound firewall rules.
4. Save the region.

## Override default outbound regions

Use the following steps to set the outbound region for an individual resource. This overrides the organization default.

1. Go to the resource's configuration page.
2. In **Advanced options**, select **Override default outbound Retool region**. If you don't see this setting, [reach out](https://docs.retool.com/page/contact-support) to the Retool team.
3. Select your region in the **Outbound Retool Region** setting.
4. If it's available on your resource, select **Test Connection** to confirm your resource still works.
5. Save your changes. Your resource now automatically uses the selected region.

---

## Configure SSH tunneling for resources

Retool supports SSH tunneling for the following data sources if they are hosted on a private network:

- [PostgreSQL](../integrations/database/postgresql.mdx)
- [MySQL](../integrations/database/mysql.mdx)
- [Microsoft SQL Server](../integrations/database/microsoft-sql-server.mdx)
- [MongoDB](../integrations/database/mongodb.mdx)
- [Cassandra](../integrations/database/cassandra.mdx)
- [Redis](../integrations/database/redis.mdx)
- [Vertica](../integrations/database/vertica.mdx)
- [RethinkDB](../integrations/database/rethinkdb.mdx)

:::info Connect without tunneling

Retool is building support for querying firewalled resources without SSH tunnels and firewalled resources that do not support SSH. To learn more or be considered for early access, contact cloud-connect@retool.com.
:::

## Configure SSH tunneling

You can configure SSH tunneling when creating a new resource or update the configuration of an existing resource. To update an existing resource, navigate to the **Resources** tab in your Retool organization settings, then select the resource to update.

1. On your resource's configuration page, select the **Enable SSH tunnel** checkbox in the **Advanced Options** section.

2. Enter the **Bastion host** and **Bastion port** with which Retool connects, then download Retool's public key. If you have multiple Retool organizations, download the public key for each organization you want SSH access for. Retool will attempt to connect to your bastion host with the corresponding private keys and the username `retool`.

3. Configure your bastion host to allow connections from Retool.

4. Create a user account for Retool. Below is a sample script run for different environments.

```shell title="Ubuntu"
ec2-user@bastion:~$ sudo adduser retool --disabled-password
Adding user `retool' ...
Adding new group `retool' (1003) ...
Adding new user `retool' (1003) with group `retool' ...
Creating home directory `/home/retool3' ...
Copying files from `/etc/skel' ...
Changing the user information for retool3
Enter the new value, or press ENTER for the default
Full Name []:
Room Number []:
Work Phone []:
Home Phone []:
Other []:
Is the information correct? [Y/n] y
```

```shell title="Amazon Linux"
# Do not create a password for the retool user
ec2-user@bastion:~$ sudo adduser retool --password NP
```

To authorize Retool to connect to the host, add the contents of the public keys from step two on a new line in `/home/retool/.ssh/authorized_keys`.

```shell
# Login as root
sudo su

# Create the authorized_keys file if it does not exist yet
mkdir -p /home/retool/.ssh
touch /home/retool/.ssh/authorized_keys

# Use your favorite editor to add Retool's public key to the file
vim /home/retool/.ssh/authorized_keys

# Set permissions on the authorized_keys file
chmod 644 /home/retool/.ssh/authorized_keys

# Change owner of authorized_keys file to Retool
chown retool:retool /home/retool/.ssh/authorized_keys
```

If you want to minimize access to your servers, add Retool's [IP addresses to your allowlist](../../reference/ip-allowlist-cloud-orgs.mdx).

5. Once that has been successfully configured, you can now use your database's private IP address within the rest of the connection form.

### SSH tunneling with OpenSSH 8.7 and newer

Retool's public key is generated using `ssh-rsa`. This was deprecated in [OpenSSH 8.8](https://www.openssh.com/txt/release-8.8), but OpenSSH 8.7 can also be affected. If you are using this or a newer version of OpenSSH, add the following line to your `sshd_config` file to allow this type of key:

```
PubkeyAcceptedKeyTypes +ssh-rsa
```

Ensure that you restart your SSH server once you save your changes.

### Self-hosted Retool deployments

The above steps should also work in most on-premise deployments - Retool in most cases will auto-provision your environment with a keypair.

Self-hosted Retool also supports the use of custom SSH keys and usernames. To configure these, create a volume mount for the `/retool_backend/keys` directory in the Retool container, and add any private key you wish to use from within Retool into this directory. For example, if you want to use `myprivatekey.pem`, the SSH tunnel configuration for the resource would resemble the following:

:::note

Refer to the [rotate SSH keys](../../../self-hosted/guides/rotate-ssh-keys.mdx) guide for instructions on key rotation. After you download the public key, follow the steps in **Configure SSH tunneling** to add it to `authorized_keys`.

:::

### Debug common connection errors

```
All configured authentication methods failed.
```

This error usually means Retool is able to reach the SSH host, but can't authenticate. Confirm that you have created a _retool_ user and the Retool public key has been added to your authorized keys.

```
Channel open failure: Connection refused
```

This error occurs when the SSH tunneling config is working but the host/port you tried to connect to has refused the connection.

```
Could not establish a connection. Try checking your database firewall configuration and whitelisting Retool's IP address.
```

This error usually occurs when you run into a firewall or other configurations aren't properly setup. For example, trying to connect Postgres to an HTTP port, incorrect SSH tunnel configs or the database host/port are wrong. Try going through the steps below to identify the specific error:

1. Did you create a _retool_ user on your SSH host and add the public key?
2. If you have access to the SSH host, try connecting Retool while monitoring the auth logs (`tail -f /var/log/auth.log`). if you're not seeing any connection attempts, then you may not have whitelisted Retool's IP.
3. While debugging, use the proper SSH tunnel configs, but set the database configs to something bogus, e.g. localhost:5555. If the SSH tunnel is fine, you should see the "Connection refused" error, and you'll know that your database configs are the problem, not the SSH tunnel configs.

#### Slow queries or timeouts

Connections between Retool and the bastion host may be throttled. If queries are timing out or slow to resolve, add the following line to your `sshd_config` file.

```
MaxStartups 1000:1000:1000
```

---

## Configure SSL connections for data sources

Retool supports SSL and TLS connections to database resources as long as the database server is configured to support it.

The following resource types have options for SSL/TLS encryption in their configuration settings:

- [AlloyDB](../integrations/database/alloydb.mdx)
- [Cassandra](../integrations/database/cassandra.mdx)
- [CouchDB](../integrations/database/couchdb.mdx)
- [ElasticSearch](../integrations/analytics/elasticsearch.mdx)
- [GraphQL](../integrations/api/graphql.mdx)
- [gRPC](../integrations/development/grpc.mdx)
- [Microsoft SQL](../integrations/database/microsoft-sql-server.mdx)
- [MongoDB](../integrations/database/mongodb.mdx)
- [MySQL](../integrations/database/mysql.mdx)
- [Postgres](../integrations/database/postgresql.mdx)
- [Redshift](../integrations/database/amazon-redshift.mdx)
- [Redis](../integrations/database/redis.mdx)
- [REST API](../integrations/api/rest.mdx)
- [RethinkDB](../integrations/database/rethinkdb.mdx)

## Connect using SSL/TLS

To connect with SSL, on the **Create resource** or **Edit resource** form, select the **Use SSL/TLS** checkbox. Depending on the resource, additional fields are shown once the checkbox is clicked. The standard options are **CA Certificate**, **Client Key**, **Client Certifcate**, and **Verification mode**.

For **API Resources**, specify an **HTTPS** base URL before clicking the **Use self-signed certificates** checkbox to add TLS options.

**CA Certificate** is a certificate signed by a trusted, third-party certificate authority (CA). The client, which is Retool in this case, uses the certificate to verify that they are talking to the correct server. **Client Key** and **Client Certificate** are additional fields that identify the client to the server.

### Verification modes

The following table lists the available **Verification mode** options:

| Verification mode                    | `psql` equivalent | Description                                                                                               |
| ------------------------------------ | ----------------- | --------------------------------------------------------------------------------------------------------- |
| **Full verification**                | `verify-full`     | Verifies the server host matches the name stored in the server certificate and checks the CA certificate. |
| **Verify CA Certificate**            | `verify-ca`       | Verifies the server by checking the certificate chain up to the root certificate stored on the client.    |
| **Skip CA Certificate verification** | `require`         | Establishes an encrypted connection without CA certificate verification.                                  |

Retool uses Node drivers to power our resources, and occasionally, the drivers are limited in their functionality. As a result, not all resources support all modes. For example, MySQL only supports **Verify CA Certificate** and **Skip CA Certificate verification**.

---

## Connect to Amazon Bedrock

import Intro from "./_intro.mdx";

## Supported models

import Support from './_support.mdx';

Amazon Bedrock is a managed service that can be configured for different AI models, such as Anthropic or Cohere models. The models available for use with Retool AI depend on the models you configure for Bedrock.

## Set up your Amazon Bedrock credentials

import Configure from '../_partials/_ai-configure.mdx';

Amazon Bedrock requires the following credentials:

- **AWS IAM access key ID**.
- **AWS IAM secret access key**.
- **AWS Region**.

You can also provide an optional **AWS IAM Session Token**, if required. Log in to the [AWS IAM dashboard](https://us-east-1.console.aws.amazon.com/iamv2/home?) to obtain your IAM credentials.

:::note

Retool recommends using an AWS-managed policy instead of building one from scratch. Refer to the [AWS managed policies for Amazon Bedrock](https://docs.aws.amazon.com/bedrock/latest/userguide/security-iam-awsmanpol.html) documentation for more information.

:::

---

## Connect to Amazon Knowledge Base

Retool supports [Amazon Knowledge Bases](https://docs.aws.amazon.com/bedrock/latest/userguide/kb-how-it-works.html) as a [vector store](../../../quickstarts/retool-vectors.mdx) for Retool AI. Once configured, you can use an Amazon knowledge base as an alternative to Retool Vectors.

## Prerequisites

To import an Amazon knowledge base for use with Retool AI, you need:

- The knowledge base name.
- The knowledge base ID.
- To [connect to Amazon Bedrock](./amazon-bedrock.mdx) in Retool AI.

Refer to the [Amazon Knowledge Bases documentation](https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base-create.html) to learn more about creating a knowledge base and obtaining these credentials.

## Add the Amazon knowledge base to Retool

To import the Amazon knowledge base:

1. Sign in to Retool and navigate to the **Resources** tab, then select **Retool Vectors**.
2. Click **Create new** and select **Import from Amazon Knowledge Bases**.
3. Provide the knowledge base name and ID. 

Once configured, the knowledge base appears in the list of vectors. You can then select the knowledge base from an AI action in which you want to provide vector data.

Retool does not directly import any data from the knowledge base. When you select the knowledge base, Retool communicates directly with the knowledge base which functions in the same way as Retool Vectors to provide additional context for the AI model.

---

## Connect to Anthropic

import Intro from "./_intro.mdx";

## Supported models

import Support from "./_support.mdx";

import Models from '../../../../_partials/_ai/_models/_anthropic.mdx';

## Set up your Anthropic credentials

import Configure from "../_partials/_ai-configure.mdx";

You can retrieve your Anthropic API key from your [Account settings](https://console.anthropic.com/account/keys).

---

## Connect to Azure OpenAI

import Intro from './_intro.mdx';

## Supported models

import Support from './_support.mdx';

## Set up your Azure OpenAI credentials

import Configure from '../_partials/_ai-configure.mdx';

Azure OpenAI requires the following credentials:

- API key.
- Azure endpoint URL.
- Deployment name (AI model).

You can retrieve your Azure OpenAI credentials from the [Azure Portal](https://portal.azure.com).

When using Azure OpenAI, all AI Actions use the model specified in this configuration.

---

## Connect to Cohere

import Intro from './_intro.mdx';

import Support from './_support.mdx';

## Set up your Cohere credentials

import Configure from "../_partials/_ai-configure.mdx";

You can retrieve your Cohere API key from either the Cohere [dashboard](https://os.cohere.ai) or [CLI tool](https://docs.cohere.ai/cli-key).

---

## Connect a custom AI provider

import Intro from "./_intro.mdx";

Connecting a custom AI provider is helpful when:

- You want to use a third-party AI provider like Mistral, Fireworks AI, Together AI, or OpenRouter.
- You want to connect a custom LLM.
- You have increased security and compliance requirements and need to route traffic through your own proxies.

## Supported models

import Support from "./_support.mdx";

## Set up your AI platform credentials

To configure a custom AI provider in Retool:

1. Navigate to the **Resources** tab and select **Retool AI**.
2. Scroll down to the **Custom providers** section and click **Add**.
3. Supply the requested information about your custom provider.
4. Click **Add**.

:::warning Create separate API credentials for Retool

Where possible, create API credentials for each service you use to interact with your chosen AI platform. This allows you to best manage and revoke access without disruption. All API credentials used with Retool are encrypted and stored securely.

:::

---

## Connect to Google Gemini

import Intro from "./_intro.mdx";

## Supported models

import Support from './_support.mdx';

import Models from '../../../../_partials/_ai/_models/_gemini.mdx';

## Set up your Google Gemini credentials

import Configure from "../_partials/_ai-configure.mdx";

You can retrieve your Google API key from either the [Google AI Studio dashboard](https://makersuite.google.com/app/apikey).

---

## AI integration guides

You can get started with Retool [AI actions](../../../../queries/concepts/actions.mdx) and agents using one of the Retool-managed [AI models](../../../concepts/models.mdx). This enables you to build and test AI functionality before using them in production. When they're ready for production use, configure one of the supported AI providers with your own API credentials.

:::info

Support for individual models may differ depending on whether you're using [AI actions](../../../../queries/concepts/actions.mdx) or [agents](../../../../agents/quickstart.mdx). Refer to the provider's integration page or the [AI models](../../../concepts/models.mdx) guide to learn more.
:::

---

## Connect to OpenAI

import Intro from "./_intro.mdx";

## Supported models

import Support from "./_support.mdx";

import Models from '../../../../_partials/_ai/_models/_openai.mdx';

## Set up your AI platform credentials

To configure an AI platform with your API key, navigate to the **Resources** tab and select **Retool AI**. Select the AI model below for configuration instructions.

import Configure from "../_partials/_ai-configure.mdx";

:::info

Configuring your own OpenAI API key disables the Retool-managed OpenAI connection. All existing AI Action queries using OpenAI automatically start using your connection.

:::

You can retrieve your OpenAI API key from the [API Keys](https://platform.openai.com/account/api-keys) page in your OpenAI account.

---

## Connect to Amazon Athena

import * as Partials from '../_partials/ResourcesPartials';
import Requirements from '../_partials/_requirements.mdx';
import Configure from '../_partials/_configure.mdx';
import Auth from '../_partials/_auth/_auth-settings.mdx';
import Ssl from '../_partials/_settings/_ssl.mdx';
import Test from '../_partials/_test-connection.mdx';
import Save from '../_partials/_save.mdx';
import Wrapup from '../_partials/_wrapup.mdx';

  

  

  
  

  

  

import Related from '../_partials/_related-docs.mdx';

---

## Connect to Databricks

import * as Partials from "../_partials/ResourcesPartials";
import Requirements from "../_partials/_requirements.mdx";
import Configure from "../_partials/_configure.mdx";
import Auth from "../_partials/_auth/_auth-settings.mdx";
import Ssl from "../_partials/_settings/_ssl.mdx";
import Test from "../_partials/_test-connection.mdx";
import Save from "../_partials/_save.mdx";
import Wrapup from "../_partials/_wrapup.mdx";
import JavaDBConnector from "../_partials/_java-dbconnector.mdx";

  
  
  
  
  

import Related from "../_partials/_related-docs.mdx";

---

## Connect to Datadog

import * as Partials from '../_partials/ResourcesPartials';
import Requirements from '../_partials/_requirements.mdx';
import Configure from '../_partials/_configure.mdx';
import Auth from '../_partials/_auth/_auth-settings.mdx';
import Ssl from '../_partials/_settings/_ssl.mdx';
import Test from '../_partials/_test-connection.mdx';
import Save from '../_partials/_save.mdx';
import Wrapup from '../_partials/_wrapup.mdx';

---

## Connect to Elasticsearch

import * as Partials from '../_partials/ResourcesPartials';
import Requirements from '../_partials/_requirements.mdx';
import Configure from '../_partials/_configure.mdx';
import Auth from '../_partials/_auth/_auth-settings.mdx';
import Ssl from '../_partials/_settings/_ssl.mdx';
import Test from '../_partials/_test-connection.mdx';
import Save from '../_partials/_save.mdx';
import Wrapup from '../_partials/_wrapup.mdx';

  

  
  

  

import Related from '../_partials/_related-docs.mdx';

---

## Analytics integration guides



---

## Connect a GraphQL API

import * as Partials from '../_partials/ResourcesPartials';
import Requirements from '../_partials/_requirements.mdx';
import Configure from '../_partials/_configure.mdx';
import Auth from '../_partials/_auth/_auth-settings.mdx';
import Ssl from '../_partials/_settings/_ssl.mdx';
import Test from '../_partials/_test-connection.mdx';
import Save from '../_partials/_save.mdx';
import Wrapup from '../_partials/_wrapup.mdx';

---

## API integration guides



---

## Connect to OpenAPI

import * as Partials from '../_partials/ResourcesPartials';
import Requirements from '../_partials/_requirements.mdx';
import Configure from '../_partials/_configure.mdx';
import Auth from '../_partials/_auth/_auth-settings.mdx';
import Ssl from '../_partials/_settings/_ssl.mdx';
import Test from '../_partials/_test-connection.mdx';
import Save from '../_partials/_save.mdx';
import Wrapup from '../_partials/_wrapup.mdx';

:::note
Retool supports OpenAPI versions 2.0, 3.0.x, and 3.1.0.
:::

---

## Connect a REST API

import * as Partials from '../_partials/ResourcesPartials';
import Requirements from '../_partials/_requirements.mdx';
import Configure from '../_partials/_configure.mdx';
import Auth from '../_partials/_auth/_auth-settings.mdx';
import Ssl from '../_partials/_settings/_ssl.mdx';
import Test from '../_partials/_test-connection.mdx';
import Save from '../_partials/_save.mdx';
import Wrapup from '../_partials/_wrapup.mdx';

---

## Connect to the Retool API

import * as Partials from '../_partials/ResourcesPartials';
import Requirements from '../_partials/_requirements.mdx';
import Configure from '../_partials/_configure.mdx';
import Auth from '../_partials/_auth/_auth-settings.mdx';
import Ssl from '../_partials/_settings/_ssl.mdx';
import Test from '../_partials/_test-connection.mdx';
import Save from '../_partials/_save.mdx';
import Wrapup from '../_partials/_wrapup.mdx';

You can use the [OpenAPI](openapi.mdx) integration to create a Retool API resource and make it available in Retool. Once complete, your users can write queries that interact with your organization using the Retool API.

  

  
  

  

Authentication is performed using [Bearer HTTP authentication](https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication#basic) with an API key. You must first create an API key with the required permission scopes. Refer to the [Retool API authentication](../../../../org-users/guides/retool-api/authentication.mdx) guide for instructions.

Use `https://api.retool.com/api/v2/spec` for cloud-hosted organizations.

Use `https://[your-instance-url].com/api/v2/spec` for a self-hosted deployment instance.

Refer to the [Retool API authentication](../../../../org-users/guides/retool-api/authentication.mdx) guide for instructions on creating an API token.

By default, responses include up to 100 items. When there are more items, the `has_more` field in the response is set to `true` and the `next_token` field has a pagination token.

```json
{
  "data": [
    {...},
  ],
  "has_more": true,
  "next_token": "opaque-pagination-token"
}
```

To request the next page of results, include the token in the URL parameters of the request:

```
curl -H "Authorization: Bearer {token}" https://api.retool.com/api/v2/resources?next_token=opaque-pagination-token
```

---

## Connect a SOAP API

import * as Partials from '../_partials/ResourcesPartials';
import Rest from './rest.mdx';
import Configure from '../_partials/_configure.mdx';
import Requirements from '../_partials/_configure.mdx';
import Auth from '../_partials/_auth/_auth-settings.mdx';
import Ssl from '../_partials/_settings/_ssl.mdx';
import Test from '../_partials/_test-connection.mdx';
import Save from '../_partials/_save.mdx';
import Wrapup from '../_partials/_wrapup.mdx';

  

  
  

     

  

:::caution Set the correct headers for SOAP requests

SOAP requests must also include the following key-value header values.

| Key             | Value       |
| :-------------- | :---------- |
| `Content-Type ` | `text/xml ` |

If you use a SOAP 1.1 service, include `SOAPAction` and an appropriate value.

You may need to include additional headers, depending on your SOAP API requirements. refer to your SOAP API specification for details. The name of the SOAP method is usually provided in the SOAP body but may need to be provided in the header instead.

:::

To perform SOAP API requests:

- Use the **POST** request method.
- Use the **Raw** body type.
- If you use WSDL, provide the path to the WSDL in the endpoint URL.

---

## Connect to BigID

import * as Partials from '../_partials/ResourcesPartials';
import Requirements from '../_partials/_requirements.mdx';
import Configure from '../_partials/_configure.mdx';
import Auth from '../_partials/_auth/_auth-settings.mdx';
import Ssl from '../_partials/_settings/_ssl.mdx';
import Test from '../_partials/_test-connection.mdx';
import Save from '../_partials/_save.mdx';
import Wrapup from '../_partials/_wrapup.mdx';

---

## Connect to Close

import * as Partials from '../_partials/ResourcesPartials';
import Requirements from '../_partials/_requirements.mdx';
import Configure from '../_partials/_configure.mdx';
import Auth from '../_partials/_auth/_auth-settings.mdx';
import Ssl from '../_partials/_settings/_ssl.mdx';
import Test from '../_partials/_test-connection.mdx';
import Save from '../_partials/_save.mdx';
import Wrapup from '../_partials/_wrapup.mdx';

---

## Connect to Front

import * as Partials from '../_partials/ResourcesPartials';
import Requirements from '../_partials/_requirements.mdx';
import Configure from '../_partials/_configure.mdx';
import Auth from '../_partials/_auth/_auth-settings.mdx';
import Ssl from '../_partials/_settings/_ssl.mdx';
import Test from '../_partials/_test-connection.mdx';
import Save from '../_partials/_save.mdx';
import Wrapup from '../_partials/_wrapup.mdx';

---

## Connect to HubSpot

import * as Partials from '../_partials/ResourcesPartials';
import Requirements from '../_partials/_requirements.mdx';
import Configure from '../_partials/_configure.mdx';
import Auth from '../_partials/_auth/_auth-settings.mdx';
import Ssl from '../_partials/_settings/_ssl.mdx';
import Test from '../_partials/_test-connection.mdx';
import Save from '../_partials/_save.mdx';
import Wrapup from '../_partials/_wrapup.mdx';

  

  
  

  

Refer to the [HubSpot developer documentation](https://developers.hubspot.com/docs/api/private-apps) to learn how to generate private app tokens.

:::caution Deprecated authentication method

API key authentication for HubSpot has been deprecated. Use an alternative authentication method, if available.

:::

Refer to the [HubSpot Knowledge Base](https://knowledge.hubspot.com/integrations/how-do-i-get-my-hubspot-api-key) to learn how to obtain an API key.

Refer to the [HubSpot developer documentation](https://developers.hubspot.com/docs/api/private-apps) to learn how to generate private app tokens.

:::caution Deprecated authentication method

API key authentication for HubSpot has been deprecated. Use an alternative authentication method, if available.

:::

Refer to the [HubSpot Knowledge Base](https://knowledge.hubspot.com/integrations/how-do-i-get-my-hubspot-api-key) to learn how to obtain an API key.

---

## CRM integration guides



---

## Connect to Salesforce

import * as Partials from '../_partials/ResourcesPartials';
import Requirements from '../_partials/_requirements.mdx';
import Configure from '../_partials/_configure.mdx';
import Auth from '../_partials/_auth/_auth-settings.mdx';
import Ssl from '../_partials/_settings/_ssl.mdx';
import Test from '../_partials/_test-connection.mdx';
import Save from '../_partials/_save.mdx';
import Wrapup from '../_partials/_wrapup.mdx';

  

  
  

  

:::note

Retool does not support the Salesforce implementation of [Proof Key for Code Exchange (PKCE)](https://help.salesforce.com/s/articleView?id=sf.remoteaccess_pkce.htm&type=5). To ensure that your Salesforce integration with Retool functions as expected, turn off the **Require Proof Key for Code Exchange (PKCE) Extension for Supported Authorization Flows** setting in your [Salesforce app settings](https://help.salesforce.com/s/articleView?id=sf.authorization_code_credentials_configure.htm&type=5).

:::

Enable **Customize Salesforce OAuth urls** to specify custom authorization and token URLs.

Enable **Customize Salesforce OAuth urls** to specify custom authorization and token URLs.

---

## Connect to AlloyDB

import * as Partials from '../_partials/ResourcesPartials';
import Requirements from '../_partials/_requirements.mdx';
import Configure from '../_partials/_configure.mdx';
import Auth from '../_partials/_auth/_auth-settings.mdx';
import Ssl from '../_partials/_settings/_ssl.mdx';
import Test from '../_partials/_test-connection.mdx';
import Save from '../_partials/_save.mdx';
import Wrapup from '../_partials/_wrapup.mdx';

  

  
  

  

import Related from '../_partials/_related-docs.mdx';

---

## Connect to Amazon DynamoDB

import * as Partials from '../_partials/ResourcesPartials';
import Requirements from '../_partials/_requirements.mdx';
import Configure from '../_partials/_configure.mdx';
import Auth from '../_partials/_auth/_auth-settings.mdx';
import Ssl from '../_partials/_settings/_ssl.mdx';
import Test from '../_partials/_test-connection.mdx';
import Save from '../_partials/_save.mdx';
import Wrapup from '../_partials/_wrapup.mdx';

  

  
  

  

import Related from '../_partials/_related-docs.mdx';

---

## Connect to Amazon Redshift

import * as Partials from '../_partials/ResourcesPartials';
import Requirements from '../_partials/_requirements.mdx';
import Configure from '../_partials/_configure.mdx';
import Auth from '../_partials/_auth/_auth-settings.mdx';
import Ssl from '../_partials/_settings/_ssl.mdx';
import Test from '../_partials/_test-connection.mdx';
import Save from '../_partials/_save.mdx';
import Wrapup from '../_partials/_wrapup.mdx';

  

  
  

  

import Related from '../_partials/_related-docs.mdx';

---

## Connect to BigQuery

import * as Partials from '../_partials/ResourcesPartials';
import Requirements from '../_partials/_requirements.mdx';
import Configure from '../_partials/_configure.mdx';
import Auth from '../_partials/_auth/_auth-settings.mdx';
import Ssl from '../_partials/_settings/_ssl.mdx';
import Test from '../_partials/_test-connection.mdx';
import Save from '../_partials/_save.mdx';
import Wrapup from '../_partials/_wrapup.mdx';

  

  
  

  

Your [dataset location](https://cloud.google.com/bigquery/docs/locations) is required so Retool can fetch the dataset's [metadata](https://cloud.google.com/bigquery/docs/information-schema-intro) to power query autocomplete. Defaults to `region-us` if no value is provided.

Your [dataset location](https://cloud.google.com/bigquery/docs/locations) is required so Retool can fetch the dataset's [metadata](https://cloud.google.com/bigquery/docs/information-schema-intro) to power query autocomplete. Defaults to `region-us` if no value is provided.

You must ensure the key is granted access to the BigQuery Data Viewer and BigQuery User [roles](https://cloud.google.com/bigquery/docs/access-control). Refer to the [Google developer documentation](https://cloud.google.com/iam/docs/service-account-overview) for details on creating a service account key.

You must ensure the key is granted access to the BigQuery Data Viewer and BigQuery User [roles](https://cloud.google.com/bigquery/docs/access-control). Refer to the [Google developer documentation](https://cloud.google.com/iam/docs/service-account-overview) for details on creating a service account key.

import Related from '../_partials/_related-docs.mdx';

---

## Connect to Cassandra

import * as Partials from '../_partials/ResourcesPartials';
import Requirements from '../_partials/_requirements.mdx';
import Configure from '../_partials/_configure.mdx';
import Auth from '../_partials/_auth/_auth-settings.mdx';
import Ssl from '../_partials/_settings/_ssl.mdx';
import Test from '../_partials/_test-connection.mdx';
import Save from '../_partials/_save.mdx';
import Wrapup from '../_partials/_wrapup.mdx';

  

  
  

  

import Related from '../_partials/_related-docs.mdx';

---

## Connect to CosmosDB

import * as Partials from '../_partials/ResourcesPartials';
import Requirements from '../_partials/_requirements.mdx';
import Configure from '../_partials/_configure.mdx';
import Auth from '../_partials/_auth/_auth-settings.mdx';
import Ssl from '../_partials/_settings/_ssl.mdx';
import Test from '../_partials/_test-connection.mdx';
import Save from '../_partials/_save.mdx';
import Wrapup from '../_partials/_wrapup.mdx';

  

  
  

  

import Related from '../_partials/_related-docs.mdx';

---

## Connect to CouchDB

import * as Partials from '../_partials/ResourcesPartials';
import Requirements from '../_partials/_requirements.mdx';
import Configure from '../_partials/_configure.mdx';
import Auth from '../_partials/_auth/_auth-settings.mdx';
import Ssl from '../_partials/_settings/_ssl.mdx';
import Test from '../_partials/_test-connection.mdx';
import Save from '../_partials/_save.mdx';
import Wrapup from '../_partials/_wrapup.mdx';

  

  
  

  

import Related from '../_partials/_related-docs.mdx';

---

## Connect to Databricks Lakebase

import * as Partials from '../_partials/ResourcesPartials';
import Requirements from '../_partials/_requirements.mdx';
import Configure from '../_partials/_configure.mdx';
import Auth from '../_partials/_auth/_auth-settings.mdx';
import Ssl from '../_partials/_settings/_ssl.mdx';
import Test from '../_partials/_test-connection.mdx';
import Save from '../_partials/_save.mdx';
import Scopes from '../_partials/_settings/_scopes.mdx';
import Wrapup from '../_partials/_wrapup.mdx';

  

  
  

  

Retool strongly recommends using SSL/TLS certificate validation whenever it's available. This ensures the connection is secure and prevents attackers from using invalid server certificates to gain access to your data.

When creating your OAuth app in Databricks Lakebase:
- **Select the "ALL APIs" scope** to grant Retool the necessary permissions
- **Unselect "Generate a client secret"** as Databricks Lakebase uses PKCE (Proof Key for Code Exchange) for enhanced security

Retool prefills this value with a placeholder. Replace `{databricksHost}` with your Databricks Lakebase host.

```url
https://{databricksHost}/oidc/v1/authorize
```

Retool prefills this value with a placeholder. Replace `{databricksHost}` with your Databricks Lakebase host.

```url
https://{databricksHost}/oidc/v1/token
```

import Related from '../_partials/_related-docs.mdx';

---

## Database integration guides



---

## Connect to JDBC

import * as Partials from '../_partials/ResourcesPartials';
import Requirements from '../_partials/_requirements.mdx';
import Configure from '../_partials/_configure.mdx';
import Auth from '../_partials/_auth/_auth-settings.mdx';
import Test from '../_partials/_test-connection.mdx';
import Save from '../_partials/_save.mdx';
import Wrapup from '../_partials/_wrapup.mdx';
import JdbcOnprem from '../_partials/_jdbc_onprem_configure.mdx';

  

  
  

  

import Related from '../_partials/_related-docs.mdx';

---

## Connect to Microsoft SQL Server

import * as Partials from '../_partials/ResourcesPartials';
import Requirements from '../_partials/_requirements.mdx';
import Configure from '../_partials/_configure.mdx';
import Auth from '../_partials/_auth/_auth-settings.mdx';
import Ssl from '../_partials/_settings/_ssl.mdx';
import Test from '../_partials/_test-connection.mdx';
import Save from '../_partials/_save.mdx';
import Wrapup from '../_partials/_wrapup.mdx';

  

  
  

  

:::tip 
You can [configure self-hosted deployments to use Kerberos authentication](../../authentication/mssql-kerberos.mdx) with Microsoft SQL Server resources.
:::

import Related from '../_partials/_related-docs.mdx';

---

## Connect to MongoDB

import * as Partials from '../_partials/ResourcesPartials';
import Requirements from '../_partials/_requirements.mdx';
import Configure from '../_partials/_configure.mdx';
import Auth from '../_partials/_auth/_auth-settings.mdx';
import Ssl from '../_partials/_settings/_ssl.mdx';
import Test from '../_partials/_test-connection.mdx';
import Save from '../_partials/_save.mdx';
import Wrapup from '../_partials/_wrapup.mdx';

  

  
  

  

Only required when using the **Standard** connection format.

Only required when using the **Standard** connection format.

import Related from '../_partials/_related-docs.mdx';

---

## Connect a MySQL database

import * as Partials from '../_partials/ResourcesPartials';
import Requirements from '../_partials/_requirements.mdx';
import Configure from '../_partials/_configure.mdx';
import Auth from '../_partials/_auth/_auth-settings.mdx';
import Ssl from '../_partials/_settings/_ssl.mdx';
import Test from '../_partials/_test-connection.mdx';
import Save from '../_partials/_save.mdx';
import Wrapup from '../_partials/_wrapup.mdx';

  

  
  

  

import Related from '../_partials/_related-docs.mdx';

---

## Connect to Oracle Database

import * as Partials from '../_partials/ResourcesPartials';
import Requirements from '../_partials/_requirements.mdx';
import Configure from '../_partials/_configure.mdx';
import Auth from '../_partials/_auth/_auth-settings.mdx';
import Ssl from '../_partials/_settings/_ssl.mdx';
import Test from '../_partials/_test-connection.mdx';
import Save from '../_partials/_save.mdx';
import Wrapup from '../_partials/_wrapup.mdx';

  

  
  

  

import Related from '../_partials/_related-docs.mdx';

---

## Connect a PostgreSQL database

import * as Partials from '../_partials/ResourcesPartials';
import Requirements from '../_partials/_requirements.mdx';
import Configure from '../_partials/_configure.mdx';
import Auth from '../_partials/_auth/_auth-settings.mdx';
import Ssl from '../_partials/_settings/_ssl.mdx';
import Test from '../_partials/_test-connection.mdx';
import Save from '../_partials/_save.mdx';
import Wrapup from '../_partials/_wrapup.mdx';

  

  
  

  

import Related from '../_partials/_related-docs.mdx';

---

## Connect to Presto

import * as Partials from '../_partials/ResourcesPartials';
import Requirements from '../_partials/_requirements.mdx';
import Configure from '../_partials/_configure.mdx';
import Auth from '../_partials/_auth/_auth-settings.mdx';
import Ssl from '../_partials/_settings/_ssl.mdx';
import Test from '../_partials/_test-connection.mdx';
import Save from '../_partials/_save.mdx';
import Wrapup from '../_partials/_wrapup.mdx';

  

  
  

  

import Related from '../_partials/_related-docs.mdx';

---

## Connect to Redis

import * as Partials from '../_partials/ResourcesPartials';
import Requirements from '../_partials/_requirements.mdx';
import Configure from '../_partials/_configure.mdx';
import Auth from '../_partials/_auth/_auth-settings.mdx';
import Ssl from '../_partials/_settings/_ssl.mdx';
import Test from '../_partials/_test-connection.mdx';
import Save from '../_partials/_save.mdx';
import Wrapup from '../_partials/_wrapup.mdx';

If you want to connect to Redis without a password, you must [disable protected mode](https://redis.io/topics/security).

import Related from '../_partials/_related-docs.mdx';

---

## Connect to RethinkDB

import * as Partials from '../_partials/ResourcesPartials';
import Requirements from '../_partials/_requirements.mdx';
import Configure from '../_partials/_configure.mdx';
import Auth from '../_partials/_auth/_auth-settings.mdx';
import Ssl from '../_partials/_settings/_ssl.mdx';
import Test from '../_partials/_test-connection.mdx';
import Save from '../_partials/_save.mdx';
import Wrapup from '../_partials/_wrapup.mdx';

  

  
  

  

import Related from '../_partials/_related-docs.mdx';

---

## Connect to SAP Hana

import * as Partials from '../_partials/ResourcesPartials';
import Requirements from '../_partials/_requirements.mdx';
import Configure from '../_partials/_configure.mdx';
import Auth from '../_partials/_auth/_auth-settings.mdx';
import Ssl from '../_partials/_settings/_ssl.mdx';
import Test from '../_partials/_test-connection.mdx';
import Save from '../_partials/_save.mdx';
import Wrapup from '../_partials/_wrapup.mdx';

  

     

  
  

  

import Related from '../_partials/_related-docs.mdx';

---

## Connect to Snowflake

import * as Partials from '../_partials/ResourcesPartials';
import Requirements from '../_partials/_requirements.mdx';
import Configure from '../_partials/_configure.mdx';
import Auth from '../_partials/_auth/_auth-settings.mdx';
import Ssl from '../_partials/_settings/_ssl.mdx';
import Test from '../_partials/_test-connection.mdx';
import Save from '../_partials/_save.mdx';
import Wrapup from '../_partials/_wrapup.mdx';

  

Retool uses **per-user authentication** to connect to Snowflake using OAuth.

  
  
     

Retool uses **per-user authentication** to connect to Snowflake using OAuth.

  

import Related from '../_partials/_related-docs.mdx';

---

## Connect to Vertica

import * as Partials from '../_partials/ResourcesPartials';
import Requirements from '../_partials/_requirements.mdx';
import Configure from '../_partials/_configure.mdx';
import Auth from '../_partials/_auth/_auth-settings.mdx';
import Ssl from '../_partials/_settings/_ssl.mdx';
import Test from '../_partials/_test-connection.mdx';
import Save from '../_partials/_save.mdx';
import Wrapup from '../_partials/_wrapup.mdx';

  

  
  

  

import Related from '../_partials/_related-docs.mdx';

---

## Connect to AWS Lambda

import * as Partials from '../_partials/ResourcesPartials';
import Requirements from '../_partials/_requirements.mdx';
import Configure from '../_partials/_configure.mdx';
import Auth from '../_partials/_auth/_auth-settings.mdx';
import Ssl from '../_partials/_settings/_ssl.mdx';
import Test from '../_partials/_test-connection.mdx';
import Save from '../_partials/_save.mdx';
import Wrapup from '../_partials/_wrapup.mdx';

---

## Connect to CircleCI

import * as Partials from '../_partials/ResourcesPartials';
import Requirements from '../_partials/_requirements.mdx';
import Configure from '../_partials/_configure.mdx';
import Auth from '../_partials/_auth/_auth-settings.mdx';
import Ssl from '../_partials/_settings/_ssl.mdx';
import Test from '../_partials/_test-connection.mdx';
import Save from '../_partials/_save.mdx';
import Wrapup from '../_partials/_wrapup.mdx';

---

## Connect to Firebase

import * as Partials from '../_partials/ResourcesPartials';
import Requirements from '../_partials/_requirements.mdx';
import Configure from '../_partials/_configure.mdx';
import Auth from '../_partials/_auth/_auth-settings.mdx';
import Ssl from '../_partials/_settings/_ssl.mdx';
import Test from '../_partials/_test-connection.mdx';
import Save from '../_partials/_save.mdx';
import Wrapup from '../_partials/_wrapup.mdx';

---

## Connect to GitHub

import * as Partials from '../_partials/ResourcesPartials';
import Requirements from '../_partials/_requirements.mdx';
import Configure from '../_partials/_configure.mdx';
import Auth from '../_partials/_auth/_auth-settings.mdx';
import Ssl from '../_partials/_settings/_ssl.mdx';
import Test from '../_partials/_test-connection.mdx';
import Save from '../_partials/_save.mdx';
import Wrapup from '../_partials/_wrapup.mdx';

---

## Connect to gRPC

import * as Partials from '../_partials/ResourcesPartials';
import Requirements from '../_partials/_requirements.mdx';
import Configure from '../_partials/_configure.mdx';
import Auth from '../_partials/_auth/_auth-settings.mdx';
import Ssl from '../_partials/_settings/_ssl.mdx';
import Test from '../_partials/_test-connection.mdx';
import Save from '../_partials/_save.mdx';
import Wrapup from '../_partials/_wrapup.mdx';

---

## Development integration guides



---

## Connect to the OpenAI Platform API

import * as Partials from "../_partials/ResourcesPartials";
import Requirements from "../_partials/_requirements.mdx";
import Configure from "../_partials/_configure.mdx";
import Auth from "../_partials/_auth/_auth-settings.mdx";
import Ssl from "../_partials/_settings/_ssl.mdx";
import Test from "../_partials/_test-connection.mdx";
import Save from "../_partials/_save.mdx";
import Wrapup from "../_partials/_wrapup.mdx";

:::warning

This resource integration is for interacting directly with Open AI's [platform API](https://platform.openai.com/docs/overview). This can be useful for OpenAI organization administrators to programmatically [manage users](https://platform.openai.com/docs/api-reference/users) and [projects](https://platform.openai.com/docs/api-reference/projects).

Refer to the [OpenAI for Retool AI documentation](../ai/openai.mdx) if you want to use OpenAI's models to power AI apps, workflows, and agents.

:::

export function CreateResource() {
  return (
    
      
    
  )
}

  

  
  

  

  
  

## Query the resource

The OpenAI Platform resource is now available for use in [resource queries](../../../../queries/tutorials/resource-query.mdx). When writing an OpenAI Platform resource query, you can select any supported API method in the **Operations** dropdown. Refer to OpenAI's platform [API reference](https://platform.openai.com/docs/api-reference/introduction) for more information about supported actions.

export function QueryResource() {
  return (
    
      
    
  )
}

---

## Finance integration guides



---

## Connect to Stripe

import * as Partials from '../_partials/ResourcesPartials';
import Requirements from '../_partials/_requirements.mdx';
import Configure from '../_partials/_configure.mdx';
import Auth from '../_partials/_auth/_auth-settings.mdx';
import Ssl from '../_partials/_settings/_ssl.mdx';
import Test from '../_partials/_test-connection.mdx';
import Save from '../_partials/_save.mdx';
import Wrapup from '../_partials/_wrapup.mdx';

---

## Connect to Google Analytics

import * as Partials from '../_partials/ResourcesPartials';
import Requirements from '../_partials/_requirements.mdx';
import Configure from '../_partials/_configure.mdx';
import Auth from '../_partials/_auth/_auth-settings.mdx';
import Ssl from '../_partials/_settings/_ssl.mdx';
import Test from '../_partials/_test-connection.mdx';
import Save from '../_partials/_save.mdx';
import Wrapup from '../_partials/_wrapup.mdx';

---

## Connect to Google Calendar

import * as Partials from '../_partials/ResourcesPartials';
import Requirements from '../_partials/_requirements.mdx';
import Configure from '../_partials/_configure.mdx';
import Auth from '../_partials/_auth/_auth-settings.mdx';
import Ssl from '../_partials/_settings/_ssl.mdx';
import Test from '../_partials/_test-connection.mdx';
import Save from '../_partials/_save.mdx';
import Wrapup from '../_partials/_wrapup.mdx';

Refer to the [Calendar guide](../../../../apps/guides/presentation-styling/calendar.mdx) for information on how to use this resource with the [Calendar component](../../../../apps/reference/components/presentation/calendar.mdx).

:::note
If you self-host Retool and are using a stable release, to enable **Google Calendar** toggle the feature flag in **Settings** > **Beta**. 
:::

export function ArcadeEmbed() {
  return (
    
      
    
  )
}

---

## Connect to Google Cloud Datastore

import * as Partials from '../_partials/ResourcesPartials';
import Requirements from '../_partials/_requirements.mdx';
import Configure from '../_partials/_configure.mdx';
import Auth from '../_partials/_auth/_auth-settings.mdx';
import Ssl from '../_partials/_settings/_ssl.mdx';
import Test from '../_partials/_test-connection.mdx';
import Save from '../_partials/_save.mdx';
import Wrapup from '../_partials/_wrapup.mdx';

  

     

  
  

  

Refer to the [Google developer documentation](https://cloud.google.com/iam/docs/service-account-overview) for details on creating a service account key.

import Related from '../_partials/_related-docs.mdx';

---

## Connect to Google Cloud Storage

import * as Partials from '../_partials/ResourcesPartials';
import Requirements from '../_partials/_requirements.mdx';
import Configure from '../_partials/_configure.mdx';
import Auth from '../_partials/_auth/_auth-settings.mdx';
import Ssl from '../_partials/_settings/_ssl.mdx';
import Test from '../_partials/_test-connection.mdx';
import Save from '../_partials/_save.mdx';
import Wrapup from '../_partials/_wrapup.mdx';
import CORS from '../_partials/_cors-google.mdx';

---

## Connect to Google Docs

import * as Partials from '../_partials/ResourcesPartials';
import Requirements from '../_partials/_requirements.mdx';
import Configure from '../_partials/_configure.mdx';
import Auth from '../_partials/_auth/_auth-settings.mdx';
import Ssl from '../_partials/_settings/_ssl.mdx';
import Test from '../_partials/_test-connection.mdx';
import Save from '../_partials/_save.mdx';
import Wrapup from '../_partials/_wrapup.mdx';

:::note
If you self-host Retool and are using a stable release, enable **Google Docs** from **Settings** > **Beta**. 
:::

export function ArcadeEmbed() {
  return (
    
      
    
  )
}

---

## Connect to Google Maps

import * as Partials from '../_partials/ResourcesPartials';
import Requirements from '../_partials/_requirements.mdx';
import Configure from '../_partials/_configure.mdx';
import Auth from '../_partials/_auth/_auth-settings.mdx';
import Ssl from '../_partials/_settings/_ssl.mdx';
import Test from '../_partials/_test-connection.mdx';
import Save from '../_partials/_save.mdx';
import Wrapup from '../_partials/_wrapup.mdx';

  

  
  

    

  

The following APIs must be enabled on the Google Cloud project associated with the API key you provide:

- [Distance Matrix API](https://developers.google.com/maps/documentation/distance-matrix)
- [Elevation API](https://developers.google.com/maps/documentation/elevation)
- [Geocoding API](https://developers.google.com/maps/documentation/geocoding)
- [Geolocation API](https://developers.google.com/maps/documentation/geolocation)
- [Roads API](https://developers.google.com/maps/documentation/roads)
- [Time Zone API](https://developers.google.com/maps/documentation/timezone)
- [Places API](https://developers.google.com/maps/documentation/places/web-service)
- [Distance Matrix API](https://developers.google.com/maps/documentation/distance-matrix/overview)
- [Street View API](https://developers.google.com/maps/documentation/streetview/overview)

---

## Connect to Google Search Console

:::tip Enable Google Search Console integration

The Google Search Console integration is an opt-in beta. To enable, navigate to **Settings > Beta** and enable **Google Search Console integration**. 

:::

import * as Partials from '../_partials/ResourcesPartials';
import Requirements from '../_partials/_requirements.mdx';
import Configure from '../_partials/_configure.mdx';
import Auth from '../_partials/_auth/_auth-settings.mdx';
import Ssl from '../_partials/_settings/_ssl.mdx';
import Test from '../_partials/_test-connection.mdx';
import Save from '../_partials/_save.mdx';
import Wrapup from '../_partials/_wrapup.mdx';

---

## Connect to Google Sheets

import * as Partials from '../_partials/ResourcesPartials';
import Requirements from '../_partials/_requirements.mdx';
import Configure from '../_partials/_configure.mdx';
import Auth from '../_partials/_auth/_auth-settings.mdx';
import Ssl from '../_partials/_settings/_ssl.mdx';
import Test from '../_partials/_test-connection.mdx';
import Save from '../_partials/_save.mdx';
import Wrapup from '../_partials/_wrapup.mdx';

  

  
  

  

When building apps on top of Google Sheets, _all users_ in a Retool organization can access and edit sheets that have been shared with the user who completed the authentication process.

---

## Connect to Google Slides

:::note

If you self-host Retool and are using a stable release, reach out to your account manager to enable Google Slides.

:::

import * as Partials from '../_partials/ResourcesPartials';
import Requirements from '../_partials/_requirements.mdx';
import Configure from '../_partials/_configure.mdx';
import Auth from '../_partials/_auth/_auth-settings.mdx';
import Ssl from '../_partials/_settings/_ssl.mdx';
import Test from '../_partials/_test-connection.mdx';
import Save from '../_partials/_save.mdx';
import Wrapup from '../_partials/_wrapup.mdx';

export function ArcadeEmbed() {
  return (
    
      
    
  )
}

  

  
  

## Next steps
Your Google Slides resource is now ready to use. You can [query](../../../queries) your resource from an app or a workflow, or use it as [core tool](../../../agents/guides/tools/use-core-tools) within an agent.

---

## Google integration guides



---

## Integration guides

Retool provides a number of pre-built integrations that enable you to connect third-party providers with Retool as resources. If there isn't a built-in integration for your desired data source, you can also connect any [REST API](./api/rest.mdx) or [GraphQL API](./api/graphql.mdx)

---

## Messaging integration guides



---

## Connect to Microsoft Teams

import * as Partials from '../_partials/ResourcesPartials';
import Requirements from '../_partials/_requirements.mdx';
import Configure from '../_partials/_configure.mdx';
import Auth from '../_partials/_auth/_auth-settings.mdx';
import Ssl from '../_partials/_settings/_ssl.mdx';
import Test from '../_partials/_test-connection.mdx';
import Save from '../_partials/_save.mdx';
import Wrapup from '../_partials/_wrapup.mdx';

---

## Connect to OneSignal

import * as Partials from '../_partials/ResourcesPartials';
import Requirements from '../_partials/_requirements.mdx';
import Configure from '../_partials/_configure.mdx';
import Auth from '../_partials/_auth/_auth-settings.mdx';
import Ssl from '../_partials/_settings/_ssl.mdx';
import Test from '../_partials/_test-connection.mdx';
import Save from '../_partials/_save.mdx';
import Wrapup from '../_partials/_wrapup.mdx';

---

## Connect to SendGrid

import * as Partials from '../_partials/ResourcesPartials';
import Requirements from '../_partials/_requirements.mdx';
import Configure from '../_partials/_configure.mdx';
import Auth from '../_partials/_auth/_auth-settings.mdx';
import Ssl from '../_partials/_settings/_ssl.mdx';
import Test from '../_partials/_test-connection.mdx';
import Save from '../_partials/_save.mdx';
import Wrapup from '../_partials/_wrapup.mdx';

---

## Connect to Slack

import * as Partials from '../_partials/ResourcesPartials';
import Requirements from '../_partials/_requirements.mdx';
import Configure from '../_partials/_configure.mdx';
import Auth from '../_partials/_auth/_auth-settings.mdx';
import Ssl from '../_partials/_settings/_ssl.mdx';
import Test from '../_partials/_test-connection.mdx';
import Save from '../_partials/_save.mdx';
import Wrapup from '../_partials/_wrapup.mdx';

---

## Connect an SMTP server

import * as Partials from '../_partials/ResourcesPartials';
import Requirements from '../_partials/_requirements.mdx';
import Configure from '../_partials/_configure.mdx';
import Auth from '../_partials/_auth/_auth-settings.mdx';
import Ssl from '../_partials/_settings/_ssl.mdx';
import Test from '../_partials/_test-connection.mdx';
import Save from '../_partials/_save.mdx';
import Wrapup from '../_partials/_wrapup.mdx';

---

## Connect to Twilio

import * as Partials from '../_partials/ResourcesPartials';
import Requirements from '../_partials/_requirements.mdx';
import Configure from '../_partials/_configure.mdx';
import Auth from '../_partials/_auth/_auth-settings.mdx';
import Ssl from '../_partials/_settings/_ssl.mdx';
import Test from '../_partials/_test-connection.mdx';
import Save from '../_partials/_save.mdx';
import Wrapup from '../_partials/_wrapup.mdx';

---

## Connect to Amazon S3 and S3-compatible services

import * as Partials from '../_partials/ResourcesPartials';
import Requirements from '../_partials/_requirements.mdx';
import Configure from '../_partials/_configure.mdx';
import Auth from '../_partials/_auth/_auth-settings.mdx';
import Ssl from '../_partials/_settings/_ssl.mdx';
import Test from '../_partials/_test-connection.mdx';
import Save from '../_partials/_save.mdx';
import Wrapup from '../_partials/_wrapup.mdx';

## Configure the CORS policy

---

## Object and file store integration guides



---

## Connect to Asana

import * as Partials from '../_partials/ResourcesPartials';
import Requirements from '../_partials/_requirements.mdx';
import Configure from '../_partials/_configure.mdx';
import Auth from '../_partials/_auth/_auth-settings.mdx';
import Ssl from '../_partials/_settings/_ssl.mdx';
import Test from '../_partials/_test-connection.mdx';
import Save from '../_partials/_save.mdx';
import Wrapup from '../_partials/_wrapup.mdx';

---

## Project management integration guides



---

## Connect to Jira

import * as Partials from '../_partials/ResourcesPartials';
import Requirements from '../_partials/_requirements.mdx';
import Configure from '../_partials/_configure.mdx';
import Auth from '../_partials/_auth/_auth-settings.mdx';
import Ssl from '../_partials/_settings/_ssl.mdx';
import Test from '../_partials/_test-connection.mdx';
import Save from '../_partials/_save.mdx';
import Wrapup from '../_partials/_wrapup.mdx';

  

  
  

  

  See [Jira documentation](https://confluence.atlassian.com/jirakb/how-to-find-cloud-site-id-1272283178.html) to learn how to find your Cloud ID for the `domain` server variable.

---

## Connect to Notion

import * as Partials from '../_partials/ResourcesPartials';
import Requirements from '../_partials/_requirements.mdx';
import Configure from '../_partials/_configure.mdx';
import Auth from '../_partials/_auth/_auth-settings.mdx';
import Ssl from '../_partials/_settings/_ssl.mdx';
import Test from '../_partials/_test-connection.mdx';
import Save from '../_partials/_save.mdx';
import Wrapup from '../_partials/_wrapup.mdx';

---

## Connect to Amazon SNS

import * as Partials from '../_partials/ResourcesPartials';
import Requirements from '../_partials/_requirements.mdx';
import Configure from '../_partials/_configure.mdx';
import Auth from '../_partials/_auth/_auth-settings.mdx';
import Test from '../_partials/_test-connection.mdx';
import Save from '../_partials/_save.mdx';
import Wrapup from '../_partials/_wrapup.mdx';
import JavaDBConnector from '../_partials/_java-dbconnector.mdx';

You can use the Amazon SNS integration in apps and workflows to publish messages to a topic. Once configured, you can [subscribe to the topic using Amazon SQS](https://docs.aws.amazon.com/sns/latest/dg/sns-sqs-as-subscriber.html), enabling you to use [Retool's SQS integration](./amazon-sqs.mdx) to respond to events in your apps and workflows.

  

Set up an Amazon SNS topic for Retool to access. Generate an [SNS policy](https://docs.aws.amazon.com/sns/latest/dg/sns-using-identity-based-policies.html) for that resource with rights to the following actions:

```
"Effect":"Allow",
"Action":[
  "sns:ListTopics",
  "sns:Publish"
]
```

  
  

Set up an Amazon SNS topic for Retool to access. Generate an [SNS policy](https://docs.aws.amazon.com/sns/latest/dg/sns-using-identity-based-policies.html) for that resource with rights to the following actions:

```
"Effect":"Allow",
"Action":[
  "sns:ListTopics",
  "sns:Publish"
]
```

  

import Related from '../_partials/_related-docs.mdx';

---

## Connect to Amazon SQS

import * as Partials from '../_partials/ResourcesPartials';
import Requirements from '../_partials/_requirements.mdx';
import Configure from '../_partials/_configure.mdx';
import Auth from '../_partials/_auth/_auth-settings.mdx';
import Test from '../_partials/_test-connection.mdx';
import Save from '../_partials/_save.mdx';
import Wrapup from '../_partials/_wrapup.mdx';
import JavaDBConnector from '../_partials/_java-dbconnector.mdx';

You can use the Amazon SQS integration in apps and workflows to send, receive, and delete messages from a queue.

  

Set up an Amazon SQS queue for Retool to access. Generate an [SQS policy](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-using-identity-based-policies.html) for that resource with rights to the following actions:

```
"Effect":"Allow",
"Action":[
  "sqs:SendMessage",
  "sqs:ReceiveMessage",
  "sqs:DeleteMessage",
  "sqs:GetQueueAttributes",
  "sqs:ListTopics"
]
```

  
  

Set up an Amazon SQS queue for Retool to access. Generate an [SQS policy](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-using-identity-based-policies.html) for that resource with rights to the following actions:

```
"Effect":"Allow",
"Action":[
  "sqs:SendMessage",
  "sqs:ReceiveMessage",
  "sqs:DeleteMessage",
  "sqs:GetQueueAttributes",
  "sqs:ListTopics"
]
```

  

The prefix that Retool appends to queues.

The prefix that Retool appends to the queue.

import Related from '../_partials/_related-docs.mdx';

---

## Streaming integration guides



---

## Connect to Kafka

import * as Partials from '../_partials/ResourcesPartials';
import Requirements from '../_partials/_requirements.mdx';
import Configure from '../_partials/_configure.mdx';
import Auth from '../_partials/_auth/_auth-settings.mdx';
import Test from '../_partials/_test-connection.mdx';
import Save from '../_partials/_save.mdx';
import Wrapup from '../_partials/_wrapup.mdx';
import JavaDBConnector from '../_partials/_java-dbconnector.mdx';

You can use the Kafka integration in Retool Apps and Retool Workflows to produce, consume, or commit messages to a topic.

  

  
  

If your Kafka implementation's SSL certificates are signed by an internal CA, your Retool deployment cannot connect until you configure it to trust your CA. You do this by setting `NODE_EXTRA_CA_CERTS` to the absolute path of your certificate files. The files need to include one or more trusted certificates in PEM format. For more information, refer to [Configure SSL and custom certificates](../../../../self-hosted/guides/certificates.mdx).

  

The Simple Authentication and Security Layer (SASL) mechanism. Options include `PLAIN`, `SCRAM-SHA-256`, and `SCRAM-SHA-512`. Defaults to `SCRAM-SHA-512`.

The security protocol. Options include `SASL_SSL`, `SSL`, `SASL_PLAINTEXT`, `PLAINTEXT`. Defaults to `SASL_SSL`.

The Kafka brokers in the cluster that you want to connect to, in a comma-separated list.

The Simple Authentication and Security Layer (SASL) mechanism. Options include `PLAIN`, `SCRAM-SHA-256`, and `SCRAM-SHA-512`. Defaults to `SCRAM-SHA-512`.

The security protocol. Options include `SASL_SSL`, `SSL`, `SASL_PLAINTEXT`, `PLAINTEXT`. Defaults to `SASL_SSL`.

The Kafka brokers in the cluster that you want to connect to, in a comma-separated list.

## Query the Kafka resource

When querying the Kafka resource, you can choose from one of three actions:

- Produce messages for a topic
- Consume messages from a topic
- Commit messages in a topic

import FxSvg from '/img/icons/fx.svg';

:::note

Consumer groups are automatically deleted after 7 days without use, unless you [edit Kafka's `offsets.retention.minutes` value](https://kafka.apache.org/documentation/#brokerconfigs_offsets.retention.minutes).

To create a new `Consumer Group` within Retool, click the  button and enter the desired value. After refreshing, the new value appears in the dropdown.

:::

import Related from '../_partials/_related-docs.mdx';

---

## Web search integration guides



---

## Connect to Tavily Web Search

import * as Partials from '../_partials/ResourcesPartials';
import Requirements from '../_partials/_requirements.mdx';
import Configure from '../_partials/_configure.mdx';
import Auth from '../_partials/_auth/_auth-settings.mdx';
import Ssl from '../_partials/_settings/_ssl.mdx';
import Test from '../_partials/_test-connection.mdx';
import Save from '../_partials/_save.mdx';
import Wrapup from '../_partials/_wrapup.mdx';

export function ArcadeEmbed() {
  return (
    
      
    
  )
}

  

  
  

  

No authentication is required to use the Tavily Web Search integration. You can choose to provide your own [Tavily API key](https://docs.tavily.com/documentation/quickstart) if you do not want to be subject to Retool's rate limits (100 calls per 24 hours) on Tavily.

To use your own key, enable the **Provide my own API key** setting, and enter your key in the **Custom API Key** setting.

You must provide your own [Tavily API key](https://docs.tavily.com/documentation/quickstart).

To use your own key, enable the **Provide my own API key** setting, and enter your key in the **Custom API Key** setting.

---

## Manage resources

You can view all resources within your organization in the **Resources** tab. The `•••` menu alongside each resource contains various actions. Some available options include:

- Rename
- Duplicate
- Move to folder
- [Protect resource](../../source-control/guides/protect/resources.mdx) (only available if you use Source Control)
- Delete

You can also access a subset of actions when editing a resource, either from the resource configuration page or when you edit a resource within the app IDE.

Duplicating a resource creates a resource with the same configuration and credentials. This includes authentication tokens used to authenticate with the resource. The duplicate resource also inherits the default permissions of the folder that the resource is created in.

---

## Export table data from Retool Database

You can export Retool Database table data in CSV format to create a backup or migrate to another database. You can also query a table if you want to export and save the data progammatically.

## Export as CSV

You can export Retool Database tables as a comma-separated `.csv` file directly from the editor. Right-click on the table's tab and select **Export CSV**. Retool generates the CSV file, which is then downloaded using your browser.

You can also click  in the toolbar and select **Export CSV**.

## Retrieve data using SQL

You write [SQL queries](../../../queries/guides/sql/queries.mdx) within Retool apps and workflows to interact with Retool Database table data. If you need to retrieve table data and store it elsewhere, write an SQL query such as:

```sql title="Retrieve table data"
select * from customers
```

:::warning
Avoid retrieving large datasets using SQL. If you need to export a table with many rows, export it as a CSV.
:::

---

## Access Retool Database tables externally

Retool provides connection strings as [PSQL commands](https://www.postgresql.org/docs/current/app-psql.html) and [PostgreSQL connection URLs](https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-CONNSTRING) for cloud-hosted organizations to access their Retool Database data externally.

## Get connection details

:::info
Only admin users can view connection string information.
:::

You can copy the PSQL command directly to the command line, or use the PostgreSQL connection URL in external applications. For example, use the connection URL in PostgreSQL clients such as [PgAdmin](https://www.pgadmin.org/), platforms such as Zapier, or any ORM which connects to PostgreSQL. Some tools may not support connection strings with role names and passwords, so you may need to enter these fields directly.

export function ArcadeEmbed() {
  return (
    
      
    
  )
}

Tables created using connection strings might not immediately appear in the Retool Database editor. You can select the table from the sidebar to open it.

---

## Customize field views in Retool Database

The Retool Database editor has a number of view options for table fields to customize the experience. Click  in the field header to display the contextual menu with additional options. You can also click  in the toolbar to view field options.

## Pin a field

Select Pin this field to keep the field visible on the left-side of the table. Pinned fields remain in view when you horizontally scroll. 

export function PinField() {
  return (
    
      
    
  )
}

## Hide and reorder fields

Select Hide this field to hide the field from view. Hidden fields are not deleted from the table and only hidden from view. You can also control the visibility of all fields, and change the order of fields in the table, from the  options in the toolbar. 

export function HideReorder() {
  return (
    
      
    
  )
}

---

## Filter and sort Retool Database table rows

You can search Retool Database table data, apply filters, and customize sort options in the editor.

## Search records

Click  or press Mod f, then enter a search term to search through all records in the current table. Any results are highlighted and you can move between results using the search box.

Search table data.

## Filter records

Click  to define filter conditions and show only records that match all of them. For example, you can show only records with a `quantity` field value less than `9000` and contain `the` in the `name` field value.

You can add multiple field filters from the **Field options** menu. Click the field name in the header and select **Filter by this field**.

Filter table data.

Click **Apply filter** to filter records. The  popup remains active while filters are applied and displays the number of filter conditions in use. To disable the filter, remove all filters and click **Apply filter** again.

## Sort records

You can sort rows by columns in either ascending or descending order, and sort by multiple columns. Click  in the field header and select the sort mode you want to use. You can also click  in the toolbar to open sorting options.

Sort table records.

---

## Retool Database how-to guides



---

## Link Retool Database tables

You can link rows between tables in the Retool Database editor to see relevant data in one place. For example, you could link a table with customer information to another table with subscriptions.

The **Foreign Key** field references a field from another table that contains unique values, such as the primary key. Once a value is set, you can view the relevant linked row. 

## Add a Foreign Key field

To add a foreign key field to a table:

1. Click  to the right of the last field.
1. Select **Foreign key** as the field type.
1. Specify the table and field on which to link. For example, the `id` field of a `subscriptions` table. You can only select fields with unique values.
1. Set a value in the new field that corresponds to a value of the field you selected. For example, a subscription ID.

## View linked table data

Once linked, you can click  within the cell to open the referenced row. You can then edit the referenced table data directly without needing to switch to another table.

The values you specify for foreign keys do not need to be unique. You can link to the same unique row on the linked table multiple times (e.g., multiple orders for the same customer).

export function ArcadeEmbed() {
  return (
    
      
    
  )
}

---

## Manage table data in Retool Database

You can manage data for your Retool Database tables using the editor. The spreadsheet-like interface enables you to add, edit, and remove rows without needing to write SQL statements.

## Add a row

Click  in the toolbar and select . You can also use the keyboard shortcut Mod Return to quickly add new rows.

## Edit row data

Double-click on a cell to edit its value. The editor presents different input options depending on the field type. For example, editing a **Checkbox** field value (i.e., the `BOOL` PostgreSQL column type) presents the choice of setting `TRUE` or `FALSE`.

Edit a cell value.

## Delete rows

To delete rows of data, select them using the checkbox and click the red **Delete** button at the bottom of the window.

:::danger
Deleting a field permanently removes it and any data it contains from the table. You should [export table data](./export-data.mdx) before making any significant changes.

:::

---

## Manage Retool Database table fields

A Retool Database field is a table column for a specific type of data. Each field maps to a supported [PostgreSQL column type](#available-fields-and-types) that specifies both the type and format of data. For example, the **Number** field is for number values, but you can specify which PostgreSQL type to use, such as `integer`, `float`, or `decimal`.

## Available fields and types

When adding or editing table fields, you must specify the correct PostgreSQL column type to ensure that only valid data is entered. It also configures additional methods of input and determines how best to filter data.

Use the app below to explore Retool Database fields and supported PostgreSQL types.

## Add a new field

To add a field, click  to the right of the last column. Specify the name and type, then click **Save**.

Add a field.

You can also add a new field to the left or right of existing fields; Click the field name to open the **Field options** menu and select either  or .

Insert a field to the left or right of an existing field.

When adding a field, you [configure its options](#configure-field-options) based on your requirements.

## Remove a field

To remove a field, click  in the field header and select **Delete** in the toolbar.

:::danger
Deleting a field permanently removes it and any data it contains from the table. You should [export table data](./export-data.mdx) before making any significant changes.

:::

Select the rows to delete.

## Configure field options

You can configure additional options to refine the values for a field to further customize the data it stores.

Configure field options.

#### Nullable

Set **Nullable** to **true** to allow empty values for the field. This is useful for optional information that isn't required. For required fields, such as an order number, set this to **false**.

#### Unique

The **UUID** and **auto-incrementing integer ID** fields require unique values by default. You can also specify whether other fields should require unique values by setting **Unique** to **true**. When enabled, each row value must be unique. This is useful for unique data, such as a customer's email address or order number.

#### Default value

You can optionally specify a _default value_ for a field if a new row is added without explicitly setting its value. Retool Database supports a manually specified default value or an SQL expression. An SQL expression is useful for default values that are dynamically set, such as a date:

```title="Default value of the current date"
CURRENT_DATE
```

Refer to [PostgreSQL's official documentation](https://www.postgresql.org/docs/9.5/datatype.html) to learn more about PostgreSQL schemas and data types.

---

## Use Retool Database with multiple environments

You can use Retool Database with [multiple environments](../../../org-users/guides/configuration/environments.mdx#configure-environment-resources) to develop apps and workflows using nonproduction data. You can then use schema migrations to sync table schema changes between environments.

The Retool Database resource is automatically configured for any additional environments in use by your organization. Each environment contains an isolated set of tables—modifications in one environment does not impact other environments.

## Select the environment

The Retool Database editor uses table data for the currently selected environment, which is _production_ by default. Use the **Environment** menu in the lower-left to select which environment data to use.

Switch environments in the Retool Database editor.

## Migrate table schema between environments

The **Retool Database** resource is automatically configured for all environments your organization uses. Using *schema migrations*, you can update Retool Database table schemas in one environment and copy these changes to another environment. This allows you to iterate on your database schema in testing environments and deploy updates to users on production apps only when changes are ready.

### Schema migration

You can create a schema migration after creating, updating, or removing any tables or fields in any environment. Click the **Environment** menu in the lower-left and select **Schema migration**.

The **History** view shows past migrations, including the executed SQL and whether the migration completed successfully. Click **New migration** to start creating a migration.

On the new migration modal, you can choose the source and destination environments using the dropdowns and view the schema differences between the two environments. For example, the following shows the addition of two fields: an integer field named `age` and a text field named `avatar_url`. Each are present in the staging environment and not in production.

You can click the checkboxes next to the modified tables or fields to exclude changes from the migration.

#### Preview and edit SQL

In the GUI view, the SQL a migration executes is generated automatically. To preview this SQL, click the **SQL** tab. You can edit this SQL to execute custom migrations, but you cannot return to the GUI view after making changes to the SQL. To return to the GUI view, click the **Undo SQL edits** button to reset the SQL changes.

### Execute migrations

To run schema migrations, select the confirmation checkbox and click **Migrate**. On the **History** modal, your migration will display as **Running** and marked as **Completed** when it's finished. You can then navigate back to your destination environment to see the changes reflected on that database.

### Failed migrations

Migrations with errors show as **Failed** in the **History** modal. When a migration fails, none of its changes apply to your database, so after fixing any errors you can run a migration containing the same changes. The detail view for these failed migrations contains the related PostgreSQL error message.

---

## Shell script resource

# Run shell scripts on remote hosts

:::note Beta

The Shell Script resource is currently in beta and may be modified in backward-incompatible ways.

Imagine you have python scripts that you would like to trigger from a Retool application. You could build an API that accepts requests and runs these scripts, but that is a lot of work to build, deploy, and maintain. If you had to run these scripts manually, you would likely ssh into the remote host and directly call them. The Shell Script resource allows your Retool applications to do this; connect directly to remote machines and execute arbitrary commands.

## Set up

### 1. Go to `settings/beta` and toggle Shell Scripting

![](https://d3399nw8s4ngfo.cloudfront.net/docs/rd/c369f2c-Screen_Shot_2021-07-23_at_4.45.38_PM.png)

### 2. Create a new resource & choose Shell Script

![](https://d3399nw8s4ngfo.cloudfront.net/docs/rd/e1b484a-Screen_Shot_2021-07-23_at_4.47.04_PM.png)

### 3. Enter machine information

![](https://d3399nw8s4ngfo.cloudfront.net/docs/rd/22db270-Screen_Shot_2021-07-23_at_4.51.56_PM.png)

### 4. Download Retool's public key

Your instance of Retool generates a public and private key pair. For Retool to connect with your remote host, you must add Retool's public key. This is the same process we recommend for configuring bastion hosts, and detailed steps can be found [here](../../guides/connections/ssh-tunnels.mdx).

### 5. Test connection and create resource

![](https://d3399nw8s4ngfo.cloudfront.net/docs/rd/40d49f3-NmmQyAyw.png)

Test the connection by clicking the Test Connection button right next to the Create Resource button in the bottom right.

# Example Usage

### Calling simple, static commands

Any command supplied to a Shell Script query will be executed on the remote host. A simple application might allow a user to click a button to get the uptime of that machine. To do this, we need a query that calls "uptime", a button to trigger this query, and a place to display the result.

![Uptime query](https://d3399nw8s4ngfo.cloudfront.net/docs/rd/8716af3-Screen_Shot_2021-07-23_at_5.01.31_PM.png)

The result of a Shell Script query is an object with three keys:

- `exitCode`: the exit code from the process
- `stdErr`: standard error from the process
- `stdOut`: the standard out from the process

![A text component displaying the results of `getUptime.data.stdOut`](https://d3399nw8s4ngfo.cloudfront.net/docs/rd/53dc785-Screen_Shot_2021-07-23_at_5.05.09_PM.png)

### Calling commands with dynamic arguments

In real applications, we need to trigger commands with dynamic arguments. The Shell Script resource can take arguments from a Retool application via the `{{ }}`. For example, if we had a dropdown with two different commands, we could run one of them by consuming `{{ dropdown1.value }}` as Shell Script arguments.

![Calling a command with dynamic arguments.](https://d3399nw8s4ngfo.cloudfront.net/docs/rd/1cdb3df-Screen_Shot_2021-07-23_at_5.11.18_PM.png)

---

## Run shell scripts on remote hosts

:::info beta

The Shell Script resource is currently in beta and may be modified in backward-incompatible ways. It is only available on Self-hosted Retool.

:::

Imagine you have python scripts that you would like to trigger from a Retool application. You could build an API that accepts requests and runs these scripts, but that is a lot of work to build, deploy, and maintain. If you had to run these scripts manually, you would likely ssh into the remote host and directly call them. The Shell Script resource allows your Retool applications to do this; connect directly to remote machines and execute arbitrary commands.

# Set up

### 1. Go to `settings/beta` and toggle Shell Scripting

![](https://d3399nw8s4ngfo.cloudfront.net/docs/rd/c369f2c-Screen_Shot_2021-07-23_at_4.45.38_PM.png)

### 2. Create a new resource & choose Shell Script

![](https://d3399nw8s4ngfo.cloudfront.net/docs/rd/e1b484a-Screen_Shot_2021-07-23_at_4.47.04_PM.png)

### 3. Enter machine information

![](https://d3399nw8s4ngfo.cloudfront.net/docs/rd/22db270-Screen_Shot_2021-07-23_at_4.51.56_PM.png)

### 4. Download Retool's public key

Your instance of Retool generates a public and private key pair. For Retool to connect with your remote host, you must add Retool's public key. This is the same process we recommend for configuring bastion hosts, and detailed steps can be found [here](../connections/ssh-tunnels.mdx).

### 5. Test connection and create resource

![](https://d3399nw8s4ngfo.cloudfront.net/docs/rd/40d49f3-NmmQyAyw.png)

Test the connection by clicking the Test Connection button right next to the Create Resource button in the bottom right.

# Example Usage

### Calling simple, static commands

Any command supplied to a Shell Script query will be executed on the remote host. A simple application might allow a user to click a button to get the uptime of that machine. To do this, we need a query that calls "uptime", a button to trigger this query, and a place to display the result.

![Uptime query](https://d3399nw8s4ngfo.cloudfront.net/docs/rd/8716af3-Screen_Shot_2021-07-23_at_5.01.31_PM.png)

The result of a Shell Script query is an object with three keys:

- `exitCode`: the exit code from the process
- `stdErr`: standard error from the process
- `stdOut`: the standard out from the process

![A text component displaying the results of `getUptime.data.stdOut`](https://d3399nw8s4ngfo.cloudfront.net/docs/rd/53dc785-Screen_Shot_2021-07-23_at_5.05.09_PM.png)

### Calling commands with dynamic arguments

In real applications, we need to trigger commands with dynamic arguments. The Shell Script resource can take arguments from a Retool application via the `{{ }}`. For example, if we had a dropdown with two different commands, we could run one of them by consuming `{{ dropdown1.value }}` as Shell Script arguments.

![Calling a command with dynamic arguments.](https://d3399nw8s4ngfo.cloudfront.net/docs/rd/1cdb3df-Screen_Shot_2021-07-23_at_5.11.18_PM.png)

---

## Troubleshoot resource connections

Retool can connect to many databases and APIs. Certain data sources may have specific setup requirements, such as allowed IPs or required keys. Where necessary, we document these requirements. Refer to the integration's documentation when configuring your resource and use the following information as you troubleshoot any connection issues. If you need to make changes with your data source, refer to their documentation for more information and guidance.

Some resources include testing options that you can use to troubleshoot connection issues. These options are displayed when you create or edit a resource, and include a [debugging console](../../apps/concepts/debug-tools.mdx#resource-configuration-page) that displays detailed error information.

## Allow Retool IP addresses to access your data source

Certain resources use an allowlist of IP addresses to prevent unauthorized connections. [Add Retool's IP addresses to your allowlist](../reference/ip-allowlist-cloud-orgs.mdx) if necessary.

Each data source can use a different method for allowing remote connections. Refer to the data source's documentation to learn how you add allow IP addresses.

:::info Connect without allowlist

Retool is building support for querying firewalled resources without allowlisting Retool’s IP address. To learn more or be considered for early access, contact cloud-connect@retool.com.
:::

## Verify your credentials or connection string is correct

For databases like [PostgreSQL](integrations/database/postgresql.mdx) and [MongoDB](integrations/database/mongodb.mdx), Retool allows you to connect using traditional credentials (username, database, password, port) and a _connection string_.

Verify that your credentials are correct and that you're referencing the correct database.

The final part of a connection string (`/mydb`) references the database name. Ensure that your connection string references the correct database. If you copy a connection string from a console (like MongoDB Atlas), this may default to another database name.

## Database or provider credentials

You must provide a database username and password when connecting using traditional credentials or with a connection string. These credentials are often not the same as those used to access your data source's web console.

Create a new database user specifically for connecting with Retool and use these credentials to create the resource.

## SSL and certificates

Certain integrations support SSL encryption, such as [MongoDB](https://docs.mongodb.com/manual/tutorial/configure-ssl/). This additional layer of security keeps your data safe and prevents threats like [man-in-the-middle](https://en.wikipedia.org/wiki/Man-in-the-middle_attack) (MITM) attacks.

If SSL is available for a resource, Retool displays **SSL** on the resource connection page.

If your database uses a self-signed certificate instead of a publicly signed certificate, you must configure Retool to trust the custom certificate. Check **Connect using SSL** and then check **Use a self-signed certificate**.

## Connect via SSH tunneling

If you cannot allow Retool's IP address or need to use data on a private network, you can [create an SSH tunnel](connections/ssh-tunnels.mdx). SSH tunneling is not supported by all integrations.

## Common error messages

Retool reports on any errors when connecting to a data source. The following errors occur if any provided information is invalid (e.g., username and password are incorrect) or if Retool is unable to connect to the data source (e.g., Retool IP addresses not added to an allowlist).

| Error                                     | Description                                                                                                                                                               |
| ----------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `getaddrinfo ENOTFOUND`                   | The hostname is not reachable. Verify the hostname details are correct, Retool is allowed to access it, or if it is behind a private network that requires SSH tunneling. |
| `password authentication failed for user` | The credentials are incorrect. Verify the credentials and try again.                                                                                                      |
| `database "" does not exist`              | The database does not exist. Verify the database details and try again.                                                                                                   |
| `connect ECONNREFUSED`                    | The port is incorrect or Retool is not allowed to access the data source.                                                                                                 |

---

## Manage embeddings in Retool-managed Vectors

You can use [Retool-managed Vectors](../../quickstarts/retool-vectors.mdx) to store plain text or extracted text from PDF documents, or text from publicly accessible web pages.

:::note

If your deployment is self-hosted, follow the [Enable Retool-managed Vectors on self-hosted deployments](../../../self-hosted/guides/vectors.mdx) guide before you get started.

:::

## Create a vector

Within the scope of Retool-managed Vectors, a vector is a collection of unstructured text (known as _embeddings_). You create a vector to define the overall relationship and then add text or URLs to it. For example, if you wanted to build an AI-powered chat tool and want it to use context from your support site, you would create a vector (such as **Documentation**) and add URLs from your documentation site.

To create a Vector:

1. Navigate to the Resources landing page and click **Retool Vectors**.
2. Click **Create new** and select **Vector** from the dropdown list.
3. Specify a **Vector name**.
4. The **Default embedding model** is ```text-embedding-ada-002```, but you can select the [OpenAI embedding model](https://platform.openai.com/docs/guides/embeddings#embedding-models) of your choice from the dropdown. 
5. Add **Filter labels** to filter vectors with Retool AI queries. Refer to [Use Retool AI to query vectors with filters and metadata](./filters.mdx) for more information.
    :::info
    To use filters and metadata in Retool AI queries, you must define them when creating a vector. If no filter labels are provided, all vectors are searched during a query.
    ::: 
6. Add metadata to the **Default metadata** field in key-value pairs. 
7. Choose whether the **Vector type** is a **Document** or a **Site URL**. 
    :::info Vector contents
    Each vector you create can contain either document text or URLs, not both.
    :::
8. Click **Create**.

export function ArcadeEmbed_createnew() {
  return (
    
      
    
  )
}

## Edit a vector

You can edit the **Vector name**, **Description**, **Filter labels**, and **Default metadata** of a Retool-managed Vector. 

:::note
You cannot change the embedding model of a vector once it has been created.
:::

Select the vector to edit, click `•••`, then select **Edit vector details**.

If necessary, click **Delete Vector** to remove it. All vector data will be removed and cannot be recovered—you would need to recreate the vector.

export function ArcadeEmbed_edit() {
  return (
    
      
    
  )
}

## Remove documents and URLs

Toggle the checkbox next to the document or URL in a vector to select it, then click **Delete**.

You can add documents or plain text to a vector manually or query the **Retool Vectors** resource in apps or workflows.

## List Vectors

You can query the **Retool Vectors** resource in apps or workflows to list all available Vectors. This enables you to build apps that allows users to select a Vector and perform further actions, such as adding documents or URLs to it.

1. Set **Resource** to **Retool Vectors**.
2. Set **Vector action** to **List all Vectors**.

---

## Use Retool AI to query vectors with filters and metadata

You can use AI actions in Retool to reference the embeddings stored in Retool Vectors. Retool Vectors can be queried from [Retool Apps](../../../apps/index.mdx) or [Retool Workflows](../../../workflows/index.mdx) using [AI Actions](../../../workflows/guides/blocks/ai-action.mdx). 

* *Metadata* allows you to provide additional context about your data with a key-value pair and can help you organize and manage your vectors. 
* *Filter labels* help you select and retrieve the vectors that are relevant to a query. 

:::note
Before you can use Retool AI to query a vector with filters or metadata, they must first be added to a Retool Vector. See [Manage embeddings in Retool-managed Vectors](./embeddings.mdx) for more information.
:::

## Generate text with Retool AI

Use the **Generate text** AI action with the filter labels applied to your vectors to generate a text response based on specific embeddings. 

1. Open the **Code** panel.
2. Click the **+** sign and select **AI Action**, or add a **Resource query** and change the **Resource** field to **Retool AI**.  
3. Select **Generate text** as the **Action**. Refer to [Generate text](../../../queries/guides/ai/text.mdx#generate-text) for more information.
4. Toggle the checkbox on to **Use Retool Vectors to provide more context to your query**. 
5. Select the vector(s) you want to query in the **Select Vector** field. 
6. In the **Filters** field, select the vector document or URL that you want to use for your query. 
7. Add a prompt to the **Input** field.
8. Click **Save**. 
9. Click **Run** to display the generated text in the **Output** message. 

export function ArcadeEmbed_generate_text() {
  return (
    
      
    
  )
}

## Generate chat response with Retool AI

Use the **Generate chat response** AI action with the filter labels applied to your vectors to generate a chat response based on specific embeddings. 

1. Open the **Components** panel.
2. Search for the **LLM Chat** component and drag it to the canvas.
3. A chat query is automatically created with the **Generate chat response** AI action selected. Refer to [Retool AI chat actions](../../../queries/guides/ai/chat.mdx) for more information.
4. Toggle the checkbox on to **Use Retool Vectors to provide more context to your query**. 
5. Select the vector(s) you want to query in the **Select Vector** field. 
6. In the **Filters** field, select the vector document or URL that you want to use for your query. 
7. Click **Save**. 
8. Type a message in the chat component to generate a response.

export function ArcadeEmbed_chat() {
  return (
    
      
    
  )
}

---

## Store vector embeddings for AI actions



---

## Store documents and text in Retool-managed Vectors

You can use [Retool-managed Vectors](../../quickstarts/retool-vectors.mdx) to store and generate AI-related vector data for plain text or extracted text from PDF documents. Retool can then provide AI models with related information when performing [AI actions](../../../queries/concepts/actions.mdx).

## Add a document

:::info Workflows only accept plain text

You cannot use the **Convert document to text** AI action in a workflow. You need to extract the text first and make it available for the workflow to use.

:::

You can add documents or plain text to a vector manually or query the **Retool Vectors** resource in apps or workflows.

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

1. Navigate to the **Resources** page and select **Retool Vectors**.
2. Select the vector in which to add.
3. Click **Add document**, then select either **Upload file** or **Add plain text**.
4. **Filter labels** and **Metadata** are inherited from the parent vector.

:::tip Extract text from PDFs in apps

Use the [Convert document to text AI](../../../queries/guides/ai/document.mdx#convert-document-to-text) action in web or mobile apps to first extract text from a PDF document. You can then reference the extracted text using `{{ }}` notation, such as `{{ convertDocument.data }}`.

:::

1. Create an app or a workflow, open the **Code panel**, and click the plus sign **+** to add a new **Resource query**. 
2. Set the **Resource** to **Retool Vectors**.
2. Set **Vector action** to **Insert document**.
3. Select the **Vector** in which to store the document. 
4. Set **Document content** to the desired text.
5. **Filter labels** and **Metadata** are inherited from the parent vector.
6. Specify a name for the document in the **Document name** field.
7. **Save** and **Run** the query. 

export function ArcadeEmbed() {
  return (
    
      
    
  )
}

When run, the query adds a new document to the vector. If a document with the same name already exists, the query returns an error.

## Update or upsert a document

Use the **Update document** action to update an existing document. You can also use the **Upsert document** action to update an existing document or create one if it doesn't exist.

Combine this with the [List documents](#list-documents) action in apps to enable users to select from a list of documents in a vector.

From a **Resource query**: 

1. Set **Resource** to **Retool Vectors**.
2. Set **Vector action** to **Update document** or **Upsert document**.
3. Set **Document content** to the desired text.
4. Make updates to **Filter labels** and **Metadata** as needed.
5. Specify a name for the document in the **Document name** field.

export function ArcadeEmbed_upsert() {
  return (
    
      
    
  )
}

When run, the query adds a new document to the vector. If a document with the same name already exists, the contents are updated.

## Delete an existing document

Use the **Delete an existing document** action to remove a specified document from a vector.

:::danger Destructive action

Any documents you delete from a Vector are unrecoverable. Enable **Show a confirmation modal before running** in the **Advanced** tab to display a confirmation message and prevent accidental deletion.

:::

From a **Resource query**: 

1. Set **Resource** to **Retool Vectors**.
2. Set **Vector action** to **Delete document**.
3. Select the vector in the **Vector** field.
4. Specify the name of the document in the **Document name** field.

## List documents

Use the **List documents** action to retrieve a list of all documents in an existing vector.

From a **Resource query**: 

1. Set **Resource** to **Retool Vectors**.
2. Set **Vector action** to **List document**.
3. Set **Document content** to the desired text.
4. Specify a name for the document in the **Document name** field.

## Get document chunks

Use the **Get document chunks** action to retrieve the text for a specified document. When run, the query returns a list of text strings.

From a **Resource query**: 

1. Set **Resource** to **Retool Vectors**.
2. Set **Vector action** to **Get document chunks**.
3. Select the vector in the **Vector** field.
4. Specify the name of the document in the **Document name** field.

## Clear Vector documents

Use the **Clear Vector documents** action to delete all documents in the specified vector.

:::danger Destructive action

Any documents you delete from a Vector are unrecoverable. Enable **Show a confirmation modal before running** in the **Advanced** tab to display a confirmation message and prevent accidental deletion.

:::
From a **Resource query**: 

1. Set **Resource** to **Retool Vectors**.
2. Set **Vector action** to **Clear Vector documents**.
3. Select the vector in the **Vector** field.

---

## Store web page text in Retool-managed Vectors

You can use [Retool-managed Vectors](../../quickstarts/retool-vectors.mdx) to store and generate AI-related vector data for text from publicly accessible web pages. Retool then crawls the specified URLs and fetches the text content. Retool can then provide AI models with related information when performing AI actions.

:::note
URL crawling is not supported for [Self-hosted Retool](../../../self-hosted/index.mdx) instances.
:::

## Create URL Vector

You can create a URL Vector and add URLs for publicly accessible web pages manually or query the **Retool Vectors** resource in apps or workflows. You only need to specify a base URL, such as `https://docs.retool.com`—Retool crawls the URL and fetches text for any pages at this location.

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

1. Navigate to the **Resources** settings and click **Retool Vectors**.
2. Click **Create new**.
3. Select **Vector**.
4. Specify the **Vector name**, the **Default embedding model**, **Filter labels** and **Default metadata** in the appropriate fields.
5. Choose **Site URLs** for the **Vector type**.
6. Click **Create**.
7. Click **Add URLs**.
8. Specify the web pages in the **Links to crawl** field.
9. Add links to exclude from the vector in the **Link prefix to exclude** field as necessary. 
10. The **Filter labels** and **Default metadata** are prepopulated based on what you specified during vector creation in step 4. 
11. Click **Fetch**. 

Retool crawls the specified URLs and automatically fetches the text content and creates embeddings for each.

export function ArcadeEmbed_website() {
  return (
    
      
    
  )
}

1. Open the **Code** panel. 
2. Click the **+** sign to add a new **Resource query**. 
3. Set **Resource** to **Retool Vectors**.
4. Set **Vector action** to **Create URL Vector**.
5. Specify the **Vector name**, the **Default embedding model**, **Filter labels** and **Default metadata** in the appropriate fields.
6. Specify the URL in the **Links to crawl** field.
7. Click **Save**.
8. Click **Run**.

export function ArcadeEmbed_fromApp() {
  return (
    
      
    
  )
}

## Refresh a URL vector

If the content of crawled web pages has changed, use the **Refresh URL Vector** action to crawl the URLs again. Retool updates existing embeddings with any new content and calculates new vector data automatically.

1. Set **Vector action** to **Refresh URL Vector**.
2. Specify the vector to refresh in the **Vector** field.

## List all URLs in a vector

Use the **List URLs** action to retrieve a list of all crawled URLs within the specified vector.

1. Set **Vector action** to **List URLs**.
2. Specify the vector to refresh in the **Vector** field.

## Get URL chunks

:::tip Combine with the List URLs action

Use the **List URLs** action to get a list of URLs within a vector in a separate query. You can then reference a specific URL using `{{ }}` notation, such as `{{ listUrls.data[2] }}`.

:::

Use the **Get URL chunks** action to retrieve the chunked text for a specified URL in a vector.

1. Set **Vector action** to **Get URL chunks**.
2. Specify the vector to use in the **Vector** field.
3. Specify the URL for which to get chunks in the **url name** field.

---

## Resources how-to guides

import Howto from '/docs/_partials/_doctypes/_howto.mdx';

:::tip Get started

If you want to connect your data to Retool:

- Read the [quickstart](./quickstart) to learn about the fundamental concepts.
- Follow a [tutorial](./tutorial/) to connect your data sources or use Retool's built-in solutions.

:::

---

## Data sources documentation

You can connect almost any API or database to Retool and build software using your data. Retool includes a wide range of API and database integrations, such as Salesforce and PostgreSQL, and you can connect to any REST or GraphQL API.

Retool also offers a number of built-in solutions that you can use instead of, or alongside, other data sources.

Built-in [integrations](guides/integrations/index.mdx) enable you to connect almost any API and database with Retool.

[Retool Database](quickstarts/retool-database.mdx) is a managed PostgreSQL database with a spreadsheet-like interface to manage your data.

export function ArcadeIntro() {
  return (
    
      
    
  );
}

[Retool Email](quickstarts/retool-email.mdx) is a hosted email resource for cloud-hosted organizations to send emails without needing to configure an email provider.

[Retool Storage](quickstarts/retool-storage.mdx) is a Retool-hosted file store for cloud-hosted organizations. Using Retool Storage, you can upload and download files and use them in your apps and workflows.

Upload documents and URLs to use as text embeddings to inform AI models.

---

## Resources quickstart

This guide serves as an introduction to resources, data sources, and integrations. It covers many of the concepts and terminology you can expect to use as you connect data sources to use with apps and workflows. After reading this page, you should have a good understanding of the fundamentals for connecting APIs and databases.

## Introduction

You can connect almost any [data source](#data-sources) and make it available for use in your Retool organization as a [resource](#resources). Retool includes a wide range of [integrations](#integrations) and [authentication methods](#authentication-methods) so you can connect to almost any database or API.

Retool also offers a range of [built-in solutions](#built-in-solutions) that you can use instead of external data sources.

## Data sources

A data source is somewhere you store and perform operations with data. This could be a [PostgreSQL database](https://www.postgresql.org/), the [Twilio REST API](https://www.twilio.com/docs/usage/api), an [Amazon S3 bucket](https://docs.aws.amazon.com/AmazonS3/latest/userguide/UsingBucket.html), etc. You can add as many data sources as you need to Retool and make them available for users to query.

## Resources 

A [resource](resources.mdx) is a saved set of user-configured properties that determine how Retool interacts with a data source. You create a resource for each data source you want to use with Retool. You can then select the resource when writing a query so you can interact with the data.

Each resource has its own configuration options that Retool uses when interacting with a data source. This configuration can include:

- Authentication credentials and flow (username and password, API key, OAuth, etc.)
- Database connection settings (host, port, database name, etc.)
- API settings (base URL, default headers, cookies, etc.)

### Retool access to resources

import Allow from '../reference/ip-allowlist-cloud-orgs.mdx';

### Lifecycle

import Lifecycle from '../../_partials/_resource-lifecycle.mdx';

### Authentication methods

Retool supports wide range of [authentication methods](../guides/authentication/api.mdx), including:

- API keys and tokens
- Auth0
- AWS IAM
- Basic HTTP authentication
- Bearer authentication
- Digest authentication
- Google service account
- Oauth 1.0
- Oauth 2.0
- OAuth 2.0 custom applications
- Session-based

You can also [configure custom authentication](../guides/authentication/custom.mdx) to perform complex or bespoke resource authorization that require multiple steps.

## Integrations

_Integrations_ are the available data source types for which you can create a resource. Retool includes [built-in integrations](https://retool.com/integrations/) for many popular data sources that require minimal configuration, such as [SQL databases](../guides/integrations/index.mdx), [Twilio](https://retool.com/integrations/twilio), and [Stripe](https://retool.com/integrations/stripe). 

If Retool doesn't have a built-in integration for a particular type of data source, you can connect to almost any API using [REST](../guides/integrations/api/rest.mdx), [GraphQL](../guides/integrations/api/graphql.mdx), or [SOAP](../guides/integrations/api/soap.mdx) integrations.

## Built-in solutions

Retool has a number of built-in resources with which you can store and use data.

### Retool Database

[Retool Database](./retool-database.mdx) is a fast, secure solution for saving and editing data to use in Retool apps. It combines a PostgreSQL database with a spreadsheet-like interface to manage your data. On Retool Cloud, the underlying database is managed by Retool. On [Self-hosted deployments](../../self-hosted/guides/retool-database.mdx), you host your own PostgreSQL database.

### Retool Email

[Retool Email](./retool-email.mdx) is a hosted email resource for cloud-hosted organizations to send emails without needing to configure an email provider. You can build apps and workflows that send emails using the **Retool Email** resource. 

### Retool RPC

[Retool RPC](./retool-rpc.mdx) (Remote Procedure Call) is a fast, secure solution for connecting your own codebase to Retool. You define functions in your backend and then call them from Retool apps using a Retool RPC resource.

### Retool Storage

[Retool Storage](./retool-storage.mdx) is a Retool-hosted file store for cloud-hosted organizations. Using Retool Storage, you can upload and download files and use them in your apps and workflows. Retool Storage includes up to 5 GB of storage per organization. Files can be up to 40 MB each, although your browser may have settings that restrict this limit further.

Some file input components, such as [Image](https://retool.com/components/image) and [PDF](https://retool.com/components/pdf), have built-in support for files on Retool Storage; automatically uploading files without the need for separate queries.

### Retool Vectors

[Retool-managed Vectors](./retool-vectors.mdx) is a hosted vector database that enables you to store unstructured text from documents and web pages for use with AI models through Retool. Retool abstracts away the complexities of preparing text and automatically generates the required data for AI models to make decisions using your data.

## Helper resources

_Helper resources_ don't interact with data sources. Instead, they provide you with additional functionality to transform or manipulate data. These resources include:

| Resource                                                                | Description                                                       |
| ----------------------------------------------------------------------- | ----------------------------------------------------------------- |
| [Query JSON with SQL](../../queries/guides/sql/query-json.mdx)               | Write SQL statements to query JSON data.                          |
| [PDF Exporter](../../queries/guides/generate-pdfs.mdx)     | Export data as a PDF file.                                        |
| [ParentWindow](../../apps/guides/app-management/embed-apps.mdx)                 | Receive data from the parent page when using an embedded web app. |
| [Run JS Code](../../queries/guides/javascript/index.mdx)     | Write JavaScript code to transform data or control app behavior.  |
| [Mobile Push Notifications](../../mobile/guides/app-management/push-notifications.mdx) | Send push notifications to Retool Mobile app users.               |
| [Retool Workflow](../../queries/guides/workflows.mdx)               | Run a workflow using provided data and receive the output.        |
| User Action                                                             | Perform actions for external users.                               |
| [Import from Query Library](../../queries/guides/query-library.mdx) | Import a query from the shared Query Library.                     |

---

## Retool Database quickstart

This guide serves as an introduction to Retool Database. It covers many of the concepts and terminology you would come across when working with data in Retool Database. After reading this page, you should have a good understanding of the fundamentals for Retool Database.

## Introduction

Retool Database is a fast, secure solution for saving and editing data to use in Retool apps. It combines a PostgreSQL database with a spreadsheet-like interface to manage your data. On Retool Cloud, the underlying database is managed by Retool. On [Self-hosted deployments](../../self-hosted/guides/retool-database.mdx), you host your own PostgreSQL database.

export function ArcadeIntro() {
  return (
    
      
    
  )
}

## Features

With Retool Database, you can:

- [Store tables of data](../guides/retool-database/manage-fields.mdx) in a securely hosted PostgreSQL database that's only available as a resource within your Retool organization.
- [Visually interact with data](../guides/retool-database/manage-data.mdx) using a spreadsheet-like interface to edit, search, filter, and sort records.
- Import or [export](../guides/retool-database/export-data.mdx) data in CSV format.
- [Build apps and write queries](../quickstarts/resources.mdx) to interact with Retool Database like any other resource.
- Make use of [multiple environments](../guides/retool-database/multiple-environments.mdx), such as staging and production.
- [Configure resource permissions](../../permissions/guides.mdx) to control access to Retool Database within your organization.
- [Capture form submissions](../../forms/index.mdx) for forms created in Retool.

Retool Database is available to all cloud-hosted organizations. Self-hosted organizations can follow the [configuration guide](../../self-hosted/guides/retool-database.mdx) to configure Retool Database, backed by your own PostgreSQL database. Once configured, the Retool Database editor is available to use.

Retool Database for cloud-hosted organizations are connected to the internet and can be accessed using the provided [connection string](../guides/retool-database/external-access.mdx#connection-strings). Retool's [security guide](https://docs.retool.com/page/security) provides detailed information about data storage and security for provisioned databases hosted by Retool. Within your Retool organization, you can control who has access by configuring [user permissions](../../permissions/guides.mdx).

:::info
Retool Database is designed to be a convenient way to store data to use within or outside of Retool. It is not designed to be a highly-available, scalable database service, and you should use a separate managed database provider if your use case requires these guarantees.
:::

## Usage and limits 

Cloud-hosted organizations can store the equivalent of 5GB of PostgreSQL data, with unlimited tables and rows. The amount of storage space your data uses is dependent on how many records, fields, and tables you use, and the size of values. Retool customers on a Business or an Enterprise plan that exceed their storage limits can reach out to Retool to request a limit increase. Retool customers on the Free plan would need to upgrade to a Business or an Enterprise plan prior to requesting a storage limit increase.  

## Data redundancy

Retool Database uses multiple levels of redundancy, which include daily backups of all data in a PostgreSQL cluster managed by our cloud provider. Retool retains each of these backups for 7 days. Retool recommends implementing a secondary backup process that stores and retains data for a longer period of time as an additional guardrail.

If you have any questions or would like to know more, [contact Retool Support](/support).

## Staging data

Any changes you make with data in Retool Database cannot be reverted. Retool recommends using [multiple environments](../../org-users/guides/configuration/environments.mdx) with staging data to avoid accidental loss of data.

---

## Retool Email quickstart

Retool Email is a hosted email resource for cloud-hosted organizations to send emails without needing to configure an email provider.

## Features

With Retool Email, you can:

- Send emails from apps and workflows using queries.
- Write messages using plain text, HTML, or Markdown.
- Include attachments with sent messages.
- Set a **Reply-To** address and add **CC/Bcc** recipients.
  
## Availability and limits

Cloud-hosted organizations on paid plans can send up to 120 emails per hour. Organizations on the **Free** plan can send up to 50 emails per day.

## Customization

Retool does not allow users to modify the sender email address. However, you can set a **Reply-To** address so that replies are sent to the email of the your choice. 

Retool sends emails from one of the following addresses:

- `mail@.retool-email.com` when a **Reply-To** address is set. 
- `noreply@.retool-email.com` when no **Reply-To** address is set.

:::note

Messages from Retool Email always include a `Sent via Retool Email (https://retool.com)` line at the bottom. If it is critical to remove this line of branding, Retool recommends using an [SMTP server](../guides/integrations/messaging/smtp.mdx).

:::

---

## Retool RPC quickstart

Retool RPC (Remote Procedure Call) is a fast, secure solution for connecting your own codebase to Retool. You define functions in your backend and then call them from Retool apps using a Retool RPC resource.

## Features

With Retool RPC, you can:

- [Register functions from your codebase](../tutorials/retool-rpc.mdx#2-define-server-side-functions) and use them in Retool apps.
- [Configure function permissions](../tutorials/retool-rpc.mdx#4-configure-function-permissions) to control access to exposed functions within your organization.
- [Use schema versioning](../tutorials/retool-rpc.mdx#5-schema-versioning) to ensure your exposed functions are always up-to-date.
- [Ensure customer safety](#architecture-and-security) with its outbound-only architecture.

## Architecture and security

Retool RPC is an _outbound-only_ architecture, which means the registered server only makes outbound requests to Retool and never receives inbound requests.

On every start up, the RPC server registers itself and the functions it exposes to Retool. After that completes, the RPC server continuously polls for new requests from Retool in the following flow:

Retool stores query requests and responses in a messaging queue. The direction of the arrows represents the direction of the request. 

- The blue arrows represent _Pop Query_ requests, which poll for _Run Query_ requests.
- The black arrows are _Run Query_ requests, which are made by calling functions in the Retool UI. 

When a _Pop Query_ request detects a _Run Query_ request, it interacts with your codebase and then initiates the red flow. This sends a _Post Query Response_ to respond to the original _Run Query_ request.

Only making outbound requests ensures your codebase is never exposed to the internet, and that your data is secure.

Other security measures include:

- Retool requires a valid access token and resource access for all RPC-related requests.
- Each resource is given a different queue to ensure isolation between resources.

---

## Retool Storage quickstart

Retool Storage is a Retool-hosted file store for cloud-hosted organizations. Using Retool Storage, you can upload and download files and use them in your apps and workflows.

:::note

If you use a [Self-hosted Retool deployment](../../self-hosted/guides/retool-storage.mdx), you can use your own storage provider and access your files through the [Retool Storage interface](#managing-files-and-folders).

:::

## Features

With Retool Storage, you can:

- Store up to 5GB of files for use in apps and workflows.
- Easily upload user files with file input components.
- Enable public access to files for use over the internet.
- Upload, download, and manage files using either queries or the Retool Storage interface.

## Identify files

Retool Files are uniquely identified by their URL. URLs let users download files (your Retool app users for private files, anyone on the internet for public files). URLs use the following format: `{your-domain}/api/file/{file-uuid}`.

:::tip
Retool recommends using file URLs to refer to Retool Files from other data resources, like databases.
:::

Using the file's URL, you can download, modify, and otherwise interact with the file.

## Manage files and folders

You can use the Retool Storage interface to manage your files and folders. To access the Retool Storage interface, sign in to your Retool organization, select the **Resources** tab, and click **Retool Storage**.

Within this interface, you can:

- Upload, download, rename, move, delete, and set public access on files.
- Create, rename, and delete file folders.
- Search for files and folders.
- Monitor your storage usage.

## Restrict file access

You can optionally restrict access to files on Retool Storage.

---

## Retool-managed Vectors

This guide serves as an introduction to [Retool Vectors](https://retool.com/products/ai). It covers many of the concepts and terminology you would come across when storing and using vector data. After reading this page, you should have a good understanding of the fundamentals for Retool Vectors.
:::note[Set up Retool AI]
You must set up Retool AI before you can use Retool Vectors. Follow the setup instructions in [Retool AI](../../self-hosted/concepts/retool-ai.mdx#ai-actions).
:::
## Introduction

Retool Vectors enables you to use a vector database to store unstructured text from documents and web pages for use with Retool AI. You can use either:

- [Retool-managed Vectors](#retool-managed-vectors).
- A supported third-party vector store, such as [Amazon Knowledge Bases](#amazon-knowledge-bases).

## AI embeddings and vectors

AI models use embeddings to determine the meaning and connection between objects, such as blocks (chunks) of text. An embedding is a type of vector, a mathematical representation of an object. The more closely related text chunks are, the smaller the difference in their calculated vectors. For example, the vector difference between "water" and "wet" would be smaller than the difference between "water" and "banana".

For use cases that involve similarity search with large datasets, such as an AI-powered chat tool that relies on content from support articles, embedding vectors must be first calculated. This vector data is then provided to the AI model so it can make informed decisions. These vector calculations should be saved in a _vector database_ to allow for efficient storage and retrieval of large datasets of embeddings.

When you reference a Vector in an AI action, Retool includes the most relevant content in the AI model request. When run, Retool automatically:

1. Calculates the vector for the AI action's input.
2. Identifies which embeddings in the chosen vector closely relate to the input.
3. Appends the text from the embeddings when making the request to the AI model.

These steps are performed in the back-end and not visible to users, further reducing complexity.

### Vector organization

You can think of Vectors as file directories, and embeddings as the files they contain. Each Vector should contain relevant information that you consider related. For example, if you wanted to build an AI-powered chat tool that can respond using information from support articles, you would create (such as **Documentation**) and add URLs from your support site.

### Use Vectors in AI actions

You reference embeddings from Retool Vectors in AI actions. Retool includes the most relevant content in the AI model request, based on the input. When run, Retool automatically:

1. Calculates the vector for the AI action's input.
2. Identifies which embeddings in the chosen vector closely relate to the input.
3. Appends the text from the embeddings when making the request to the AI model.

These steps are performed in the back-end and not visible to users, further reducing complexity.

## Retool-managed Vectors

Retool-managed Vectors abstracts away the complexities of preparing text and automatically generates the required data for AI models to make decisions using your data. You create a _vector_ in which to store _embeddings_—unstructured text about a particular topic.

Retool automatically generates embeddings, splitting unstructured text into chunks where needed. If you add URLs to a Vector, Retool crawls matching web pages, fetching and storing the text.

:::info OpenAI embeddings

Retool uses the OpenAI [embeddings API](https://platform.openai.com/docs/api-reference/embeddings) to calculate vectors for text chunks.

:::

You can manually add text to a Vector or write queries that interact with Retool-managed Vectors. Once added, you can manage the embeddings and view the associated text or URL.

### Text embeddings

When you add text to Retool-managed vector, Retool automatically performs the following:

1. If a document is provided, Retool extracts the text.
2. Splits the text into chunks.
3. Calculates the vector for each chunk.
4. Stores this information in the vector.

### URL embeddings

When you add a URL to a Retool-managed vector, Retool automatically performs the following:

1. Crawls the URL for any pages that match. For example, specifying `https://docs.retool.com` would include `https://docs.retool.com/ai` but not `https://retool.com`.
2. Fetches the text for each page and creates a new embedding in the vector.
3. Splits the text into chunks.
4. Calculates the vector for each chunk.
5. Stores this information in the vector.

Retool can only fetch text from web pages that are publicly available and directly linked from other pages. Pages that are not accessible (e.g., requires authentication or behind a firewall) or that have no inbound links (e.g., pages only accessible with a direct URL) cannot be crawled.

You can also exclude certain URLs whose domain and path match. For example, `https://docs.retool.com/changelog` would prevent any pages that contain this URL from being crawled.

## Amazon Knowledge Bases

Retool supports [Amazon Knowledge Bases](https://docs.aws.amazon.com/bedrock/latest/userguide/kb-how-it-works.html) vector stores. You can [connect a knowledge base](retool-vectors.mdx) to use for vector embeddings in AI actions. Once configured, Retool communicates directly with the knowledge base to provide context for AI actions.

## Limitations

* Retool currently supports OpenAI for Vectors.
* The following limits apply when crawling a website:
    * A maximum of three web crawl requests can run concurrently.
    * Web crawls are limited to 25 URLs.
    * Web crawls time out after 15 seconds.
    * A maximum of two web crawls can occur during each five-second interval.

---

## Resources quickstarts

import Quickstarts from '/docs/_partials/_doctypes/_quickstart.mdx';

---

## Resources environment variables

import Resources from "@site/docs/self-hosted/reference/environment-variables/resources.mdx";

---

## Data sources glossary

import SharedGlossary from '../../_partials/_glossary.mdx';

---

## Retool Cloud IP addresses

Retool Cloud organizations must ensure that any configured resources, such as APIs and databases, allow access from Retool's IP addresses. If you make use of inbound firewall rules, include the following IP addresses in its allowlist. Refer to your data source or firewall documentation for specific guidance.

:::info Connect without allowlist

Retool is gathering interest in a feature that would enable querying firewalled resources without allowlisting Retool’s IP address. To learn more or be considered for early access, contact cloud-connect@retool.com.
::: 

By default, Retool uses the AWS `us-west-2` region, based in Oregon, US. To route resources through Europe or other regions, see the [outbound regions documentation](../guides/connections/outbound-retool-regions.mdx).

import RetoolIps from '../../_partials/_retool-ips.mdx'

If you use Retool Self-hosted, refer to the [self-hosted network and storage requirements](../../self-hosted/reference/requirements.mdx) for additional details.

---

## The Retool Storage File object

## Properties

---

## Resources reference

import Reference from '/docs/_partials/_doctypes/_reference.mdx';

:::tip Get started with web apps

If you are unfamiliar with Retool mobile apps and want to get started: 

- Read the [quickstart](./quickstart) to learn about the fundamental concepts.
- Follow a [tutorial](./tutorial/) to build your first mobile app.

:::

---

## Create a resource tutorial

A resource is a set of user-configured properties that determine how Retool interacts with a data source, such as an API or database. You create a resource for each data source you want to use with Retool. You can then select the resource when writing a [query](../../queries/index.mdx) so you can interact with the data.

Retool provides a number of [pre-built integrations](../guides/integrations/index.mdx) that enable you to connect third-party providers with Retool as resources. If there isn't a built-in integration for your desired data source, you can also connect any [REST API](../guides/integrations/api/rest.mdx) or [GraphQL API](../guides/integrations/api/rest.mdx)

In this tutorial, learn how to create a new resource that connects a REST API.

## Generate a mock API with customer data

## Create a new resource

The easiest way to create a new resource is from the Resources page. On this page, complete the following steps to create a new REST API resource:

1. Click **Create new**, and select **Resource** from the dropdown menu.
2. Select the **REST API** resource type from the list of resources.
3. Name the resource and paste the base URL you retrieved in the previous step. 
4. Click **Create resource** to finalize the creation of your resource. A confirmation message appears and prompts you to return to the **Resources** page or create an app.

export function CreateResource() {
  return (
    
      
    
  )
}

## Use the new resource

You can use your newly-created resource in web apps, mobile apps, and workflows. Refer to the following guides for more information about querying resources.

---

## Retool Database tutorial

[Retool Database](https://retool.com/products/database) is a fast, secure solution for saving and editing data to use in Retool apps. It combines a PostgreSQL database with a spreadsheet-like interface to manage your data. On Retool Cloud, the underlying database is managed by Retool. On [Self-hosted deployments](../../self-hosted/guides/retool-database.mdx), you host your own PostgreSQL database.

## 1. Create a table

You can visually interact with your database much like a spreadsheet. Log in to Retool and select the **Database** tab to access the Retool Database editor.

Databases organize data into _tables_ that can have different schema (e.g., separate tables for product and customer data). The sidebar contains a list of tables in Retool Database. When you open a table, it appears as a tab at the top of the editor for quick access.

Retool Database prompts you to create a new table automatically if one doesn't already exist. You can create an empty table, import existing data in CSV format, or generate a table schema with AI.

export function ArcadeCreateTable() {
  return (
    
      
    
  )
}

## 2. Set the primary key for the table

A _primary key_ is a field that uniquely identifies each table row (record). Retool automatically includes an `id` field for the primary key when you create a new table as it's the default option during a CSV import.

:::info

Tables without a primary key are read-only and you cannot make changes to data unless there is a primary key set.

:::

You can set or change a table's primary key at any time. Right-click a table tab and select **Edit Primary Key**, then select a field in the **New Primary Key** dropdown menu.

export function ArcadeEditKey() {
  return (
    
      
    
  )
}

If your data doesn't contain a single field that can uniquely identify rows, you can use a _composite key_. When enabled, you can select multiple fields and use their combined values as a primary key.

## 3. Add a row

Click **Add row** to add a new row of data to the table. To quickly edit existing table data, double-click on a cell and update its value, then click **Save**. You can also interact with certain fields using checkboxes or select options.

export function ArcadeNewRow() {
  return (
    
      
    
  )
}

4. ## Query your data

:::info Rate limit for cloud-hosted organizations

There is a limit of 1,000 queries per minute for Retool Database that applies across the whole organization.

:::

You [write queries](../../queries/quickstart.mdx#resource-queries) to interact with Retool Database data in the same way as any other SQL database resource connected to Retool.

Select the **Retool Database** resource in the query editor, then specify **SQL mode** to write raw SQL queries, or **GUI mode** to construct queries with an interface. As with other SQL databases, you can explore tables in the database.

You can switch between multiple environments from your apps which automatically refreshes any queries you've written. Provided you use the same table names, your app automatically reloads data from the selected environment.

---

## Retool RPC tutorial

:::info

Retool currently supports [JavaScript](https://github.com/tryretool/retoolrpc/blob/main/javascript/README.md) and [Python](https://github.com/tryretool/retoolrpc/blob/main/python/README.md) SDKs.

Reach out to your Retool account manager to access Retool RPC on self-hosted Retool 3.38 Edge versions and earlier.

:::

Retool RPC (Remote Procedure Call) is a fast, secure solution for connecting your own codebase to Retool. You define functions in your backend and then call them from Retool apps using a Retool RPC resource.

## Prerequisites

The prerequisites for Retool RPC depend on whether your organization is cloud-hosted or uses a self-hosted deployment.

You must set up a Redis server and connect it to your self-hosted instance before you can set up Retool RPC. The Redis server functions as the messaging queue for handling requests and responses between the instance and agent. 

Redis server requirements

Your Redis server must:

- Be accessible by hostname and password. 
- Have at least 10GiB memory.
- Be reachable from your Retool instance.

Run `redis-cli` on your Retool instance to verify it can connect to the Redis server. 

Configure eviction policy

Use `redis-cli` and the following command to set the eviction policy to `noeviction`.

```shell
CONFIG SET maxmemory-policy noeviction
```

Retool automatically clears data after a short period of time. 

Configure environment variables

:::note Restart your instance after changing environment variables

You must restart your Retool instance whenever you modify environment variables. 

:::

Edit `docker.env` on your Retool instance and update the following environment variables so it can connect to the Redis server.

| Variable                    | Description                                                           |
| --------------------------- | --------------------------------------------------------------------- |
| `RETOOL_RPC_REDIS_HOST`     | The Redis server hostname or IP address (e.g., `retool.example.com`). |
| `RETOOL_RPC_REDIS_PORT`     | The Redis server port (e.g., `6379`).                                 |
| `RETOOL_RPC_REDIS_PASSWORD` | The password with which to authenticate.                              |
| `RETOOL_RPC_REDIS_DB`       | The database number (e.g., `0`).                                      |
| `RETOOL_RPC_REDIS_TLS`      | Whether TLS should be used (e.g., `false`).                           |

To start using Retool RPC, you need to:

1. Create an RPC resource on Retool so Retool apps can communicate with your server.
2. Generate an access token to authorize your server so it can communicate with Retool.
3. Register a server with Retool's SDK to expose server-side functions to Retool and to handle function calls.

## 1. Set up Retool RPC

You can register a server with the [Retool CLI](#set-up-retool-rpc-with-retool-cli) or [set it up yourself](#set-up-retool-rpc-in-an-existing-project) with an existing project and the Retool SDK. The CLI option is recommended for initial testing.

:::info
[Node.js](https://nodejs.org/en/download) is required to use the CLI.
:::

The CLI is the easiest way to get started with Retool RPC. It automatically generates a resource and RPC server for you. You can use it to quickly test out Retool RPC and then migrate to a more permanent solution.

To setup Retool RPC with the CLI, run the following commands in your terminal.

```bash
# Log into your Retool organization
npx retool-cli login

# Follow the step by step instructions to create a resource and register a server
npx retool-cli rpc
```

If you already have a project, you can register a server with Retool's SDK. This is the recommended way to set up Retool RPC for production.

Create an RPC resource

Sign in to your Retool organization and [create a Retool RPC resource](https://login.retool.com/auth/login?source=docs&redirectOnLogin=resources/new/retoolSdk).

After creating the resource, Retool provides instructions and a code snippet. In the code snippet, `resourceId` is already populated for you.

Generate an access token

Create an access token with the RPC scope by navigating to your [access tokens page](https://login.retool.com/auth/login?source=docs&redirectOnLogin=settings/api). Save this token somewhere safe since you'll need it to register your server.

Register a server

Copy the code snippet from the resource form instructions into a file that can access your codebase. Be sure to populate all fields (e.g., replace the `apiToken` with the token you generated in the previous step) and install relevant dependencies.

:::warning
If you're a cloud customer and your server is running in a private network, you may need to allow outbound traffic to [Retool IP addresses](https://docs.retool.com/data-sources/quickstarts/resources).
:::

Run the file to register your server with Retool. This file serves as the entry point to your codebase and must be running for Retool to communicate with your code.

## 2. Define server-side functions

After registering your server with Retool, you can interact with your codebase. You need to define functions through your registered server, fill in the implementation, and then call the function from Retool apps.

:::warning
Be sure to restart your server to pick up any changes to your registered functions.
:::

Retool RPC allows you to customize functions with any number of arguments. Currently supported argument types are: `string`, `number`, `boolean`, `json`, and `array`. You can also specify whether an argument is required or optional.

```js
// server.js

rpc.register({
  name: "randomFunction",
  arguments: {
    stringInput: {
      type: "string",
      description: "A required string input",
      required: true,
    },
    numberInput: {
      type: "number",
      description: "A required number input",
      required: true,
    },
    booleanInput: { type: "boolean", description: "An optional boolean input" },
    jsonInput: { type: "json", description: "An optional json input" },
    stringArrayInput: {
      type: "string",
      array: true,
      description: "An optional string array input",
    },
    jsonArrayInput: {
      type: "json",
      array: true,
      description: "An optional json array input",
    },
  },
  implementation: async (args, context) => {
    console.log(args.stringInput);
    console.log(context.userEmail);
    // Use parts of your codebase here
  },
});
```

The `args` parameter contains the arguments passed in from Retool, and the `context` parameter contains information about the user that called the function. Fill in the implementation of the function. Since this server connects to your codebase, you can use your existing infrastructure (ORM frameworks, helper functions, logging, testing, CI/CD, etc.) to enhance the developer experience.

## 3. Call server-side functions from Retool

After registering server-side functions, you can call them from Retool apps like [any other resource](https://docs.retool.com/data-sources/quickstarts/resources). Search for the RPC resource you created and select the function you want to call. Retool automatically generates a form for you to fill in the arguments.

Enter the arguments and click **Run** to execute the function. Retool automatically checks the argument passed and displays an error if the types don't match or required fields are missing.

## 4. Configure function permissions

You can configure permissions to control access to exposed functions within your organization. Unlike private APIs that require you to build your own authentication middleware, Retool RPC makes it easy to enforce user or [group-level](https://docs.retool.com/permissions/tutorial) access to functions.

```js
rpc.register({
  name: "randomFunctionWithPermissions",
  arguments: {
    stringInput: { type: "string", description: "A string input" },
  },
  permissions: {
    userEmails: ["hello@world.com"],
    groupNames: ["Hello world group"],
  },
  implementation: async (args, context) => {
    return "Hello world!";
  },
});
```

By default, all functions are accessible to all users. If a `userEmails` or `groupNames` field is specified, only users with the specified email or in the specified group can call the function. If both are provided, users only need to satisfy one condition.

## 5. Configure schema versioning

Retool RPC supports schema versioning to ensure exposed functions are always up-to-date. If you check `Require explicit version` on the resource form, you must increment the version on every server change. This is to ensure non-conflicting changes if multiple people are testing different schemas with the same resource.

```js
const rpc = new RetoolRPC({
  apiToken: 'API_TOKEN',
  host: 'HOST',
  resourceId: 'RESOURCE_ID',
  version: '0.0.1', // Increment this on every server change e.g., 0.0.1 -> 0.0.2 -> 0.0.3
})
```

If left unchecked, Retool uses the last registered server's schema. This is useful for early development where you want to quickly iterate on your functions.

Retool prompts users to refresh their schema if they are running queries against an outdated schema. This can be done by clicking the refresh button on the **Schema** tab or by refreshing the page.

---

## Retool Storage tutorial

Retool Storage is a Retool-hosted file store. In this guide, you build an app with the following functionality:

- Generate a PDF from a Chart component
- Upload the PDF to Retool Storage
- Send emails using Retool Email with the Retool Storage file attached

To test out the app yourself, you can [download the app as JSON](/img/docs/demos/c4c42327-0331-4f8a-ae70-8df7c0dae761.json) and [import](../../apps/guides/app-management/import-export.mdx) it to your organization. See the [Retool Storage overview](../quickstarts/retool-storage.mdx) to learn about other ways to use Retool Storage.

### 1. Add a Chart component

In the **Apps** tab, click **Create new > App** to create an app. Name the app and then click **Create app**.

To help organize your app, add a Tabbed Container and label the steps **Generate PDF**, **Store PDF**, and **Send email**. Add a Chart component to your app and drag it to the canvas. This app uses sample data, but you can also use your own data to populate the chart.

### 2. Generate a PDF

To generate a PDF from components in your app, you can use Retool's build-in [utility methods](../../queries/reference/libraries/utils.mdx). Create a JavaScript query and enter the following code. Add any additional components you want to include to the `componentsToInclude` array.

```javascript
utils.downloadPage("report.pdf", { componentsToInclude: ["chart1"] });
```

Next, add a Button component to the canvas and update its label to **Generate PDF**. In the Button's Inspector, attach an event handler to trigger your `downloadPage` query.

### 3. Upload a PDF to Retool Storage

You can upload files to Retool Storage in apps using the File Button, File Input, and File Dropzone components. In the **Store PDF** tab of your container, add a File Button component.

Next, add a resource query and set the resource to Retool Storage. Set the **Action type** to **Upload file** and the **File source** to your File Button component. Select **Make file public on upload** to allow the file to be accessed outside of Retool. You can change this later from the **Retool Storage** resource page (`.retool.com/files`).

### 4. List uploaded files

Create another Retool Storage query, rename it to `listFiles`, and set the **Action type** to **Get a list of file metadata**. This retrieves a list of all files uploaded to Retool Storage for your organization, so you may want to filter some files from the list. In this example, the following **Transformer** filters the list of files to only PDFs.

```javascript
return data.filter((file) => file.type === "application/pdf");
```

In the **Send email** tab, add a Select component. Set the **Mode** to **Mapped**, and set its **Data source** to this query. Update its label to **File**.

### 5. Retrieve file contents

Create another Retool Storage query and rename it to `getFileContents`. Set the **Action type** to **Get file contents**, then set the file name to `{{ select1.value }}`. File contents retrieved from [Retool Storage queries](../quickstarts/retool-storage.mdx) are stored in `queryName.data.base64Data`.

Attach an event handler to the Select component to trigger `getFileContents`, so the query retrieves the contents of the selected file.

### 4. Send emails with file attachments

Add an Email component to specify the recipient.

Next, add a resource query using **Retool Email** as the resource. Set the **To** field to `{{ email1.value }}`, and fill in the rest of the fields with your desired content. In **Attachments**, toggle the `fx` option, and set the field to:

```javascript
[{data: {{ getFileContents.data.base64Data }}, name: {{ getFileContents.data.name }}, contentType: 'application/pdf'}]
```

Add a Button component and label it **Send**, and attach an event handler to the button to trigger `sendEmail`.

### 5. Test your app

Enter a test email and click **Send** to test your queries. You can also prevent sending emails to invalid addresses by setting the **Disabled** field of the **Send** button to `{{ !textInput || textInput.validationMessage }}`.

---

## Retool-managed Vectors tutorial

Retool-managed Vectors is a hosted vector database that enables you to store unstructured text from documents and web pages for use with AI models through Retool. Retool abstracts away the complexities of preparing text and automatically generates the required data for AI models to make decisions using your data.

You can include related information from [Retool-managed Vectors](../quickstarts/retool-vectors.mdx) to provide more context. This allows you to instruct AI models to use your own data when making decisions, such as responding to a customer with context from support articles.

The following guide explains how to add text to Retool-managed Vectors and use it with the [Generate text](../../queries/guides/ai/text.mdx#generate-text) AI Action.

:::info Vector contents

Each vector you create can contain either document text or URLs, not both.
:::

## 1. Enable Vectors

import Enable from '/docs/_shared/_enable-vectors.mdx';

## 2. Create a Vector

To get started, navigate to the **Resources** tab in your organization and select **Retool Vectors**. You can create two types of Vectors:

- [Document Vector](../guides/vectors/text.mdx): Store plain text that you enter manually or extract from uploaded PDF documents.
- [URL Vector](../guides/vectors/urls.mdx): Store text fetched from publicly accessible web pages.

The following instructions cover both Vector types. To continue with this guide, create a **URL Vector**.

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

To create a Document Vector:

1. Navigate to the **Resources** settings and click **Retool Vectors**.
2. Click **Add Vector**.
3. Specify a name and select **Document**.
4. Click **Create**.

To create a URL Vector:

1. Navigate to the **Resources** settings and click **Retool Vectors**.
2. Click **Add Vector**.
3. Specify a name and select **Site URLs**.
4. Click **Create**.

## 3. Add embeddings

Click **Add document** and select whether to upload a PDF file or add plain text manually. Retool extracts text from PDF documents automatically.

:::info URLs must be publicly accessible
Retool can only crawl URLs that are publicly accessible and linked from other pages that match the base URLs. Pages that can only be accessed directly or require authentication cannot be added.
:::

Click **Add URLs** to add web pages to the Vector then add a base URL to **Links to crawl**. You can specify multiple URLs by clicking **Add link**.

You only need to specify a base URL, such as `https://docs.retool.com`—Retool crawls the URL and fetches text for any pages at this location. You can exclude web pages by providing a base URL in **Link prefix to exclude**—any URLs that match are not crawled.

For the purposes of this guide, set the following:

- **Links to crawl**: `https://docs.retool.com`
- **Link prefix to exclude**: `https://docs.retool.com/changelog`

This instructs Retool-managed Vectors to crawl Retool Docs but exclude changelog content.

## 4. Use Retool-managed Vectors in AI Actions

You can include context from Retool-managed Vectors in apps and workflows using the [Generate text](../../queries/guides/ai/text.mdx#generate-text) and [Generate chat response](../../queries/guides/ai/chat.mdx) AI Actions. This step assumes you have created a URL Vector using `https://docs.retool.com`.

1. Navigate to the **Query Library** tab and click **+ New**.
2. Set **Resource** to **Retool AI**.
3. Select the **Generate text** action.
4. Enter `What is a resource?` as the **Input**.
5. Enable **Use Retool Vectors to provide more context to your query** and select the URL Vector you created.
6. Click **▶︎** to run the query.

Retool automatically includes relevant context to the AI model from the specified Vector.

## Wrap up

You have now created a new vector store using Retool-managed Vectors, added text content, and performed an AI Action with Vector context.

---

## Resources tutorials

import Tutorial from '/docs/_partials/_doctypes/_tutorial.mdx';

:::tip Learn more about data sources and resources

Read the [resources](./tutorials.mdx) quickstart guide to learn more about connecting data sources with your Retool organization.

:::

---

## Autofill forms

You can pass default URL query string and hash parameters to forms, similar to how you pass [parameters to apps](../../apps/guides/app-management/customize-app-urls.mdx#launch-an-app-with-url-query-parameters). Use the [urlparams](../reference/objects/url.mdx) object to populate default values.

For example, if you set a **Quantity** form field's default value to `{{ urlparams.quantity }}`, passing the query string `?quantity=5` in the URL pre-populates the field with `5`.

---

## Manage fields

### Use AI to generate fields

If you use Retool Database, you can use AI to generate a form for your use case. From a blank form, select **Click here to start with AI**, and provide your use case. Fields are then automatically generated, which you can further customize. A table named after your form is created when you publish the form, and contains columns for each input field in your form.

### Add presentation fields

You can add Text, Image, and Divider fields from the **+** button. These can help you organize your form and provide additional context to users. Presentation fields do not affect data written to your database.

### Add custom fields

You can add custom fields to forms connected to Retool Database. When you publish your form, a column is inserted into your database with the settings from the custom field. Custom fields default to use the name of the input component, so you may want to change this name before you publish.

## Hide fields

It can be useful to hide database fields, especially those which have default values set by your database, from your form.

When you hide a field from the sidebar, the field is not passed to the database insert request. You may want to use this to hide `id`, `created_at`, or other auto-generated fields, so your database can handle these inserts.

To hide a field from users, but still include it in the database insert request, use the **Hidden** field in the field settings. You can use this conditionally hide fields based on any criteria. For example, to hide a `custom_name` field when the `status` field is not `'new'`, you could set **Hidden** to `{{ status.value !== 'new' }}`. When the `status` field is not `new`, the `custom_name` field is set to `null`.

## Delete fields

You can delete fields from your form by clicking the delete icon. Non-presentation fields must be hidden before you can delete them.

---

## Configure themes

In the **Settings** tab, you can customize the color, typography, and border radius on your form to match your organization's branding.

---

## Forms how-to guides

import Howto from '/docs/_partials/_doctypes/_howto.mdx';

---

## Retool Forms documentation

Retool Forms enables you to build standalone, customizable forms. Forms are publicly accessible with unique URLs and responses are written to a connected SQL database (Retool Database, MySQL, PostgreSQL, etc.).

:::warning

This section covers only Retool Forms, which are standalone and cannot be embedded in an app. For in-app forms, refer to the [form component guides](../apps/guides/forms-inputs/forms/index.mdx).

:::

---

## The Current User object

:::tip Not available in public forms

`current_user`  is `null` for publicly accessible forms.

:::

## Properties

---

## The Retool Context object

## Properties

---

## The Theme object

## Properties

## Methods

---

## The Url object

## Properties

---

## The Viewport object

## Properties

---

## Retool Forms reference

import Reference from '/docs/_partials/_doctypes/_reference.mdx';

:::tip Get started with forms

Follow the [tutorial](./tutorial/) to build your first form.

:::

---

## Retool Forms tutorial

Use Retool Forms to build standalone, customizable forms whose responses are written to a connected SQL database (MySQL, PostgreSQL, etc.). Forms are publicly accessible from a unique URL.

:::warning

This tutorial covers only Retool Forms, which are standalone and cannot be embedded in an app. To build forms within apps, use a [Form component](../apps/reference/components/containers-forms/index.mdx).

:::

## Requirements

Retool Forms is available on Retool Cloud and self-hosted Retool versions 3.36 and later. 

All users can create and fill out forms. You can build as many forms as you'd like and capture as many responses as your database supports.

To connect forms to an existing database, you must first connect the database as a [resource](../data-sources/quickstarts/resources.mdx) in Retool. To use [Retool Database](../data-sources/tutorials/retool-database.mdx) to store responses on self-hosted Retool, you must first [configure Retool Database](../self-hosted/guides/retool-database.mdx). On cloud-hosted Retool, no additional configuration is required to use Retool Database.

## 1. Create a form

Go to the **Forms** tab and select **Create form**. Name your form and select **Create form**.

## 2. Connect your data

In the **Database** tab, select **Generate from database** to write responses to an existing database, or **Start from scratch** to store responses in Retool Database. From the **Database** tab, you can change the underlying database at any time.

If you create your form from scratch, a new table is automatically generated when you [publish your form](#6-preview-and-publish-your-form). Generated tables are named after your form.

If your database schema changes as you build your form, you can select **...** > **Sync from database** to view and sync schema changes to your form.

## 3. Build your form

You can use the sidebar to reorder your form, and use the drag-and-drop form editor to customize individual fields.

## 4. Connect a workflow

:::info

Triggering Retool workflows from form submissions is currently rolling out for self-hosted Retool.

:::

From the **Workflows** tab, you can trigger a [Retool workflow](../workflows/index.mdx) on successful form submissions. Ensure your workflow has [webhook triggers](../workflows/guides/triggers/webhooks.mdx) enabled. All form fields are passed as workflow parameters.

## 5. Set themes

In the **Settings** tab, you can customize the color, typography, and border radius on your form to match your organization's branding.

## 6. Preview and publish your form

To preview your form before you publish it, select the preview icon in the upper right. To generate a shareable URL for your form, select **Publish** in the upper right. Once published, the form is accessible to any user given the unique URL.

## 7. Use form responses

After you publish and distribute your form, select the **Responses** tab to view form responses. Responses are read-only, but you can click **Clone as Retool app** to copy the data to an app, or **Download** to download the data as a CSV.

---

## Glossary of terms

Definitions of terms you may come across when building software on Retool.

## A

## B

## C

## D

## E

## F

## G

## H

## I

## J

## K

## L

## M

## N

## O

## P

## Q

## R

## S

## T

## U

## V

## W

## X

## Y

## Z

---

## Index

import DocCardList from "@theme/DocCardList";
import VersionCard from "@theme/VersionCard";
import VersionCardList from "@theme/VersionCardList";
import RecentChangelog from "@theme/RecentChangelog";
import ReleasesForLanding from "@site/src/components/ReleasesForLanding";

  Retool Docs
  Build internal software better with AI
  Create apps, agents, and workflows with any LLM, data source, or API. Deploy AI across your business.

  Generate apps with Assist
  Automate work with Agents

## What's new

Updates, changes, and improvements at Retool.

## Latest releases

The latest versions of supported self-hosted Retool releases.

## Explore the platform

Seamlessly connect databases, build with elegant components, and customize with code. Accelerate mundane tasks, freeing up time for the work that matters most.

---

## Mobile app best practices

import Shared from '/docs/_shared/_app-performance-best-practices.mdx';

## Enable cache on page load

If your users will be using your app in an area with low connectivity or or slow connection, consider turning on **Enable Cache page load** in **Settings** > **Mobile Advanced Settings**. This setting allows you to cache the app state on mobile devices to improve performance.

:::note

Enabling this setting may mean that users do not get the most recent version of your app. Users will see a top banner indicating that the app has been updated.

:::

---

## Mobile app biometric verification

Biometric verification enhances the security of your Retool mobile apps by adding an extra layer of identity verification using biometric data. After users log in, they are prompted to verify their identity using biometrics each time they bring the app to the foreground. Biometric verification does not replace your existing login mechanisms.

## Enable biometric verification

Go to **Settings** > **Mobile Advanced Settings** and toggle **Retool Mobile: Enable user verification via biometrics** on.

To allow users to use screen lock credentials (e.g., passcode or pattern) as a fallback to biometrics, select **Retool Mobile: Enable user verification via screen lock credentials**. The device's operating system determines when this fallback is used, and may prompt for the fallback after consecutive failures or if biometrics are unavailable.

You can also enable the **Privacy Screen**, which obscures the app preview when viewed from the mobile device's app switcher.

## Verification behavior

The first time users log in to Retool Mobile apps after enabling biometric verification, they are prompted to set up biometric authentication—e.g., enrolling fingerprints or enabling face recognition. For future logins, when users bring the app to the foreground after logging in, they are prompted to verify their identity using biometrics.

If biometric validation fails after three attempts, users are logged out of the app.

## Security

Retool does not store any biometric data. Biometric validation relies on the security features of the underlying operating system to securely provide and handle biometric data.

---

## Command Palette

import Shared from '/docs/_shared/_command-palette.mdx';

---

## Debug Tools

import Shared from '/docs/_shared/_debug-tools.mdx';

---

## Programming paradigms at Retool

import Shared from '/docs/_shared/_programming-paradigms.mdx';

---

## Push notifications

Retool Cloud and Self-hosted organizations can send push notifications to Retool Mobile users. Push notifications are a built-in feature made available using the Retool Mobile app for iOS and Android.

Retool uses [Amazon SNS](https://aws.amazon.com/sns/) to provide a centralized service for push notifications in Retool Mobile. This makes it possible for Retool organizations to send push notifications without any additional configuration or dependencies.

## The Mobile Push Notification resource

Retool makes push notifications available as a [resource](../../data-sources/quickstarts/resources.mdx). This enables you to write queries that send push notifications using any Retool app or workflow. For instance, you could configure a [webhook-triggered workflow](../../workflows/guides/triggers/webhooks.mdx) to send a push notification if a PagerDuty incident is created or if the daily order volume in [Stripe](../../data-sources/guides/integrations/finance/stripe.mdx) exceeds a particular threshold.

Users must first explicitly subscribe to push notifications—you cannot automatically enroll a user.

## Topics

Push notifications use topics to represent the scope for recipients. Topics are similar in function to mailing lists—users subscribe to them based on what information they want to be notified about. Users [subscribe to push notifications](../guides/app-management/push-notifications.mdx#subscribe-users-to-push-notifications) using a subscription query in which you specify the topics to use. To send a notification, you use a query that references the relevant topic rather than managing a separate list of users.

Retool initially includes the `ALL_USERS` topic, which represents all Retool Mobile users in your organization. You can add or remove topics, and set your own, such as `SALES_TEAM` or `ENG_ONCALL`. You specify the topics to use in both the [subscribe](#subscribe) and [send](#send) queries. Once subscribed, a user can receive notifications to the topics in which they're included.

For example, the overall process to send notifications to sales managers could be:

1. You create a query to subscribe users to a set of topics, such as `SALES_TEAM` and `SALES_MANAGERS`.
2. A sales manager opens the mobile app containing the subscription query and then subscribes to those topics.
3. To send a notification, you specify the topics to use. To notify sales managers, you would use the `SALES_MANAGERS` topic.

You can also subscribe users to direct notifications on an individual basis using the `USER` topic (e.g., `USER:{{current_user.email}}`).

## Action type

The query's **Action type** determines what action to take in relation to push notifications.

### Subscribe

The **Subscribe** action type subscribes users to push notifications. You add subscribe queries to mobile apps that run automatically when launched by a user. This adds the user to the topics defined in the query. Only Retool Mobile apps can contain subscribe queries.

To subscribe a user to direct push notifications intended only for them, use `USER:{{current_user.email}}`.

### Send

The **Send** action type sends push notifications. These queries use the specified topics to represent the recipients. For instance, `SALES_TEAM` sends a push notification to all users who subscribed to the `SALES_TEAM` topic. You can send notifications directly to individual users if they subscribed with the `USER` topic with their email address.

## Deep links

Push notifications can include _deep links_ to other Retool Mobile apps and the screens they contain. This enables users to tap on a notification and be taken directly to a relevant app.

You can also include data as key-value pairs when sending a push notification which can be referenced in apps using `initialDeepLink.params`. This enables you to further customize the deep link experience. For example, you could include a user ID using `id=123` and reference it in a query to look up users with `{{initialDeepLink.params.id}}`.

`initialDeepLink.params` also includes the following properties:

| Property         | Value    | Description                                        |
| ---------------- | -------- | -------------------------------------------------- |
| `appName`        | `string` | The app to launch when the notification is tapped. |
| `releaseVersion` | `string` | The release version of the mobile app.             |
| `screen`         | `string` | The specific screen in the app to open, if set.    |

For example, a workflow could automatically send a notification whenever a new sales lead is received. The notification deep links to a sales CRM app and includes the `id` of the new lead. A recipient can tap on the notification and navigate directly to the app. By including the `id`, the app can automatically display the lead's information.

---

## The Retool Mobile app

Retool Mobile eliminates the need for compiling apps, complex distribution, and store listings with lengthy reviews. Instead of separate apps, you use a single app—Retool Mobile for iOS and Android—to browse and run apps natively. Retool Mobile apps also function as progressive web apps.

This approach simplifies deployment and makes all Retool Mobile apps instantly available. You can share links to apps so users can launch them on their device, or open them in a browser.

## How the Retool Mobile app works

The Retool Mobile app for iOS and Android uses [React Native](http://react-native.org/) to run mobile apps natively. Users can log in to their Retool organization, browse or search for mobile apps, and launch them on their mobile device.

## Device support

Retool Mobile apps are currently supported on the following OS versions. You may be able to download the app on older devices, but you will not receive updates.

| Operating system | Minimum version                  |
| ---------------- | -------------------------------- |
| iOS              | 15.5                             |
| Android          | API 23 (Android 6.0 Marshmallow) |

Some Retool functionality may be unavailable due to restrictions or limitations when run natively.

## App links

You can share links to mobile apps with users that launch automatically in the Retool Mobile app. If a user doesn't have the app installed, they are routed to the Apple App Store or Google Play. Users can enable the **Start on most recent app** option to launch the last app in use whenever opening the Retool Mobile app.

:::tip Mobile apps on the web

You can also launch Retool Mobile apps as progressive web apps (PWA). This makes it possible to use Retool Mobile apps on a wide range of devices that are unable to use the Retool Mobile app for iOS and Android (e.g., Amazon Fire tablets).
:::

---

## White-label mobile apps

Eligible Retool organizations can request _White-label Apps_: a custom-branded version of the Retool Mobile app. Retool can manage the distribution of White-label apps to users in your organization through the iOS App Store and Google Play, or you can self-manage this process.

To create a White-label App, you provide Retool with the necessary provisioning resources. Retool then generates a custom version of the mobile app for you and uploads it to the iOS App Store or Google Play.

## Eligibility

The requirements for white-label apps depend on whether you use Retool-managed or self-managed distribution, and if you will distribute apps to iOS or Android devices.

If you're an existing Enterprise customer, reach out to your deployed engineer to get started. If you're interested in upgrading to an Enterprise plan, [book a demo](https://retool.com/demo/?meeting_page_source=docs).

## Distribution options

Depending on your use case, Retool can manage the distribution of White-label apps (Retool-managed) or you can manage them directly (self-managed). In most cases, use Retool-managed distribution unless you must handle app distribution directly.

Retool manages the end-to-end process for publishing and distributing White-label apps. This includes publishing White-label apps on your behalf to the iOS App Store or Google Play. These apps are visible only to users in your organization. Your organization uses an MDM or EMM solution to manage devices on which White-label apps are installed.

Retool also manages updates and store reviews, and you have control over the release schedule.

Your organization is responsible for publishing and distributing White-label apps. Instead of publishing White-label apps on your behalf, Retool uploads app binaries to your Apple or Google Developer account. You then submit the app for review.

Self-managed distribution requires you to set up Apple or Google developer accounts, manage updates, and handle store reviews.

## Requirements

You can use this distribution option if your organization:

- Manages mobile devices using an enterprise mobility management (EMM) or MDM (mobile device management) solution.
- Only distributes apps to internal employees.

You must meet the following requirements for Retool-managed distribution of your White-label apps.

- **iOS**
  - Enrolled in [Apple Business Manager](https://business.apple.com/).
  - Use a third-party MDM solution.
- **Android**
  - Enrolled in [Managed Play Store](https://play.google.com/work).
  - Use a third-party EMM solution.

You can use this distribution option if your organization doesn't meet the requirements for Retool-managed distribution or has a use case that requires publishing White-label apps directly to the app stores.

You must meet the following requirements for self-managed distribution of White-label apps.

- **iOS**

  - Enrolled in the [Apple Developer Program](https://developer.apple.com/programs/).
  - Provide login credentials to Retool for a Developer Access level role.
  - Provide a service key to Retool for interacting with the App Store APIs.

- **Android**
  - Enrolled in the [Google Android Developer Program](https://developer.android.com/distribute/console).
  - Provide login credentials to Retool for a Developer Access level role.
  - Provide a service key to Retool for interacting with the Play Store APIs.
  -

---

## Mobile apps concept guides

import Concept from '/docs/_partials/_doctypes/_concept.mdx';

:::tip Get started with mobile apps

If you are unfamiliar with Retool mobile apps and want to get started: 

- Read the [quickstart](./quickstart) to learn about the fundamental concepts.
- Follow a [tutorial](./tutorial/) to build your first mobile app.

:::

---

## Add documentation to mobile apps

You can add documentation to an app to provide guidance and context for other users. 

## Write a README

README files are an important part of any programming project. Their purpose is to introduce the codebase to new users and help share important project details with collaborators. All mobile apps include a built-in README file for you to edit. Find the README by clicking the app's title in the toolbar.

Inside the **Edit app details** modal, there's an **Editor README** section. This text area accepts Markdown.

Content in the README is only visible to users with **Edit** or **Own** permissions on the app. When other editors open the **Edit app details** modal, they’ll see the rendered Markdown, along with the last editor to update the text, and a timestamp. Editors can click **Edit** to update the README themselves.

import Shared from '/docs/_shared/_app-documentation.mdx';

---

## Import and export apps

import Shared from '/docs/_shared/_import-export-apps.mdx';

---

## App management



---

## Send push notifications

Retool Cloud and Self-hosted organizations can send _push notifications_ to Retool Mobile users. Using the built-in **Mobile Push Notifications** resource, you write queries that send notifications to specified users from any Retool app or workflow.

Configuring push notifications is a two-part process:

- Add a query to mobile apps that subscribe users to push notifications and enables them on their device.
- Write queries in Retool apps and workflows to send push notifications to subscribed users.

Self-hosted deployments must also complete additional steps before using push notifications.

## Subscribe users to push notifications

Each user must first _subscribe_ to receive push notifications. This is done by adding a query to mobile apps that runs automatically whenever users launch the app. Open a mobile app in the app IDE and add a **Resource query**, select the **Mobile Push Notifications** resource, then select the **Subscribe** action.

You specify the topic to which the user subscribes. You can configure multiple topics, such as `ALL_USERS` or `SALES_TEAM`. You can subscribe the user to receive only direct notifications using `USER:{{current_user.email}}`.

When the query runs, it subscribes the user to push notifications. The mobile app also prompts the user to allow notifications on their device if they have not yet done so. Once subscribed, the user can receive notifications sent to relevant topics.

## Send push notifications

The **Mobile Push Notifications** resource is available anywhere you can write queries in Retool. This enables you to send notifications from any app or workflow. You can send notifications to specific users by including their email addresses or to all users. You specify the recipients and message, and then configure the query to run.

Queries for the Mobile Push Notifications resource only send when used in web apps and workflows. If you need to send push notifications from a mobile app, specify the **Send** action.

Send queries include a **Topics** field in which you add recipients. Add any topics previously used to subscribe users, such as `SALES_TEAM`. If the user subscribed to the `USER` topic that included their email address, such as `USER:{{current_user.email}}`, use `USER:jenny@example.com`.

Users can only receive notifications sent for the topics to which they subscribed.

## Configure deep links

Push notifications can include [deep links](../../concepts/push-notifications.mdx#deep-links) that, when tapped, enable users to navigate to a specific app. To include a deep link, toggle the **Configure Deep Link** setting on.

There are three settings to configure:

- **App**: The app to launch when the notification is tapped.
- **Screen**: The specific screen in the app to open. If you do not select a screen, the app's default screen is used.
- **Params**: Key-value pairs to include as available parameters for the target app.

### Deep link parameters

The `initialDeeplink.params` object contains a list of key-value pairs for each set of deep link parameters that may have been included. For example, `id=123` is available using `initialDeeplink.params.id`. You can reference deep link parameters anywhere in your mobile app and use them to control behavior, such as retrieving a specific user or prefilling an input field.

## Configure push notifications for Self-hosted deployments

If you have a Self-hosted deployment, you must obtain a _push notification API token_ from Retool and then configure additional environment variables.

First, contact our support team to request a token. Once you receive it, configure the following environment variables:

```
MOBILE_PUSH_NOTIFIER_HOST=https://spb8yl7d3j.execute-api.us-west-2.amazonaws.com
MOBILE_PUSH_NOTIFIER_API_TOKEN=(Your push notification API token)
```

---

## Preview and share mobile apps with users

import Share from "../../../_shared/_share.mdx";

---

## Custom and embedded content



---

## Display tables using Markdown

Retool Mobile supports advanced formatting by using Markdown within a Text component. While Retool Mobile doesn't have a table component, you can display tabular data using Markdown tables.

## Basic table formatting

Tables can be displayed with Markdown using pipe and dash symbols, for example:

```
| Month    | Revenue |
| -------- | ------- |
| January  | $1000   |
| February | $1200   |
| March    | $1800   |
```

The above Markdown renders as a table.

| Month    | Revenue |
| -------- | ------- |
| January  | $1000   |
| February | $1200   |
| March    | $1800   |

## Format repeatable data

Data returned from a resource query can also be rendered in a table by dynamically building the Markdown. For example, you might have a resource query named `query1` which returns the following array.

```json
[
  {
    "month": "January",
    "revenue": 1000
  },
  {
    "month": "February",
    "revenue": 1200
  },
  {
    "month": "March",
    "revenue": 1800
  }
]
```

In the Text component's **Value** field, the following would render the same table.

```
| Month    | Revenue |
| -------- | ------- |
{{query1.data.map(item => `| ${item.month} | $${item.revenue} |`).join('\n')}}
```

This code uses the [`map()` method](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map) of the array instance to iterate over each object in the array and format it into a string in the correct Markdown format. It then joins the new array of strings into a single string using `.join('\n')`. The same approach could be used in a transformer.

---

## Customize the theme of mobile apps

:::warning

Retool Mobile app themes function separately from Retool web app [themes](../../../apps/guides/presentation-styling/themes.mdx).

:::

You can create and manage custom styling for your mobile apps with _themes_. To customize your app's theme, click the `•••` **App actions** menu and select **App theme**.

- **Primary**: The default accent color used by most mobile components.
- **Header**: The background color for the title area of screens.
- **Buttons**: The corner style for buttons.

You can create custom themes and apply them to your mobile apps.

---

## Deploy mobile apps

The Retool Mobile app is available on the [App Store](https://apps.apple.com/us/app/retool-mobile/id1586183808) or [Google Play](https://play.google.com/store/apps/details?id=com.retool.retool). Once installed, you can log in to Retool and run mobile apps natively.

## Sign in to your Retool organization

:::tip

You can share app links to users that automatically log them in using [passwordless login](#passwordless-login).

:::

Use **Host settings** to select whether your Retool organization is on Retool Cloud or [Self-hosted](../../../self-hosted/index.mdx) (e.g., an on-premise deployment). Both [Self-hosted Retool](../../../self-hosted/index.mdx) and [Retool Cloud](https://retool.com/pricing/) organizations use the Retool Mobile app for iOS and Android to launch mobile apps natively.

If your mobile devices have limited memory, you can enable the **WebView Login** option in your organization's **Beta** settings to use an embedded WebView component for web-based logins. This reduces the Retool Mobile app's total memory usage and help prevent it from being unloaded when in the background.

## Browse and launch Retool Mobile apps

Retool Mobile for iOS and Android provides access to your Retool organization's mobile apps. When launched, it runs the most recently opened mobile app.

You can browse through the list of apps or search to find a particular mobile app. You can return to this list by pressing the **Home** button in the title bar area of the mobile app. You can also access frequently used apps in the side drawer.

## Switch environments

If your mobile app queries resources configured with [multiple environments](../../../org-users/guides/configuration/environments.mdx) (e.g., Production and Staging), you can switch between them in the sidebar of the Retool Mobile app. Environment switching is only available to users with **Edit** access to apps.

## Retool Mobile on the web

:::note

[Self-hosted Retool](../../../self-hosted/index.mdx) organizations directly control and manage PWA versions of Retool Mobile apps.

:::

You can launch Retool Mobile apps as progressive web apps (PWA). This enables the use of Retool Mobile apps on a wide range of devices that cannot run them natively using Retool Mobile for iOS and Android (e.g., Amazon Fire tablets).

Open an app link in a browser to launch a Retool Mobile app on the web. On a desktop device, the Retool Mobile app is displayed in a device frame and includes a QR code that links to the app. Scan the QR code from your mobile device to launch the app from the device.

## Share apps and invite users

:::tip Generate auto-join links for mobile-only users

You can generate an **auto-join link** that allows users to sign up from the Retool Mobile app using SSO. Users who sign up using this method are added to your organization as mobile-only users. You must [configure auto-join domains](../../../org-users/tutorials/manage.mdx#configure-auto-join-domains) to enable this option.

:::

You can [invite new users](../../../org-users/tutorials/manage.mdx#add-users) or send a link to existing users via email. Click the **Share** button in the upper-right of the app IDE to display sharing options. You can enter individual email addresses or click **Add many at once** to use a comma-separated list. You can also copy the link to an app to use elsewhere.

All Retool apps have a unique URL. Direct links open in the Retool Mobile iOS or Android app automatically. If the app is not currently installed, the user is routed to their device-specific app store listing for download.

Invited users can create an account in Retool Mobile for iOS and Android before the mobile app launches.

## Passwordless login

:::info Cloud only

Passwordless login for Retool Mobile is only available on cloud-hosted Retool.

:::

Retool Mobile includes a _passwordless login flow_ for existing users. Any existing user who opens a mobile app link is automatically logged into the Retool Mobile app. This enables you to distribute apps to your workforce without existing users needing to log in first, resulting in fewer steps.

You can also perform passwordless login if you first need to install the Retool Mobile iOS or Android app. Retool copies the app link to the clipboard when redirecting you to the device-specific app store listing. Once installed, the Retool Mobile app uses the clipboard link to complete passwordless login. This requires access to the clipboard contents. When prompted, click **Allow**.

The passwordless login flow for users who just installed Retool Mobile can automatically sign in using [passwordless login](#passwordless-login).

### Restrict user access

Your users can browse and launch any of your mobile apps by default. If your Retool organization is on a [Business or an Enterprise plan](https://retool.com/pricing/), you can [configure permission controls](../../../permissions/guides.mdx) and restrict mobile app access only to certain users or groups.

---

## Deployment



---

## Version and release apps

import Shared from '/docs/_shared/_releases-history.mdx';

---

## Provision and distribute White-label Retool Mobile apps

To create a White-label app, you provide Retool with the necessary provisioning resources. Retool then generates a custom version of the mobile app for you and uploads it to the iOS App Store or Google Play.

:::info Requirements

The requirements depend on whether Retool or your organization manages app distribution. If you're an existing Enterprise customer, reach out to your deployed engineer to get started. If you're interested in upgrading to an Enterprise plan, [book a demo](https://retool.com/demo/?meeting_page_source=docs).

Learn more in the [White-label app](../../../concepts/white-label.mdx) explanation guide.

:::

## 1. Provision a White-label app from Retool

You can request a White-label app by completing the [provisioning form](https://retoolin.tryretool.com/embedded/public/ac1ba0ab-72d4-48be-87b4-86bd305be5d2). You must provide the following provisioning resources when submitting the request.

| Resource                                     | Description                                                                                                                                                                                                                                                       | Required for Retool-managed apps | Required for self-managed apps |
| :------------------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :------------------------------: | :----------------------------: |
| **Icon**                                     | The app icon.Must be a PNG image with a minimum resolution of 1024x1024. Width-to-height ratio must be 1:1.                                                                                                                                           |      |      |
| **Full-size logo**                           | The image displayed in various places, such as the iOS launch screen.Must be a PNG image with a minimum resolution of 320x80. Width-to-height ratio must be 4:1.                                                                                      |        |      |
| **Compact logo**                             | The image displayed in various places where the full-size logo cannot be used, such as the Android splash screen. This can be the same as the app icon.Must be a PNG image with a minimum resolution of 1024x1024. Width-to-height ratio must be 1:1. |        |      |
| **Splash screen color**                      | The splash screen background color. Must be a hex color value.                                                                                                                                                                                        |        |      |
| **Login logo**                               | The image displayed on login the screen.Must be a PNG image with a minimum resolution of 320x80. Width-to-height ratio must be 4:1.                                                                                                                   |        |      |
| **App display name**                         | The name of the app (e.g., `My Custom App`).                                                                                                                                                                                                                      |        |      |
| **App’s Store name**                         | The name to display in the store listing for the iOS App Store or Google Play. This name must be unique across all apps on the store.If your app name is not unique, combine it with your company name (e.g., `My Custom App by ACME`).               |        |      |
| **Instance URL**                             | The URL of your company’s Retool instance (e.g., `example.retool.com`).                                                                                                                                                                                           |        |      |
| **Primary app’s UUID (Single-app only)**     | The UUID to use for the White-label app (optional).                                                                                                                                                                                                               |        |      |
| **Apple Organization ID**                    | The Apple Organization ID to publish apps to the iOS App Store on your behalf.                                                                                                                                                                                    |        |     |
| **Managed Play Organization Id**             | The Google Organization ID to publish apps to Google Play on your behalf.                                                                                                                                                                                         |        |     |
| **Apple Developer Account Credentials**      | Account credentials with Developer access for your Apple Developer Account.                                                                                                                                                                                       |       |      |
| **Play Store Developer Account Credentials** | Account credentials with Developer access for your Google Developer Account.                                                                                                                                                                                      |       |      |
| **Apple Service Key**                        | The Service Key for App Store Connect.                                                                                                                                                                                                                            |       |      |
| **Google Service Key**                       | The Service Key for Google Play Console.                                                                                                                                                                                                                          |       |      |

Retool will notify you when your White-label app is ready. It is not automatically published.

## 2. Distribute a White-label app

Retool publishes White-label apps on your behalf to the iOS App Store or Google Play. These apps are visible only to users in your organization. Retool also manages updates and store reviews, and you have control over the release schedule.

To distribute Retool-managed White-label apps to devices, complete the following steps for either iOS or Android.

iOS

1. Link your MDM solution to Apple Business Manager.
2. Add your devices from Apple Configurator to Apple Business Manager. Refer to [Apple's documentation](https://support.apple.com/guide/apple-business-manager/add-devices-from-apple-configurator-axm200a54d59/web) for instructions.
3. Assign devices to your MDM server. You can either assign devices manually or configure automatic assignment.
4. Enroll your devices in your MDM solution. Management policies are applied to enrolled devices and will add them to Apple Business Manager.
5. Refer to your MDM solution's documentation to install White-label apps onto managed devices.

Android

Enroll your devices into your EMM solution. Once enrolled, users can install the White-label app onto their managed devices.

You are responsible for publishing self-managed White-label apps to the iOS App Store or Google Play. Once Retool notifies you that the app binaries have been uploaded, you can submit the app for review. After publishing, your users can install the app.

---

## Configure external authentication for White-label apps

Retool can authenticate users–internal or external to your company–into embedded apps. Organizations with [White-label apps](./index.mdx) can use custom authentication with Retool API to perform external authentication with White-label apps as well.

When your mobile user attempts to sign in, the app navigates to your custom login page. Once authenticated, your backend authorizes the user with Retool and redirects them back to the White-label app for which they now have access. The process is the same whether you're using web apps or a White-label mobile app.

Follow the [embedded apps](../../../../apps/guides/app-management/embed-apps.mdx) guide to get started.

---

## White-labeled Retool Mobile apps

[White-label apps](../../../concepts/white-label.mdx) are custom-branded versions of the Retool Mobile app of which eligible organizations can request. Retool can manage the distribution of White-label apps to users in your organization through the iOS App Store and Google Play, or you can self-manage this process.

---

## Manage White-label app updates

Your White-label app functions in the same way as the Retool Mobile app. You can continue to make incremental changes to your mobile app (e.g., editing existing apps and queries) without needing to publish an update.

You must publish a new version of your White-label app to the iOS App Store or Google Play if you need to:

- Make use of new functionality in Retool Mobile.
- Change your app's name, image assets, or icon.

---

## Mobile app error reporting and observability

import Observability from "../../_shared/_observability.mdx";
import Errors from "../../_partials/_app-errors.mdx";
import Filtering from "../../_shared/_filtering-routing.mdx";

---

## Manage date and time values in web apps

import Shared from '/docs/_shared/_time-zones.mdx';

---

## Upload files and images in mobile apps

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

Retool provides a number of components that enable users to upload files and images in mobile apps:

- File Input
- [Image Input](../../reference/components/media/image-input)

These components have several configuration options that allow you to control what users can upload.

:::caution File size limit

The maximum supported file size for file uploads is 40MB.

:::

## Add file upload functionality

Add a File Input component to the canvas. This enables users to upload files from the mobile app.

### Accepted file types

Use the **File types** option to specify the MIME types to allow for upload. Retool provides three categories of file types from which you can select.

The **Documents** option contains a list of MIME types for common file types, such as PDFs and Microsoft Word documents.

```json Document MIME types
[
  "text/*",
  "application/*",
  "application/pdf",
  "application/msword",
  "application/vnd.ms-excel",
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
  "application/json",
  "application/rtf",
  "application/xml"
]
```

The **Images** option allows the upload of all images that use the `['image/*']` MIME type.

The **Any** option uses `['*/*']` as the specified MIME type, allowing for the upload of any file.

import FxSvg from '/img/icons/fx.svg';

:::tip Specify your own MIME types

You can provide your own list of MIME types to accept. Click the  button and specify an array of MIME type values.

:::

## Add image upload functionality

Add an Image Input component to the canvas. This button enables users to select an image to upload.

### Input method

You can configure the Image Input component's **Input method** option to specify whether users can upload images from their device's photo library, capture and upload images with the camera, or allow the user to choose.

### Resolution

To reduce file size and improve performance, Retool can scale images during upload. Select **Low**, **Medium**, or **High** to specify the resolution size to use. You can also prevent resolution changes with **Original**.

### Compress photos

Retool can also compress images for file size and performance. Enabling this option results in images that are 50% smaller in size but with minimal loss of quality.

### Single or multiple selection

You can specify whether users can upload a single image or multiple images.

If you allow multiple images, you can also specify a minimum or maximum number of images to allow.

## Reference uploaded file and image data
The Image Input and File Input components temporarily save captured data as blobs with `blob:` or `file://` URI strings. You can reference this blob elsewhere in your app (e.g., to preview in an [Image](../../reference/components/media/image.mdx) component) or upload captured images or files to a data store.

:::tip Convert blobs to Base64-encoded strings

You can use [utils.getDataByObjectURL()](../../../queries/reference/libraries/utils.mdx#utilsgetdatabyobjecturl) to convert blobs into a Base64-encoded string for other uses.

:::

The `value` property for the [Image Input](../../reference/components/media/image-input.mdx) and [File Input](../../reference/components/forms/file-input.mdx) components contains an array of `blob:` or `file://` values, as the components support multiple selections. The `files` property is an object with more information about the uploaded images. `value` is always an array, regardless of whether a user uploads a single file or multiple images. Single-image uploads are accessible using `value[0]`.

## Improved version of File Input

The improved File Input component offers users the ability to upload multiple files at a time, and the `value` state property is an array of blob URLs instead of a single Base64-encoded URL. The `value` property is a `string[]`, not an `object[]`.

export function ArcadeEmbed() {
  return (
    
      
    
  )
}

## Save uploaded files and images

You can reference `value` in queries to [store files in a data store](../../../queries/guides/files.mdx), such as Retool Storage or [Amazon S3](../../../data-sources/guides/integrations/object-file-store/amazon-s3.mdx).

:::tip Save files directly to Retool Storage

You can enable the **Upload file to Retool Storage** option for the component to automatically store the file in Retool Storage.

:::

---

## Forms and inputs



---

## Define option lists

import Shared from '/docs/_shared/_define-option-lists.mdx';

---

## Accept digital signatures

import FxSvg from '/img/icons/fx.svg';

You can use the [Signature](../../reference/components/forms/signature.mdx) component in mobile apps to collect digital signatures from customers.

## Collect a signature

Add the Signature component to the canvas then press the signature to present the input field. The component uses landscape orientation by default to maximize the available space.

The Signature component temporarily saves a captured signature in PNG format as a blob with a `blob:` or `file://` URI string. You can reference this blob elsewhere in your app (e.g., to preview in an [Image](../../reference/components/media/image.mdx) component) or upload captured signatures to a data store.

## Save uploaded signatures

:::important
Retool recommends saving signatures with [utils.getDataByObjectURL()](../../../queries/reference/libraries/utils.mdx#utilsgetdatabyobjecturl), which converts blobs into a Base64-encoded string. 
:::

You can reference the `value` property of Signature in queries to upload and store the signature in a data store, such as Amazon S3 or Retool Storage. 

### Upload a signature to Retool Storage

To save a signature to Retool Storage, add a JavaScript query to convert the blob URL to a Base64-encoded string. 

In the IDE, from your mobile app that contains a Signature component:

1. Capture a signature.
2. From the Code tab, select **+** and add a **JavaScript query** to the screen. 
3. Add the following code snippet to the query, and replace `signature1` in the following example code with the name of your signature component.
   ```   
   const base64String = await utils.getDataByObjectURL(signature1.value);
   return base64String;
   ```

export function ArcadeEmbed() {
  return (
    
      
    
  )
}

4. Click **+** to add a **Resource query** to the screen. 
5. Choose **Retool Storage** as the **Resource**.
6. Select **Upload file** as the action type.
7. Click the  button next to the **File content** field and enter `{{ query1.data }}`. Replace `query1` with the name of your JavaScript query.
8. Give the file a name, and click **Save**. 
9. Click **Run**. 

export function ArcadeEmbed_rq() {
  return (
    
      
    
  )
}

The **Output** section of the query displays the Base64-encoded string that you uploaded to **Retool Storage**. 

To verify that you've correctly captured the signature image:

1. Navigate to the **Retool home** button and select **Resources** from the dropdown. 
2. Select **Retool Storage**.
3. Find the signature file you uploaded to Retool Storage, and select **Download** from the  menu.
4. Open the downloaded file and copy the Base64 output.
5. In the IDE, click the **Components** tab.
6. Click **+** to add an Image component to the screen. 
7. In your mobile app, select the Image component to open the Inspector. 
8. Paste the Base64-encoded string into the **Image source** URL field. 

The image displayed should look the same as the signature you captured. 

export function ArcadeEmbed_verify() {
  return (
    
      
    
  )
}

### Upload a signature to an external data store
Queries that upload to data stores, such as Google Cloud Store and Amazon S3, require the correct MIME type and Base64-encoded data. Captured signatures use the `image/png` MIME type. You can use [utils.getDataByObjectURL()](../../../queries/reference/libraries/utils.mdx#utilsgetdatabyobjecturl) to convert blobs into a Base64-encoded string.

---

## Retool Mobile hardware integrations



---

## Read and write NFC tag data

Retool Mobile can read data from NFC tags and supports writing data using NDEF ([NFC Data Exchange Format](https://w3c.github.io/web-nfc/#dfn-ndef-record)) records.

## Read data using the NFC Reader mobile component

The [NFC Reader](../../reference/components/media/nfc-reader.mdx) mobile component uses a mobile device's native NFC reader interface without any additional configuration required. When a user presses the button, the native NFC reader appears and scans the NFC tag. The scanned data is then available using the component's `value` property.

This method for reading NFC data requires no additional configuration but often results in the native interface obscuring the app.

## Read and write data using the NFC resource

You can use the **NFC (Near-field communication)** resource for mobile apps to read and write NFC tag data. Unlike the NFC Reader mobile component, NFC resource queries don't use the native NFC reader interface. When the query is triggered, the NFC resource reads or writes NFC data seamlessly, which is better suited for frequent use of NFC tags.

### 1. Create a resource query

First, create a query that uses the **NFC** resource.

1. Click  to open the **Code** tab.
2. Click **+** to add a query.
3. Select **Resource query**.
4. Select the **NFC** resource.

### 2. Select the NFC method

Select the **Read** action to read NFC data. No additional configuration is required. 

Read data using an NFC resource query.

Select the **Write** action to write data to NFC tags. This is stored as a [NDEF TEXT record](https://w3c.github.io/web-nfc/#dfn-ndef-record).

Write data using an NFC resource query.

---

## Capture data with ProGlove scanners

Retool Mobile supports the use of [ProGlove](https://proglove.com) scanners with Android devices. Once configured, you use the [ProGlove mobile component](../../reference/components/media/proglove.mdx) to capture events from, initiate pairing with, and disconnect from ProGlove scanners.

## Prerequisites

:::tip

ProGlove shares common APIs with [Zebra](./zebra/index.mdx) for interoperability but it functionally distinct. You can use ProGlove scanners with any supported Android device.

:::

The ProGlove [INSIGHT Mobile](https://docs.proglove.com/en/insight-mobile--android-.html) app manages the integration between the Android device and ProGlove scanners. To use the ProGlove mobile component, a ProGlove administrator must:

- Install and set up the INSIGHT Mobile app on the Android device.
- Configure the INSIGHT Mobile [intent integration path](https://docs.proglove.com/en/intent-api---basic-integration.html#select-the-intent-integration-path).

Once complete, Retool Mobile can function with ProGlove scanners.

## 1. Configure the ProGlove component

First, add the **ProGlove** component to your mobile app. You use this component to pair and disconnect ProGlove scanners, and receive captured data.

Adding the ProGlove component.

When a ProGlove scanner captures data, it sends it as a ProGlove [Intent](https://docs.proglove.com/en/intent-api---basic-integration.html#barcode-scan-intent-structure) object. The Intent object contains the `com.proglove.api.extra.BARCODE_DATA` key that represents the data in the scanned barcode, and a `com.proglove.api.extra.BARCODE_SYMBOLOGY` key that represents the barcode type. Review [ProGlove's documentation on barcode symbologies](https://docs.proglove.com/en/symbology-settings.html) to see all possible values for `BARCODE_SYMBOLOGY`.

```json title: "Example ProGlove Intent"
{
  "com.symbol.datawedge.decoded_mode": "single_decode",
  "com.proglove.api.extra.BARCODE_SYMBOLOGY": "CODE 128",
  "com.proglove.api.extra.BARCODE_DATA": "1234567890",
  "com.motorolasolutions.emdk.datawedge.label_type": "LABEL-TYPE-CODE128",
  "com.symbol.datawedge.data_string": "1234567890",
  "com.motorolasolutions.emdk.datawedge.data_string": "1234567890",
  "com.motorolasolutions.emdk.datawedge.source": "scanner",
  "com.symbol.datawedge.label_type": "LABEL-TYPE-CODE128",
  "com.symbol.datawedge.source": "scanner"
}
```

The ProGlove component functions as a listener and receives the Intent, which triggers the **Capture** event. The component's `data` property is set to the received Intent. You can reference this property almost anywhere in Retool, such as `{{ proGlove1.data }}`.

You can also add a **Capture** event handler that runs whenever data is captured. For example, you can use the **Run script** action to set the value of a [Text](../../reference/components/text/text.mdx) component using JavaScript.

```js
text1.setValue(JSON.stringify(proGlove1.data));
```

Configure the ProGlove component event handler.

If you want to extract data from the barcode, use the `com.symbol.datawedge.data_string` key value. For example: `zebraDataWedgeReader1.data['com.symbol.datawedge.data_string']`.

## 3. Pair a ProGlove scanner

The ProGlove component initially displays a **Pair ProGlove** button. This action can only be performed when running the app on an Android device. When pressed, the INSIGHT Mobile app appears and performs the pairing process where you scan the Android device's QR code with the scanner. Once a scanner is paired, you can then use it to capture data.

The component's `scannerState` property reflects the current scanner connection.

| Value          | Description                                                  |
| -------------- | ------------------------------------------------------------ |
| `DISCONNECTED` | Scanner is disconnected.                                     |
| `CONNECTED`    | Scanner is connected.                                        |
| `CONNECTING`   | Scanner is connecting.                                       |
| `ERROR`        | An error occurred when attempting to connect to the scanner. |
| `RECONNECTING` | Scanner is reconnecting.                                     |
| `SETTING_UP`   | The scanner is currently being set up.                       |
| `SEARCHING`    | Searching for a scanner.                                     |

## Disconnect a scanner

You can disconnect a paired ProGlove scanner by pressing the **Disconnect** button. The `scannerState` property value changes to `DISCONNECTED` once done.

---

## Capture data using Zebra Android devices

import Zebra from "./_zebra.mdx";

Retool uses the [Zebra DataWedge APIs](https://techdocs.zebra.com/datawedge/11-3/guide/api/overview/) to receive and capture events using the [Zebra DataWedge Reader](../../../reference/components/media/zebra.mdx) component. To see an example app using the Zebra APIs, try out the [Inventory Management with Zebra Scanner](https://retool.com/templates/zebra-warehouse-management) template.

## Prerequisites

For security purposes, Zebra [controls access to the DataWedge Intents APIs](https://techdocs.zebra.com/datawedge/11-3/guide/programmers-guides/secure-intent-apis/). Zebra administrators must first create a Zebra DataWedge profile. You can create this profile on the **Zebra DataWedge setup** screen within the **Settings** menu. Open the top left menu when viewing the Retool Mobile app on a Zebra device and select **Settings** > **Zebra DataWedge setup** to get started.

This screen contains information for debugging your DataWedge profile, as well as a button to automatically configure a profile for Retool and an output of events:

Retool Mobile top left menu

Retool Mobile settings menu, showing an option for Zebra DataWedge setup

Zebra DataWedge Setup screen

Alternatively, administrators can [create a Zebra DataWedge profile](https://techdocs.zebra.com/datawedge/11-3/guide/api/createprofile/) with the following configuration to add the Retool Mobile app as an approved DataWedge application.

| Setting             | Value                     |
| ------------------- | ------------------------- |
| **Associated app**  | `com.retool.retool`       |
| **Activity**        | `*`                       |
| **Intent output**   | **Enabled**               |
| **Intent action**   | `com.retool.zebra.ACTION` |
| **Intent category** | Clear or leave unset      |
| **Intent delivery** | **Broadcast intent**      |

Once configured, the Retool Mobile app is able to receive captured data and provide it to your mobile apps. Refer to the [Zebra DataWedge APIs documentation](https://techdocs.zebra.com/datawedge/11-3/guide/api/) for more information on approved apps and profiles.

## Receive captured data in Retool Mobile

The [Zebra DataWedge Reader](../../../reference/components/media/zebra.mdx) component allows your Retool Mobile apps to receive this data and use it elsewhere. Add this component to your mobile app to receive captured Zebra data and configure [event handlers](../../interaction-navigation/event-handlers.mdx) to perform actions with it.

When a Zebra device captures data, it sends it as a DataWedge [Intent](https://techdocs.zebra.com/datawedge/11-3/guide/output/intent/#theintentobject) object. The Zebra DataWedge Reader component functions as a listener and receives the Intent, which triggers the **Capture** event. The component's `data` property is set to the received Intent.

The intent object contains a `com.symbol.datawedge.data_string` key that represents the data in the scanned barcode, and a `com.symbol.datawedge.label_type` key that represents the barcode type. Review [Zebra's documentation on the intent object](https://techdocs.zebra.com/datawedge/11-3/guide/output/intent/#theintentobject) to see all possible values for `label_type`. The intent object also contains various other keys depending on the model of your Zebra device. See below for a sample intent object:

```
{
  "com.symbol.datawedge.decoded_mode": "single_decode",
  "v2API": true,
  "com.motorolasolutions.emdk.datawedge.label_type": "LABEL-TYPE-CODE128",
  "com.symbol.datawedge.data_string": "1234567890",
  "com.symbol.datawedge.data_dispatch_time": 1701754038282,
  "com.motorolasolutions.emdk.datawedge.data_string": "1234567890",
  "com.motorolasolutions.emdk.datawedge.source": "scanner",
  "com.symbol.datawedge.label_type": "LABEL-TYPE-CODE128",
  "com.symbol.datawedge.source": "scanner"
}
```

You configure event handlers to trigger queries or perform actions when events occur. Click **+ Add** in the **Interaction** section of the Inspector to add an event handler.

For example, you can use the **Run script** action to set the value of a [Mobile Text](../../../reference/components/text/text.mdx) component using JavaScript. This is useful when testing your apps on Zebra devices. This example wraps the `data` property in `JSON.stringify()` to display it as a string.

```js
text1.setValue(JSON.stringify(zebraDataWedgeReader1.data));
```

If you want to extract data from the barcode, access the `com.symbol.datawedge.data_string` key on the data object. For example: `zebraDataWedgeReader1.data['com.symbol.datawedge.data_string']`.

## Hide the Zebra component button

The Zebra DataWedge Reader component initially displays a **Toggle scan** button that can trigger the embedded capture hardware, such as a scanner. If your Zebra devices already have a dedicated hardware button, you can hide the component. In the **Layout** section of the Inspector, set the component's **Hidden** setting to `true`.

Your mobile app only needs to contain a Zebra DataWedge Reader component to receive captured data, but it doesn't need to be visible.

---

## Build mobile apps for Zebra Android devices

import Zebra from "./_zebra.mdx";

---

## Print to Zebra label printers

You can use the **Zebra Printer** resource for mobile apps to write queries for Zebra Android devices that print to Bluetooth Zebra label printers.

## 1. Create a resource query

First, create a query that uses the **Zebra Printer** resource.

1. Click  to open the **Code** tab.
2. Click **+** to add a query.
3. Select **Resource query**.
4. Select the **Zebra Printer** resource.

## 2. Select the print method

Retool can send print jobs to a Bluetooth Zebra printer by either broadcasting to its MAC address or directly to one that is currently paired. Select the desired **Method** in the query.

Use **Broadcast to MAC address** to send print jobs to a Bluetooth Zebra printer and enter its MAC address, such as `00:23:45:67:89:AB`.

Send print jobs to a specified printer using its MAC address.

Select **Send to paired device** to send print jobs to a Zebra printer that is currently paired with the Zebra Android device. 

Send print jobs to a paired printer.

A ZPL (Zebra Programming Language) string is a series of commands for printing to Zebra printers. The exact ZPL string you provide is dependent on the Zebra printer in use.

The following example is a ZPL string that uses a `{{ }}` dynamic expression to reference a the current user's email address.

```text title="ZPL string example"
^XA
^FO50,50^A0N50,50^FD{{ current_user.email }}^FS
^XZ
```

Refer to Zebra's [ZPL command](https://supportcommunity.zebra.com/s/article/ZPL-Command-Information-and-DetailsV2) documentation to learn more about writing ZPL strings.

---

## Event handlers

import Shared from '/docs/_shared/_event-handlers.mdx';

---

## Interaction and navigation



---

## Assemble mobile screens

Retool Mobile organizes mobile components into separate screens that you create for different purposes. Users navigate between screens using the tab bar or by interactions that trigger event handlers, such as pressing a button or selecting an item from a list.

## Manage screens

When editing a Retool Mobile app, the [app IDE](../../../apps/concepts/ide.mdx) includes an additional _mobile panel_ on the left. Use the **Screens** section of the mobile panel to select, add, or delete screens from your mobile app.

To add a new screen, click the **+** button. To delete an existing screen, click the `•••` icon next to the screen, then select **Delete**.

Each screen has a _title_ and _name_ that you can update in the Inspector.

- The _title_ (e.g., `Screen 1`) is the text displayed in the app, similar to a web component's label. It appears in the title bar area of your app and in the tab bar at the bottom (if visible).
- The _name_ (e.g., `screen1`) is used within the editor as the reference when you configure settings or write queries.

You configure the selected screen using the Inspector (the **Inspect** tab) in the right panel.

## Navigate between screens

You can configure navigation between screens for your mobile app using the tab bar, configuring event handlers, or with JavaScript.

### Navigate with the tab bar

:::note

The first tab in the list is also the default screen that is first shown to users when opening the app.

:::

Mobile apps automatically include a _tab bar_ at the bottom of the app if **Add to tab bar** is enabled on at least two screens. Pressing a tab navigates to the screen associated with it.

You customize the tab bar in the **Tab** section of the Inspector. Click and drag to change the order of tab. The tab bar displays the screen name by default. You can click on each tab to set a custom icon and title for each tab.

### Navigate using event handlers

Retool uses [event handlers](event-handlers.mdx) to trigger queries or other actions in response to user events on mobile components. You can create **Navigation** event handlers that navigate to a screen when a specified action occurs.

| **Name**               | **Description**                                           |
| ---------------------- | --------------------------------------------------------- |
| **Navigate to screen** | Navigate to the specified screen.                         |
| **Open Modal**         | Open a modal using the specified screen.                  |
| **Back**               | Go back to the previous screen.                           |
| **Back to root**       | Navigate back to the first screen.                        |
| **Open bottom sheet**  | Open a Bottom Sheet that slides from the bottom of the viewport. |
| **Select tab**         | Navigate to a screen and update the tab bar.              |

You can trigger **Navigation** events almost anywhere in a mobile app that supports event handling, such as a button press or query failure.

#### Tablet mode navigation

Event handlers in tablet mode have an additional option for adding screens as detail views. When building an app for tablets, select the event handler and enable the **Add as detail view in tablet mode** option. From there, you can select different view settings for the screen.

### Navigate using JavaScript

You can [write JavaScript](../../../queries/quickstart.mdx) to control navigation using `navigator.navigateTo()` and the name of the screen:

```js title="Navigate to a screen"
navigator.navigateTo("screen1");
```

## Trigger actions with event handlers

You can configure screens with event handlers that trigger actions based on certain interactions or using additional buttons in the title bar.

Use the **Screen events** section of the Inspector to configure a screen with one of the following event handlers. Click **+ Add** to add an event handler or click an existing one to edit. You can also duplicate or delete event handlers by clicking the **...** icon.

| **Name**    | **Description**                              |
| ----------- | -------------------------------------------- |
| **Load**    | The screen is loaded.                        |
| **Visible** | The screen becomes visible.                  |
| **Hidden**  | The screen becomes hidden.                   |
| **Unload**  | The screen is unloaded.                      |
| **Refresh** | The user performs a pull-to-refresh gesture. |

### Load and unload events

A **Load** event occurs when a screen is loaded into the app's navigation. This occurs when:

- You add a screen to the tab bar in the app IDE.
- A user first navigates to a screen during an app session.
- A modal screen appears.

Load events are useful if you need to perform a one-time action in a particular screen, rather than trigger the action every time.

An **Unload** event occurs when a screen is unloaded from navigation. This occurs when:

- You remove a screen to the tab bar in the app IDE.
- A modal screen is dismissed.

Modal screens trigger **Load** and **Unload** events since they are loaded and unloaded into the app's navigation on-demand.

### Visible and hidden events

A **Visible** event occurs whenever a screen becomes visible to a user. A **Hidden** event occur when a screen is no longer visible. These events occur when users navigate the app and move from screen to screen.

### Refresh events

Retool Mobile supports the pull-to-refresh gesture (swipe and pull down on a screen). This triggers a **Refresh** event. A common use for this is to reload data, but you can also configure a **Refresh** event to perform any type of supported action.

You can provide users with visual feedback that data is currently being refreshed. Set the **Refreshing** property in the **Interaction** section of the Inspector to a truthy value. For example, queries include the `isFetching` property that reflects whether it is actively running.

## Action buttons

You can configure _action buttons_ that appear in the title bar area. Use the **Actions** section of the Inspector for a selected screen to configure action buttons.

The title bar supports a maximum of three action buttons—one left and two right. You can set a custom icon and text for action buttons, and select the action to perform.

## Display screens as modals or sheets 

Mobile apps can also display a screen as a modal or bottom sheet. These appear over the current screen without affecting navigation. As such, they contain controls to dismiss the screen instead of navigation. 

Modals and sheets must be invoked using an event handler, such as a button press. You configure modals and sheets using the **Navigation** event handler action. 

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

A _modal_ appears as a full-size screen and contains a **Done** button to dismiss. Use the **Open modal** method and select a screen to use. 

A _bottom sheet_ appears as a sliding popover that originates from the bottom of the viewport. It is only partially visible at first and can be dragged vertically to change its size. To dismiss, drag the sheet to the bottom of the viewport. 

Use the **Open bottom sheet** method and select a screen to use.

---

## Share data between mobile app screens

Mobile app screens cannot directly interact with each other. You can use globally scoped variables or localStorage to pass data between pages.

## Share data using global variables

Variables temporarily store data for the duration of the user's app session. They can also include an optional initial value. Learn more about [variables](../../../queries/guides/store-temporary-data.mdx).

To create a global variable, navigate to the **Code** tab and click **+ > Variable**. As the variable is globally scoped, you can update its value from any page using [event handlers](../../../apps/guides/interaction-navigation/event-handlers.mdx), or with the `setIn()` and `setValue()` [JavaScript methods](../../../queries/reference/objects/variable.mdx#methods).

For example, you can use the List Collection component's **Click** event handler to store the selected item in a global variable. You can then reference the global variable in another screen.

Store page data in a global variable.

You can then reference the global variable anywhere else within the mobile app.

 
Reference a global variable for use in another screen.

Once the user leaves the mobile app, the variable reverts to its initial value.

## Store page data in localstorage

:::warning

localStorage does not encrypt data. Only use localStorage to store nonsensitive information. 

:::

[localStorage](../../../queries/guides/store-temporary-data.mdx) temporarily stores data in the device's localStorage. Unlike variables, localStorage is a persistent data store. Provided the user continues to use the same browser and has not cleared their browsing history or cache, data remains available.

Use [event handlers](../../../apps/guides/interaction-navigation/event-handlers.mdx) or the `setValue()` [JavaScript method](../../../queries/reference/objects/localstorage.mdx#methods) to store data in localStorage. You can also clear app-specific data using `clear()`.

---

## Display data with Collection mobile components

You can present data using Card Collection and List Collection components that [dynamically map data](../forms-inputs/option-lists.mdx) and display it using prebuilt layouts. These components use **Mapped options** settings in the Inspector to configure item properties and how they appear.

## Display cards

The Card Collection mobile component display items in a card layout. It combines an image or icon with text information.

You can control the appearance of cards using the **Data Layout** settings in the Inspector. Options include:

- **Style**: **Flat** renders cards without a background and applies rounded corners to images. **Elevated** renders cards with a distinct border, shadow, and padding.
- **Scroll**: **Vertical** renders cards in a vertically scrolling column. **Horizontal** renders cards in a horizontally scrolling row.
- **Size**: **Full** renders full-size cards. **Half** renders half-size cards. If **Scroll** is set to **Vertical**, cards are displayed as either a single column or two-column grid.

You can also configure the image dimension ratio, such as **1:1** or **4:3** to display images to best fit your needs.

## Display lists 

The List Collection component renders each row of data using a list layout. It combines an image or icon with text information.

You can control the appearance of list items using the **Data Layout** settings in the Inspector. Options include:

- **Style**: **Flat** renders list items with no margin or background, and can include an optional separator between list items. **Elevated** renders list items with a distinct border, shadow, and padding.

## Assemble a custom collection

The Custom Collection mobile component allows you to build your own collection using other mobile components. This gives you control over which mobile components to include.

You add mobile components to a Custom Collection by clicking the **+** button or dragging them into the collection. You also use `item` and `i` to reference the current data source and set these as values for each mobile component.

## Select collection items

You can configure event handlers to trigger an action when a user selects a collection item, such as navigating to another screen or triggering a query. When a user selects an item, the item's data is stored in the collection's `selectedItem` property. This allows you to use details about a selected item elsewhere.

For example, each item contains a URL, `item.url`, to a web page that should open when selected. To achieve this:

1. Select a collection and click **+ Add** in the **Interaction** settings to add an event handler.
2. Set the **Action** to **Open URL**
3. Set the **URL** to `{{ self.selectedItem.url }}`

When an item is selected in a collection, the mobile app opens the web page using the `URL` of the selected item.

---

## Group components with the Mobile Container component

Retool Mobile apps arrange [mobile components](../../reference/components/index.mdx) in _column_ (vertical) and _row_ (horizontal) layouts. [Container](../../reference/components/layout/container.mdx) components include additional layout settings to control the layout of nested components.

## Horizontal layouts

You can arrange nested components horizontally:

1. Click **+** in the **Components** section and add a **Container** mobile component to your mobile app.
2. Add some mobile components to this Container, or drag existing ones into it.
3. Configure the Container to arrange nested mobile components in a row layout by selecting a **Layout type** of **➜**.

## Gap and padding

You can use **Gap** and **Padding** settings to fine-tune their layout.

- **Gap** controls the space between nested mobile components.
- **Padding** controls the space surrounding all nested mobile components.

You may need to adjust these settings whenever you make significant changes to your app's layout.

If you use nested mobile components extensively, you can use **Gap** and **Padding** settings to fine-tune their layout.

- **Gap** controls the space between nested mobile components.
- **Padding** controls the space surrounding all nested mobile components.

You may need to adjust these settings whenever you make significant changes to your app's layout.

## Spacing

Use the [Divider](../../reference/components/layout/divider.mdx) and [Spacer](../../reference/components/layout/spacer.mdx) mobile components to visually separate vertical areas of your mobile app with dividing lines or empty blocks of space.

---

## Customize mobile app style

You can customize the appearance and layout of mobile apps in a number of ways. Use Collections to display data using prebuilt card and list layouts, or create your own with mobile components. Configure your app's layout and tailor the design to meet your needs, and include additional UI elements to further extend functionality.

## Customize the layout with containers

Retool Mobile apps arrange [mobile components](../../reference/components/index.mdx) in _column_ (vertical) and _row_ (horizontal) layouts. [Container](../../reference/components/layout/container.mdx) components include additional layout settings to control the layout of nested components.

### Horizontal layouts

You can arrange nested components horizontally:

1. Click **+** in the **Components** section and add a **Container** mobile component to your mobile app.
2. Add some mobile components to this Container, or drag existing ones into it.
3. Configure the Container to arrange nested mobile components in a row layout by selecting a **Layout type** of **➜**.

### Gap and padding

You can use **Gap** and **Padding** settings to fine-tune their layout.

- **Gap** controls the space between nested mobile components.
- **Padding** controls the space surrounding all nested mobile components.

You may need to adjust these settings whenever you make significant changes to your app's layout.

If you use nested mobile components extensively, you can use **Gap** and **Padding** settings to fine-tune their layout.

- **Gap** controls the space between nested mobile components.
- **Padding** controls the space surrounding all nested mobile components.

You may need to adjust these settings whenever you make significant changes to your app's layout.

### Spacing

Use the [Divider](../../reference/components/layout/divider.mdx) and [Spacer](../../reference/components/layout/spacer.mdx) mobile components to visually separate vertical areas of your mobile app with dividing lines or empty blocks of space.

## Use collections to present data

You can present data using Card Collection and List Collection components that [dynamically map data](../forms-inputs/option-lists.mdx) and display it using prebuilt layouts. These components use **Mapped options** settings in the Inspector to configure item properties and how they appear.

You can also create your layout of mobile components with Custom Collection.

### Cards

Card Collection display items in a card layout. It combines an image or icon with text information.

You can control the appearance of cards using the **Data Layout** settings in the Inspector. Options include:

- **Style**: **Flat** renders cards without a background and applies rounded corners to images. **Elevated** renders cards with a distinct border, shadow, and padding.
- **Scroll**: **Vertical** renders cards in a vertically scrolling column. **Horizontal** renders cards in a horizontally scrolling row.
- **Size**: **Full** renders full-size cards. **Half** renders half-size cards. If **Scroll** is set to **Vertical**, cards are displayed as either a single column or two-column grid.

You can also configure the image dimension ratio, such as **1:1** or **4:3** to display images to best fit your needs.

### Lists

List Collection renders each row of data using a list layout. It combines an image or icon with text information.

You can control the appearance of list items using the **Data Layout** settings in the Inspector. Options include:

- **Style**: **Flat** renders list items with no margin or background, and can include an optional separator between list items. **Elevated** renders list items with a distinct border, shadow, and padding.

### Custom Collection

Custom Collection allows you to build your own collection using other mobile components. This gives you control over which mobile components to include.

You add mobile components to a Custom Collection by clicking the **+** button or dragging them into the collection. You also use `item` and `i` to reference the current data source and set these as values for each mobile component.

### Select collection items

You can configure event handlers to trigger an action when a user selects a collection item, such as navigating to another screen or triggering a query. When a user selects an item, the item's data is stored in the collection's `selectedItem` property. This allows you to use details about a selected item elsewhere.

For example, each item contains a URL, `item.url`, to a web page that should open when selected. To achieve this:

1. Select a collection and click **+ Add** in the **Interaction** settings to add an event handler.
2. Set the **Action** to **Open URL**
3. Set the **URL** to `{{ self.selectedItem.url }}`

When an item is selected in a collection, the mobile app opens the web page using the `URL` of the selected item.

## Additional UI elements

Retool Mobile event handlers include actions to display supplemental UI elements with additional actions or information.

Action sheets and alerts are modals that provide additional information and event handler actions for users to select. These actions allow users to trigger queries, navigate to a screen, etc. Both Action sheets and alerts can also include a title and description, allowing you to provide more context to users.

### Display an action sheet

An _action sheet_ is an overlay modal that appears at the bottom of the screen. It contains a title and description, along with a list of actions from which a user selects.

To create an action sheet:

1. Add a new event handler.
2. Set the **Action** to **Action sheet**.
3. Click **+ New** to add a new action to the sheet.

You configure event handlers for each menu item in an action sheet.

### Reload data with pull-to-refresh

Retool Mobile supports the pull-to-refresh gesture on screens by configuring the **Refresh** event handler. This allows users to trigger a specific action by performing the gesture on the specified screen.

A common use for this is to reload data in the current screen. If your screen contains components that use data from a query, you can configure the event handler to trigger the query. This reloads the query data and updates the components, refreshing the app with the latest data.

To enable pull-to-refresh on a selected screen:

1. Click **+ Add** to create an event handler.
2. Select the **Refresh** event.
3. Select the **Trigger** action and specify the query to run.

### Display an alert modal

An _alert_ is a modal that appears at the center of the screen. It contains a title and description, along with a maximum of two actions.

To create an alert:

1. Add a new event handler.
2. Set the **Action** to **Alert**.
3. Click **+ New** to add a new action to the alert.

### Display in-app notifications

:::note

Retool Mobile notifications are in-app banners. They are not push notifications.

:::

A _notification_ is an informational modal that appears at the bottom of the screen.

To create a notification:

1. Add a new event handler.
2. Set the **Action** to **Notification**.
3. Specify the **Title**, **Description**.
4. Select the **Type** of notification

The notification's **Type** reflects the severity of the notification, changing the icon and color used. You can also control the duration that notifications remain on the screen.

## Apply custom theme styles

:::warning

Retool Mobile app themes function separately from Retool web app [themes](../../../apps/guides/presentation-styling/themes.mdx).

:::

You can create and manage custom styling for your mobile apps with _themes_. To customize your app's theme, click the `•••` **App actions** menu and select **App theme**.

- **Primary**: The default accent color used by most mobile components.
- **Header**: The background color for the title area of screens.
- **Buttons**: The corner style for buttons.

You can create custom themes and apply them to your mobile apps.

---

## Layout and structure



---

## Retool Mobile offline functionality



---

## Offline assets

The **Offline Assets** app setting in Retool Mobile allows you to store PDF files that can be retrieved and viewed offline, or in situations where internet connectivity is limited.  

## Create a new offline asset

:::note
PDF is currently the only file type supported for offline assets. 
:::

To create a new offline asset, upload a PDF URL to your mobile app from **App settings > Offline Assets**. 
1. Click the **App Settings** tab. 
2. Select **Offline Assets**. 
3. Click the **Add new** button.
4. Populate the **Name** and **URL** of the PDF.
5. Click **Add**. 

export function ArcadeEmbed_offline() {
  return (
    
      
    
  )
}

## View an offline asset with PDF Viewer

:::warning
To view your PDF with the PDF Viewer component, your URL must have a CORS policy that allows retool.com to access the PDF file. CORS policies vary between cloud and self-hosted (for example, `https:{domain}.retool.com` for cloud-hosted organizations, and `FQDN` for self-hosted organizations). To view an example CORS policy, refer to [Configure the CORS policy](../../../data-sources/guides/integrations/object-file-store/amazon-s3.mdx#configure-the-cors-policy). 

You can also upload a PDF as a Retool Storage resource, and select **Copy URL** from the `...` dropdown menu. 
:::

To use the PDF Viewer component:
1. Open the **Component tree** panel. 
2. Select the **+** to add a new component.
3. Select the PDF Viewer component and drag it to the app IDE. 
4. In the **Inspector**, select **Offline Asset** from the **PDF source** dropdown. 
5. Select the **Offline Asset** to view from the dropdown list. 

The PDF Viewer component displays the selected offline asset. 

export function ArcadeEmbed_pdfviewer() {
  return (
    
      
    
  )
}

---

## Offline mode

Offline mode makes it possible for Retool Mobile apps that run natively to continue functioning without a data connection. When enabled, queries that read data can cache the most recent results to make them available offline. Queries that write data are held in a queue and run once the data connection is restored.

## Considerations

If you plan to use offline mode, keep in mind the following considerations.

### Read queries only cache data when viewed by the user

Queries configured to read data for offline mode only cache data when the user views the results. The user must navigate to screens and view the query data at least once while connected.

If you need to download data in advance, consider using localStorage to temporarily download data that can be accessed when offline.

### Write queries run sequentially

Queries configured to write data in offline mode run sequentially when the connection is restored. If one query fails due to a conflict, the user must resolve it before any remaining queries can run.

### Write queries cannot have dependencies

Queries with pending changes in offline mode cannot depend on any other queries. For example, if you have a customer management app that is offline, the user could not create a new customer record and then refresh the list of customers. Similarly, the user could not create a new customer record offline and then make further changes.

### Handle conflicts

All pending tasks run sequentially when a device's connection is restored. If multiple users made changes to the same data, offline mode cannot merge their changes. Consider using sync delay when enabling offline mode so that users must trigger pending tasks.

### Cached data limits

Retool Mobile can cache up to 100MB of data. If offline mode exceeds this limit, Retool Mobile excludes the last used entries.

## Enable offline mode

Offline mode is available on a per-app basis and enabled in the app IDE. Click `•••` to open the **App actions** menu, select **Mobile app settings**, then toggle **Mobile offline mode** on.

Retool Mobile attempts to trigger pending queries automatically. You can require users to manually trigger pending queries that write data by toggling **Mobile offline mode delay sync**.

When offline mode is enabled, your app displays a connection status bar at the top of each screen.

- **Connected** or **Reconnected** (green): The app is connected to Retool.
- **Offline** (amber): The app is not connected to Retool and is operating in offline mode. The status includes the number of pending changes.
- **An error has occurred** (red): The app is unable to reconnect or cannot perform pending changes.

Retool Mobile stores cached data in the filesystem and is not lost when the app or device is restarted. Cached data is deleted if the app is uninstalled.

## Configure offline query types

You must configure the **Query type** for each query that should be available in offline mode:

- **Read**: The query reads data. The app caches the most recent data returned by the query and makes it available offline.
- **Write**: The query writes data. The app enqueues these queries and triggers them when the connection is restored.

Select a query in the bottom panel, navigate to the **Advanced** tab, and specify the **Query type** in the **Offline** section.

## View query status

The **Job Manager** contains a list of failed, pending, and completed queries. Tap the connection status bar at the top of the app screen to open it. Each entry contains the query name and date. Users can remove pending queries by pressing **Remove**.

Offline write queries can display key-value pairs in the Job Manager. You configure these using the **Display body** fields in the **Offline** section for a query.

Display body values can help provide context on the pending changes, such as displaying the original and modified values.

## Run pending changes

Retool Mobile automatically processes pending queries once the connection is restored. If **Mobile offline mode delay sync** is enabled, the Job Manager includes an action button to manually trigger the queries—users must press this for changes to occur.

The Job Manager processes each pending change sequentially. If a query fails for any reason, such as a conflict in data, the user must resolve this by retrying or removing the failed change. Any remaining queries will remain in a pending state until this is completed.

## Use Retool Storage in offline mode

Some users experience issues handling images in offline mode, because dependent queries are not supported after uploads. As a result, it’s impossible to execute post-upload processes while offline.

If you are having issues handling images in offline mode, reach out to your account manager or the support team and request that they enable the `mobileRetoolStorageAsync` feature flag.

This feature enables uploaded files to be stored on the device and added to the offline queue for later submission while providing the Retool Storage metadata right away. Users can then proceed with post-data processing even while offline.

---

## Reference dates and times in components

You can reference a configured date and time in various components, preserving the user's selected time zone.

import Components from '/docs/_shared/_dates-in-components.mdx';

---

## Display icons

import Shared from '/docs/_shared/_icons.mdx';

---

## Presentation and styling



---

## Share data between mobile app screens

Mobile apps use global and per-screen scopes for components and code.

- Globally scoped objects can be referenced across multiple screens. Retool continually evaluates globally scoped objects regardless of the screen currently in view.
- Screen-scoped objects can only be referenced within the same screen. Retool only evaluates screen-scoped objects when the screen is currently being viewed.

If you need to share data between screens, you can use globally scoped variables or localStorage.

## Share data using global variables

[Variables](../../queries/guides/store-temporary-data.mdx) temporarily store data for the duration of the user's app session. They can also include an optional initial value. 

To create a global variable, navigate to the Code tab and click **+ > Variable**. As the variable is globally scoped, you can update its value from any screen using [event handlers](./interaction-navigation/event-handlers.mdx), or with the `setIn()` and `setValue()` [JavaScript methods](../../queries/reference/objects/variable.mdx#methods).

Store data in a global variable.

You can then reference the global variable from any screen.

 
Reference a global variable.

For example, you can use the Table component's **Double Click Row** event handler to store the selected row data in a global variable. You can then reference the global variable in another screen, such as a component value.

If a user closes the tab, navigates away from the app, or opens the app in another tab, the variable reverts to its initial value.

## Store screen data in localStorage

:::warning

localStorage does not encrypt data. Only use localStorage to store nonsensitive information. 

:::

[localStorage](../../queries/guides/store-temporary-data.mdx) temporarily stores data in the browser's localStorage. Unlike variables, localStorage is a persistent data store. Provided the user continues to use the same browser and has not cleared their browsing history or cache, data remains available.

Use [event handlers](./interaction-navigation/event-handlers.mdx) or the `setValue()` [JavaScript method](../../queries/reference/objects/localstorage.mdx#methods) to store data in localStorage. You can also clear app-specific data using `clear()`.

---

## Mobile apps how-to guides

import Howto from '/docs/_partials/_doctypes/_howto.mdx';

:::tip Get started with mobile apps

If you are unfamiliar with Retool mobile apps and want to get started: 

- Read the [quickstart](./quickstart) to learn about the fundamental concepts.
- Follow a [tutorial](./tutorial/) to build your first mobile app.

:::

---

## Retool Mobile documentation

[Retool Mobile](https://retool.com/products/mobile) is a fast, complete solution for building native iOS and Android apps for your mobile workforce. Connect to your databases and APIs, assemble polished mobile interfaces with multi-page navigation, and deploy apps instantly.

---

## Retool Mobile quickstart

import Image from '@site/src/components/Image';

This guide serves as an introduction to Retool mobile apps that run natively on iOS and Android. It covers many of the concepts and terminology you would come across as you build mobile apps. After reading this page, you should have a good understanding of the fundamentals for building Retool mobile apps.

## Assemble the interface

A Retool Mobile app's user interface is comprised of screens and components. These interface elements function as objects with internal state.

- [Screens](#screens) are separate sections that contain their own code and components. Users navigate between screens, which are often used for distinct use cases. For example, a customer support app might have separate screens to view a list of customers and details of a selected customer.
- [Components](#components) are interface elements, such as a [text input field](./reference/components/forms/text-input.mdx) or a [button](./reference/components/buttons/button.mdx), with which users interact.

:::info

Retool Mobile app screens function in much the same way as [pages](../apps/quickstart.mdx) in Retool apps.

:::

Retool exposes properties, methods, and events with which you can interact. As you interact with components, their properties change. For example, entering text into a Text Input component changes its `value` property value.

You also write code that interacts with data, transforms values, or control behavior using JavaScript methods. For example, use `setValue('Jenny Appleseed')` to set the `value` property value of a Text Input component to **Jenny Appleseed**.

### Components

You build mobile apps using the [app IDE](../apps/concepts/ide.mdx) for Retool Mobile, Retool's drag-and-drop app building web interface. You use the app IDE to:

- Visually assemble the mobile app interface.
- Write queries to interact with data.
- Configure actions based on user interactions.
- Share apps directly with users.

### Screens

Retool only evaluates a screen's objects when the screen is currently in view. This allows for apps to serve multiple functions without impacting performance.

The **Screens** tab contains a list of screens within the app. The default screen is the one that first loads when launching the app. You can explore and manage all screens, change the default screen, and view more details.

Screens also function as modals and sheets, providing a number of ways for which users can interact. You can optionally configure screens with _actions_—buttons in the top bar that trigger event handlers

### Tab bar

The _tab bar_ is the primary navigation element in mobile apps. You specify which screens to include and they appear as selectable tab items. You can also customize the tab item's label and icon. Users then tap to navigate to each screen.

### Global and screen scopes

Apps use global and per-screen scopes for components and code.

- Globally scoped objects can be referenced across multiple screens. Retool continually evaluates globally scoped objects regardless of the screen currently in view.
- Screen-scoped objects can only be referenced within the same screen. Retool only evaluates screen-scoped objects when the screen is currently being viewed.

#### Globally scoped objects

You can create **Global** code (e.g., resource queries or variables), which all screens can reference. Each screen can interact with globally scoped code to trigger queries, set variable values, etc. For example, if you were building a customer support app then you could use a single globally scoped query to retrieve customer information rather than duplicate the same query across multiple screens.

You can drag code to either **Global** or **Screen** to change its scope. You can also move code across screens using the **Move to screen** contextual menu action.

All screens and their contents can reference globally scoped objects. Globally scoped objects, however, can only reference other globally scoped objects. For instance, a globally scoped query cannot reference a property for a component in a screen.

#### Screen-scoped objects

All code and components within a screen are screen-scoped, and cannot be referenced by other screens. If a screen contains code or event handlers that would run on load, these run whenever you navigate to the screen.

Globally scoped and screen-scoped code and components.

## Connect interface elements together

Most component properties are editable. You configure them in the IDE with either static values (`string`, `number`, `boolean`, `array`, and `object`) or reference other component values using `{{ }}` embedded expressions, similar to the use of [template literals](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals).

You reference property values using [dot notation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Property_accessors#dot_notation). For instance, you can select an item from the inventory list to get more details. The Image component value is set to `{{ itemCollection.selectedItem.image }}`, which updates whenever you change the selection.

## Use JavaScript expressions for values

Retool performs [string interpolation](https://en.wikipedia.org/wiki/String_interpolation) and evaluates `{{ }}` embedded expressions as JavaScript. As a result, you can write JavaScript code—that evaluates and returns a value synchronously—almost anywhere. This enables you to dynamically set property values using transformations or conditional logic to build complex apps.

The List Collection component uses a ternary operator and the selected value of the Segmented Control mobile component to toggle sorting the list by quantity or price.

```js
{{
  sortOptions.value === 'quantity'
  ? getItems.data.sort((a, b) => b.quantity - a.quantity)
  : getItems.data.sort((a, b) => b.price - a.price)
}}
```

## Connect your data using resources

A resource is a saved set of user-configured properties that determines how Retool connects to a data source, such as a [PostgreSQL](../data-sources/guides/integrations/database/postgresql.mdx) database or [REST API](../data-sources/guides/integrations/api/rest.mdx). You create a resource for each data source you want to use with Retool, then write queries to interact with them.

Each resource has configuration options that Retool uses when interacting with a data source. This simplifies how you query data sources while ensuring access is secure.

import Lifecycle from '../_partials/_resource-lifecycle.mdx';

## Read and write data using queries

A query is a piece of code you write to interact with a resource and perform CRUD operations. As with components, queries maintain an internal state and expose properties. Queries can also perform asynchronous actions and run simultaneously with other queries.

Queries are not part of an app's user interface. You reference the query's `data` property to read and display data in components for which users can interact. Queries can also reference component input values and write them back to the data source.

## Connect the interface together

Under the hood, Retool maintains a dependency graph for each app. This represents all property values and where they're referenced. Whenever a property changes, all downstream references using embedded expressions automatically update. This is similar to how spreadsheet formulas work when referencing cell values; if a referenced value changes then the formula instantly updates its result.

The **Component tree** and **Code** panels contain the **Graph** pane. This visualizes the dependency graph for a selected component or query. You can use the graph to view the relationship between the selected component or query and its immediate dependents.

export function ArcadeGraph() {
  return (
    
      
    
  )
}

:::tip

Hover the cursor over the connecting points to display a tooltip with a list of dependencies and dependents.

:::

You can chain embedded expressions together by referencing values that also use embedded expressions. Any input value changes automatically propagate through the entire app. This makes it possible to build powerful applications with very few lines of code.

:::info Dependency cycles
The dependency graph enables Retool to prevent you from creating circular dependencies, where two or more properties rely on each other to function. If you attempt to reference values that rely on one another, the IDE displays a warning.

:::

The Inventory mobile app contains a List Collection component to display a list of inventory items. Its data source is set to `getItems.data`. There is also a slider that filter results based on quantity. This is done using a JavaScript `filter()` expression that transform the output of the query.

```javascript
return formatDataAsArray(data).filter(row => row.quantity 

## Control and run queries with event handlers

You configure event handlers to perform actions whenever a specific event occurs, such as a button press or query error. There are numerous actions available, such as setting component values and triggering queries.

The Inventory mobile app uses a number of different event handlers. For instance, an event handler is configured to navigate to the `itemDetailsScreen` screen when an item is selected from the list. This screen contains components that reference the selected item's properties.

## Transform data using transformers

While you can use JavaScript within `{{ }}` embedded expressions, you may need to manipulate multiple sources of data and implement complex logic to produce values, such as filtering or joining data sets.

A [transformer](../queries/guides/transformers.mdx) is a reusable block of JavaScript. Unlike the data transformation you can perform directly from a query, transformers operate independently. You reference property values using embedded expressions and the results of the transformation are output on the transformer's `value` property using a `return` statement.

The Inventory mobile app uses a transformer, `totalPrice`, to calculate the total amount of all visible items. The result is then formatted using `toLocaleString()` and displayed in a Text mobile component.

```js
const items = {{ getItems.data }}
const total = items.reduce((acc, item) => acc + (item.price * item.quantity), 0);

const formattedTotal = total.toLocaleString('en-US', {
  minimumFractionDigits: 2,
  maximumFractionDigits: 2
});

return formattedTotal;
```

Transformers are maintained by the dependency graph and continually output a transformed value. If you make changes to any values in the dependency chain, the transformer automatically updates.

## Script apps with JavaScript

You can write JavaScript code to control app behavior, set property values, and more. Components and queries are globally scoped and include built-in methods to control their state. These methods can accept supported parameters, such as string or index values. In either case, you only need to use standard JavaScript notation, not `{{ }}` embedded expressions.

:::note JavaScript output
JavaScript queries can output data using a `return` statement.
:::

The **Reset** button below the list triggers a JavaScript query that sets the value of the Slider and Segmented Control mobile components, effectively resetting the results to their defaults.

```js
quantitySlider.setValue(50);
sortOptions.setValue('quantity');
```

## Run apps natively on iOS and Android

:::tip Mobile PWA apps

You can run mobile apps in the browser as progressive web apps.

:::

Users browse and run mobile apps natively using the Retool Mobile app iOS and Android. This approach simplifies deployment and makes all Retool Mobile apps instantly available. You can share links to apps so users can launch them on their device, or open them in a browser.

The Retool Mobile app for iOS and Android uses [React Native](http://react-native.org/) to run mobile apps natively. Users can log in to their Retool organization, browse or search for mobile apps, and launch them on their mobile device.

Whenever you add or update an app, it's immediately available within the Retool Mobile app for users.

## Leverage mobile device functionality

Retool Mobile enables you to make use of the software and hardware functionality of mobile devices.

- **Biometric verification**. Use built-in biometric features to provide an extra layer of identity verification, such as fingerprint or face scanning. After users log in, they are prompted to verify their identity using biometrics each time they bring the app to the foreground. Biometric verification does not replace your existing login mechanisms.
- **NFC**: Use a device's built-in NFC reader to capture data from NDEF-formatted tags.
- **Camera**: Use the camera to take photos and scan barcodes.
- **Zebra**: Receive data captured by a Zebra Android device with dedicated hardware.

## Send push notifications

The Retool Mobile app includes support for push notifications. You can trigger notifications with queries using the built-in **Mobile Push Notifications** resource from any app or workflow.

Configuring push notifications is a two-part process:

- Add a query to mobile apps that subscribe users to push notifications and enables them on their device.
- Write queries in Retool apps and workflows to send push notifications to subscribed users.

Push notifications use topics to represent the scope for recipients. Topics are similar in function to mailing lists—users subscribe to them based on what information they want to be notified about. Users [subscribe to push notifications](./guides/app-management/push-notifications.mdx#subscribe-users-to-push-notifications) using a subscription query in which you specify the topics to use. To send a notification, you use a query that references the relevant topic rather than managing a separate list of users.

## Work offline

[Offline mode](./guides/offline-functionality/offline-mode.mdx) allows natively run mobile apps to continue functioning without a data connection. When enabled, queries that read data can cache the most recent results to make them available offline. Queries that write data are held in a queue and run once the data connection is restored.

## Test and troubleshoot issues

You can use Retool's [Debug Tools](./concepts/debug-tools.mdx) to explore your Retool Mobile app, review errors, and debug issues during development. You can also use the Model browser in the left panel of the app IDE to explore all component and query properties.

Retool Mobile does not support interactions using the web console. This includes `console.log()` or running JavaScript using the **Console** tab of Debug Tools. Instead, you can use components to display output by setting their values (e.g., Text Area) or **Run JS Code** JavaScript queries to perform certain commands directly in the app IDE.

## Wrap up

Using these fundamental concepts, you can build complex mobile apps that:

- Contain polished user interfaces that can adapt to your needs.
- Dynamically reference values anywhere using dependency chains.
- Connect with almost any API and database to interact with your data.
- Perform actions using conditional logic in response to user events or script apps to control behavior.

## Next steps

You now have a basic understanding of how to build a Retool app. Check out the [mobile app tutorial](tutorial.mdx) to build a complete app from start to finish.

---

## The Button component for Retool Mobile

## Properties

## Methods

## Events

---

## The Fab component for Retool Mobile

Fab floats above other content and remains at a fixed position.

## Properties

## Methods

## Events

---

## Button components for Retool Mobile



---

## The Checkbox Group component for Retool Mobile

## Properties

## Methods

## Events

---

## The Checkbox component for Retool Mobile

## Properties

## Methods

## Events

---

## The Date Picker component for Retool Mobile

## Properties

## Methods

## Events

---

## The Date Time Picker component for Retool Mobile

## Properties

## Methods

## Events

---

## The File Input component for Retool Mobile

## Properties

## Methods

## Events

---

## The Form component for Retool Mobile

## Properties

## Methods

## Events

---

## Form components for Retool Mobile



---

## The Multiselect component for Retool Mobile

## Properties

## Methods

## Events

---

## The Number Input component for Retool Mobile

## Properties

## Methods

## Events

---

## The Radio Group component for Retool Mobile

## Properties

## Methods

## Events

---

## The Search Bar component for Retool Mobile

## Properties

## Methods

## Events

---

## The Segmented Control component for Retool Mobile

## Properties

## Methods

## Events

---

## The Select component for Retool Mobile

Options are displayed in a full-screen list box with search filter when there are more than 10 values.

## Properties

## Methods

## Events

---

## The Signature component for Retool Mobile

## Properties

:::note

Retool recommends saving signatures with [utils.getDataByObjectURL()](../../../../queries/reference/libraries/utils.mdx#utilsgetdatabyobjecturl), which converts blobs into a Base64-encoded string. For more information, refer to the [Accept digital signatures](../../../guides/forms-inputs/signatures.mdx) guide. 

:::

## Methods

## Events

---

## The Slider component for Retool Mobile

## Properties

## Methods

## Events

---

## The Status component for Retool Mobile

## Properties

## Methods

## Events

---

## The Switch Group component for Retool Mobile

## Properties

## Methods

## Events

---

## The Switch component for Retool Mobile

## Properties

## Methods

## Events

---

## The Text Area component for Retool Mobile

## Properties

## Events

---

## The Text Input component for Retool Mobile

## Properties

## Methods

## Events

---

## Retool Mobile components reference



---

## The Card component for Retool Mobile

## Properties

## Methods

## Events

---

## The Collapsible Container component for Retool Mobile

## Properties

## Methods

## Events

---

## The Container component for Retool Mobile

## Properties

## Methods

## Events

---

## The Divider component for Retool Mobile

## Properties

## Methods

---

## Layout components for Retool Mobile



---

## The Spacer component for Retool Mobile

## Properties

## Methods

## Events

---

## The Tabbed Menu component for Retool Mobile

:::info Preset configuration

Tabbed Container is a preset configuration of the [Container](./container.mdx) and [Segmented Control](../forms/segmented-control.mdx) components. Refer to their documentation for more information about properties, methods, and events.

:::

---

## The Chart component for Retool Mobile

A chart to visualize data in different layouts using [Plotly](https://plotly.com/). Refer to [Plotly's JavaScript reference](https://plotly.com/javascript/reference/) to learn more about available options.

## Properties

## Methods

## Events

---

## The HTML component for Retool Mobile

:::note

The HTML component utilizes [react-native-render-html](https://github.com/meliorence/react-native-render-html), and it has certain [limitations](https://github.com/meliorence/react-native-render-html/blob/master/HELP.adoc#standard) that mean it cannot always adhere to CSS or HTML standards.

:::

## Properties

## Methods

## Events

---

## The Icon component for Retool Mobile

## Properties

## Methods

## Events

---

## The Image Input component for Retool Mobile

Captured images are temporarily stored on the device for native apps and in the Retool organization for web apps.

## Properties

## Methods

## Events

---

## The Image component for Retool Mobile

## Properties

## Methods

## Events

---

## Media components for Retool Mobile



---

## The Map component for Retool Mobile

An embedded map using [MapBox](https://www.mapbox.com/) to display latitude and longitude coordinates as points of interest. It supports default coordinates and can trigger queries when selecting a point.

## Properties

## Methods

## Events

---

## The Microphone component for Retool Mobile

Recordings are Base64-encoded in WebM format, and audio playback displays a progress bar and elapsed time.

## Properties

## Methods

## Events

---

## The NFC Reader component for Retool Mobile

NFC Reader supports reading NDEF-formatted tags. Please [reach out](mailto:mobile-team@retool.com) if your use case requires reading other NFC formats.

## Properties

## Methods

## Events

---

## PDF Viewer component

## Properties

---

## The ProGlove component for Retool Mobile

Receive data captured by an Android device with a connected [ProGlove scanner](../../../guides/hardware-integrations/proglove.mdx).

## Properties

## Methods

## Events

---

## The Scanner component for Retool Mobile

## Properties

## Methods

## Events

## Supported barcode formats

Mobile Scanner supports a range of barcode formats on iOS and Android.

| Name                        | Short name      |             iOS             |           Android           |
| :-------------------------- | :-------------- | :-------------------------: | :-------------------------: |
| Aztec Code                  | aztec           |   |   |
| Codabar                     | codabar         |   |   |
| Code 39                     | code39          |   |   |
| Code 39 with 43 check digit | code39mod43     |   |  |
| Code 93                     | code93          |   |   |
| Code 128                    | code128         |   |   |
| Data Matrix                 | datamatrix      |   |   |
| EAN-13                      | ean13           |   |   |
| EAN-8                       | ean8            |   |   |
| Interleaved 2 of 5          | interleaved2of5 |   |  |
| ITF-14                      | itf14           |   |   |
| MaxiCode                    | maxicode        |  |   |
| PDF417                      | pdf417          |   |   |
| RSS 14                      | rss14           |  |   |
| RSS Expanded                | rssexpanded     |  |   |
| UPC-A                       | upc_a           |  |   |
| UPC-E                       | upc_e           |   |   |
| UPC/EAN-13                  | upc_ean         |  |   |
| QR                          | qr              |   |   |

---

## The WebView component for Retool Mobile

## Properties

## Methods

## Events

---

## The Zebra DataWedge Reader component for Retool Mobile

Receive data captured by a Zebra Android device with dedicated hardware and sent using the [Zebra DataWedge APIs](https://techdocs.zebra.com/datawedge/11-3/guide/api/). Refer to the [Retool Mobile on Zebra devices](../../../guides/hardware-integrations/zebra/index.mdx) guide for instructions.

## Properties

## Methods

## Events

---

## The Card Collection component for Retool Mobile

## Properties

## Methods

## Events

---

## The Custom Collection component for Retool Mobile

## Properties

## Methods

## Events

---

## Pattern components for Retool Mobile



---

## The Key Value component for Retool Mobile

## Properties

## Methods

## Events

---

## The List Collection mobile layout

## Properties

## Methods

## Events

---

## The Heading component for Retool Mobile

## Properties

## Methods

---

## Text components for Retool Mobile

Mobile components to display headings and plain text.

---

## The Text component for Retool Mobile

## Properties

## Methods

---

## Retool Mobile environment variables

import Mobile from "@site/docs/self-hosted/reference/environment-variables/mobile.mdx";

---

## Mobile app event handlers reference

## Events

Support for each event depends upon the component or object being configured.

## Actions

import Actions from '/docs/_shared/_event-handler-actions.mdx';

---

## Mobile apps glossary

import SharedGlossary from '../../_partials/_glossary.mdx';

---

## The Current User object

## Properties

---

## The Retool Context object

## Properties

---

## The Theme object

## Properties

---

## The Url object

## Properties

---

## The Viewport object

## Properties

---

## Retool Mobile reference

import Reference from '/docs/_partials/_doctypes/_reference.mdx';

:::tip Get started with web apps

If you are unfamiliar with Retool mobile apps and want to get started: 

- Read the [quickstart](./quickstart) to learn about the fundamental concepts.
- Follow a [tutorial](./tutorial/) to build your first mobile app.

:::

---

## Retool Mobile tutorial

[Retool Mobile](https://retool.com/products/mobile) enables you to quickly build mobile apps using a drag-and-drop interface and mobile component library. You can connect almost any database and API to Retool, allowing your workforce to interact with your data using native apps for iOS and Android.

This tutorial explains how to build a basic customer management mobile app on Retool. You can browse through a list of customers, select one to view details, and update their email address.

## Prerequisites

Familiarity with common technologies like APIs, SQL, and JavaScript is expected to complete this tutorial. If you need to learn more about these technologies, try the following online learning resources:

- [Freecodecamp: How to use REST APIs](https://www.freecodecamp.org/news/how-to-use-rest-api/)
- [Khan Academy: Introduction to SQL](https://www.khanacademy.org/computing/computer-programming/sql)
- [Codecademy: JavaScript](https://www.codecademy.com/catalog/language/javascript)

## What you'll learn

After completing this tutorial, you'll gain the necessary knowledge to:

- Connect your data sources as resources.
- Assemble user interfaces using drag-and-drop components.
- Query resources to interact with data.
- Connect queries and components to manipulate data.
- Extend your app's functionality with JavaScript queries and transformers.

These terms and concepts may not be familiar but you'll learn about them as you work through the tutorial.

## 1. Create a resource

Retool can interact with almost any API or database, and includes [native integrations](../data-sources/index.mdx) for many different data sources. After you configure a resource, you can build apps using your data.

Return to the **Resources** page and then navigate to the **Apps** page.

## 2. Create a new mobile app

Navigate to the Apps page and click **Create new > Mobile app**. Every new mobile app is initially configured with a demo that uses a preconfigured interface and sample data for you to try out. For the purposes of this tutorial, remove the demo content when you open the app.

export function CreateNewApp() {
  return (
    
      
    
  )
}

When you develop a Retool Mobile app, the [Mobile IDE](../apps/concepts/ide.mdx) renders your mobile app on the canvas. On the left are tabs that contain sections to manage different aspects of the app, such as Screens and Components. When you select a screen or component, the Inspector on the right provides you with configurable settings.

## 3. Prepare screens

You create multi-screen mobile apps where each [screen](guides/interaction-navigation/screens.mdx) functions as a separate _page_ with its own code and components. You can navigate between each screen using the tab bar or by interactions that trigger event handlers, such as pressing a button or selecting an item from a list. Retool only evaluates the code and components of the screen currently in view, ensuring that complex mobile apps are performant.

### Add new screens

This app uses two screens, one for displaying a list of customers and another for editing the selected customer's details. To add these screens:

1. Navigate to the Screens tab and click .
2. Right-click the screen and select **Rename**, then set its name to `customers`. 
3. Repeat the process to add a screen named `customerDetails`.

Once done, right-click the **customers** screen and select **Set as default screen**.

After adding the new screens, right-click on each existing screen and select **Delete**.

export function AddScreens() {
  return (
    
      
    
  )
}

Each screen has a title to identify which screen a user is currently viewing. This is displayed at the top of the app and in the navigation bar. Set the title for the **customers** and **customerDetails** screens by selecting one and updating the **Title** in the Inspector to `Customers` and `Customer details`, respectively.

## 4. Get customer data

You write [resource queries](../queries/tutorials/resource-query.mdx) to interact with resources, such as SQL statements or API requests. Queries can be either screen-scoped or globally scoped. For the purposes of this tutorial, add a page-scoped query:

1. Navigate to the Code tab.
1. In the **customers** section, below the **Global** section, click  and select **Resource query**.
1. Select the resource you created for the mock API.

When you select an API resource, the code editor contains a set of inputs for you to write an API request. APIs commonly use different endpoints based on the type of data used. You don't need to specify an endpoint to get customer data from the mock API. Since API queries default to using a **GET** request, no further configuration is needed. Click **Save & Run** to save the query and perform the API request. 

The query results appear below the code editor. The mock API returns a list of customer data that you will use to populate the mobile app's UI in the next step.

Before continuing, delete the demo queries that were included when you created the app. Right-click on each query and then select **Delete**.

export function GetCustomers() {
  return (
    
      
    
  )
}

## 5. Display a list of customers

The [List Collection](./reference/components/patterns/list-collection.mdx) mobile component presents data using a list layout. You can use List Collection to display customer data without needing to build any type of repeatable layout.

Switch to the **customers** screen and then navigate to the Component tree tab. Click  and then select the **List Collection** component. 

Retool [automatically maps the most recently run query's data](guides/forms-inputs/option-lists.mdx) to the component and populates values based on common usage (e.g., using `item.email` for an email address). Update the List Collection component's settings in the Inspector to the following:

| Setting | Value | Description |
| --- | --- | --- |
| Title | `{{ item.first }} {{ item.last }}` | Use the customer's name for the list item title. |
| Body | `{{ item.email }}` | Use the customer's email address for the list item body. |
| Media type | **None** | Since the customer data has no images, disable the list item image. |
| Action type | **Label and icon** | Display an optional label and icon on the right-side of the list item. |
| Label | Empty | Clear the label text to remove it. |

## 6. Add a customer search field

You can add a text input field that dynamically filters the list of customers, making it easier to find what you're looking for. The [Search Bar](./reference/components/forms/search-bar.mdx) mobile component is a preset of the Text Input mobile component, which is preconfigured with a search icon already. 

Add a **Search Bar** mobile component to the customers screen, then change its **Label** to `Search` from the Inspector.

Mobile components are arranged vertically by default. When you add the Search Bar component, it appears below the List Collection component. In the Component tree tab, click and drag the Search Bar component to position it above List Collection.

export function DisplayCustomers() {
  return (
    
      
    
  )
}

## 7. Filter the list of customers

To use the input value of Search Bar to search customers, you can use either client-side or server-side filtering. For the purposes of this tutorial, the app uses client-side filtering.

With client-side filtering, all necessary data is retrieved first and then filtering occurs within the app. You should use client-side filtering if:

- There is only a limited amount of data.
- The resource does support server-side filtering of data.

With server-side filtering, the query uses the filter value when making the request. The resource then returns only matching data. You should use server-side filtering if:

- There is a large amount of data.
- The resource supports server-side filtering of data. 

You can use `{{ }}` embedded expressions to write JavaScript almost anywhere in Retool. The mock API supports filtering with the `filter` URL query string, and you can reference the value of Search Bar directly in the query.

### Filter with a transformer

You can use a transformer to perform client-side filtering of query results. Transformers dynamically update whenever there is a change to reference values. 

To create a transformer:

1. Navigate to the Code tab.
2. Click  and select **Transformer**.

Next, write a JavaScript statement that filters the results based on the value of Search Bar using the `filter()` JavaScript method.

```js title="filterCustomers"
// Reference the customer data from the query
const data = {{  getCustomers.data }}

function filterCustomers(searchString) {
  // Search customers based on first + last names
  const filteredData = data.filter(customer => {
  // Combine the first and last names into a single, lowercase string
  const fullName = `${customer.first} ${customer.last}`.toLowerCase();
  return fullName.includes(searchString.toLowerCase());
});
// Return the results
return filteredData;
}

// use the filterCustomers function with the value of the Search Bar component
return filterCustomers({{ searchBar1.value }});
```

To use the transformer results, update the **Data source** of the List Collection component to use `filterCustomers`.

export function Transformer() {
  return (
    
      
    
  )
}

## 7. Select a customer and view details

This mobile app will allow users to view customer details. When a user selects a customer, the app navigates to the **Customer details** screen which will display customer information.

### Navigate to another screen

First, configure the app to show the **customerDetails** screen when selecting a customer. Retool uses [event handlers](guides/interaction-navigation/event-handlers.mdx) to trigger queries or other actions in response to user events, such as selecting a product.

Select `collectionView1` within the **customers** screen and add an event handler from the **Interaction** settings of the Inspector. Configure the event handler with the following settings:

| Setting    | Value            | Description                                                   |
| ---------- | ---------------- | ------------------------------------------------------------- |
| **Event**  | **Press**        | Trigger the specified action when the user selects a customer. |
| **Action** | **Navigation**   | Perform the specified navigation.                             |
| **Method** | **Navigate to screen**   | Navigate to the **customerDetails** screen.              |
| **Screen** | **customerDetails** | The screen that appears when the user selects a customer.      |

Click on a customer to test the event handler. The **customerDetails** screen doesn't contain any components and is currently empty. 

export function EventHandler() {
  return (
    
      
    
  )
}

### Store the selected customer data

Code and components are screen-scoped or globally scoped. Since the `getCustomers` query is scoped to the `customerDetails` screen, its cannot be referenced elsewhere. You use [variables](../queries/guides/store-temporary-data.mdx) that are globally scoped to tempoarily store data and make it available in other screens.

1. Navigate to the Code tab.
1. In the **Global** section, click  and select **Variable**.
1. Rename the variable to `selectedCustomer`. 

The List Collection component's `selectedItem` contains the data of a selected item, which is available at `{{ item }}` when configuring an event handler. Create another event handler to store this data in a variable.

| Setting    | Value            | Description                                                   |
| ---------- | ---------------- | ------------------------------------------------------------- |
| **Event**  | **Press**        | Trigger the specified action when the user selects a customer. |
| **Action** | **Set variable**   | Perform the specified navigation.                             |
| **State** | **selectedCustomer**   | The variable in which to store data.              |
| **Method** | **Set value** | Set a variable value when the event handler runs.      |
| **Value** | `{{ item }}` | The selected item. |

When you select a customer, the app loads the `customerDetails` screen.

export function GlobalVar() {
  return (
    
      
    
  )
}

### View selected customer data

`selectedCustomer.value` is an object with the selected customer data. To view this data:

1. Add a [Key Value](./reference/components/patterns/key-value.mdx) mobile component to the `customerDetails` screen.
1. In the Inspector, set **Data** to `{{ selectedCustomer.value }}` and **Header** to `{{ selectedCustomer.value.first }} {{ selectedCustomer.value.last }}`.

The selected customer data appears in the Key Value component automatically. Its header also displays the customer's name.

export function SelectedCustomer() {
  return (
    
      
    
  )
}

## 8. Update the customer's email address

Now that the app displays selected customer information, the next step is to make changes and save them back to the resource. For the purposes of this tutorial, the app enables you to modify the customer's email address.

1. Add a **Text Input** component to the `customerDetails` screen.
1. Set the **Default value** of the component to `{{ selectedCustomer.email }}` from the Inspector.

### Add a query to update the email address

The Text Input component automatically displays the email address of the selected customer. You add another resource query to save changes, similar to the query that retrieves customer data.

1. Add a **Resource query** to the `customerDetails` screen. This must be screen-scoped as globally scoped queries cannot reference any data from a page. 
1. Select the mock API resource.
1. Rename the query to `updateCustomer`. 

APIs commonly use `PATCH` or `PUT` methods to modify existing data. These request methods require the object's identifier (ID). This is also stored in `selectedCustomer`. Update the query with the following configuration:

| Setting | Value | Description |
| --- | --- | --- |
| Action | **PATCH** | Use the **PATCH** method to modify an existing object. |
| URL | `{{ selectedCustomer.value.id }}`. | This updates the API endpoint to use the customer ID (e.g., `https://example.com/customers/1`) that determines which object to update. |
| Body (key) | `email` | The property to update. |
| Body (value) | `{{ textInput1.value }}` | The value with which to update. |

Queries also support event handlers. Once a customer email address is updated, the app should return to the `customers` screen. Add an event handler with the following configuration:

| Setting    | Value            | Description                                                   |
| ---------- | ---------------- | ------------------------------------------------------------- |
| **Event**  | **Success**        | Trigger the specified action when the query successfully runs. |
| **Action** | **Navigation**   | Perform the specified navigation.                             |
| **Method** | **Back**   | Navigate back to the previous screen.              |

When the event handler runs, the app returns to the `customers` screen. The `getCustomers` query automatically refreshes so the customer list reflects the changes.

### Add a button to save changes

The final step is to add a button that saves the changes. 

1. Add a Button component to the `customerDetails` page.
1. Configure it with an event handler that uses the **Control query** action and select the `updateCustomer` query.

After you update email address and press the button to save changes, the following sequence occurs:

1. The `updateCustomer` query runs and updates the email address with `textInput1.value`.
1. After the query successfully runs, it triggers an event handler to navigate back to the `customers` screen.
1. Navigating back to the `customers` screen automatically triggers the `getCustomers` query, updating the customer data in the app.

export function EditDetails() {
  return (
    
      
    
  )
}

## Test your mobile app

Now that your app is complete, it's time to test it on your mobile device. Click **Go to app** in the top right to open the mobile app as a progressive web app (PWA). Scan the QR code with your iOS or Android device to launch it in the Retool Mobile app. You use this app to browse and launch any of the mobile apps you build.

If you don't have the app installed already, your device is automatically routed to the [iOS App Store](https://apps.apple.com/us/app/retool-mobile/id1586183808) or [Google Play](https://play.google.com/store/apps/details?id=com.retool.retool).

## Wrap up

You've now successfully built a mobile app that retrieves customer data and presents it in a list layout, and enables you to select a product and update its name.

---

## Branding

You can use branding to customize headers, sign up and login pages, email invites to users, the Retool user menu, and more. Navigate to your organization's [Branding](https://login.retool.com/auth/login?source=docs&redirectOnLogin=settings/branding) to configure.

To switch to a different page or email, use the dropdown menu on the right.

When customizing emails, to remove all references to Retool, you must enter a **From name** and a **Reply-to address**.

If you would like to provide support directly to your end-users, you can use the [custom Intercom support feature](../guides/external/intercom-messenger.mdx). This allows you to bring your own Intercom Messenger client to Retool.

Once set, branding is visible to anyone using your organization's apps in user mode.

:::note

You must be on the Enterprise plan to hide the Retool user menu. [Book a demo](https://retool.com/demo/?meeting_page_source=docs) to learn more about Enterprise functionality.

:::

---

## External users

Once you [enable external apps](../../apps/guides/app-management/external-apps/index.mdx), any authenticated user outside your organization is classified as an external user. All external users are added to a permission group, which enables you to control what apps they can access.

Common external users include customers, vendors, or partners. External users can only access [external apps](../../apps/concepts/share-externally/external.mdx) or [public](../../apps/guides/app-management/share.mdx#share-web-apps-with-users) links.

## Permission groups

Define internal users by email domain using the **External Apps** settings of your organization. Any user with an email that does not include this domain is categorized as an external user and added to the **External Users** [permission group](../../permissions/guides/configure-permission-groups.mdx). You can also create other permission groups and manage group membership to control the level of access external users have.

:::note

Prior to version 3.259.0, Retool's permissioning structure automatically granted the **All Users** group **Use all** access, which overrode any permission controls you set for the **External Users** group. Retool recommends [removing all access](../../permissions/guides/configure-permission-groups.mdx#configure-access-rules-for-a-permission-group) (**Edit**, **Use**, **Own**) from the **All Users** group and using the **External Users** group as the primary permission group.

For organizations created after version 3.259.0, the **All Users** group does not have universal access permissions by default. [Read more in the changelog entry](/changelog/updated-permissions-for-all-users).

:::

## Pricing

import External from '../_partials/_external-billing.mdx';

---

## Governance in Retool

Retool offers a powerful set of governance features that enable organizations to control, secure, and efficiently manage apps, workflows, and access to data. This guide explains ways to build a strong governance model in Retool, organized around the three levels of access management in Retool:

1. **Organizational access**: who is allowed to use Retool, and who is not?
2. **Project access**: within an organization, which Retool apps or workflows is a user allowed to use?
3. **Data access**: within a project, what data is a user allowed to view and update?

## Organizational access

Organizational access refers to how users in your company gain access to Retool. While an access approval process might happen outside of Retool (e.g., users request access in your company's ticketing system), Retool provides several ways to facilitate this access.

### Integrate with your identity provider

You can set up login, map groups, and provision users by integrating Retool with a [supported identity provider](../../sso/index.mdx) (IdP). Retool supports Google LDAP, and identity providers that support OpenID and SAML authorization protocols.

### User provisioning

Users can be provisioned into Retool directly through SSO, invitation, and access requests. Refer to the [user management](../tutorials/manage.mdx) tutorial.

If you want users to automatically be provisioned Retool accounts when visiting Retool's login page, you can set up [just-in-time provisioning](../../sso/guides/jit-provisioning.mdx). If the user exists in your identity provider but not yet in Retool, Retool automatically creates a user account and grants them organizational access. To make sure their access is scoped to the right project, you can map groups and roles directly to the custom groups you set up in Retool. See [Role-based access controls](#role-based-access-controls) for more.

### Spaces

Large organizations have many different teams and use cases that often operate independently. You can set up [Spaces](../tutorials/spaces.mdx) to enable isolation of teams and development workflows, without needing to create a separate Retool account if you're on cloud or spin up separate Retool instances if you're self-hosting.

In some cases, it may make sense to deploy several instances in separate VPCs to ensure network isolation between development and production instances. See [scale your Retool organization](scale-organization.mdx) for more.

### Programmatic management

Organizations on the Enterprise plan can programmatically create Spaces, set organizational settings, and configure SSO through the [Retool API](../../api/index.mdx). This allows you hook into your existing systems and centralize governance across your different teams using Retool.

## Project access

Project access refers to managing users' access to the different use cases–groups of apps, workflows, queries–you're using Retool for. For example, a project could be a suite of Retool apps built to allow your Support team to more easily work with data and update customer information. These are often organized in several folders in a given Retool organization or Space.

### Role-based access controls

Retool's role-based access controls let you manage access to Retool apps, folders, Workflows, resources, queries, and more. You can create multiple custom permission groups, assign access levels to Retool apps, and delegate [Group Admin](../../../permissions/guides/configure-permission-groups#custom-permission-groups) responsibility to users for them to manage group membership.

Users who do not have access to Retool apps cannot see them in the application listing.

[Learn more](../../permissions/quickstart.mdx#access-rules) about role-based access controls.

### Direct access sharing

Sometimes, it may be too much overhead for an admin to create a permission group to facilitate one-off access to Retool apps. When enabled, [direct access sharing](../../permissions/guides/app-permissions/share-apps.mdx) lets users with **Own** access to an app manage its permissions. You can audit access to an app and learn how access is granted—directly or from permission groups—from an app's access list in the application listing.

## Data access

Data access concerns a user's ability to see or edit sensitive data within Retool apps. In Retool, restricting access to apps displaying or working with sensitive data implicitly means restricting access to the data itself. Retool has controls to make sure editors and viewers can only see data they're allowed to see.

### Resource environments

Resource environments allow admins to configure resources that point to sensitive and nonsensitive data. Retool also supports setting permission groups' access levels to resource environments, which ensures that only certain groups can operate on production data.

[Learn more](../guides/configuration/environments.mdx) about resource environments.

### User attributes

Often, information about Retool users exists in systems outside of Retool, but is necessary to determine the data a user is allowed to access. User attributes allow you to set arbitrary metadata on the Retool user.

You can [reference user attributes](../guides/user-management/user-attributes.mdx) in Retool apps through JavaScript: you can hide and show data and app elements, as well as control custom behavior. You can also use them in queries, which makes it straightforward to set up [row-level security](../../queries/concepts/row-level-security.mdx) in Retool.

### Queries

To ensure users can only see data that is relevant to them, use [query spoofing prevention](../../queries/quickstart.mdx#query-variable-spoofing-prevention). This ensures that any query referencing attributes on the current user cannot be modified to return other data.

### Best practices

Many companies maintain access control services (in the form of APIs) that determine what data a user is allowed to see. Often these services rely on a user token sent from an identity provider upon login.

If you have OpenID SSO integrated with Retool, you can pass the JWT obtained from the login as a header to each request for this service. This ensures the Retool user is always authorized to make such requests, and your service would contain the necessary backend logic to determine what data to return to Retool.

If you don’t have OpenID SSO set up but have a separate authorization server, you can also define a [custom authentication workflow](../../data-sources/guides/authentication/custom.mdx#1-create-a-rest-api-resource). This lets your backend authenticate a user into your API.

## App development and release process

Retool also provides controls to manage app development, reviews, and releases to users.

### Source Control

[Source Control](../../source-control/index.mdx) allows organizations to manage changes to their Retool apps using pull requests on remote source control management (SCM) providers, such as GitHub and GitLab. Instead of making changes directly to an application, changes are made on a separate branch.

Protected apps are not modified until changes are reviewed and merged in the source control provider (e.g., in GitHub). This workflow mirrors a typical software development lifecycle, in which no engineer can push code directly to the `main` branch.

Source Control enables users to sync apps across multiple Retool instances and Spaces. If you have VPC isolation between non-production and production instances, a common approach is to configure your production instance of Retool as read-only, pulling changes from a central repository. Development happens on branches in a development instance, and once changes are reviewed through pull requests and app preview branches, code is merged into the main branch.

### Releases

[Releases](../../apps/guides/app-management/releases-history.mdx) let you version and release app changes to your users. This method can also be used in conjunction with Source Control. Once a branch is merged into production, you can review it on production data before rolling out changes to users using versioned release.

### Audit logs

On a Business or an Enterprise plan, Retool provides [audit logs](../guides/monitoring/audit-logs.mdx) for user actions that happen in Retool. If you're self-hosting Retool, you have access to the underlying PostgreSQL database on which your Retool instance runs. You can [connect it as a resource](../guides/monitoring/audit-logs.mdx#access-audit-logs-in-sql-or-stdout) and build your own Retool app to display custom views of your audit logs.

Additionally, you can send audit log events from Retool to DataDog. See our [guide](../guides/monitoring/audit-logs.mdx) for more details.
In self-hosted Retool, all audit logs stream to `stdout`, so you can set up an external service or sidecar that consumes them.

### Usage analytics

If you're on the Enterprise plan, [Usage Analytics](../guides/monitoring/usage-analytics.mdx) allows you to understand adoption across your organization at scale. By default for self-hosted Retool, usage is aggregated across all instances using the same license key. Similarly, if you have multiple Spaces set up on an instance, you can view usage across all Spaces.

---

## Internationalization

Retool supports internationalization (i18n), allowing you to adapt Retool app content and data for users across different languages and regions. This guide covers how to add translations to your Retool org and use Retool's out-of-the-box i18n functionality in your apps.

## Upload translations

Navigate to **Settings > Internationalization** to upload and manage your translations.

### File structure and naming convention

Your translation files should be structured as flat JSON objects and follow a consistent naming convention across different locales.

Below is an example of what your filesystem might look like. Each locale's directory (e.g., `en`, `es`, `fr`, `kr`) should contain the translation files with the same filenames (`common.json`, `customer_settings.json`). Make sure each file contains the same set of keys.

```
├── en
│   ├── common.json
│   └── customer_settings.json
├── es
│   ├── common.json
│   └── customer_settings.json
├── fr
│   ├── common.json
│   └── customer_settings.json
└── kr
    ├── common.json
    └── customer_settings.json
```

Here are example files for `common.json`, uploaded separately into Retool for the English (en) and Spanish (es) languages.

```json title="/en/common.json"
{
    "add_card_receipts": "add card receipts",
    "add_filter": "add filter",
    "amount": "amount",
    "budget": "budget",
    "date": "date"
    ...
}
```

```json title="/es/common.json"
{
    "add_card_receipts": "agregar recibos de tarjeta",
    "add_filter": "agregar filtro",
    "amount": "cantidad",
    "budget": "presupuesto",
    "date": "fecha"
    ...
}
```

### Upload translation files

Retool supports the most common ISO language codes, conforming to the ISO 639-1 standard, and includes country codes. Select your language and country code and upload your flat JSON file.

Files uploaded for locales without a country code specified will automatically be used as a fallback. For example, if a file is uploaded for `French (fr)`, translations will still work for users in France and Canada. If `French (fr-FR)` is also uploaded, then Retool will default to `French (fr-FR)` for users in France and `French (fr)` for users in Canada.

## Source Control

Retool supports the ability to sync translations across multiple spaces or instances by integrating with [source control](../../source-control/index.mdx). To get started:

1. Create a folder named `translations` at the root of your repository.
2. Inside this folder, use the same [file structure and naming conventions](#file-structure-and-naming-convention) that you use when uploading translation files directly to Retool.
3. All translation files in the `translations` folder are be automatically synced to Retool instances that are linked to the same source control repository.

## Localize your Retool apps

To localize your applications and format text, dates, and currencies, follow the [localization guide](../../apps/guides/app-management/localization.mdx). Retool provides default translations for strings in components in several languages.

---

## Provisioning and licensing

When you sign an annual agreement for the Enterprise plan on Retool, our team will assist with provisioning your purchased products and services. This depends on whether you use a cloud-hosted or self-hosted deployment.

## Cloud-hosted

For customers hosted in our multi-tenant Cloud instance, you will sign up for a new instance of Retool or utilize an existing instance of Retool on a self-service plan. Your Retool Account Executive will provision that instance of Retool with the required permissions to enable Enterprise plan features.

## Cloud-hosted and Retool-managed

For customers where Retool is managing your deployment inside of your own dedicated single-tenant infrastructure, Retool will manage all aspects of the licensing and provisioning process. Our infrastructure team will reach out to you with access instructions once your instance is deployed.

## Self-hosted

For customers who elect to self-host Retool in their own instance, your Account Executive will provide you with a unique license key via email that you will provide inside an environment variable for each deployment. This license key will expire at the conclusion of your Retool agreement’s service term, but the expiration date will be extended as and when your Retool agreement renews.

---

## Scale

This guide provides administrative best practices to scale your Retool use across your organization.

## Prerequisites

Before you begin, read about [governance in Retool](governance.mdx) and how to put the right controls in place to allow new teams to efficiently and safely use Retool. If you're self-hosting Retool, you should also understand Retool's [deployment model](../../self-hosted/guides/scale-retool-infra.mdx) and how it can be scaled to support new use cases in Retool.

## Set up a hub and spoke model

The hub and spoke model is an organizational model that can set up your teams to implement and scale Retool effectively. Under this model, a centralized group of platform administrators manage Retool and:

- Configure organizational setup like [Spaces](../tutorials/spaces.mdx), [SSO](../../sso/index.mdx) and [Source Control](../../source-control/index.mdx)
- Delegate permissions and oversee organizational access
- Perform maintenance and upgrades
- Help onboard new teams and provide best practices for using Retool

After deploying Retool, the _hub_ is responsible for making sure that the _spokes_ can build and use apps efficiently. Setting up the Hub requires identifying key stakeholders to manage Retool at the infrastructure and application level. To ensure smooth onboarding at scale, it's best to define your processes upfront.

### Identify your Retool platform owners

Delegate ownership of Retool to those who can oversee the specific needs and requirements of each team. Platform owners are usually responsible for defining access processes, and centralizing information to help new teams get to value quickly.

### Identify your infrastructure owners

If you're self-hosting Retool or connecting to sensitive data, appoint infrastructure owners who understand the technical aspects of Retool, including deployment, maintenance, and scalability.

### Define your governance model

Establish a clear [governance model](governance.mdx) that outlines rules, policies, and procedures for Retool development and usage. This includes:

- Developing knowledge of various use cases for Retool
- Reviewing the data sources connected to Retool, and their level of sensitivity
- Users groups who will be building and using Retool Apps and Workflows
- How new users and teams will onboard onto Retool
- Auditing, observability, and usage tracking features

#### Integrate with your identity provider

We recommend integrating Retool with an existing identity provider if you need to provision and manage many groups of stakeholders. With [just-in-time (JIT) user provisioning](../../sso/guides/jit-provisioning.mdx) enabled, users who exist in your identity provider are automatically provisioned Retool accounts upon signing into Retool.

As new teams and user groups are added, you can configure role-mapping between your identity provider and Retool as needed. New team members are automatically provisioned with Retool accounts (via [SCIM](../../sso/guides/scim-user-provisioning.mdx) or [Group Push](../../sso/guides/scim-user-provisioning.mdx#enable-group-push)), streamlining the onboarding process.

## Set up automations

Use the [Retool API](../guides/retool-api/index.mdx) to automate the creation and provisioning of new users, permission groups, and Spaces for new use cases.

## Define your development process

At scale and in production, having the right Retool app development process helps ensure a stable product for users. [Source Control](../../source-control/index.mdx) and [Releases](../../apps/guides/app-management/releases-history.mdx) are two key features to enforce a development lifecycle that scales across your company.

If you're using [Spaces](../tutorials/spaces.mdx), multiple teams can each have separate development workflows between development and production instances. See [Spaces and multiple instances](#spaces-and-multiple-instances) below.

### Set up Source Control

[Source Control](../../source-control/index.mdx) allows organizations to manage changes to their Retool applications using pull requests on remote source control management (SCM) providers, such as GitHub and GitLab. Instead of making changes directly to an application, changes are made on a separate branch.

Source Control enables users to sync applications across multiple instances of Retool. A common approach is to have staging and production instances of Retool be configured as read-only, pulling changes from the staging and main branches. All development happens via branches in a development instance and code is merged into the main branch. See our [recommended workflow](../../source-control/quickstart.mdx) for using Source Control in Retool.

### Reviews and ownership

Using the hub-and-spoke model, the hub typically configures a standard Source Control setup across Retool instances, as well as the Spaces within them.

With Spaces, you can copy Source Control setup from your admin Space to a child space, making it easy to standardize development across teams. If teams have their own flows, you can also delegate administrative privileges to other users within a Space, and they can set up Source Control for their Spaces as well.

When the hub has configured the required access controls and permissions, it should not be heavily involved in the day-to-day development of apps, but may coordinate releases to production.

### Versions and Releases

[Releases](../../apps/guides/app-management/releases-history.mdx) lets you version and release app changes to your users. This method can also be used in conjunction with Source Control.

Although you can configure your application to use the `main` branch, you may still not want it to update every time the branch is updated. In these cases, you can create versioned releases and control when updates are available to your users.

### Codify onboarding and best practices

As you're setting up Retool, it's important that teams can quickly onboard onto Retool and deliver value for users. It's useful to create an organization-specific onboarding guide on the following topics:

- Overview of the organizational structure of teams who own and build in Retool
- How to identify a Retool use case
- How to obtain a Retool account
- How to obtain access to resources for your use case (APIs, databases, and permissions)
- Useful resources and documentation on development (pointing to Retool documentation)
- Application promotion and release process
- How to help onboard operations teams
- How to build Retool apps (e.g., video of using the App editor to build a new app)

You can use the [technical onboarding template](https://docs.google.com/document/d/1YDzNbT4mCAniA2NLOJTFkeGluhZ4Gdxxt8ZNp0YXXBY/edit?usp=sharing) to get started.

### Reuse groups of components with modules

You can use [modules](../../apps/guides/layout-structure/modules.mdx) to share groups of components across Retool apps. This encourages code reuse and delivers a more consistent end-user experience across your apps. Changes to a module are immediately reflected across all apps in which it is used. Modules also let you specify [inputs](../../apps/guides/layout-structure/modules.mdx#add-inputs) and [outputs](../../apps/guides/layout-structure/modules.mdx#add-outputs), allowing you to centralize and reuse logic across different use cases.

### Reuse queries

The [Query Library](../../queries/concepts/query-library.mdx) enables you do create and reuse queries in the same way as modules function to reuse components. You can write, share, and control access to queries from the Query Library, which is important if you have many apps leveraging the same data source.

Any queries in individual apps should be moved into the Query Library if you find the same queries being written across apps. Queries within the Query Library also have permissions, so if you have complex or sensitive queries and want a specific team to own them, you can manage access through your organization settings.

### Customize style with themes

You can create themes with custom color palettes that can be quickly applied to apps. [Themes](../../apps/guides/presentation-styling/themes.mdx) provide a way for builders to build apps that match their organization's existing brand guidelines.

## Scale Retool to new use cases

Because Retool can be applied to solve a broad range of use cases, when a new use case comes up, it's important to understand its nature: what data these apps or workflows are accessing, isolation considerations, and change management processes.

Depending on the above, you can choose a combination of deploying a new Retool instance, Spaces, and permission groups to ensure teams are onboarded quickly with the right processes in place.

### When to deploy a new Retool instance

If you're self-hosting Retool for data security or compliance reasons, you are likely running a [multi-instance deployment](../../self-hosted/concepts/multi-instance-deployment.mdx) with at least two instances, one representing a production and the other a non-production instance. If a new use case requires additional VPC isolation between production user groups due to sensitive data or isolated user pools, it's recommended you deploy an additional production instance.

You can set up [Source Control](../../source-control/index.mdx) to automatically sync and promote changes between instances and enable a Git-based review process for your application changes, as outlined above.

#### Spaces and multiple instances

:::warning

To use Spaces with Source Control, ensure you [migrate your apps to Toolscript](/changelog/yaml-serialization-deprecation).

:::

[Spaces](../tutorials/spaces.mdx) drastically reduces the administrative overhead of onboarding new, isolated groups of users. You won’t need to spin up additional instances to ensure full separation of apps, resources, and users. If you are using Spaces and Source Control, you can use the following approach:

1. **Create two additional child Spaces**. Create one on your new production instance, and another on your existing development instance. This keeps your development instance neat with no additional overhead.
2. **Connect Spaces to the same Git repository**. Copy settings through the UI or use the [Retool API](../guides/retool-api/automate-spaces.mdx) to programmatically configure Source Control on each Space.

### When to create a Space

Spaces provide access and isolation guarantees at the organizational level, while permission groups help you control project access. Spaces makes sense when the benefit of isolated development workflows and user groups outweighs the benefit of sharing.

For example, you might develop apps and workflows specific to your Sales organization to track account health, usage, and forecasted pipeline. These apps and workflows might be built on top of [Salesforce](../../queries/tutorials/examples/salesforce.mdx) and a data warehouse resource (e.g., [Databricks](../../data-sources/guides/integrations/analytics/databricks.mdx), [Snowflake](../../data-sources/guides/integrations/analytics/databricks.mdx), or [BigQuery](../../data-sources/guides/integrations/database/bigquery.mdx)). If your DevOps team has a new Retool use case and wants to build apps to manage their deployment configuration on top of RDS using AWS APIs, it makes sense to create a new Space for them. This lets them build, deploy, and use Retool apps while managing users in a completely isolated setting. Assuming the organizations can use the same Retool instance, you would create Spaces on the same instance: **sales.retool.mycorp.com** and **devops.retool.mycorp.com**.

In this context, a Retool platform owner could delegate administrative responsibility to admins of each respective Space, while reusing the same SSO configuration. Because resources, queries, and even development processes are so separate between teams, there is little benefit to keeping these two organizations within the same Space.

:::note

You can automate Space creation and configuration using the [Retool API](../guides/retool-api/automate-spaces.mdx).

:::

### When to use permission groups

In the above example, the Retool apps in **sales.retool.mycorp.com** could be used across Account Executives, Sales Operations, Sales Managers, and the leadership team. Depending on the size of the organization, certain teams and users within the Sales org could require privileged access to certain apps. In this case, creating permission groups per team is the recommended approach.

Keeping Sales-related use cases in the Sales Space allows you to more quickly build new applications:

- Resources, applications, and modules are already configured
- Teams have organizational context on which apps and queries are useful
- The development workflow is defined

Additionally, new users are more likely to find the applications that are relevant to them as they are provisioned into the Sales Space.

---

## Administration concept guides

import Concept from '/docs/_partials/_doctypes/_concept.mdx';

---

## Archive Retool Cloud users or organizations

Users on Retool Cloud organizations can archive their own accounts. Administrators can archive an organization, which also archives all users who belong to it. Archiving isn't supported for self-hosted deployments.

## Archive your user account

Archiving your user account disables your access to the Retool organization. You may want to archive your user account if you need to join a different Retool organization and want to use the same email address.

Administrators cannot archive individual users as this action must be performed by logging in as the user. To disable access for an individual user, administrators can [disable](../../tutorials/manage#disable-users) the account instead.

To archive your user account:

1. Navigate to the [Settings](https://login.retool.com/auth/login?source=docs&redirectOnLogin=settings) page.
2. Select **Account** in the sidebar.
3. Click **Archive account** at the bottom of the page.
4. Click **Archive account** on the confirmation modal.

You cannot archive your user account if you are the sole administrator of an organization. You must either promote another user to the **Admin** permissions group or archive the entire organization.

## Archive an organization

You must have **Admin** permissions to archive your organization. When you archive an organization, Retool also:

- Archives all users, which disables access for all users immediately.
- Disables active workflows and public apps.

If the organization is on a paid plan with a monthly subscription, archiving the organization cancels the subscription. If the organization is on an annual plan, archiving [does not result in a prorated refund](/support/billing-usage#annual-billing). Organizations with auto-join email domains configured will no longer be joinable by users with the listed email domains.

To archive an organization:

1. Navigate to the [Settings](https://login.retool.com/auth/login?source=docs&redirectOnLogin=settings) page.
2. Click **Advanced** in the sidebar.
3. Scroll to the bottom of the page and click **Archive organization**.
4. Click **Archive organization** on the confirmation modal.

---

## Change Retool Cloud subdomain

Retool Cloud admins can change an organization's subdomain at `retool.com` at any time. Performing this action permanently changes the URL of your organization (e.g., `acme.retool.com` -> `acme2.retool.com`).

:::warning Considerations when changing subdomain

Subdomain changes are permanent. Keep in mind the following considerations as you decide whether to make this change:

- **All organization URLs will change**. Any external references to your organization, such as bookmarks, must be updated to use the new subdomain. Any links that contain the previous subdomain will no longer work.
- **Previous subdomain will be released**. Once a subdomain is changed, the previous one is made available for other organizations to use.

:::

To change your subdomain, navigate to your organization's [Advanced](https://login.retool.com/auth/login?source=docs&redirectOnLogin=settings/advanced) settings. Specify the new subdomain to use and click **Save**. If the subdomain is not available, Retool suggests some alternatives. You can also enter another subdomain to check if it's available. 

Once the change is made, you are logged out and must log in again.

---

## Configure a custom domain for Retool Cloud

You can configure your Retool Cloud organization to use a custom domain. This enables your users to more easily navigate and improves the [embedded app](#using-retool-embed) across browsers.

## 1. Configure DNS

DNS configuration needs to be completed with the tooling you use to manage your top level domain name. This is often the registrar where you registered the domain, or a DNS provider such as Cloudflare or AWS.

Create a `CNAME` record mapping either the top level domain or subdomain to Retool’s alias for custom domains:

- `custom-domain.retool.com`

Retool recommends against using wildcard `*` DNS entries for your configuration as these can expose you to domain takeovers.

DNS changes can take up to 24 hours to propagate in some cases. To validate that your DNS is configured and propagated, you can use the `dig` command on the command line:

```
$ dig retool.example.com CNAME +noall +answer

; > DiG 9.10.6 > retool.example.com CNAME +noall +answer
;; global options: +cmd
retool.example.com. 120 IN CNAME custom-domain.retool.com.
```

## 2. Configure Retool

Navigate to `/settings/branding` in your organization's Retool settings. Under **Add a custom domain**, enter the domain name in the text box.

The domain briefly enters a pending state while Retool provisions HTTPS certificates and updates internal infrastructure to support the new domain. An error state likely indicates that the DNS wasn't updated to point to Retool. If this occurs, verify that your DNS is updated and that `dig` shows the correct IP addresses, and then retry verification.

## 3. Log in

The domain should be configured after a few minutes. Sign out of your organization and back in through your custom domain to confirm. Your new login page should be visible on `/auth/login`.

Note that you can still log in through `.retool.com/auth/login` as well as `/auth/login`.

:::info

The Sign in with Google option is not available by default when accessing the login page using your custom domain. You must configure [Google SSO](../../../sso/tutorials/google/google-sign-in.mdx) for your custom domain to make it available. Users can still log in using Sign in with Google at `.retool.com/auth/login` or `login.retool.com/auth/login` until you make this change.

:::

## Using Retool Embed

To [embed Retool apps](../../../apps/guides/app-management/embed-apps.mdx) from your Retool-hosted organization into a website like `https://example.com`, ensure that Retool is on the root `example.com` domain or a subdomain like `retool.example.com`. Because Retool is the hosting provider, you need to make some changes to your DNS configuration.

:::note

Some web browsers, like Safari, block third party cookies by default. Since Retool sets cookies when authenticating users, attempting to authenticate the embedded Retool app across domains is not possible in these browsers, unless you change your browser's cookie privacy settings.

:::

---

## Manage configuration variables

You can specify configuration variables for reference in resource configurations, apps, and workflows. Configuration variables are specific to resource environments and can be either values or secrets.

Retool encrypts configuration variables on Retool Cloud or, if you self-host Retool, in your deployment's PostgreSQL storage database.

## Requirements

Configuration variables are available on Retool Cloud and self-hosted Retool versions 3.4.0 and later for organizations on a Business or an Enterprise plan. Configuration variables in workflows are currently available on Retool Cloud.

You must be an admin to create and edit configuration variables. Configuration variable values and secrets availability depends on usage. Only users with **Edit** permissions for a relevant area (e.g., resources) can use configuration variables.

| Name      |                Values                |                Secrets                | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| --------- | :----------------------------------: | :-----------------------------------: | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Resources |  |   | Configuring resources in Retool can require handling sensitive values, e.g. database passwords or API keys. Retool is [SOC 2 Type 2 compliant](https://docs.retool.com/page/security), and most customers store these values with Retool. Configuration variables allow you to centralize and control access to these values. If you have specific security requirements that require you to store secret values externally, rather than encrypted in Retool’s database, consider integrating Retool with a Secrets Manager. |
| Apps      |  |  | Secret configuration variables are not available in apps and queries. You cannot use configuration variable values in [public or external](../../../apps/guides/app-management/embed-apps.mdx) apps.                                                                                                                                                                                                                                                                                                            |
| Workflows |  |   | As you build a workflow, Retool sanitizes secret configuration variables in block responses when running individual blocks. Secret values can only be passed to subsequent blocks when the workflow is run in its entirety, either by clicking **Run workflow** in the workflow IDE or when the workflow is triggered.                                                                                                                                                                                                       |
## Create configuration variables

To create a configuration variable, go to **Settings** > **Configuration variables**.

Configuration variables have resource environment-specific values. For example, if you create a `db_password` configuration variable, you may need to specify different values depending on the resource environment (e.g., production or staging).

### Secret configuration variables

To create a secret, toggle **Mark variable as secret** when creating a configuration variable. Secret configuration variables are available for use only in resource configurations and workflows, and their values are never exposed on the frontend. Use secrets if you need to store sensitive information, such as security credentials.

## Use configuration variables

You can use autocomplete to access configuration variables in the resource editor, app IDE, and workflow IDE. Retool uses the appropriate value depending on the current resource environment.

Reference configuration variables in resource configurations using the following syntax.

```
{{ environment.variables.YOUR_VAR_NAME }}
```

In apps, workflows, and queries:

```
{{ retoolContext.configVars.YOUR_VAR_NAME }}
```

:::info

Configuration variables are cached so it may take up to five minutes for your changes to take effect.

:::

## Configuration variables with multi-instance deployments

Config vars are recommended for use with [Protected Resources](../../../source-control/guides/protect/resources.mdx). When protecting a resource, only the template value (`{{ environment.variables.your_name }}`) is stored in Source Control. You must define your configuration variables on each instance.

## Configuration variables, environment variables, and Secrets Managers

The use of configuration variables, `RETOOL_EXPOSED` variables, and Secrets Manager depends on your security and permission requirements.

Config vars are set directly in the Retool settings web interface, are available on Retool Cloud and self-hosted Retool, and are stored encrypted. Use configuration variables when you need to access variables per resource environment.

On self-hosted Retool deployments, `RETOOL_EXPOSED_*` variables are set per-instance as [environment variables](../../../../self-hosted/reference/environment-variables/#retool_exposed_name). Their values are never exposed in Retool.

If your use case requires higher levels of security, integrating with a third-party Secrets Manager such as [AWS](../../../self-hosted/guides/secrets/aws.mdx) or [Vault](../../../self-hosted/guides/secrets/hashicorp-vault.mdx) is recommended.

## Configuration variables API

Organizations on the Enterprise plan running on Retool Cloud or self-hosted Retool versions 3.42 and later can use the [Retool API](../../../api/list-configuration-variables-and-their-values.api.mdx) to manage configuration variables.

---

## Configure resource environments

All Retool organizations on paid plans have _production_ and _staging_ resource environments:

- Production is the default resource environment for Retool apps and cannot be removed or renamed.
- Staging allows you to test apps without impacting production.

Administrators of Retool Cloud or self-hosted Retool organizations can create any number of separate resource environments to build, run, and test apps and workflows. All [administrators and editors](../../../permissions/guides.mdx#configure-access-rules-for-a-permission-group) can access and use these environments by default. Organizations on a Business or an Enterprise plan can configure [per-environment resource permissions](../../../permissions/guides/configure-permission-groups.mdx#control-access-to-resource-environments) to allow users to access only certain resource environments, such as allowing access to staging data but preventing access to production.

When you [configure a resource](#configure-environment-resources), you set the resource environments that resource is accessible in. This allows you to test apps with staging data and restrict access to production data. Resource environments differ from [versioning apps](../../../apps/guides/app-management/releases-history.mdx): apps function across resource environments. When you query a resource in an app, the resource's environments determine the data the app uses.

## Create a resource environment

Administrators create and manage resource environments for a Retool organization from the [Environments](https://login.retool.com/auth/login?source=docs&redirectOnLogin=settings/environments) settings. Click **Create new** to create a resource environment. All resource environments must have a unique name and display color.

## Configure resources

Multiple resources environments allow you to display and test against nonsensitive (non-production) data. You can set up connections to your data sources (e.g., database or API) and add environment-specific credentials within the same resource.

Each resource must be configured for your organization's default resource environment. New resources are configured for the default resource environment automatically.

To configure a resource for a specific environment:

1. Select the **Resources** tab and click **Edit**.
2. Add the appropriate resource credentials for each defined resource environment.

You don't need to configure a resource for every resource environment. Keep in mind that you cannot switch to an resource environment while editing an app if it hasn't been configured with a resource that is referenced by the app.

### Configure per-environment permissions

Admins for organizations on a Business or an Enterprise plan can configure different access levels to resources from **Settings > Permissions**. Learn more in the [permission groups documentation](../../../permissions/guides/configure-permission-groups.mdx#control-access-to-resource-environments).

## Switch resource environments

You can switch between resource environments directly from the app IDE. Users with edit or admin access can also switch resource environments in preview mode. You cannot switch to a resource environment that is not configured with a required resource.

You can access resource settings and configure them for other resource environments by clicking **Edit** in the **Resource** field of a query.

Switching resource environments automatically reloads the app to use the appropriate resources and credentials. If your resource requires authentication, users must re-authenticate the first time they switch to a different resource environment. Retool then stores separate access tokens for each resource environment.

### Viewer resource environments

Users that have **Use** access to an app can switch between multiple environments from the Retool contextual menu in the lower-left corner.

This feature is not supported on Retool Mobile.

## Use specific environments across apps

Retool saves your most recently selected resource environment to your browser cache and automatically uses it the next time you open an app. For example, if you switch to a staging environment in one app, the next app you open automatically uses the same staging environment.

You can link directly to a Retool app and include the `_environment` [URL query parameter](../../../apps/guides/app-management/customize-app-urls.mdx) to automatically open it with a specified environment.

:::note

The default resource environment for Public Apps is production.

:::

## Reference the selected resource environment

The `retoolContext` object contains the `environment` property that corresponds to the name of the resource environment currently in use. Use `{{ retoolContext.environment }}` to reference this anywhere you need to surface the resource environment in your app.

---

## Manage configuration

import DocCardList from "@theme/DocCardList";

---

## Manage users in your organization

import DocCardList from "@theme/DocCardList";

---

## Integrate Intercom Messenger for end-users

You can bring your own Intercom Messenger to Retool to provide support to end-users. End-users are shown a help bubble when viewing apps, and when clicked, your own Intercom Messenger is displayed.

## Requirements
To provide Intercom Messenger support to your end-users, your organization must be on a Business or an Enterprise plan. You must also be an admin of your organization to configure Intercom-related settings.

Retool requires that you use Intercom’s [Identity Verification](https://www.intercom.com/help/en/articles/7946878-what-is-identity-verification) feature. Intercom strongly recommend using this feature because it prevents user impersonation and ensures conversations are private.

## Set up Intercom Messenger support
1. Navigate to **Settings > Branding** in Retool.
2. Select **Configure** on the **Intercom Messenger Support** section.
3. Enter your **Intercom App ID**. See [Intercom’s documentation](https://www.intercom.com/help/en/articles/8771110-getting-started-faqs#h_8ebc4ba345) to find this value.
4. Enter your **Intercom Identity Verification Key**. This can be found in your [Intercom security settings](https://www.intercom.com/help/en/articles/183-set-up-identity-verification-for-web-and-mobile).
5. Click **Close** to save your changes.
6. Test the Intercom messenger client by navigating to a Retool app as a view-only user. Click the help bubble to reveal your Intercom messenger client.

## Sending user data to Intercom
Intercom allows organizations to track information about end-users through the use of both standard and custom data attributes. A user’s Intercom experience, including their Messenger client language, can also be customized using Intercom's data attributes.

By default, Retool sends only the following information about a user to Intercom:
* Email
* User SID

To send additional information about a user to Intercom, you must use Retool's [User Attributes](../user-management/user-attributes.mdx).

1. Navigate to **Settings > Branding** in Retool.
2. Select **Configure** in the **Intercom Messenger Support** section.
3. Under **User Attributes**, select **Add attribute** and select from one of your organization’s user attributes. 
4. Specify the name that the user attribute should be mapped to when it is sent to Intercom.
5. Click **Save**.
6. When an end-user next opens an app, the selected user attributes is sent to Intercom and can be seen under the **Details** section of the Intercom user.

---

## View user audit logs

:::warning

Audit logs require administrator [permissions](../../../permissions/quickstart.mdx).

:::

Retool automatically logs user actions, such as query runs and password resets. The logs include user information (such as the user ID in the audit log download, and the user's email on the **Audit logs** page), the action taken, and when the action took place.

You can access audit logs from either:

- The **User** menu on the top-right when browsing your organization.
- The **Retool** menu on the top-left of the app IDE.

To access the audit log, visit `/audit`. You can see a list of all the events that occurred, information about the user who performed them (email or user ID), and the time. You can also explore more detailed information, including the exact query, the parameters passed, the user's IP address, or response time. 

:::note
For a full list of events captured in the audit logs, refer to the [Logged events](../../reference/logged-events.mdx) reference page.
:::

Audit logs for Retool Cloud organizations are retained for one year. You can see the past three months of data using the **Date range** selector on the **Audit logs** page, and you can [download logs](#download-audit-logs-on-retool-cloud) for the past year. Self-hosted deployments manage their own audit log retention.

## Access audit logs in SQL

:::note

Access to the audit logs SQL table are only available on self-hosted deployments. If you're interested in a self-hosted deployment, [reach out](https://retool.com/demo/?meeting_page_source=docs) for a demo.

:::

Self-hosted Retool deployments can use SQL to query the audit logs database table.

### Query audit logs in SQL

Retool logs events to the `audit_trail_events` table in the [postgres](../../../self-hosted/concepts/architecture.mdx#postgres) database of the deployment instance. You can create a [PostgreSQL resource](../../../data-sources/guides/integrations/database/postgresql.mdx) if you want to build apps and workflows to query audit log data.

The `audit_trail_events` table contains the following columns.

| Column           | Description                                                                        |
| ---------------- | ---------------------------------------------------------------------------------- |
| `actionType`     | The type of action taken. See [Logged events](#logged-events) for possible values. |
| `userId`         | The ID of the user taking the action.                                              |
| `ipAddress`      | The IP address of the user taking the action.                                      |
| `responseTimeMs` | The response time of the action, in milliseconds.                                  |
| `pageName`       | The name of the app, module, workflow, or page on which the action was taken.      |
| `queryName`      | For query actions, the name of the query.                                          |
| `resourceName`   | For actions on resources, the name of the resource.                                |
| `metadata`       | Additional data about the action.                                                  |

You can join the `audit_trail_events` table with the `users` table to learn more details about the users who performed actions. For example, the following query returns records of groups created and the user who created each group.

```sql
select
u.email, u."userName", a."actionType", a.metadata
from
  audit_trail_events a
  join users u on a."userId" = u.id
  where a."actionType" = 'CREATE_GROUP';
```

## Export and download audit logs

If you self-host Retool, you can export and stream audit logs using SQL and `stdout` or by connecting to DataDog, which is supported on Retool Cloud as well.

### Output audit logs to stdout

If you self-host Retool, set the [environment variable](../../../self-hosted/reference/environment-variables/index.mdx#log_audit_events) `LOG_AUDIT_EVENTS=true` to output all audit log events to `stdout`. This is useful if you use external services to monitor and consume logs from `stdout`. You can set up a sidecar service that ingests these logs and set up custom monitoring in your APM solution.

### Stream audit logs to Datadog and Splunk

:::warning
This feature is only available on the Enterprise plan. If you self-host Retool, you must be running version 3.38 or later for Datadog and 3.114 or later for Splunk.
:::

To configure Datadog:

1. [Create a Datadog API key](https://docs.datadoghq.com/account_management/api-app-keys/) for streaming Retool audit logs.
2. Enter your Datadog API key on **Settings** > **Advanced** under **Audit Log**.

Logs will be sent to Datadog with `service:retool-audit-log` attribute.

To configure Splunk:

1. [Create an HTTP Event Collector (HEC) token](https://docs.splunk.com/Documentation/Splunk/9.3.2/Data/UsetheHTTPEventCollector) for Retool audit logs.
2. [Determine the HEC URI](https://docs.splunk.com/Documentation/Splunk/9.3.2/Data/UsetheHTTPEventCollector#Send_data_to_HTTP_Event_Collector) where the logs should be sent.
3. Enter your HEC token and URI on **Settings** > **Advanced** under **Audit Log**.

Retool sends logs to Splunk with `source:retool-audit-log` attribute.

### Download audit logs on Retool Cloud

Retool Cloud customers on a Business or an Enterprise plan can download audit logs directly from the Audit Logs page.

After selecting a date range and starting a download, the download job is displayed in a list with a **Pending** status. Once complete, a temporary link with a compressed CSV file is made available in the **Downloads** list. The link expires an hour after being created.

### Download audit logs on Self-hosted

If you self-host Retool and have connected to the Retool audit logs database table, you can export audit logs through the following SQL command:

```sql
\copy audit_trail_events to 'audit_logs' csv;
```

## Hide query data from logs

You can hide parameters from logs on a per-query basis. See the [query documentation](../../../queries/quickstart.mdx#hide-parameters-from-audit-logs) for more details.

To prevent all headers in queries from being logged, enable the `HIDE_ALL_HEADERS_IN_AUDIT_LOG_EVENTS` [environment variable](../../../self-hosted/reference/environment-variables#property-HIDE_ALL_HEADERS_IN_AUDIT_LOG_EVENTS). This is only available on self-hosted deployments.

---

## Monitor usage and logs

import DocCardList from "@theme/DocCardList";

---

## Monitor app and user analytics

As more users build and use Retool apps within your organization, it’s helpful to understand adoption patterns to better make decisions about your use of Retool. If you’re self-hosting Retool, you might run multiple instances, and seeing which users are using which apps can be difficult.

Retool provides a number of usage analytics for you to view that provide detailed information about users and app usage. For self-hosted organizations, usage analytics data is aggregated across all deployments that you have.

## View usage analytics

Admin users can view usage analytics for your organization by navigating to **Settings > Usage Analytics**.

Usage analytics are only available to admins by default. Admins can grant access to non-admin users using [permission groups](../../../permissions/guides/configure-permission-groups.mdx). Navigate to your permission group and under **Additional > Settings page visibility**, select **View usage analytics**. Users in this permission group can view organization-wide Retool usage.

Active users

The **Users** tab contains analytics for all users with access to your organization. This is segmented based on the following types:

| Type | Description |
| --- | --- |
| Total active users | Total number of all users in Retool in the previous 30-day window up to the selected end date. |
| Builders | Total number of distinct builders in the previous 30-day window up to the selected end date. |
| Internal users | Total number of distinct internal users in the previous 30-day window up to the selected end date. |
| External users | Total number of distinct external users in the previous 30-day window up to the selected end date. |

You can hover the cursor over each data point in the chart to view complete details for usage.

Users details

The **Users details** section provides more details about users. You can search the table to filter the results. Select a user in the table to view more details about their app usage over the specified time period.

Active apps

The **Apps** tab contains analytics for all app usage across the organization. This is segmented based on the following types:

| Type | Description |
| --- | --- |
| Total active apps | Total number of distinct apps viewed at least once in the previous 30-day window up to the selected end date. |
| Total app saves | Total number of app saves across all apps during the selected time period. |
| Total app views | Total number of app views across all apps during the selected time period. |

You can hover the cursor over each data point in the chart to view complete details for usage.

Apps details

The **Apps details** section provides more details about app usage. You can search the table to filter the results. Select an app in the table to view more details about its usage over the specified time period.

## Enable usage analytics for self-hosted Retool

Self-hosted organizations can enable Usage Analytics by setting the `USAGE_API_TOKEN` environment variable. This environment variable is a manually granted Usage Analytics access token to ensure security. To obtain this token, contact your Retool account manager.

If you self-host Retool, you might deploy multiple instances to isolate your production and non-production instances. Usage Analytics automatically gathers user and app usage (and other sensitive data) across all of your instances. Retool recommends enabling Usage Analytics on the instance with the most restrictions to keep data secure. Only admins of that instance will have the ability to view usage in **Settings > Usage Analytics** by default.

Retool assumes emails uniquely identify users. If a user is accessing multiple Retool instances, they must use the same email on each instance to avoid being counted multiple times in active-user counts. This also means that Retool expects to see a temporary spike in usage for an organization undergoing a domain migration.

---

## Configure Retool API authentication

The Retool API uses access tokens to authenticate requests. Organization admins can create access tokens from their organization's **Settings > API** page.

## Create an access token

import Tokens from "/docs/_partials/_tokens.mdx";

You can create access tokens in the **API** settings for your organization.

## Specify scopes and permissions

When you create an access token, you specify scopes that determine its level of access. Each scope has a set of permissions to control what operations are allowed when using the token.

Some scopes support individual read and write permissions. **Write** access also grants **Read** access.

import RetoolApi from "../_partials/_scopes/_retool-api.mdx"

## Authenticate requests

Authentication is performed using [Bearer HTTP authentication](https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication#basic) with the provided token.

```shell
curl -X POST https://retool.example.com/api/v2/apps -H 'Authorization: Bearer $BEARER_TOKEN'
```

## Access tokens for spaces

If your organization uses [Spaces](../../tutorials/spaces.mdx), each space has its own authentication tokens and Retool API endpoints. With one exception, only tokens created for a space can be used to interact with its Retool API endpoints.

An admin can use a token from the primary organization to interact with Retool API endpoints for a space within the organization only when:

- The admin user created the token on the primary organization.
- The admin user of the primary organization is also an admin for the space.

## API rate limits

Retool uses a point system for rate limiting where endpoint requests cost a certain number of points. You can use up to 300 points in a 60 second window. If you exceed this, Retool blocks API calls for 60 seconds.

| Endpoints                                                                                                                                      | Points |
| ---------------------------------------------------------------------------------------------------------------------------------------------- | ------ |
| Apps, Folders, Users                                                                                                                           | 2      |
| Access Request, App Themes, Environment, Groups, Resources, Resource Configurations, Source Control, Spaces, SSO, User Attributes, User Invite | 5      |
| Permissions                                                                                                                                    | 10     |

## Create a Retool API resource

You can create a Retool API resource to interact with it using apps and workflows. Refer to the [Retool API resource guide](../../../data-sources/guides/integrations/api/retool-api.mdx) to connect using the OpenAPI integration.

---

## Automate user onboarding using the Retool API

To onboard teams to Retool, you often need to grant them the ability to build apps with new or existing resources. This can include:

- Creating app and resource folders
- Creating permission groups
- Setting folder permissions
- Provisioning users

Performing these tasks manually can be difficult to scale, but you can use the Retool API to automate these steps.

This guide outlines how to use the permissions and folder endpoints in the Retool API to onboard new users. If these users must operate in isolation from other teams, with their own resources, software development lifecycle, and release process, consider [creating a Space](automate-spaces.mdx) for them.

## Requirements

The [Retool API](../../../api/index.mdx) is available to cloud organizations and self-hosted organizations running v3.18 or later. API users must generate [access tokens](authentication.mdx) to authenticate. This guide assumes you have an access token with **Read and Write** scopes for users, permissions, and Spaces.

In this guide, replace `space-domain` with the domain of your [Space](../../tutorials/spaces.mdx) or organization, e.g., `organization.retool.dev` or `custom-space.organization.retool.dev`.

## 1. Create an app folder

The following command creates a top-level app folder named **Support**. The response contains the ID of the newly created folder; save this for a later step.

```shell
curl -X POST https://{space-domain}/api/v2/folders -H 'Authorization: Bearer $BEARER_TOKEN' -H 'Content-Type: application/json' --data '{"name": "Support", "parent_folder_id": null, "folder_type": "app"}'
```

## 2. Create a resource folder

The following command creates a top-level resource folder named **Support resources**. The response contains the ID of the newly created folder; save this for a later step.

```shell
curl -X POST https://{space-domain}/api/v2/folders -H 'Authorization: Bearer $BEARER_TOKEN' -H 'Content-Type: application/json' --data '{"name": "Support resources", "parent_folder_id": null, "folder_type": "resource"}'
```

## 3. Update and create permission groups

By default, the **All users** group has **Use** access to apps and resources. To ensure new Retool users have restricted access unless they're explicitly added to a permission group, set the universal access level for **All users** to **None**.

If you don't know the ID for the **All users** group, use the `GET /groups` endpoint to retrieve it.

```shell
curl -X PATCH https://{space-domain}/api/v2/groups/1 -H 'Authorization: Bearer $BEARER_TOKEN' -H 'Content-Type: application/json' --data '{"operations": [{"op": "replace", "path": "universal_app_access", "value": "none"}]}'
```

Next, create a new permission group. Save its ID for later steps.

```shell
curl -X POST https://{space-domain}/api/v2/groups -H 'Authorization: Bearer $BEARER_TOKEN' -H 'Content-Type: application/json' --data '{"name": "Support team", "universal_app_access": "none", "universal_resource_access": "user", "members": []}'
```

## 4. Set folder permissions

Grant the newly created permission group access to the new app and resource folders with the following command. Replace `GROUP_ID` with the ID of your new permission group, and `APP_FOLDER_ID` and `RESOURCE_FOLDER_ID` with the IDs of your new app and resource folders.

```shell
curl -X POST https://{space-domain}/api/v2/permissions/grant -H 'Authorization: Bearer $BEARER_TOKEN' -H 'Content-Type: application/json' --data '{"subject": {"id": GROUP_ID, "type": "group"}, "object": {"id": APP_FOLDER_ID, "type": "folder"}, "access_level": "edit"}'
```

```shell
curl -X POST https://{space-domain}/api/v2/permissions/grant -H 'Authorization: Bearer $BEARER_TOKEN' -H 'Content-Type: application/json' --data '{"subject": {"id": GROUP_ID, "type": "group"}, "object": {"id": RESOURCE_FOLDER_ID, "type": "folder"}, "access_level": "edit"}'
```

## 5. Provision and map users

Create users in Retool.

```shell
curl -X POST https://{space-domain}/api/v2/users -H 'Authorization: Bearer $BEARER_TOKEN' -H 'Content-Type: application/json' --data '{"first_name": "Test", "last_name": "User", "active": true, "email": "testuser@retool.com"}'
```

Use the newly created user IDs to add users to the new permission group, and optionally set any certain users as admins.

```shell
curl -X POST https://{space-domain}/api/v2/groups/{GROUP_ID}/members -H 'Authorization: Bearer $BEARER_TOKEN' -H 'Content-Type: application/json' --data '{[{"id": USER_ID, "is_group_admin": false}]}'
```

## 6. Wrap up

You can confirm the onboarding flow correctly created app folders, groups, and users from the **Settings > Permissions** page. You should see the newly created permission group, and within it, a new member. The **Apps** and **Resources** tabs should reflect the new apps and folders.

To further streamline onboarding, you can add the Retool API as a resource and create an app or workflow to trigger these steps based on user input.

---

## Automate Spaces configuration using the Retool API

If you need to configure many [Spaces](../../tutorials/spaces.mdx), you may want to programmatically configure them with the Retool API, rather than manually create and configure every Space. You can use the commands in this guide within Retool apps, workflows, or other scripts to streamline Spaces configuration.

## Requirements

The [Retool API](../../../api/index.mdx) is available to cloud organizations and self-hosted organizations running v3.18 or later. API users must generate [access tokens](authentication.mdx) to authenticate. This guide assumes you have an access token with **Read and Write** scopes for users, permissions, and Spaces.

## 1. Get existing spaces

From the Admin Space, use the following command to retrieve all existing Spaces.

```shell
curl -X GET https://{ADMIN_SPACE_DOMAIN}/api/v2/spaces -H 'Authorization: Bearer $BEARER_TOKEN'
```

## 2. Edit theme

From the child Space, update the theme.

```shell
curl -X PUT https://{CHILD_SPACE_DOMAIN}/api/v2/app_themes -H 'Authorization: Bearer $BEARER_TOKEN' -H 'Content-Type: application/json' --data '{"name": "Default theme", "theme": {"info": "hsl(208, 70%, 55%)", "canvas": "#FFFFFF", "danger": "#CA483F", "primary": "#128747", "success": "#128747", "warning": "#D17823", "tertiary": "#034822", "textDark": "#262626", "highlight": "#f6e5c4","secondary": "#d7eae0", "textLight": "#FFFFFF", "borderRadius": "4px", "surfacePrimary": "#FFFFFF", "surfaceSecondary": "#F9F9F9"}}'
```

## 3. Edit SSO configuration

From the child Space, update the SSO configuration. Refer to the [SSO](../../../sso/index.mdx) documentation for more detail on SSO fields.

```shell
curl -X POST https://{CHILD_SPACE_DOMAIN}/api/v2/sso/config -H 'Authorization: Bearer $BEARER_TOKEN' -H 'Content-Type: application/json' --data
'{"data": {"config_type": "google", "google_client_id": "GOOGLE_CLIENT_ID", "google_client_secret": "GOOGLE_SECRET", "disable_email_password_login": false}}'
```

## 4. Create a Source Control configuration

:::warning

To use Spaces with Source Control, ensure you [migrate your apps to Toolscript](/changelog/yaml-serialization-deprecation).

:::

From the child Space, create a [Source Control](../../../source-control/index.mdx) configuration.

```shell
curl -X POST https://{CHILD_SPACE_DOMAIN}/api/v2/source_control/config -H 'Authorization: Bearer $BEARER_TOKEN' -H 'Content-Type: application/json' --data {"config": {"config": {"type": "App", "app_id": "app_id", "installation_id": "installation_id", "private_key": PRIVATE_KEY, "url": "string", "enterprise_api_url": "string"}, "provider": "GitHub", "org": "github_organization", "repo": "github_repo", "default_branch": "main"}}
```

## 5. Create additional Spaces

You can generate a new Space with settings automatically copied over from an existing Space. Set `copy_sso_settings` and `copy_branding_and_themes_settings`. When you create spaces programmatically, you also must set `create_admin_user` to `true`. This creates a default admin user with the email of the API key creator.

```shell
curl -X POST https://{ADMIN_SPACE_DOMAIN}/api/v2/spaces -H 'Authorization: Bearer $BEARER_TOKEN' -H 'Content-Type: application/json' --data '{"name": "Finance", "domain": "finance.sample-org.dev", "options": {"copy_sso_settings": true, "copy_branding_and_themes_settings": true, "create_admin_user": true}}'
```

---

## Retool API how-to guides



---

## User management how-to guides



---

## Enable two-factor authentication

Two-factor authentication (2FA) provides an additional level of security. Admins can enable two-factor authentication so that users must either enter a one-time passcode (OTP) generated by an authenticator app or use a security key (FIDO2) each time they log in.

:::note Two-factor authentication for individual users

Users in organizations on the Enterprise plan can enable two-factor authentication for their account even if it's not required for the organization **Settings** > **Account**.

:::

### Enforce two-factor authentication

Admins can manage two-factor authentication enforcement by navigating to **Settings** > **Advanced**. Set the **Require Two Factor Authentication** option to either the **OTP** or **FIDO2** method. The next time a user logs in, they will have to configure two-factor authentication before they can continue.

To disable organization-wide two-factor authentication, change this option to **None**.

## Set up OTP authentication

OTP requires a compatible authenticator app, such as 1Password, Authy, and Google Authenticator. To set up:

1. Scan the QR code with the authenticator app.
2. Enter the generated one-time passcode to confirm and complete set up.

Whenever a user attempts to sign in, they must also enter a generated one-time passcode.

## Set up FIDO2 authentication

:::caution Use OTP when using Retool Mobile

FIDO 2FA is not supported in Retool mobile apps. Use OTP 2FA instead.

:::

FIDO2 requires a FIDO2-complaint security key. This can be either a hardware key (e.g., Yubikey) or a supported security key method (e.g., [passkey](https://blog.1password.com/what-are-passkeys/)). Support for available options depend on the user's device and browser.

FIDO2 setup is handled by the user's browser. Follow the instructions to set up a hardware key or passkey. 

## Reset two-factor authentication for individual users

:::warning Keep your two-factor authentication details secure

If you're the only admin of your organization and lose access to your two-factor authentication method, contact our [contact our support team](mailto:support@retool.com).

:::

Retool administrators can reset 2FA for individual users in the Users settings. Navigate to **Settings** > **Users**, then click the `...` menu for the user. Once reset, the user must setup 2FA again the next time they log in.

Users of Retool organizations on the Enterprise plan can also reset their own 2FA from **Settings** > **Account**.

---

## Configure user attributes

Often, information about Retool users exists in systems outside of Retool. With user attributes, you can bring this information into Retool and store it on the user–across all of your Retool apps.

You can create and add attributes to users to enable custom experiences in Retool. Admins can create and apply attributes to any Retool user. When building Retool apps, you can reference attributes through the `current_user` object to control functionality. Attributes are secure by default: bad actors cannot spoof data passed into queries that reference attributes.

## Create user attributes

To create a user attribute, go to **Settings** > **User attributes**. Add a name as your key, a label for readability, and data type.

User attributes support the following data types:

- String: Can contain letters, numbers, symbols, and spaces (e.g., username or account tier).
- Number: Supports floating point values.
- JSON: Stored as an object.

Optionally, you can add a default value to be applied across all users. When a value is not assigned to the user, the default value is set.

## Assign attribute values to users

:::info Retool API

You can also assign and delete user attributes using User Attributes endpoints in the [Retool API](../../../api/add-or-update-user-attributes-on-a-user-invite.api.mdx).

:::

Admins can assign attribute values directly to users from **Settings > Users**. Under **User Attributes**, update and reset user attribute values. Resetting an attribute value clears it, or reverts it to its default value if one is set.

You cannot delete an attribute key from a user without first deleting the attribute at the organizational level.

:::note Using custom authentication with Retool API

If you [embed external apps](../../../apps/guides/app-management/embed-apps.mdx) or use the [SCIM API](../../../scim/index.mdx), and passing values into the `metadata` property, those values will also be available on the `current_user.metadata` object. If an attribute with the same name already exists, respecting the attribute type, Retool will set its value with the value in the API request.

:::

### Use in Retool apps

When editing a Retool app, you can reference user attributes through `current_user.metadata.`. Add logic referencing these attributes to hide and show components based on attributes set on the user, filter data, and more.

Setting default values is also especially useful when building Retool apps that might reference nested values. This way, you can ensure the schema across users is consistent and doesn't vary between applications.

### Row-level security

When implementing [row-level security](../../../queries/concepts/row-level-security.mdx), many customers maintain mapping tables from the Retool user's email or permission group to foreign keys in their database. To save a `JOIN` operation and maintenance, you can add these foreign keys directly to the user as attributes.

---

## Administration how-to guides

import Howto from '/docs/_partials/_doctypes/_howto.mdx';

:::tip Get started

Read the [quickstart](./quickstart) to learn about the fundamental concepts for Retool administration.

:::

---

## Administration documentation

Manage your Retool organization, manage users, create isolated spaces for teams, and more.

---

## Administration quickstart

This guide serves as an introduction to Retool administration. It covers many of the concepts and terminology you would come across when managing or working within a Retool organization. After reading this page, you should have a good understanding of the fundamentals for organizations and users.

## Introduction

A Retool _organization_ is a distinct collection of users and data. Organizations operate separately from one another, have their own configuration settings, and are where users share access to work.

Each cloud-hosted organization has its own `.retool.com` subdomain, such as `https://example.retool.com`. Self-hosted organizations use the URL for their deployment and may have multiple instances.

## Spaces

Spaces are an organizational feature that allow you to create multiple isolated Retool organizations. These spaces exist within the same parent organization and provide a multitenant experience. Each space has its own:

- Subdomain of your Retool organization (e.g., `space1.example.retool.com`).
- SSO configuration.
- Source Control configuration.
- User accounts and permission groups.
- Retool Database.
- Data (folders, apps, workflows, resources, etc.)

Spaces are useful when:

- Your teams want to have separate source control repositories and sets of apps available to them.
- You have isolated use cases which don't overlap with the rest of your Retool usage: e.g., you want to create a suite of “performance review” apps or an external portal, each with its own set of users, apps, and resources.
- You want to delegate administration of Retool to a distributed set of admins, based on the apps they’ll be overseeing.

## Users

:::tip User billing

Refer to the [billing and usage](/support/billing-usage) documentation to learn more about the different user types that relate to billing.

:::

A _Retool user_ is a Retool account that belongs or has access to an organization. Users represent the people with access to the organization and its data. Retool uses email addresses as the identifier for users.

When a user signs up, Retool associates them with an existing organization if the user meets one of the following conditions:

- They use an invitation from an existing organization.
- Their email address domain matches one configured by an existing organization to automatically add users from that domain.
- They use an SSO provider configured for an existing organization.

Retool uses the email address as the identifier for a user and associates it with an organization at signup. This can be an existing organization if the user meets certain conditions or a new organization for which the user is the primary admin.

If the user doesn't meet these conditions during signup, Retool prompts them to create a new organization for which they become the primary admin.

import Email from "./_partials/_email.mdx"

### Drafts

The **Drafts** tab of the Apps landing page is a personal folder for [builders](/support/billing-usage#user-types) to develop and test apps. Only you and organization admins have access to view or edit apps that you create in this section. This feature is useful for organizations where creating applications and folders is restricted—admins don't have to give users explicit permission to create apps in their **Drafts**.

You cannot share an app that is currently in the **Drafts** folder with other users. Once the app is ready to be shared with other users, move the app to a different folder in the organization so it can then be accessed by others.

Admins can see draft apps for all users in the organization using the **Users' drafts** filter.

**Drafts** are enabled by default. Admins can toggle off this feature by navigating to **Settings** > **Beta** and turning off **Drafts folders**.

### External users

Organizations can [embed web apps](../apps/concepts/share-externally/embed.mdx) into their own web-based applications for use by external users, such as customers, vendors, or partners. An external user is not considered part of a Retool organization and can only access apps for which they have access.

External users priced at the same rate as internal users on the Team and Business [plans](https://retool.com/pricing). However, usage for external use cases varies and the default pricing might not work for everyone. If you're pre-product or have hundreds of thousands of users, [talk to our team](https://retool.com/demo/?meeting_page_source=docs) to learn more.

Refer to [External users](./concepts/external-users.mdx) for more information about external users.

### Authentication

Retool manages authentication of users for your organization. The available methods and process depend on your subscription plan and whether you use an SSO identity provider (idP). Retool organizations on every plan can use Sign in with Google. Organizations on the Enterprise plan can configure additional SAML and OIDC providers.

Regardless of authentication method, new users must be added to relevant [permission groups](../permissions/tutorial.mdx) to grant them required access. You can either configure the SSO authentication flow to handle this automatically or you can manually [configure user permissions](../permissions/guides/configure-permission-groups.mdx).

Retool supports Sign in with Google. You can sign in using your existing Google account. Retool creates a new organization if you're not an existing user.

If your organization uses [Google Workspace](https://workspace.google.com/) and all users share the same domain, users can select **Sign in with Google** and log in automatically to the same Retool organization. If you attempt to sign in with Google and there is no existing organization, Retool creates one and assigns you as an administrator.

Retool accounts use an email address and password which operates separately from Sign in with Google. You can specify a set of domains from which to allow users with a matching email address to join. Navigate to **Settings > Advanced**, then add one or more domains to the **Auto-join domain** section. You then specify whether users with a matching email address can request to join or join automatically for that domain.

When auto-join is disabled, anyone who signs up to Retool with a username and password creates a new organization, regardless of whether the email address shares a domain with an existing Retool organization. To join an organization using email and password instead of creating a new one, they will need to receive an invitation.

[SSO](../sso/index.mdx) is a user authentication tool that enables users to securely access multiple applications and services using one set of credentials. Rather than require users to create additional usernames and passwords for Retool, you can centralize logins to a single identity provider (IdP). SSO is primarily used for authentication, though Retool also supports syncing groups for authorization.

## Retool API

The [Retool API](../api/index.mdx) enables Retool admins to programmatically manage different aspects of their organization, such as:

- Access control
  - Users
  - Groups
  - Permissions
  - SSO
- Apps and themes
- Resources and resource environments
- Folders for apps, resources, and workflows
- Spaces
- Source Control

Retool also implements a subset of the [SCIM 2.0 API](../scim/index.mdx). This adheres to the [SCIM 2.0 Protocol](https://developer.okta.com/docs/reference/scim/scim-20/) that is used by identity providers (e.g., Okta) to automatically provision users and map groups.

While there is overlap between functionality in the Retool API and SCIM 2.0 API, use the Retool API for automating operations when possible.

## Retool Events

Retool Events allow organizations to build workflows that trigger automatically in response to actions taken in Retool. These workflows can then perform custom actions, such as sending custom onboarding emails to new users or notifying admins about certain actions that occur.

You can even [configure branding options](../apps/guides/app-management/external-apps/index.mdx#configure-branding) to replace Retool's built-in email notifications with workflows that send custom transactional emails with a reply-to address at your domain. When doing so, you should set up appropriate alerts as error handlers in your workflows.

Read the [Retool Events workflow](../workflows/guides/retool-events.mdx) tutorial to learn more.

---

## Organizations and users glossary

import SharedGlossary from '../../_partials/_glossary.mdx';

---

## Audit trail logged events

By default, Retool captures the following events in the audit log. Refer to the [View user audit logs](../guides/monitoring/audit-logs.mdx) page for more information.

| Identifier in logs                     | Action                                                           |
|----------------------------------------|------------------------------------------------------------------|
| `ACCESS_TOKEN_CREATED`                 | An access token was created.                                     |
| `ACCESS_TOKEN_REVOKED`                 | An access token was revoked.                                     |
| `ADD_PAGE_TO_GROUP`                    | A page was added to a group.                                     |
| `ADD_USERS_TO_GROUP`                   | A user added other users to a group.                             |
| `ANALYTICS_CONFIG_CREATED`             | An analytics configuration was created.                          |
| `ANALYTICS_CONFIG_DELETED`             | An analytics configuration was deleted.                          |
| `ANALYTICS_CONFIG_UPDATED`             | An analytics configuration was updated.                          |
| `ARCHIVE_ORGANIZATION`                 | An organization was archived.                                    |
| `ARCHIVE_USER`                         | A user account was archived.                                     |
| `CANCEL_USER_TASK`                     | A user task was cancelled.                                       |
| `CONFIG_VAR_CREATE`                    | A configuration variable was created.                            |
| `CONFIG_VAR_DELETE`                    | A configuration variable was deleted.                            |
| `CONFIG_VAR_UPDATE`                    | A configuration variable was updated.                            |
| `CONFIRM_PASSWORD_RESET_LINK`          | A user confirms a password reset request.                        |
| `CREATE_EVENT_WORKFLOW`                | An event-based workflow was created.                             |
| `CREATE_GROUP`                         | A user created a group.                                          |
| `CREATE_RESOURCE`                      | A user created a resource.                                       |
| `CREATE_ROLE`                          | A new role was created.                                          |
| `CREATE_USER`                          | A new user account was created.                                  |
| `CREATE_USER_TASK`                     | A user task was created.                                         |
| `CREATE_WORKFLOW`                      | A user created a workflow.                                       |
| `DATASOURCE_CREATE`                    | A new data source was created.                                   |
| `DELETE_EVENT_WORKFLOW`                | An event-based workflow was deleted.                             |
| `DELETE_GROUP`                         | A user deleted a group.                                          |
| `DELETE_RESOURCE`                      | A user deleted a resource.                                       |
| `DELETE_ROLE`                          | A role was deleted.                                              |
| `DELETE_USER`                          | A user account was deleted.                                      |
| `DELETE_WORKFLOW`                      | A user deleted a workflow.                                       |
| `DIRECTLY_SHARE_PAGE_WITH_USER`        | A page was directly shared with a user.                          |
| `DISABLE_RETOOL_DEFAULT_EMAIL`         | The default Retool email notifications were disabled.            |
| `DISABLE_TRIGGER`                      | A user disabled a workflow trigger.                              |
| `DISABLE_TWO_FACTOR_AUTH`              | A user disabled two-factor authentication.                       |
| `DISABLE_USER`                         | A user disabled another user.                                    |
| `DISABLE_WORKFLOW`                     | A workflow was disabled.                                         |
| `DOWNLOAD_AUDIT_LOGS`                  | Audit logs were downloaded.                                      |
| `ENABLE_TRIGGER`                       | A user enabled a workflow trigger.                               |
| `ENABLE_USER`                          | A user enabled another user.                                     |
| `ENABLE_WORKFLOW`                      | A workflow was enabled.                                          |
| `INVITE_USER`                          | A user invited another user.                                     |
| `LOGIN`                                | A user logged in.                                                |
| `LOGIN_FAILED`                         | A user login attempt failed.                                     |
| `LOGOUT`                               | A user logged out.                                               |
| `MODIFY_PERMISSIONS`                   | Permissions were modified.                                       |
| `PAGE_EXPORT`                          | A user exported a page.                                          |
| `PAGE_VIEW`                            | Page views.                                                      |
| `PLAYGROUND_QUERY_RUN`                 | A user ran a query in the Query Library.                         |
| `QUERY_PREVIEW`                        | Query tests (preview runs).                                      |
| `QUERY_RUN`                            | Query runs (executed in production or live context).             |
| `RE_INVITE_USER`                       | A user re-sent an invite.                                        |
| `REASSIGN_USER_TASK`                   | A user task was reassigned.                                      |
| `REDEEM_INVITE`                        | A user redeemed an invite.                                       |
| `RELEASE_WORKFLOW`                     | A user released a workflow.                                      |
| `REMOVE_PAGE_FROM_GROUP`               | A page was removed from a group.                                 |
| `REMOVE_TWO_FACTOR_AUTHENTICATOR`      | Two-factor authentication device was removed.                    |
| `REMOVE_USER_FROM_GROUP`               | A user was removed from a group.                                 |
| `REMOVE_USERS_FROM_GROUP`              | A user removed other users from a group.                         |
| `REQUEST_PASSWORD_RESET_LINK`          | A user requested a password reset link.                          |
| `REQUEST_PASSWORDLESS_LOGIN`           | A user requested passwordless login.                             |
| `REQUEST_PASSWORDLESS_TOKEN`           | A passwordless login token was requested.                        |
| `RESET_GOOGLE_ID`                      | A user's Google ID was reset.                                    |
| `RESET_RETOOLDB_PASSWORD`              | The RetoolDB password was reset.                                 |
| `RETOOL_AI_FEATURE_CHANGED`            | A Retool AI feature setting was changed.                         |
| `RETOOL_STORAGE_FILE_ACCESSED`         | A file in Retool Storage was accessed.                           |
| `RETOOL_STORAGE_FILE_DELETED`          | A file in Retool Storage was deleted.                            |
| `RETOOL_STORAGE_FILE_METADATA_RETRIEVED`| Metadata for a Retool Storage file was retrieved.                |
| `RETOOL_STORAGE_FILE_MOVED`            | A file in Retool Storage was moved.                              |
| `RETOOL_STORAGE_FILE_UPDATED`          | A file in Retool Storage was updated.                            |
| `RETOOL_STORAGE_FILE_UPLOADED`         | A file was uploaded to Retool Storage.                           |
| `RETOOL_STORAGE_FILES_LISTED`          | Files in Retool Storage were listed.                             |
| `RETOOL_STORAGE_FOLDER_CREATED`        | A folder was created in Retool Storage.                          |
| `RETOOL_STORAGE_FOLDER_DELETED`        | A folder was deleted in Retool Storage.                          |
| `RETOOL_STORAGE_FOLDER_RENAMED`        | A folder in Retool Storage was renamed.                          |
| `RETOOL_STORAGE_FOLDERS_LISTED`        | Folders in Retool Storage were listed.                           |
| `REVEAL_RETOOLDB_CONNECTION_STRING`    | The RetoolDB connection string was revealed.                     |
| `RUN_WORKFLOW`                         | A user ran a workflow manually.                                  |
| `RUN_WORKFLOW_BLOCK`                   | A user ran a workflow block manually.                            |
| `SEND_MAGIC_LOGIN`                     | A magic login link was sent.                                     |
| `SIGN_UP`                              | A user signed up.                                                |
| `SOURCE_CONTROL_CONFIG_UPDATE`         | Source control configuration was updated.                        |
| `SOURCE_CONTROL_DEPLOYMENT_FINISHED`   | A source control deployment finished.                            |
| `SOURCE_CONTROL_SETTINGS_UPDATE`       | Source control settings were updated.                            |
| `SUBMIT_USER_TASK`                     | A user task was submitted.                                       |
| `SUGGEST_USER`                         | A user was suggested (e.g., for assignment or sharing).          |
| `UPDATE_BILLING_PLAN`                  | The billing plan was updated.                                    |
| `UPDATE_GROUP`                         | A group was updated.                                             |
| `UPDATE_ORGANIZATION`                  | A user updated an organization.                                  |
| `UPDATE_RESOURCE`                      | A user updated a resource.                                       |
| `UPDATE_ROLE`                          | A role was updated.                                              |
| `USER_CHANGED_EMAIL_AND_VERIFY`        | A user changed their email and verified it.                      |
| `USER_EMAIL_CHANGE`                    | A user changed their email address.                              |
| `USER_EMAIL_CHANGE_NOTIFICATION_SENT`  | Notification sent about a user's email change.                   |
| `USER_EMAIL_VERIFICATION_SENT`         | Email verification was sent to a user.                           |
| `USER_EMAIL_VERIFY`                    | A user verified their email address.                             |
| `USER_NAME_CHANGE`                     | A user changed their name.                                       |
| `VERIFY_2FA_FAILURE`                   | Two-factor authentication verification failed.                   |
| `VERIFY_2FA_SUCCESS`                   | Two-factor authentication verification succeeded.                |
| `VIEW_WORKFLOW`                        | A user viewed a workflow.                                        |

---

## Administration reference

import Reference from '/docs/_partials/_doctypes/_reference.mdx';

:::tip Get started with your organization and users

If you are unfamiliar with managing your organization and want to get started, read the [quickstart](./quickstart) to learn about the fundamental concepts.

:::

---

## Manage organization users

Retool provides several options for admins to add users to their organization:

- Invite users to sign up with an email address and password.
- Allow users to request access to your organization.
- Specify a list of domains to automatically add users with matching email addresses.
- Configure SSO and allow users to sign in using your SSO provider.
- Receive notifications about suggested users.

You can also disable users to prevent them from accessing the organization at any time.

## Invite users

:::caution

Users needing to sign in with an email and password must first be invited to a Retool Cloud organization. If they attempt to sign up first, Retool creates a new organization and adds them to it.

:::

You can invite users to join your Retool organization. New users can create an account with their email address and password, or sign in using SSO.

To invite a user:

1. Click the User menu on the upper-right, then select **Settings**.
2. Select the **Users** settings in the **User management** section of the sidebar.
3. Click **Invite**, then enter the email addresses of users to invite.
4. Retool sends an invite URL to the users you specified. This URL expires after one week.

Admins can also invite users directly from an app by clicking **Share**.

For organizations on the Enterprise plan, users can sign up using the URL of your deployment's sign up page. 

Retool [strongly recommends disabling signups and enforcing SSO usage](../quickstart.mdx#authentication#sso-providers-for-self-hosted-retool).

export function InviteUser() {
  return (
    
      
    
  )
}

## Allow users to request access

To enable users to request access to join your Retool organization, go to **Settings > Advanced Settings** and toggle **Allow anyone to request to join**.

Enabling this settings adds a link to your organization login page (`.retool.com/auth/login>`) prompting users to enter a valid email address. 

Visit **Settings > Users** to approve an access request. After approving, the user receives an email to join your Retool organization.

## Configure auto-join domains

Retool Cloud organizations can specify a set of domains from which to allow users with a matching email address to join. Navigate to **Settings > Advanced Settings**, then add one or more domains to the **Auto-join domains** section. You then specify whether users with a matching email address can either request to join or join automatically for that domain.

:::note

Auto-joining domains is not supported for self-hosted organizations.

:::

## Add SSO users

Retool Cloud supports Sign in with Google on all pricing plans. Organizations on the Enterprise plan can configure other supported SSO providers, such as [Okta]( ../../sso/tutorials/okta/oidc.mdx).

If you have a Retool Cloud organization and use [Google Workspace](https://workspace.google.com/), all users who share the same domain can select **Sign in with Google** and log in. Users are automatically added to your Retool Cloud organization.

Organizations on the Enterprise plan can configure additional SSO providers. Users can then sign in automatically, but [additional steps are required](../quickstart.mdx#authentication#sso-providers-for-self-hosted-retool) before they have access.

:::tip Generate auto-join links for mobile-only users

You can generate an **auto-join link** from a mobile app's [share options](../../mobile/guides/deploy/deployment.mdx#share-apps-and-invite-users) that allows users to sign up directly from the Retool Mobile app using SSO. Users who sign up using this method are added as mobile-only users. You must [configure auto-join domains](#configure-auto-join-domains) to enable this option.

:::

## Suggest users

Retool users who aren't administrators can notify admins about users who might need access. To suggest a user, navigate to **Settings > Users** and click **Suggest**. Users can provide email addresses for potential users and click **Suggest new members**.

Retool organization admins receive a notification and can decide whether to add or invite users.

## Disable users

Retool organization admins can disable access of any user within their Retool organization. Disabling users prevents them from logging into their Retool account, as well as accessing or editing any apps, queries, or resources in your shared Retool organization.

You can disable users from your organization's [Users](https://login.retool.com/auth/login?source=docs&redirectOnLogin=settings/users) settings. Select a user, then click **Disable user**.

You can enable a disabled user by clicking *...* next to their name, then **Enable user**. If you don't see the disabled user in the users list, ensure **Hide disabled users** is not selected in the user filters.

---

## Spaces tutorial

Retool Spaces is an organizational feature that allows you to split your Retool organization into multiple isolated ones, creating a multitenant experience. After enabling Retool Spaces, you retain your original organization as an **Admin Space**, and you can create any number of alternative spaces.

Each space has its own:

- Subdomain
- SSO configuration
- Source Control configuration
- User accounts and permission groups
- Retool Database
- Folders, apps, workflows, modules, queries, resources, etc.

Spaces are useful when:

- Your teams want to have separate source control repositories and sets of apps available to them.
- You have isolated use cases which don't overlap with the rest of your Retool usage: for example, you want to create a suite of “performance review” apps or an external portal, each with its own set of users, apps, and resources.
- You want to delegate administration of Retool to a distributed set of admins, based on the apps they’ll be overseeing.

See the guide to [governance on Retool](../concepts/governance.mdx) to learn when to use Retool Spaces, multiple instances, and permission groups.

## Initial setup and Admin Space

Navigate to **Settings > Spaces** to enable Retool Spaces. This sets up Retool Spaces and provisions SSL certificates, which typically takes around five minutes. Once it is finished, you can begin to create spaces.

By default, new self-hosted Retool instances are configured with one space. This space looks and behaves exactly the same as a new instance without spaces—you spin up the instance, and then create the first account, which becomes its admin, in this space. The first space is the **Admin Space**. If you're self-hosting Retool, when you upgrade an existing instance to a version with spaces, the existing organization becomes the **Admin Space**.

If you anticipate needing multiple spaces, consider keeping the **Admin Space** free of apps, and use it only for superadmin responsibilities.

## Create spaces

Admin users of the **Admin Space** can create and manage spaces from **Settings > Spaces**, or use the [Retool API](../../api/index.mdx). Each space must have a name, description, and associated subdomain. You can choose to automatically copy over SSO, branding, and theme settings from the current organization.

### Configure domains

The domain of your **Admin Space** does not change. If the domain on which you enable Retool Spaces is `example.retool.com`, every other space is automatically located as a subdomain (for example, `testing.example.retool.com`).

You can [change the subdomain](../guides/cloud/change-subdomain.mdx) or create a [custom domain](../guides/cloud/custom-domains.mdx) for any space after it's created.

If you're self-hosting Retool, the domain of each space must point to the current instance and have a correct SSL certificate. Users can navigate directly to the space using this domain.

:::note

To avoid configuring a domain for each new space, you can set up a wildcard subdomain in your DNS settings—for example, `*.retool.mycorp.com`—and secure it with a matching wildcard SSL certificate. You can then create new spaces with arbitrary subdomains that match the wildcard without having to update your DNS again. You can set any level of subdomain—for example, `*.mycorp.com`, `*.retool.mycorp.com`, and `*.retool.prod.mycorp.com` are all possible subdomains.

Retool expects the domain name to be passed via `Host` header to the backend. If your self-hosted instance has proxy or load balancer in front of Retool backend, make sure it's configured to set `Host` header to the host used in the original request.

Not all Identity Providers support wildcard domains. When setting up SSO for your spaces, make sure your Identity Provider is compatible with wildcards.

:::

### Log in to new spaces

The admin of the new space can log in using the following methods:

- If SSO was copied over for the new space, Retool creates an admin account for this superadmin on the new space. They can use their exisiting SSO account to log in directly to the new space.
- If SSO hasn’t been configured for the space, the admin needs to log in by resetting the password associated with their email address.

You can add users from any permission group to your space, including admin users. However, only admin users of the  **Admin Space** can create new spaces.

## Configure spaces

Admins can customize SSO, invite users, configure source control, and update settings on spaces the same way they update settings on existing organizations.

:::tip

You can also use the [Retool API](../../api/) to programmatically configure spaces. See the [guide](../guides/retool-api/automate-spaces.mdx) for more information.

:::

### Spaces and SSO

Each space has its own SSO configuration, but you can copy existing SSO settings to a new space when you create it. Since each space has a different domain name, you must confirm that a correct callback URL is configured in your IdP. Most IdPs allow you to add multiple callback URLs; you need to add one for each space. Some IdPs, like Auth0, support wildcards in callback URLs.

Okta's Retool integration accepts a single domain name in its configuration, so you need to configure a separate Okta app for each space, or use the generic OIDC or SAML app configuration to provide multiple callback URLs.

Spaces can also use different SSO settings depending on their use cases. For example, a general-purpose space with apps for everyone at your company might use JIT provisioning. A space for use with only a finance team might need explicit user provisioning.

#### SSO settings and environment variables

When you use environment variables to configure SSO settings, those settings apply to all spaces, unless you override them per space from **Settings > SSO**.

This applies to all SSO settings except those used for SCIM provisioning. The `SCIM_AUTH_TOKEN` environment variable only applies to the **Admin Space** and is not supported on other spaces. To use SCIM provisioning on a non-admin space, navigate to **Settings > API**, and create an access token with the `scim` scope.

### Spaces and Source Control

:::warning

To use Retool Spaces with Source Control, ensure you [migrate your apps to Toolscript](/changelog/yaml-serialization-deprecation).

:::

Each space has its own separate [Source Control](../../source-control/index.mdx) configuration, so it can connect to a different Git repository or an entirely different SCM provider. For each new space, you need to set up Source Control to point to the repository that you want to link to the space.

Multiple spaces can also connect to a single Git repository. For example, you might want to use spaces to represent different dev, staging, and prod instances. These spaces function the same as multiple instances connected to the same Git repository—you can choose which branch to point to by default, and sync changes when commits are merged into this branch.

### Spaces and Retool Database

Each space has its own [Retool Database](../../data-sources/quickstarts/retool-database.mdx). If you already configured an [external PostgreSQL cluster](../../data-sources/quickstarts/retool-database.mdx) to use on your self-hosted instance, you can connect the new Space's Retool Database to the same cluster. Each space automatically creates a new database in the cluster.

### Switch between spaces

Users can have accounts in multiple spaces and switch between them. From the navigation bar, users can navigate between the spaces to which they belong. Users must log in to each space separately.

### Copy across spaces

For organizations on the Enterprise plan on Retool Cloud and self-hosted Retool versions 3.41 and later, admins can copy apps, resources, Query Library queries, and workflows across spaces. The following applies to all copied items:

- Copies are unprotected in the destination space.
- Copied resources are created in the destination space's default resource environment.
- All dependencies except environment variables are copied to the destination space. You must configure environment variables in the destination space.
- Releases, permissions, and unit tests are not copied to the destination space.

---

## Administration tutorials

import Tutorial from '/docs/_partials/_doctypes/_tutorial.mdx';

---

## _access Rules

Permission groups use [access rules](../quickstart.mdx#access-rules) that determine the apps, resources configuration, and workflows that members can access. Access rules can also apply to folders in which these are organized.

Select the **Apps**, **Resources**, **Workflows**, or **Agents** tab to configure their respective access rules. The **Select type** option enables you to define specific access by configuring access individually, or apply **Use all**, **Edit all**, or **Own all**.

:::note

Folder permissions are inherited. Giving a user **Edit** access to a folder will also give that user **Edit** access to all of the items within that folder.

:::

---

## _add To Group

Click **Add new members** to add users to the group. You can search the list of users and select multiple users to add. Click **Select all** to select all users currently visible, then click **Add to group**.

---

## _agents Perm Levels

When interacting with an agent, a user is a member of a permission group for both the agent and the resource, and the following rules are observed.

  
     
    **AGENT PERMISSION LEVEL**
  
  
    **RESOURCE PERMISSION LEVEL**
     
    **NONE**
    **USE**
    **EDIT**
    **OWN**
  
  
     **NONE**
     Cannot interact with an agent, cannot call a tool on any resource. 
     Can interact with an agent. If the agent calls a tool that the user does not have permission to use, an error message is displayed.
     Can modify an agent’s configuration, but can only reference a resource in a tool if the user also has permissions to use the resource.
     Can modify an agent’s configuration, delete, and rename the agent, but can only reference a resource in a tool if the user also has permissions to use the resource.
  
  
     **USE**
     Cannot interact with an agent, cannot call a tool on any resource. 
     Can interact with an agent. Can call tools. 
     Can modify an agent. Can add and call tools.
     Can modify, delete, or rename an agent. Can add and call tools.
  
  
     **EDIT**
     Cannot interact with an agent, cannot call a tool on any resource. 
     Can interact with an agent. Can call tools. 
     Can modify an agent. Can add and call tools.
     Can modify, delete, or rename an agent. Can add and call tools.
  
  
     **OWN**
     Cannot interact with an agent, cannot call a tool on any resource. 
     Can interact with an agent. Can call tools. 
     Can modify an agent. Can add and call tools.
     Can modify, delete, or rename an agent. Can add and call tools.
  

The visibility of certain tabs within Retool Agents is also limited based on permissions:

 | Tabs             | Use       | Edit           | Own            |
 |------------------| ----------| ---------------| ---------------|
 | Chats            | Access    | Access         | Access         |
 | Configuration    | No access | Access         | Access         |
 | Logs             | No access | Access         | Access         |
 | Evals            | No access | Access         | Access         |

---

## _default Groups

The default groups and permissions differ depending on the plan your organization uses.  All pricing plans have **Admin** and **All Users** groups. Business and Enterprise plan users have more granular control over groups, and can create their own [custom groups](#custom-permission-groups). 

The following built-in permission groups cannot be modified or removed, and the access levels cannot be changed.

| Group         | Apps | Workflows | Agents    | Resources |
| ------------- | ---- | --------- | --------- | --------- |
| **All Users** | Edit | Edit      | Edit      | Own       | 
| **Admin**     | Own  | Own       | Own       | Own       |

The following built-in permission groups cannot be modified or removed. These are preconfigured with default permission levels, which can be updated by an admin.

| Group         | Apps | Workflows | Agents    | Resources |
| ------------- | ---- | --------- | --------- | --------- |
| **All Users** | None | None      | None      | None      |
| **Viewer**    | Use  | Use       | Use       | Use       |
| **Editor**    | Edit | Edit      | Edit      | Own       |
| **Admin**     | Own  | Own       | Own       | Own       |

:::note

For organizations created before Retool version 3.259.0, the **All Users** group had **Edit** access to apps and workflows, and **Use** access to resources. [Read more in the changelog entry](/changelog/updated-permissions-for-all-users).

:::

---

## _perm Groups

:::info Availability

Custom permission groups are not available on the Free plan.

:::

Organization admins can use permission groups to restrict users from accessing certain apps, workflows, or connected resources. 

App owners and admins can also use [direct sharing](../guides/app-permissions/share-apps.mdx) to share apps with users, independent of permission groups.

---

## Manage permissions for Retool Agents

There are three objects that are relevant from a permissions standpoint: the agent, the tool, and the resource. 
* Agents have **Use**, **Edit**, or **Own** permissions.
* Resources have **Use**, **Edit**, or **Own** permissions.
* Tools are not independently permissioned, they are implicitly permissioned based on the agent that contains the tools.

To use an app that calls an agent, you also need to have **Use** permissions on the app.

## Folder permissions
For a user group to see all of the agents in an organization from their [All agents page](../../agents/quickstart#all-agents), an admin must grant them **Edit all** or **Own all** access for agents.  

1. Navigate to **Settings > Permissions**.
2. Select a permission group.
3. Select the **Agents** tab.
4. Choose **Edit all**. 

Before a user can create and edit agents, an admin must [configure their permission group](../guides/configure-permission-groups#configure-permission-groups-for-a-user) so that they have either **Edit** or **Own** permissions on an agent folder.  

* **Edit** permissions on an agent folder allow users to create new agents within the folder, view and edit the configuration of agents in the folder that they have edit access to, and use agents they have edit access to in creator mode. 
* **Own** permissions on an agent folder allow users to do everything they can do with **Edit** permissions, as well as move, delete, or rename agents within the folder. 

Permissions are not necessarily inherited to the agents within folders. Admins can choose to provide user groups with **Edit** permissions on a folder, and restrict access to an individual agent within a folder. 

## Individual agent permissions
An agent is permissioned like an app or workflow. Refer to [Permissions for Apps](../guides/app-permissions) for more information about permissions within apps.

* **Use** permission for an agent will allow a user to view it from `/agents`, and access only the **Chat** tab.
* **Edit** permissions allow a user to view and edit the configuration of an agent, and use the agent in creator mode.  
    :::note
    You can only edit the configuration of an agent if you have the necessary permissions to all tools used by the agent (e.g., **Use** for workflows, **Edit** for resources and MCP).
    :::
* **Own** permissions allow a user to edit an agent’s configuration, including moving or deleting the agent.

## Permission groups

Agents are available in the `/settings/permissions/group/{group_id}/group-name` page as a top-level, permissionable object.

You can define access for agents at a group-level in **Settings > Permissions**.

A permission group may have **Use**, **Edit**, or **Own** permissions on an agent.

### Use
A member of a permission group with **Use** access to an agent may:
* View the agent (including **Name**, **Description**, and version history).
* Access the chat tab of the agent on `/agents/{uuid}`.
* Create new chat threads and messages with the agent.
* Have tool calls executed on their behalf if they have **Use** permissions on the underlying resource(s) for the agent.
    * If users don’t have the required permissions to a resource, Retool throws an error, which is passed back to the agent.

### Edit
A member of a permission group with **Edit** access to an agent may:
* Build an agent.
* Edit an agent (all editable properties).

### Own
A member of a permission group with **Own** access to an agent may:
* Build an agent.
* Move an agent.
* Edit an agent.
* Delete an agent.
* Rename an agent.

import Agentperms from '/docs/permissions/_partials/_agents-perm-levels.mdx';

 :::note
For more detailed information about the intersection of permission levels between agents and resources, refer to the [Permission levels](../reference/permission-levels.mdx) reference page.
:::

## Admin capabilities
You must have [Retool AI](../../self-hosted/concepts/retool-ai.mdx) enabled for your organization to be able to use Retool Agents.

Retool Agents can be globally enabled or disabled for a given organization in **Settings > Retool AI > AI Agents**.

An admin of your Retool organization can enable Retool Agents in **Settings > Retool AI > AI Agents**.

:::warning
Exercise extreme caution when disabling **AI Agents Sharing**, as it will immediately unpublish all currently shared threads from your organization. This is a security feature in place to prevent unauthorized public sharing of sensitive information. Toggling **AI Agents Sharing** back on will not restore sharing for any previously-created public threads.
:::

To enable the **Function Generator** for automatic [custom tool creation](../../agents/guides/tools/create-custom-tools.mdx), toggle **AI Agents Function Generation**.

## User consent handling

Consent is different from access control. Consent assumes that the agent has the permission level to execute the tool, but it is a validation step that the parameters passed into the tool are acceptable.

To require confirmation before an agent uses a tool, on the **Edit Tool** page, select the checkbox for **Require user confirmation before use**.

Check the box to **Require user confirmation before use** on the **Edit Tool** page.

When an agent is triggered via chat or from an app, tools requiring consent will prompt you for approval within the chat interface.

Tool requiring approval within the agent chat interface.

When an agent is called from a workflow, only tools that do not require consent will be accessible. Similarly, [agents invoked by another agent](../../agents/guides/tools/use-agent-as-tool.mdx) will not be able to access tools that require consent, even if the parent agent was called via chat.

---

## Configure draft app permissions

The **Drafts** tab of a user's Apps landing page is a personal folder for each user to develop and test apps. For more information, refer to the [Administration Quickstart](../../../org-users/quickstart.mdx#drafts).

**Drafts** are enabled by default. Admins can toggle off this feature by navigating to **Settings** > **Beta** and turning off **Drafts folders**.

## Manage permissions for draft apps {#draft-apps}

Admins can control which permission groups can create draft apps. To toggle this option:

1. Navigate to **Settings > Permissions**.
1. Select a permission group.
1. Select the **Additional** tab.
1. Toggle **Allow creating draft apps** on or off.

When enabled for a group, users in that group can create apps that are stored in their own draft folders. Disabling this option prevents all users in the group from creating drafts.

---

## Manage permissions within Retool Apps



---

## Manage per-page permissions in multipage apps

Admins can configure **Use** access to each page of multipage apps.

To do so, create a permissions group and open the **Apps** tab. Click  next to each app to see all of its pages. Select **Use** for each page that you want users in that group to be able to view.

Users who attempt to access a page for which they do not have **Use** permission are redirected to another page in the app for which they do have access.

:::note

Per-page **Edit** or **Own** permissions are not available.

:::

## Configure page permissions with Source Control

In order to support per-page permissioning, Retool added a universally unique identifier (UUID) for each page. Before you configure per-page permissions for an existing app that is [protected with Source Control](../../../source-control/guides/protect/apps.mdx), first create a new branch with no changes and push it to Source Control. If your version of Retool is later than 3.191-edge, Retool automatially creates a migration commit that adds UUIDs to each page.

Once you merge this commit, you can successfully configure per-page permissions on your protected app.

:::note

If you are working on more than one branch before the UUID addition in version 3.191-edge, Retool runs the migration on each of those branches, and the branches will end up with different UUIDs. Make sure add UUIDs only once, do not override the UUIDs on the `main` branch after adding them. Doing so results in the inability to set per-page permissions, because the IDs initially set on `main` are the ones that Retool will use.

:::

---

## Sharing apps with users and groups

When **Allow app owners to manage permissions** in **Settings > Advanced** is enabled, app owners can directly share apps with individual users and groups.

Once enabled, app owners can use the **Share** modal to share an app with any member of their organization. They can set the access level—**Use**, **Edit**, or **Own**—for the given user or group. Admins can also invite users to their organization and give them direct access without creating a new permission group. App owners can only share with existing users in their organization.

In the **Share** modal, app owners can view all users who have access granted through direct sharing. Admins can view all users with access, including those granted access through permission groups.

---

## Configure permission groups

You can manage permission groups in the **Permissions** settings for your organization. You can use built-in permission groups or create your own custom groups.

### Default groups

import Default from '/docs/permissions/_partials/_default-groups.mdx';

### Create a custom group

import Addgroup from '/docs/permissions/_partials/_add-to-group.mdx';

To remove a user:

1. Hover the cursor over the specified user.
2. Click the **•••** button to open the contextual menu.
3. Select **Remove from group**.

## Configure permission groups for a user

You can configure the permission group membership for individual users from the **Users** organization settings. This page lists all enabled users in your Retool organization and the permission groups to which they're a member. You can search and filter users with different criteria, such as name or last active.

Select a user from the list to display their details. The **Permissions** section lists the groups they belong to, along with the apps, resources, and workflows they can access.

Click **Groups** to modify group membership. You can add groups to the list by entering the group name. The groups list autocompletes and also presents a dropdown menu of lists to select.

## Configure access rules for a permission group

import Access from '/docs/permissions/_partials/_access-rules.mdx';

## Control access to resource environments

Admins for organizations on the Business or an Enterprise plan can configure different access levels to [resource environments](../../org-users/guides/configuration/environments.mdx) in the **Permissions** tab. This is useful if you need to restrict access to production data but still want to allow access to other environments, such as staged data.

Access to resources and their environments are controlled by the **Select access type** option. To configure different access for a resource's environments, you must first set this to **Define specific resource access**. Once set, select a resource and click **▶︎** to reveal per-environment access control. You can then change the individual permissions for that resource's environments.

Configure per-environment access for a resource.

---

## Restrict access with the current_user object

The [current_user](../../apps/reference/objects/current-user.mdx) object contains metadata about the currently logged-in user. This includes `groups`, which contains a list of assigned permission groups. You can use this data to restrict access to certain components.

## Restrict access to certain data

You can also restrict access to database records by referencing `current_user` in queries. `current_user.email` uniquely identifies the email address of the user running the query.

For example, you could restrict access to an `employees` table that contains a `manager` field, populated with the manager’s email address, by referencing `current_user.email`:

```sql
SELECT
  *
FROM
  employees
WHERE
  manager = {{current_user.email}};
```

You can also reference `current_user` within a resource's configuration. For example, you can always include `current_user.email` in the request body. Retool organizations integrated with [OpenID SSO providers](../../sso/tutorials/custom/oidc.mdx) also provide identification using `current_user.metadata.idToken`. This provides greater flexibility for restricting access.

See the [Row-level security](../../queries/concepts/row-level-security.mdx) page for information on limiting access to database records.

---

## Configure fine-grained admin permissions

The _Roles and Permissions_ feature enables the use of role-based access control for settings that would normally be available only to admins. This offers greater flexibility than [permission groups](../guides/configure-permission-groups.mdx) and is useful for organizations who want to delegate access of certain settings to non-admin users without the need to grant full admin privileges.

For example, a Design team may need access to an organization's [branding](../../org-users/concepts/branding.mdx) settings so they can manage the branding styles. Rather than give every member of the Design team full admin access, the organization can create a role with **Manage branding** permission and apply it to the Design team's group. The Design team is then able to configure the organization's branding settings while still be restricted from making changes to any other organization settings.

Role-based permissions offer much greater access control than [permission groups](./configure-permission-groups.mdx). Once you configure the necessary roles to control access, you can apply them to any number of groups. Retool will eventually transition to role-based access controls as a permissions management method.

:::info

Only organization admins can configure roles and their permissions.

:::

## Create a role with the required admin permissions

:::tip

Create roles that have only the minimum admin permissions needed. You can create and assign multiple roles to groups so that members receive a combination of their permissions.

:::

A role contains a set of admin permissions that grant access to specific organization settings, such as **Manage Spaces**. Create each role and select which permissions are applicable. Once completed, select the groups to which the role applies. Each user within the group then inherits the role permissions.

To get started, sign in to your Retool organization and navigate to **Settings > Roles & Permissions**. Then, click **Create Role** to create a new custom role.

You define the name and description for each role, and select which permissions to set. You can search through permissions or filter them by type, such as **User management** and **Configuration**. Each permission controls access to a specific settings page within your organization. For example, enabling the **Manage branding** permission allows access to the **Manage branding** settings page.

Toggle the permissions that should apply to the role. The **Permissions preview** pane displays a summary of the role's permissions as you make changes.

Click **Save changes** once you complete the changes to your role. You can return to the role at any time to make further change, if needed.

export function CreateRole() {
  return (
    
      
    
  );
}

## Assign the role to groups

You can assign roles to groups from either the **Roles & Permissions** or **Groups** page.

The **Groups** settings page is where you manage all groups for your organization. To change roles for a group, select the group and click **Modify role assignments**.

export function Groups() {
  return (
    
      
    
  );
}

The **Assignment** tab contains a list of groups to which the role is assigned. Click **+ Add group assignment** to select which groups are assigned the role. You can also click **>** to expand a group and view a complete list of its members.

export function Roles() {
  return (
    
      
    
  );
}

---

## View the access list

For each app, folder, workflow, resource, or agent, you can view the list of users and user groups that have access. When on the listing page for one of these objects, click the **•••** menu and select **View access list**. Use the tabs at the top of the list to show **Users** or **Groups**. The list shows the [access level](../reference/permission-levels) of each user or user group.

The access list for a workflow.

---

## Permissions how-to guides



---

## Permissions documentation

Learn how to set permissions and control user access within Retool.

---

## Permissions quickstart

You can [configure user permissions](../permissions/guides/configure-permission-groups.mdx) to restrict access to apps, resources, and workflows. You add users to [permission groups](#permission-groups) that use [access rules](#access-rules) which determine what members can access.

## Permission groups

import Permgroups from '/docs/_shared/_permission-groups.mdx';

## Access rules

import Access from '/docs/_shared/_access-rules.mdx';

---

## Permission levels

There are three permission levels for apps, resources, workflows, and agents: **Use**, **Edit**, and **Own**.

## Apps, Resources, and Workflows

The following permissions rules apply to apps, resources, and workflows. 

| Permission | Apps                                                                                              | Resources                                                                                            | Workflows                                                                                                   |
| ---------- | ------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------- | 
| **Use**    | Interact with apps only.                                                                          | Access only resources for queries in apps. Create and edit queries against resources in workflows.   | Run workflows only.                                                                                         |
| **Edit**   | Build, edit, delete, rename, release, and export apps. Create, edit, delete, and rename app folders.        | Create and edit queries against resource.                                                  | Build, edit, rename, and export workflows.                                                                  |
| **Own**    | Build, edit, delete, rename, release, move, and export apps. Create, edit, delete, and rename app folders. | Create, edit, delete, rename, and move resources. Create, edit, delete, and rename resource folders. | Build, edit, delete, rename, move, and export workflows. Create, edit, delete, and rename workflow folders. |

## Agents 

import Agentperms from '/docs/permissions/_partials/_agents-perm-levels.mdx';

 :::note
For further permissions management and settings related to Retool Agents, refer to the [Manage permissions for Retool Agents](../guides/agent-permissions.mdx) page.
:::

---

## Permissions reference



---

## Permission group tutorial

This tutorial walks you through how to create a permission group, how to set **Use**, **Edit**, or **Own** access, and how to delete a permission group. 

import Permgroups from '/docs/permissions/_partials/_perm-groups.mdx';

## 1. Navigate to the permissions settings
Click on your user profile icon in the top right-hand corner, and select **Settings** from the dropdown to locate **Permissions**. 

export function ArcadeEmbed1() {
  return (
    
      
    
  )
}

## 2. Create a custom permission group 
To create a new permission group, select **Create new**, give it a name, and select **Create group**. 

import Addgroup from '/docs/permissions/_partials/_add-to-group.mdx';

export function ArcadeEmbed2() {
  return (
    
      
    
  )
}

## 3. Configure access rules for a permission group

import Access from '/docs/permissions/_partials/_access-rules.mdx';

export function ArcadeEmbed3() {
  return (
    
      
    
  )
}

## 4. Delete a permission group
To delete a permissions group, on the **Permissions** page, select the **...** more options dropdown next to the **Edit** button for the group you want to delete. Then select **Delete group** from the dropdown. 

## Next steps
To continue learning about user permissions and user access controls, refer to the permissions [how-to guides](./guides) and [reference materials](./reference).

---

## Retool AI actions

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import Intro from '../../_shared/_actions.mdx'

## Text actions

Use [Text](../guides/ai/text.mdx) actions to generate and analyze text content. You provide an instruction and select the model to use.

The response is made available on the `data` query property. Rather than waiting until the full response is generated, Retool receives the response _stream_. This allows the AI model to immediately respond so you can see the response appear in real time.

### Generate text

The [Generate text](../guides/ai/text.mdx#generate-text) action generates text-based content from the input instructions. This is useful if you need some initial content or sample data. For example, you can generate a product description:

> Write a creative product description for a mechanical keyboard named VelocityX Pro, with the keywords "fast responsiveness", "ergonomic", "gaming-optimized" for a software developer who enjoys gaming, and describe the benefits of this product in 100 words.

> Introducing the VelocityX Pro Mechanical Keyboard: a winning blend of performance and comfort, expressly designed for the discerning software developer and gaming enthusiast. This marvel of engineering offers lightning-fast responsiveness, delivering an unparalleled key-press experience. Every keystroke is smooth, satisfying and immediate, powering your code-writing and gaming sessions alike. The VelocityX Pro is also ergonomic, thoughtfully crafted to alleviate strain during long coding marathons or intense gaming battles. This gaming-optimized key titan ensures elevated accuracy and speed, designed to keep pace with your agile mind. Finally, the VelocityX Pro suits your dual passion for code and gaming, becoming your ultimate tool for victory.

### Summarize text

The [Summarize text](../guides/ai/text.mdx#summarize-text) action generates a summary of the input text. For example, you can provide the text from a blog post and generate a concise summary:

Retool [blog post](https://retool.com/blog/external/):

> Retool started six years ago as a frontend builder for internal tools. Since we launched, we’ve worked with tens of thousands of companies across every vertical—from two-person startups all the way to Fortune 10s. We focused on making it as fast as possible for developers to build internal apps so that they don’t have to start from scratch to build the same patterns of admin panels, CRUD apps, frontends for APIs, automations, etc.[...]

> Retool, a frontend builder for internal tools, is introducing new products aimed at also supporting external use cases. The new offerings, Retool Portals and Retool Embed, were designed to help developers create dashboards, workflows and features for external users such as contractors, vendors, partners, or chosen customers. These external users often have close relationships with the company but aren't employed by it. The new tools will allow companies to simplify processes by automating many tasks that are typically done manually. These features are now available on a Business or an Enterprise plan.

### Classify text

The [Classify text](../guides/ai/text.mdx#classify-text) action analyzes the input text and classifies it based on the specified labels. This can be useful if you need to perform sentiment analysis or categorize customer requests in some way.

> I was pleasantly surprised by the water bottle's elegant design and excellent insulation, which kept my water cool for an extended period.

Classification labels: `positive`, `negative`, `neutral`

```json
{
  "data": "positive"
}
```

### Extract entity from text

The [Extract entity from text](../guides/ai/text.mdx#extract-entity-from-text) action analyzes the input text and identifies information based on the specified entities. For example, you can extract the `product` name and `Return address` entities from the following message:

> Dear Mandy,
>
> Your return request for the product, LunarStride Pro, has been declined due to not meeting the required condition for acceptance. We will be shipping this back to 1234 Elm Street, Springfield, CI 56789.

```
{
  "Product": "LunarStride Pro",
  "Return address": "1234 Elm Street, Springfield, CI 56789"
}
```

## Chat actions

Use [Chat](../guides/ai/chat.mdx) actions to generate message responses based on context from the conversation history and any additional provided data. The **Chat** component for web apps has built-in support and automatically creates an AI Action query to generate chat responses.

### Generate chat response

The [Generate chat response](../guides/ai/chat.mdx#generate-a-response) action can respond to conversations with users based on the messages previously sent. You can use this action to [create an AI chatbot](../../apps/guides/forms-inputs/chats/llm-chat.mdx) on Retool.

The **Message history** requires a JSON array of objects with the following properties:

| Property | Description                                                                                                                                                                                  |
| -------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `role`   | The participant in the conversation. Either `user` for the participant sending messages (i.e., the user) or `assistant` for the participant responding to messages (i.e., the AI responses). |

```

[
  {
    "role": "user",
    "content" "hello"
  },
    {
    "role": "assistant",
    "content" "hello"
  },
]

```

## Document actions

:::info Not available in Workflows
Document actions are only available in Retool apps.
:::

Use [Document](../guides/ai/document.mdx) actions to parse and analyze text from documents you upload or are available in a data store, such as [Amazon S3](../../data-sources/guides/integrations/object-file-store/amazon-s3.mdx).

### Convert document to text

The [Convert document to text](../guides/ai/document.mdx#convert-document-to-text) action analyzes the contents of a file and returns the text it contains. You can connect the action to a File Input component or reference a file using `{{ }}` notation, such as a file retrieved from a data store.

The AI model processes the document, extracts the text, and returns it in the response.

## Image actions

Use [Image](../guides/ai/image.mdx) actions to generate images based on the provided input.

### Generate image

The [Generate image](../guides/ai/image.mdx#generate-an-image) action produces images based on the input prompt, then returns a base64-encoded PNG image. This can be used as the value for an Image component or downloaded using [utils.DownloadFile()](../reference/libraries/utils.mdx).

> A close up, studio photographic portrait of a white siamese cat that looks curious, backlit ears.

---

## Ask AI and quick actions

Retool can help you build apps and workflows faster with built-in AI functionality:

- [Ask AI](#ask-ai): Write, edit, and fix queries.
- [Quick actions](#quick-actions): Automatically build user interfaces with multiple components connected together.

## Ask AI

import Ask from '../../_shared/_ask-ai.mdx';

### AI query accuracy

AI is not infallible. To help mitigate problems from incorrect queries, Ask AI presents the results for you to accept or reject. If Ask AI modifies an existing query, a comparison is also included.

You should review all changes before accepting or rejecting AI queries. Retool cannot guarantee that queries are always accurate, nor that they would not result in a destructive action (e.g., deletion or incorrect changes). It's ultimately your responsibility to evaluate Ask AI queries before running them.

### Data sharing

Ask AI is powered by OpenAI [GPT models](https://platform.openai.com/docs/models/overview). Retool does not share referenced data nor the results of any AI-generated query with AI partners. Retool does share metadata, including database schema, so that Ask AI can function effectively. You should not use Ask AI if this metadata is sensitive and must remain confidential.

## Quick actions

Quick actions appear whenever you add certain UI components that commonly require multiple steps to implement. For example, if you add a Table component, you would be presented with quick actions for connecting a data source, adding a search filter, or creating a form to edit table data.

Click **✧** to access quick actions for a component whenever they are available.

---

## Query performance best practices

It's important to continually monitor the performance of apps and workflows, and make improvements where needed. Performance issues can happen for any number of reasons and can be difficult to replicate, especially when they involve external factors.

Follow these practices to identify, resolve, and prevent query performance degradation to keep apps and workflows working efficiently as possible.

## Allow for additional query overhead

Retool queries add a small amount of overhead to queries (approximately 150ms) when compared to making an API request or querying a database directly. This additional overhead allows Retool to:

- Download results
- Transform data using JavaScript
- Assign values to relevant components
- Calculate further dependencies

This overhead shouldn't have any noticeable affect and may only be apparent when compared to a direct request.

## Separate query logic to reduce round trips

If you have many similar queries (e.g., multiple queries for the same database table), consider using [query JSON as SQL](../guides/sql/query-json.mdx) or JavaScript [transformers](../guides/transformers.mdx) to reduce the number of requests sent to your resources. These allow you to query a resource once, and then further manipulate or transform the data as needed.

## Limit the number of queries that run automatically

You can configure apps to run queries on page load or whenever there's a relevant input change. While this can help keep your app updated, users cannot fully interact with the app until those queries are complete, making the app feel unresponsive for a short time.

Limit the number and size of queries that run automatically. Use [event handlers](../../apps/guides/interaction-navigation/event-handlers.mdx) to trigger queries under certain conditions or use [watched inputs](../guides/advanced-options.mdx#watch-inputs) to run the query automatically when certain inputs change.

In addition, consider the following alternatives which can help reduce query run frequency.

### Configure query run delay

You can add a delay to queries so that a minimum amount of time must pass before a query runs automatically. Configure the **Delay between runs** option in the **Advanced** tab. Whenever the query is triggered, it runs only when the specified amount of time has passed. For example, a delay of `5000` would result in a query waiting 5 seconds before running again.

### Table filters and search

If you display data using a [Table](../../apps/guides/data/table/index.mdx) component, the built-in filters and search options can provide you with similar functionality. These features function client-side, reducing the need to make repeated requests to a database (e.g., filter to show only active customers or search for a product name).

### Query JSON with SQL

You can use the [Query JSON with SQL](../guides/sql/query-json.mdx) resource to query JSON data using SQL statements. This allows you to query existing data from other queries, such as retrieving a subset of data.

### Transform results

[Transformers](../guides/transformers.mdx) allow you to perform real-time transformation of data using JavaScript. You write JavaScript statements that transform or filter referenced data based on your criteria.

You can either create a separate transformer that references other query data or directly transform the results of a query using the **Transform results** settings.

## Use query caching to your advantage

You can [cache query results](./caching) for a specified period of time to reduce the number of queries to a resource. You can also [cache queries for users across your organization](./caching#how-query-caching-works). If you’re running large analytical queries, or don't need immediate data, consider using caching to improve performance.

For example, if you cache a query and 100 users run the query within the cache duration, your resource is accessed only once instead of 100 times. After the first query, the following 99 queries return significantly faster. Depending on your use case, even a 5-10 minute cache can prevent extraneous round trips.

Be careful of stale data, and programmatically [invalidate the cache](./caching#invalidate-the-cache) when updates are made.

## Retrieve only required data from large data sets

Rendering thousands of rows of data into a table impacts browser performance. Instead of loading large amounts of data, consider transforming or filtering data in the query. Many APIs support pagination, so you can filter responses to only return data you need. The [Table](https://retool.com/components/table) component supports using server-side pagination to allow for more specific data requests.

## Put complex logic in workflows or backends

Overuse of complex JavaScript can impact the Retool frontend (the part of the app with which users interact). If you need to perform complex logic or querying of data, avoid doing this solely with JavaScript. Put this logic into the Retool backend (the part of the app that interacts with resources), or use [Retool Workflows](../../workflows/index.mdx).

---

## Query caching

Retool provides support for caching query results, allowing users to better manage their data. By caching query results, you can speed up the performance and load speeds of an application.

Query caching is most helpful in cases of:

- Expensive database queries on slow updating datasets. Running an aggregation query over months of event data can be expensive and slow. Caching the results of these queries means expensive queries run less frequently and results load faster.
- Database or API queries that return a very large amount of results. Querying your database for 5,000+ rows of data can be very resource-intensive for your application. Caching the results can free up the time and resources that the query would originally have used.

Caching is not recommended for transactional queries. If your data is updating in realtime, via an upstream source or Retool app actions, caching increases the likelihood that your users will see stale, incorrect data.

## How query caching works

When enabled, queries are cached server-side inside of the Retool database connector. Whenever a query is run, Retool checks the inputs and cache duration lifespan to determine whether to return cached results or route the query to your database.

If the exact same query is run using the same inputs within the **Cache duration** lifespan, the cached result is returned rather than querying the resource. If the cache lifespan for the specific query and input combination has expired or the cache has been invalidated, the query is routed to the resource.

By default, the cache is shared across users in the same organization. If two users run a query with the same requests—even with different auth tokens—the cached results are still returned.

Administrators can disable **Cache queries across all users** in your organization's [Advanced](https://login.retool.com/auth/login?source=docs&redirectOnLogin=settings/advanced) settings to perform caching on a per-user basis instead.

## Use query caching

Caching is set at the query level. Check **Cache the results of this query** in the **Advanced** tab of the query editor to turn on caching for a specific query. You must specify the number of seconds the query should be cached for (e.g., `3600` for one hour).

### Monitor the cache

You can use cache-related [query properties](../reference/objects/query.mdx) to determine if a cached result was used, when the cached results were fetched from the resource and whether the next run will hit the cache.

| Property                           | Description                                                                                                                                                                                                             |
| ---------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `query.servedFromCache`            | Boolean indicating whether query results were returned from cache.                                                                                                                                                      |
| `query.lastReceivedFromResourceAt` | Unix timestamp in milliseconds when the query result was last received from the resource.                                                                                                                               |
| `query.cacheKeyTtl`                | The cache duration in seconds, referenced as the TTL (Time to Live) time. If `query.lastReceivedFromResourceAt + (query.cacheKeyTtl * 1000) > Date.now()` the next run will query the resource and cache fresh results. |

### Invalidate the cache

You can use the [invalidateCache()](../reference/objects/query.mdx#invalidatecache) JavaScript method to invalidate the cache before the TTL runs out. You can also use [event handlers](../../apps/guides/interaction-navigation/event-handlers.mdx) to invalidate the cache by selecting the **Control query** action and **Clear cache** method.

## Configure the cache for Self-hosted deployments

### Redis caching

Without a Redis-connected resource, the cache is stored on the local file system of the Retool server. The cache can be invalidated if the Retool worker stops running which may cause in-memory and file system caches to be wiped.

With a Redis-connected resource, the cache is stored within Redis instead of the file system, and is automatically set up once connected. This enables greater flexibility around caching behavior and also gives you visibility on how data is stored.

Refer to our documentation on [environment variables](../../self-hosted/reference/environment-variables/redis.mdx) to view Redis-specific variable information. Once set up and connected, Retool automatically leverages the Redis instance as a caching layer for queries with caching enabled.

### Connect Retool to Redis on AWS ElastiCache

1. Log in to the AWS console for your appropriate region.
2. Create an Amazon ElastiCache cluster.
3. Choose Redis as your cluster engine. Do not enable cluster mode. Cluster mode will handle spreading keys across multiple shards. By default, the Redis shard should be able to store 13GB of data which is substantial.

4. Enter the name and description of the cluster. Leave the rest of the fields as-is.

- **Port**: 6379 by default. A [custom port](https://www.cloudconformity.com/knowledge-base/aws/ElastiCache/default-port.html) can be specified as an additional layer of protection though for most use cases is not required.
- **Node type**: Large by default. Automatically set to be able to store 13GB of data.
- **Multi-AZ**: True by default. Multi-AZ is especially useful when we have strong high availability requirements for the use case (many users, critical workflow). Redis is usually highly available even without this feature as long as we replicate to at least 2 nodes.
- **Number of Replicas**: 2 by default. This will replicate the data into 2 other nodes as well.

:::tip

In the event that the primary node for the cluster fails, Multi-AZ ensures that it follows protocol to assign a new primary immediately (taking the read replica with the fastest recorded latency times). For small or medium use cases, or for testing purposes, you can set this to `false`. You can change this retroactively by modifying the replication group.

:::

5. Advanced Redis Settings: Ensure we are under the same VPC for this Redis instance as the instance where Retool is deployed. Otherwise, the two will not be able to communicate. For Multi-AZs, we need to provide two subnets.

6. Data Management: **Enable automatic backups**. This is optional but highly recommended. If you experience unexplained issues, you can retrieve the previous backup.

7. Create Cluster.

#### Monitor the Redis instance

1. Log in to the Retool instance (or create a new one in the same VPC as both Retool and Redis) and enter the following commands.

```shell
sudo wget http://download.redis.io/redis-stable.tar.gz

sudo tar xvzf redis-stable.tar.gz

cd redis-stable

sudo CC=clang make BUILD_TLS=yes # only if TLS is enabled
```

2. Read the Redis instance by running either of the two commands below. The cluster endpoint should be the reader hostname. The port number should be the port number entered above (by default, it is 6379).

```shell
# If no password is setup, run:
redis-cli -h  -c -p 

# Otherwise...
redis-cli -h  --tls -a  -p 
```

3. Once in the Redis CLI, run some `get` and `set` commands to verify expected behavior. Running the `INFO` command displays stats for the Redis cluster.

---

## JavaScript

When building apps in Retool, anything inside `{{ }}` is JavaScript. You can use it to access variables custom to your app, as well as globals provided by Retool. You can also write custom JavaScript to manipulate data.

For security purposes, all JavaScript runs in a separate iframe, on a different domain. This is to prevent JavaScript injection, such as cross-site scripting (XSS) attacks.

## Common Use Cases

### Manipulating Data

Because anything inside of `{{ }}` is just JavaScript, you can manipulate the variables in Retool. Let's say you want to make a string lowercase, just write `{{ textinput1.value.toLowerCase() }}`. Adding 100 to a value would just be: `{{ textinput1.value + 100 }}`. Making a date show up in the format you want using `moment` would just be: `{{ moment(table1.selectedRow.date_column).format('YYYY-MM-DD') }}` .You can even do more complex things, like map over an array of objects, and pick out one of the fields: `{{ query1.data.map(i => i.name) }}`.

Because it's all JavaScript, Retool can handle any JSON shape returned by databases and APIs. Just write a quick 1-liner to transform data.

### Complex JavaScript

If you want to write multiple lines of code we suggest using [Transformers](../guides/transformers.mdx) rather than writing them in-line in `{{ }}`. This is useful if you want to do things like filter, transform, and even join different data sets. Here's an example transformer that takes the results of a database query, filters out for approved users, and returns an array with their `credit_amount` multiplied by 10:

```javascript
var users = {{ query1.data }};
var approvedOnly = users.filter(i => i.approved === true);
var amountsTimesTen = approvedOnly.map(i => i.credit_amount * 10);
return amountsTimesTen;
```

### Run JS Code (Perform custom behavior using JavaScript)

You can also manipulate the components in your Retool app programmatically, by [Scripting Retool](../guides/javascript/index.mdx). Rather than doing this in Transformers, you should create queries of type `Run JS Code`.

For example if you want to iterate over a CSV file and call an API for every row in the CSV, you could do something like this:

```javascript
// map through every row of a csv file and call an API
return Promise.all(
  filepicker1.parsedValue.map((row) => {
    return apiQuery.trigger({
      additionalScope: {
        id: row.id,
      },
    });
  }),
).then((results) => {
  return results;
});
```

## Variables

All of the components and queries have names: for example, `textinput1`, or `query1`. And all of them are globally available on the page you're in, so you can refer to them elsewhere on the page: for example, `{{ textinput1.value }}` or `{{ query1.data }}`.

For example, set the `value` of a `Text` component to be `{{ table.selectedRow.first_name }}`, and the `Text` component will change based on the selected row of the `table`.

But we give you other variables too, including libraries like like [Lodash](https://lodash.com/) (`_`), and [Moment](https://momentjs.com/) (`moment`), as well as variables that represent the email of the currently logged in user (`current_user`), the current URL and its parameters (`url`), and the browser's localStorage.

## Exploring objects using the State window

If you want to see a list of all available variables on a page, open the **State** window from the bottom left panel. From there, you can view all the components, queries, and other global variables available. Anything you can see there can be accessed in Retool.

| Section         | Description                                                                                                                               |
| :-------------- | :---------------------------------------------------------------------------------------------------------------------------------------- |
| Temporary state | This section lists the variables used in your app and the associated details. Variables enable you to temporarily store your app's state. |
| Components      | This section lists the components used in your app layout, and the associated component details.                                          |
| Queries         | This section lists the queries used in your app and the associated query details.                                                         |
| Globals         | This section lists the global variables used in your app and the associated variable details.                                             |

:::tip Debugging

If code within `{{ }}` isn't working, try using the **State** window to debug the issue.

:::

---

## Query performance

:::tip Query timeline
You can also use the **Query Timeline** in the [debug toolbar](../../apps/concepts/debug-tools.mdx) to visualize and identify long query run times, duplicate queries, and chained queries.
:::

Complex queries or those retrieving large amounts of data can affect the performance of apps and workflows. Retool provides details about the performance of queries and breaks down these measurements between the backend and frontend. 

Queries display the total runtime in the query editor once they complete. Place the cursor over the runtime to display a popover menu with a breakdown of performance.

The lifecycle of a query is shown in the diagram below.

* **Transfer data**: The latency between the client browser and the Retool DBConnector service. 
* **Execute resource**: The latency between the Retool DBConnector service and the end-user resource. 

## Total time

The total time for the query to execute and receive a complete set of results.

## Prepare query

The time taken to calculate all inputs to a query in the Retool frontend, format the request, and then send it to the Retool backend to make a request to the resource.

## Backend

The time taken by the Retool backend to execute the query with the resource, and transfer data to and from the Retool backend. It includes the following measurements.

| Measurement          | Description                                                                                                                                                                                                                                                                                                                                                       |
| -------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Execute resource** | The time taken by the Retool backend to prepare the query, execute it with the resource, and receive the response. Network latency between Retool and the resource, along with the time taken by the resource to perform the request, can impact the time taken. Larger queries and responses require more bandwidth and can be more affected by network quality. |
| **Transfer data**    | The time taken to transfer the query and results between the Retool backend and frontend.                                                                                                                                                                                                                                                                         |

## Frontend

The time taken by the Retool frontend processing the query results. It includes the following measurements.

| Measurement         | Description                                                                                                                                                                                                                                                                                                                                                                                      |
| ------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **Handle response** | The time taken to receive the query response in the Retool frontend and populate the query's `data` property in the app's data model                                                                                                                                                                                                                                                             |
| **Transformer**     | The time taken processing the query's original `data` property using your attached transformer and returning a result. This statistic only appears if the query has a query transformer attached and enabled. More complex transformers with many recursive iterations or additional data references take longer to process.                                                          |
| **Post-processing** | The time taken to update all dependencies inside of the Retool app that reference properties of this query. For example, a [**Table**](https://retool.com/components/table) component that displays `{{query2.data}}` or a [Text Input](https://retool.com/components/text-input) component that displays `{{ query2.data[0]name }}`. The more dependencies to update, the longer this can take. |

## Response size

The total size of the payload received. Larger payloads result in longer processing times in both the Retool backend and frontend.

---

## Prepared statements

Retool converts SQL queries into prepared statements. This makes queries run more efficiently and prevents SQL injection attacks. Since most databases do not support dynamic column or table names in prepared statements, you generally cannot use `{{ }}` embedded expressions to dynamically specify columns or tables.

## How it works

A prepared statement separates the query code from the values it references. This allows the query to be reused with different values without the database needing to recompile the query each time. Instead, the database can use the same pre-compiled query and use different values whenever it's run. 

In addition, this prevents any code, malicious or accidental, from performing destructive actions, such as `DROP TABLE`. 

## Dynamic values

The following example uses a `{{ }}` embedded expression to reference a value when retrieving a list of users. As a prepared statement, the query successfully runs with the dynamic value.

```sql
SELECT id, name, subscription
FROM sample_users
WHERE expiration 

```sql
select id, first_name, last_name
from users u
where u.id = {{ numberInput1.value }};
```

```sql
select id, first_name, last_name
from users u
where u.id = '{{ numberInput1.value }}'
```

Consult your database documentation on prepared statements to confirm expected usage.

---

## Query Library

The Query Library lets you create, run, and share queries across your organization and between Retool apps. Queries in the library are similar to functions in JavaScript—you can define variables in them and they return a result. You can then “call” this query inside and across multiple Retool apps, so that you’re not copy pasting the same query everywhere.

## Features and use cases

Query Library supports:

- Writing a query for any resource (SQL, Firebase, REST, etc.)
- Sharing your queries with the rest of your organization
- Defining variables for your query that you can use when importing it in apps
- Maintaining and rolling back to a previous version of your query
- Running queries in [different environments](../../apps/concepts/debug-tools.mdx#query-library)
- Downloading the results of a query as JSON or CSV

Example use cases:

- Writing a SQL statement and sharing the link with your coworker
- Writing a query that’s used across multiple Retool apps
- Checking out an older version of a complicated SQL query
- Storing a SQL snippet for later reference

## Permissions

Retool admins can configure who has access to the Query Library using permission groups. Note that currently, anyone given access to the Query Library has read and write access. Navigate to the permission group in Retool and select the **Additional** tab to set these permissions.

All queries are private when created. While private, they can only be read and updated by the creator. Users can choose to Share a query, which makes it accessible to the entire organization. You can only delete private queries, and after sharing a query, you can't make it private again.

:::note

Users only have access to queries if they have access to the resource used in the query. This holds true for shared queries as well.

:::

## Version history and source control

Every time you save a query, Retool stores a snapshot, similar to a commit. You can click the **Saved on** text in the bottom right corner to view the history, see the differences between saves, and revert to a specific version. Both SQL-based and non-SQL resources have version history, but only SQL resources show a line by line diff of the changes.

:::note

When you select a specific version of an imported query in your Retool apps, you can use this history view to verify the differences.

:::

If you use Source Control, you can also [protect queries](../../source-control/guides/protect/queries.mdx) to track changes and share queries across Retool instances.

## Reusable queries

You can import shared queries from the Query Library into your Retool apps. This lets you avoid repetition and maintains a single source of truth for your organization. For example, instead of copy pasting the same query on monthly revenue into each app, you can maintain one in the Library.

By default, when you import a shared query into an app, it syncs with the latest version. You also have the option to choose a specific version instead.

For more details on reusing queries, [check out this guide](../guides/query-library.mdx).

## Variables

Variables let you avoid hardcoding pieces of your queries, the same way you can inside a Retool app. In your app you might use `select * from users where id = {{ textinput1.value }}`, but in the Library, there are no other objects to reference. So, the Query library extracts unknown words inside `{{ }}`. In this case, you might write `select * from users where id = {{ user_id }}`, and the Library would pick out `user_id` and display it on the right.

Note that like in the regular Retool app, you can use JavaScript inside `{{ }}`.
For example, you can:

- Write expressions like `{{ parseInt(user_id) }}`
- Write queries like `select * from users where status = {{ age > 65 ? 'retired' : 'working' }}`
- Use libraries like `moment` or `numbro` inside `{{ }}`

For details on how variables work with Reusable queries, check out this guide on [reusing queries](../guides/query-library.mdx).

---

## Row-level security

Row-level security in Retool lets you manage access to specific rows within database tables. It ensures that users can only see and interact with data that they are authorized to access. In Retool, you can implement row-level security by referencing properties of the current user accessing the app in your Resource queries.

## Implement row-level security

Below is an example for how you can implement row-level security by referencing the Retool user's email in queries against your resources. This example assumes you maintain a mapping table from user emails to groups.

The `orders` table below contains order information for different clients (Retool users). The `group_id` designates the client assigned to each row.

| id  | group_id | description |
| --- | -------- | ----------- |
| 1   | 1        | order 1     |
| 2   | 1        | order 2     |
| 3   | 2        | order 3     |
| 4   | 2        | order 4     |
| 5   | 3        | order 5     |
| 6   | 3        | order 6     |

The `user_groups` table maps Retool users to groups. Within a Retool app, when Alice selects data from the `orders` table, Alice should only see the first two rows.

| user_email        | group_id | name  |
| ----------------- | -------- | ----- |
| alice@example.com | 1        | Alice |
| bob@example.com   | 2        | Bob   |
| jane@example.com  | 3        | Jane  |

To achieve this, you can apply a filter using an inner join.

```sql
SELECT        *
FROM          orders as a
INNER JOIN    (SELECT group_id from user_groups where user_email = {{ current_user.email }}) as b
ON            a.group_id = b.group_id
```

The request passes the request from the client to Retool's server, and the query is evaluated with prepared statements on Retool's backend before being executed on the database. The result is returned along the same path. 

To ensure that the client cannot intercept the initial request and insert a different user’s email, [prevent query variable spoofing](../quickstart.mdx#query-variable-spoofing-prevention) is on by default. This ensures that the parameterized statement that arrives at the server contains the same `current_user.email` as the client that's logged in.

## Use user attributes

Rather than maintaining a mapping table, you can use [user attributes](../../org-users/guides/user-management/user-attributes.mdx) to store foreign keys directly on the current user. This prevents the need for additional `JOIN`s, which improves query performance and maintainability while keeping your data secure.

## Additional security

To ensure the security of the request passing from the server to the database, you can take several approaches. Deploying the server and the database within the same virtual private cloud (VPC) avoids exposing requests to the public internet. You can also enable encryption communication between the server and the database using SSL certs.

This architecture has two advantages:

- Because the database filters the result, unfiltered data isn't sent over the network. This minimizes the amount of data exposed over the network, so if there is a security breach, less data is at risk.
- Latency is also reduced because the data transmitted over the network is minimized.

---

## Queries and code concept guides

import Concept from '/docs/_partials/_doctypes/_concept.mdx';

---

## Advanced query options

The following options are available in the query editor's **Advanced** tab. Many query options can help you improve your [app's performance](../../apps/concepts/best-practices.mdx). Read about [best practices](../concepts/best-practices.mdx) to learn how to optimize queries.

## Exclude parameters from audit logs

Queries and their parameters are logged in the [audit logs](../../org-users/guides/monitoring/audit-logs.mdx) when they're run. You should hide sensitive parameters, such as API keys, from your audit logs. Add sensitive parameters to the **Disable logging for** field on the **Advanced** tab in the query editor. In the audit logs, these parameter values display as `--blacklisted-by-developer--`.

## Query throttling

If app performance is slow, it might be because your queries are refreshing too frequently (e.g., on every keystroke). To solve this, you can throttle queries so they runs less frequently. The default is `750ms`.

## Query timeout

Retool automatically times out queries that run for longer than 10 seconds (`10000ms`). You can adjust the **Timeout after** duration for queries on an individual basis in the **Advanced** tab of the query editor. For Retool-hosted users, the maximum duration before a query times out is 120 seconds (`120000ms`). Self-hosted users can set the `DBCONNECTOR_QUERY_TIMEOUT_MS` [environment variable](../../self-hosted/reference/environment-variables/index.mdx#property-DBCONNECTOR_QUERY_TIMEOUT_MS) to change the maximum timeout value.

## Configure query-specific notifications

There are a few notification settings you can set at the [global level](../../apps/concepts/notifications.mdx#global-notification-settings), but you can also configure notification settings on individual queries. This includes toggling success and failure notifications, but also duration and success messages. You configure these settings from the **Response** tab after selecting a query.

## Keep variable references in sync

:::warning

This setting may introduce performance issues and may not work well with transformers, so use it with caution.

:::

If your query calls a component's `setValue` method, you can ensure future references to the component use the updated value by toggling on the **Keep variable references inside the query with your app** setting. This can be useful if you need to set and use a value in the same query.

## Allow only select users to run resource queries

The **Access controls** settings enable you to restrict resource query usage to specific [permission groups](../../permissions/guides/configure-permission-groups.mdx). If configured, any users who are not a member of a listed group cannot run or trigger the resource query. Click the **Groups that can run this query** and then select the permission groups for whom you want to restrict access.

Restrict access with permission groups.

---

## Retool AI chat actions

import Connectsvg from "/img/icon-packs/bold/interface-geometric-circle-alternate.svg";

You can use the **Retool AI** resource to generate chat responses based on the provided instructions and message history. You can provide text directly in the query, reference existing data from elsewhere (e.g., another query), or use data stored in Retool Vectors.

## Get started

To get started with chat actions for apps, add a new [LLM Chat component](../../../apps/reference/components/special-inputs/llm-chat.mdx). For workflows, add a new [AI Action block](../../../workflows/guides/blocks/ai-action.mdx).

Adding a LLM Chat component automatically creates an AI Action query with **Generate chat response** selected and prefills the input and message history.

1. Add an LLM Chat component to the canvas.
2. Find the newly-created Retool AI query.
3. Optionally, enable **Use Retool Vectors to provide more context to your query**, and choose the vector you want to use. Incorporating [Vectors](../../../data-sources/quickstarts/retool-vectors.mdx) enables the chatbot to generate responses specific to your needs.
4. Select the AI model to use (e.g., **GPT-4**).
5. Click **Save** and then **Run** to perform the action.

The specified AI model then generates a response based on the previous messages and additional input provided.

export function ArcadeEmbed() {
  return (
    
      
    
  )
}

Like all components, you can access LLM Chat [component properties](../../../apps/reference/components/special-inputs/llm-chat.mdx) using JavaScript. For example, LLM Chat components have a `messageHistory` property that contains all messages in the chat log. You can reference specific messages using `{{ chat1.messageHistory[0].content }}`.

Refer to the [LLM Chat guide](../../../apps/guides/forms-inputs/chats/llm-chat.mdx) for more information about this component.

1. Click and drag  to create a new, connected block. 
2. Select **AI Action**.
3. Optionally, enable **Use Retool Vectors to provide more context to your query**, and choose the vector you want to use. Incorporating [Vectors](../../../data-sources/quickstarts/retool-vectors.mdx) enables the chatbot to generate responses specific to your needs.
4. Select the AI model to use (e.g., **GPT-4**).

---

## Retool AI document actions

You can use the **Retool AI** resource to parse PDF documents and extract the text for use elsewhere. Unlike other AI actions, Retool parses the PDF directly—no files or text are sent to an AI model.

## Get started

To get started with AI actions for apps, add a new **AI Action** query.

## Convert document to text

Use the **Convert document to text** action to extract the text content from a PDF file and return it as text. This is useful if you need to include content from PDF documents for use in other AI actions.

You specify an input component for files, such as [File Input](https://retool.com/components/file-input) or [File Button](https://retool.com/components/file-button), or reference a file from another source using `{{ }}` notation (e.g., a file retrieved from an Amazon S3 bucket).

1. Select the **Convert document to text** action.
2. Specify the file to use in the **File source** field.
3. Click **Save** and then **Run** to perform the action.

Retool parses the PDF file and returns the extracted text. The response is available at `{{ query.data }}`.

---

## Retool AI image actions

You can use the **Retool AI** resource to write queries that leverage AI models to generate images. The AI model returns a Base64-encoded string of the image.

As with all queries, the response is available at `{{ query.data }}`. You can display base64-encoded images in any Retool component that support images, such as the [Image](https://retool.com/components/images) or [Avatar](https://retool.com/components/avatar) components.

## Get started

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

import Getstarted from "./_getstarted.mdx";

## Generate an image

Use the **Generate image** action to generate an image based on the instructions you provide.

1. Select the **Generate image** action.
2. Enter some instructions in the **Input** field.
3. Select the AI model to use, (e.g., **dall-e-2**).
4. Click **Save** and then **Run** to perform the action.

The query output then displays a preview of the base64-encoded image that the AI model returns.

## Image constraints

AI models typically generate `image/png` images with a maximum resolution (e.g., 1024x1024px for **dall-e-2**). You can specify custom dimensions but they cannot exceed the maximum limit.

---

## Retool AI text actions

You can use the Retool AI resource to write queries that leverage AI models to generate and analyze text content. You can provide text directly in the query, reference existing data from elsewhere (for example, another query), or use data stored in Retool Vectors.

As with all queries, the response is available at `{{ query.data }}`. If you reference the query data in a component, such as a [Text Area](https://retool.com/components/text-area) component, Retool streams the response so it appears in real time.

## Add an AI Action

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

import Getstarted from "./_getstarted.mdx";

The Retool AI text actions are: **Generate text**, **Summarize text**, **Classify text**, and **Extract entity from text**. 

:::info
For all text actions, the **Fx** button next to the **Model** field allows you to dynamically select different AI models within your apps or workflows. Refer to the [Dynamic AI model selection](#dynamic-ai-model-selection) section for more information.
:::

## Generate text

Use the **Generate text** action to generate text content based on the instructions you provide.

1. Select the **Generate text** action.
2. Enter some instructions in the **Input** field.
3. Select the AI model to use (for example, **GPT-4**).
4. Click **Save** and then **Run** to perform the action.

The specified AI model then generates the requested text.

export function ArcadeEmbed_generate() {
  return (
    
      
    
  )
}

### Include context from Retool Vectors

import Vectors from "./_vectors.mdx";

### Dynamic AI model selection

Combine the **Fx** button with an [Option list](https://docs.retool.com/apps/guides/forms-inputs/option-lists) in a [Select](https://docs.retool.com/apps/reference/components/select) component to change the AI model dynamically. 

1. Create a new [Generate text](#generate-text) query. 
2. Open the **Components** panel and drag a **Select** component onto the canvas. 
3. In the **Inspector**, select **Mapped**.
4. Set the **Data source** to the query. 
5. Switch the **Mode** to **Manual** and click on the **Option** labels to edit them.
6. In your query, select the **Fx** button next to the **Model** field and copy the model string.
7. Paste the string into the **Value** field of the **Edit option** box. 
8. Add a **Label** 
9. Repeat Steps 6-8 as needed for additional AI model options.
10. Change the **Model** value in your query to `{{ select1.value }}`
11. Click **Save**.
12. Choose one of the AI model options from the **Select** component dropdown list. 
13. **Run** the query. 

The model listed in the **Output** metadata should match the **Model** selected from the dropdown. 

export function ArcadeEmbed_fx() {
  return (
    
      
    
  )
}

## Summarize text

Use the **Summarize text** action to generate a summary of the provided text.

1. Select the **Summarize text** action.
2. Enter a passage of text in the **Input** field.
3. Select the AI model to use (for example, **GPT-4**).
4. Click **Save** and then **Run** to perform the action. 

The specified AI model then generates a summary of the provided text.

export function ArcadeEmbed_summarize() {
  return (
    
      
    
  )
}

## Classify text

Use the **Classify text** action to analyze text and categorize it with one of the specified labels. The AI model determines what each label should be for and decides which label most appropriately reflects the text. This is useful for performing customer support or sentiment analysis.

1. Select the **Classify text** action.
2. Enter a passage of text in the **Input** field.
3. Specify the **Classification labels** to use.
4. Select the AI model to use (for example, **GPT-4**).

:::info
`{{ query.data }}` contains a `category` property with a value that corresponds to the chosen label.
:::

export function ArcadeEmbed_classify() {
  return (
    
      
    
  )
}

## Extract entity from text

The **Extract entity from text** action analyzes the input text and identifies information based on the specified entities.

1. Select the **Extract entity from text** action.
2. Enter a passage of text in the **Input** field.
3. Specify the **Entities to extract** (for example, `product name` or `address`).
4. Select the AI model to use (for example, **GPT-4**).

:::info
`{{ query.data }}` contains an array of key-value pairs for each entity the AI model has identified.
:::

export function ArcadeEmbed_extract() {
  return (
    
      
    
  )
}

---

## Collect app usage analytics

Retool’s analytics feature allows you to collect analytics from your apps, and it supports integrations with Segment and Google Analytics.

:::note

Your organization must be on the Enterprise plan to use analytics features.

:::

## Get started

There's an **Analytics** section on the **Settings** > **Advanced** tab in Retool. From there, you can connect to Segment and Google Analytics. You can also log to standard out. After connecting, events are sent to all enabled integrations.

## Configuration

After connecting, you can create **Analytics tracking** queries in the app IDE.

Each analytics event has three configurable sections: when to trigger the query, what conditions have to be met, and the fields to include in the payload.

This example triggers when the `finished` property of `query1` changes, and only runs if the query returns more than 10 items. The payload includes the current time, the user that triggered the query, how long the query took to run, and the value of the `textInput1` component.

## Triggering

The instrumentation event triggers when any of the listed properties change. If you want to limit when the payload is sent, enable a condition. The condition can access properties outside of your **Trigger On Property Change** clauses.

---

## Query GraphQL APIs

:::tip Introduction to GraphQL

If you're unfamiliar with GraphQL, check out the [Introduction to GraphQL](https://graphql.org/learn/) guide by the [GraphQL Foundation](https://graphql.org/foundation/) to learn more about its fundamental concepts.

:::

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

You can write queries to interact with an existing [GraphQL resource](../../../data-sources/guides/integrations/api/graphql.mdx) in your Retool organization. Retool can read GraphQL schema from the API's introspection endpoint, which enables autocomplete and linting of GraphQL queries.

To interact with a GraphQL API that is not configured as a resource, select the **GraphQL** resource from the **Resource** field in the query editor. You manually define the API endpoint and other parameters in the available fields.

:::warning

Clicking **Test** on a GraphQL query runs the query with your latest changes. Retool recommends testing your query on non-production data to avoid making unintended changes to your resource. Refer to [Testing queries](../../quickstart.mdx#testing-queries) for more information.

:::

The following example is a GraphQL query that retrieves a list of three SpaceX launches. 

  

  

  
    

```graphql title="SpaceX launch history"

query Launches($limit: Int) {
  histories(limit: $limit) {
    details
    title
    event_date_utc
    id
  }
}

```

```json title="Response"

{
  "data": {
    "histories": [
      {
        "details": "Falcon 1 becomes the first privately developed liquid-fuel rocket to reach Earth orbit.",
        "title": "Falcon reaches Earth orbit",
        "event_date_utc": "2008-09-28T23:15:00Z",
        "id": "5f6fb2cfdcfdf403df37971e"
      },
      ...
    ]
  }
}

```

## Reference values in GraphQL variables

Unlike other query types, you use [variables](https://graphql.org/learn/queries/#variables) to reference values within Retool in the query body. You specify the variables to use in the query editor and then reference those within the GraphQL query body.

GraphQL variables begin with the `$` character. In the previous example, `$limit` references the **limit** variable from the query editor.

In certain situations you may need to use JavaScript directly in the query body (e.g., to dynamically specify a query field, rather than a value). You can use `{{ }}` expressions in the query body. 

## Fetch and mutate data

GraphQL queries that only fetch data can run automatically. GraphQL queries that modify data must contain a `mutation` field. Similar to **POST** REST API requests, mutation queries cannot run automatically and must be triggered by an event handler. 

## Paginate GraphQL data

The [Table](https://retool.com/components/table) component supports [GraphQL Relay-based cursor pagination](https://relay.dev/graphql/connections.htm). You can enable this from the **Add-ons** section of the Inspector. 

1. Click **+** and select **Pagination**.
2. Click the **Pagination** add-on and toggle **Enable server-side pagination**.
3. Set the **Pagination type** to **GraphQL Relay Cursor based**.

Refer to the [server-side pagination](../../../apps/guides/data/table/pagination.mdx) guide to learn more about paginating data.

---

## Query REST APIs

You can make requests to any REST or [SOAP](../../../data-sources/guides/integrations/api/soap.mdx) API. You can also use [custom authentication](../../../data-sources/guides/authentication/custom.mdx) to interact with private REST APIs.

## Connect to a REST API

You can connect to a REST API in two ways:

- [Create a resource](../../../data-sources/guides/integrations/api/rest.mdx) to connect the API to Retool. This allows you to configure the API once so it's available as a resource anywhere in Retool. You can also configure additional [authentication options](../../../data-sources/guides/authentication/api.mdx), if required.
- Use the built-in **REST API** resource and manually construct API requests. This is useful if you only need to query an API temporarily and won't use it elsewhere. You must manually define API endpoints, authentication options, and any other parameters in each query.

## Query a REST API

You can select a REST API resource in your Retool organization from the **Resource** field in the query editor. After selecting the resource, the configured API endpoint appears in the **URL** field. You can then specify the parameters and other options in the available fields.

To interact with a REST API that is not configured as a resource, select the **REST API** resource from the **Resource** field in the query editor. You manually define the API endpoint and other parameters in the available fields.

:::warning

Clicking **Test** on a REST API query runs the query with your latest changes. Retool recommends testing your query on non-production data to avoid making unintended changes to your resource. Refer to [Testing queries](../../quickstart.mdx#testing-queries) for more information.

:::

### Action types

Retool supports the following request methods for REST APIs:

- **GET**
- **POST**
- **PUT**
- **PATCH**
- **DELETE**

You specify the method to use by selecting an option in the **Action type** dropdown.

Queries using **GET** methods automatically run whenever any of their parameters change by default (e.g., input field value changes). Queries using **POST**, **PUT**, **PATCH**, and **DELETE** methods must be manually triggered by default. You can choose whether a query should run automatically or manually in the query editor; select **Run query only when manually triggered** or **Run query automatically when inputs change** in the dropdown menu.

### Path and URL parameters

You can include additional path and URL parameters to any API request in the query editor. Path parameters can be included directly in your URL, and URL parameters can be added in the **URL parameters** section. Path and URL parameters can also read from values within curly braces (`{{ }}`).

When you specify URL parameters, Retool automatically appends them to the endpoint URL. Conversely, Retool detects any URL parameters added to the endpoint URL and populates the URL parameter fields.

The following example shows a **GET** request which reads the currently selected row of a [Table component](https://retool.com/components/table) and passes it as a URL parameter with a key of `id`.

#### Disable URL parameter sorting

URL parameters are automatically sorted alphabetically. To disable sorting, navigate to **Settings** > **Beta** and turn on the **Disable URL Params Sorting** setting.

### Request headers

For REST APIs configured as a resource, you can set request headers on the resource's configuration page. Headers set on resource configuration pages are always included on any requests using that resource.

You can also add headers to any request using the **Headers** fields in the query editor. These headers are included in addition to any already configured for the resource.

Retool sanitizes any headers with keys that contain `authorization`, `key`, or `password`.

:::note

Retool passes through all headers by default, even if they are duplicates. To exclude duplicate headers, navigate to **Settings** > **Beta**, and toggle on the **Remove duplicate headers (case-insensitive)** settting.

:::

### Request bodies

You can send requests with **JSON**, **raw**, **x-www-form-urlencoded**, **Form data**, or **binary** bodies.

#### JSON

To construct a JSON request body, select **JSON** in the **Body** section of the query editor. You can then construct a JSON object using the key-value fields. A `Content-Type: application/json` request header is automatically added to requests using **JSON** body types. The JSON body also supports nested objects within a single key.

#### Raw

To send a request body without modifications, select **Raw** in the **Body** section of the query editor. For example, if you use the **Raw** body type and manually add a `Content-Type: application/json` header, you can send more complex JSON objects.

You can include JSON in raw request bodies with some additional formatting. You can either wrap the entire body in curly braces to construct the object dynamically or manually format values in the following ways:

- **String values**: Wrap values in curly braces `{{ }}` with double quotes.
- **Boolean or number values**: Do not wrap curly braces `{{ }}` with double quotes.
- **Objects and arrays**: Use`JSON.stringify()` to convert to string values.

#### x-www-form-urlencoded

To send URL-encoded data, select **x-www-form-urlencoded** in the **Body** section of the query editor. Retool adds `Content-Type: application/x-www-form-urlencoded` to the request header.

#### Form data

:::tip

See the guide to [handling files in Retool](../files.mdx) to learn how Retool represents files.

:::

To send form data in your request, select **Form data** in the **Body** section of the query editor. A `Content-Type: multipart/form-data` header is added to the request.

To upload a file using form data, set a **key** to `file`, select the **File** upload type, and set the **value** to the file to upload. The `.value` property on [File Input](https://retool.com/components/file-input), [File Button](https://retool.com/components/file-button), and [File Dropzone](https://retool.com/components/file-dropzone) components has the correct schema for file uploads. For example, set **value** to `{{ fileInput.value }}` to upload a file as form data.

#### Binary

To send data that can't be formatted as form data—for example, an image, audio, or video—select **binary** in the **Body** section of the query editor.

The following examples passes the [File button](https://retool.com/components/file-button) upload value as binary data.

### Cookies

You can configure REST API resources to use [cookies-based authentication](../../../data-sources/guides/authentication/api.mdx#cookie-based-apis) for REST API resource support cookies for API authentication. You can also add cookie headers to API requests using the **Cookies** key-value field in the query editor.

---

## App functions

_App functions_ enable you to write reusable logic with dynamic parameters. Use functions when you want to perform the same actions on different pages, with different parameters, and return different data.

Functions run only when they are called, and they are stateless—you can't reference a `.data` or `.value` property as the source for component data or another value. Functions also replace most usages of [app-level preloaded custom JavaScript](./javascript/custom.mdx) and the **Additional Scope** setting in resource queries.

This page covers only app functions, which differ in some ways from [workflow functions](../../workflows/guides/functions.mdx).

## Types of app functions

App functions are one of the many tools that you can use to accomplish your goal. Use this section to identify which use case they are best- suited for.

There are two types of app functions. They work similarly, but are used for different purposes.

### Sync functions

_Sync functions_ are a mechanism that enables you to reuse JavaScript code. They run synchronously and are helpful tools for formatting or processing different sets of data in the same way.

They can be called from any JavaScript in your app, including in embedded expressions `{{ }}`.

For example, you could have a table showing the inventory of all your products. The manufacturer uses one part number, but your business uses a custom part number that combines the manufacturer number and the color, and you want to display your custom part number in a table.

You would create a sync function with two parameters, `manufacturer` and `color`. In the **JavaScript code** input, write `return manufacturer + "-" + color`. Test out your function with example parameters.

export function CreateSync() {
  return (
    
      
    
  )
}

Next, you would create a new column in your Table for your custom part number. Set the value of the column to `{{ function1({manufacturer: currentSourceRow.partNumber, color: currentSourceRow.color}) }}`, which dynamically provides parameters to the function using the current source row.

export function UseSync() {
  return (
    
      
    
  )
}

#### Sync functions vs other JavaScript logic

Retool provides a variety of options for writing functional code, each with a distinct purpose:

- Use a sync function if you want to reuse/parameterize simple JavaScript code that has no side effects. You can think of a function as a parameterized, anonymous version of a transformer, whose result is returned directly to the caller rather than being stored in the app state. You can also think of a function as a “pure function” in JS.
- Use a [JavaScript query](../quickstart.mdx#code-queries) to write JavaScript code that handles app orchestratation (such as control a component or trigger another query), or whose return value should be persisted in app state and be referenceable by other parts of your app.
- Use a [transformer](../quickstart.mdx#transformers) to transform data and store the transformed result in app state so it can be referenced by other parts of your app. You can think of a transformer like a [selector in React](https://redux.js.org/usage/deriving-data-selectors).
- Use a [variable](../quickstart.mdx#variables) to store some state and explicitly update its value from other parts of your app (such as from an event handler).

### Resource functions

_Resource functions_ are a mechanism that enables you to reuse resource queries. Resource functions are helpful tools for performing tasks that don't require a persistent state, such as updating or deleting an entry. Resource functions eliminate the need for the **Additional Scope** setting in resource queries.

Resource functions run asynchronously.

They can be called from a JavaScript query or a Function Call query, but they cannot be called from embedded expressions.

For example, you could use a resource function that utilizes a REST API to delete a set of customers. Using a function in this scenario would be ideal if you might need to delete customers from various different pages.

Create a resource function that accesses an your REST API of customers with one parameter, `customer`. Update the request URL to include your parameter.

export function ResourceFunction() {
  return (
    
      
    
  )
}

To connect this function to a [Button](../../apps/reference/components/buttons/button.mdx), you first need to [create a Function Call query](#function-call-query). Then, use the Button's event handler to trigger the Function Call. You can also select a `Run Script` event handler and call the function from the script.

## Calling functions

There are several ways to trigger app functions.

### Function Call query

You can use the _Function Call_ query type to trigger your function. Function Call has a state, which means that you can use the output of this query as a static and referenceable value. You must use a Function Call to trigger a Resource Function run from an event handler.

Add a Function Call query in the **Code** menu. Select the function you want to call, and define the parameters.

export function FunctionCall() {
  return (
    
      
    
  )
}

Similar to other types of queries, you can also configure event handlers and run behavior for a Function Call.

### Inline functions

You can also call functions directly from JavaScript code. Use the following guidelines when calling functions:

- Sync functions can be called anywhere that you can use [embedded expressions](../quickstart.mdx#embedded-expressions), or from JavaScript queries.
- Resource functions can only be called from Javascript queries.
- When calling functions from JavaScript queries, you do not need to surround them with brackets.
- Call functions with either positional parameters or named parameters:
  - Named parameters: `functionName({param1: value, param2: value})`. Use named parameters when your function takes a large number of parameters or has optional parameters.
  - Positional parameters: `functionName(value, value)`. Use positional parameters when your function only has a few parameters.

---

## Write queries and code with Ask AI

import Default from "/docs/_shared/_ai-default-model.mdx"

Ask AI enables you to leverage AI when writing JavaScript, SQL, or GraphQL queries. You can instruct Ask AI to:

- **Generate** a new query using natural language instructions.
- **Edit** an existing query using natural language instructions.
- **Explain** an existing query and add comments.
- **Fix** errors in an existing query.

## Generate a query

When your query is empty, the AI operates in generate mode and can write you a query using plain English.

Click **Ask AI** to open a text field and make your request.

## Edit a query

If you have a query already, Retool's AI operates in edit mode and can modify the existing query. Click the **Ask AI** icon to open a text field and make your request.

## Explain a query

For existing queries, you can also set Retool's AI to operate in explain mode, which describes the functionality of the existing query by adding a comment.

Click the **Ask AI** icon and select **Edit** > **Explain** to add a comment to the query.

## Fix a query

If a query fails to run, click **Run error detected. Debug?** to have Ask AI debug the query and suggest a fix. Ask AI uses context about the query, schema, and the error message. It can then explain the problem and provide a possible fix.

---

## Dynamically query resources

Using dynamic queries, you can use a single query to access multiple different resources of the same type. You can use components to enable a user to select which resource to query. Dynamic queries decrease the maintenance burden for apps that need to query various similar resources.

Some example use cases for dynamic queries include:

- An app for your support team to interact with customer data, where every customer’s data is hosted on a standalone database with unique credentials.
- An admin panel to measure the health of customers’ deploys, where every customer has their own tenant.
- A generic budget dashboard for client projects, where every client has their own database.

:::note

Dynamic queries are available in Retool Apps only. This feature is not available in Retool Workflows.

:::

This guide includes instructions for creating a simple dynamic query that retrieves a set of users from one of three different REST APIs.

## Find resource ID

To create a dynamic query, find the ID of the resources that you want to query.

There are three methods to retrieve the resource ID:

- _Manually:_ You can find ID of a resource from the URL of the resource’s configuration page. The ID is the  character string following `resources/`.  For example, if the URL is `https://demo.retool.com/resources/b49d8ef2-a774-433f-9b5c-cadd2a60c678`, the resource ID is `b49d8ef2-a774-433f-9b5c-cadd2a60c678`.
- _Via database:_ If you are on a self-hosted instance of Retool, you can query the underlying Retool database to fetch a list of resources.
- _Via the Retool API:_ You can query the `/resources` endpoint of the [Retool API](../../api) to fetch a list of resources, filtered by the desired resource type.

## Assign ID to a selection component

Use a component to select between resource IDs. For example, use a Select, Listbox, Radio Group, or other selection input component. Create an option for each resource, with the resource ID in the `value` field.

## Create dynamic query

To create a dynamic query, add a new query from the **Code** menu. Click the **𝑓** button, and add a JavaScript snippet that represents a resource ID. For example, if you are using a Select to choose which resource to query, set the **Resource ID**.

In the following example, the `select1` component includes three different resources, with their corresponding resource IDs in the `value` field.

You can only query one type of resource in a given dynamic query. This example uses three REST API resources.

To change the resource type, toggle the **𝑓** button and change the resource type.

---

## Interact with files

You can add components that allow users to upload files in [web apps](../../apps/guides/forms-inputs/file-inputs.mdx) and [mobile apps](../../mobile/guides/forms-inputs/files.mdx). You can also query data stores, such as Retool Storage or [Amazon S3](../../data-sources/guides/integrations/object-file-store/amazon-s3.mdx), to save or retrieve files.

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

## Reference user-uploaded files in apps

How you reference user-uploaded files differs depending on whether you're using web or mobile apps.

Files that users upload are Base64-encoded. A [File Input](../../apps/reference/components/special-inputs/file-input.mdx), [File Dropzone](../../apps/reference/components/special-inputs/file-dropzone.mdx), or [File Button](../../apps/reference/components/special-inputs/file-button.mdx) component's value property contains an array of objects that correspond to uploaded files.

`value` is always an array, regardless of whether a user uploads a single file or multiple files. Single-file uploads are accessible using `value[0]`.

Uploaded files are Base64-encoded. The component's `value` property contains a Base64-encoded string of the file. You can reference Base64-encoded values anywhere in Retool that accepts a string value, including URLs, using `{{ query.data.base64data }}`.

For component properties without built-in image fields, such as the **Prefix image** of a [List View component](../../apps/reference/components/list-view), use the `data:` prefix and include the MIME type. For example:

```
data:image/png;base64,{{uploadedImageQuery.data.base64Data}}
```

:::tip Convert blobs to Base64-encoded strings

Mobile apps use blobs to temporarily store files. Use [utils.getDataByObjectURL()](../reference/libraries/utils.mdx#utilsgetdatabyobjecturl) to convert blobs into a Base64-encoded string to use with queries for other data sources.

:::

You use either the File Input component or the Image Input component to upload files or images. These components are functionally similar but have some notable differences.

### File Input

Files that users upload are Base64-encoded. The File Input component's `value` property contains a Base64-encoded string of the file. You can reference Base64-encoded values anywhere in Retool that accepts a string value, including URLs. For example, you can set the URL of an Image component to `{{ fileInput1.value }}` to display an uploaded image.

The [file](../../mobile/reference/components/forms/file-input.mdx#property-file) property is an object with more information about the uploaded file.

### Image Input

The [Image Input](../../mobile/reference/components/media/image-input.mdx) component temporarily saves captured data as blobs with `blob:` or `file://` URI strings. You can reference this blob elsewhere in your app (e.g., to preview in an [Image](../../mobile/reference/components/media/image.mdx) component) or upload captured images to a data store.

The Image Input component's `value` contains an array of `blob:` or `file://` values, as the component supports multiple selections. The `files` property is an object with more information about the uploaded images.

## Interact with files on data stores

You can create, retrieve, and modify files on [Retool Storage](../../data-sources/quickstarts/retool-storage.mdx) or any other connected data store resource, such as [Amazon S3](../../data-sources/guides/integrations/object-file-store/amazon-s3.mdx).

You can write queries to save and retrieve files on Retool Storage.

### Save files to Retool Storage

:::tip Save files directly to Retool Storage

Enable the **Upload file to Retool Storage** option for supported upload components, such as [File Button](https://retool.com/components/file-button), to automatically store the file in Retool Storage without the need for a separate query.

:::

Use the **Upload file** action to upload files to Retool Storage. If your app has a supported component for uploads, you can select it from the **File source** dropdown. Retool then saves the uploaded file.

In some cases, you may need to reference Base64-encoded data instead of a component, such as data returned by another query.

import FxSvg from '/img/icons/fx.svg';

Click the  button to enable more granular options. You can then specify the **File content**, a Base64-encoded string, and the file name to use.

In [Retool Workflows](../../workflows/index.mdx), use the **File content** field to set your file content, and give the file a unique name. You can also use JavaScript to dynamically set the file name—for example, `{{ 'report-' + new Date().toDateString() + '.csv' }}`.

### List all files on Retool Storage

Use the **Get a list of file metadata** action type to retrieve metadata about the files your organization has uploaded to Retool Storage. The list includes file names, IDs, sizes, types, URLs, and created and modified dates.

:::note

To improve the performance of this action, you can choose to paginate the results that Retool returns. Navigate to **Settings** > **Beta**, and toggle on the **Retool Storage: Paginate list actions** setting.

:::

### Retrieve a file from Retool Storage

Query the **Retool Storage** resource to retrieve saved files as an array of [Retool File](../../data-sources/reference/objects/file.mdx) objects. Set the **Action type** to **Get contents of a file** and select the file to retrieve.

Some components, such as [Image](https://retool.com/components/image) and [PDF](https://retool.com/components/pdf), have built-in support for files on Retool Storage. Select **Storage** as the **Source** and then select the file to use.

### Download files from Retool Storage

In web and mobile apps, write queries using the **Download a file** action type to download a file to the user's browser. You cannot download files in Retool Workflows.

### Delete files on Retool Storage

Delete files by writing queries using the **Delete a file** action type. Select a file by its name, or pass in its ID.

### Manage files on Retool Storage

To view all your uploaded files, change file access levels, and manually upload, download, move, or delete files, go to **Resources** > **Retool Storage**, or directly to `your-org.retool.com/files`. By default, uploaded files are accessible to users in the organization which hosts the file. Select **...** > **Make public** to make files publicly accessible.

You can also view file IDs and URLs from this page. You can use IDs in Retool Storage queries, and URLs in [Image](https://retool.com/components/image) and [PDF](https://retool.com/components/pdf) components in apps.

You can query any data store that has been made available as a [resource](../../data-sources/quickstarts/resources.mdx) in Retool. How you save and retrieve files, and the format in which it returns files, depends on your data source.

For example, the following query retrieves a file from Amazon S3:

| Setting         | Value                    |
| --------------- | ------------------------ |
| **Action type** | **Read a file from S3**. |
| **Bucket name** | The S3 bucket name.      |
| **S3 file key** | The S3 file path.        |

```json title="Amazon S3 example response"
{
  "Metadata": {},
  "LastModified":"2023-09-15T19:49:20.000Z",
  "ContentLength":21204,
  "ContentType":"binary/octet-stream",
  "AcceptRanges":"bytes",
  "ETag":"8522cef0882eecf42bc8093d64f2d051",
  "Key":"path/to/file.jpg",
  "Body":"UklGRsx..."
}
```
Once retrieved, `{{ query.data.Body }}` contains the Base64-encoded file data for you to reference.

## Fetch files using a URL

:::caution Remote files must be accessible

The remote file must be publicly accessible and not subject to CORS policies. If the file is stored in a remote data store to which you have access, consider creating a resource instead.

:::

In some cases, you may need to fetch a file from a remote URL, such as an image. You can write a query to retrieve the remote file and use it within your app.

1. Add a query and select the **RESTQuery** resource.
2. Select the **GET** action and provide the URL to the remote file.

If the remote file is binary data, Retool makes it available as a file object with the same schema as Retool Storage files. You can reference `{{ query.data.base64Data }}` to use the Base64-encoded data. Plain text content is not encoded.

The following example retrieves Retool's GitHub organization image.

```title="Retrieve a GitHub image"
GET https://github.com/tryretool.png
```

`{{ query.data.base64Data }}` is the Base64-encoded.

```json title="Query data"
{
  "name": "tryretool",
  "type": "image/png",
  "sizeBytes": 4551,
  "base64Data": "iVBORw0KGgoAA..."
}
```

---

## Generate PDFs

Retool provides a built-in PDF exporter to generate PDFs based on data in your Retool apps. To download the entire view of your Retool app as a PDF, you can instead use the [utils.downloadPage()](../reference/libraries/utils.mdx#utilsdownloadpage) method.

## Write queries using the PDF resource

Select the **PDF Exporter (exporter)** resource in the query editor and configure the following fields. On query success, a PDF file with the given contents is downloaded to the user's browser.

### PDF content

The **PDF content** field accepts Markdown for formatting. To convert data, such as the contents of a table, to a format usable for Markdown, use a JavaScript [transformer](transformers.mdx) or [query](javascript/index.mdx).

The following transformer constructs Markdown table formatting for `{{ table1.data }}`.

```javascript title="transformer1"
const headers = [Object.keys({{ table1.data }}[0])];
const breaks = [headers[0].map(() => "---")];
const rows = {{ table1.data }}.map((r) => Object.values(r));
const tableEntries = headers.concat(breaks).concat(rows);
return tableEntries.map((row) => "|" + row.join("|") + "|").join("\n");
```

You can then reference the transformer in the PDF Exporter resource using an `{{ }}` embedded expression, such as `{{ transformer1.value }}`.

### Filename

Use the **Filename** field to specify a PDF file name. This field accepts dynamic inputs. For example, set it to `user_{{ usersTable.selectedRow.id }}_data` to download the file as `user__data.pdf`.

---

## Preload custom JavaScript code and libraries

Retool enables you to make use of custom JavaScript and libraries in apps. You can configure this on a per-app basis or for all apps in your organization.

In general, Retool recommends you configure custom JavaScript and libraries only in apps in which it is required.

:::warning Custom JavaScript is sandboxed

For security reasons, all JavaScript runs in a sandbox. Retool executes all JavaScript in a separate `` on a different domain to prevent cross-site scripting (XSS) attacks. You cannot use jQuery or similar libraries directly in apps.

:::

## Configure custom JavaScript

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

You can preload custom JavaScript to extend app functionality with custom logic. Once configured within an app, custom JavaScript is available only within that app. If you configure custom JavaScript across your organization, it is preloaded and available across all apps.

While you can call global JavaScript functions from anywhere in your app, [local storage](../../reference/objects/localstorage.mdx) is the recommended way to store global variables in Retool.

To add preloaded JavaScript to an app, open the **App Settings** tab in the left panel, then select **Preloaded JS**.

:::warning All apps load custom JavaScript for the organization

Add custom JavaScript for the organization only if it is needed in most apps. Custom JavaScript can affect performance, especially if you load complex JavaScript functions that aren't used in every app.

:::

Retool admins can configure custom JavaScript that loads in all apps within the organization. This is useful if there is custom JavaScript or libraries that must be available in all apps. Navigate to your organization's **Settings** at `/settings` and select the **Advanced** tab.

After you define your preloaded JavaScript, you can use your methods wherever you write JavaScript, such as:

- Within `{{ }}` embedded expressions, such as `{{ window.myCustomHelper() }}`.
- In [transformers](../transformers.mdx) and [JavaScript queries](./index.mdx).

Custom JavaScript functions use the `window` prefix.

## Configure custom libraries

:::tip Preloaded libraries

Retool automatically [imports some libraries](./index.mdx#libraries), such as `moment()`.

:::

Retool supports the use of externally-hosted JavaScript libraries that function without any external dependencies. Retool recommends using libraries that follow [UMD](https://github.com/umdjs/umd).

In addition, Retool recommends using:

- **The minified version of a library**. Minified versions are optimized to load quicker and generally end with `.min.js`.
- **Only the libraries that you require**. Every library you add to an app is loaded. The more libraries you include, the more it can impact performance.

[CDNJS](https://cdnjs.com/libraries) lists libraries you can load. Non-minified builds usually require `@require` or `import` statements. Some libraries may not be compatible.

To add libraries to an app, open the **App Settings** tab in the left panel, then select **Libraries**.

To import external libraries, add URLs to **Settings** > **Advanced** > **Libraries** in your organization's settings, or the **Libraries** section of an app's settings. This allows you to access the library wherever you write JavaScript.

Custom libraries extend app functionality further with additional features and logic. For instance, you can use the [blueimp-md5](https://cdnjs.com/libraries/blueimp-md5) library to generate an MD5 hash of an email address to [retrieve a profile image from Gravatar](../../../apps/guides/presentation-styling/avatar.mdx#obtain-profile-images-from-gravatar).

---

## Write and run JavaScript

You can write JavaScript to interact with components and queries, which is useful for adding custom logic to your apps. This guide covers common use cases of JavaScript in Retool. For more comprehensive references, visit the [JavaScript API reference](../../reference.mdx) and the [Component reference](https://retool.com/components).

To get started, open the code list and create a query. Select **Query** in the **JavaScript** section.

In the editor, you can write code to set component properties, trigger queries, and access useful JavaScript libraries.

:::note

To ensure safety and security for all users, certain interactions with the browser and context outside of Retool apps can't be run. For example, you can't access browser events or use libraries like jQuery.

:::

## Run an API request for each row in a table

This examples makes an API request for each row in a table, and then shows any errors returned in the process.

### 1. Add a table

Add a Table component to your app. Select **Use an array** in the **Data source** dropdown menu, then paste this JSON into the **Data source** attribute.

```json
[
  {
    "id": 1,
    "name": "Hanson Deck",
    "email": "hanson@deck.com",
    "sales": 37
  },
  {
    "id": 2,
    "name": "Sue Shei",
    "email": "sueshei@example.com",
    "sales": 550
  },
  {
    "id": 3,
    "name": "Jason Response",
    "email": "jason@response.com",
    "sales": 55
  },
  {
    "id": 4,
    "name": "Cher Actor",
    "email": "cher@example.com",
    "sales": 424
  },
  {
    "id": 5,
    "name": "Erica Widget",
    "email": "erica@widget.org",
    "sales": 243
  }
]
```

### 2. Create a query

Create a query using the **RestQuery (restapi)** resource. Set the **Action type** to **Post** and use this URL: `https://approvals.tryretool.com/api/users/approve?email={{table1.data[i].email}}`. The URL parameters are populated automatically.

By default, the `i` property is `0` but JavaScript in a subsequent step will increment this value so the query runs on each row.

### 3. Add a Button and Text components

Add a Button and two Text components to your app. **Status** shows the query's progress and **Errors** displays any errors while the query runs.

### 4. Write the JavaScript query

Create a JavaScript query named `query2` and add the following JavaScript.

```javascript
var rows = table1.data;
var errors = "";
var total = rows.length;

function runQuery(i) {
  // Update the Status text
  Status.setValue("Progress: " + (i.toString() + "/" + total.toString()));

  if (i >= rows.length) {
    console.log("Finished running all queries");
    return;
  }

  console.log("Running query for row", i);

  query1.trigger({
    additionalScope: { i: i }, // This is where we override the `i` variable
    // You can use the argument to get the data with the onSuccess function
    onSuccess: function (data) {
      runQuery(i + 1);
    },
    onFailure: function (error) {
      // Update the Errors text
      errors += "Found error at line " + i.toString() + ":  " + error + "\n\n";
      Errors.setValue(errors);
      runQuery(i + 1);
    },
  });
}

runQuery(0);
```

### 5. Add an event handler to your button

After saving `query2`, add an [event handler](../../../apps/guides/interaction-navigation/event-handlers.mdx) to your button that triggers the JavaScript query.

Now click the **Submit** button to test the app. As the query runs on each row, the status updates and errors are displayed. Since the API endpoint at `https://approvals.tryretool.com/api/users/approve` doesn't exist, all the requests fail.

## Clear state after running a query

You can use the following snippet to clear state after a query runs.

```javascript
userInput.setValue("");
emailInput.setValue("");
pricingTierDropdown.setValue(null);
```

## Trigger a query

This snippet programmatically triggers a query.

```javascript
query1.trigger();
```

You can also pass additional arguments to customize the behavior of a query.

```javascript
query1.trigger({
  additionalScope: {
    name: "hi",
  },
  // You can use the argument to get the data with the onSuccess function
  onSuccess: function (data) {
    console.log("Successully ran!");
  },
});
```

The `additionalScope` option allows you to pass more variables to the query that aren't defined on the global scope. In this example, `name` is now passed to `query1`, and `query1` can access `{{name}}`. The `onSuccess` or `onFailure` callback is called after the function completes.

:::note

Queries that reference values within `additionalScope` initially show an error because there's no global property of the specified name. This error resolves when you populate the **Additional Scope** field or save and run the query.

:::

Here's an example of `additionalScope` used in an app.

## Retrieve triggering components

The variable `triggeredById` returns the name of the component that triggered a query. You can reference this inside of `{{ }}` in any query to return the name of the component that triggered it. If the query is triggered by another query, `triggeredById` returns `undefined`.

```javascript
text1.setValue("I was triggered by component: " + triggeredById);
```

## Retrieve triggering component indexes

If a query is triggered by a table action or a button in a list view, the variable `i` is defined in the query and returns the component's index in that table or list view.

```javascript
text1.setValue("I was triggered by component at index: " + i);
```

## Trigger a query for each item in an array

This script triggers a query for each item in an array.

```javascript
var rows = [{ a: 1 }, { a: 2 }, { a: 3 }, { a: 4 }];

function runQuery(i) {
  if (i >= rows.length) {
    console.log("Finished running all queries");
    return;
  }
  var data = rows[i];
  console.log("Running query for row", data);

  query1.trigger({
    additionalScope: {
      data: data,
    },
    // You can use the argument to get the data with the onSuccess function
    onSuccess: function (data) {
      runQuery(i + 1);
    },
  });
}

runQuery(0);
```

## Return data

Besides manipulating components and queries, JavaScript queries can also return data. For example, this script generates a random number.

```javascript
return Math.random();
```

When this query is triggered, you can access the number generated using the `.data` property: `{{ generateRandomNumber.data }}`.

## Promises and async queries

JavaScript queries can be asynchronous. If you return a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise), Retool waits for the promise to resolve before considering the query complete.

### Simple promise

Passing in a query to be triggered as the first argument in a `Promise.resolve()` triggers the other query, waits for it to finish, and then returns the `.data` result from the triggered query.

```javascript
return Promise.resolve(query1.trigger());
```

### Access data from an asynchronous function

Use [await](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await) to wait for a `Promise` and access the data it returns. The following example [triggers a query](../../reference/objects/query.mdx#properties#trigger) named `getCountry` within a `for` loop. Using `await`, the loop waits for data to be returned before repeating.

```javascript
const countries = ["spain", "france", "germany"];
let allResults = [];

for (let country of countries) {
  let countryResult = await getCountry.trigger({
    additionalScope: { countryName: country },
  });
  allResults.push(countryResult);
}

return allResults;
```

### Promising an array of query returns

You can also pass in an array of items that are dependent on query triggers, and use `Promise.all()` to return all of their results in an array of the same length. In this case, you would trigger `query1` for each row in `table1`, and pass in the `id` value from each row. Using `{{id}}` inside `query1` evaluates as the provided row id when it's run.

```javascript
const promises = table1.data.map((row) => {
  return query1.trigger({
    additionalScope: {
      id: row.id,
    },
  });
});

return Promise.all(promises);
```

### Resolve and reject

If you want to return a value from the query, you can pass it in as a parameter to the Promise's `resolve` function. You can also use the `reject` function from the Promise to fail the query.

In the following example, the query takes two seconds to run, and returns the value `12345` through the resolve function.

```javascript
return new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve(12345);
  }, 2000);
});
```

:::tip Ask the community about scripting

If you're running into any issues with writing JavaScript or scripting in Retool, check out some of the [answered questions on our community forums](https://community.retool.com/search?q=javascript), or [ask one of your own](https://community.retool.com/).

:::

---

## Share queries with the Query Library

You can use the same query across multiple apps by sharing them with the Query Library. Often, you want the same functionality across apps, but don’t want to copy paste the same query over and over again. Reusable queries help you avoid code duplication, version control queries, and share queries with your team.

## Write your query

Reusable queries are written in the [Query Library](https://login.retool.com/auth/login?source=docs&redirectOnLogin=querylibrary). To set up a reusable query:

1. Create and configure a query.
2. Save the query.
3. Share the query using the **Share** button. This makes your query visible and editable to every Editor in your team. You can also import the query in your apps.

:::note

By default all users have access to the Query Library. If you're an admin, you can configure which user groups have access to the Query library in your Permission settings.

:::

You can define variables for queries using curly braces `{{ }}`. Variables are dynamic inputs to your query. You can define defaults in the **Variables** section of the right hand panel. When you import a query in a Retool app, you can pass inputs to the variables you define.

:::tip
Tip: You can write JavaScript inside the `{{ }}` curly braces
:::

## Import your query

Now that your query has been shared, you can import it inside any Retool app. To do this, create a new query in your app and select **Import from Query Library** from the **Resource** dropdown.

:::note

Every time you save a query in the library Retool creates a new version. By default, when you import a shared query into an app, it will be in sync with the latest version. You also have the option to choose a specific version instead.

:::

## Using variables

You can define variables by wrapping their names in `{{ }}` curly braces within reusable queries. For example, if you write `select * from users where age > {{ min_age }} and age 

You can also write more complicated JavaScript expressions. Consider this query: `select * from users where status = {{ age > 65 ? 'retired' : 'working' }}`. In this example, you can pass in `age` as a numerical input, and Retool evaluates it as `retired` or `working` based on the value.

---

## Configure query run behavior

Web or mobile app queries can run either automatically or manually, and include additional run behavior options. These features depend on whether a query is only reading data or making changes.

| Run behavior | Actions                                 | Description                                                                                    |
| :----------- | :-------------------------------------- | :--------------------------------------------------------------------------------------------- |
| Automatic    | **SQL** mode and **GET** requests       | The query runs on page load or whenever a referenced value changes, such as a component value. |
| Manual       | **GUI** mode and all other API requests | The query runs only when triggered by an event.                                                |

Use the **Run behavior** settings in the code editor to view and switch between the available options.

## Run a query automatically

SQL mode queries for databases or GET requests for APIs can run automatically. If enabled, the query runs whenever the page loads or a referenced value changes, such as a component value. This is best suited for smaller datasets or when an app needs to reflect changes immediately.

Click **Run behavior > Automatic** to configure a query to run automatically.
 

## Run a query manually

**GUI** mode SQL queries or any other type of API request (**POST**, **PUT**, etc.) can only run manually. The query must be triggered for it to run. You can trigger queries using an event handler, such as a button click, or with JavaScript code using the `query.trigger()` method. 

You can also configure automatic queries that only read data to run manually. Retool recommends switching to manual run behavior whenever querying a large dataset. Frequent runs of these types of queries can potentially result in rate limits or app performance issues. 

Click **Run behavior > Manual** to configure a query to run manually.

## Additional run behavior options

In addition to running queries automatically or manually, you can configure additional options in the **Advanced** tab. Available options depend on the query's run behavior.

### Run a query on page load

Whenever a user launches an app, automatic queries run once the page loads. You can also configure this behavior for manual queries. To configure this option, navigate to the **Advanced** tab and enable the **Run this query on page load?** setting.

You can also configure the **Page load delay** option for queries that run on on page load. This delays the query from running until the specified time, in milliseconds, has passed since the page loaded. For example, a delay of `5000` would result in a query waiting 5 seconds after a user launches the app before running.

:::caution Avoid running queries that modify data on page load

Running a query on page load prevents users from triggering the query. If a query is not correctly configured, it could result in erroneous changes or deletion of data.

:::

### Run a query periodically

You can configure queries to run at a regular interval. This can be useful for keeping app data current without needing users to perform any action. 

Enable **Run this query periodically** and specify the interval, in milliseconds, at which the query runs again. 

### Run a query when certain values change

Both automatic and manual queries can be triggered whenever a specified value changes, such as an input field or another query. This is similar to configuring a **Change** event handler.

Select the values for which the query should monitor in the **Watched inputs** field, such as `{{ textInput1.value }}` or `{{ query1.data }}`. 

### Require confirmation before running

:::tip Markdown-formatted messages

You can use Markdown formatting in query confirmation messages. 

:::

To prevent users making accidental changes when a query runs, you can include a confirmation modal with a custom message. Users can then either confirm the query should run or cancel. 

Enable **Show a confirmation before running**, then provide a confirmation message. 

## Prevent queries from running

In more complex apps with many queries, you can prevent queries from running if they are not immediately needed. For example, a query should only run if a user selects an option in a Select component.

To prevent a query from running, specify a truthy statement or value in the **Disable query** field. For example, 

- `{{ !select1.value }}` evaluates as true if the component has no current value.
- `{{ password.value.length

---

## _mode

There are two modes from which to select when writing an SQL query. The mode you choose depends on whether you need to read or write data:

- **SQL**: Read data using an SQL statement.
- **GUI**: Write data using a graphical query editor. 

Select **{props.mode}** mode.

---

## Explore database schemas

Retool can retrieve database table schemas from supported data sources, such as SQL databases. You can then browse the schema, search for tables and columns, and use autocompletion in the code editor.

## View schema

In the code editor for a resource query, click **Schema** to display the schema browser for the currently selected resource. The schema browser contains a list of all tables and details about their columns, such as name and type. You can also search the schema in the app IDE to find relevant tables or columns.

## Refresh schema

Retool periodically fetches the resource's schema. Click  to manually refresh the schema to reflect the latest state.

## Autocomplete table and columns

You can autocomplete table and column names in SQL mode queries by selecting one of the presented options or pressing Tab to autocomplete the first match. In GUI mode, Retool populates column names in the provided dropdowns. 

## Schemas for large datasets

If your resource contains a large number of databases or tables, Retool performs a partial fetch of the schema to prevent performance degradation. Regardless of whether the schema is complete, you can always reference valid tables and columns when writing queries.

---

## Read data from SQL databases

You can create queries that use SQL statements to retrieve (read) data from connected database resources, such as a [PostgreSQL](../../../data-sources/guides/integrations/database/postgresql.mdx) or a [MySQL](../../../data-sources/guides/integrations/database/mysql.mdx) database.

## 1. Add a query

import AddQuery from './_add-query.mdx';

import Mode from './_mode.mdx';

## 2. Write an SQL statement to retrieve data

:::tip Create AI-generated SQL queries 

You can also use the [Ask AI](../ask.mdx) option to generate SQL queries.

:::

Write an SQL statement to retrieve data from the database. The following example retrieves the `id`, `name`, `subscription`, and `expiration` values for all records in the `sample_users` table of a database.

```sql title="getUsers"
SELECT 
  id, 
  name, 
  subscription, 
  expiration
FROM
  sample_users
```

You use `{{ }}` embedded expressions to reference other values within the SQL statement, such as components and queries.

The following example adds a `WHERE` clause to retrieve only records with an `expiration` date prior to a Date Input component value.

  

```sql title="getUsers"
SELECT 
  id,
  name, 
  subscription, 
  expiration
FROM
  sample_users
WHERE 
  expiration 
  

  
  

Write an SQL statement to retrieve data from the database. The following example retrieves the `id`, `name`, `subscription`, and `expiration` values for all records in the `sample_users` table of a database.

```sql title="getUsers"
SELECT 
  id, 
  name, 
  subscription, 
  expiration
FROM
  sample_users
```

You use `{{ }}` embedded expressions to reference other values, such as blocks or webhook payloads.

The following example adds a `WHERE` clause to retrieve only records with an `expiration` date before the `expiredBefore` value provided by the [Start](../../../workflows/guides/triggers/webhooks.mdx) block.

```sql title="getUsers"
SELECT 
  id,
  name, 
  subscription, 
  expiration
FROM
  sample_users
WHERE 
  expiration >= {{ moment() }}
AND expiration 

:::info Prepared statements

To prevent SQL injection, Retool converts SQL queries into [prepared statements](../../concepts/prepared-statements) that separate the query from values. This prevents you from writing queries that dynamically reference column or table names.

:::

## 3. Run the query

import RunQuery from './_run.mdx';

---

## Query JSON data with SQL statements

You can create queries that use SQL statements to query JSON data, such as data from other queries, using the **Query JSON with SQL** resource. Instead of referencing database tables for data, you use `{{ }}` embedded expressions to reference JSON arrays of objects.

:::info Client-side SQL

Retool uses the [AlaSQL](https://github.com/AlaSQL) JavaScript library for JSON SQL queries. Some SQL syntax may differ since queries run in the browser. For example, AlaSQL uses square brackets and backticks to enclose column names that contain whitespace, rather than double quotes. 

Refer to the [AlaSQL documentation](https://github.com/agershun/alasql/wiki/Sql) for a complete reference on supported operations.

:::

## 1. Add a query

import AddQuery from './_add-query.mdx';

## 2. Write an SQL statement

import QuerySqlJson from './_query-sql-json.mdx';

:::tip Reformat JSON data structure

The structure of the `data` property depends on the response from the data source. Use the [helper](../../reference/libraries/index.mdx) methods `formatDataAsArray()` or `formatDataAsObject()` to convert between arrays and objects.

:::

## 3. Run the query

import RunQuery from './_run.mdx';

## Reference array values in JSON SQL queries

If you need to reference an array within a query, such as a list of values for an `IN` clause, prefix the array with `@`.

```sql
SELECT 
  id, 
  name, 
  subscription, 
  expiration
FROM
  {{ formatDataAsArray(getUsers.data) }}
WHERE 
  id IN @({{ activeUsers.data }})
```

---

## Write data to SQL databases

You can create SQL queries using a visual interface (**GUI** mode) to safely write data to a connected database resource, such as a [PostgreSQL](../../../data-sources/guides/integrations/database/postgresql.mdx) or a [MySQL](../../../data-sources/guides/integrations/database/mysql.mdx) database. This method helps prevent against destructive actions that malformed SQL statements could cause, such as dropping a table or overwriting existing data with incorrect values.

To test a SQL query, author the query in **GUI** mode and click **Test** to view a mock of the query response in the **Output**

:::warning

Clicking **Test** on a query in **SQL** mode runs the query. For example, testing a query in **SQL** mode that drops a table will in reality drop the table. Retool strongly recommends using **GUI** mode only when performing potentially destructive actions. Refer to [Testing queries](../../quickstart.mdx#testing-queries) for more information.

:::

## 1. Add a query

import AddQuery from './_add-query.mdx';

import Mode from './_mode.mdx';

  

## 2. Select the action type

import SqlActions from '../../../_partials/_queries/_sql-actions.mdx'

Select a table and the desired **Action type** for your query. 

## 3. Specify a changeset

import Changeset from './_changeset.mdx'

## 4. Specify filters and primary key

import SqlFilters from './_filter-by.mdx'

If required, configure the **Filter by** options for the query. For example, you may want to filter records where `id` matches the corresponding value from a selected table row.

| Column | Operator | Value                         |
| ------ | -------- | ----------------------------- |
| `id`   | `=`      | `{{ table1.selectedRow.id }}` |

The **Bulk update via a primary key** and **Bulk upsert via a primary key** actions use a specified **Primary key column** to identify which records to update. For example, you may want to specify `id` as the primary key so that the query updates each record based on the `id` values provided in the changeset array.

If required, configure the **Filter by** options for the query. or example, you may want to filter records where `id` matches the corresponding value from data received in a webhook event.

| Column | Operator | Value                        |
| ------ | -------- | ---------------------------- |
| `id`   | `=`      | `{{ startTrigger.data.id }}` |

The **Bulk update via a primary key** and **Bulk upsert via a primary key** actions use a specified **Primary key column** to identify which records to update. For example, you may want to specify `id` as the primary key so that the query updates each record based on the `id` values provided in the changeset array.

## 5. Run the query

import RunQuery from './_run.mdx';

## Use SQL statements to write or modify data

Retool recommends you only use GUI mode to write or modify data. If necessary, you can use **SQL** mode and write SQL statements to perform these actions. 

:::warning

Clicking **Test** on a query in **SQL** mode runs the query. For example, testing a query in **SQL** mode that drops a table will in reality drop the table. Retool strongly recommends using **GUI** mode only when performing potentially destructive actions.

:::

Users with sufficient permissions to modify resources (e.g., admins) can restrict write operations to **GUI** mode only. Enable **Show write GUI mode only** in a resource's settings to prevent write operations using SQL statements.

---

## Store temporary data with variables and localStorage

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

You can store data temporarily instead of writing changes back to a data source. There are three methods available:

- Variables: Temporarily store data within the app.
- localStorage: Temporarily store data in the customer's browser.
- URL query strings: Temporarily store data in the URL.

Variables are like scratch-pads for your app. You can store data in them while your app is running. They are accessible anywhere on your app inside `{{ }}`, and they support reads (`{{ variable.value }}`), as well as writes (`{{ variable.setValue(3) }}`).

[localStorage](https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage) is a flexible solution for temporarily storing data locally to the browser. All apps in your Retool organization have the same [origin](https://developer.mozilla.org/en-US/docs/Glossary/Origin) and share access to its localStorage. Users can erase their localStorage at any time though or switch to a different browser.

URL query strings are best suited for smaller pieces of information that you need to share between apps. You can append [query strings](https://en.wikipedia.org/wiki/Query_string) to an app's URL and retrieve them using the `url` object.

## Store data using variables

:::warning

Variables are reset each time your app is loaded.

:::

Variables are useful in the following situations:

- Retaining input field values or query results that can change while a user interacts with your app.
- Storing data that is only used in the app session and doesn't need to persist.
- Performing complex logic that requires temporarily storing data first.

### Create a variable

Open the code list and click **+** to create variables.

### JavaScript methods

You can call the following methods within JavaScript queries.

#### variable.setValue(value: any)

Sets `variableName.value` to the value passed in as an argument. Returns a void Promise.

For example, to set the value of `variable1` to a string "user_123_456":

```js
await variable1.setValue("user_123_456");
```

#### variable.setIn(path, value: any)

Sets the value of `variableName.value` at a specified location. `path` accepts an array of keys or indexes to select, where each item represents a key or index in the path to the object to update. The last item of the `path` array is the key or index to update. The value is set without destroying and recreating other values.

When using `variableName.setIn`, the initial value of `variableName` must be an empty object (e.g., `{ }`).

The following examples show objects before and after calls to `variableName.setIn`.

##### Path as an array of indexes

```json
"object1": {
  "key1": [
    "value1",
    "value2"
  ],
  "key2": {
    "nestedKey1": "value3"
  }
}
```

```js
await variableName.setIn(["object1", "key1", 1], "value3")`
```

```json
"object1": {
  "key1": [
    "value1",
    "value3"
  ],
  "key2": {
    "nestedKey1": "value3"
  }
}
```

##### Path as an array of keys

```json
"object1": {
  "key1": [
    "value1",
    "value2"
  ],
  "key2": {
    "nestedKey1": "value3"
  }
}
```

```js
await tempState.setIn(["object1", "key2", "nestedKey1"], "value4")
```

```json
"object1": {
  "key1": [
    "value1",
    "value2"
  ],
  "key2": {
    "nestedKey1": "value4"
  }
}
```

## Store data using localStorage

:::warning Overwriting data in localStorage

Saving a value to localStorage using a key that currently exists will immediately overwrite it. Use a naming convention if you intend to use localStorage with multiple apps.

:::

Use [localStorage.setValue()](../reference/objects/localstorage.mdx) to save data as key-value pairs to localStorage. You can also save objects to localStorage if you want to share entire data sets rather than individual values.

```javascript
// Save to localStorage

localStorage.setValue("app1name", table1.selectedRow.name);

localStorage.setValue("app1data", table1.selectedRow);
```

You can use the [State](../../apps/concepts/ide.mdx) tab to view `localStorage` and confirm that your app data was successfully saved. Click the **Left panel** button, located above the canvas, to open the Modal Browser. Expand `localStorage` to reveal the currently stored values.

### Retrieving data

Use `localStorage.values` to retrieve saved data from localStorage:

```javascript
// Load a value stored in localStorage

{
  {
    localStorage.values.app1name
      ? localStorage.values.app1name
      : "No product submitted";
  }
}

console.log(localStorage.values.app1name);

// Load a value from an object stored in localStorage

{
  {
    localStorage.values.app1data.name
      ? localStorage.values.app1data.name
      : "No product submitted";
  }
}

console.log(localStorage.values.app1data.name);
```

### Deleting data

Use `localStorage.clear()` to clear all localStorage data from your apps. You can also clear specific values by setting an empty value for a specified key:

```javascript
// Clear localStorage

localStorage.clear();

// Set an empty value

localStorage.setValue("app1name", null);
```

Retool recommends you delete data from localStorage after retrieving it once it is longer needed.

### Considerations when using localStorage

Keep in mind the following considerations to avoid common pitfalls when implementing localStorage:

- **Prevent query loops**. Avoid queries that write to localStorage that trigger based on changes to localStorage values. This can cause an infinite loop and impact your app's performance.
- **Assume apps are open in multiple tabs**. It's common for users to have multiple apps—or multiple instances of the same app—open in different browser tabs. Consequently, an event triggered by a change to a localStorage value can cause performance issues because it occurs in every instance of the app.

## Store values in URL query strings

You can send data directly from one app to another using query strings. Query strings are best suited for smaller pieces of information that is not sensitive.

Every app has a unique URL. There are two ways to pass data from one app to another with query strings:

- Use event handlers to open an app and specify query strings to include.
- Manually construct a link to another app that includes query strings in the URL.

### Configure URL query strings with event handlers

An [event handler](../../apps/guides/interaction-navigation/event-handlers.mdx) acts in response to specified user interaction, such as a button click. The **Go to app** action opens another app and includes additional options to create query strings.

Specify a name for the query string and a reference to some data to pass. For example, a query string value of `{{table1.selectedRow.name}}` would include the value for the `name` column from this table’s selected row.

### Manually construct a link

You can also link to an app with query strings attached to the URL. This method can be helpful if you need to link to an app differently or share data outside of Retool.

Copy the URL of the app you want to send data to, and add your query strings:

```html
Open in new app
```

### Retrieve query string values

You retrieve any query strings appended to the app’s URL from the `url` object. For example, you can dynamically include the value of a particular query string or display a placeholder if the value doesn't exist:

```javascript
// Load a value from a query string

{
  {
    url.searcbParams.name ? url.searchParams.name : "No product submitted";
  }
}

console.log(url.searchParams.name);
```

---

## Transform data with JavaScript

Transformers enable you to write larger, reusable, blocks of JavaScript code that can be referenced anywhere in the app. You can use JavaScript [libraries](../reference/libraries/index.mdx) and [utility methods](../reference/libraries/utils.mdx), and Transformers are scoped to the page.

Use transformers whenever you need to reuse the same blocks of JavaScript code in an app.

## Create a transformer

In the **Code** panel, click **+** > **Transformer** to create a transformer.

Transformers are written in JavaScript. The return value at the end is what becomes the value of the transformer in the rest of the app. Here's an example of using a transformer to split out the first name from a string value in a table column.

You can use `{{ yourTransformerName.value }}` to reference the transformer's value. This is how the name is displayed in the Text component in the example above.

You can also select **Test** to check the results of a transformer, but you must **Save** the transformer to use its value in the rest of your app.

## Delete a transformer

Select the transformer you want to delete in the bottom panel. Then click **•••** > **Delete** to remove the transformer.

## Query transformers

Transformers are often used to change the results of a query into a different format. When you attach a transformer directly to a query, it changes the value of the query everywhere. This means `query1.data` uses the results of the query **after** the transformer has been applied.

Here's an example using query transformers to return a specific field from the query results.

After writing this query transformer, instead of writing `query1.data.result`, you can use `query1.data`.

Query transformers work the same way as regular transformers. In the transformer, you are provided a field `data` which contains the results of the query without any modification. The return value from the transformer you write becomes the value of `yourQuery.data` in the rest of the app.

If you want the unaltered results from the query, you can use `yourQuery.rawData` to access the results before transformation.

## Transformers are read-only

Transformers in Retool are read-only: they cannot affect the values of other components or state in Retool. They can only update _their own_ value using a `return` statement. This means that if you're writing JS in a Transformer, you **cannot**:

- Set the value of a variable
- Set the value of a component
- Trigger a query

To do any of these, you'll need to use a JS Code query.

## Examples

The following show common use cases for transformers.

### Return data

To return data from the transformer, use the `return` syntax.

```javascript
const val = {{textinput1.value}}
return parseFloat(val) * 10
```

### Include a variable from your app

Use the `{{ }}` syntax to include a variable used elsewhere on the your app. The transformer will automatically re-run when the variable value changes.

```javascript
const val = {{textinput1.value}}
return parseFloat(val) * 10
```

### Use query data

To access the query results, use `{{sqlQuery.data}}`. If you need to access the original response of the query, use `{{sqlQuery.rawData}}`.

```javascript
// Retrieves query data
{{ sqlQuery.data }}

// Retrieves the original query response
{{ sqlQuery.rawData }}
```

### Convert query data to an array

If you want to use query data as an array of objects, use [formatDataAsArray](../reference/libraries/tools.mdx#formatdataasarray).

```js
{{ formatDataAsArray(sqlQuery.data) }}
```

### Sort an API query

If your API doesn't support filtering using parameters, you can sort using the `sort()` syntax.

```javascript
const data = {{query1.data}}

return data.sort((e1, e2) => e1.fieldToSortBy - e2.fieldToSortBy)
```

### Modify query data

To modify query data, use the `map()` syntax. The following example adds `1` to every query data value.

```javascript
const data = {{query1.data}}
return data.map(x => x + 1)
```

### Filter an API query

If your API doesn't support filtering using parameters, you can filter using the `.filter()` syntax.

```javascript
const data = {{query1.data}}

return data.filter(f => f.fieldToFilterBy.toLowerCase().indexOf(textInput3.value.toLowerCase()) !== -1 )
```

### Join two queries

To join the result of a REST query with a SQL query in to one table, use the `zipWith()` syntax.

```javascript
var sqlDataSorted = {{formatDataAsArray(query1.data)}}.sort((e1, e2) =>  e1.id - e2.id)
var apiDataSorted = {{query2.data}}.sort((e1, e2) =>  e1.id - e2.id)

return _.zipWith(sqlDataSorted, apiDataSorted, (sql, api) => Object.assign({}, api, sql))
```

## Failure conditions

You can use failure conditions in queries to mark your queries as failing. In the **Response** tab of the query editor, add conditions to the **Failure conditions** section. The keys in this section are the conditions, and the values are the error messages to display. If any condition results in a truthy value, Retool shows the error message.

For example, to throw an error if your API returns fewer results than you've configured in a Text Input, set a failure condition of `{{ data.results.length 

To use similar logic outside of the **Failure conditions** section, you need to include the query name (e.g., `{{ queryName.data.results.length < textinput1.value }}`).

### Failure condition properties

Within the failure conditions inputs, you can access `.data`, `.error` and `.metadata` properties. Failure conditions are especially useful to set when your resource always returns a success. For example, most GraphQL APIs return a 200 status code, even when the response contains errors.

Use `.data` to reference the data returned by your query (rows in a database, the response of an API, etc.). The `.error` property extracts an error out of the query's response. The `.metadata` property contains metadata about your query's response, such as response headers for a REST API. Note that `.metadata` is generally only available for REST and GraphQL queries.

:::note

The green evaluation box for failure conditions autocompletes your data based on the last run of the query. For example, `{{ data.error }}` in the autocomplete shows you the `.error` field from the last query result.

:::

---

## Edit queries in VS Code

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

The VS Code extension allows you to author complex code in the comfort of your own development environment. Enjoy custom keybindings, flexible window management, third-party extensions, and integration with your existing code repositories.

Retool's VS Code extension is currently available for editing queries within apps, including those protected with [Source Control](../../source-control/index.mdx). Editing Query Library and workflows queries is not yet supported.

## Setup

1. Ensure your Retool admin has enabled **VS Code Editing Enabled** in the **Settings** > **Beta** section on your Retool instance.
2. Download the VS Code [extension](https://marketplace.visualstudio.com/items?itemName=Retool.retool-vscode-extension) from the VS Code marketplace. If you are not running the latest version of Retool, use the changelog to choose the right extension version for your Retool instance.

## Usage

You can start building with the VS Code extension by following a deep link from the Retool web editor, or invoking a `Retool:*` command directly from VS Code.

1. Complete the setup steps above.

2. In VS Code, checkout the branch of your repository that you want to work in.

3. In the browser, while editing a Retool app that contains queries, open the **Code** tab and then click the **VS Code** icon.

4. The browser displays an authorization page for you to grant VS Code permission. You can also save your consent to skip this step in the future. After you click **Authorize**, your browser launches the VS Code app.

5. VS Code automatically downloads and displays the queries from the app you were editing. You can edit and save the query files as you would edit other code on your machine.

1. Complete the setup steps above.

2. Invoke the `Retool: Sign In...` command using the VS Code [Command Palette](https://code.visualstudio.com/docs/getstarted/userinterface#_command-palette).

3. Follow the instructions to open the authorization page on your Retool instance. After you click **Authorize**, your browser redirects back to your local VS Code application.

4. You can now invoke the **Retool: Open App** command from the [Command Palette](https://code.visualstudio.com/docs/getstarted/userinterface#_command-palette) to open the queries from any app you have access in VS Code. You can then edit and save the query files like regular code on your machine.

  

## Features

:::info

Some query types (e.g. REST queries) and code blocks do not appear in VS Code. See the [Known limitations](#gui-and-non-code-queries) section for more information.

:::

### Hot reloading
:::warning

Hot reloading is not currently available if multiplayer is enabled on your app.

:::

When you save query files in VS Code, the query content automatically syncs back to your Retool instance. Any open query editors in your browser tab automatically refresh when you refocus your mouse on the Retool editor. You can then click “run” to test your new code.

  

### Merge conflict resolution

If someone else saves a new version of a query you are editing, you will see a merge conflict resolution prompt in VS Code the next time you attempt to save. Once the merge conflict is resolved, the query body will sync over to Retool as normal.

### JS type completion

JavaScript query bodies benefit from type auto-completions in VS Code. Completion options should trigger for any variable available in the Retool browser context, including:

- Global objects (e.g. `window`, `Math`, `localStorage`)
- Built-in libraries (e.g. `lodash`)
- Widget names (e.g. `text1`, `input1`)
- Retool utility functions (e.g. `utils.confetti`, `formatDataAsArray`)

These types are auto-refreshed every 60 seconds based on your latest app save. To refresh types manually, you can invoke the **Retool: Refresh from Retool** quick command.

Type completions are also available within Retool expressions for JavaScript queries. Completions are not available for Retool expressions within other languages, such as SQL queries.

### Integration with extensions

Since query files are written to your local file system the same as any other code, the VS Code extension is compatible with other third-party extensions. For example, you can integrate query writing with [GitHub Copilot](https://marketplace.visualstudio.com/items?itemName=GitHub.copilot), [Vim](https://marketplace.visualstudio.com/items?itemName=vscodevim.vim), and [Code Spell Checker](https://marketplace.visualstudio.com/items?itemName=streetsidesoftware.code-spell-checker). Note that Retool is not responsible for the behavior of third-party plugins.

### VS Code commands

The VS Code extension adds several convenience commands that can be invoked from the [Command Palette](https://code.visualstudio.com/docs/getstarted/userinterface#_command-palette) to interact with your Retool instance. The following table lists the available commands.

| Name                        | Description                                                                                                   |
| --------------------------- | ------------------------------------------------------------------------------------------------------------- |
| Retool: Sign in...          | Initiate authentication flow with your Retool instance                                                        |
| Retool: Sign out...         | Sign out of any currently active sessions and revoke all cached authentication tokens                         |
| Retool: Who Am I            | Display the currently logged-in user, if any                                                             |
| Retool: Open App            | Open queries from a Retool app in the workspace. You must be logged in to run this command.
| Retool: Refresh from Retool | Fetch latest changes from your Retool instance for the currently open app. Your active tab must be a Retool query. |
| Retool: Open in Retool      | Open up a browser tab to the Retool app currently being edited. Your active tab must be a Retool query. |

## Known limitations

### Auto-formatting and linting

Linters like Prettier and ESLint may treat Retool expressions as JavaScript blocks and destroy them on format. For this reason, it's recommended to enable a linter to receive auto-suggestions, but disable the **Format on save** option in VS Code.

### Multiple Retool instances
Editing queries from multiple instances simultaneously is not supported at the moment; your workspace can only contain queries from a single Retool instance. If you open a deep link from a Retool instance and already have queries open from another instance, your existing VS Code folders will be closed automatically.

### GUI and non-code queries
Currently, only code-based queries can be edited in VS Code. Queries that are configured primarily via a graphical interface (e.g. GUI-mode SQL, REST, OpenAPI) will not appear in VS Code. In addition, aside from transformers, secondary code blocks such as event handlers are not editable in VS Code either. File a ticket on the [VS Code extension GitHub repository](https://github.com/tryretool/vscode-extension/issues) to surface feature requests.

### Creating, renaming, and deleting queries
Creating, renaming, and deleting queries is not supported from VS Code. To perform a CRD operation, save any pending changes in VS Code first, perform the operation from your Retool browser tab, and then use the **Retool: Refresh from Retool** quick command in VS Code to resync.

## Telemetry

Retool takes customer privacy and data transparency seriously. The VS Code extension only communicates with your Retool instance. You can monitor outbound network traffic in VS Code by enabling the **Help** > **Toggle Developer Tools** option.

The following usage statistics are collected by default:

- `Retool:*` VS Code command invocations
- Session duration
- Number of editing sessions over time
- Number of unique apps edited

If you run an air-gapped on-premise instance, these usage stats are not reported anywhere. Otherwise, the stats are reported to a central Retool analytics server.

The content of customer code opened in VS Code is never used for analytics and is never transmitted to any centralized Retool servers. In addition, Retool never collects data on non-Retool folders opened in VS Code.

## Feedback

To provide feedback, file an issue on the VS Code extension [GitHub repository](https://github.com/tryretool/vscode-extension/issues).

---

## Import and run a workflow from an app

The [Retool Workflows](../../workflows/index.mdx) query resource enables you to run a workflow from an app. This is useful for reducing complexity as it enables you to:

- Break down complex sets of queries into more manageable functions that perform specific actions (e.g., perform multiple API requests).
- Reuse the same actions across multiple apps, reducing the amount of duplication (e.g., transform and store data in [Retool Vectors](../../data-sources/guides/vectors/embeddings.mdx)).

The query triggers the specified workflow, passing the provided data for it to use. If the workflow produces data, it is returned back to the current app.

:::tip Run another workflow from a workflow

You can also use the [Workflow block](../../workflows/guides/blocks/run-workflow.mdx) within a workflow for the same functionality.

:::

## Import a workflow

Open the **Code** tab, add a new query, and select **Import a Workflow**. This populates a query with the **Retool Workflows** resource. You then select the workflow to run and specify the parameters to pass:

| Parameters | Description                                                                                                               |
| ---------- | ------------------------------------------------------------------------------------------------------------------------- |
| **Raw**    | Reference raw data. This can be any value, such as a string or all JSON data from a previous block (e.g., `query1.data`). |
| **JSON**   | Create a set of key-value pairs using input fields.                                                                       |
| **None**   | Do not pass any data.                                                                                                     |

You do not have to pass any data to the specified workflow. For example, you may want to run a workflow that retrieves data to then use in the app.

## Return data to the app

Workflows run from within an app operate in a similar way as a [webhook-triggered](../../workflows/guides/triggers/webhooks.mdx) workflow. When run, data passed from the app is made available on `startTrigger.data`. You must include a [Response](../../workflows/guides/blocks/response.mdx) block in the workflow to be run as this is how it returns data back to the app. If you want to trigger a workflow without returning data back to the app, you don't need a Response block.

---

## Queries and code how-to guides

import Howto from '/docs/_partials/_doctypes/_howto.mdx';

---

## Queries and code documentation

Write queries to interact with data, script apps to control behavior and respond to user events, and create functional logic to transform data using JavaScript. You can also extend the functionality of workflows with Python.

---

## Queries and code quickstart

import SideBySide from '@site/docs/_partials/_side-by-side.mdx';

This guide serves as an introduction to queries and code in Retool. It covers many of the concepts and terminology you can expect to use when querying and transforming data, scripting behavior, and executing code. After reading this page, you should have a good understanding of the fundamentals for writing queries and code.

## Introduction

[Web apps](../apps/index.mdx), [mobile apps](../mobile/index.mdx), and [workflows](../workflows/index.mdx) all rely on functional code with which to operate. The code you write, language you use, and where you write it depend on the context and functionality being used.

Queries are executable blocks of code that query data, control app behavior, and other functions. Queries must be triggered to run. This can be done with app event handlers or triggered as part of code elsewhere. Some queries can run automatically, such as when a referenced input changes (e.g., a text field) or as part of a workflow.

Retool performs [string interpolation](https://en.wikipedia.org/wiki/String_interpolation) and evaluates `{{ }}` embedded expressions as JavaScript. As a result, you can write JavaScript code that evaluates and returns a value synchronously—almost anywhere.

[Transformers](./quickstart.mdx?apps-workflows=apps#transformers) are reusable blocks of JavaScript code that synchronously transform data. You write JavaScript code that manipulates or reshapes data, such as query results, to meet your needs.

[Variables and localStorage](./quickstart.mdx#temporary-state) are data stores for apps that need to temporarily store state.

Store a value temporarily in a variable.
   

You can specify custom JavaScript code and libraries for use across Retool. You can also make use of built-in libraries and third-party libraries that Retool preloads.

   Using custom Python in a workflow.
   

## Queries

Queries are asynchronous blocks of code that execute on-demand. These are globally scoped and can be triggered from any part of an app or workflow. [Query objects](reference/objects/query.mdx) have state, expose properties, and can be controlled with methods.

The `data` property contains the results of the last run. You either select a query or reference it's `data` property to use its results.

Queries can also reference other values, such as components, and write them back to the data source. Queries can also perform asynchronous actions, run simultaneously, and trigger [event handlers](../apps/guides/interaction-navigation/event-handlers.mdx) upon success or failure.

### Resource queries

A resource query is a piece of code you write to interact with a resource (i.e., an API or database) and perform CRUD operations.

Resource queries are not part of an app's user interface. Users interact with queries via components. For example, a user completes and submits a form in a customer refund app. When the form is submitted, it triggers a `refundCustomer` query which performs a refund API action with Stripe.

If a resource query only reads data, such as retrieving a list of customers, it can automatically run. If a resource query writes data, it must be manually run using an event handler.

The query retrieves a list of customers from a database using an SQL statement.

Workflows use [Resource query](../workflows/guides/blocks/resource-query.mdx) blocks to interact with data sources. These are fundamentally the same as app queries. You either select a Resource query block or reference it's `data` property in another block. When you specify the resource to query, Retool presents relevant options based on the resource type.

Resource query blocks run automatically when part of the workflow's control flow or as part of a function.

The **Loop** block references the **getCustomers** query. Its then iterates on the query results to send an email.

#### API resource queries

Queries for API-based resources include relevant options for making API requests. Resources for popular service integrations, (Amazon S3, Google Sheets Twilio, etc.) include a tailored set of options. This abstracts away some of the complexities of working with APIs.

Other resources, such as GraphQL-based integrations or custom APIs, include more generic options and require further knowledge of working with the API.

#### SQL resource queries

You interact with databases and other structured data stores using SQL. Retool provides two modes with which to interact using SQL: **SQL** and **GUI**.

- SQL mode is for primarily for reading data from databases. You write (raw) SQL statements that retrieve matching records.
- GUI mode is for writing and modifying data in databases. Rather than need to write an SQL statement, GUI mode queries contain options to specify what changes to make and the values to use. This method helps prevent against destructive actions that malformed SQL statements could cause, such as dropping a table or overwriting existing data with incorrect values.

#### Query variable spoofing prevention

To prevent a user from manipulating network requests to pass in arbitrary values to prepared statements, Retool enables _query spoofing_ by default. This rejects network requests that refer to `current_user` properties (e.g., `current_user.email`) which don’t match the expected values for the user making the query. If you include additional logic in your expression (e.g., `current_user.groups.map(group => group.name)`), query spoofing prevention is not available.

### Code queries

You can write JavaScript code to control app behavior, transform data, set property values, and more. Workflows also supports Python code.

**JavaScript queries** are multiline blocks of JavaScript code. You can write complex JavaScript statements to perform advanced data transformations and control app behavior, such as components and other queries.

The **Loop** block references the **getCustomers** query. Its then iterates on the query results to send an email.

The following JavaScript query loops through each row of the specified table (`table1.data`) and triggers the `updateCustomer` query.

```javascript title="Loop through table rows"
var rows = table1.data;
var errors = "";
var total = rows.length;

function runQuery(i) {
  // Update the Status text
  Status.setValue("Progress: " + (i.toString() + "/" + total.toString()));

  if (i >= rows.length) {
    console.log("Finished running all queries");
    return;
  }

  console.log("Running query for row", i);

  updateCustomer.trigger({
    additionalScope: { i: i }, // This is where we override the `i` variable
    // You can use the argument to get the data with the onSuccess function
    onSuccess: function (data) {
      runQuery(i + 1);
    },
    onFailure: function (error) {
      // Update the Errors text
      errors += "Found error at line " + i.toString() + ":  " + error + "\n\n";
      Errors.setValue(errors);
      runQuery(i + 1);
    },
  });
}

runQuery(0);
```

Workflows can execute both JavaScript and Python code. You can write complex statements to perform advanced data transformations or control workflow behavior, such as triggering functions.

You can use popular [JavaScript](../workflows/guides/blocks/code/javascript.mdx#use-libraries-in-a-workflow) or [Python](../workflows/guides/blocks/code/python.mdx#available-libraries) libraries to further extend the functionality of workflows.

The **Code** block executes custom Python code that extends the functionality of a workflow.

This workflow uses a Resource query block to retrieve a list of transactions. It then uses Python to generate a bar chart that counts the total number of subscription plans. The Python code returns a base64-encoded image which can then be stored in Retool Storage or another file store resource.

```python title="Generate a chart"
def display_bar_chart():
    import matplotlib.pyplot as plt
    import base64
    import io

    plans = [customer['plan'] for customer in getCustomers.data]
    plan_counts = {plan: plans.count(plan) for plan in set(plans)}

    plt.bar(plan_counts.keys(), plan_counts.values())
    plt.xlabel('Plan Type')
    plt.ylabel('Total Counts')

    img = io.BytesIO()
    plt.savefig(img, format='png')
    img.seek(0)

    encoded_image = base64.b64encode(img.read()).decode('utf-8')
    plt.close()

    return encoded_image

return display_bar_chart()

import matplotlib.pyplot as plt
import base64
import io

def display_plan_counts_chart():
    data = getCustomers.data
    plan_counts = {}

    for customer in data:
        plan = customer['plan']
        if plan in plan_counts:
            plan_counts[plan] += 1
        else:
            plan_counts[plan] = 1

    plt.bar(plan_counts.keys(), plan_counts.values())
    plt.xlabel('Plan Type')
    plt.ylabel('Count')
    plt.title('Total Counts for Each Type of Plan')
    plt.gcf().set_size_inches(15, 8)

    buffer = io.BytesIO()
    plt.savefig(buffer, format='png')
    buffer.seek(0)
    chart_image = base64.b64encode(buffer.read()).decode('utf-8')

    return chart_image

return display_plan_counts_chart()
```

The **Code** block executes custom Python code that extends the functionality of a workflow.

The chart generated by the Python code.

### AI actions

AI actions are queries that interact with AI models. Instead of code, you write a prompt—the instructions for the AI model to follow—and include any relevant data.

The **AI action** block references the **getCustomers** query and contains instructions to generate a Markdown table.

### Analytics tracking

Retool can integrate with third-party analytics tools, such as Google Analytics and Segment. When configured, you can add **Analytics tracking** queries that send configured events when triggered.

Analytics tracking queries trigger on property change and can include conditional statements. When triggered, the query sends the configured payload to your connected analytics service.

The **Code** block executes custom Python code that extends the functionality of a workflow.

### Testing queries

When editing a query, click **Test** to test out your changes with your latest edits. Retool executes your query and displays the result in the **Output** section, but no downstream entities within Retool are updated. For example, components are not updated, and event handlers are not executed.

:::warning

In most queries, clicking **Test** fully executes the code in your query. Any changes, additions, or deletions that a query makes will in reality be completed when testing. 

To be safe, Retool recommends testing your query on non-production data.

:::

For SQL queries, clicking **Test** while using using **GUI** mode does _not_ execute the query, and outputs a mock of the SQL query. This feature helps you avoid making destructive changes.

If you want to update your app state based on the query run, click , then **Run in app**. Retool executes the query against your resource, and propagates the resulting data into your app—components update, and other queries that depend on its value will run.

Once you confirm that the query works as intended, click **Save** to finalize your changes.

## Embedded expressions

Retool performs [string interpolation](https://en.wikipedia.org/wiki/String_interpolation) and evaluates `{{ }}` embedded expressions as JavaScript. As a result, you can write JavaScript code—that evaluates and returns a value synchronously—almost anywhere. This enables you to dynamically set property values using transformations or conditional logic to build complex apps and workflows.

import Embedded from '/docs/_shared/_quickstarts/_embedded-expressions.mdx';

## Data transformations

While you can use JavaScript within `{{ }}` embedded expressions and JavaScript queries, you may need to manipulate data and implement complex logic to produce values, such as filtering or joining data sets.

### Transformers

A [transformer](./guides/transformers.mdx) is a reusable block of JavaScript. You reference property values using embedded expressions and the results of the transformation are output on the transformer's `value` property using a `return` statement.

While similar to JavaScript queries, transformers cannot control app behavior. This is because transformers are dynamically evaluated in the same way as embedded expressions. The returned value updates whenever referenced values in the transformer change.

The **Code** block executes custom Python code that extends the functionality of a workflow.

### Query transformations

If a query returns data in a format unsuitable for components or other elements in your app, you can directly transform a query's output. The return value of this transformation is then used wherever you access `query.data`.

You can also use `{{ }}` embedded expressions in query transformations. This can help improve app performance as certain actions, such as filtering, can be performed using JavaScript rather than repeatedly running a query. For example, the following snippet filters query data based on whether the first name of a customer matches the value of a Text Input component.

```js title="Query transformation"
const filteredData = formatDataAsArray(data).filter(
  obj => obj.first.includes({{ search.value }})
);
return filteredData;
```

The **Code** block executes custom Python code that extends the functionality of a workflow.

## Preloaded code and libraries

You can specify custom code and libraries to use within apps and workflows. This extends the functionality within Retool and enables more flexibility.

You can preload custom JavaScript statements and libraries on a per-app basis or for the whole organization to extend app functionality with custom logic.

The **Code** block executes custom Python code that extends the functionality of a workflow.

The **Code** block executes custom Python code that extends the functionality of a workflow.

Retool includes support for a selection of popular JavaScript libraries which you can use in a workflow. You can browse and add libraries, configure their imports, and use them in your workflow.

### Built-in libraries

import BuiltIn from "/docs/_shared/_libraries/_built-in-libraries.mdx";

### Preloaded third-party libraries

import PreloadedLibraries from '/docs/_shared/_libraries/_preloaded-libraries.mdx';

## Temporary state

Retool apps can temporarily store data using variables, localStorage, or URL query strings.

### Variables

Variables can temporarily store data for a user while the app is running. They are accessible anywhere on your app using the `value` property.

Each variable has an initial value you configure and methods with which to update it. The variable reverts back to the initial value the next time the user opens the app.

  This variable contains an array of objects as its initial value.

### localStorage

[localStorage](https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage) is a flexible solution for temporarily storing data locally to the browser. All apps in your Retool organization have the same [origin](https://developer.mozilla.org/en-US/docs/Glossary/Origin) and share access to the browser's localStorage.

Since users can erase their localStorage at any time though or switch to a different browser, localStorage should not be relied upon as a persistent data store.

  You can store data to the browser's localStorage.

### URL query and hash strings

URL query strings are best suited for smaller pieces of information that you need to share between apps. You can append [query strings](https://en.wikipedia.org/wiki/Query_string) to an app's URL and retrieve them using the `url` object.

  URL query and hash strings can be used to store values or sync state, such as the ID of a selected customer.

---

## Query and code glossary

import SharedGlossary from '../../_partials/_glossary.mdx';

---

## The File Utils JavaScript library

import Fileutils from "/docs/_shared/_libraries/_fileutils.mdx";

---

## JavaScript libraries



---

## Preloaded JavaScript libraries

import PreloadedLibraries from "/docs/_shared/_libraries/_preloaded-libraries.mdx";

import PreloadedExamples from "/docs/_shared/_libraries/_preloaded-examples.mdx";

---

## The Tools JavaScript library

import Tools from "/docs/_shared/_libraries/_tools.mdx";

---

## The Utils JavaScript Library

import Utils from "/docs/_shared/_libraries/_utils.mdx";

---

## The localStorage object

Use `localStorage` to save data locally to the browser.

## Properties

## Methods

---

## The Query object

Each Query object represents a [query](../../../queries/index.mdx) within an app, such as an SQL query or transformer. Each instance has a unique name with which to reference (e.g., `getUsers.trigger()`).

## Properties

## Methods

## Events

---

## The Variable object

Each instance has a unique name with which to reference (e.g., `myVariable1.value`).

## Properties

## Methods

---

## Queries and code reference

import Reference from '/docs/_partials/_doctypes/_reference.mdx';

---

## Insert CSV data into a database

You can use Retool's File Button and Table components to upload CSVs and insert their rows into your database.

## 1. Upload files

Start by dragging in a [File Button](https://retool.com/components/file-button) component from the right panel. Toggle on **Parse files** in the Inspector.

This button now automatically parses CSV and JSON, which you can test by uploading a file. If you don't have a CSV ready, you can [download the sample file](https://cdn.tryretool.com/docs/books.csv) used in this guide. Parsed files are stored in `fileButton1.parsedValue`, and content from a single file in `fileButton1.parsedValue[0]`. 

## 2. Render uploaded rows

You can now render your CSV rows into a [Table component](https://retool.com/components/table). Create a new Table component, then pull in data from the File Button. In the table's Inspector, change **Data source** to `{{ fileButton1.parsedValue[0] }}`.

You may need to clear out columns from the demo data before you upload your CSV. Select **...** next to **Columns** in the Inspector, then **Clear columns**.

## 3. Insert rows into your database

In this step, rows in your first table are inserted into your database when a user selects them.

First, add an **Action** button to each row, so you can choose which rows to insert. In the **Actions** section of the Inspector, select **+**. Name it **Insert into DB**.

Next, create another query and name it `insertIntoDB`. Select your database as the _Resource_ type. This example uses Retool Database to store data.

Use **GUI mode** in the query to enable safe writes to your database, and select your table. This example uses the `books` table. Set the following parameters:

- **Action type**: **Insert a record**
- **Changeset** type: **Object**
- **Changeset** value: **table1.selectedRow**

If it's safe to do so for your database, select **Save & Run** to test this query.

Finally, connect the **Insert into DB** action to the query by adding `insertIntoDB` as an event handler to the action. This inserts a record into the database based on the selected row in the uploaded CSV table. You can modify this query later to perform a bulk upload and use data from the entire table.

## 4. Verify uploaded data

To verify the data is uploaded properly, create a Table component containing its records. Drag a Table component onto the canvas.

Create a SQL query to retrieve your database records, then set this SQL query as the **Data source** for your new table.

```sql getBooks
select * from books order by id desc;
```

Finally, you can selectively disable the Upload button for rows that are already uploaded. In the **Copy to DB** action, set the **Disabled** field to `{{ table3.data.find(i => i.id === currentSourceRow.id )}}`. This disables the **Copy to DB** function for rows whose IDs are already present in the `books` database.

---

## Firebase query tutorial

Retool supports Firebase's Admin API and allows you to build CRUD apps on top of Firestore, RealtimeDB, and Auth data.

## Working with Firestore

You need to connect a Firebase resource before you can work with Firestore. Follow the [Connect to Firebase](../../../data-sources/guides/integrations/development/firebase.mdx) guide to connect a Firebase resource if you haven't yet.

:::tip Firestore admin panel template

Retool built a [template](https://retool.com/templates/firestore-admin-panel) that can help you get started with CRUD operations. To use the template, click **Create new** and then **Create from template** on your Retool homepage. Select the Firestore Admin Panel template to get started.

:::

### Query Firestore and get Collections

To query Firestore, create a new resource query and select **Firestore** from the **Service type** dropdown. Set the **Action type** to **Query Firestore**. You can also specify a collection using the dropdown, or input a custom value by clicking **Use raw id**.

Retool lets you query using a key (a document field), operators (`==`, `in`, `>=`, etc.), and a value. You can add as many statements as you need, and you can also set limits, order results by field, etc.

You can set the value of your key or value dynamically with JavaScript, which you can use to implement features like search. For example, you can use a Text Input component to pass a search term into the `value` input.

### Format Firestore query results for a Table component

You can display the query's results in a Table component to view all the documents in a collection. Either select the query in the **Data source** dropdown, or use JavaScript (`{{ query_name.data }}`).

You may need to use `lodash` or other [JavaScript libraries](../../guides/javascript/custom.mdx) to reformat your data for display in the Table component. For example, use`{{ _.values(query_name.data) }}`, or for more advanced use cases, use `.zipWith`:

```
_.zipWith(_.keys(query_name.data), _.values(query_name.data), (key, value) => Object.assign({}, { key: key}, value))
```

You can write this code in the **Data source** field of the table, apply it as a transformer in your query, or create a transformer. See the [transformer docs](../../guides/transformers.mdx) to learn more. You can also use helper functions, such as [formatDataAsArray](../../reference/libraries/tools.mdx), but you might need to do some custom formatting.

Retool allows you to query available Firestore collections (top level or under a specific document ID), which you can use to dynamically select which documents to display in the table. To get started, create a query that lists top level collections.

To query a nested collection, specify the **Parent document ID**. You can also specify the document path (e.g., `home/locations/restaurants`).

Next, display the results of this query in a Select component.

Then connect the value of the Select component to your original query (`query1` in the example) by changing the **Collection** to use a raw ID and pass the value of the Select component. Make sure that your first query is set to run when inputs change.

### Update documents in Firestore

To update a Firestore document, you need the document’s ID and the object to update it with. Create a new query, select your Firebase resource, choose **Firestore** from the **Service type** dropdown, and choose **Update Document** as the **Action type**.

Passing a partial object as the value updates only your passed fields.

There are a few ways to build a UI for the update flow:

1. Use a Form component with Text Input components for each document field you want to update.
2. Use a JSON Editor component that lets you update values directly, and submit the changed values with a Button component.
3. Make columns in the Table component editable.

You can choose whichever pattern fits your users’ needs, as long as you format the results as a JSON object and pass it in the **Value** field of your query. Both the document ID and value can be dynamic, so you can pass their values using JavaScript in `{{ }}`. For this guide, a Table component is used to make updates.

Select the table to make the columns editable. To simplify the example, a single column is made editable.

This makes the columns editable on the frontend but doesn't save the changes to your resource. To save the changes, open the query you created previously that updates a document.

For document ID, pass the ID of the edited row with `{{ table1.changesetArray['0'].id }}` (this works for updating a single row, but you'll learn how to [update multiple rows](#update-multiple-rows) in a subsequent section). Enable **Use raw id** for the collection, and pass the selected value from the dropdown.

When you edit tables, the changes are stored in the `changesetArray` property until they're saved. You can pass values from this property into queries. For this example, set the **Value** in the query to `{ "streetname": "{{ table1.changesetArray['0'].streetname }}"}`. Your query should now look something like this.

Make sure to save the query. If some of the values display an `undefined` error, this is expected if the table hasn't been edited yet. 

When a change is saved, the update query needs to run, but the table also needs to be refreshed after the update. To do this, add a **Save action** to the table, connect it to the update query, and then add a success event handler to the update query that triggers your original query. The demo below illustrates this process.

Edit the `streetname` for one of the rows and then click **Save** to test the workflow. 

#### Update multiple rows

The app currently supports updating a single row. To update multiple rows, create a JavaScript query that iterates through the table's `changesetArray` property, which contains all the changes. On each iteration, you trigger the update query for the changed row.

```javascript
const toUpdate = table1.changesetArray
toUpdate.forEach ((record) => {
  query3.trigger({
    additionalScope: {
      document_id: record.id,
      document_object: record
    }
  })
})
```

This code uses `additionalScope` to pass values from `table1.changesetArray` to `query3`, which updates each row.

To connect your JavaScript to the update query, set the **Document ID** to `{{ document_id }}` and **Value** to `{{ document_object }}`. These values are passed from `additionalScope`.

Finally, update the save action on the table to trigger the JavaScript query instead of the update query.

You can now edit multiple street names to test this functionality.

### Use references in Firestore queries

If your Firestore query needs to use [Database References](https://firebase.google.com/docs/reference/js/database.databasereference.md), you can reference them in Retool using the `$ref` identifier in the value of your query.

The syntax is similar to [MongoDB Extended JSON](https://docs.mongodb.com/manual/reference/mongodb-extended-json/) syntax, where `$ref` specifies that the string should be a ref.

### Insert a document

Create another query and select your Firebase resource. Then set:

- **Service type** to **Firestore**.
- **Action type** to **Insert document**.
- Your **Collection** value.

Inserting a document in Retool takes the same format as updating a document, but you can leave the document ID blank if you want Firestore to automatically generate one.

### Delete a document

Create another query and select your Firebase resource. Then set:

- **Service type** to **Firestore**.
- **Action type** to **Delete document**.
- Your **Collection** value.

The only parameter you need to provide is a document ID, which you can pass dynamically based on the selected row (e.g., `{{ table1.selectedRow._id }}`).

### Get document by ID

Create another query and select your Firebase resource. Then set:

- **Service type** to **Firestore**.
- **Action type** to **Get Document by ID**.
- Your **Collection** value.

The only parameter you need to provide is a document ID, which you can pass dynamically based on the selected row (e.g., `{{ table1.selectedRow._id }}`).

## Working with RealtimeDB

Retool lets you get, update, and delete records in your RealtimeDB.

:::note

You must provide the **Firebase database URL** to query Firebase Realtime Database.

:::

### Query the database

To query the RealtimeDB, create a query and select your Firebase resource. Then set:

- **Service type** to **Realtime Database**.
- **Action type** to **Query Database**.
- Your [DatabaseReference](https://firebase.google.com/docs/reference/js/database.databasereference.md).

If you enable **Use ordering**, you can access these ordering and filtering options.

- Order by child, key, or value.
- Limit to the first or last item.
- Use `equalTo`, `startAt`, and `endAt` to [filter your queries](https://firebase.google.com/docs/reference/js/database.query).

### Set and update data

The Firebase database offers [two APIs for updating data](https://medium.com/@jasonbyrne/closer-look-at-firebase-set-versus-update-eceff34d056b): `.set()` and `.update()`.

The `.set()` method _replaces_ your chosen object with the value that you provide. For example, if your initial object has five fields, and you use `.set()` to only pass three fields, the updated object only contains the three fields. To use this method in Retool, choose **Set** from the **Action type** dropdown. You need to provide a database ref and an object to set.

The `.update()` method updates fields if they exist, but doesn't replace an entire object. The query format is the same as `.set()`, except that you set the **Action type** to **Update data** and provide your database ref and update object.

:::warning You cannot set or update root level properties

You can't run `.update()` or `.set()` queries on the root of your database. If your database ref doesn't have a `/` in it (e.g., references a child), your queries fail. If you input a database ref but the query still fails, you might need to try prepending it with a slash (e.g., `/characters` instead of `characters`).

:::

### Delete fields

Retool doesn't support deleting fields or objects directly, but you can use the `set()` method to change a value to `null`. When you `.set()` a property to `null`, it is deleted from the database. Make sure to pass `null` as JavaScript in curly braces, e.g., `{{ null }}`.

## Working with Firebase Auth

Retool lets you view, update, add, and delete users from your Firebase Authentication setup.

:::tip Firestore admin panel template

If want to do basic CRUD operations on your Firebase Auth data, Retool built a template that can help you get started. [See more details](https://retool.com/templates/firebase-auth-admin-panel) or click **Create new** and then **Create from template** on your Retool homepage. Look for the Firebase Auth Admin Panel template to get started.

:::

### List users

To list your existing Firebase Auth users, create a query and select your Firebase resource. Then set:

- **Service type** to **Firebase Auth (user management)**.
- **Action type** to **List users**.

You can display the results of the query in a table by selecting the query as the table's **Data source**.

You can limit the number of users the query returns using the **Number of users to retrieve** property. You can set this value manually or use a dynamic value referencing a component's value—for example, `{{ textInput1.value }}`.

### Get a user by UID, email, or phone number

To get a user by UID, email, or phone number, create a query and select your Firebase resource. Then set:

- **Service type** to **Firebase Auth (user management)**.
- **Action type** to UID, email, or phone number.

The example query below retrieves a user by their email address, which is passed in dynamically from a Text Input component.

### Delete a user

To delete a user, create a query and select your Firebase resource. Then set:

- **Service type** to **Firebase Auth (user management)**.
- **Action type** to **Delete a user**.

You also need to pass the user's UID. In the example query below, the ID of the selected user is passed into the query.

### Update a user’s information

To update a user’s information, create a query and select your Firebase resource. Then set:

- **Service type** to **Firebase Auth (user management)**.
- **Action type** to **Update a user**.

You also need to pass the user's UUID and the update object.

You can design your UI for updating users in various ways: a form, a raw JSON object, an editable table, etc. If you want to use a table, see the section above on [updating documents](#update-documents-in-firestore) for an example.

A common use case for Firebase Auth in Retool is verifying email addresses. You can use the [update example](#update-a-users-information) for this.

### Create a new user

To create a new user, create a query and select your Firebase resource. Then set:

- **Service type** to **Firebase Auth (user management)**.
- **Action type** to **Create a user**.

You also need to provide a user object. Technically, the Firebase API doesn’t require you to include any fields, but Retool recommends passing at least an email address and password.

Remember that the user object field is dynamic, so you can pass values from other Retool components (a form, two text inputs, etc.) as you build your UI.

:::tip Ask the community about Firebase/Firestore

If you're running into any issues with Firebase/Firestore in Retool, check out some of the [answered questions on our community forums](https://community.retool.com/search?q=firebase), or [ask one of your own](https://community.retool.com/).

:::

## Use timestamps in Firestore queries

Firestore uses a custom data type for timestamps and does not support string values. To write timestamps back to Firestore, provide the timestamp directly in a query, such as `{ lastUpdatedAt: {{ moment() }} }` or `{ lastUpdatedAt: {{ new Date() }} }`. Any values provided to a query using `additionalScope` are strings and cannot be used.

---

## Google Analytics query tutorial

You can connect to [Google Analytics](../../../data-sources/guides/integrations/google/google-analytics.mdx) by creating a resource in Retool. Once complete, you can write app or workflow queries to interact with Google Analytics APIs.

To start, select the API you want to query from the **API** dropdown. Next, select the desired API operation from the **Operation** dropdown. You can also search for available operations within this field.

After you select an operation, the query editor displays additional **Path** and **Query** parameters.

:::caution 

If you connect to Google Analytics using OAuth 2.0, you need to grant access to Retool in the Google Admin console under **Security** > **Apps**. 

:::

## Build an analytics report

To build a report using the `/reports:batchGet` operation of the v4 Reporting API, review the [Google Analytics API documentation](https://developers.google.com/analytics/devguides/reporting/data/v1/rest/). Google also provides an interactive [Request Composer](https://ga-dev-tools.appspot.com/request-composer/) for building requests you can copy and paste into Retool.

## Process the report response

The `/v4/reports:batchGet` endpoint returns an array of Report objects. While the Report object contains useful metadata, you may need to manipulate the data to render its results in a chart or table. You can use the following transformer on your query to parse results into a useable table.

```javascript title="Transformer Code"
const transformedReports = data.reports.map((report) => {
  const { columnHeader } = report;
  const dimensionEntries = (columnHeader.dimensions || []).map((name) => name);
  const metricHeaderEntries = (
    columnHeader.metricHeader.metricHeaderEntries || []
  ).map((o) => ({ ...o, key: o.name }));
  const rows = report.data.rows || [];

  const formattedData = rows.reduce((arr, row) => {
    const dimensions = row.dimensions || [];
    const flatDims = dimensions.reduce((obj, value, index) => {
      const key = dimensionEntries[index];
      return { ...obj, [key]: value };
    }, {});
    const flatMetrics = row.metrics[0].values.reduce((obj, value, index) => {
      const { key } = metricHeaderEntries[index];
      return { ...obj, [key]: Number(value) };
    }, {});
    arr.push({ ...flatDims, ...flatMetrics });
    return arr;
  }, []);
  return { ...report, formattedData };
});

return { ...data, reports: transformedReports };
```

The following snippets show the response after the transformer has been applied.

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

```json
    [ {
        "ga:landingPagePath": "/",
        "ga:users": 147825,
        "ga:goal1ConversionRate": 5.254646535406078,
        "ga:goal1Completions": 14102
      },
      {
        "ga:landingPagePath": "/contact",
        "ga:users": 32371,
        "ga:goal1ConversionRate": 0.0040,
        "ga:goal1Completions": 130
      }, {...},
]
```

```json {{gaQuery.data.reports\[0].data}}
  { "columnHeader": {
        "dimensions": ["ga:landingPagePath" ],
        "metricHeader": {
          "metricHeaderEntries": [
            { "name": "ga:users", "type": "INTEGER" },
            {  "name": "ga:goal1ConversionRate","type": "PERCENT" },
            { "name": "ga:goal1Completions",  "type": "INTEGER" }
          ]
        }
      },
      "data": {
        "rows": [
          { "dimensions": [ "/" ],
            "metrics": [
              {  "values": [ "148876", "5.270975823347485", "14265" ]  }
            ]  },
          {
            "dimensions": [ "/blog/salesforce-for-engineers/" ],
            "metrics": [
              { "values": [  "31963",  "0.0",  "0"  ] }
            ]
          }, {...}],
     ...}
```

---

## Google Sheets query tutorial

You can build Retool apps using your [Google Sheets](https://docs.google.com/spreadsheets) data, reading and writing data to Google Sheets as you would any other data source. This means you can also [query Google Sheets using SQL](../../guides/sql/query-json.mdx) and combine it with other data sources.

This guide explains how to:

- Query Google Sheet data.
- Display the data in a table.
- Use a form to add rows.
- Edit individual cells.

## Requirements

To build apps with Google Sheets, you need:

- A [Google Sheets resource](../../../data-sources/guides/integrations/google/google-sheets.mdx).
- Edit access to the Google Sheet you want to work with.

### Spreadsheet requirements

To make it easier to work with Google Sheet data, your spreadsheet should meet these requirements:

- The first row needs to contain column names that map to the data in each column.
- Column names should only use alphanumeric characters and lowercase letters, and underscores to separate words.
- There should be no empty columns between columns.
- There should be no empty rows between rows.

If your spreadsheet groups data in a different format (e.g., summary data in a standalone cell), you can instead use [A1 notation](https://developers.google.com/sheets/api/guides/concepts#a1_notation) to query data.

:::note

Retool queries a maximum of 26 columns (`A:Z`). If you have more than 26 columns in your data, you need to use [A1 notation](https://developers.google.com/sheets/api/guides/concepts#a1_notation).

:::

## 1. Create an app

If you haven't created an app yet, [log in to Retool](https://login.retool.com/auth/login) and click **Create new** -> **App**. Name the app and then click **Create app**.

## 2. Write a query to access your data

To work with Google Sheets, create a query to pull the data into your app. Click **+** > **Resource query** in the query editor.

Confirm the following query settings are correct:

- **Resource** is set to your Google Sheets resource.
- **Action type** is set to **Read data from a spreadsheet**.
- **Spreadsheet** is set to the spreadsheet that contains your data.
- If your data isn't contained on the first sheet, pass the sheet name in the **Sheet name** field.

Click **Save and run** to query your data.

If needed, you can set a **Data range** using **Limit** and **Offset**, or [A1 notation](https://developers.google.com/sheets/api/guides/concepts#a1_notation). Limit caps the number of rows returned, excluding the first row with your column names. Offset sets an integer offset on the rows returned, excluding the first row with your column names.

## 3. Display your data in a table

To display the data from your query, drag a [Table component](https://retool.com/components/table) to the canvas. Retool automatically sets the table's **Data source** to the query you created. The **Primary key** should also be set, but verify the value is correct before continuing.

## 4. Add rows

To create rows and append data to your spreadsheet, you need to make the table columns editable. With the table selected, click **•••** in the **Columns** section and select **Make all columns editable**.

Next, drag a [Form component](https://retool.com/components/form) to the canvas and click **Generate form**. Use the default **Source** of `table1`, verify the column and input types are correct, and click **Generate form**. This form is used to add rows, so it should be populated with blank values. To remove the currently selected row data, select the form and delete the **Data source** value in the Inspector.

To add rows, you need a query that writes data from the form back to your spreadsheet. Create another resource query and set:

- **Action type** to **Append data to spreadsheet**.
- **Values to append** to `{{ form1.data }}`.

Scroll to the bottom of the query editor and add a success **Event handler**. Set **Query** to the query that pulls data from your spreadsheet. This way, when you add a row, the table data in your app updates automatically.

Make sure to save the query.

The last step to add rows is to create an event handler on the form's **Submit** button. Select the button and click **+** in the **Event handlers** section. Make sure **Query** is set to the query you just created.

Test out the form by filling out the data and clicking **Submit**.

## 5. Update existing rows

When you made columns editable, it made it possible to click individual cells and edit them. To save these edits back to your spreadsheet, create another resource query and set:

- **Action type** to **Bulk update a spreadsheet by primary key**.
- **Primary key column** to the column you use as the primary key.
- **Array of rows to update** to `{{ table_name.changesetArray }}`.
- A success event handler that runs the query that reads data from your spreadsheet.z

Save the query and then select your table. Click **Save actions** under **Add-ons** in the **Inspect** tab. Create an event handler that runs the bulk update query.

Edit a few cells and click **Save** to test the edit functionality.

If the bulk update query doesn't work for your use case, you can also write a JavaScript query to iterate through rows and update them individually.

```javascript
// Get list of changes
const updates = table1.changesetArray.map((d, i) => {
  // Trigger the query that updates an individual row
  update_row.trigger({
    // Use additional scope and the i variable to pass updates to
    // for each change to the query that updates individual rows
    additionalScope: { i: i },
    onSuccess: function (data) {
      if (i == table1.changesetArray.length - 1) {
        // Refresh table data after updating
        // the last row
        getTableData.trigger();
      }
    },
  });
});

return Promise.all(updates);
```

## Data type options

By default, Retool reads Google Sheets data as formatted strings (e.g., "$1.25" or "TRUE"). This means table sorting is string-based, and column types might not match your spreadsheet exactly. You can optionally configure queries to read data as typed values instead. To enable this option, select **Read data as typed values** in the **Data types** section of the query editor.

Formatted strings work well when you:

- Display data in a table exactly as it appears in Google Sheets, and you don’t need to use any table sorting or formatting features.
- Use column formats supported by Google Sheets that are not supported by Retool.

Formatted strings do not work well when you try to apply Retool’s column formats to them. For example, a formatted boolean from Google Sheets is `"TRUE"` or `"FALSE"`, which if you used with the **Boolean** column type, would always evaluate to `true`.

If you decide to read data as typed values, uncheck **Compare formatted spreadsheet values** in queries that write data back to your spreadsheet so rows are updated correctly.

---

## Queries and code example tutorials



---

## Amazon S3 query tutorial

You can connect to [Amazon S3](../../../data-sources/guides/integrations/object-file-store/amazon-s3.mdx) or S3-compatible services by creating a resource in Retool. Once complete, you can write app or workflow queries to interact with S3 bucket data.

You select the **action type** for S3 queries that determines what action the query performs, such as listing all files or uploading data.

## List all files in a bucket

Select **List all files in a bucket** to retrieve a list of all files. This contains information about each file, such as the file key.

You can use **Prefix to filter results** so only file keys that start with the same string are returned. In general, use prefixes to filter directory structure, such as `images/`. You can enter values directly into this field or reference component values like `{{ textInput.value }}`.

## Read a file from S3

Select **Read a file from S3** to retrieve the contents of a specified file. You set the value of **S3 file key** to the corresponding key of the file to retrieve. The content of the file is Base64-encoded.

For example, you can configure a [Listbox](https://retool.com/components/listbox) component to use data from a query that lists all images in S3. The selected file is retrieved from S3 using `{{ listbox1.value }}` as the **S3 file key**, then displayed using the [Image](https://retool.com/components/image) component.

## Download a file from S3

Select **Download a file from S3** to retrieve a specified file from the S3 bucket. This action is similar to **Read a file from S3** but the file is downloaded by the browser instead of being made available by the query.

## Generate a signed URL

Select **Generate a signed URL** to retrieve a direct link to the file. You specify the **operation name** that the URL supports, such as GET or PUT, along with any **operation options** to include.

For example, you can select a file from a list and generate a signed URL for it that expires in 60 seconds. Set the **Operation name** to **Get object** and **Operation options** to the following:

    
    ```json
    {
      Key: {{ listBox1.value }},
      Expires: 60
    }
    ```
  
  
    ```json
    {
      Key: {{ listBox1.value }},
      expiresIn: 60
    }
    ```
  

The signed URL can be used by anyone to download the file, but is no longer valid after 60 seconds.

## Upload data

Select **Upload data** to upload data to the S3 bucket. You configure the following settings when writing an upload query:

| Action type          | Description                                                                                                                             |
| -------------------- | --------------------------------------------------------------------------------------------------------------------------------------- |
| **S3 Content-Type**  | The MIME type for the uploaded file. You can select a MIME type for common file types, such as CSV and JSON, or specify a custom value. |
| **Upload file name** | The file name for the uploaded data.                                                                                                    |
| **Upload data**      | The base64-encoded data to upload.                                                                                                      |

The [File Button](https://retool.com/components/file-button), [File Dropzone](https://retool.com/components/file-dropzone), and [File Input](https://retool.com/components/file-input) components for web apps return base64-encoded values and MIME types for selected files.

The [Image Input](../../../mobile/reference/components/media/image-input.mdx) component for Retool Mobile apps returns blob values and MIME types for selected files. Use [utils.getDataByObjectURL](../../reference/libraries/utils.mdx#utilsgetdatabyobjecturl) in a JavaScript query first to convert blobs into Base64-encoded values.

```js convertToBase64
return utils.getDataByObjectURL(imageInput1.value[0]);
```

## Copy a file to a new location

Select **Copy a file to a new location** to copy a file and save it to another location. You provide the key of the file to copy as **Copy source**, and the key of the file to create as **Destination file key**.

## Delete a file from S3

Select **Delete a file from S3** to delete the specified file from the S3 bucket. To prevent accidental deletion, you can enable **Show a confirmation modal before running** in the **Advanced** tab of the query. You can also reference the current file key the query would delete in the **Confirmation message**:

```
{{ deleteData.fileKey }} will be permanently deleted. Are you sure?
```

## Get, delete, or update tags on a file from S3

Select **Get tags on a file from S3** to get all tags for the specified file. Tags are returned as key-value pairs. Select **Delete tags on a file from S3** to remove all tags from the specified file.

Select **Update tags on a file from S3** to update the specified tags or add new ones. Set **Tag Set** with key-value pairs for the required tags.

---

## Salesforce query tutorial

After setting up a [Salesforce integration](../../../data-sources/guides/integrations/crm/salesforce.mdx) with Retool, your Salesforce resource is available to use in the query editor. You can then configure a query using the Salesforce Object Query Language (SOQL) or other query types to retrieve and modify data from Salesforce.

## Query types

Under **Query types**, choose the method to use to query Salesforce. **SOQL queries** are often used to read data, and **CRUD action** and **Bulk load** are often used to write data.

### SOQL queries

Select **SOQL query** to construct queries using [Salesforce Object Query Language (SOQL) syntax](https://developer.salesforce.com/docs/atlas.en-us.soql_sosl.meta/soql_sosl/sforce_api_calls_soql.htm).

For example, the following query retrieves opportunities marked "Closed Won" within the last month.

```sql
SELECT Id, Name
FROM Opportunity
WHERE StageName = 'Closed Won' and CloseDate >= {{ moment().format('YYYY-MM-01') }}
```

### CRUD action

The **CRUD Action** query type supports **Retrieve**, **Create**, **Update**, **Delete**, and **Upsert** operations. It accepts a **Resource type** and **Resource ID**. See the [Salesforce Object Reference](https://developer.salesforce.com/docs/atlas.en-us.object_reference.meta/object_reference/sforce_api_objects_list.htm) for a list of standard objects.

### Bulk load

Using the **Bulk load** query type, Retool supports Bulk Insert, Bulk Update, Bulk Upsert, and Bulk Delete operations.

For example, the following query inserts Account objects.

The following query updates Account objects. The `extIdField` option specifies the external ID field name.

## Troubleshoot access tokens

If you see an `expired access/refresh token` error when running Salesforce queries, you may need to change a setting in Salesforce to allow Retool to generate valid access and refresh tokens.

- If you have **Enforce IP restrictions** set in your **IP Relaxation** settings, consider editing your policy to **Refresh token is valid until revoked**.
- Ensure you only enable the **Connect to a sandbox organization** resource setting if you are connecting to a developer sandbox organization.
- Ensure the **Timeout value** in your [organization-wide settings](https://help.salesforce.com/s/articleView?id=sf.connected_app_manage_session_policies.htm&type=5) is not too low.

---

## Shopify GrapQL query tutorial

You can connect to Shopify by creating a GraphQL or REST API resource in Retool. This guide provides examples using the GraphQL API.

## Retrieve customers

The following GraphQL query retrieves the name, email, address, and order count for the first 20 customers.

```graphql
query {
  customers(first: 20) {
    edges {
      node {
        displayName
        email
        defaultAddress {
          name
          address1
          address2
          city
          province
          country
          zip
        }
        ordersCount
      }
    }
  }
}
```

To use this data in a Table component, access the `.node` property of each result. The following example shows how to destructure the query results (here, named `getCustomers`). Use this example as the **Data source** of Table.

```
{{ getCustomers.data.customers.edges.map(customer => customer.node) }}
```

## Retrieve orders

The following GraphQL query retrieves the product names, quantity, email, and price for the first 10 orders in your Shopify store.

```graphql
query {
  orders(first: 10) {
    edges {
      node {
        email
        lineItems(first: 10) {
          edges {
            node {
              product {
                title
              }
              quantity
            }
          }
        }
        totalPriceSet {
          shopMoney {
            amount
          }
        }
      }
    }
  }
}
```

To access these results in a Table component, destructure the results by mapping the `edges` field.

```
{{ getOrders.data.orders.edges.map(order => order.node) }}
```

To display the nested values directly, rather than as objects, set the column's **Mapped value** field. For example, to use the `amount` field as a table column, set its mapped value to `{{ self.shopMoney.amount }}`.

## Server-side pagination

Shopify’s GraphQL API supports server-side pagination using GraphQL relay based cursor pagination.

### 1. Update your query

Add the `cursor` field under `edges`, and the following variables in the customers query.

`(first: $first, last: $last, after: $afterPage, before: $beforePage)`

For example, an updated `getCustomers` query might resemble the following.

```graphql
query ($first: Int, $last: Int, $afterPage: String, $beforePage: String) {
  customers(
    first: $first
    last: $last
    after: $afterPage
    before: $beforePage
  ) {
    edges {
      cursor
      node {
        displayName
        email
        defaultAddress {
          name
          address1
          address2
          city
          province
          country
          zip
        }
        ordersCount
      }
    }
  }
}
```

After you add these variables to your GraphQL query, assign values by filling in the **Variables** section in the query editor. Set the following variables, where `table1` is the name of your table.

| Key          | Value                                                                      |
| ------------ | -------------------------------------------------------------------------- |
| `first`      | `{{ table1.pagination.beforeCursor ? null : table1.pagination.pageSize }}` |
| `last`       | `{{ table1.pagination.beforeCursor ? table1.pagination.pageSize : null }}` |
| `afterPage`  | `{{ table1.pagination.afterCursor }}`                                      |
| `beforePage` | `{{ table1.pagination.beforeCursor }}`                                     |

See the guide to [server-side pagination](../../../apps/guides/data/table/pagination.mdx) for more information.

### 2. Configure table server-side pagination

In the **Add-ons** section of the table's Inspector, select **Pagination**, then **Enable server-side pagination**. Under **Pagination type**, select **GraphQL Relay cursor based**. Fill in the input fields with the following values.

| Field                | Value                                                                   |
| -------------------- | ----------------------------------------------------------------------- |
| Previous page cursor | `{{ _.first(getCustomers.data.customers.edges).cursor }}`               |
| Next page cursor     | `{{ _.last(getCustomers.data.customers.edges).cursor }}`                |
| Has more data        | `{{ _.last(getCustomers.data.customers.edges).cursor ? true : false }}` |

---

## SMTP query tutorial

If you have your own SMTP service, you can add it as resource to make it available in Retool apps and workflows. Once configured, you can send emails using your mail provider.

## 1. Create an SMTP resource

Follow the [Connect to SMTP servers](../../../data-sources/guides/integrations/messaging/smtp.mdx) guide to add your SMTP service as a resource.

## 2. Create an app

If you haven't created an app yet, [log in to Retool](https://login.retool.com/auth/login) and click **Create new** -> **App**. Name the app and then click **Create app**.

## 3. Add a Form component

Drag a Form component to the canvas, then click **Add components**. Select **Email** from the list to add an email field to the form.

## 4. Create a query

Create a resource query and select your SMTP resource. Enter a valid email address in the **From** field. You can customize the sender name using the format `"custom-name" custom-email@domain.com`. Set the **To** field to `{{email1.value}}`. This passes the email address in the Email component to the query. Then, fill out the subject and body. You can optionally use Retool's AI feature to draft the body content. Make sure to save the query.

## 5. Add an event handler

To send the email, you need to add an event handler to the **Submit** button. Select the button and then click **+** in the **Event handlers** section of the **Inspector**. The default settings should run the query you created, but make sure that:

- **Event** is set to **Submit**.
- **Action** is set to **Control query**.
- **Query** is set to the query you created.

## 6. Test the form

To test the form, enter a valid email address and click the **Submit** button. If you don't see the email in your inbox, check your spam folder.

## Add attachments to emails

Whether you use Retool Email or your own SMTP service, you can allow users to add attachments to the emails they send. To do this, add a File Button, File Dropzone, or File Input component to the canvas. Then in the query that sends the email, add the component in the **Attachment(s)** field. This allows users to upload an attachment using the app, and then automatically add it to the email.

You can also set the **Attachment(s)** field to the results of a [Retool Storage query](../../../data-sources/quickstarts/retool-storage.mdx) or any query returning a [file object](../../guides/files.mdx) in Retool.

---

## Stripe query tutorial

You can connect to [Stripe](../../../data-sources/guides/integrations/finance/stripe.mdx) by creating a resource in Retool. Once complete, you can write app or workflow queries to interact with Stripe data.

You select the **Operation** for Stripe queries to determine what action the query performs, such as retrieving a list of customers or creating a refund.

## Select an operation

:::note

Click **Stripe docs** to access Stripe's API documentation at any time.

:::

Query operations are derived from the API request methods available in [Stripe's API](https://stripe.com/docs/api). When a query is run, Retool performs the API request using your Stripe API key. When you select an operation, the query editor displays the available settings for you to configure.

For example, the **GET /v1/customers** operation performs a GET request to [retrieve a list of customers](https://stripe.com/docs/api/customers/retrieve). You can provide values for attributes like `email` and `limit` to retrieve only the customers required.

If you use Stripe Connect, you can specify the account ID of a connected account with the `Stripe-Account` field.

## Automatically paginate results

You can automatically paginate results by enabling **Auto-paginate**. This option fetches all paginated results without the need to perform [server-side pagination](../../../apps/guides/data/table/pagination.mdx).

---

## Resource query tutorial

This tutorial explains how to create resource queries that interact with connected resources. There are two types of resource query:

- **API**: Queries that use API requests to interact with API-based resources.
- **SQL**: Queries that use SQL statements to interact with SQL-based resources such as databases and similar data stores.

## Introduction

Queries for API resources include relevant options for making API requests. Resources for popular service integrations, ([Amazon S3](../../data-sources/guides/integrations/object-file-store/amazon-s3.mdx), [Google Sheets](../../data-sources/guides/integrations/google/google-sheets.mdx) [Twilio](../../data-sources/guides/integrations/messaging/twilio.mdx), etc.) include a tailored set of options. This abstracts away some of the complexities of working with APIs.

Other resources, such as [GraphQL](../guides/api/graphql.mdx)-based integrations or custom APIs, include more generic options and require further knowledge of working with the API. 

Queries for databases and similar types of structured data stores use SQL queries, such as [PostgreSQL](../../data-sources/guides/integrations/database/postgresql.mdx) or [MySQL](../../data-sources/guides/integrations/database/mysql.mdx) databases. 

There are two modes from which to select when writing an SQL query. The mode you choose depends on whether you need to read or write data:

- **SQL**: Read data using an SQL statement.
- **GUI**: Write data using a graphical query editor. 

## Prerequisites

This tutorial uses a demo REST API with sample customer data. You can use the **Sample API generator** to create a fully functional REST API for testing purposes that's preloaded with sample data.

Save the base URL for later, then navigate to **Apps** and click **Create new > App**.

This tutorial uses sample customer data and Retool Database, a built-in PostgreSQL database. To prepare Retool Database:

1. Download `sample_customers.csv`.
2. Navigate to **Resources** and select **Retool Database**.
3. Click **Import CSV** and select **Into a new table**.
4. Upload `sample_customers.csv` and then click **Create table**.

Once complete, navigate to **Apps** and then click **Create new > App**.

## 1. Add a resource query to read data

Click  to open the **Code** tab, then click **+** to add a new query. Retool can interact with a REST API that is not configured as a resource so you don't need to create one first. Search for **REST API** in the **Resource** field and select it.

Click  to open the **Code** tab, then click **+** to add a new query. Select **Retool Database**.

## 2. Write the query code

Update the query with the following options. 

| Option          | Value          | Description                                |
| --------------- | -------------- | ------------------------------------------ |
| **Action type** | **GET**        | Perform a GET request that retrieves data. |
| **URL**         | `YOUR_API_URL` | The URL for the sample API.                |

Click **Save & Run** to save the resource query. The results appear in the **Output** section below. 

Write an SQL statement to retrieve data from the database. The following example retrieves all data from the newly created `sample_customers` table.

```sql
SELECT 
  *
FROM
  sample_customers
```

Click **Save & Run** to save the resource query. The results appear in the **Output** section below. 

## 3. Display results in a table

With the query results available, you can now display them using a component. Right-click on the canvas, click **Add component**, and select the [Table](../../apps/reference/components/data/table.mdx) component.

You can reference the query output elsewhere in the app using the query's `data` property. This contains an object with key names that correspond to the column names. Each key contains an array of values.

Tables automatically reference the most recently created query or you can change this in the **Data** setting of the Inspector. 

## 4. Edit table data

Tables are read-only by default but can be configured to allow editing. To do this, you specify which columns should be editable. 

Position the cursor over the **First** table column, click **•••**, then select **Make editable**. Repeat this process for the **Last** table column. Once done, you can click to edit cells in these columns.

Although the table data is editable, there is no query to save the edits back to the database. When you make a table editable, Retool adds a **Save action** to the table. You configure this with an [event handler](../../apps/guides/interaction-navigation/event-handlers.mdx) that triggers a query when changes are saved.

## 5. Add a resource query to write data

Navigate back to the **Code** tab and click **+** to add another REST API resource query. The action you use often depends on the API. **POST**, **PUT**, and **PATCH** actions modify data differently. Since this query modifies existing data only, select the **PATCH** action.

You provide the modified data in the _body_ of the the API request. Retool supports different types of body data, such as **JSON** and **Form Data**. Select **JSON** and set the value to `table1.changesetArray`.

Each table row corresponds to a customer object in the API. When run, this query updates each object.

Navigate back to the **Code** tab and click **+** to add another Resource query for Retool Database. As this query will write back changes, select **GUI** mode. 

GUI mode provides you with a set of inputs to configure a writable query. This is a safer alternative to using raw SQL statements. Update the query with the following options.

| Option                         | Value                           | Description                                                  |
| ------------------------------ | ------------------------------- | ------------------------------------------------------------ |
| **Table**                      | `sample_customers`              | The database table to update.                                |
| **Action type**                | **Bulk update via primary key** | Update multiple records that correspond to the primary keys. |
| **Primary key column**         | `id`                            | The primary key column to identify records.                  |
| **Array of records to update** | `table1.changesetArray`         | The edited records in the table.                             |

Each table row corresponds to a database table record. When run, this query updates each record and uses the `id` to match edited values with the correct table record.

## 6. Configure the save action

The final step is to configure the table's **Save action**. Select the table to display its settings in the Inspector, then select the **Save action**. 

Event handlers trigger queries and perform actions in response to events or user interactions, such as clicking the **Save** button. Add an event handler and select the query you just created.

## 7. Refresh data on save

Now that the save action is set up, you can edit table data and then save changes. However, the table does not immediately reflect the changes. This is because the query that retrieves data from the database needs to be run again.

Queries also support event handlers and can perform actions on success or failure. Add an event handler to the write query that triggers the read query on success. Now, whenever changes are successfully saved, the read query runs again and the table reflects the latest changes.

---

## Queries and code tutorials

import Tutorial from '/docs/_partials/_doctypes/_tutorial.mdx';

---

## Create a Resource Configuration

import MethodEndpoint from "@theme/ApiExplorer/MethodEndpoint";
import ParamsDetails from "@theme/ParamsDetails";
import RequestSchema from "@theme/RequestSchema";
import StatusCodes from "@theme/StatusCodes";
import OperationTabs from "@theme/OperationTabs";
import TabItem from "@theme/TabItem";
import Heading from "@theme/Heading";

  

Creates a new resource configuration for a non-default environment.

---

## Create a Resource

import MethodEndpoint from "@theme/ApiExplorer/MethodEndpoint";
import ParamsDetails from "@theme/ParamsDetails";
import RequestSchema from "@theme/RequestSchema";
import StatusCodes from "@theme/StatusCodes";
import OperationTabs from "@theme/OperationTabs";
import TabItem from "@theme/TabItem";
import Heading from "@theme/Heading";

  

Creates a new resource, along with a resource configuration for the default environment.

---

## Delete a Resource Configuration

import MethodEndpoint from "@theme/ApiExplorer/MethodEndpoint";
import ParamsDetails from "@theme/ParamsDetails";
import RequestSchema from "@theme/RequestSchema";
import StatusCodes from "@theme/StatusCodes";
import OperationTabs from "@theme/OperationTabs";
import TabItem from "@theme/TabItem";
import Heading from "@theme/Heading";

  

Deletes the resource configuration with the given resource configuration id.
    You cannot delete resource configurations in the default environment.

---

## Delete a Resource

import MethodEndpoint from "@theme/ApiExplorer/MethodEndpoint";
import ParamsDetails from "@theme/ParamsDetails";
import RequestSchema from "@theme/RequestSchema";
import StatusCodes from "@theme/StatusCodes";
import OperationTabs from "@theme/OperationTabs";
import TabItem from "@theme/TabItem";
import Heading from "@theme/Heading";

  

Deletes the resource with the given resource id, along with all of its configurations.

---

## Get a Resource By Id

import MethodEndpoint from "@theme/ApiExplorer/MethodEndpoint";
import ParamsDetails from "@theme/ParamsDetails";
import RequestSchema from "@theme/RequestSchema";
import StatusCodes from "@theme/StatusCodes";
import OperationTabs from "@theme/OperationTabs";
import TabItem from "@theme/TabItem";
import Heading from "@theme/Heading";

  

Returns the resource configuration with the given id.

---

## Get a Resource Configuration By Id

import MethodEndpoint from "@theme/ApiExplorer/MethodEndpoint";
import ParamsDetails from "@theme/ParamsDetails";
import RequestSchema from "@theme/RequestSchema";
import StatusCodes from "@theme/StatusCodes";
import OperationTabs from "@theme/OperationTabs";
import TabItem from "@theme/TabItem";
import Heading from "@theme/Heading";

  

Returns the resource configuration with the given resource configuration id.

---

## Get an Environment by Id

import MethodEndpoint from "@theme/ApiExplorer/MethodEndpoint";
import ParamsDetails from "@theme/ParamsDetails";
import RequestSchema from "@theme/RequestSchema";
import StatusCodes from "@theme/StatusCodes";
import OperationTabs from "@theme/OperationTabs";
import TabItem from "@theme/TabItem";
import Heading from "@theme/Heading";

  

Returns the environment with the given id.

---

## Get Environments

import MethodEndpoint from "@theme/ApiExplorer/MethodEndpoint";
import ParamsDetails from "@theme/ParamsDetails";
import RequestSchema from "@theme/RequestSchema";
import StatusCodes from "@theme/StatusCodes";
import OperationTabs from "@theme/OperationTabs";
import TabItem from "@theme/TabItem";
import Heading from "@theme/Heading";

  

Returns a list of environments.

---

## Get Resource Configurations

import MethodEndpoint from "@theme/ApiExplorer/MethodEndpoint";
import ParamsDetails from "@theme/ParamsDetails";
import RequestSchema from "@theme/RequestSchema";
import StatusCodes from "@theme/StatusCodes";
import OperationTabs from "@theme/OperationTabs";
import TabItem from "@theme/TabItem";
import Heading from "@theme/Heading";

  

Returns a paginated list of resource configurations.

---

## Get Resources

import MethodEndpoint from "@theme/ApiExplorer/MethodEndpoint";
import ParamsDetails from "@theme/ParamsDetails";
import RequestSchema from "@theme/RequestSchema";
import StatusCodes from "@theme/StatusCodes";
import OperationTabs from "@theme/OperationTabs";
import TabItem from "@theme/TabItem";
import Heading from "@theme/Heading";

  

Returns a paginated list of resources.

---

## Get the Default Environment

import MethodEndpoint from "@theme/ApiExplorer/MethodEndpoint";
import ParamsDetails from "@theme/ParamsDetails";
import RequestSchema from "@theme/RequestSchema";
import StatusCodes from "@theme/StatusCodes";
import OperationTabs from "@theme/OperationTabs";
import TabItem from "@theme/TabItem";
import Heading from "@theme/Heading";

  

Returns the default environment.

---

## Retool Developer API

import ApiLogo from "@theme/ApiLogo";
import Heading from "@theme/Heading";
import SchemaTabs from "@theme/SchemaTabs";
import TabItem from "@theme/TabItem";
import Export from "@theme/ApiExplorer/Export";

This version of the Retool API is deprecated. Please use [Retool API v2](https://docs.retool.com/api).

  
  
    

      
        
          
            
              
                Security Scheme Type:
              
                http
              
            
              
                HTTP Authorization Scheme:
              
                bearer

---

## Update a Resource Configuration

import MethodEndpoint from "@theme/ApiExplorer/MethodEndpoint";
import ParamsDetails from "@theme/ParamsDetails";
import RequestSchema from "@theme/RequestSchema";
import StatusCodes from "@theme/StatusCodes";
import OperationTabs from "@theme/OperationTabs";
import TabItem from "@theme/TabItem";
import Heading from "@theme/Heading";

  

Updates the resource configuration with the given resource configuration id.

---

## Update a Resource

import MethodEndpoint from "@theme/ApiExplorer/MethodEndpoint";
import ParamsDetails from "@theme/ParamsDetails";
import RequestSchema from "@theme/RequestSchema";
import StatusCodes from "@theme/StatusCodes";
import OperationTabs from "@theme/OperationTabs";
import TabItem from "@theme/TabItem";
import Heading from "@theme/Heading";

  

Updates the resource with the given resource id.

---

## All Edge releases of Self-hosted Retool

import Releases from '@site/src/components/ReleaseNotesAll.js';

---

## Self-hosted Retool Edge releases



---

## Self-hosted Retool releases

You can [deploy a self-hosted instance of Retool](../self-hosted/tutorials.mdx) on your own infrastructure, such as a virtual private cloud (VPC). There are two release channels for self-hosted versions of Retool:

- [Stable](#stable): A new release every 13 weeks (quarterly).
- [Edge](#edge): A new release every week.

Unless you need access to the latest features and have the ability to upgrade frequently, Retool strongly recommends that you use the Stable channel.

:::info Legacy releases

import Legacy from "./_partials/_legacy.mdx";

:::

## Stable release channel {#stable}

import Stable from "./_partials/_stable.mdx";

## Edge release channel {#edge}

import Edge from "./_partials/_edge.mdx";

## Update to a newer release

import Upgrade from "./_partials/_upgrade.mdx";

## Release versioning

Releases use [semantic versioning](https://semver.org) for versions using the format `MAJOR.MINOR.PATCH-CHANNEL`.

- `MAJOR.MINOR` refers to the release (e.g., `3.33`).
- `MAJOR.MINOR.PATCH` refers to a specific version of the release (e.g., `3.33.1`).
- `CHANNEL` refers to the release channel. Either `stable` or `edge`.

Retool will release `PATCH` version updates (e.g., `3.47.2-stable`) if necessary. Whether you upgrade to a new release or perform an update of an existing one, always specify the full semantic version number you want to use.

---

## All Stable releases of Self-hosted Retool

import Releases from '@site/src/components/ReleaseNotesAll.js';

---

## Self-hosted Retool Stable releases



---

## System architecture of self-hosted Retool deployments

import SelfhostedLatest from "@site/src/components/SelfhostedLatest";
import EnterpriseRequirement from "../_partials/_enterprise-plan-requirement.mdx";

Organizations that have on-premise requirements can deploy the Retool platform on their own infrastructure. Each deployment instance uses a distributed set of containers with services for different functions. These work together to securely run the platform within your VPN or VPC.

## Containers and services

A standard deployment instance uses the following containers and services that interact with each other. The `SERVICE_TYPE` [environment variable](../reference/environment-variables/index.mdx#service_type) values determine what services a container runs.

| Container                               | Image                   | Repository                                                                                  | Services                                                       |
| --------------------------------------- | ----------------------- | ------------------------------------------------------------------------------------------- | -------------------------------------------------------------- |
| [api](#api)                             | `backend`               | [tryretool/backend](https://hub.docker.com/r/tryretool/backend)                             | `MAIN_BACKEND``DB_CONNECTOR``DB_SSH_CONNECTOR`     |
| [jobs-runner](#jobs-runner)             | `backend`               | [tryretool/backend](https://hub.docker.com/r/tryretool/backend)                             | `JOBS_RUNNER`                                                  |
| [workflows-worker](#workflows-worker)   | `backend`               | [tryretool/backend](https://hub.docker.com/r/tryretool/backend)                             | `WORKFLOW_TEMPORAL_WORKER` (for workflows)                                    |
| [workflows-backend](#workflows-backend) | `backend`               | [tryretool/backend](https://hub.docker.com/r/tryretool/backend)                             | `WORKFLOW_BACKEND``DB_CONNECTOR``DB_SSH_CONNECTOR` |
| [agent-worker](#agent-worker)           | `backend`               | [tryretool/backend](https://hub.docker.com/r/tryretool/backend)                             | `WORKFLOW_TEMPORAL_WORKER` (for agents)                                     |
| [agent-eval-worker](#agent-eval-worker) | `backend`               | [tryretool/backend](https://hub.docker.com/r/tryretool/backend)                             | `AGENT_EVAL_TEMPORAL_WORKER`                                   |    
| [code-executor](#code-executor)         | `code-executor-service` | [tryretool/code-executor-service](https://hub.docker.com/r/tryretool/code-executor-service) | No service type.                                               |

### api

The **api** container manages the core functionality for a Retool deployment instance, such as:

- Frontend interactions (e.g., building apps and workflows).
- Hosting apps and workflows.
- Managing users and permissions.

**api** runs the following services:

import MainBackend from "../_partials/_service-main-backend.mdx";
import DbConnector from "../_partials/_service-db-connector-services.mdx";

#### Network ingress and egress

**api** requires ingress from client interactions, such as loading an app in a browser. These are typically handled by a load balancer (e.g., nginx) which proxies the requests.

The following table displays ingress and egress requirements for **api**.

| Container             |       Network ingress        |       Network egress        |
| :-------------------- | :--------------------------: | :-------------------------: |
| **code-executor**     |  |  |
| **postgres**          |  |  |
| **retooldb-postgres** |  |  |
| **Temporal**          |  |  |
| **Resources**         |  |  |

#### Replicas

You can replicate **api** as you scale to manage higher volumes of workflow traffic.

The following diagram illustrates a typical resource query trace as it processes through a self-hosted deployment.

### jobs-runner

The **jobs-runner** container manages background tasks, runs database migrations for Retool version upgrades, and [Source Control](../../source-control/index.mdx). It runs the following service:

import JobsRunner from "../_partials/_service-jobs-runner.mdx";

#### Network ingress and egress

The following table displays ingress and egress requirements for **jobs-runner**.

| Container    |       Network ingress        |       Network egress        |
| :----------- | :--------------------------: | :-------------------------: |
| **postgres** |  |  |

#### Replicas

You must not replicate **jobs-runner**. It performs tasks and migrations that must be performed as a single container.

### workflows-worker

The **workflows-worker** container continuously polls the Temporal Cluster for tasks required to either start or execute blocks within a workflow. It makes requests to **code-executor** to execute blocks and process results, then reports back to Temporal to continue or complete workflow execution.

**workflows-worker** runs the following service.

import WorkflowTemporalWorker from "../_partials/_service-workflow-temporal-worker.mdx";

#### Network ingress and egress

The following table displays ingress and egress requirements for **workflows-worker**.

| Container             |       Network ingress        |       Network egress        |
| :-------------------- | :--------------------------: | :-------------------------: |
| **code-executor**     |  |  |
| **postgres**          |  |  |
| **retooldb-postgres** |  |  |
| **Temporal**          |  |  |
| **Resources**         |  |  |

#### Replicas

You can replicate **workflows-worker** as you scale to manage higher volumes of workflow traffic.

### workflows-backend

The **workflows-backend** container receives and processes requests from **code-executor** to process workflows. It also handles the upload of workflows logs, block results, and run status updates.

import WorkflowBackend from "../_partials/_service-workflow-backend.mdx";

#### Network ingress and egress

The following table displays ingress and egress requirements for **workflows-backend**.

| Container             |       Network ingress        |       Network egress        |
| :-------------------- | :--------------------------: | :-------------------------: |
| **code-executor**     |   |  |
| **postgres**          |  |  |
| **retooldb-postgres** |  |  |
| **Temporal**          |  |  |
| **Resources**         |  |  |

#### Replicas

You can replicate **workflows-backend** as you scale to manage higher volumes of workflow traffic.

### agent-worker
The **agent-worker** container continuously polls the Temporal cluster for pending agent runs to execute. It makes requests to [code-executor](#code-executor) to execute the agent logic, call tools and process results, and then it reports back to Temporal to continue or complete agent execution.

#### Network ingress and egress

The following table displays ingress and egress requirements for **agent-worker**.

| Container             |       Network ingress        |       Network egress        |
| :-------------------- | :--------------------------: | :-------------------------: |
| **code-executor**     |  |  |
| **postgres**          |  |  |
| **retooldb-postgres** |  |  |
| **Temporal**          |  |  |
| **Resources**         |  |  |

#### Replicas

You can replicate **agent-worker** as you scale to manage higher volumes of workflow traffic.

### agent-eval-worker
The **agent-eval-worker** continuously polls the Temporal Cluster for pending agent eval runs. When an eval is running, the **agent-eval-worker** makes calls from Postgres to the LLM provider configured in the [test case](../../agents/concepts/evals.mdx#datasets-and-test-cases), and compares the output to the expected value.

#### Network ingress and egress

The following table displays ingress and egress requirements for **agent-eval-worker**.

| Container             |       Network ingress        |       Network egress        |
| :-------------------- | :--------------------------: | :-------------------------: |
| **code-executor**     |  |  |
| **postgres**          |  |  |
| **Temporal**          |  |  |
| **Resources**         |  |  |

#### Replicas

You can replicate **agent-eval-worker** as you scale to manage higher volumes of workflow traffic.

### code-executor

The **code-executor** container executes single block runs from the Workflows IDE, multiple blocks as part of a Workflow execution, and any arbitrary user code written in a Workflow. It executes JavaScript and Python code directly, or makes requests to **workflows-backend** to run resource queries against databases, APIs, etc.

By default, the **code-executor** uses [nsjail](https://github.com/google/nsjail) to sandbox code execution. [nsjail](https://github.com/google/nsjail) requires [privileged](https://docs.docker.com/reference/cli/docker/container/run/#privileged) container access. If your deployment does not support privileged access, you can [run the code executor in unprivileged mode](../guides/code-executor-security-privileges.mdx#run-code-executor-in-unprivileged-mode). However, Retool strongly recommends running NsJail with privileged mode, as it provides sandboxing and remains the most secure option.

#### Network ingress and egress

The following table displays ingress and egress requirements for **code-executor**.

| Container             |       Network ingress        |        Network egress        |
| :-------------------- | :--------------------------: | :--------------------------: |
| **api**               |   |  |
| **workflows-backend** |  |   |
| **workflows-worker**  |   |  |

#### Replicas

You can replicate **code-executor** as you scale to manage higher volumes of workflow traffic.

### postgres

**postgres** manages the internal PostgreSQL database in which an instance stores its apps, resources, users, permissions, and internal data. All deployment instances contain a default `postgres` container for testing purposes. You must [externalize this database](../guides/storage-database.mdx) before using the deployment instance in production.

### retooldb-postgres

You can optionally [configure your deployment to use Retool Database](../guides/retool-database.mdx) with a separate PostgreSQL database. You can use `retooldb-postgres` to get started but Retool recommends you migrate to an externally hosted database for use in production.

## Other dependencies

Self-hosted deployment instances have additional dependencies.

### Resources

Each data source you use with Retool is represented by a resource, such as APIs and external databases. Your deployment instance must have access to any of its resources to interact with data.

import Temporal from "../_partials/_temporal-info.mdx";

### Temporal

## Docker images

Retool uses Docker images that configure the containers and their respective services. Each container runs one or more services to distribute functionality. This approach allows for efficient scaling of a Retool deployment instance as needs grow.

Retool maintains two image repositories on [Docker Hub](https://hub.docker.com/u/tryretool):

- The [backend](https://hub.docker.com/r/tryretool/backend) image is used for most containers and services.
- The [code-executor-service](https://hub.docker.com/r/tryretool/code-executor-service) image is used to execute blocks of code in Retool Workflows.

Each Docker Hub repository tag corresponds to a particular version of Retool. You specify the version to use when deploying or upgrading a release. For instance:

- 
    tryretool/backend:
    
  
- 
    tryretool/code-executor-service:
    
  

For information about hardened variants of these images, including `arm64` support and security changes, see [Hardened images (beta)](./hardened-images.mdx).

---

## Container logs

import EnterpriseRequirement from "../_partials/_enterprise-plan-requirement.mdx";

You can use Retool's backend container logs to monitor your deployment's errors and performance. To access logs for Retool product events, such as user creation, use the [audit logs](../../org-users/guides/monitoring/audit-logs.mdx) instead.

## Access container logs

Retool sends container logs to standard output by default. The method to view container logs depends on your deployment provider. Refer to your provider's documentation to learn more about available logging options.

For deployments using [Docker Compose](../tutorials.mdx), use `sudo docker compose logs`.

See the [Docker logs documentation](https://docs.docker.com/engine/reference/commandline/compose_logs/) for a complete list of options you can pass to `docker compose logs` or `docker logs`.

For deployments using Kubernetes, use `kubectl logs`:

```
kubectl logs -p  -n 
```

## Use logs to debug

The `api` and `db-connector` containers or pods log events related to queries and requests. For events related to [Source Control](../../source-control/index.mdx), see the `jobs-runner` container or pod logs.

To follow the lifecycle of a request in Retool, look for the `requestId` field. You can then query using the request ID and any associated `QUERY_REQUEST`, `QUERY_COMPLETE`, `RESPONSE_SEND`, and `QUERY_RESULT` events, which contain the query's environment, source, and more details.

Set the `DEBUG` and `LOG_LEVEL` [environment variables](../reference/environment-variables/index.mdx) to enable more verbose logging.

## Send logs to log aggregators

Because logs are piped to standard output by default, you can connect them to log aggregators. For example, send logs to Datadog by [registering an agent](https://docs.datadoghq.com/containers/docker/log/?tab=containerinstallation). See the documentation for your log aggregator for more details.

On Docker-based deployments, you configure logging drivers by creating and configuring a `daemon.json` file, then restarting Docker. See [Docker's documentation](https://docs.docker.com/engine/reference/commandline/dockerd/#daemon-configuration-file) for more details.

---

## Custom code execution security

import EnterpriseRequirement from "../_partials/_enterprise-plan-requirement.mdx";

The [code-executor](./architecture.mdx#code-executor) container executes arbitrary user-written code for custom JavaScript or Python libraries in [workflows](../../workflows/index.mdx). Retool recommends running [code-executor](./architecture.mdx#code-executor) with sandboxing enabled, for flow safety and data security reasons. But Retool does support running without sandboxing enabled, as it requires privileged container access, which some organizations do not allow.

[Privileged](https://docs.docker.com/reference/cli/docker/container/run/#privileged) container access is commonly restricted by default and why Retool allows code-executor to run in _unprivileged_ mode. Should this be the case, Retool recommends an exception be made so that Retool can run as a trusted product or framework. This will allow code-executor to safely manage your operational code.

## Security, functionality, and usability

Retool follows three core philosophies when developing the self-hosted architecture: _security_, _functionality_, and _usability_.

| Priority | Description |
| --- | --- |
| Security | Protect systems and data with strong safeguards. |
| Functionality | Build powerful and flexible features. |
| Usability | Provide straightforward and low-friction experiences. |

Too much focus on one priority can be at the detriment of the others. Retool's approach is to always strike the right balance across all three.

Due to the potential impact that executing arbitrary code can have, Retool prioritizes security and functionality above usability. As such, Retool's architecture is built so that this custom code is executed in a secure, sandboxed environment but without arbitrary restrictions. This approach ensures that customers don't have to review and ensure that all custom code written by their users is free from bugs or malicious code.

## Sandboxed environment with NsJail

Retool uses [NsJail](https://github.com/google/nsjail), a process isolation tool for Linux, to securely execute custom code. NsJail leverages Linux kernel features such as namespaces, control groups (cgroups), and [seccomp-bpf](https://en.wikipedia.org/wiki/Seccomp) [syscall](https://man7.org/linux/man-pages/man2/syscall.2.html) filters to isolate custom code from the rest of the system.

By doing so, NsJail is able to isolate the file system, restrict network access, and enforce CPU and memory limits to prevent any single workflow from impacting overall system stability.

## Priviledged and unprivileged modes

Docker containers can be run in either _unprivileged_ or  _privileged_ mode.

| Mode | Description |
| --- | --- |
| Unprivileged | If the container cannot run with `--privileged`, NsJail cannot apply its sandbox. In this case, custom code runs without Retool’s isolation safeguards, and you must fully trust all user-written code. |
| Privileged | In self-hosted Retool, the code-executor container is configured with Docker’s `--privileged` flag. This allows NsJail to configure the kernel features required for sandboxing. NsJail then executes user code inside a jailed process with reduced privileges. |

The code-executor container is configured to run in privileged mode by default. Retool only uses the minimum amount of elevated permissions necessary to implement sandboxing and relinquishes these once no longer required.

:::note
Only the code-executor container is configured to run in privileged mode—all other backend services operate separately without any form of elevated permissions.
:::

Retool strongly recommends that self-hosted organizations always use privileged mode unless there are specific reasons which prevent this.

## Exceptions for using unprivileged mode

In some cases, it may not be possible for a self-hosted deployment instance to run code-executor in priviledged mode. For instance:

- Managed container orchestration environments, such as [GKE Autopilot](https://cloud.google.com/kubernetes-engine/docs/concepts/autopilot-overview) and [AWS Fargate](https://aws.amazon.com/fargate/), do not allow the use of privileged containers.
- Kubernetes clusters with pod security policies can explicitly block privileged containers.

Retool provides customers with the option of [running the container in unprivileged mode](../guides/code-executor-security-privileges.mdx) for these types of situations. When you configure code-exector to use unprivileged mode, however, many of the safeguards that sandboxing provide are no longer in place. This assumes that you fully trust all user-written custom code that is executed.

## Risks of non-sandboxed custom code environment

:::warning
A non-sandboxed environment should only be used if an organization can trust that all users will not write code that is either malicious or critically flawed.
:::

| Risk Category | Examples |
|-------------------|--------------|
| Data risks | Exfiltrating credentials or sensitive data to an external attacker; accessing or manipulating restricted data. |
| Account risks | Compromising or taking control of other user accounts. |
| Execution risks | Interfering with future code execution. Bugs or malicious code can cause unexpected or unstable results. |
| System risks | Damaging the deployment instance by deleting or modifying critical system files. Bugs in user code can also cause unintended damage, such as erroneous deletion of files or unpredictable outcomes. |
| External misuse | Coordinating targeted attacks using the deployment instance. |

---

## Hardened images for self-hosted Retool

import EnterpriseRequirement from "../_partials/_enterprise-plan-requirement.mdx";

Self-hosted instances can use _hardened images_, which are available on the [edge release channel](../../releases/index.mdx#edge). These images are designed to improve supply-chain security, reduce the attack surface, and support modern infrastructure while remaining functionally compatible with existing deployments.

Refer to the [changelog entry for hardened images](/changelog/hardened-images) for information about how to transition to using hardened images.

This guide explains what hardened images are, how they differ from classic images, and what to consider before adopting them in your environments.

## Hardened vs. classic images

Hardened images introduce several changes compared to the existing **classic** Docker images:

- **Chainguard-based, Wolfi OS images:** Hardened images use a minimal [Wolfi](https://wolfi.dev/) base and are patched and maintained through Chainguard. System-level packages are curated and updated to reduce known vulnerabilities and tighten supply-chain security.

- **Multi-architecture support:** Hardened images are published as **multi-architecture Open Container Initiative (OCI) images** that support both `amd64` and `arm64`. When you run them on `arm64` nodes, you can often reduce compute requirements and improve performance compared to equivalent `amd64` instances.

- **Bazel-built OCI images instead of Dockerfiles:** Hardened images are built using Bazel, which assembles OCI layers directly instead of using traditional Dockerfiles. This enables finer-grained control over file layout, permissions, and dependencies.

Classic images remain supported, and you can continue using them if hardened images do not fit your requirements. Over time, Retool plans to make hardened images the default for self-hosted deployments.

## Image repositories and release channels

Hardened images use the same repositories as [classic images](./architecture.mdx#containers-and-services): `tryretool/backend` for most backend services such as `api`, `jobs-runner`, and workflow workers.

Refer to the [Self-hosted architecture](./architecture.mdx#docker-images) guide for an overview of how these images map to containers and services.

### Hardened image tags

Hardened images are first released on the [edge channel](../../releases/index.mdx#edge) as beta builds. Tags use the following pattern: `X.YYY.Z-edge-hardened-beta`, where `X.YYY.Z` matches the corresponding edge version for classic images. 

The changes available on the hardened image tag contain the same changes as the classic images. These changes can be found in the [edge release notes](../../releases/edge/index.mdx).

Classic edge tags (for example, `X.YYY.Z-edge`) continue to be published alongside hardened tags, and you can choose which series to deploy.

## Changes that may affect your deployment

Hardened images are intended to be functionally compatible with classic images, but there are some important behavioral and operational differences to be aware of.

### System dependency packages

Hardened images include a smaller, more controlled set of _system dependency packages_ at the OS level. Examples of system dependencies include tools like `curl` or `ssh`, or other utilities installed by the base image.

In classic images, some tools may be present because of the underlying distribution or how the image is built. With hardened images:

- System dependencies are explicitly curated and patched.
- Extra tools that Retool does not depend on are removed where possible.
- Newly added dependencies are evaluated for security and long-term support.

For broader security recommendations, refer to [Security hardening best practices](./security-hardening.mdx).

### Modified or custom Retool images and debugging tools

Some customers extend Retool images to add additional packages or tools, or rely on interactive debugging inside the containers. For example:

- Building a custom Docker image `FROM tryretool/backend` and running `apt-get install ...`.
- Baking extra utilities directly into the containers.
- Opening a shell in a Retool container to run ad-hoc debugging commands.

Hardened images significantly change how these patterns work:

- The underlying OS is no longer Debian-based; common tools like `apt` are not available.
- Image layers are generated by Bazel, and the file layout, users, and permissions may differ from classic images.
- Directly modifying hardened images can bypass many of the security benefits they provide.
- Nonessential system utilities are removed, so you may see fewer CLI tools available and different default users/permissions compared to classic images.

Retool does not recommend, and cannot support, building custom images that modify hardened Retool images in place. If you have additional runtime or debugging needs:

- Prefer running sidecar containers or separate services that you control.
- If you must create a custom assembly that embeds Retool, use a workflow that is compatible with Wolfi/Chainguard images and follows their security guidance.
- Keep custom tooling off the main Retool containers whenever possible.
- Use centralized logging and observability tools, such as those described in [Container logs](./container-logs.mdx) and [Collect self-hosted telemetry data](../guides/telemetry.mdx).
- Run debugging tools from separate admin or bastion hosts rather than from within Retool containers.

If you currently rely on custom Retool images or in-container debugging workflows, plan for additional validation and manual changes when testing hardened images.

### MSSQL with Windows Authentication

The only known product feature not currently supported in hardened images is **Microsoft SQL Server with Windows Authentication**. This configuration is complex to maintain and introduces additional security and build performance considerations.

If you currently use MSSQL with Windows Authentication, you should continue using _classic images_ while Retool determines the long-term support model for Windows Authentication.

### code-executor and other workloads

Many customers also run the separate [code-executor](../guides/code-executor-security-privileges.mdx) service.

While hardened images are in public beta:

- Hardened images are available for core backend services first.
- A hardened `code-executor-service` image is under active development and may not yet be available for your version.
- You may therefore have a _mixed environment_ where core backend services use hardened images, while some auxiliary services (such as `code-executor`) continue to use classic images.

This mixed setup is expected and supported during the public beta. You can gradually migrate each workload to hardened images as they become available, starting with non-production environments.

## Infrastructure and `arm64` considerations

Hardened images are published as multi-architecture images that support both `amd64` and `arm64`. However, full support for an end-to-end `arm64` deployment depends on hardened images being available for all required services, including `code-executor`. 

Retool is actively working to expand `arm64` coverage across all services.

## Frequently asked questions

Refer to the following frequently asked questions.

### Do hardened images change how Retool behaves?

Hardened images are intended to be **functionally equivalent** to classic images for supported features. Most differences are at the OS, packaging, and security hardening layers.

You should not see changes to how apps, workflows, or queries behave, aside from:

- Unsupported configurations such as MSSQL with Windows Authentication.
- Any custom tooling or workflows that rely on incidental OS tools inside the containers.

### Can I switch between classic and hardened images?

Yes. Because hardened images share the same underlying product version as classic images, you can:

- Upgrade from classic to hardened images on a given edge version.
- Roll back to classic images on that same version if necessary.

Always follow the guidance in [Upgrade deployments](./update-deployment.mdx) when changing image tags, and test changes on non-production instances first.

---

## Multi-instance deployment

import EnterpriseRequirement from "../_partials/_enterprise-plan-requirement.mdx";

If running one instance of Self-hosted Retool with [multiple environments](../../org-users/guides/configuration/environments.mdx) doesn't meet your requirements, you can run multiple instances of Retool each with its own database. Multiple instances are sometimes used to meet certain security, compliance, and networking requirements.

Each separate instance of Retool can be treated as an “environment” in the typical programming context. Developers typically build in development and staging, and end-users often access apps only in production. It is also possible to spin up more instances to represent Quality Assurance (QA) or User Acceptance Testing (UAT) environments.

There is no limit to the number of separately deployed instances of Retool you can spin up in your organization with a single license key. Users are also de-duplicated in your organization by email address, so additional instances do not affect your user count.

## When to use a single Retool instance

In general, you should only deploy the instances you need. If you’re starting out with a small, defined set of use cases for one team, or if you don’t need to isolate Retool instances by VPC, you can start with a single instance.

Retool allows you to define [multiple environments](../../org-users/guides/configuration/environments.mdx) within a single instance so that you can safely build, run, and test apps for your end-users.

## When to deploy multiple instances

You might have development endpoints where editors can safely build and test apps on non-production data. If so, it's recommended to mirror a typical Software Development Life Cycle (SDLC):

- Deploy a development instance of Retool in the development VPC.
- Deploy a production instance of Retool in the production VPC.

This ensures your development Retool instance can only point to development endpoints and helps organize different user types across your organization.

Our [Source Control](../../source-control/index.mdx) feature lets you safely promote application changes between instances via a Git-based workflow. You can only have one Git repository associated with an instance—all pull requests must go through a single group of reviewers.

### Isolate team development workflows

Retool recommends you split out instances for each team if:

- You operate under a full-stack or [Spotify](https://www.atlassian.com/agile/agile-at-scale/spotify) model and have many autonomous teams building tooling on their own.
- You don't have shared resources or endpoints across teams, but teams want to manage their own development workflows independently.

### Legal and compliance purposes

If you are launching or operate into a market that requires network traffic to be isolated to specific regions, you may need to isolate your Retool instance as well. In other cases, a production instance might need to be locked down to be read-only (i.e., no editors can build apps).

### Testing new features and upgrades

If you want to safely test out a new beta feature or instance-wide setting (e.g., a new SSO configuration), you can spin up a separate Retool instance for this purpose. See [upgrade deployments](update-deployment.mdx) for more information.

---

## Retool AI for self-hosted deployments

import EnterpriseRequirement from "../_partials/_enterprise-plan-requirement.mdx";

Self-hosted customers can deploy and embed Retool AI for use with apps and workflows. To learn more about how you can use Retool AI, refer to the [Retool AI actions concept](../../queries/concepts/actions.mdx) documentation, and the [AI actions how-to guides](../../queries/guides/ai/chat.mdx)

## AI platform options

You can configure a direct connection to a [supported AI platform](../../data-sources/concepts/models.mdx) by providing an API key. You also have the option to use a Retool-managed OpenAI connection. For production use cases, Retool recommends you provide an API key and directly connect to an AI platform.

The Retool-managed OpenAI connection is disabled by default. Contact your Retool account representative or our [support team](mailto:support@retool.com) to gain access.

## Retool-managed Vectors

[Retool-managed Vectors for self-hosted deployments](../guides/vectors.mdx) is built on [Retool Database](../guides/retool-database.mdx). To store vector data, you must configure and enable Retool-managed Vectors and Retool Database.

## AI Actions

import Partial from '../../_shared/_retool-managed-self-hosted.mdx';

## Data sharing and retention

When Retool AI is used to build or configure a query, application, or workflow (e.g., prompting [Ask AI](../../queries/concepts/ask.mdx) to help write queries), the input is shared with the applicable third-party LLM provider, listed in our [Subprocessors](https://docs.retool.com/legal/subprocessors) page. Inputs are deleted within 30 days.

Any inputs or outputs that correspond to the categories above may continue to be used to inform product improvements. Retool does not use any inputs submitted to, or outputs generated from, Retool AI that is embedded within a deployed application or workflow (e.g., text stored in [Retool-managed Vectors](../../data-sources/quickstarts/retool-vectors.mdx)). These inputs and outputs are treated as "Customer Data" in accordance with the [Customer Terms of Service](https://docs.retool.com/legal/customer-terms-of-service), [Security Practices](https://docs.retool.com/legal/security), and [Data Processing Addendum](https://docs.retool.com/legal/dpa).

## Additional resources
Refer to the following documentation for additional ways you can use AI within Retool: 
* [Assist](../../apps/guides/assist)
* [Agents](../../agents/index.mdx)
* [AI in app building](../../apps/concepts/ai.mdx)

---

## Security hardening best practices

import EnterpriseRequirement from "../_partials/_enterprise-plan-requirement.mdx";

Retool provides different security hardening options that you can customize. Use the following best practices when evaluating and configuring your deployment according to your use case, threat model, and risk assessment.

For an overview of Retool's hardened container images and how they relate to security posture, see [Hardened images (beta)](./hardened-images.mdx).

:::note Kubernetes infrastructure 

If you deploy Retool on Kubernetes, review your hosting provider’s documentation:

- [Amazon EKS Best Practices Guide for Security](https://aws.github.io/aws-eks-best-practices/security/docs/)
- [Security concepts for applications and clusters in Azure Kubernetes Service (AKS)](https://learn.microsoft.com/en-us/azure/aks/concepts-security)
- [GKE - Harden your cluster's security](https://cloud.google.com/kubernetes-engine/docs/how-to/hardening-your-cluster)

:::

## Increase security of your deployment

Retool uses [environment variables](../reference/environment-variables/index.mdx) to control certain functions and characteristics for self-hosted deployments. Use the following environment variable recommendations to improve security hardening.

### Set a strong encryption key

Retool encrypts sensitive values like API credentials in its internal database. Set the `ENCRYPTION_KEY` environment variable to a cryptographically random value. If you have the [OpenSSL CLI installed](https://www.openssl.org/docs/man3.2/man1/openssl.html), generate this value with this command: `openssl rand -base64 32`. 

### Set a strong JWT secret

Retool uses a JSON web token (JWT) to sign requests for authentication with Retool's backend API server. If changed, all active user login sessions are invalidated. Set the `JWT_SECRET` environment variable to a cryptographically random value. If you have the [OpenSSL CLI installed](https://www.openssl.org/docs/man3.2/man1/openssl.html), you can generate this value using this command: `openssl rand -base64 32`.

### Disable public apps

Retool supports sharing [apps publicly](../../apps/guides/app-management/embed-apps#public-apps) using a public link. If you want to prevents apps from being shared publicly, set  `DISABLE_PUBLIC_PAGES` to disable public apps and `DISABLE_IMAGE_PROXY` to disable the proxy used for public apps.

### Disable app editing in production

When using source control to promote apps between development and production instances, set `VERSION_CONTROL_LOCKED` to disable editing for all elements (apps, workflows, resources, etc.) in the production environment. This forces app changes to be made using source control. Admins can still delete unprotected elements.

### Enable short sessions

Retool sessions are valid for one week by default. Set `USE_SHORT_SESSIONS` to restrict session length to 12 hours instead.

## Increase security for your users

Configuring authentication options ensures only your users have access to Retool. In addition to single sign-on (SSO) support, you can require strong passwords and two-factor authentication (2FA).

### Single sign-on

Retool supports SSO to enable users to securely access multiple applications and services using one set of credentials. See the [SSO documentation](../../sso/index.mdx) to set up SSO with your identity provider.

### Disable username and password login

You can [disable Retool's built-in authentication method](../../sso/guides/authentication/enforce-sso.mdx) (email address and password) and require that all users log in using SSO by setting the `DISABLE_USER_PASS_LOGIN` environment variable. Make sure to set this variable if you use SSO exclusively.

### Require strong passwords for login

Navigate to **Settings > Beta** to enable **Require Strong Password for Login**. This requires passwords to have:

- A minimum of 12 characters.
- One uppercase letter.
- One lowercase letter.
- One number.
- One special character.

### Require two-factor authentication

You can require 2FA in Retool by navigating to **Settings > Advanced** and enabling **Require Two Factor Authentication**. Users can set up 2FA using either TOTP or FIDO2 hardware keys. 

### Limit default permissions

Retool’s [permissions system](../../permissions/guides/configure-permission-groups) lets you configure permission controls for apps, resources, and workflows. Retool recommends enforcing least privilege for the **All users** group and selectively adding permission groups as needed for users.

### Respond to compromised accounts

If a user’s account is compromised, consider taking the following steps:

- [Disable the user](../../org-users/tutorials/manage.mdx#disable-users) to mitigate the current risk.
- [Review audit logs](../../org-users/guides/monitoring/audit-logs.mdx) to identify suspicious account behavior such as: 
  - User sign-in events.
  - Query runs.
  - User invites.
  - Password resets.
- Enable two-factor authentication for the user, and consider [requiring 2FA for your organization](../../org-users/guides/user-management/two-factor-authentication.mdx#enable-2fa).

After completing an investigation and mitigating the immediate impact, [enable the user](../../org-users/tutorials/manage.mdx#enable-users).

## Prevent query variable spoofing

[Prevent query variable spoofing](../../queries/quickstart#query-variable-spoofing-prevention) is enabled by default. This prevents users from manipulating network requests and passing in arbitrary values to prepared statements. Confirm this is setting is enabled by navigating to **Settings > Beta**.

## Keep your deployment up to date

You are responsible for updating self-hosted instances and for the security of your underlying hosts. You can subscribe to Retool's [changelog](https://docs.retool.com/releases) using [RSS](https://docs.retool.com/changelog/rss.xml) or [JSON](https://docs.retool.com/changelog/feed.json) to stay up to date with releases. 

## Monitor audit logs

Actions that users take within Retool are stored in [audit logs](../../org-users/guides/monitoring/audit-logs.mdx). You can also write these actions to [container logs](container-logs.mdx) and pipe them into your observability tooling by setting the `LOG_AUDIT_EVENTS` [environment variable](../reference/environment-variables/index.mdx#log_audit_events).

---

## Temporal Clusters for Self-hosted Retool

import TemporalOptions from "../_partials/_temporal-options.mdx"
import EnterpriseRequirement from "../_partials/_enterprise-plan-requirement.mdx";

## Compare options

import TemporalCompare from "../_partials/_temporal-compare.mdx"

## Egress

Whether you use a Retool-managed or self-managed cluster, egress is required for Self-hosted Retool to use Temporal. Both `MAIN_BACKEND` and `WORKFLOW_TEMPORAL_WORKER` containers must be able to connect.

If you're using a Retool-managed cluster or a self-managed cluster on Temporal Cloud, your instance must have egress to the internet (public network) on ports for the following domains:

| Port | Domains |
| --- | --- |
| 443 | `*.retool.com`, `*.tryretool.com` |
| 7233 | Your Temporal namespace endpoint. Retool-managed clusters use the format `org-[sid].atdwz.tmprl.cloud`, where `sid` is your organization's ID (e.g., `org-1234567890.atdwz.tmprl.cloud`.  |

### Lifecycle

When the Temporal Cluster is needed:

1. The `MAIN_BACKEND` service enqueues workflows with Temporal.
2. A `WORKFLOWS_TEMPORAL_WORKER` receives instructions from Temporal for the specific tasks required to run a workflow, leveraging the Self-hosted Retool backend.
3. `DB_CONNECTOR` makes a request to your network-protected resources, or `CODE_EXECUTOR` executes custom Python.

### Data and encryption

:::tip

By default, Retool-managed clusters only store encrypted names and IDs of objects in Temporal Cloud—only minimal customer data is sent to the cluster. [All encrypted data in a Retool-managed cluster is retained for 14 days](https://docs.retool.com/legal/security#storage-of-customer-data). [Please reach out](/support) if you would like to make changes to this retention period.

:::

All data sent between your deployment and Temporal Cloud is encrypted with your `ENCRYPTION_KEY`.

Data processing, including query and code execution, occurs within your VPC by workers that you self-host. All coordination and orchestration happens in an isolated namespace within the Retool-managed cluster. No code results or query data is sent outside of your VPC by default.

The process occurs within your VPC. All coordination and orchestration happens in an isolated namespace within the Retool-managed cluster. No query data is sent from your VPC.

Retool-managed clusters perform automatic [mTLS](https://en.wikipedia.org/wiki/Mutual_authentication#mTLS) rotation. If necessary, you can manually perform this when required.

## Local clusters

:::info Each instance requires its own local cluster

If you deploy multiple instances of Self-hosted Retool with Workflows (e.g., staging and production instances), they must each have their own local cluster namespace.

:::

A _local_ cluster is one that is created when deploying Self-hosted Retool with Workflows. Unlike a self-hosted cluster in your VPC, a local cluster is only used by its Self-hosted Retool instance.

 Local clusters enable you to get up and running quickly without needing to commit to a dedicated Temporal Cluster, but can become complex to scale and manage. A Retool-managed cluster, or a self-managed cluster on Temporal Cloud or in your VPC, centralizes the cluster as each instance can use it via a resource-isolated namespace.

## Large scale deployments

Workflows can be deployed to scale to hundreds of concurrent block runs per second. There are three Temporal options for running more than 10 workflows per second:

- Use a Retool-managed Temporal Cluster.
- Use a self-managed Temporal Cluster.
- Use Cassandra as the Temporal datastore.
If you anticipate running workflows at a higher scale, please [reach out to us](/support) to work through a deployment strategy that is best for your use case.

## Telemetry

Retool uses a [Prometheus Metrics exporter](https://typescript.temporal.io/api/interfaces/worker.PrometheusMetricsExporter) to expose [Temporal Worker metrics](https://docs.temporal.io/references/sdk-metrics). This is specified in the Temporal worker's [runtime options](https://typescript.temporal.io/api/interfaces/worker.RuntimeOptions#telemetryoptions).

```
telemetryOptions: {
  metrics: {
    prometheus: { bindAddress: '0.0.0.0:9090' }
  }
}
```

You can optionally specify the endpoint for an [OpenTelemetry collector](https://opentelemetry.io/docs/collector/) if you prefer to use one with the `WORKFLOW_TEMPORAL_OPENTELEMETRY_COLLECTOR` environment variable.

Metrics are available for scraping using the `/metrics` route.

For more information about telemetry, refer to [Collect self-hosted telemetry data](../guides/telemetry.mdx).

---

## Self-hosted Retool upgrade best practices

import EnterpriseRequirement from "../_partials/_enterprise-plan-requirement.mdx";

This guide provides high-level recommendations and best practices for updating Retool for production deployments. For deployment-specific installation instructions, use the deployment guide for your Retool deployment type.

## Prepare for the update

Before you upgrade, choose the version to upgrade to and schedule downtime for the upgrade.

### Choose the version

Check the [Releases](../../releases/index.mdx) page to see each version of Retool and its changelog. Read the changelogs between your current version and the version you're upgrading to. Changelogs also contain instructions for managing deprecated features.

Keep your deployment instance up-to-date with the latest release. If your current version is more than 10 versions behind, Retool recommends you upgrade incrementally (e.g., 3.0, 3.10, 3.20...) and verify each installation.

### Schedule downtime

If you run Retool on a single container or node, there will be downtime during the upgrade. If you run a multi-container deployment, see the [Scale Retool infrastructure](../guides/scale-retool-infra.mdx#zero-downtime-upgrades) guide to learn about zero-downtime upgrades. If you run multiple instances, consider scheduling separate downtimes for each: for example, upgrade dev first, then staging, and then production.

Schedule the downtime in advance, even if it's a short time period or during off-peak hours. Clearly communicate to users that they should not use or edit apps during the upgrade. It may be helpful to make an announcement to users a few days in advance.

The amount of time to schedule varies. For example, point-in-time recovery and taking database snapshots can impact the duration.

## Test apps on a sandbox instance

Testing on a sandbox instance is not required, but it is recommended if:

- You usually run a single instance of Retool.
- Your primary Retool instances are heavily used.
- You have done a moderate to high amount of customization in your Retool apps. For example, using custom CSS, custom components, or Retool app development workflows.
- Your current version of Retool is more than two months behind the most recent version.

Pre-update testing includes spinning up a separate, temporary Retool instance with the new version and testing it with your current apps. This allows you test the upgrade process in a low-risk environment and build confidence for upgrading your production instances.

### 1. Spin up a temporary instance

Follow the instructions in your deployment guide for spinning up a new instance, or use an existing sandbox instance. First, install your current version of Retool.

#### Copy your database

Retool recommends seeding the temporary instance with your current apps by copying your existing instance’s PostgreSQL database to the temporary instance. It’s important to use a copy of your existing database. Don't connect to your existing Retool database: upgrades often include database migrations, which may alter the database.

Refer to your database provider for instructions on backing up your database to a file and restoring the new database with that file.

Before you connect your new instance to the database, ensure that the `ENCRYPTION_KEY` and `USE_GCM_ENCRYPTION` environment variables are set to the same value as in your existing Retool instance.

:::warning

Ensure that the temporary instance is configured with these environment variables to prevent disruptions to Retool Workflows on the existing instance:

- Set `TEMPORAL_TASKQUEUE_WORKFLOW=sandbox-test` on containers where `SERVICE_TYPE` includes `MAIN_BACKEND`, `WORKFLOW_BACKEND`, or `WORKFLOW_TEMPORAL_WORKER`.
- Set `WORKER_TEMPORAL_TASKQUEUE=sandbox-test` on containers where `SERVICE_TYPE` includes `WORKFLOW_TEMPORAL_WORKER`.

**Failure to apply these environment variables may cause both the existing and temporary instances to be unable to run Workflows.**

:::

### 2. Install the new version

Run the upgrade on the temporary Retool instance, following the upgrade steps for your deployment type.

### 3. Test your apps

Test the new instance on your most critical apps, and apps which use a variety of resources and components. You might want to write test cases, a checklist, or an internal upgrade runbook to help standardize this process. This can include specific context and commands and become a resource for your team.

After your tests pass, clean up the new instance and upgrade your production instances.

## Upgrade Retool

During Retool upgrades, remind users about the downtime and completed upgrades, and create backups of your instances. Upgrade instances sequentially, starting with the development instance, followed by staging and production.

### 1. Remind your users about the downtime

As a courtesy, it’s helpful to send an announcement to your users shortly before you begin the downtime. If you use Source Control, you should also avoid merging any pull requests while you perform the upgrade.

### 2. Create a backup

You need to create a backup for each of your Retool instances so that you can restore them if needed. If you're upgrading in batches, create a backup before each batch.

If you're deployed on a cloud platform like AWS, the cloud provider might have a convenient way to back up the state of your running instances. For example, AWS offers a way to [back up](https://docs.aws.amazon.com/prescriptive-guidance/latest/backup-recovery/ec2-backup.html) and [restore EC2 instances](https://docs.aws.amazon.com/prescriptive-guidance/latest/backup-recovery/restore.html) as an AMI.

On all deployments:

- Back up your Retool PostgreSQL database. If your PostgreSQL database is managed outside of Retool and has point-in-time recovery enabled, you already have backups. Otherwise, you can enable point-in-time recovery, or take a snapshot of the database.
- Copy and store your `ENCRYPTION_KEY` environment variable, along with any environment variables specific to your instance, in a safe place.

### 3. Install the new version

Retool releases can be pulled from [Docker Hub](https://hub.docker.com/u/tryretool). See the deployment guide for your instance for detailed instructions.

After installation, Retool recommends manually testing the deployment to verify it was successful. You can use the [release notes](../../releases/index.mdx) to better understand what has changed and what to test. Depending on how you're using Retool, you might want to verify your apps, queries, and workflows work as expected. If you're upgrading in batches, test the deployment after each batch.

### 4. Notify your users after the upgrade is complete

As a courtesy to your users, it’s helpful to send an announcement to them to let them know they can use Retool again.

---

## Self-hosted Retool concept guides

import Concept from '/docs/_partials/_doctypes/_concept.mdx';
import EnterpriseRequirement from "./_partials/_enterprise-plan-requirement.mdx";

:::tip Get started with self-hosted Retool

Follow a [tutorial](./tutorial/) to deploy self-hosted Retool on your infrastructure.

:::

---

## Configure SSL and custom certificates

import EnterpriseRequirement from "../_partials/_enterprise-plan-requirement.mdx";

Docker Compose deployments of Self-hosted Retool include [https-portal](https://github.com/SteveLTN/https-portal) to automatically configure HTTPS. You can either provision a certificate with [Let's Encrypt](https://letsencrypt.org/) or manually add your own custom certificate.

The process for Kubernetes and other deployment types is similar to the steps for Docker Compose, but might require different settings. For example, with Kubernetes you can use Kubernetes Secrets, and with Heroku you can extend the Dockerfile to copy the certificate into the container.

:::note

`https-portal` requires that port 80 be available and exposed to the internet, so Retool configures this automatically. If you modify this setting, `https-portal` won't function correctly.

:::

## SSL with Let's Encrypt

Provisioning a certificate with Let's Encrypt is a two-step process:

1. Configure DNS
2. Update Docker configuration file

### Configure DNS

First, set up a DNS to point `retool.yourcompany.com` to the Retool server. Next, open the `docker.env` file and update `DOMAINS` with the new domain.

```text
DOMAINS=retool.yourcompany.com -> http://api:3000
```

### Update Docker Compose

Open the `compose.yaml` file and set `STAGE` to `production`:

```yaml
...
  https-portal:
    ...
    environment:
      STAGE: 'production'
    networks:
      - frontend-network
...
```

## Add custom certificates manually

Let's Encrypt can only provision a certificate if your Retool deployment has full internet access. If you deploy Retool on a VPC without complete access to the internet, you can manually add certificates instead.

:::note

If you are using Retool Mobile or hosting your deployment behind a firewall, concatenate your primary certificate file and intermediate certificate file. This ensures that the server presents the full chain of certificates and the root issuer is validated. 

:::

### Modify HTTPS configuration

Update the `https-portal` service in the `compose.yaml` file to use an [nginx image](https://hub.docker.com/_/nginx/), and create two Docker volumes for your certificates. Rename the `https-portal` service to `nginx`.

```yaml
nginx:
  image: nginx:latest
  ports:
    - "80:80"
    - "443:443"
  command: [nginx-debug, "-g", "daemon off;"] # Improve error logging in the container
  volumes:
    - ./nginx:/etc/nginx/conf.d
    - ./certs:/etc/nginx/certs
  links:
    - api
  depends_on:
    - api
  networks:
    - frontend-network
```

### Mount certificates

To mount your certificates, create the directories these volumes point to.

In the `retool-onpremise` directory:

1. Create a `certs` directory if it doesn't exist.
2. Move your `.crt` and `.key` files into the `certs` directory.

### Set up and configure nginx

To configure [nginx](https://nginx.org):

1. Create an `nginx` directory if it doesn't currently exist.
2. Create a configuration file named `nginx.conf`.
3. Add the following to `nginx.conf` and update it with your own information.

```text
server {
    listen 80;
    server_name retool.yourcompany.dev; # container logs. These logs are helpful if you run into issues and need to troubleshoot.

```text
sudo docker compose exec https-portal bash
cd /var/log/nginx
cat error.log
```

## Connect to APIs using HTTPS

If your API's SSL certificates are signed by an internal CA, your Retool deployment cannot connect over HTTPS until you configure it to trust your CA. You do this by setting `NODE_EXTRA_CA_CERTS` to the absolute path of your certificate files. The files need to include one or more trusted certificates in PEM format.

If you use [Source Control](../../source-control/index.mdx), set the `SSL_CERT_FILE` environment variable to the path of your certificate files on your `api` and `jobs-runner` containers.

### Configure Docker Compose

With Docker Compose deployments, you need to store the certificate as a file on the filesystem, and then mount that file to the `api` container.

1. Create a subdirectory in your `retool-onpremise` repo named `ca`.
2. Save your internal certificate in PEM format to `./ca/cert.pem`.
3. Configure the following `compose.yaml` and `docker.env` files.

```yaml
version: '2'
services:
api:
image: tryretool/backend:latest
env_file: ./docker.env
...
volumes:
  - ./ssh:/retool_backend/autogen_ssh_keys
  - ./ca:/retool_backend/ca

db-connector:
...
volumes:
  - ./ca:/retool_backend/ca
```

```text
NODE_ENV=production
...
NODE_EXTRA_CA_CERTS=/retool_backend/ca/cert.pem
...
```

---

## Configure code-executor security and privileges

import EnterpriseRequirement from "../_partials/_enterprise-plan-requirement.mdx";

:::danger

Retool strongly recommends running the `code-executor` container in priviledged modes so that [custom code executes in a sandboxed environment](../concepts/custom-code-execution-security.mdx). You should only use unprivileged mode if it is not possible for your deployment to use privileged mode.

:::

The [code-executor](../quickstart.mdx#containers-and-services) service uses a default security configuration. It also runs in a privileged mode that runs workflow code in a sandbox environment.

## Disable default security configuration

If necessary, you can explicitly disable the default security configuration for a link-local address. This is useful if privileged access (e,g, `NET_ADMIN`) cannot be given to the code-executor service container.

First, run the following startup commands with elevated privileges:

```shell
iptables-legacy -A OUTPUT -d 169.254.0.0/16 -m owner --uid-owner retool_user -j DROP
```

```shell
iptables-legacy -A OUTPUT -d 192.168.0.0/16 -m owner --uid-owner retool_user -j DROP
```

Next, set the `DISABLE_IPTABLES_SECURITY_CONFIGURATION` environment variable to `true`.

```dockerfile
DISABLE_IPTABLES_SECURITY_CONFIGURATION=true
```

## Run code-executor in unprivileged mode

The Code executor service uses [NsJail](https://github.com/google/nsjail) to sandbox code execution. NsJail requires [privileged](https://docs.docker.com/reference/cli/docker/container/run/#privileged) container access. If your deployment framework does not support privileged access, (e.g., [ECS Fargate](https://docs.aws.amazon.com/AmazonECS/latest/bestpracticesguide/fargate-security-considerations.html), you can set the `CONTAINER_UNPRIVILEGED_MODE` environment variable to `true`. While you can run without NsJail, we recommend using privileged mode with NsJail enabled whenever possible, as it provides sandboxing and stronger security.

To run in unprivileged mode:

1. Set the `CONTAINER_UNPRIVILEGED_MODE` environment variable to `true` on your code-executor container.
2. Set the container user to run as `retool_user.` You can do this in Docker via the [USER instruction](https://docs.docker.com/reference/dockerfile/#user), or in Kubernetes via a [security context](https://kubernetes.io/docs/tasks/configure-pod-container/security-context/).
3. Ensure the container or pod does not run with `privileged` capabilities. 

The following example runs code-executor in unprivileged mode using Docker Compose:

```dockerfile
  code-executor:
    user: retool_user
    build:
     ...
    environment:
      - NODE_ENV=production
      - NODE_OPTIONS=--max_old_space_size=1024
      - CONTAINER_UNPRIVILEGED_MODE=true
      ...
    privileged: false
    ...
```

The `CONTAINER_UNPRIVILEGED_MODE` environment variable is also used to disable default configurations for link-local addresses to prevent Amazon EC2 metadata leaks. You must also run the startup commands to [disable the default security configuration](#disable-default-security-configuration).

---

## Self-hosted Retool migration guides

import DocCardList from "@theme/DocCardList";

---

## Migrate from Cloud to Self-hosted

import EnterpriseRequirement from "../../_partials/_enterprise-plan-requirement.mdx";

This guide outlines the steps required to copy your apps and configuration from your Cloud to self-hosted deployment. Before you begin, review the [pricing](https://retool.com/pricing) page to confirm your self-hosted plan supports the features you need. Self-hosted plans have a different set of supported features and may have a [different billing structure](/support/billing-usage) than Cloud plans.

## Requirements

To perform this migration, you need:

- A working Cloud instance of Retool.
- A working Self-hosted instance of Retool. To deploy a self-hosted instance of Retool, obtain a license key from your Retool account manager, or using our [Self-hosted Portal](https://my.retool.com/). Follow the [deployment guides](../../tutorials.mdx) for additional instructions.
- [Admin permissions](../../../permissions/guides/configure-permission-groups#default-permission-groups) on both instances.

:::warning

To use [Retool Workflows](../../../workflows/index.mdx) or [Retool Database](../../../data-sources/quickstarts/retool-database.mdx), ensure that you configure your self-hosted deployment to support [Retool Workflows](../../tutorials.mdx) and/or [Retool Database](../retool-database.mdx).

:::

Before migrating, [upgrade your self-hosted instance](../../concepts/update-deployment.mdx) to the most recent version of Retool. Self-hosted releases are typically two weeks behind Cloud releases, so your self-hosted instance may be missing features already on your Cloud instance. Typically this does not cause any issues, but you may need to make minor modifications to your applications on the self-hosted instance.

If your plan includes Source Control, follow the instructions for migrating [with Source Control](#with-source-control). Otherwise, follow the instructions for migrating [without Source Control](#without-source-control).

## With Source Control

If you use [Source Control in Retool](../../../source-control/index.mdx), use the following steps to synchronize apps, resources, and workflows between your Cloud and self-hosted instances. Source Control is available on the [Enterprise plan](https://retool.com/pricing). Reach out to your Retool account manager for more information.

### 1. Configure Source Control

Ensure you have configured Source Control on your Cloud instance and that you can access its repository. Next, set up [source control](../../../source-control/index.mdx) on your self-hosted instance. Use the same provider and repository as your Cloud instance.

### 2. Migrate resources

If your Cloud instance uses [config vars](../../../org-users/guides/configuration/config-vars.mdx) to set credentials, manually copy these config vars to your self-hosted instance. Next, migrate your resources:

- In your Cloud instance, [protect all resources](../../../source-control/guides/protect/resources.mdx). Make sure you merge the resources into the `main` branch.
- In your self-hosted instance, from the [source control deployment dashboard](../../../source-control/guides/manage-deployment.mdx#view-source-control-deployments), [deploy the latest version](../../../source-control/guides/manage-deployment.mdx#full-and-partial-deployments) of the repository.

Confirm that you can see your resources in the self-hosted instance.

Self-hosted instances can use [environment variables](../secrets/environment-variables.mdx#1-define-the-retool_exposed_db_password-variable) or secrets managers, such as [AWS Secrets Manager](../secrets/aws.mdx) and [HashiCorp Vault](../secrets/hashicorp-vault.mdx), to store sensitive credentials. Consider storing credentials, such as database passwords and API keys, using one of these methods.

:::note

All plans support environment variables. The Enterprise plan supports integrations with secrets managers.

:::

### 3. Retool Database

To migrate Retool Database from your Cloud instance to self-hosted, manually export and import your tables. You can [export a CSV](../../../data-sources/quickstarts/retool-database.mdx#export-data-as-a-csv) for each table on your Cloud instance, and [import each CSV](../../../data-sources/quickstarts/retool-database.mdx#import-csv) into your self-hosted database.

### 4. Copy Query Library queries

Queries in the [Query Library](../../../queries/concepts/query-library.mdx) are not synchronized with Source Control. In your self-hosted instance, manually recreate any shared queries used in your Cloud instance.

### 5. Migrate apps and workflows

To migrate apps and workflows:

- In your Cloud instance, [protect all apps and workflows](../../../source-control/index.mdx). Make sure you merge the apps and workflows into the main branch.
- In your self-hosted instance, from the [source control deployment dashboard](../../../source-control/guides/manage-deployment.mdx#view-source-control-deployments), [deploy the latest version](../../../source-control/guides/manage-deployment.mdx#full-and-partial-deployments) of the repository.

:::warning

Workflow [webhook URLs](../../../workflows/guides/triggers/webhooks.mdx) change during the migration, so make sure to update any webhooks you reference elsewhere in your stack.

:::

### 6. Test apps and workflows

On your self-hosted instance, test the most critical apps and workflows.

## Without Source Control

If you don't use Source Control, use the following steps to copy your apps and workflows to your self-hosted instance.

### 1. Recreate resources

Cloud resources may use [config vars](../../../org-users/guides/configuration/config-vars.mdx) to set credentials, such as passwords or API keys. First, manually migrate config vars to the self-hosted instance.

Next, recreate all resources in your self-hosted instance. Ensure both instances use the same resource names. If your resource names differ, imported apps and workflows will not work properly.

Self-hosted instances can use [environment variables](../secrets/environment-variables.mdx#1-define-the-retool_exposed_db_password-variable), or secrets managers such as [AWS Secrets Manager](../secrets/aws.mdx) and [HashiCorp Vault](../secrets/hashicorp-vault.mdx), to store sensitive credentials. Consider moving credentials such as database passwords, or API keys, to one of these methods.

:::note

All plans support environment variables. The Enterprise plan supports integrations with secrets managers.

:::

### 2. Retool Database

To migrate Retool Database from your Cloud instance to self-hosted, manually export and import your tables. You can [export a CSV](../../../data-sources/quickstarts/retool-database.mdx#export-data-as-a-csv) for each table on your Cloud instance, and [import each CSV](../../../data-sources/quickstarts/retool-database.mdx#import-csv) into your self-hosted database.

### 3. Copy Query Library queries

Queries in the [Query Library](../../../queries/concepts/query-library.mdx) are not synchronized with Source Control. In your self-hosted instance, manually recreate any shared queries used in your Cloud instance.

### 4. Export apps and workflows

:::warning

Workflow [webhook URLs](../../../workflows/guides/triggers/webhooks.mdx) change during the migration, so make sure to update any webhooks you reference elsewhere in your stack.

:::

Next, [export your apps and workflows](../../../apps/guides/app-management/import-export.mdx) as JSON. Exports include any queries and configuration options in use, and you create individual exports for each app and workflow. To export an app or workflow, click the **•••** button to open the contextual menu, then select **Export and download**.

Now, import these into your self-hosted organization. To import an app or workflow, click **Create new** and select **From JSON**.

### 5. Test apps and workflows

On your self-hosted instance, test the most critical apps and workflows.

## Update your organization settings

Update the self-hosted deployment to invite users and copy over settings.

### 1. Invite users

After migrating apps and workflows, add your users to the new instance using [single-sign on](../../../sso/index.mdx) (SSO) or email and password authentication. Retool strongly recommends using SSO to authenticate users. SSO is more secure than email and password authentication, and using an identity provider can simplify the process of managing your users.

:::note

All plans support SSO with Google. The Enterprise plan supports SSO using any SAML or OIDC identity provider.

:::

#### Provision users

If you authenticate using SSO, and your identity provider supports JIT user provisioning, you can automatically migrate users by configuring SSO and JIT provisioning on the new instance. When a user signs in using SSO to the new instance, Retool automatically creates a new user account.

If you use email and password authentication, manually migrate users [by sending email invitations](../../../org-users/tutorials/manage.mdx#invite-users). You can bulk invite users by inserting a comma-separated list of email addresses. When a user signs up using the link in the email invite, Retool creates a new user account.

#### Migrate permission groups

You can migrate permission groups with role mapping or by manually recreating permission groups.

If you use role mapping with an OIDC or SAML-based identity provider, you can set up role mapping on the new instance to migrate groups. After configuring role mapping, your permission groups automatically migrate to the new instance.

If you do not use role mapping, recreate your [permission groups](../../../permissions/guides/configure-permission-groups) in your new instance and add your users to them.

### 2. Copy settings

Copy [app themes](../../../apps/guides/presentation-styling/themes.mdx), [custom branding](../../../org-users/concepts/branding.mdx), and any [org-wide JavaScript](../../../queries/guides/javascript/custom.mdx) from your Cloud instance to your self-hosted instance. You must manually recreate themes in your self-hosted instance. Check the [Settings page](https://login.retool.com/auth/login?source=docs&redirectOnLogin=settings) for any other settings you need to migrate to the new instance, including **Beta** feature flags.

## 3. Usage Analytics

To set up [usage analytics](../../../org-users/guides/monitoring/usage-analytics.mdx) on your self-hosted instance, reach out to your Retool account manager to obtain an access token. After you have a token, [follow the instructions](../../../org-users/guides/monitoring/usage-analytics.mdx#enable-usage-analytics-on-self-hosted-retool) to enable usage analytics.

## Downgrade plan

When you no longer need to use your Cloud organization, downgrade it to the Free plan. Navigate to the **Billing** settings and click **Downgrade**. Ensure you have migrated all your apps, resources, workflows, and database tables before doing this.

---

## Migrate from Self-hosted to Cloud

import EnterpriseRequirement from "../../_partials/_enterprise-plan-requirement.mdx";

This guide outlines the steps required to copy your apps and configuration from your self-hosted deployment to Retool Cloud. Before you begin, review the [pricing](https://retool.com/pricing) page to confirm your Cloud plan supports the features you need. Self-hosted plans have a different set of supported features and may have a [different billing structure](/support/billing-usage) than Cloud plans.

## Requirements

To perform this migration, you need:

- A working Cloud instance of Retool. To create Cloud instance of Retool, sign up for an account on [retool.com](https://retool.com/).
- A working Self-hosted instance of Retool.
- [Admin permissions](../../../permissions/guides/configure-permission-groups#default-permission-groups) on both instances.

Before migrating, [upgrade your self-hosted instance](../../concepts/update-deployment.mdx) to the most recent version of Retool. Self-hosted releases are typically two weeks behind Cloud releases, so your self-hosted instance may be missing features already on your Cloud instance. Typically this does not cause any issues, but you may need to make minor modifications to your applications on the self-hosted instance.

If your plan includes Source Control, follow the instructions for migrating [with Source Control](#with-source-control). Otherwise, follow the instructions for migrating [without Source Control](#without-source-control).

## With Source Control

If you use [Source Control in Retool](../../../source-control/index.mdx), use the following steps to synchronize apps, resources, and workflows between your Cloud and self-hosted instances. Source Control is available on [an Enterprise plan](https://retool.com/pricing). Reach out to your Retool account manager if you are interested in an Enterprise plan.

### 1. Configure Source Control

Ensure you have configured Source Control on your self-hosted instance and that you can access its repository. Next, set up [source control](../../../source-control/index.mdx) on your Cloud instance. Use the same provider and repository as your self-hosted instance. Source Control with GitHub and GitLab are supported on Retool Cloud.

### 2. Migrate resources

If your self-hosted instance uses [config vars](../../../org-users/guides/configuration/config-vars.mdx) to set credentials, manually copy these config vars to your Cloud instance.

:::note

If you use [environment variables](../secrets/environment-variables.mdx), [AWS Secrets Manager](../secrets/aws.mdx), or [HashiCorp Vault](../secrets/hashicorp-vault.mdx) to store credentials, you need to store those credentials as secret [config vars](../../../org-users/guides/configuration/config-vars.mdx), or directly within the resource configuration page.

:::

Next, migrate your resources:

- In your self-hosted instance, [protect all resources](../../../source-control/guides/protect/resources.mdx). Make sure you merge the resources into the main branch.
- In your Cloud instance, from the [source control deployment dashboard](../../../source-control/guides/manage-deployment.mdx#view-source-control-deployments), [deploy the latest version](../../../source-control/guides/manage-deployment.mdx#full-and-partial-deployments) of the repository.

Confirm that you can see your resources in the self-hosted instance.

### 3. Retool Database

To migrate Retool Database from your self-hosted instance to Cloud, manually export and import each table into the Cloud instance. You can [export a CSV](../../../data-sources/quickstarts/retool-database.mdx#export-data-as-a-csv) for each table on your self-hosted instance, and [import each CSV](../../../data-sources/quickstarts/retool-database.mdx#import-csv) into your Cloud database.

### 4. Copy Query Library queries

Queries in the [Query Library](../../../queries/concepts/query-library.mdx) are not synchronized with Source Control. In your Cloud instance, manually recreate any shared queries used in your self-hosted instance.

### 5. Migrate apps and workflows

To migrate apps and workflows:

- In your self-hosted instance, [protect all apps and workflows](../../../source-control/index.mdx). Make sure you merge the apps and workflows into the main branch.
- In your Cloud instance, from the [source control deployment dashboard](../../../source-control/guides/manage-deployment.mdx#view-source-control-deployments), [deploy the latest version](../../../source-control/guides/manage-deployment.mdx#full-and-partial-deployments) of the repository.

:::warning

Workflow [webhook URLs](../../../workflows/guides/triggers/webhooks.mdx) change during the migration, so make sure to update any webhooks which are referenced elsewhere in your stack.

:::

### 7. Test apps and workflows

On your Cloud instance, test the most critical apps and workflows.

## Without Source Control

If you don't use Source Control or your plan does not include Source Control, use the following steps to copy your apps and workflows to your Cloud instance. Business and Team plans do not include Source Control.

### 1. Recreate resources

If your self-hosted instance uses [config vars](../../../org-users/guides/configuration/config-vars.mdx) to set credentials, manually copy these config vars to your Cloud instance.

:::note

If you are using [environment variables](../secrets/environment-variables.mdx), [AWS Secrets Manager](../secrets/aws.mdx), or [HashiCorp Vault](../secrets/hashicorp-vault.mdx) to store credentials, store those credentials as secret [config vars](../../../org-users/guides/configuration/config-vars.mdx) or directly within the resource configuration page.

:::

Next, recreate all resources in your Cloud instance. Ensure that resource names are identical between instances. If your resource names differ, imported apps and workflows will not work properly.

### 2. Retool Database

To migrate Retool Database from your self-hosted instance to Cloud, manually export and import each table into the Cloud instance. You can [export a CSV](../../../data-sources/quickstarts/retool-database.mdx#export-data-as-a-csv) for each table on your self-hosted instance, and [import each CSV](../../../data-sources/quickstarts/retool-database.mdx#import-csv).

### 3. Copy Query Library queries

Queries in the [Query Library](../../../queries/concepts/query-library.mdx) are not synchronized with Source Control. In your Cloud instance, manually recreate any shared queries used in your self-hosted instance.

### 4. Export apps and workflows

:::warning

Workflow [webhook URLs](../../../workflows/guides/triggers/webhooks.mdx) change during the migration, so make sure to update any webhooks you reference elsewhere in your stack.

:::

Next, [export your apps and workflows](../../../apps/guides/app-management/import-export.mdx) as JSON. Exports include any queries and configuration options in use.

Apps and workflows are exported individually. To export an app, click the **•••** button to open the contextual menu, then select **Export and download**.

Now, import these into your Cloud organization. To import an app or workflow, click **Create new** and select **From JSON**.

### 5. Perform application testing

On your Cloud instance, test the most critical apps and workflows.

## Update your organization

Update the Cloud deployment to invite users and copy over settings.

### 1. Invite users

After migrating apps and workflows, add your users to the new instance using [single-sign on](../../../sso/index.mdx) (SSO) or email and password authentication. Retool strongly recommends using SSO to authenticate users. SSO is more secure than email and password authentication, and using an identity provider can simplify the process of managing your users.

:::note

All plans support SSO with Google. The Enterprise plan supports SSO using any SAML or OIDC identity provider.

:::

#### Provision users

If you authenticate using SSO, and your identity provider supports JIT user provisioning, you can automatically migrate users by configuring SSO and JIT provisioning on the new instance. When a user signs in using SSO to the new instance, Retool automatically creates a new user account.

If you use email and password authentication, manually migrate users [by sending email invitations](../../../org-users/tutorials/manage.mdx#invite-users). You can bulk invite users by inserting a comma-separated list of email addresses. When a user signs up using the link in the email invite, Retool creates a new user account.

#### Migrate permission groups

You can migrate permission groups with role mapping or by manually recreating permission groups.

If you use role mapping with an OIDC or SAML-based identity provider, you can set up role mapping on the new instance to migrate groups. After configuring role mapping, your permission groups automatically migrate to the new instance.

If you do not use role mapping, recreate your [permission groups](../../../permissions/guides/configure-permission-groups) in your new instance and add your users to them.

### 2. Copy settings

Copy [app themes](../../../apps/guides/presentation-styling/themes.mdx), [custom branding](../../../org-users/concepts/branding.mdx), and any [org-wide JavaScript](../../../queries/guides/javascript/custom.mdx) from your self-hosted instance to your Cloud instance. You must manually recreate themes in your Cloud instance. Check the [Settings page](https://login.retool.com/auth/login?source=docs&redirectOnLogin=settings) for any other settings you need to migrate to the new instance, including **Beta** feature flags.

## Downgrade plan

When you no longer need to use the self-hosted organization, downgrade it to the Free plan. Navigate to [Retool Self-hosted Portal](https://my.retool.com/) and change your plan to a free plan.

---

## Multiplayer for self-hosted Retool Apps

import EnterpriseRequirement from "../_partials/_enterprise-plan-requirement.mdx";

Multiplayer enables multiple users to make changes to the same app simultaneously. Similar to collaborative editing tools like Google Docs, users can see what others are working on and changes are reflected in real-time. 

[Learn more about multiplayer](../../apps/concepts/multiplayer.mdx).

Use the instructions in this guide to set up multiplayer on a self-hosted deployment, which requires additional configuration.

:::note

Multiplayer is enabled by default on cloud instances and requires no additional configuration.

:::

## Multiplayer infrastructure

Enabling multiplayer for self-hosted Retool requires making several infrastructure changes:

1. Deploy a new _multiplayer service_. This service manages the real-time editing state.
2. Update your frontend proxy to route multiplayer traffic to the new multiplayer service.

The multiplayer service and the Retool editor frontend maintain a WebSocket connection. The multiplayer service also requires the ability to connect to the main Postgres database.

The following sections include more details about making this architecture change using Retool's [official retool-helm chart](../tutorials/kubernetes/helm.mdx) or a non-helm deployment.

## Configuring multiplayer with Kubernetes Helm

import Prereqs from '../_partials/_multiplayer_prereq.mdx';

Using the [official retool-helm chart](../tutorials/kubernetes/helm.mdx) is the easiest way to set up multiplayer.

Enable the service by setting the `multiplayer: enabled` option [in your values file](https://github.com/tryretool/retool-helm/blob/3e1759d575cfb05a18ff39ea12424658b766ddcb/values.yaml#L494).

:::note

You can also opt-in to use Retool's preconfigured [ingress rules](https://github.com/tryretool/retool-helm/blob/69a3d90cb736b1b6450684e0db74dad96d756306/charts/retool/templates/ingress.yaml#L33), or you can [configure them manually](#configure-web-proxy).

:::

## Configuring multiplayer for non-Kubernetes Helm deployments

First, provision resources to run the multiplayer service. Then, complete the steps in the following sections.

### Set environment variables

Set the following environment variables for the new container:

```
# Multiplayer-specific environment variables
SERVICE_TYPE=MULTIPLAYER
MULTIPLAYER_SERVER_PORT=3009 # Configure to match your proxy settings (see Configure web proxy section).

# Standard required environment variables. Their values should match the values used for the existing Retool backend service.
COOKIE_INSECURE
WEBSOCKET_ALLOWED_ORIGIN # Supports '*' wildcard
POSTGRES_HOST
POSTGRES_PORT
POSTGRES_DB
POSTGRES_USER
POSTGRES_SSL_ENABLED
POSTGRES_PASSWORD
ENCRYPTION_KEY
JWT_SECRET
LICENSE_KEY
```

:::important

Beginning in the Q2 2026 stable release, the `LICENSE_KEY` environment variable will be required for the multiplayer service. Retool recommends setting it now to avoid any service interruptions.

:::

### Configure web proxy

Configure the web proxy to route traffic for `api/multiplayer/*` to the new multiplayer service. All other traffic should route to the regular Retool backend service.

The following code snippet is an example [nginx](https://www.f5.com/go/product/welcome-to-nginx) configuration that achieves this. Note that this example does not include SSL termination and omits unrelated settings, so your actual config may look slightly different.

```
# nginx/nginx.conf

http {
  map $http_upgrade $connection_upgrade {
    default upgrade;
    '' close;
  }

  server {
    listen 80;
    server_name retool.app.localhost;
    error_log /var/log/nginx/retool80.error_log debug;

    location /api/multiplayer/ {
      proxy_pass http://multiplayer:3009/api/multiplayer/;

      proxy_http_version 1.1;
      proxy_set_header Upgrade $http_upgrade;
      proxy_set_header Connection $connection_upgrade;
      proxy_set_header Host $host;
    }

    # Existing configuration to route traffic to Retool's API.
    # This config must come after the /api/multiplayer config above since
    # it is less specific.
    location / {
      proxy_pass http://api:3000/;

      resolver 127.0.0.11 valid=30s;
      add_header X-XSS-Protection "1; mode=block";
      add_header X-Content-Type-Options nosniff;
    }
  }
}
```

## Verify functionality

To verify that the feature is working, open an app in the Retool editor. If the multiplayer feature is enabled, you will see your avatar on the right side of the status bar.

The **Network** tab should show a WebSocket connection. The **Status** column should say `101` and the **Time** column should say `Pending` because the connection is left open.

WebSocket connection

The following screenshot shows example connection details. The expected response **Status Code** is `101 Switching Protocols`.

Example connection details

## Troubleshooting

If multiplayer functionality isn’t working, or you see many repeated connection attempts in the **Network** tab, the proxy likely isn’t configured correctly. To confirm traffic is reaching the multiplayer service, check the service’s logs for messages such as `“Handle updated request for ” and “Handle new connection for ...”`. 

If you don't see any logs from the multiplayer service, that can be an indicator that the routing is configured incorrectly, and that the traffic was directed to the backend service instead. Double check that your [web proxy](#configure-web-proxy) is configured correctly.

If you have any issues, please reach out to Retool Support and send your multiplayer service logs.

---

## Configure same-origin and sandbox for iframes

import EnterpriseRequirement from "../_partials/_enterprise-plan-requirement.mdx";

By default, self-hosted deployments enforce the [same-origin policy](https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy) for iframes and custom components embedded in Retool apps. All embedded content is considered to be from a separate origin and fails the same-origin policy. 

This isolates embedded content (e.g., custom components) for security purposes but it can restrict functionality, such as:

- Accesing cookies.
- Accessing certain JavaScript APIs.
- Making any HTTP requests.

If necessary, you can set the `ALLOW_SAME_ORIGIN_OPTION` environment variable to use the `allow-same-origin` attribute and bypass these restrictions.

## Update environment variables

You can update your environment variable configuration to use `allow-same-origin` for iframe content by setting the `ALLOW_SAME_ORIGIN_OPTION` environment variable to `true`. 

:::danger Set `SANDBOX_DOMAIN` to avoid security risks

If you need iframes to use `allow-same-origin`, you should also set the `SANDBOX_DOMAIN` environment variable.

:::

## Configure sandbox domain

By default, your Retool instance will make use of a single domain, and all access to your Retool backend will arrive via that domain. However, having only a single domain can cause some security issues when `ALLOW_SAME_ORIGIN_OPTION` is set to `true`. 

Setting up an additonal domain to point to your Retool backend, and then setting the value `SANDBOX_DOMAIN` to this second domain, can protect you from these security issues. 

Once `SANDBOX_DOMAIN` is set, it provides an alternative origin for the browser to use when executing builder-written JavaScript. This isolates builder-written code from interacting with the the rest of the page and it's contents, including authentication cookies for your Retool backend. 

If `SANDBOX_DOMAIN` is not set, but `ALLOW_SAME_ORIGIN_OPTION` is set, all builder-written JavaScript code runs on the same origin as your Retool deployment instance, and has access to everything on the page, including all cookies. A malicious builder on your Retool instance could take advantage of this to run their javascript code in other builder's browsers, and take actions on their behalf. 

The value you use for `SANDBOX_DOMAIN` should be a fully functional domain that routes HTTP requests to your Retool instance. In most cases, this requires going through the process of registering a new domain, and configuring it to point to your Retool backend.

For example, if you currently host your Retool backend on `mydomain.com`, Retool recommends you registering a new domain, such as `mydomain-sandbox.com`, and set `mydomain-sandbox.com` to point to your Retool backend (identically to how you setup `mydomain.com`). Then, set the value of the `SANDBOX_DOMAIN` environment variable to be `https://mydomain-sandbox.com`. Note that you must include the protocol in the value, which is usually `https`.

---

## Prevent users from creating or using specific resource types

import EnterpriseRequirement from "../_partials/_enterprise-plan-requirement.mdx";

Self-hosted organizations can specify optional restrictions using [environment variables](../reference/environment-variables/index.mdx) that prevent users from creating or using certain resource types. The restrictions you set depend upon your use case. Configuring these restrictions does not remove or modify the configuration of an existing resource.

Any restrictions you set can be reverted at any time. This enables you to temporarily disable resources (e.g., if your security team needs to review an integration before it can be used).

## Prevent users from creating certain resource types

Use the `RESOURCE_TYPES_CREATION_DENY_LIST` environment variable to specify a comma-separated list of resource integration types that cannot be created. Users can still interact with any existing resources of these types but they will not be able to create new ones.

```title="Example"
RESOURCE_TYPES_CREATION_DENY_LIST=graphql,twilio,postgresql
```

## Prevent users from creating or using certain resource types

In some cases, you may need to block all use of a certain resource type. You can use the `RESOURCE_TYPES_DENY_LIST` environment variable to provide a list of all resource integration types that are to be blocked. This effectively disables the resource type on the deployment instance, preventing users from creating and querying resources of these types.

```title="Example"
RESOURCE_TYPES_DENY_LIST=graphql,twilio,postgresql
```

Once enabled, any queries for restricted resources will not run and return a query error.

:::note

The error message displayed in self-hosted Retool 3.300 and later also explains that that query failed due to the resource being restricted. Prior releases only return a query error.

:::

## Specify the environment variable values

Both environment variables can accept a comma-separated list containing any of the following resource type values. Refer to the [self-hosted deployment tutorials](../tutorials.mdx) to learn more about configuring environment variables for your instance.

| Resource               | Type                 |
| ---------------------- | -------------------- |
| PostgreSQL             | `postgresql`         |
| MySQL                  | `mysql`              |
| MSSQL                  | `mssql`              |
| OracleDB               | `oracledb`           |
| Redshift               | `redshift`           |
| MCP                    | `mcp`                |
| MongoDB                | `mongodb`            |
| Google Sheets          | `googlesheets`       |
| Elasticsearch          | `elasticsearch`      |
| Cassandra              | `cassandra`          |
| CosmosDB               | `cosmosdb`           |
| CouchDB                | `couchdb`            |
| RethinkDB              | `rethinkdb`          |
| REST API               | `restapi`            |
| GraphQL                | `graphql`            |
| BigQuery               | `bigquery`           |
| S3                     | `s3`                 |
| GCS                    | `gcs`                |
| Slack                  | `slackopenapi`       |
| Salesforce             | `salesforce`         |
| Athena                 | `athena`             |
| GitHub                 | `github`             |
| Stripe                 | `stripe`             |
| Twilio                 | `twilio`             |
| SendGrid               | `sendgrid`           |
| Firebase               | `firebase`           |
| DynamoDB               | `dynamodb`           |
| Basecamp               | `basecamp`           |
| Close.io               | `closeio`            |
| Snowflake              | `snowflake`          |
| Redis                  | `redis`              |
| Vertica                | `vertica`            |
| Presto                 | `presto`             |
| SAP Hana               | `saphana`            |
| Lambda                 | `lambda`             |
| OpenAPI                | `openapi`            |
| Google Cloud Datastore | `datastore`          |
| gRPC                   | `grpc`               |
| SMTP                   | `smtp`               |
| Jira                   | `jira`               |
| BigID                  | `bigid`              |
| AlloyDB                | `alloydb`            |
| Databricks             | `databricks`         |
| Databricks Lakebase    | `databricksLakebase` |
| JDBC                   | `jdbc`               |
| Kafka                  | `kafka`              |
| SQS                    | `sqs`                |
| SNS                    | `sns`                |
| Tavily                 | `tavily`             |

---

## Set up Retool Database on Self-hosted deployments

import EnterpriseRequirement from "../_partials/_enterprise-plan-requirement.mdx";

[Retool Database](../../data-sources/quickstarts/retool-database.mdx) is a PostgreSQL resource provided by Retool. You can query it like any other resource, but it also includes a spreadsheet-like interface for interacting with data.

On self-hosted deployments, you can use your own PostgreSQL database to host Retool Database. Your database automatically connects to the main Retool backend service for your deployment. This allows you to use Retool Database's interface for managing data. 

Retool Database is included in all pricing plans. Because you control your own PostgreSQL database on self-hosted deployments, there are no data limits or overages for Retool Database on self-hosted deployments.

:::info

Retool Database is separate from the [storage database](../concepts/architecture.mdx#containers-and-services), which is required in self-hosted Retool deployments to store user information and logs.

:::

## Requirements

To use Retool Database on self-hosted deployments, you need:

- A PostgreSQL database. On self-hosted Retool versions 3.14 or later, you need a database running PostgreSQL version 14.3 or later.
- Credentials for a database user with permissions to create databases and roles. These credentials are used once to create the database and generate a generic user, who only has access to the created database. Further interactions, such as querying the database, use the generic user and its permissions.

:::note

Organizations with self-hosted deployments using [Kubernetes](../tutorials/kubernetes/manifests.mdx), [Helm](../tutorials/kubernetes/helm.mdx), or [ECS Fargate](../tutorials/ecs-fargate/index.mdx) must specify a PostgreSQL database to use for the backend. 

:::

## 1. Add database configuration

Navigate to `{your-domain}/resources?setupRetoolDB=1` on Retool and fill out the form with the following fields.

| **Setting**       | **Description**                                   |
| ----------------- | ------------------------------------------------- |
| Database host     | The URL or IP address.                            |
| Database name     | The name of the database.                         |
| Database username | The username.                                     |
| Database password | The password.                                     |
| Database port     | The port number.                                  |
| Use SSL/TLS       | Connect with [SSL/TLS](../../data-sources/guides/connections/ssl.mdx). |

Select **Test your connection** to confirm you can connect to Retool Database.  

:::warning
Using Docker to host Retool Database is not recommended for storing production data, and Retool recommends [externalizing the database](./retool-database.mdx#specify-an-external-postgresql-database)

:::

A Retool Database PostgreSQL container is automatically created and provisioned on new deployments that use [Docker Compose](../tutorials.mdx). Refer to the [retool-onpremise](https://github.com/tryretool/retool-onpremise) repository for more information on adding a Retool Database PostgreSQL container to existing deployments.

## 2. Save your resource

Click **Save and initialize** to save your Retool Database settings. You can now use with the [Database editor UI](../../data-sources/quickstarts/retool-database.mdx#interact-with-data-using-the-database-editor-ui) to configure and interact with your Retool Database tables.

## 3. Import existing data

Retool always creates a new database for each of your environments. To import existing data to Retool Database, use [pg_dump and psql](https://www.postgresql.org/docs/14/backup-dump.html) commands. 

You can use the [connection strings](../../data-sources/quickstarts/retool-database.mdx#connection-strings) dropdown to find the database host, name, user, password, and port for the current environment. 

:::note

Changing the connection string does not switch the underlying data store, and the only way to migrate existing data from one database to another is through `pg_dump` and `psql`. You can also connect an existing PostgresSQL database using the [native integration](../../data-sources/guides/integrations/database/postgresql.mdx).

:::

Use `pg_dump` and `psql` commands to migrate data between databases. Your commands might use the following structure:

```title="Export SQL"
pg_dump EXISTING_DATABASE_CONNECTION_STRING > pg_dump.sql
```

```title="Import SQL"
psql RETOOL_CONNECTION_STRING < pgdump.sql
```

---

## Set up Retool Storage on Self-hosted deployments

import EnterpriseRequirement from "../_partials/_enterprise-plan-requirement.mdx";

[Retool Storage](../../data-sources/quickstarts/retool-storage.mdx) is a file storage resource provided by Retool. You can use it like any other file storage resource, with the addition of a Retool-provided file manager interface.

On self-hosted deployments, you can use your own storage bucket to host Retool Storage. This allows you to use Retool Storage's interface for managing files.

:::info 

Retool supports the following storage providers:

* [Amazon Simple Storage Service (Amazon S3)](../../data-sources/guides/integrations/object-file-store/amazon-s3.mdx)
* [Google Cloud Storage (GCS)](../../data-sources/guides/integrations/google/google-cloud-storage.mdx)
* S3-compatible storage providers like [Digital Ocean Spaces](https://docs.digitalocean.com/reference/api/spaces-api/) or [Wasabi](https://wasabi.com/downloads/)

:::

Retool Storage is included in all [pricing plans](https://retool.com/pricing). Because you control your own file storage bucket on self-hosted deployments, there are no data limits or overages for Retool Storage on self-hosted deployments.

### Requirements

To use Retool Storage on self-hosted deployments, you need credentials for a user who has permissions to modify and read files within your file storage provider. Retool uses these credentials to upload, download, and delete files.

### 1. Add storage configuration

Navigate to `{your-domain}/resources` on Retool and next to Retool Storage click **Settings**

Set up the resource per your storage provider.

Click **Test your connection** to confirm that you can connect to your storage provider.  

### 2. Save your resource

Click **Save** to save your Retool Storage settings. You can now use with the [Retool Storage interface](../../data-sources/quickstarts/retool-storage.mdx) to preview, upload, and download your Retool Storage files.

:::warning 

### Changing storage provider will break all existing files

In order to migrate to another provider, all files need to be manually copied from the prior storage bucket to the new one with identical folder structure.

:::

---

## Rotate your encryption key

import EnterpriseRequirement from "../_partials/_enterprise-plan-requirement.mdx";

Retool supports encryption key rotation for organizations with self-hosted deployments. This encryption key is used to encrypt sensitive values in Retool's backend database. Encryption key rotation is a *zero-downtime* operation. 

Organizations should rotate their encryption key if they suspect that their key was leaked or exposed to an unauthorized individual. Use the procedures below to add an encryption key to a deployment that previously did not have one. When using a deployment previously missing an encryption key, Retool generally does *not* encrypt values found to be in plaintext. 

The minimum version required to complete an encryption key rotation is 3.148. 

### 1. Take a snapshot of your deployment's database
Before you begin, Retool recommends that you take a snapshot of your instance's database and store it somewhere safely with limited permissions. Retool's key rotation procedure is intended to have no downtime or data loss, but its status as an public beta feature means there is a higher risk of data loss. 

### 2. Update your deployment's environment variables
Start with generating a new encryption key. Retool recommends your keys to be at least 64 characters in length. Set the following environment variables:

```
USE_ENCRYPTION_V2=true
ENCRYPTION_KEY_OLD={old encryption key}
ENCRYPTION_KEY={new encryption key}

ENABLE_LOGS_FOR_DECRYPTION_WITH_OLD_KEY=true # optional, used for observability (more below)
```

After updating these environment variable:
* Your database reads will be able to decrypt values encrypted with either the old or the new encryption key. 
* Your database writes will be encrypted with the new encryption key. 
* After adding a new key, it won't be safe to remove it until another database rotation is completed since it could be in use

If you are setting the encryption key for the first time, and therefore do not have an old encryption key, you can leave the `ENCRYPTION_KEY_OLD` environment variable blank in the encryption key rotation script. 

### 3. Run the database rotation script
To complete your encryption key rotation, encrypt all the values in your database to be encrypted with the new key using the following script:

```shell
./retool_backend --backfill-encrypt-secrets

Optional args:
--batch-size 
    > the number of rows to operate on in each batch (default 1000)
--resume-run-uuid 
    > the uuid of the backfill/key rotation run to resume, in case it previously failed/exited/etc

```

### 4. Monitor your deployment for completion
Monitor the output of the above script for completion of the database rotation. After completion, you can monitor your instance for any usage of the old encryption key. With the `ENABLE_LOGS_FOR_DECRYPTION_WITH_OLD_KEY` environment variable, any usage of the old key for decryption will emit one of the following logs:

```shell
[decrypt] Decrypting a secret using the old encryption key AND old encryption schema!
[decrypt] Decrypting a secret using the old encryption key!
[decryptBuffer] Decrypting a secret using the old encryption key!
```

If you see these logs after completing the encryption key rotation script, please contact us immediately at support@retool.com. 

### 5. Remove previous encryption key
If you are rotating your encryption key because you suspect a data breach, Retool recommends that you remove all references to the previous key as soon as you are confident the encryption key rotation script is complete. To do so, you can remove the `ENCRYPTION_KEY_OLD` environment variable from your instance.

---

## Rotate SSH keys

import EnterpriseRequirement from "../_partials/_enterprise-plan-requirement.mdx";

Organizations with Self-hosted Retool deployments can regenerate SSH keys used for SSH tunneling. This allows you to follow your organization's credential rotation policy or update keys if your encryption key has changed.

## Invalidate existing SSH keys

If you've rotated your encryption key—for example, while upgrading from Retool Cloud to Self-hosted—you may need to invalidate existing keys. These steps require access to the [Retool PostgreSQL database](storage-database.mdx).

### 1. Check the `ssh_keys` table

This SQL query should only return one record.

```sql
select * from ssh_keys
```

### 2. Remove the existing SSH key

```sql
truncate ssh_keys
```

## Regenerate and download the new SSH key

When you download Retool's public key, Retool creates a new SSH key if it doesn't already exist.

If your key is for SSH tunneling, use the **Download Retool's public key** link on the resource configuration page. Open the `retool.pub` file and copy the entire key to your clipboard. Clicking the link generates a new record in the `ssh_key` table and downloads the public key to your local machine.

---

## Scale your self-hosted deployment infrastructure

import ReleaseVersions from '@site/static/data/releases/stable.json'
import EnterpriseRequirement from "../_partials/_enterprise-plan-requirement.mdx";

Retool's self-hosted Docker image consists of several containers required to run your deployment. Before you continue, you should review [Retool's self-hosted architecture](../concepts/architecture.mdx) to understand which services need scaling as usage increases.

## Scale your Retool deployment

It's recommend to self-host Retool on a container orchestration service, such as Kubernetes. Retool provides [Helm charts](../tutorials/kubernetes/helm.mdx) and [Terraform modules](../tutorials/ecs-fargate/terraform.mdx) for you to easily get started. See the [deployment overview](../tutorials.mdx) for a full list of supported deployment options.

Retool is packaged as a single stateless Docker container. The only dependency it has is a PostgreSQL database, which is used to store data such as user information, organization settings, audit logs, and applications.

To scale a Retool instance, you follow these high-level steps:

1. Host the [PostgreSQL database](storage-database.mdx) on an external system, e.g., AWS RDS. The separation of database and application allows you to independently scale and manage each service.
2. Start multiple Retool containers that use the same Postgres database. The number of containers you deploy depends on your traffic and resource requirements. We recommend scaling the `api` container. You can do this by updating the replica count in your container orchestration service of choice.
3. Use a load balancer to route traffic between the Retool server containers to ensure high availability.

:::note

You should only run one replica of the `jobs-runner` in each Retool environment because it runs database migrations and other background tasks that should only operate as a singleton. You can scale up as many replicas as necessary of the containers/pods that run the other service types.

:::

## Near-zero downtime upgrades

All `MAJOR.MINOR` release upgrades, such upgrading from {Object.keys(ReleaseVersions)[1]} to {Object.keys(ReleaseVersions)[0]}, perform database migrations. Patch release upgrades within the same `MAJOR.MINOR` release, such as {Object.keys(ReleaseVersions)[0]}.1 to {Object.keys(ReleaseVersions)[0]}.2, generally do not.

### General upgrade strategy

Each container or pod attempts to perform database migrations at startup after an upgrade. In multi-container setups, upgrades must be coordinated carefully to prevent container deadlocks and minimize downtime.

:::tip
Database migrations are backward-compatible so older containers or pods can continue serving traffic while these migrations run.
:::

1. Stop all containers except `jobs-runner`.
1. Start a new `jobs-runner` container using the latest `MAJOR.MINOR.PATCH` image tag, such as {Object.keys(ReleaseVersions)[0]}.1-stable.
1. Wait for the database migrations to complete.
1. Stop the old `jobs-runner` container.
1. Start the remaining containers using the new image.
1. Verify all containers are healthy before routing traffic.

Kubernetes + Helm deployments support rolling upgrades that simplify the process. First, use `helm upgrade` with the latest release tag. For example:

```
helm upgrade retool retool/retool \
  --namespace retool \
  --set image.tag=3.196.1-stable
```

During the upgrade process:

- A new `jobs-runner` pod is created and starts running migrations.
- All other new pods start but wait for migrations to complete.
- Once all new pods are verified as healthy, the old pods are terminated automatically.

:::tip

You can monitor the progress of database migrations for the `job-runner` pod using `kubectl`:

```
kubectl logs deployment/jobs-runner -n retool
```
:::

For Kubernetes deployments without Helm, perform a manual rolling update.

1. Patch the `jobs-runner` deployment to use the new image tag.
1. Wait for the new pod to start and complete database migrations.
1. Patch the remaining deployments to use the new image.
1. Monitor rollout status and ensure all pods are healthy:

:::tip

You can monitor the progress of database migrations for the `job-runner` pod using `kubectl`:

```
kubectl rollout status deployment/ -n retool
```
:::

---

## _config Check

Retool checks the validity of the configuration to ensure that secrets are available. If Retool cannot access the secrets manager you've configured, an error message appears in the Secrets Manager settings.

Validate secrets configuration.

---

## Retrieve secrets from AWS Secrets Manager

import EnterpriseRequirement from "../../_partials/_enterprise-plan-requirement.mdx";

Configuring Resources in Retool can require handling sensitive values, e.g. database passwords or API keys. Retool is [SOC 2 Type 2 compliant](https://docs.retool.com/legal/security), and most customers store these values with Retool. However, depending on your security posture, you may want to store secret values externally, rather than encrypted in Retool’s database.

To support this, Retool supports retrieving secrets from AWS Secrets Manager for customers running self-hosted Retool.

## Requirements

To use the AWS Secrets Manager with Retool, you need:

- A self-hosted Retool deployment.
- Have [admin permissions](../../../permissions/guides.mdx) for your Retool organization.
- Already have AWS Secrets Manager configured to store your secrets.

## 1. Create IAM policy for Retool

In AWS, [create an IAM policy](https://docs.aws.amazon.com/secretsmanager/latest/userguide/auth-and-access_examples.html) to grant Retool access to your secrets. Retool recommends you store secrets under a `retool/` namespace for easier access control. The following is an example policy you might use.

```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": [
        "secretsmanager:GetSecretValue",
        "secretsmanager:DescribeSecret"
      ],
      "Resource": ["arn:aws:secretsmanager:Region:AccountId:secret:retool/*"]
    },
    {
      "Effect": "Allow",
      "Action": ["secretsmanager:ListSecrets"],
      "Resource": "*"
    }
  ]
}
```

## 2. Attach IAM policy to your principal

Next, attach the policy to the principal associated with your Retool workload. For example, if you deploy Retool on EC2, attach this policy to the instance profile for the EC2 instance.

## 3. Configure Secrets Manager in Retool
Secrets management must be configured for the primary organization, and for any spaces within an organization that need to use secrets.

import MultiInstance from './_multi-instance.mdx';

For each [Retool Space](../../../org-users/tutorials/spaces), visit **Settings** > **Secrets Manager** and enter the **Region** associated with your AWS Secrets Manager instance and an optional **Namespace** (details below). Click **Test connection** to confirm Retool can connect to your AWS Secrets Manager, then click **Save**.

### Namespace

The **Namespace** field is a value that will be prepended to any secret names Retool looks up. For example, if all your Retool-facing secrets in AWS Secrets Manager start with `retool/`, you might set the namespace to be `retool/` as well. If you have multiple Retool deployment instances, you can use this to resolve the same secret name in a Resource configuration to different secrets in your AWS account. For this reason, setting the namespace is recommended if you use [Protected Resources](../../../source-control/guides/protect/resources.mdx).

For example, if you have "development" and "production" deployment instances, you might use the following naming convention for secrets in your AWS account:

```
// Secrets for development
retool/dev/db_user
retool/dev/db_password

// Secrets for production
retool/prod/db_user
retool/prod/db_password
```

On your Retool development instance, you would then set the namespace to `retool/dev`, and on your production instance to `retool/prod`. You can then reference secrets for either deployment instance using `{{ secrets.db_user }}` and `{{ secrets.db_password }}`, and Retool will fetch the appropriate secret at runtime.

import ConfigCheck from './_config-check.mdx';

## 4. Use secrets in resources

After you save your Secrets Manager configuration in Retool, if you granted Retool the `ListSecrets` permission, available secrets appear on **Settings** > **Secrets Manager**.

You can reference them in Resource configurations using template syntax, e.g. `{{ secrets.name }}` or `{{ secrets['name'] }}`, either by copying values from the **Reference** column, or with autocomplete on the Resource configuration page.

You can access JSON keys with `{{ secrets.name.key }}` or `{{ secrets['name']['key'] }}`. You can access arbitrary levels of nested keys in your secrets. Note that keys will not autocomplete.

:::info

If your secret values are not quoted, you may need to wrap the template string in quotes in resource configurations.

For example, given an unquoted secret (`secret-value`) for the key `key_name`, you'd use `"{{ secrets.key_name.key }}"`. Given a quoted secret (`"secret-value"`), you'd use `{{ secrets.key_name.key }}`.

:::

When you rotate secrets in AWS, Retool automatically reads updated values from your secrets manager. This means you don't need to restart your Retool instance or update any configuration when rotating secrets.

## Time to live (TTL) setting

Retool caches secrets it fetches with a configurable time to live. This reduces API calls to your secrets manager, which keeps queries fast and reduces costs.
However, this means secrets may become temporarily "stale" when they are rotated. You can update **Cache TTL (ms)** in **Settings** > **Secrets Manager** to minimize failed queries in the event that a secret is rotated.

## Security considerations

Any user that can configure resources can use secrets in resources. This could lead to inappropriate uses of secrets. To mitigate risk, you can make use of the `secretsmanager:GetSecretValue` and `secretsmanager:DescribeSecret` actions via IAM policies.

---

## Manage secrets with environment variables

import EnterpriseRequirement from "../../_partials/_enterprise-plan-requirement.mdx";

You can use environment variables to manage secrets like database passwords and bearer tokens. This allows you to automatically rotate secret credentials, and help protect sensitive information.

If your use case requires higher level of security, you may want to use [AWS Secrets Manager](./aws.mdx) or [HashiCorp Vault](./hashicorp-vault.mdx) to externally manage secrets. These integrations allow you to rotate secrets without redeploying your Retool instance.

To manage secret and non-secret environment variables through Retool's web interface, consider using [configuration variables](../../../org-users/guides/configuration/config-vars.mdx).

## 1. Define the RETOOL_EXPOSED_DB_PASSWORD variable

Set the `RETOOL_EXPOSED_DB_PASSWORD` variable to your database connection string. Depending on how you set up Retool, you might need to restart the Docker container.

:::note

To avoid leaking potentially sensitive environment variables, Retool only allows users to read environment variables with the `RETOOL_EXPOSED_` prefix.

:::

## 2. Create a new Postgres connection

Add a new Postgres connection and use the connection string format. Make sure to replace the database password with the `%RETOOL_EXPOSED_DB_PASSWORD%` variable. It should look something like this.

You can use environment variables like this for any field that you define. For example, you could use environment variables to configure the headers you send in API requests.

## 3. Save and restart the container

Click **Save** and restart the container.

---

## Manage secrets with the file system

import EnterpriseRequirement from "../../_partials/_enterprise-plan-requirement.mdx";

Some deployment systems, like Docker swarm and Docker secrets, require secrets values to be read from the file system instead of being set through environment variables. For instance, instead of setting a `POSTGRES_PASSWORD` in your environment, you point `POSTGRES_PASSWORD_FILE` to a text file that contains the password.

## 1. Set the `RETOOL_LOAD_FILE_SECRETS` environment variable

:::caution

You must have the ability to set non-secret environment variables.

:::

At startup, Retool looks for the configured secret files and sets them as environment variables for running the container, not the entire system. Make sure to set the `RETOOL_LOAD_FILE_SECRETS` environment variable to `true`. Without this, Retool doesn't load secrets from the file system.

## 2. Configure environment variables

Instead of adding secrets to the environment directly, add the path to where your secrets are stored on the file system and append `_FILE` to the end of each environment variable name. For example, if you want to set the `ENCRYPTION_KEY`, you’d set `ENCRYPTION_KEY_FILE` to the path on the file system where the file exists.

```text
RETOOL_LOAD_FILE_SECRETS=true
ENCRYPTION_KEY_FILE=/path/to/key
```

When starting Retool, you can check the logs to verify the environment variables are set:

```
RETOOL-CONFIG: RETOOL_LOAD_FILE_SECRETS is true, reading the following secrets from the filesystem
RETOOL-CONFIG: Setting ENCRYPTION_KEY via /path/to/key
```

If you don't see messages similar to this, see the [troubleshooting](#troubleshooting) section.

## Manage your own secrets

Retool supports managing your own secrets using environment variables prefixed with `RETOOL_EXPOSED`. You can use the file system to manage these secrets too.

Instead of using the `RETOOL_EXPOSED` prefix, use `RETOOL_FILE_EXPOSED`. For example, if you want multiple resources to use your database password, set `RETOOL_FILE_EXPOSED_DB_PASSWORD` to the path on the file system.

```text
RETOOL_LOAD_FILE_SECRETS=true
RETOOL_FILE_EXPOSED_DB_PASSWORD=/path/to/db/password
```

## Troubleshooting

| **Error**                                                                                  | **Resolution**                                                                                                                                                                                                                                |
| ------------------------------------------------------------------------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `RETOOL-CONFIG: Error setting SECRET via SECRET_FILE: /path/to/secret_file does not exist` | This error means the path in the `SECRET_FILE` environment variable doesn't exist. Double check the path is accessible to the container running Retool at build time.                                                                         |
| `RETOOL-CONFIG: Error setting SECRET via SECRET_FILE: /path/to/secret_file is a directory` | This means the path provided in the `SECRET_FILE` environment variable exists, but isn't a file and can't be used to set the secret. Ensure the path provided in the `SECRET_FILE` environment variable points to a file and not a directory. |

---

## Retrieve secrets from GCP Secrets Manager

import EnterpriseRequirement from "../../_partials/_enterprise-plan-requirement.mdx";

Configuring Resources in Retool can require handling sensitive values, e.g., database passwords or API keys. Retool is [SOC 2 Type 2 compliant](https://docs.retool.com/page/security), and most customers store these values with Retool. However, depending on your security posture, you may want to store secret values externally, rather than encrypted in Retool’s database. To support this, you can store and retrieve secrets from GCP Secrets Manager.

## Requirements

To use the GCP Secrets Manager with Retool, you must:

- Run self-hosted Retool on versions 3.20 or later on the Enterprise plan.
- Have [admin permissions](../../../permissions/guides.mdx) for your Retool organization.
- Already have GCP Secrets Manager configured to store your secrets.

## 1. Set up Application Default Credentials

In GCP, [set up application default credentials](https://cloud.google.com/docs/authentication/provide-credentials-adc?hl=en) to grant Retool access to your secrets.

### Workload Identity on Google Kubernetes Engine (GKE)

If you are using Google Kubernetes Engine to host Retool, you can use [workload identity](https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity) to set up application default credentials. Retool already creates a service account called `retool` in the GKE cluster. To complete the setup, add your IAM service account annotation to this pre-existing service account.

Alternatively, to automate this process, you can inject the annotations via `values.yaml` in the Retool Helm chart:

```yaml
serviceAccount:
  create: true
  name:
  annotations:
    iam.gke.io/gcp-service-account: ${gke_service_account}
```

## 2. Configure Secrets Manager in Retool
Secrets management must be configured for the primary organization, and for any spaces within an organization that need to use secrets.

import MultiInstance from './_multi-instance.mdx';

For each [Retool Space](../../../org-users/tutorials/spaces), navigate to **Settings** > **Secrets Manager** and enter the [Project ID and Project Number](https://cloud.google.com/resource-manager/docs/creating-managing-projects#identifying_projects) associated with your GCP Secrets Manager instance, and an optional **Namespace**. Click **Test connection** to confirm Retool can connect to your GCP Secrets Manager, then click **Save**.

### Namespace

The **Namespace** field is a value that's prepended to any secret names Retool looks up. For example, if all your Retool-facing secrets in GCP Secrets Manager start with `retool-`, you might set the namespace to be `retool-` as well. If you have multiple Retool deployment instances, you can use this to resolve the same secret name in a resource configuration to different secrets in your GCP account. For this reason, setting the namespace is recommended if you use [Protected Resources](../../../source-control/guides/protect/resources.mdx).

For example, if you have "development" and "production" deployment instances, you might use the following naming convention for secrets in your GCP account:

```
// Secrets for development
retool-dev-db_user
retool-dev-db_password

// Secrets for production

retool-prod-db_user
retool-prod-db_password
```

On your Retool development instance, you would then set the namespace to `retool/dev`, and on your production instance to `retool/prod`. You can then reference secrets for either deployment instance using `{{ secrets.db_user }}` and `{{ secrets.db_password }}`, and Retool will fetch the appropriate secret at runtime.

import ConfigCheck from './_config-check.mdx';

## 3. Use secrets in resources

After you save your Secrets Manager configuration in Retool, if you granted Retool the Secret Manager Admin or Secret Manager Viewer IAM roles, available secrets appear on **Settings** > **Secrets Manager**.

For users to access secret values, the Secret Manager Admin or Secret Manager Secret Accessor IAM roles must be used. You can reference them in resource configurations using template syntax, e.g., `{{ secrets.name }}` or `{{ secrets['name'] }}`, either by copying values from the **Reference** column, or with autocomplete on the resource configuration page.

You can access JSON keys with `{{ secrets.name.key }}` or `{{ secrets['name']['key'] }}`. You can access arbitrary levels of nested keys in your secrets. Note that keys will not autocomplete.

:::info

If your secret values are not quoted, you may need to wrap the template string in quotes in resource configurations.

For example, given an unquoted secret (`secret-value`) for the key `key_name`, you'd use `"{{ secrets.key_name.key }}"`. Given a quoted secret (`"secret-value"`), you'd use `{{ secrets.key_name.key }}`.

:::

When you rotate secrets in GCP, Retool automatically reads updated values from your secrets manager. This means you don't need to restart your Retool instance or update any configuration when rotating secrets.

## Time to live (TTL) setting

Retool caches secrets it fetches with a configurable time to live. This reduces API calls to your secrets manager, which keeps queries fast and reduces costs.
However, this means secrets may become temporarily stale when they are rotated. You can update **Cache TTL (ms)** in **Settings** > **Secrets Manager** to minimize failed queries in the event that a secret is rotated.

## Security considerations

Any user that can configure resources can use secrets in resources. This could lead to inappropriate uses of secrets. You can restrict the Secret Manager Admin, Secret Manager Secret Accessor, and Secret Manager Viewer IAM roles to authorized users only in GCP to mitigate the risk.

---

## Retrieve secrets from HashiCorp Vault

import EnterpriseRequirement from "../../_partials/_enterprise-plan-requirement.mdx";

Configuring Resources in Retool can require handling sensitive values, e.g. database passwords or API keys. Retool is [SOC 2 Type 2 compliant](https://docs.retool.com/page/security), and most customers store these values with Retool. However, depending on your security posture, you may want to store secret values externally, rather than encrypted in Retool’s database.

To support this, Retool supports retrieving secrets from HashiCorp Vault for customers running self-hosted Retool.

## Requirements

:::note

Retool only supports versioned KV (v2) engines.

:::

To use HashiCorp Vault with Retool, you need:

- A self-hosted Retool deployment
- A Retool organization on the Enterprise plan.
- [Admin permissions](../../../permissions/guides.mdx) for your Retool organization.
- Have HashiCorp Vault configured to store your secrets in a [versioned KV (v2)](https://developer.hashicorp.com/vault/docs/secrets/kv/kv-v2) engine.

## 1. Enable AppRole Auth Method

Follow the first two steps in the [Vault tutorial](https://developer.hashicorp.com/vault/tutorials/auth-methods/approle) to create a role for Retool with a policy to grant access to your secrets. The following is an example policy you might use.

```hcl
path "secret-mount/data/*" {
  capabilities = [ "read" ]
}

path "secret-mount/metadata/*" {
  capabilities = [ "list" ]
}
```

Note: If your Vault instance supports namespaces, your `AppRole` policy must exist in the same namespace as your KV engine.

## 2. Get a RoleId and SecretId

Next, follow the third step from the [Vault tutorial](https://developer.hashicorp.com/vault/tutorials/auth-methods/approle) to get a `RoleId` and `SecretId` for the role created above.

## 3. Configure Secrets Manager in Retool
Secrets management must be configured for the primary organization, and for any spaces within an organization that need to use secrets.

import MultiInstance from './_multi-instance.mdx';

For each [Retool Space](../../../org-users/tutorials/spaces), visit **Settings** > **Secrets Manager** and enter the following settings from your Vault deployment.

| Setting           | Description                                                                    | Example                                |
| ----------------- | ------------------------------------------------------------------------------ | -------------------------------------- |
| Vault URL & Port  | URL and port of your Vault server.                                             | `https://vault.mycorp.com:8200`        |
| Path to KV Engine | The name of your KV engine.                                                    | `secrets`                              |
| Role ID           | `RoleId` from Vault.                                                           | `40481de9-8281-cf4d-2056-abc5c738e392` |
| Secret ID         | `SecretId` from Vault.                                                         | `12345d5a-ead6-5f9f-c683-a571ad716668` |
| AppRole Mount     | Path at which the AppRole auth method is mounted. This defaults to `approle/`. | `auth/approle`                         |
| Vault Namespace   | Full namespace path to the desired KV engine                                   | `ns1/ns2`                              |

Click **Test connection** to confirm Retool can connect to Vault, then click **Save**.

### Retool Namespace

The **Retool Namespace** field is a value that will be prepended to any secret names Retool looks up. For example, if all your Retool-facing secrets in Vault start with `retool/`, you might set the namespace to be `retool/` as well. If you have multiple Retool deployment instances, you can use this to resolve the same secret name in a Resource configuration to different secrets in Vault. For this reason, setting the namespace is recommended if you use [Protected Resources](../../../source-control/guides/protect/resources.mdx).

For example, if you have "development" and "production" deployment instances, you might use the following naming convention for secrets in Vault:

```
// Secrets for development
retool/dev/db_user
retool/dev/db_password

// Secrets for production
retool/prod/db_user
retool/prod/db_password
```

On your Retool development instance, you would then set the namespace to `retool/dev`, and on your production instance to `retool/prod`. You can then reference secrets for either deployment instance using `{{ secrets.db_user }}` and `{{ secrets.db_password }}`, and Retool will fetch the appropriate secret at runtime.

import ConfigCheck from './_config-check.mdx';

## 4. Use secrets in resources

After you save your Secrets Manager configuration in Retool, if you granted Retool the `read` capability for the metadata, available secrets appear on **Settings** > **Secrets Manager**.

You can reference them in Resource configurations using template syntax, e.g. `{{ secrets.name.key }}` or `{{ secrets['name'].key }}`, either by copying values from the **Reference** column, or with autocomplete on the Resource configuration page.

You can access JSON keys with `{{ secrets.name.key }}` or `{{ secrets['name']['key'] }}`. You can access arbitrary levels of nested keys in your secrets. Note that keys will not autocomplete.

:::info

If your secret values are not quoted, you may need to wrap the template string in quotes in resource configurations.

For example, given an unquoted secret (`secret-value`) for the key `key_name`, you'd use `"{{ secrets.key_name.key }}"`. Given a quoted secret (`"secret-value"`), you'd use `{{ secrets.key_name.key }}`.

:::

When you rotate secrets in Vault, Retool automatically reads updated values from your secrets manager. This means you don't need to restart your Retool instance or update any configuration when rotating secrets.

## Time to live (TTL) setting

Retool caches secrets it fetches with a configurable time to live. This reduces API calls to your secrets manager, which keeps queries fast and reduces costs.
However, this means secrets may become temporarily "stale" when they are rotated. You can update **Cache TTL (ms)** in **Settings** > **Secrets Manager** to minimize failed queries in the event that a secret is rotated.

## Security considerations

Any user that can configure resources can use secrets in resources. This could lead to inappropriate uses of secrets. You can restrict the `list` capability in Vault to mitigate the risk.

---

## Self-hosted Retool secrets management guides

import DocCardList from "@theme/DocCardList";

---

## Configure multiple Secrets Manager configurations

import EnterpriseRequirement from "../../_partials/_enterprise-plan-requirement.mdx";

You can create multiple [Secrets Manager](./index.mdx) configurations if you need to retrieve secrets from different locations.

## Enable the multiple configurations beta

Multiple configurations for Secrets Manager is currently in public beta. Admins can enable this functionality from the **Beta** page in your Retool organization's settings.

## Create additional configurations

You configure additional secrets managers using the same options as a single configuration. You can add multiple configurations for any supported secrets manager provider.

Click **Add Secrets Manager** and then select the configuration to create. You then provide the required settings based on whether you are configuring [AWS](./aws.mdx), [HashiCorp Vault](./hashicorp-vault.mdx), or [Google Cloud Platform](./gcp.mdx).

Each configuration requires a unique string identifier (e.g., `vault_2`) so that it can be referenced across Retool.

Multiple configurations.

## Reference secrets from different configurations

How you reference secrets with multiple configurations is slightly different once you start using multiple configurations, as each configuration's identifier must now also be included in the `{{ }}` expression.

```text title="Reference multiple configurations"
{{ secrets['CONFIGURATION_NAME']['KEY_NAME']}}

{{ secrets['gcp_1']['secret3'] }}
{{ secrets['aws_1']['secret3'] }}
{{ secrets['vault_1']['secret3'] }}
```

Reference secrets from different configurations.

## Select a different default configuration

Once you add a configuration, the previous secrets manager you configured is automatically set as the default. Any existing secrets references that don't include the configuration name are parsed as aliases that point to the default configuration.

For example, if the default configuration is named `gcp_1`, you can reference a secret named `secret_1` using either:

- `{{ secrets['secret_1'] }}`
- `{{ secrets['gcp_1']['secret_1'] }}`

If necessary, you can select a different configuration to operate as the default from the **Secrets Manager** settings page. Click  to view options for the configuration and set it to the default.

If you change the default configuration to `aws_1` but currently use `{{ secrets['secret_1'] }}`, this would then point to  `{{ secrets['aws_1']['secret_1'] }}`.

:::warning

Changing the default configuration will cause any existing alias references—without the configuration identifier—to point to the newly selected default, and potentially break existing usage. Before you make changes, ensure you verify all existing references to secrets so they include the configuration name.
:::

---

## Configure and migrate to an external database

import EnterpriseRequirement from "../_partials/_enterprise-plan-requirement.mdx";

For non-production and development purposes, the default Docker Compose configuration for Self-hosted Retool includes a PostgreSQL container and does not set up SSL. This is not suitable for production use cases and you must host the Retool Storage database on an external, managed PostgreSQL database. Managed databases are more maintainable, scalable, and reliable than containerized PostgreSQL instances.

If you originally deployed an instance using the default PostgreSQL container, you can migrate its data to an external PostgreSQL database before using the instance in production.

## Prerequisites

Before migrating, ensure that your architecture meets the following recommendations and requirements:

- The minimum recommended version for the PostgreSQL database is version 13. Your PostgreSQL database must also enable the [uuid-ossp](https://www.postgresql.org/docs/current/uuid-ossp.html) module and use the Read Committed [isolation level](https://www.postgresql.org/docs/current/transaction-iso.html).
- Retool recommends allocating at least 60GB of [storage](../reference/requirements.mdx) when you set up a new Retool instance. If you're migrating an existing instance, you might need more space.
- The Retool PostgreSQL database user must have superuser privileges on the `hammerhead_production` database. This is necessary to perform essential tasks, such as installing updates.

import Tables from '../_partials/_postgres-tables.mdx';

## 1. Export data from Retool's Docker container

To export data from Retool's PostgreSQL container, run the following command on the virtual machine hosting the Retool containers, in the Retool directory.

```shell
docker compose exec postgres \
 pg_dump hammerhead_production --no-acl --no-owner --clean \
 -U  retool_internal_user -f retool_db_dump.sql
```

This dumps the data into a file named `retool_db_dump.sql` in the root of the volume used by the Retool PostgreSQL container.

To export data to your host machine, run the following command.

```shell
docker compose exec postgres \
  pg_dump hammerhead_production --no-acl --no-owner --clean \
  -U  retool_internal_user > retool_db_dump.sql
```

## 2. Migrate the data to an external hosted database

:::tip Recommended PostgreSQL version

Retool recommends using [PostgreSQL 13.7](https://www.postgresql.org/docs/release/13.7/) for the external database.

:::

To migrate the data to an external database, run the following command. Replace `$DB_CONNECTION_URI` with the PostgreSQL connection string that connects to your externally hosted database. Make sure to [correctly format the URI](https://www.postgresql.org/docs/9.3/libpq-connect.html#AEN39692).

```shell
docker compose exec postgres \
 psql $DB_CONNECTION_URI -f retool_db_dump.sql
```

## 3. Create a user with superuser privileges

Some databases grant superuser privileges to the first user added to the database, but you should check your database's documentation to learn more. Depending on your database, you might need to create a user. Some examples include the:

- `rds_superuser` for Amazon RDS.
- `cloudsqlsuperuser` for Google Cloud SQL.
- `azure_pg_admin` Azure Database for PostgreSQL.

## 4. Configure Retool to use the external database

The `docker.env` files defines several Retool options, including which database to connect to. The lines you need to edit follow this pattern:

```shell
POSTGRES_DB=hammerhead_production
POSTGRES_USER=retool_internal_user
POSTGRES_HOST=postgres
POSTGRES_PORT=5432
POSTGRES_PASSWORD={a random string}
```

Edit those variables to correspond with the database you created. For example:

```shell
POSTGRES_DB=retooldb
POSTGRES_USER=retool_user
POSTGRES_HOST=retool.xxxxxxxxxx.us-east-2.rds.amazonaws.com
POSTGRES_PORT=5432
POSTGRES_PASSWORD=xyzabc
```

Alternatively, you can delete the five environment variables and instead specify a database connection string:

```shell
DATABASE_URL=postgres://retool_user:xyzabc@retool.xxxxxxxxxx.us-east-2.rds.amazonaws.com:5432/retooldb
```

## 5. Restart the Retool server

After updating the Retool configuration, run this command from the `retool-onpremise` directory to restart the server.

```shell
sudo docker compose up -d
```

---

## Collect self-hosted telemetry data

import EnterpriseRequirement from "../_partials/_enterprise-plan-requirement.mdx";

:::warning Requirements and limitations

This feature is in development. It is currently available for self-hosted instances deployed using [retool-helm](https://github.com/tryretool/retool-helm) 6.2.0 or above, and running the most recent [Edge](../../releases/edge/index.mdx) or [Stable](../../releases/stable/index.mdx) release.

:::

Organizations with Self-hosted deployment instances can collect telemetry data using either:

- A [Retool-provided](#configure-retool-telemetry-collector) observability agent.
- A [self-managed](#configure-self-managed-observability-agents) observability agent.

Retool's observability agent can forward data to both Retool and custom destinations. Retool also supports using your own observability agent if you prefer to have complete control over telemetry data collection.

Telemetry data collection is not enabled by default. You must configure your deployment instance to start collecting and forwarding telemetry data.

## Configure Retool telemetry collector

:::tip Improve support with health monitoring

When telemetry data is forwarded to Retool, your deployment's health is continually monitored. This allows Retool to have more insight into potential issues and improves the level of support when diagnosing issues.

:::

Use the Helm CLI or update your Helm configuration file to enable telemetry collection. This will send data to Retool by default. Set `sendToRetool` to `false` to disable this if you do not want to send data to Retool.

```shell
helm upgrade --set telemetry.enabled=true telemetry.sendToRetool.enabled=false...
```

```yaml
...
telemetry:
  enabled: true
  sendToRetool:
    enabled: false
...
```

The telemetry image uses the same release version as the main backend by default. If necessary, you can specify a version tag to use using the `image.tag` option:

```yaml
telemetry:
  image:
    tag: 3.52.0-stable
```

If set, the telemetry image is fixed to the specified tag. Retool does not recommend including a tag unless you have a specific use case.

### Collection and forwarding

The **telemetry collector** container contains two services: [grafana-agent](https://grafana.com/docs/agent) and [vector](https://vector.dev/docs). You can configure `vector` to send data to either Retool or to custom destinations.

**telemetry collector** uses a secure TLS connection with short-lived client certificates when sending data to Retool. Data is securely stored on Amazon S3 buckets in `us-west-2` and not shared with any other third-parties or subprocessors.

### Types of telemetry data

When enabled, your deployment produces the following types telemetry data:

- Container Metrics (CPU, memory, network usage)
- Retool Runtime Metrics (frontend performance, backend request counts and latency)
- Container Logs (request logs, error logs, info logs)

| Source name          |       Sent to Retool        | Description                                                                                                                                 |
| -------------------- | :-------------------------: | ------------------------------------------------------------------------------------------------------------------------------------------- |
| `metrics_statsd`     |   | Retool internal metrics. This includes frontend performance, backend request count, latency, etc.                                           |
| `metrics_statsd_raw` |   | Same as `metrics_statsd`, but without any identifying tags added by the telemetry collector.                                                |
| `metrics`            |   | All collected metrics. This includes container health metrics and all metrics from `metrics_statsd`.                                        |
| `container_logs`     |   | All logs from the containers in the Retool deployment, except `audit_logs` and `debug_logs` excluded and deployment identifying tags added. |
| `container_logs_raw` |   | All logs from the containers in the Retool deployment, without any exclusion, tagging, or other processing done.                            |
| `audit_logs`         |  | Retool audit logs which are printed to container stdout, if any. Requires the relevant config to enable that feature.                       |
| `debug_logs`         |  | Debug level logs, if any. These are separated so as to avoid accidentally forwarding high volumes of debug logs to destinations.            |

### Send telemetry data to custom destinations

Retool supports sending to any custom destination supported by Vector. Refer to the [Vector sinks reference documentation](https://vector.dev/docs/reference/configuration/sinks/) for a complete list of supported sink types and configuration.

You specify custom destinations using the `customVectorConfig` variable with `sink` configurations. Each sink must include a list of [telemetry sources](#types-of-telemetry-data) for which it forwards.

```yaml
...
telemetry:
  customVectorConfig:
    sinks: ...
...
```

### Example configuration for Datadog

The following example illustrates a telemetry configuration where data is forward to Retool and [Datadog](https://datadog.com).

```yaml
...
telemetry:
  extraEnv:
    - name: DD_AGENT_HOST
      valueFrom:
        fieldRef:
          fieldPath: status.hostIP
  customVectorConfig:
    sinks:
      # forward statsd metrics to datadog-agent port 8125
      metrics_datadog:
        address: ${DD_AGENT_HOST}:8125
        buffer:
          when_full: drop_newest
        inputs:
          - metrics_statsd_raw
        mode: udp
        type: statsd
  enabled: true
...
```

### Example configuration for Prometheus Remote Write

The following example illustrates a telemetry configuration where data is forward to Retool and a [Prometheus Remote Write](https://vector.dev/docs/reference/configuration/sinks/prometheus_remote_write/) destination.

```yaml
...
telemetry:
  customVectorConfig:
    sinks:
      metrics_prometheus:
        type: prometheus_remote_write
        endpoint: https://prometheus:8087/api/v1/write
        inputs:
          - metrics
        buffer:
          when_full: drop_newest
  enabled: true
...
```

## Configure self-managed observability agents

Configuring a self-managed agent depends on a number of factors. Use the following information to configure your agent for telemetry data collection.

### Logs

Your agent should collect logs in the same way as any other container.

#### Format

Most Retool container logs are JSON-formatted. Retool recommends configuring your log collector to parse logs as JSON first, but falling back to a simple string message format upon failure.

#### Level

Set the [`LOG_LEVEL`](../reference/environment-variables/index.mdx#log_level) environment variable if you need to adjust log volume and verbosity.

#### Debugging

If you need to troubleshoot log collection, enable debug logs with the [`DEBUG`](../reference/environment-variables/index.mdx#debug) environment variable. This will result in a very large number of logs. You should only use it for troubleshooting purposes.

### Metrics

Not all emitted metrics are currently documented while telemetry data is in development as they may change in future versions. Current metrics cover various internal Retool runtime health metrics, such as frontend performance timings, resource query timings and error rates, internal cache sizes, workflow execution rates and timings, etc.

For more information about telemetry metrics, refer to the [Temporal documentation](https://docs.temporal.io/develop/worker-performance).

#### main-backend container

Retool **backend** containers are instrumented to emit metrics in the [DogStatsD](https://docs.datadoghq.com/developers/dogstatsd/datagram_shell?tab=metrics) format. To collect these metrics, you must configure the agent with a `statsd` UDP listener which is specifically DogStatsD-aware.

Set the `STATSD_HOST` environment variable to the IP or DNS name of your agent. If your agent is using a port other than `8125` (the default for most agents), set the `STATSD_PORT` environment variable to the correct port number.

#### workflow-worker container

In addition to `statsd` metrics , the **workflow-worker** container is also instrumented to also emit Temporal SDK metrics to an OpenTelemetry (OTLP) gRPC collector. Temporal SDK metrics can help you scale your deployment to keep up with Workflows traffic by tracking metrics such as queue latency.

If necessary, set the `WORKFLOW_TEMPORAL_OPENTELEMETRY_COLLECTOR` environment variable to the address of your OTLP gRPC endpoint. For example:

```shell
WORKFLOW_TEMPORAL_OPENTELEMETRY_COLLECTOR=http://localhost:4317
```

### Tracing

Retool supports Datadog for collecting backend traces. If you use the Datadog agent, set the `DD_TRACE_ENABLED` environment variable to `true`.

In some cases, you may need to configure additional trace collection options, such as:

- Setting the trace agent hostname with the `DD_TRACE_AGENT_HOSTNAME` environment variable.
- Adjusting the sample rate with the `DD_TRACE_SAMPLE_RATE` environment variable.

Retool uses the [dd-trace](https://www.npmjs.com/package/dd-trace) library and supports all available configuration parameters.

---

## Enable Retool-managed Vectors on self-hosted deployments

import EnterpriseRequirement from "../_partials/_enterprise-plan-requirement.mdx";

Organizations with self-hosted Retool deployments must configure and enable Retool Vectors before use.

## Install dependencies

To use Retool Vectors for self-hosted deployments:

- Configure [Retool Database](retool-database.mdx) on your self-hosted deployment.
- Install [pgvector](https://github.com/pgvector/pgvector), an open-source PostgreSQL extension for similarity search, in the same database cluster as Retool Database. Ensure your `pgvector` version is compatible with your PostgreSQL version.
- If you're using Amazon RDS, you also need to run [PostgreSQL 15.2 or later](https://aws.amazon.com/about-aws/whats-new/2023/05/amazon-rds-postgresql-pgvector-ml-model-integration/).

:::warning

Make sure to use Retool Database (often the `retooldb-postgres` container), not the Retool Storage database (often `postgres`). The storage database tracks app info, users, audit logs, etc. Retool Database is a PostgreSQL database you can use in apps and workflows, and has a UI for creating and editing tables.

:::

## Verify installation

Once you have enabled Retool Database and `pgvector`, you can start using Vectors. 

To verify that `pgvector` is installed correctly and the role you are using for Retool Database can create tables, run the following SQL statement in a [query](../../data-sources/quickstarts/retool-database.mdx#query-your-data):

```sql
CREATE TABLE sample_vector_table (id serial PRIMARY KEY, embedding vector(1536));
```

## Configure environment variables

:::important

The following section is required only if your deployment is Self-hosted *and* you are using a Retool-managed AI model. If you are using a self-managed model, you can skip this section.

:::

import Partial from '../../_shared/_retool-managed-self-hosted.mdx';

## Enable Vectors

import Enable from '/docs/_shared/_enable-vectors.mdx';

## Error handling
If you are experiencing issues creating vectors, connect to Retool Database using the available [connection strings](../../data-sources/guides/retool-database/external-access). 

1. Click the  next to **Database**. 
2. Click **Connection** and copy the connection string you want to use (PSQL or Postgres).
3. Use the connection string to connect to the database created.
4. Retry creating the Vector resource in Retool.

---

## Upgrade a legacy Azure Virtual Machines deployment to support Retool Workflows

import Legacy from "../../_partials/_workflows-legacy.mdx"
import EnterpriseRequirement from "../../_partials/_enterprise-plan-requirement.mdx";

## Requirements

Your self-hosted deployment must meet the following requirements for Retool Workflows.

### VM configuration

Retool Workflows requires a Linux-based virtual machine that meets the following system requirements:

import VmConfiguration from "../../_partials/_vm-configuration.mdx";

### Retool version

import Version from "../../_partials/_workflows-legacy-version.mdx"

import Temporal from "../../_partials/_workflows-legacy-temporal.mdx"

## System architecture changes

import Architecture from "../../_partials/_architecture-diagram.mdx"

## 1. Upgrade Retool

import DockerUpdate from "../../_partials/_update.mdx";

## 2. Configure Temporal

import Docker from "../../_partials/_workflows-legacy-docker.mdx"

---

## Upgrade a legacy Docker deployment to support Retool Workflows

import Legacy from "../../_partials/_workflows-legacy.mdx"
import EnterpriseRequirement from "../../_partials/_enterprise-plan-requirement.mdx";

## Requirements

Your self-hosted deployment must meet the following requirements for Retool Workflows.

### VM configuration

Retool Workflows requires a Linux-based virtual machine that meets the following system requirements:

import VmConfiguration from "../../_partials/_vm-configuration.mdx";

### Retool version

import Version from "../../_partials/_workflows-legacy-version.mdx"

import Temporal from "../../_partials/_workflows-legacy-temporal.mdx"

## System architecture changes

import Architecture from "../../_partials/_architecture-diagram.mdx"

## 1. Upgrade Retool

import DockerUpdate from "../../_partials/_update.mdx";

## 2. Configure Temporal

import Docker from "../../_partials/_workflows-legacy-docker.mdx"

---

## Upgrade a legacy Amazon EC2 deployment to support Retool Workflows

import Legacy from "../../_partials/_workflows-legacy.mdx"
import EnterpriseRequirement from "../../_partials/_enterprise-plan-requirement.mdx";

## Requirements

Your self-hosted deployment must meet the following requirements for Retool Workflows.

### VM configuration

Retool Workflows requires a Linux-based virtual machine that meets the following system requirements:

import VmConfiguration from "../../_partials/_vm-configuration.mdx";

### Retool version

import Version from "../../_partials/_workflows-legacy-version.mdx"

import Temporal from "../../_partials/_workflows-legacy-temporal.mdx"

## System architecture changes

import Architecture from "../../_partials/_architecture-diagram.mdx"

## 1. Upgrade Retool

import DockerUpdate from "../../_partials/_update.mdx";

## 2. Configure Temporal

import Docker from "../../_partials/_workflows-legacy-docker.mdx"

---

## Upgrade a legacy Google Compute Engine deployment to support Retool Workflows

import Legacy from "../../_partials/_workflows-legacy.mdx"
import EnterpriseRequirement from "../../_partials/_enterprise-plan-requirement.mdx";

## Requirements

Your self-hosted deployment must meet the following requirements for Retool Workflows.

### VM configuration

Retool Workflows requires a Linux-based virtual machine that meets the following system requirements:

import VmConfiguration from "../../_partials/_vm-configuration.mdx";

### Retool version

import Version from "../../_partials/_workflows-legacy-version.mdx"

import Temporal from "../../_partials/_workflows-legacy-temporal.mdx"

## System architecture changes

import Architecture from "../../_partials/_architecture-diagram.mdx"

## 1. Upgrade Retool

import DockerUpdate from "../../_partials/_update.mdx";

## 2. Configure Temporal

import Docker from "../../_partials/_workflows-legacy-docker.mdx"

---

## Add Retool Workflows to a legacy Kubernetes with Helm deployment

import Legacy from "../../_partials/_workflows-legacy.mdx"
import EnterpriseRequirement from "../../_partials/_enterprise-plan-requirement.mdx";

import WorkflowsHelmRetoolManagedTemporal from "../../_partials/_workflows-helm-retool-managed-temporal.mdx"
import WorkflowsHelmSelfHostedTemporal from "../../_partials/_workflows-helm-self-hosted-temporal.mdx"
import WorkflowsHelmLocalTemporal from "../../_partials/_workflows-helm-local-temporal.mdx"

## Requirements

Your self-hosted deployment must meet the following requirements for Retool Workflows.

### VM configuration

Retool Workflows requires a Linux-based virtual machine that meets the following system requirements:

import VmConfiguration from "../../_partials/_vm-configuration.mdx";

### Retool version

import Version from "../../_partials/_workflows-legacy-version.mdx"

import Temporal from "../../_partials/_workflows-legacy-temporal.mdx"

## System architecture changes

import Architecture from "../../_partials/_architecture-diagram.mdx"

## 1. Upgrade your deployment

import Update from "../../_partials/_update-helm-retool.mdx"

## 2. Configure deployment

---

## Upgrade and configure a legacy deployment with Retool Workflows

import Legacy from "../../_partials/_workflows-legacy.mdx"

Use one of the following guides to upgrade a legacy deployment of self-hosted Retool and add support for Retool Workflows.

import DocCardList from "@theme/DocCardList";

---

## Upgrade a legacy deployment to support Retool Workflows

import Legacy from "../../_partials/_workflows-legacy.mdx"
import EnterpriseRequirement from "../../_partials/_enterprise-plan-requirement.mdx";

## Requirements

Your self-hosted deployment must meet the following requirements for Retool Workflows.

### VM configuration

Retool Workflows requires a Linux-based virtual machine that meets the following system requirements:

import VmConfiguration from "../../_partials/_vm-configuration.mdx";

### Retool version

import Version from "../../_partials/_workflows-legacy-version.mdx"

import Temporal from "../../_partials/_workflows-legacy-temporal.mdx"

## System architecture changes

import Architecture from "../../_partials/_architecture-diagram.mdx"

## 1. Upgrade your deployment 

Follow these instructions to update your Retool instance to a newer release version. 

:::caution Back up the instance before performing an update

Retool strongly recommends that you {props.url ? back up the VM : "back up the VM" } before performing an update. If you cannot complete a full backup, you should at least:

- Create a snapshot of your PostgreSQL database.
- Copy the environment variables in `docker.env` to a secure location outside of Retool.

:::

import SelfhostedLatest from "@site/src/components/SelfhostedLatest";

To update your deployment to a newer version of Self-hosted Retool:

1. Update the `Dockerfile` with the newer version number. For example: tryretool/backend:
2. If your deployment is using `CodeExecutor.Dockerfile`, update it with the same version.
3. Run `./upgrade.sh` to perform the update.

Apply the updates and restart the deployment instance. The Retool instance is temporarily stopped while the update takes place and restarts automatically. Retool recommends performing the upgrade during off-peak hours to minimize downtime for users.

## 2. Configure new and existing services

Complete the following steps to configure Temporal.

  

:::caution Egress and ingress

[code-executor](../../concepts/architecture.mdx#code-executor) must have network access to [workflows-backend](../../concepts/architecture.mdx#workflows-backend) and **Temporal**.

:::

Provision the [code-executor](../../concepts/architecture.mdx#code-executor) container using the `tryretool/code-executor-service` image. You must use the same version as `tryretool/backend`. For example:

- tryretool/backend:
- tryretool/code-executor-service:

:::caution Egress and ingress

[workflows-worker](../../concepts/architecture.mdx#workflows-worker) must have network access to [code-executor](../../concepts/architecture.mdx#code-executor), **Temporal**, [postgres](../../concepts/architecture.mdx#postgres), and [workflows-backend](../../concepts/architecture.mdx#workflows-backend).

:::

Provision the [workflows-worker](../../concepts/architecture.mdx#workflows-worker) container. This container runs `tryretool/backend` with the following environment variables:

| Variable                       | Description                                                                                                                                                                                                |
| ------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `SERVICE_TYPE`                 | Set to `WORKFLOW_TEMPORAL_WORKER`.                                                                                                                                                                         |
| `ENCRYPTION_KEY`               | Required for encrypting traffic to Retool-managed Temporal Cluster. If you've already set this, there is no need to change or update. Should be set to the same value across all services that require it. |
| `WORKFLOW_BACKEND_HOST`        | Url for endpoint of [workflows-backend](../../concepts/architecture.mdx#workflows-backend). Must include protocol (e.g., `https://workflows-backend.example.com`)                             |
| `CODE_EXECUTOR_INGRESS_DOMAIN` | Url for endpoint of `code-executor`service. Must include protocol `https://code-executor.example.com:3004`)                                                                                                |
| `DISABLE_DATABASE_MIGRATIONS`  | Set to `true`                                                                                                                                                                                              |

:::caution Egress and ingress

[workflows-backend](../../concepts/architecture.mdx#workflows-backend) must have network access to [postgres](../../concepts/architecture.mdx#postgres), **Temporal**, and [workflows-worker](../../concepts/architecture.mdx#workflows-worker).

:::

Provision the [workflows-backend](../../concepts/architecture.mdx#workflows-worker) container. This would be a container running `tryretool/backend` image with the following environment variables:

| Variable                       | Description                                                                                                                                                                                                |
| ------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `SERVICE_TYPE`                 | Set to `WORKFLOW_BACKEND`                                                                                                                                                                                  |
| `ENCRYPTION_KEY`               | Required for encrypting traffic to Retool-managed Temporal Cluster. If you've already set this, there is no need to change or update. Should be set to the same value across all services that require it. |
| `WORKFLOW_BACKEND_HOST`        | Url for endpoint of [workflows-backend](../../concepts/architecture.mdx#workflows-backend). Must include protocol (`http` or `https`)                                                                                                      |
| `CODE_EXECUTOR_INGRESS_DOMAIN` | Url for endpoint of `code-executor`service. Must include protocol (`http` or `https`)                                                                                                          |
| `DISABLE_DATABASE_MIGRATIONS`  | Set to `true`                                                                                                                                                                                              |

:::caution Egress and ingress

[api](../../concepts/architecture.mdx#api) must have network access to [code-executor](../../concepts/architecture.mdx#code-executor) and **Temporal**.

:::

Update the [api](../../concepts/architecture.mdx#api) container to include the following environment variables:

| Variable                       | Description                                                                                                                                                                                                |
| ------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `ENCRYPTION_KEY`               | Required for encrypting traffic to Retool-managed Temporal Cluster. If you've already set this, there is no need to change or update. Should be set to the same value across all services that require it. |
| `WORKFLOW_BACKEND_HOST`        | The [workflows-backend](../../concepts/architecture.mdx#workflows-backend) endpoint URL. Must include protocol (`http` or `https`)                                                            |
| `CODE_EXECUTOR_INGRESS_DOMAIN` | The [code-executor](../../concepts/architecture.mdx#code-executor) endpoint URL. Must include protocol (`http` or `https`)                                                                    |

  

If you haven't already, either sign up for [Temporal Cloud](https://cloud.temporal.io/) (if you haven't already) or spin up a [self-hosted Temporal](https://docs.temporal.io/production-deployment) cluster.

:::caution Egress and ingress

[code-executor](../../concepts/architecture.mdx#code-executor) must have network access to [api](../../concepts/architecture.mdx#api) and **Temporal**.

:::

Provision the [code-executor](../../concepts/architecture.mdx#code-executor) container using the `tryretool/code-executor-service` image. You must use the same version as `tryretool/backend`. For example:

- tryretool/backend:3.33.10-stable
- tryretool/code-executor-service:3.33.10-stable

Specify the following environment variables:

| Variable       | Description                                                                                              |
| -------------- | -------------------------------------------------------------------------------------------------------- |
| `NODE_ENV`     | `production`                                                                                             |
| `NODE_OPTIONS` | Used to specify the maximum heap size for the JavaScript v8 engine. Set to `--max_old_space_size=1024`. |

:::caution Egress

[workflows-worker](../../concepts/architecture.mdx#workflows-worker) must have network egress to [code-executor](../../concepts/architecture.mdx#code-executor), **Temporal**, and [workflows-backend](../../concepts/architecture.mdx#workflows-backend).

:::

Provision the [workflows-worker](../../concepts/architecture.mdx#workflows-worker) service. This would be a container running `tryretool/backend` w/ `SERVICE_TYPE=WORKFLOW_TEMPORAL_WORKER` and the following environment variables:

| Variable                                  | Description                                                                                                                                                                                                |
| ----------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `ENCRYPTION_KEY`                          | Required for encrypting traffic to Retool-managed Temporal Cluster. If you've already set this, there is no need to change or update. Should be set to the same value across all services that require it. |
| `WORKFLOW_BACKEND_HOST`                   | Url for endpoint of [workflows-backend](../../concepts/architecture.mdx#workflows-backend). Must include protocol (`http` or `https`)                                                                                                      |
| `CODE_EXECUTOR_INGRESS_DOMAIN`            | Url for endpoint of `code-executor`service. Must include protocol (`http` or `https`)                                                                                                          |
| `DISABLE_DATABASE_MIGRATIONS`             | Set to `true`                                                                                                                                                                                              |
| `WORKFLOW_TEMPORAL_CLUSTER_FRONTEND_HOST` | The frontend host of the Temporal Cluster.                                                                                                                                                                 |
| `WORKFLOW_TEMPORAL_CLUSTER_FRONTEND_PORT` | The port with which to connect to the Temporal Cluster. Defaults to `7233`.                                                                                                                                |
| `WORKFLOW_TEMPORAL_TLS_ENABLED`           | (Optional) Whether to enable mTLS. Required if using Temporal Cloud.                                                                                                                                       |
| `WORKFLOW_TEMPORAL_TLS_CRT`               | (Optional) The base64-encoded mTLS certificate. Required if using Temporal Cloud.                                                                                                                          |
| `WORKFLOW_TEMPORAL_TLS_KEY`               | (Optional) The base64-encoded mTLS key. Required if using Temporal Cloud.                                                                                                                                  |

:::caution Egress and ingress

[workflows-backend](../../concepts/architecture.mdx#workflows-backend) must have:

- Ingress from [code-executor](../../concepts/architecture.mdx#code-executor).
- Egress to [code-executor](../../concepts/architecture.mdx#code-executor), [postgres](../../concepts/architecture.mdx#postgres), [workflows-worker](../../concepts/architecture.mdx#workflows-worker).
:::

Provision a `workflows-backend` service. This would be a container running `tryretool/backend` w/ `SERVICE_TYPE=WORKFLOW_BACKEND` and the following environment variables:

| Variable                                  | Description                                                                                                                                                                                                |
| ----------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `ENCRYPTION_KEY`                          | Required for encrypting traffic to Retool-managed Temporal Cluster. If you've already set this, there is no need to change or update. Should be set to the same value across all services that require it. |
| `WORKFLOW_BACKEND_HOST`                   | Url for endpoint of [workflows-backend](../../concepts/architecture.mdx#workflows-backend). Must include protocol (`http` or `https`)                                                                                                      |
| `CODE_EXECUTOR_INGRESS_DOMAIN`            | Url for endpoint of `code-executor`service. Must include protocol (`http` or `https`)                                                                                                          |
| `DISABLE_DATABASE_MIGRATIONS`             | Set to `true`                                                                                                                                                                                              |
| `WORKFLOW_TEMPORAL_CLUSTER_FRONTEND_HOST` | The frontend host of the Temporal Cluster.                                                                                                                                                                 |
| `WORKFLOW_TEMPORAL_CLUSTER_FRONTEND_PORT` | The port with which to connect to the Temporal Cluster. Defaults to `7233`.                                                                                                                                |
| `WORKFLOW_TEMPORAL_TLS_ENABLED`           | (Optional) Whether to enable mTLS. Required if using Temporal Cloud.                                                                                                                                       |
| `WORKFLOW_TEMPORAL_TLS_CRT`               | (Optional) The base64-encoded mTLS certificate. Required if using Temporal Cloud.                                                                                                                          |
| `WORKFLOW_TEMPORAL_TLS_KEY`               | (Optional) The base64-encoded mTLS key. Required if using Temporal Cloud.                                                                                                                                  |

Update the existing [api](../../concepts/architecture.mdx#api) container (`SERVICE_TYPE=MAIN_BACKEND`) with the following environment variables:

| Variable                                  | Description                                                                                                                                                                                                |
| ----------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `ENCRYPTION_KEY`                          | Required for encrypting traffic to Retool-managed Temporal Cluster. If you've already set this, there is no need to change or update. Should be set to the same value across all services that require it. |
| `WORKFLOW_BACKEND_HOST`                   | [workflows-backend](../../concepts/architecture.mdx#workflows-backend) endpoint URL. Must include `http` or `https`.                                                                          |
| `CODE_EXECUTOR_INGRESS_DOMAIN`            | `code-executor` endpoint URL. Must include `http` or `https`.                                                                                                                                              |
| `WORKFLOW_TEMPORAL_CLUSTER_FRONTEND_HOST` | The frontend host of the Temporal Cluster.                                                                                                                                                                 |
| `WORKFLOW_TEMPORAL_CLUSTER_FRONTEND_PORT` | The port with which to connect to the Temporal Cluster. Defaults to `7233`.                                                                                                                                |
| `WORKFLOW_TEMPORAL_TLS_ENABLED`           | (Optional) Whether to enable mTLS. Required if using Temporal Cloud.                                                                                                                                       |
| `WORKFLOW_TEMPORAL_TLS_CRT`               | (Optional) The base64-encoded mTLS certificate. Required if using Temporal Cloud.                                                                                                                          |
| `WORKFLOW_TEMPORAL_TLS_KEY`               | (Optional) The base64-encoded mTLS key. Required if using Temporal Cloud.                                                                                                                                  |

:::caution

Retool does not recommend deploying a local Temporal Cluster alongside your Retool deployment instance. 

:::

---

## Self-hosted Retool how-to guides

import Howto from '/docs/_partials/_doctypes/_howto.mdx';
import EnterpriseRequirement from "./_partials/_enterprise-plan-requirement.mdx";

:::tip Get started with self-hosted Retool

Follow a [tutorial](./tutorial/) to deploy self-hosted Retool on your infrastructure.

:::

---

## Self-hosted Retool documentation

import EnterpriseRequirement from "./_partials/_enterprise-plan-requirement.mdx";

Organizations can deploy a self-hosted Retool instance on their own cloud infrastructure.

---

## Self-hosted Retool quickstart

import SelfhostedLatest from "@site/src/components/SelfhostedLatest";
import EnterpriseRequirement from "./_partials/_enterprise-plan-requirement.mdx";

This guide serves as an introduction to [self-hosted Retool](https://retool.com/self-hosted). It covers many of the concepts and terminology you would come across when deploying and operating a self-hosted instance of Retool. After reading this page, you should have a good understanding of self-hosted Retool.

import DocCardList from "@theme/DocCardList";

Each instance uses a distributed set of containers with services for different functions. These work together to securely run the platform within your VPN or VPC.

:::tip Learn more about self-hosted architecture

Read the [system architecture](concepts/architecture.mdx) guide to learn more about the containers, services, and dependencies for self-hosted deployment instances.

:::

import Requirements from "./_partials/_deployment-requirements.mdx";

## Requirements

### Network

Deployments must be allowed access to Retool's IP addresses or domains. If you make use of outbound firewall rules, include the following IP addresses or domains in its allowlist. These allow your deployment to connect to Retool's license check, user authentication, and usage reporting services.

import Ips from "./_partials/_ips.mdx";

import Domains from "./_partials/_domains.mdx";

Each data source you use with Retool is represented by a resource, such as APIs and external databases. Your deployment instance must have access to any of its resources to interact with data.

Refer to the [requirements](./reference/requirements.mdx) documentation for more details on network requirements.

## Architecture

Each instance uses a distributed set of containers with services for different functions. These work together to securely run the platform within your VPN or VPC.

### Containers and services

A standard deployment instance uses the following containers and services that interact with each other. The `SERVICE_TYPE` [environment variable](./reference/environment-variables/index.mdx#service_type) values determine what services a container runs.

| Container                               | Image                   | Repository                                                                                  | Services                                                       |
| --------------------------------------- | ----------------------- | ------------------------------------------------------------------------------------------- | -------------------------------------------------------------- |
| [api](#api)                             | `backend`               | [tryretool/backend](https://hub.docker.com/r/tryretool/backend)                             | `MAIN_BACKEND``DB_CONNECTOR``DB_SSH_CONNECTOR`     |
| [jobs-runner](#jobs-runner)             | `backend`               | [tryretool/backend](https://hub.docker.com/r/tryretool/backend)                             | `JOBS_RUNNER`                                                  |
| [workflows-worker](#workflows-worker)   | `backend`               | [tryretool/backend](https://hub.docker.com/r/tryretool/backend)                             | `WORKFLOW_TEMPORAL_WORKER`                                     |
| [workflows-backend](#workflows-backend) | `backend`               | [tryretool/backend](https://hub.docker.com/r/tryretool/backend)                             | `WORKFLOW_BACKEND``DB_CONNECTOR``DB_SSH_CONNECTOR` |
| [code-executor](#code-executor)         | `code-executor-service` | [tryretool/code-executor-service](https://hub.docker.com/r/tryretool/code-executor-service) | No service type.                                               |

#### api

The **api** container manages the core functionality for a Retool instance, such as:

- Frontend interactions (e.g., building apps and workflows).
- Hosting apps and workflows.
- Managing users and permissions.

import MainBackend from "./_partials/_service-main-backend.mdx";
import DbConnector from "./_partials/_service-db-connector-services.mdx";

**api** requires ingress from client interactions, such as loading an app in a browser. These are typically handled by a load balancer (e.g., nginx) which proxies the requests.

| Container                   |       Network ingress        |       Network egress        |
| :-------------------------- | :--------------------------: | :-------------------------: |
| **code-executor**           |  |  |
| **Externalized Storage DB** |  |  |
| **retooldb-postgres**       |  |  |
| **Temporal**                |  |  |
| **Resources**               |  |  |

You can replicate **api** as you scale to manage higher volumes of workflow traffic.

#### jobs-runner

The **jobs-runner** container manages background tasks, runs database migrations for Retool version upgrades, and [Source Control](../source-control/index.mdx).

import JobsRunner from "./_partials/_service-jobs-runner.mdx";

| Container                   |       Network ingress        |       Network egress        |
| :-------------------------- | :--------------------------: | :-------------------------: |
| **Externalized Storage DB** |  |  |

You must not replicate **jobs-runner**. It performs tasks and migrations that must be performed as a single container.

#### workflows-worker

The **workflows-worker** container continuously polls the Temporal Cluster for tasks required to either start or execute blocks within a workflow. It makes requests to **code-executor** to execute blocks and process results, then reports back to Temporal to continue or complete workflow execution.

import WorkflowTemporalWorker from "./_partials/_service-workflow-temporal-worker.mdx";

| Container                   |       Network ingress        |       Network egress        |
| :-------------------------- | :--------------------------: | :-------------------------: |
| **code-executor**           |  |  |
| **Externalized Storage DB** |  |  |
| **retooldb-postgres**       |  |  |
| **Temporal**                |  |  |
| **Resources**               |  |  |

You can replicate **workflows-worker** as you scale to manage higher volumes of workflow traffic.

#### workflows-backend

The **workflows-backend** container receives and processes requests from **code-executor** to process workflows. It also handles the upload of workflows logs, block results, and run status updates.

import WorkflowBackend from "./_partials/_service-workflow-backend.mdx";

| Container                   |       Network ingress        |       Network egress        |
| :-------------------------- | :--------------------------: | :-------------------------: |
| **code-executor**           |   |  |
| **Externalized Storage DB** |  |  |
| **retooldb-postgres**       |  |  |
| **Temporal**                |  |  |
| **Resources**               |  |  |

You can replicate **workflows-backend** as you scale to manage higher volumes of workflow traffic.

#### code-executor

The **code-executor** container executes single block runs from the Workflows IDE, multiple blocks as part of a workflow execution, and any arbitrary user code written in a workflow. It executes JavaScript and Python code directly, or makes requests to **workflows-backend** to run resource queries against databases, APIs, etc.

By default, the **code-executor** uses [nsjail](https://github.com/google/nsjail) to sandbox code execution. [nsjail](https://github.com/google/nsjail) requires [privileged](https://docs.docker.com/reference/cli/docker/container/run/#privileged) container access. If your deployment does not support privileged access, the code executor automatically detects this and runs code without sandboxing.

| Container             |       Network ingress        |        Network egress        |
| :-------------------- | :--------------------------: | :--------------------------: |
| **api**               |   |  |
| **workflows-backend** |  |   |
| **workflows-worker**  |   |  |

You can replicate **code-executor** as you scale to manage higher volumes of workflow traffic.

#### retooldb-postgres

You can optionally [configure your deployment to use Retool Database](guides/retool-database.mdx) with a separate PostgreSQL database. You can use `retooldb-postgres` to get started but Retool recommends you migrate to an externally hosted database for use in production.

### Other dependencies

Self-hosted deployment instances have additional dependencies.

#### Externalized storage database

Your deployment must be able to connect to the externalized PostgreSQL database and have access to it.

#### Resources

Each data source you use with Retool is represented by a resource, such as APIs and external databases. Your deployment instance must have access to any of its resources to interact with data.

import Temporal from "./_partials/_temporal-info.mdx";

### Temporal

import TemporalInfo from "./_partials/_temporal-info.mdx";

import TemporalCompare from "./_partials/_temporal-compare.mdx";

### Docker images

Retool uses Docker images that configure the containers and their respective services. Each container runs one or more services to distribute functionality. This approach allows for efficient scaling of a Retool deployment instance as needs grow.

Retool maintains two image repositories on [Docker Hub](https://hub.docker.com/u/tryretool):

- The [backend](https://hub.docker.com/r/tryretool/backend) image is used for most containers and services.
- The [code-executor-service](https://hub.docker.com/r/tryretool/code-executor-service) image is used to execute blocks of code in Retool Workflows.

Each Docker Hub repository tag corresponds to a particular version of Retool. You specify the version to use when deploying or upgrading a release. For instance:

- 
    tryretool/backend:
    
  
- 
    tryretool/code-executor-service:
    
  

## Releases

Retool maintains two release channels for self-hosted Retool: [Stable](../releases/stable/index.mdx) and [Edge](../releases/edge/index.mdx).

import Stable from "../releases/_partials/_stable.mdx";
import Edge from "../releases/_partials/_edge.mdx";

---

## Authentication environment variables

import EnterpriseRequirement from "../../_partials/_enterprise-plan-requirement.mdx";

Authentication environment variables available for use with [Self-hosted Retool](../../index.mdx) deployments.

import Disclaimer from "./_disclaimer.mdx";

---

## Code executor environment variables

import EnterpriseRequirement from "../../_partials/_enterprise-plan-requirement.mdx";

**code-executor** environment variables available for use with [Self-hosted Retool](../../index.mdx) deployments. You should only set these environment variables on containers running [`tryretool/code-executor-service`](https://hub.docker.com/r/tryretool/code-executor-service/tags) images.

import Disclaimer from "./_disclaimer.mdx";

---

## Cookies environment variables

import EnterpriseRequirement from "../../_partials/_enterprise-plan-requirement.mdx";

Cookies environment variables available for use with [Self-hosted Retool](../../index.mdx) deployments.

import Disclaimer from "./_disclaimer.mdx";

---

## General environment variables

import EnterpriseRequirement from "../../_partials/_enterprise-plan-requirement.mdx";

General environment variables available for use with [Self-hosted Retool](../../index.mdx) deployments.

import Disclaimer from "./_disclaimer.mdx";

---

## Environment variables reference

Environment variables control or override certain functions and characteristics of [Self-hosted Retool](../../index.mdx) instances. Some Retool features require you to set environment variables, such as [SSO](../../../sso/index.mdx) or [Source Control](../../../source-control/index.mdx).

import Disclaimer from "./_disclaimer.mdx";

---

## Logging environment variables

import EnterpriseRequirement from "../../_partials/_enterprise-plan-requirement.mdx";

Logging-related environment variables available for use with [Self-hosted Retool](../../index.mdx) deployments.

import Disclaimer from "./_disclaimer.mdx";

---

## Mobile environment variables

import EnterpriseRequirement from "../../_partials/_enterprise-plan-requirement.mdx";

Environment variables related to Retool Mobile.

import Disclaimer from "./_disclaimer.mdx";

---

## Queries environment variables

import EnterpriseRequirement from "../../_partials/_enterprise-plan-requirement.mdx";

Queries environment variables available for use with [Self-hosted Retool](../../index.mdx) deployments.

import Disclaimer from "./_disclaimer.mdx";

---

## Redis environment variables

import EnterpriseRequirement from "../../_partials/_enterprise-plan-requirement.mdx";

Redis environment variables available for use with [Self-hosted Retool](../../index.mdx) deployments.

import Disclaimer from "./_disclaimer.mdx";

---

## Resources environment variables

import EnterpriseRequirement from "../../_partials/_enterprise-plan-requirement.mdx";

Resources environment variables available for use with [Self-hosted Retool](../../index.mdx) deployments.

import Disclaimer from "./_disclaimer.mdx";

---

## Source Control environment variables

import EnterpriseRequirement from "../../_partials/_enterprise-plan-requirement.mdx";

Source Control environment variables available for use with [Self-hosted Retool](../../index.mdx) deployments. You can also set these variables from the [Source Control settings page](https://login.retool.com/auth/login?redirectOnLogin=settings/source-control) or with the [Retool API](https://docs.retool.com/api).

import Disclaimer from "./_disclaimer.mdx";

---

## Storage database environment variables

import EnterpriseRequirement from "../../_partials/_enterprise-plan-requirement.mdx";

Storage database environment variables available for use with [Self-hosted Retool](../../index.mdx) deployments.

import Disclaimer from "./_disclaimer.mdx";

---

## Workflows environment variables

import EnterpriseRequirement from "../../_partials/_enterprise-plan-requirement.mdx";

Workflow environment variables available for use with [Self-hosted Retool](../../index.mdx) deployments. These environment variables specifically can be applied to the `api`, `workflows-worker`, and `workflows-backend` [services](../../concepts/architecture.mdx#containers-and-services).

import Disclaimer from "./_disclaimer.mdx";

---

## Self-hosted Retool glossary

import SharedGlossary from '../../_partials/_glossary.mdx';
import EnterpriseRequirement from "../_partials/_enterprise-plan-requirement.mdx";

---

## Self-hosted Retool requirements

import EnterpriseRequirement from "../_partials/_enterprise-plan-requirement.mdx";

Deploying [Self-hosted Retool](https://retool.com/self-hosted/) on your own infrastructure lets you build applications with data in your virtual private cloud (VPC) or behind your virtual private network (VPN). Businesses in the healthcare and finance industries often deploy Retool to remain compliant.

import Requirements from '../_partials/_deployment-requirements.mdx';

## Network requirements

[Retool Self-hosted](../index.mdx) organizations must ensure that their deployments allow access to Retool's IP addresses or domains. If you make use of outbound firewall rules, include the following IP addresses or domains in its allowlist. These allow your deployment to connect to Retool's license check, user authentication, and usage reporting services.

import Ips from '../_partials/_ips.mdx';

import Domains from '../_partials/_domains.mdx';

:::info
Egress is required when using Retool-managed Temporal. Refer to the [Egress](../concepts/temporal#egress) section of the [Temporal](../concepts/temporal) conceptual guide for more information. 
::: 

### HTTP proxy connections

Retool supports connections to the internet through a HTTP proxy. Add `HTTP_PROXY=http://example.com:8080` to your deployment's `docker.env` file with the required URL and port number.

### License checks

Retool uses HTTP to connect to `licensing.tryretool.com` on port `443` to verify your license. License checks are made at least once a day.

### Inviting users

Retool connects to `invites.tryretool.com` and `email-service.retool.com` on port `443` when inviting users. Retool verifies the users are authorized under your current billing plan, and then sends an invite to their email address.

### Usage reporting

Retool sends application usage information to `p.tryretool.com` on port `443`, which is used to inform product decisions.

#### Usage categories

The categories of usage information sent to Retool includes, but is not limited to, the following:

- Page views, along with the page URL.
- Query saves, including the query name and type.
- Component creation and the component type.
- Query preview, including the query name and type.
- Adding a resource, including the resource name and type.

Events are also sent with the hostname, public IP address, browser user-agent string, and the user's email address.

## Retool AI

Self-hosted customers can deploy and embed Retool AI within apps and workflows. When a user performs any action with Retool AI, the input is shared with the applicable third-party LLM provider, listed in our [Subprocessors](https://docs.retool.com/legal/subprocessors) page. Inputs are deleted within 30 days.

You can configure a direct connection to a [supported AI platform](../../data-sources/concepts/models.mdx) by providing an API key. You also have the option to use a Retool-managed OpenAI connection. If enabled, AI requests are proxied through Retool The Retool-managed OpenAI connection is disabled by default. Contact your Retool account representative or our [support team](mailto:support@retool.com) to gain access.

For production use cases, we recommend you provide an API key and directly connect to an AI platform.

When Retool AI is used to build or configure a query, application, or workflow (e.g., prompting [Ask AI](../../queries/guides/ask.mdx) to help write queries), any inputs or outputs that correspond to the categories above may continue to be used to inform product improvements. Retool does not use any inputs submitted to, or outputs generated from, Retool AI that is embedded within a deployed application or workflow (e.g., text stored in [Retool Vectors](../../data-sources/quickstarts/retool-vectors.mdx)). These inputs and outputs are treated as "Customer Data" in according with the [Customer Terms of Service](https://docs.retool.com/legal/customer-terms-of-service), [Security Practices](https://docs.retool.com/legal/security), and [Data Processing Addendum](https://docs.retool.com/legal/dpa).

---

## Temporal environment variables for local clusters

import EnterpriseRequirement from "../_partials/_enterprise-plan-requirement.mdx";

Self-hosted organizations can configure the following Temporal environment variables if they want to use a local cluster. These environment variables are relevant only if all the following are true for your organization:

- Does not use Kubernetes for self-hosted deployments.
- Did not use Retool's Helm charts when deploying a self-hosted instance.
- Uses Retool's Temporal image.
- Will use a PostgreSQL database as the backing store for Temporal.

:::warning

Temporal environment variables are only used to configure a local Temporal Cluster. These variables are managed by Temporal and function separately from Retool's environment variables.

:::

---

## Self-hosted Retool reference

import Reference from '/docs/_partials/_doctypes/_reference.mdx';
import EnterpriseRequirement from "./_partials/_enterprise-plan-requirement.mdx";

:::tip Get started with a self-hosted Retool deployment

If you are unfamiliar with deploying self-hosted Retool want to get started, read the [quickstart](./quickstart) to learn about the fundamental concepts.

:::

---

## _callout

:::info
Retool-managed, self-hosted deployments are available for invoiced customers. Contact your Retool account manager to learn more.
:::

---

## Retool-managed deployment architecture

import Callout from "../_callout.mdx";
import EnterpriseRequirement from "../../_partials/_enterprise-plan-requirement.mdx";

A self-hosted and Retool-managed _deployment_ is a customer-owned VPC that's hosted on [Amazon Web Services](https://aws.amazon.com) (AWS) and contains a [self-hosted](../../index.mdx) instance. You retain full ownership of, and control over, your data, encryption keys, access, and network infrastructure.

## Infrastructure layers

A Retool-managed, self-hosted deployment consists of two _infrastructure layers_ that operate on a dedicated AWS account.

- The [support](#support-layer) layer: The foundation of a Retool-managed, self-hosted deployment.
- The [services](#services-layer) layer: The resources needed by the self-hosted instance.

You have full ownership and control over every aspect of the deployment. Retool only has access to what's required for managing the self-hosted instance.

### Support layer

The support layer represents the dedicated VPC, resources, and configuration necessary for the deployment. It includes:

| Resource                              | Description                                                                                                                    |
| ------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------ |
| VPC                                   | The environment that contains the Runner VM and Retool-managed self-hosted instance.                                           |
| AWS Secrets Manager                   | The resource in which secrets and environment variables are stored.                                                            |
| Runner VM                             | The service that allows Retool to manage the self-hosted instance without having access to your larger infrastructure or data. |
| IAM roles and policies                | The resources that govern the scope of access granted to the Runner VM for Retool.                                             |
| DNS and private network configuration | Resources related to routing user traffic to the VPC.                                                                          |

Retool cannot directly access nor manage any resources within the support layer, and works with you to create them. To ensure that the resources are configured exactly as intended, Retool uses an Infrastructure as Code approach; a CloudFormation template is provided to your AWS admin that automatically provisions and configures the VPC, Runner VM, and IAM resources.

#### Secrets and environment variables

[AWS Secrets Manager](https://aws.amazon.com/secrets-manager/) is used to securely store secrets and [environment variables](../../reference/environment-variables/index.mdx) needed for the deployment. Resources needing to use these values retrieves them directly from Secrets Manager, to which Retool has no access.

For instance, your AWS admin adds the following secrets to Secrets Manager which are required by the CloudFormation template:

- Retool Encryption Key
- Retool JWT Secret

:::tip

Unless you are migrating from an Retool Cloud to a BYOC instance, the Retool encryption key and JWT secret values can be randomly generated. Retool recommends using `openssl rand -base64 32`. Customers who are migrating from Retool Cloud are provided values to use instead.

:::

Using Secrets Manager for environment variables also allows customers to make changes to update their instance configuration without directly modifying it.

#### Runner VM

The _Runner VM_ is a dedicated virtual server that operates within the VPC and functions as an agent for Retool's management services. It allows Retool to manage the instance without the need for broader access to your cloud environment. The Runner VM receives instructions from Retool—such as performing an update—and then executes them on the Retool-managed, self-hosted instance.

Any temporary disruption to the Runner VM does not impact the instance itself. If the Runner VM is unavailable, Retool loses access, and cannot remotely monitor or manage the instance.

#### IAM roles and policies

The Runner VM requires access that's managed using IAM roles and policies. These are used to securely manage Retool's access, prevents any escalation of privileges, and any configuration changes that might compromise the scope of access.

The Runner VM depends on three IAM roles to function correctly and have sufficient access to Retool-managed, self-hosted resources.

| Role        | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| ----------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Provision   | Used at initial setup time, primarily to create new resources. The customer disables this role after initial setup is complete for maximum data security.                                                                                                                                                                                                                                                                                                     |
| Maintenance | Used after setup for the lifetime of the Retool-managed, self-hosted instance. This role is typically used to perform `GET` or `describe-action` to monitor the health of the instance. The Runner VM may also need to create or delete resources as part of ongoing maintenance. This role is subject to tighter restrictions that prevent access to customer data. This role is subject to additional restrictions that prevent access to customer data and credentials. |
| Deprovision | Used to delete all cloud resources if the customer has decommissioned their instance. This role can remain disabled and only enabled if needed.                                                                                                                                                                                                                                                                                                          |

#### DNS and private network configuration

Once your instance is ready, you configure DNS records for your users to have access. This is an action you perform with your DNS provider after both the CloudFormation stack and instance are set up.

Retool supports additional private network options, such as VPC PrivateLink and VPN user access. While supported, Retool can only provide guidance—customers are responsible for the configuration and maintenance of any custom network configuration.

### Services layer

The services layer contains required and optional resources for the self-hosted instance, most of which are managed by Retool. This is created and managed by Retool for you, via the Runner VM. Retool cannot directly access any resources within the services layer. The Runner VM is also used by Retool to interact with the resources of the service layer.

| Resource                        | Description                                               |
| ------------------------------- | --------------------------------------------------------- |
| EKS cluster                     | Kubernetes pods and services.                             |
| RDS PostgreSQL database (main)  | PostgreSQL database for the storage of metadata.          |
| Application Load Balancer (ALB) | Network traffic management and distribution.              |
| Route53 DNS zones and records   | DNS configuration for the instance (e.g., Retool Spaces). |

#### EKS cluster

The Retool-managed, self-hosted instance uses an [Amazon Elastic Kubernetes Service](https://aws.amazon.com/eks/) (Amazon EKS) cluster that operates within the dedicated VPC.

#### PostgreSQL database

The main database in which Retool stores metadata uses [Amazon RDS for PostgreSQL](https://aws.amazon.com/rds/postgresql/).

#### Route53 DNS zones

Retool uses an [Amazon Route53](https://aws.amazon.com/route53/) publicly hosted zone to manage DNS records within the deployment. This includes:

- TLS certificate validation records.
- Application Load Balanceer (ALB) alias records.
- Wildcard records for [Retool Spaces](../../../org-users/tutorials/spaces.mdx).

This hosted zone is scoped to the custom domain used for the instance.

## Configuration options

:::note
Retool only supports the available configuration options listed below and cannot substitute them with alternatives.
:::

Retool uses a standard deployment configuration by default that's suitable for most use-cases. You can also customize certain configuration options to best suit your needs.

- **Standard**: A configuration option that's used by default if you do not request an available custom configuration option.
- **Available**: A configuration option that's not used by default but can be enabled upon request.
- **Custom**: An alternative configuration option that's available for use upon request.

Although custom configuration options are available, Retool cannot support, access, or manage any external infrastructure they use. For instance, you can request that your deployment only be accessible by VPN but Retool cannot implement nor manage the VPN for you.

Some custom options can only be configured to deployment while others are available for use at any time. Unless otherwise stated, you must configure and manage any custom configuration options you request.

### DNS

Configuration options for managing DNS records of the deployment.

| Option                                                                                                                         | Description                                                                                                                                                                                                                                                                     |
| ------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| NS record delegation Standard                                              | DNS for the deployment domain is delegated using NS records. Supports automatic certificate renewal and subdomain support for Spaces.                                                                                                                                           |
| Direct Application Load Balancer and certificate validation records Custom | Individual DNS records are configured to provide more granular control, such as support for Web Application Firewall (WAF) policies. DNS records for certificate renewal are also configured. Retool can provide guidance but you must configure and manage this configuration. |

### Ingress

Configuration options for managing user access to the deployment.

| Option                                                                                                | Description                                                                                                                                                                                                                                |
| ----------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| Retool-managed Application Load Balancer Standard | Publicly accessible ALB that handles internal and external traffic.                                                                                                                                                                        |
| Customer-managed Application Load Balancer Custom | ALB with custom configuration, such as Web Application Firewall (WAF) policies. Retool-managed, self-hosted deployments include a `byolb` ALB target group by default for which Retool can provide guidance but you must configure and manage this configuration. |
| Customer-managed VPN Custom                       | Accessible only through a VPN connection. Retool can provide guidance but you must configure and manage all aspects of the VPN connection between the user and the deployment.                                                        |

### Egress

Configuration options for managing how the deployment accesses external resources (e.g., cloud-hosted data sources).

| Option                                                                                             | Description                                                                                                                                                                                                                                 |
| -------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Public internet egress Standard                | Unrestricted internet access for connecting to any publicly reachable resource.                                                                                                                                                            |
| Static IP address pool for allowlists Standard | Retool connects to resources using a pool of [static IP addresses](../../../data-sources/reference/ip-allowlist-cloud-orgs.mdx) that can be added to allowlists.                                                                               |
| SSH tunnelling Standard                        | Connect to private resources using [SSH tunnels](../../../data-sources/guides/connections/ssh-tunnels.mdx).                                                                                                                             |
| VPN access Custom                              | Connect to private resources using a VPN. Retool can provide guidance but you must configure and manage all aspects of the VPN connection between the deployment and private resources.                                                       |
| VPC PrivateLink Custom                         | Private connection between the deployment's VPC and another VPC using [AWS PrivateLink](https://aws.amazon.com/privatelink/). Retool can provide guidance but you must configure and manage all aspects of the PrivateLink connection. |

### Storage database and fault tolerance

Configuration options that apply to the main PostgreSQL database of the Retool-managed, self-hosted instance. Any customization must be requested prior to setup.

| Option                                                                                                                                                     | Description                                                              |
| ---------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------ |
| Single-availability zone Standard                                                                      | A single, non-replicated RDS database used for metadata.                 |
| Multi-availability zone Available Configured pre-deployment | A fault-tolerant RDS database that's replicated across multiple regions. |

### Optional Retool features

Configuration options for features not enabled by default. Retool can enable, configure, and manage these features for you at any time. These features require additional resources which may incur additional AWS costs.

| Option                                                                                         | Description                                                                                                                                    |
| ---------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------- |
| Retool Database Available                     | Requires an additional [RDS database](https://aws.amazon.com/rds/) that you provision using Retool-provided information.                                                      |
| Retool Storage Available                      | Requires an [Amazon S3](https://aws.amazon.com/s3/) bucket. You can use an existing bucket or provision a new one using Retool-provided information.                         |
| Retool RPC Available                          | Requires an [Amazon ElastiCache](https://aws.amazon.com/elasticache/) for Redis resource that you provision using retool-provided information. |
| Collaborative editing (Multiplayer) Custom | No additional resources required and can be enabled upon request.                                                                              |

:::info
Retool always assumes that these services contain sensitive data. To maintain the security boundary that separates Retool from your wider infrastructure and data, Retool is prevented from accessing them.
:::

---

## Retool-managed deployment health monitoring and scaling

import Callout from '../_callout.mdx';
import EnterpriseRequirement from "../../_partials/_enterprise-plan-requirement.mdx";

Retool monitors the health of a Retool-managed, self-hosted instance 24/7 and is automatically alerted of any potential issues that may arise. This coverage includes:

- Containers (e.g., upgrade errors or misconfiguration)
- Error log spikes (e.g., functionality degredation, capacity limits)
- Databases (e.g., Amazon RDS storage or resource usage)

:::info
Health monitoring only applies to infrastructure of the Retool-managed, self-hosted instance. Refer to the [observability](../../../apps/guides/observability/index.mdx) documentation to learn how you can monitor object-level errors for apps, workflows, and more.
:::

## Alerts and response

Retool immediately reviews any alert that is triggered. If the alert requires remediation, a Retool engineer begins to diagnose the issue. If necessary, the engineer then takes any action to resolve the issue that triggered the alert.

Alerts can be triggered for any number of reasons so not every alert requires remediation. In the event that an alert did require a Retool engineer to take action, you're notified of what occurred within one business day.

:::note
Observability data is configured for use only by Retool and cannot be shared with customers.
:::

## Deployment scaling

Retool-managed, self-hosted deployments can scale as your needs grow. How it scales depends on its usage. You can contact Retool at any time to discuss scaling options. Retool will also proactively reach out if your deployment is reaching any limits.

### RDS database size

The RDS PostgreSQL database starts with 40GB of storage. It automatically increases in size as needed, up to the default limit of 200GB. Retool can raise the limit at any time upon request. There is no downtime whenever the database increases in size or the limit is raised.

The database only increases in size automatically. If the amount of data it contains is reduced, it does not scale down.

### RDS instance type

The RDS CPU and memory resources are determined by its instance type. The default type, `db.m6g.large`, uses 2x vCPUs and 8GiB memory. Unlike the RDS database size, CPU and memory resources do not scale automatically. Retool can upgrade—or downgrade—the instance type upon request. Retool also proactively monitors the instance and will recommend changes if they are deemed necessary.

:::warning
Changes to the RDS instance type require downtime. They should only be performed during a regularly scheduled maintenance period.
:::

### Backend containers and resources

Retool automatically scales the Retool-managed, self-hosted instance to ensure that it has sufficient capacity for the amount of traffic it needs. This includes making adjustments to the number and type of containers in use.

The default capacity for a Retool-managed, self-hosted instance is 20 queries per second (QPS). The resources required by your instance is dependent on your use case. If you require resources for a high volume of traffic, or if you expect an influx of traffic, contact your Retool account manager for guidance on scaling and preparation.

---

## Retool-managed deployment security

import Callout from "../_callout.mdx";
import EnterpriseRequirement from "../../_partials/_enterprise-plan-requirement.mdx";

Retool is only provided with sufficient access to a Retool-managed, self-hosted instance while being restricted from the customer's data and infrastructure. This limited access ensures that your data remains private while enabling Retool to successfully manage your instance.

## Remote access model

The [Runner VM](./architecture.mdx#runner-vm) is a _local agent_ that operates within the customer's AWS environment. Retool connects remotely to the Runner VM—with no access to any other customer infrastructure—for the sole purpose of managing the deployment.

## Access restrictions

Retool uses _deny-based_ access policies to restrict access only to the required infrastructure. To do this, the instance is deployed to a dedicated AWS account and Retool's access is restricted based on the following scopes.

| Scope                | Description                                                                                                                                                                    |
| -------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| User access          | No user access to the Retool application by default. Access can only be explicitly granted by the customer using a support user account.                                       |
| App-level secrets    | No access to encryption keys for sensitive database columns (e.g., resource credentials and SSO secrets), JWT signing keys, and customer-provided deployment secrets.          |
| Data storage access  | No access to customer data stores (e.g., Amazon RDS databases or Amazon S3 buckets).                                                                                                         |
| Privilege management | Identity and Access Management (IAM) policies prevent certain types of privilege escalation that could compromise Retool's deny-based access policies (e.g., creation of IAM roles with additional privileges). |

:::tip
In some cases, Retool may request temporary elevated privileges within the customer's environment for the purpose of issue resolution. This request is made only if absolutely necessary and there are no other options to use. The customer has full control over any request and the granting of elevated privileges.

:::

## Externally processed data

A Retool-managed, self-hosted deployment instance emits certain types of data outside the customer's environment for specific operational purposes.

| Data                  | Description                                                                                                                                                    |
| --------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Usage and user events | Analytics about Retool feature usage and user events, such as signing in.                                                                                      |
| Pricing and metering  | Information related to your organization's pricing and metering, such as user count.                                                                           |
| Infrastructure health | Observability metrics about the health of the instance. This does not include any customer data or personally identifiable information (PII)              |
| Temporal              | Temporal metadata Encrypted metadata processed in Temporal Cloud for workflow coordination. This does not include the contents of code blocks and run outputs. |
| Alerts                | System alerts and notifications, such as administrative alerts and user invites.                                           |

---

## Retool-managed deployment concept guides

import Concept from '/docs/_partials/_doctypes/_concept.mdx';
import EnterpriseRequirement from "../_partials/_enterprise-plan-requirement.mdx";

---

## Configure Retool-managed deployment secrets and environment variables

import Callout from "../_callout.mdx";
import EnterpriseRequirement from "../../_partials/_enterprise-plan-requirement.mdx";

Depending on your use case, you may need to set some environment variables to [provide additional secrets](../../guides/secrets/index.mdx) or specify [environment variables](../../reference/environment-variables/index.mdx). Customers use AWS Secrets Manager to set environment variables and secrets for their Retool-managed, self-hosted instance.

## Configure in AWS Secrets Manager

You can manage environment variables and secrets in AWS Secrets Manager. This can be done using the Secrets Manager console or the [Secrets Manager API](https://docs.aws.amazon.com/sdk-for-php/v3/developer-guide/secretsmanager-examples-manage-secret.html).

1. Sign in to the [AWS Secrets Manager console](https://console.aws.amazon.com/secretsmanager).
1. Select the `deployment_secrets` secret.
1. Click **Retrieve secret value** and then **Edit**.

The `deployments_secrets` secret accepts key-value pairs, where each key corresponds to an environment variable. To add an environment variable, click **+Add row** in the **Key/value** tab.

Any changes you make are automatically applied and take effect after a few minutes.

:::tip
Deployment secrets use a consistent template for namespacing in case of multiple deployments per account.

```
${deployment_id}/${customer_name}_deployment_secrets
```
:::

---

## Retool-managed deployment how-to guides

import Howto from '/docs/_partials/_doctypes/_howto.mdx';
import EnterpriseRequirement from "../_partials/_enterprise-plan-requirement.mdx";

---

## Retool-managed deployment documentation

import Callout from './_callout.mdx';

Retool can deploy a [self-hosted](https://retool.com/self-hosted/) Retool instance on AWS and manage it for you. This provides your organization with a fully self-hosted deployment but without the overhead of setup and maintenance. You retain full ownership of, and control over, your data, encryption keys, access, and network infrastructure.

---

## Retool-managed deployment quickstart

import Callout from "./_callout.mdx";

A Retool-managed, self-hosted deployment is a customer-owned VPC hosted on [Amazon Web Services](https://aws.amazon.com) (AWS) that contains a Retool-managed [self-hosted](../index.mdx) instance. This provides your organization with a fully self-hosted deployment but without the overhead of setup and maintenance. You retain full ownership of, and control over, your data, encryption keys, access, and network infrastructure.

Retool-managed, self-hosted deployments are best suited for organizations that:

- Are unable to use Retool Cloud (e.g., compliance restrictions)
- Do not have the resources to maintain a self-hosted deployment (e.g., a limited DevOps team)

Retool uses an Infrastructure as Code approach to programmatically configure Retool-managed, self-hosted deployments. This ensures your deployment is created exactly as needed and with as little intervention as possible.

## Overview

A Retool-managed, self-hosted deployment consists of two _infrastructure layers_:

- The [support layer](#support-layer) represents the foundation of a deployment.
- The [services layer](#services-layer) represents the resources for the self-hosted instance.

You have full ownership and control over every aspect of a deployment. Retool only has access to what's required for managing the self-hosted instance.

### Support layer

The [support layer](./concepts/architecture.mdx#support-layer) represents the core resources needed for a deployment, such as:

- The VPC on which the instance runs.
- secrets used by the instance, such as encryption keys and environment variables.
- Access management configuration that governs what Retool has access to, such as IAM policies.
- External network configuration for users to access the instance, such as DNS and VPN networking.

This layer is configured in such a way that Retool can securely access the VPC to manage the self-hosted instance without access to the rest of your infrastructure or data.

Retool does not create or configure the support layer directly. This is by design to ensure that Retool has no access to your external infrastructure and data. Instead, Retool works with you to create this layer automatically with a 1-click CloudFormation template.

The VPC includes the Runner VM: a dedicated service that receives instructions from Retool—such as performing an update—and then executes them on the Retool-managed, self-hosted instance.

### Services layer

The [services layer](./concepts/architecture.mdx#services-layer) reresents the resources for the self-hosted instance, such as the Kubernetes cluster, databases, and internal network configuration. Retool manages most of these resources for you.

Retool can only interact with your instance via the Runner VM, which operates in the support layer.

## Deployment process

Retool works with you throughout the entire deployment process. In general, there are four steps to deploy the instance:

1. [Prepare for the deployment](#1-prepare-for-the-deployment). Retool works with you to prepare the right configuration for the deployment.
1. [Create the support layer](#2-create-the-support-layer). You set up the deployment's service layer on AWS using resources and guidance from Retool.
1. [Create the services layer](#3-deploy-the-services-layer). Retool creates the services layer and configures the instance.
1. [Enable access](#4-enable-access). You update the DNS configuration so network traffic can route to the instance, giving users access and completing the deployment.

A Retool-managed, self-hosted deployment can be completed within 24 hours if all information is provided and tasks completed as soon as they're needed.

### 1. Prepare for the deployment

At the beginning of the process, Retool asks you about your deployment preferences, such as:

- The AWS region in which to deploy.
- The instance domain.
- If you need to migrate from an existing instance.
- Whether you need to make any [custom configuration](./concepts/architecture.mdx#configuration-options) changes.

As part of the preparation, you create a new AWS account that's solely used for the deployment.

### 2. Create the support layer

Once preparation is complete, Retool produces a CloudFormation template for you. This is shared with your AWS admin as a 1-click install link that starts the CloudFormation stack setup on AWS.

Once your admin populates AWS Secrets Manager with encryption keys and environment variables, they use the template to perform the setup process. Once complete, the services layer can then be created.

### 3. Deploy the services layer

The Runner VM automatically creates the resources that make up the service layer, such as the EKS cluster and PostgreSQL databases. This process is fully automated using instructions provided by Retool.

### 4. Enable access

With the instance deployed and running, the final step is to configure the deployment's DNS records using the information provided by Retool so that it can be accessed by users. If you've requested additional network options for use with the instance, Retool can also provide guidance but cannot configure them directly.

## Patch updates and release upgrades

:::info
For deployments with multiple environments (e.g., staging), Retool may update these a few days prior to the production environment to avoid disruption.
:::

Retool manages all updates and upgrades for your deployment. Your instance runs the latest [stable release](../../releases/stable/index.mdx) by default and kept up-to-date with security patches.

All services used by the instance, such as Amazon RDS for PostgreSQL, follow the officially maintained or long-term support (LTS) release cycle and are kept up-to-date. This includes updating to a newer LTS release once the current one reaches its end-of-life.

## Migrate from an existing instance

Retool can help customers migrate from an existing Retool Cloud or self-hosted instance to a Retool-managed, self-hosted deployment.

Customers on the Enterprise plan with a Retool Cloud organization can request a migration to a Retool-managed, self-hosted deployment. To arrange a migration, contact your Retool account manager.

:::warning
As self-hosted migrations involve customer data, Retool can only provide guidance and cannot export or import instance data for you.

:::

Customers on the Enterprise plan with a self-hosted Retool instance can request a migration to a Retool-managed, self-hosted deployment. This is a three-part process:

1. Retool works with you to deploy a new Retool-managed, self-hosted instance but not configure DNS records.
2. You export your existing instance's storage database and restore it to the new instance.
3. Once restored, you then configure DNS records to enable access.

---

## Retool-managed deployment ownership and responsibilities

import Callout from "../_callout.mdx";
import EnterpriseRequirement from "../../_partials/_enterprise-plan-requirement.mdx";

Retool-managed, self-hosted deployments operate using a shared responsibility model. This governs whether Retool, the customer, or both are responsible for implementing or maintaining each part of the deployment.

Shared responsibility covers the _infrastructure_ and _management_ of the deployment:

- **Infrastructure**: Shared responibilities for each service of the deployment.
- **Management**: Shared responibilities for managing and maintaining each aspect of the deployment.

## Infrastructure responsibilities

| Resource                                                      | Owner    | Layer                                                   |
| ------------------------------------------------------------- | -------- | ------------------------------------------------------- |
| CloudFormation stack                                          | Customer | [Support](../concepts/architecture.mdx#support-layer)   |
| Secrets and environment variables                             | Customer | [Support](../concepts/architecture.mdx#support-layer)   |
| DNS and private network configuration                         | Customer | [Support](../concepts/architecture.mdx#support-layer)   |
| IAM roles and policies                                        | Retool   | [Support](../concepts/architecture.mdx#support-layer)   |
| VPC                                                           | Retool   | [Support](../concepts/architecture.mdx#support-layer)   |
| EKS cluster and pods                                          | Retool   | [Services](../concepts/architecture.mdx#services-layer) |
| RDS PostgreSQL database (main)                                | Retool   | [Services](../concepts/architecture.mdx#services-layer) |
| Application Load Balancer (ALB)                               | Retool   | [Services](../concepts/architecture.mdx#services-layer) |
| Certificate renewal with AWS Certificate Manager (ACM)        | Retool   | [Services](../concepts/architecture.mdx#services-layer) |
| Route53 DNS zones and records                                 | Retool   | [Services](../concepts/architecture.mdx#services-layer) |
| Amazon RDS PostgreSQL database for Retool Database (optional) | Retool   | [Services](../concepts/architecture.mdx#services-layer) |
| Amazon S3 bucket for Retool Storage (optional)                | Retool   | [Services](../concepts/architecture.mdx#services-layer) |
| ElastiCache Redis instance for Retool RPC (optional)          | Retool   | [Services](../concepts/architecture.mdx#services-layer) |

## Management responsibilities

| Responsibility                            | Owner    | Description                                                                                                                                                                                      |
| ----------------------------------------- | -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| Deployment updates and upgrades           | Retool   | [Perform security updates and scheduled release upgrades](../quickstart.mdx#patch-updates-and-release-upgrades) of self-hosted Retool.                                                           |
| Deployment health                         | Retool   | [Monitor the health](../concepts/health-monitoring.mdx) of the instance.                                                                                                                         |
| Scaling                                   | Retool   | [Scale backend resources](../concepts/health-monitoring.mdx#deployment-scaling), such as CPU, memory and storage.                                                                                     |
| Enable optional features                  | Retool   | [Configure optional Retool features](../concepts/architecture.mdx#configuration-options), such as Retool Database.                                                                               |
| Supported configuration changes           | Both     | [Configure changes](../concepts/architecture.mdx#custom-configurations) and, if necessary, create necessary data stores.                                                                         |
| Migrations                                | Both     | [Migrate an existing Retool deployment](../quickstart.mdx#migrate-from-an-existing-instance). Migration options are dependent on each situation. Contact your Retool account manager to discuss. |
| Software observability                    | Customer | [Monitoring, testing, and maintenance](../../../apps/guides/observability/index.mdx) of user-built Retool software, such as apps and workflows.                                                  |
| AWS account management                    | Customer | Manage ownership and costs related to the [AWS account](../quickstart.mdx#1-prepare-for-the-deployment).                                                                                         |
| User management                           | Customer | [Manage Retool users](../../../org-users/index.mdx) who use and build software.                                                                                                                  |
| Secrets and environment variable handling | Customer | Securely handle and store [secrets and environment variables](../concepts/architecture.mdx#secrets-and-environment-variables), such as encryption keys.                                          |
| Data sources (resources)                  | Customer | Connect your [data sources](../../../data-sources/index.mdx) for use in Retool software.                                                                                                         |
| SSO                                       | Customer | Configure [single-sign on](../../../sso/index.mdx) to authenticate users in your organization.                                                                                                   |
| Restrict access to VPC resources          | Customer | Prevent changes being made to VPC resources, such as the Amazon EKS cluster, used for the Retool instance.                                                                                       |
| Custom configuration options              | Customer | Configure and maintain any [custom configuration options](../concepts/architecture.mdx#configuration-options), such as VPN access or PrivateLink.                                                |

---

## Retool-managed deployment reference

import Reference from '/docs/_partials/_doctypes/_reference.mdx';
import EnterpriseRequirement from "../_partials/_enterprise-plan-requirement.mdx";

---

## Deploy Self-hosted Retool on Azure Virtual Machines

import Requirements from "../_partials/_requirements.mdx";
import DockerDownload from "../_partials/_docker_download.mdx";
import DockerInstall from "../_partials/_docker_install.mdx";
import DockerKey from "../_partials/_docker_encryption_key.mdx";
import DockerConfigure from "../_partials/_docker_configure.mdx";
import DockerUpdate from "../_partials/_update.mdx";
import TemporalOptions from "../_partials/_temporal-options.mdx";
import Production from "../_partials/_additional-steps.mdx";
import DockerStart from "../_partials/_docker_start.mdx";
import SelfhostedLatest from "@site/src/components/SelfhostedLatest";
import EnterpriseRequirement from "../_partials/_enterprise-plan-requirement.mdx";

You can deploy an instance of Self-hosted Retool on [Azure Virtual Machines](https://azure.microsoft.com/en-us/products/virtual-machines/) with [Docker Compose](https://docs.docker.com/compose/).

## Requirements

## System architecture

The following diagram shows the resulting system architecture for your deployment.

## 1. Create a Linux VM

Create a new Linux VM in the [Azure Portal](https://portal.azure.com/) that meets the minimum requirements. Refer to the [Azure documentation](https://learn.microsoft.com/en-us/azure/virtual-machines/linux/quick-create-portal?tabs=ubuntu) to learn how to create a new virtual machine.

| VM Setting         | Description                                                                                                                                                                                                                                                                                                                       |
| ------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Authentication** | Use **SSH public key** authentication and provide a username. Generate a new key-pair and specify a name. Azure generates and stores the key in the Azure KeyVault to download later.                                                                                                                                             |
| **Network**        | Allow SSH (`22`), HTTP (`80`), and HTTPS (`443`) inbound public ports. The VM must have a public IP address set for external access, or a private IP which allows egress traffic from [Retool's IPs](../reference/requirements.mdx#network-requirements). Ensure **Delete public IP and NIC when VM is deleted** is enabled. |
| **Storage**        | Specify **Standard SSD** with a size that meets or exceeds the minimum requirements. Ensure **Delete with VM** is enabled for the newly added data disk.                                                                                                                                                                          |

Once the VM is initialized, download the private key when prompted. Update the permissions of the key-pair to ensure it has the required permissions for your SSH client.

```shell
chmod 400 
```

## 2. Download Self-hosted Retool

Azure automatically runs the new virtual machine once created. Obtain the public IP address from the Azure Portal and connect to it using SSH.

```shell
ssh -i keypair.pem @
```

## 3. Install dependencies

## 4. Back up encryption key

## 5. Configure the instance

## 6. Start the instance

" />

## Additional configuration

## Update your Azure VM instance

---

## Deploy Self-hosted Retool with Docker

import Requirements from "../_partials/_requirements.mdx";
import DockerDownload from "../_partials/_docker_download.mdx";
import DockerInstall from "../_partials/_docker_install.mdx";
import DockerKey from "../_partials/_docker_encryption_key.mdx";
import DockerConfigure from "../_partials/_docker_configure.mdx";
import DockerUpdate from "../_partials/_update.mdx";
import TemporalOptions from "../_partials/_temporal-options.mdx";
import DockerStart from "../_partials/_docker_start.mdx";
import Production from "../_partials/_additional-steps.mdx";
import SelfhostedLatest from "@site/src/components/SelfhostedLatest";
import EnterpriseRequirement from "../_partials/_enterprise-plan-requirement.mdx";

You can deploy a non-production instance of Self-hosted Retool for testing and development on a Linux-based VM using [Docker](https://www.docker.com/).

For non-production and development purposes, the default Docker Compose configuration includes a PostgreSQL container and does not set up SSL. This is not suitable for production use cases and you must host the Retool Storage database on an external, managed PostgreSQL database.

Managed databases are more maintainable, scalable, and reliable than containerized PostgreSQL instances. Follow the instructions in the [external storage database guide](../guides/storage-database.mdx#2-migrate-the-data-to-an-external-hosted-database) to configure your database.

Should you need to start using the deployment instance in production, [migrate to an externalized PostgreSQL database](../guides/storage-database.mdx) first.

:::danger

Retool recommends using a cloud computing provider, such as [AWS EC2](ec2.mdx), [Azure Virtual Machines](azure-vm.mdx), or [Google Compute Engine](gcp.mdx). Dedicated cloud services are more robust for use in production environments and enable you to scale as your needs grow.

:::

## Requirements

To deploy Retool for non-production or development purposes using Docker, you need:

- A Retool license key, which you can obtain from the [Retool Self-hosted Portal](https://my.retool.com/) or your Retool account manager.
- Familiarity with and installations of [Docker Engine](https://docs.docker.com/engine/install/) and [Docker Compose](https://docs.docker.com/compose/).
- A compatible Linux-based virtual machine.

{props.children}

### VM configuration

Self-hosted Retool instances require a Linux-based virtual machine that meets the following requirements:

import VmConfiguration from "../_partials/_vm-configuration.mdx";

## 1. Download Self-hosted Retool

## 2. Install dependencies

## 3. Back up encryption key

## 4. Configure the instance

## 5. Start the instance

## Additional configuration

## Update your Docker instance

---

## Deploy Self-hosted Retool on Amazon EC2

import Requirements from "../_partials/_requirements.mdx";
import DockerDownload from "../_partials/_docker_download.mdx";
import DockerInstall from "../_partials/_docker_install.mdx";
import DockerKey from "../_partials/_docker_encryption_key.mdx";
import DockerConfigure from "../_partials/_docker_configure.mdx";
import DockerUpdate from "../_partials/_update.mdx";
import TemporalOptions from "../_partials/_temporal-options.mdx";
import DockerStart from "../_partials/_docker_start.mdx";
import Production from "../_partials/_additional-steps.mdx";
import SelfhostedLatest from "@site/src/components/SelfhostedLatest";
import EnterpriseRequirement from "../_partials/_enterprise-plan-requirement.mdx";

You can deploy Self-hosted Retool on Amazon EC2 with [Docker Compose](https://docs.docker.com/compose/).

## Requirements

In addition, Retool recommends you:

- Follow this guide using an [administrative, non-Root AWS user](https://docs.aws.amazon.com/accounts/latest/reference/best-practices-root-user.html).
- Manage your [service quotas](https://repost.aws/knowledge-center/manage-service-limits) for your Retool deployment's AWS Region as you scale.

## System architecture

The following diagram shows the resulting system architecture for your deployment.

## 1. Create a Linux EC2 instance

Create a new Linux EC2 instance in the [Amazon EC2 console](https://console.aws.amazon.com/ec2/) using an Amazon Machine Image (AMI) that meets the minimum requirements. Refer to the [Amazon EC2 documentation](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EC2_GetStarted.html) to learn how to create a new instance.

| VM setting         | Description                                                                                                  |
| ------------------ | ------------------------------------------------------------------------------------------------------------ |
| **Authentication** | Enable **SSH public key** authentication and provide a username. Generate a new key-pair and specify a name. |
| **Network**        | Create or use an existing security group to configure rules for SSH (`22`), HTTP (`80`), HTTPS (`443`), and Custom TCP (`3000`). The source for these rules must be `0.0.0.0/0` and `::/0`. |

Self-hosted Retool initially runs on port `3000`. Once SSL is configured, this port is no longer required.

## 2. Download Self-hosted Retool

You can connect in the [AWS console](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-connect-methods.html) using EC2 Instance Connect, or on the command line using an SSH client, with the SSH key pair you selected in your EC2 dashboard.

```bash title="Connect using SSH"
ssh -i keypair.pem @
```

## 3. Install Docker dependencies

## 4. Back up encryption key

## 5. Configure the instance

## 6. Start the instance

" />

## Additional configuration

## Update your EC2 instance

---

## Deploy Self-hosted Retool on AWS Fargate and ECS with CloudFormation

import TemporalOptions from "../../_partials/_temporal-options.mdx";
import EncryptionKey from "../../_partials/_encryption-key.mdx";
import Egress from "../../_partials/_egress.mdx";
import EnvVarsCloud from "../../_partials/_env-vars-cloud.mdx";
import EnvVarsLocal from "../../_partials/_env-vars-local.mdx";
import SelfhostedLatest from "@site/src/components/SelfhostedLatest";
import EnterpriseRequirement from "../../_partials/_enterprise-plan-requirement.mdx";

You can deploy Self-hosted Retool on AWS Fargate using CloudFormation templates. 

## Requirements

To deploy Self-hosted Retool on AWS Fargate and ECS, you need:

- A Retool license key, which you can obtain from the [Retool Self-hosted Portal](https://my.retool.com/) or your Retool account manager.
- An [AWS account](https://aws.amazon.com/marketplace/management/signin).
- An [ECS cluster](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/create-cluster-console-v2.html) with the **AWS Fargate** launch type.

## 1. Verify network configuration

The CloudFormation template you choose depends on whether you need to deploy with or without public subnets.

- Use the [public template](https://raw.githubusercontent.com/tryretool/retool-onpremise/master/cloudformation/fargate.yaml) to deploy Self-hosted Retool in VPCs *with* public subnets.
- Use the [private template](https://raw.githubusercontent.com/tryretool/retool-onpremise/master/cloudformation/fargate.private.yaml) to deploy Self-hosted Retool in VPCs *without* public subnets.

Use the [public template](https://raw.githubusercontent.com/tryretool/retool-onpremise/master/cloudformation/fargate.yaml) to deploy Retool in VPCs with public subnets. This requires the following networking components:

- One VPC with internet access.
- Two public subnets.

You use the [private template](https://raw.githubusercontent.com/tryretool/retool-onpremise/master/cloudformation/fargate.private.yaml) to deploy Retool in VPCs without public subnets. To use this installation, set up a [NAT gateway](https://repost.aws/knowledge-center/nat-gateway-vpc-private-subnet) in front of your private subnets. This requires the following networking components:

- One VPC with internet access
- Two private subnets, attached to NAT gateways

### VPC

1. Open the AWS Management Console and navigate to the VPC service to use. Copy the value of the VPC ID.
2. In the left navigation pane, select **Internet Gateways**.
3. In the list of Internet Gateways, find the Internet Gateway associated with your VPC. If there is a record in this table associated with your VPC, the VPC is public.

### Subnets

Verify that your subnets are public. Subnet IDs are required in a later step.

1. Open the AWS Management Console and navigate to the VPC service.
2. In the left navigation pane, select **Subnets**.
3. Identify at least two subnets which are part of the VPC.
4. Confirm that the subnets are public subnets. For each subnet, select the **Route table** tab. Look for an entry where the **Destination** is `0.0.0.0/0` and the **Target** is an Internet Gateway (`igw-xxxx`). If such an entry exists, the subnet is a public subnet.
5. Confirm that the subnets have auto-assign public IP addresses enabled. For each subnet, select the subnet and go to the **Details** tab in the lower pane. Look for the **Auto-assign public IPv4 address** attribute. Confirm that the value is **Yes**.

Verify that your subnets are connected to a NAT gateway. Subnet IDs are required in a later step.

1. Open the AWS Management Console and navigate to the VPC service.
2. In the left navigation pane, click on **Subnets**.
3. Identify at least two subnets which are part of the VPC.
4. Confirm that the subnets are connected to the NAT gateway. For each subnet, select the **Route table** tab. Look for an entry where the **Destination** is `0.0.0.0/0` and the **Target** is a NAT Gateway. If such an entry exists, the subnet has access to the NAT gateway.

## 2. Configure instance

:::danger Compare your existing template with the newer version

If you previously deployed Self-hosted Retool with an older version of a CloudFormation template, compare your current template with the new one. If the `RetoolRDSInstance` object has changed, this could delete your current database instance.

:::

Download the private CloudFormation template for either **ECS on Fargate** or **ECS on EC2** from the [Self-hosted Retool GitHub repository](https://github.com/tryretool/retool-onpremise). Both of these templates assume a deployment in private subnets of your VPC (with NAT gateway) along with an Application Load Balancer (ALB) to direct external traffic to the Retool ECS service.

```bash title="Template for Workflows"
curl -L -O  https://raw.githubusercontent.com/tryretool/retool-onpremise/master/cloudformation/retool-workflows.fargate.yaml \
&& mv retool-workflows.fargate.yaml fargate.yaml
```

```bash title="Template for Agents"
curl -L -O  https://raw.githubusercontent.com/tryretool/retool-onpremise/master/cloudformation/retool-agents.fargate.yaml \
&& mv retool-agents.fargate.yaml fargate.yaml
```
These two templates are similar, however, the workflows template differs from the agents template in the following ways: 
 - **Parameters**: The agents template declares a `DesiredAgentsCount` and defaults the Retool version to 3.253.2-stable, and the workflows template contains a `Force` parameter, and defaults to Retool version 3.114.7-stable. 
 - **Environment variables**: The workflows template injects `NODE_ENV=production` and a `FORCE_DEPLOYMENT` env var (from the Force parameter) into several task definitions. The agents template sets `AGENTS_ENABLED` and `BASE_DOMAIN` in the `Retool/backend` tasks. 
 - **Temporal**: The temporal versions differ slightly, agents uses 14.6, and workflows uses 14.5. 

Refer to the [System architecture of self-hosted Retool deployments](../../concepts/architecture.mdx) conceptual guide for more information about the containers and services. 

```bash
curl -L -O  https://raw.githubusercontent.com/tryretool/retool-onpremise/master/cloudformation/retool-workflows.ec2.yaml \
&& mv retool-workflows.fargate.yaml fargate.yaml
```

### Configure Temporal

  

Comment out the **Temporal** configuration section in either [fargate.yaml](https://github.com/tryretool/retool-onpremise/blob/master/cloudformation/retool-workflows.fargate.yaml#L603-L1031) or [ec2.yaml](https://github.com/tryretool/retool-onpremise/blob/master/cloudformation/retool-workflows.ec2.yaml#L563-L971), depending on the type of deployment used.

  
    

Comment out the **Temporal** configuration section in either [fargate.yaml](https://github.com/tryretool/retool-onpremise/blob/master/cloudformation/retool-workflows.fargate.yaml#L603-L1031) or [ec2.yaml](https://github.com/tryretool/retool-onpremise/blob/master/cloudformation/retool-workflows.ec2.yaml#L563-L971), depending on the type of deployment used.

  
  

  

### Add your license key

Edit the configuration and include your license key. Replace all values of `LICENSE_KEY` with your license key.

```yaml title="fargate.yaml"
Environment:
  - Name: LICENSE_KEY
// highlight-next-line
    Value: "EXPIRED-LICENSE-KEY-TRIAL"
```

## 3. Configure CloudFormation service

Next, log into the AWS Management Console to configure the CloudFormation service:

1. Navigate to the CloudFormation service and create a new stack.
2. Upload the `fargate.yaml` file.
3. Set the following parameters.

| Parameter      | Value                                                                                                                     |
| -------------- | ------------------------------------------------------------------------------------------------------------------------- |
| `cluster`        | The name of your ECS cluster.                                                                                             |
| `desiredCount`   | `2`                                                                                                                       |
| `environment`    | `Staging`                                                                                                                 |
| `force`          | `false`                                                                                                                   |
| `image`          | The [Docker tag](https://hub.docker.com/r/tryretool/backend/tags) for the version of Retool to install, such as tryretool/backend:. |
| `maximumPercent` | `250`                                                                                                                     |
| `minimumPercent` | `50`                                                                                                                      |
| `subnetID`       | Two subnets you identified in the networking requirements section.                                                        |
| `vpcID`          | The VPC ID to use.                                                                                                        |

After creating the stack, verify its status is `CREATE_COMPLETE`.

## 4. Start the instance

The **Outputs** tab of the CloudFormation stack contains the URL of the load balancer running Self-hosted Retool. Once running, your instance is available at `http://{load-balancer-url}:3000/auth/signup`. When you first visit the page, you must create an admin account.

## Additional steps

Retool strongly recommends you externalize your database, configure SSL, and keep up-to-date with the latest version of Self-hosted Retool. Setting environment variables is often necessary to configure SSO, source control, and other self-hosted features.

### Externalize database

By default, the Retool ECS template creates a new RDS instance to serve as the PostgreSQL database. To set up the ECS deployment to use a different database, you need to update the CloudFormation template by modifying the environment variables for both the `RetoolTask` and the `RetoolJobsRunnerTask`.

1. Modify `fargate.yaml`, setting the following environment variables for both the `RetoolTask` and the `RetoolJobsRunnerTask`.

| Variable            | Description                                          |
| ------------------- | ---------------------------------------------------- |
| `POSTGRES_DB`       | The name of the external database.                   |
| `POSTGRES_HOST`     | The hostname of your external database instance.     |
| `POSTGRES_PORT`     | The port number for your external database instance. |
| `POSTGRES_USER`     | The external database username.                      |
| `POSTGRES_PASSWORD` | The external database password.                      |

2. In the AWS Management Console, navigate to the CloudFormation service. Select the Retool stack.
3. Update the stack. Replace the current template by uploading the new version of `fargate.yaml`.
4. Submit changes, and wait for the stack to redeploy. Verify that the CloudFormation stack has a status of `CREATE_COMPLETE` before continuing.

### Update Retool

1. Back up your database. Amazon RDS provides two different methods for backing up and restoring your DB instances: automated backups and database snapshots.
2. Identify the appropriate release version on [Docker Hub](https://hub.docker.com/r/tryretool/backend). See Retool's [self-hosted release notes](../../../releases/index.mdx) to learn about version-specific features.
3. In the AWS Management Console, navigate to the CloudFormation service. Select the Retool stack.
4. Update the stack. Use the current template. On the parameters screen, change the value of `Image` to the [Docker tag](https://hub.docker.com/r/tryretool/backend/tags) for the version of Retool to use, such as tryretool/backend:.
5. Submit changes, and wait for the stack to redeploy. Verify that the CloudFormation stack has a status of `CREATE_COMPLETE` before continuing.

### Add environment variables

To add [environment variables](https://docs.retool.com/reference/environment-variables), follow the steps below.

1. Modify `fargate.yaml`, setting the environment variables for both the `RetoolTask` and the `RetoolJobsRunnerTask`.
2. In the AWS Management Console, navigate to the CloudFormation service. Select the Retool stack.
3. Update the stack. Replace the current template by uploading the new version of `fargate.yaml` from your computer.
4. Submit changes, and wait for the stack to redeploy. Verify that the CloudFormation stack has a status of `CREATE_COMPLETE` before continuing.

### Configure SSL

To configure SSL, you must first obtain an SSL certificate. You can either purchase an SSL certificate from a Certificate Authority (CA) or generate a free one using Let's Encrypt. AWS also provides a service called AWS Certificate Manager (ACM) for provisioning, managing, and deploying public and private SSL/TLS certificates.

To add your SLS certificate to your instance:

1. In the AWS Management Console, navigate to the EC2 service.
2. Import your SSL certificate to AWS Certificate Manager (ACM).
3. In the AWS Management Console, navigate to the EC2 service. Under **Load Balancing**, choose Load Balancers.
4. Select the load balancer that is part of the Retool deployment.
5. In the **Listeners** tab, select **Add listener**.
6. Select **HTTPS** (port 443). Select the ACM, which you created in step 2.
7. Add the listener. You can now access Retool with a SSL connection.

### Mount volumes

There are several use cases which require the use of [volumes](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/efs-volumes.html). For example, when configuring a [gRPC resource](../../../data-sources/guides/integrations/development/grpc.mdx), you need to mount a volume containing the protos files to the Retool deployment. Follow these instructions to create a persistent volume and copy files from your local machine to the volume.

First, choose a method to upload files to the EFS volume. You can either:

- Mount the EFS volume on an EC2 instance and use standard file operations to upload files directly to the mounted directory on the EFS volume.
- Use [AWS DataSync](https://aws.amazon.com/datasync/) to transfer your local files to an EFS file system by setting up a DataSync agent and configuring a data transfer task.
- Set up an SFTP server using [AWS Transfer](https://docs.aws.amazon.com/transfer/index.html) for SFTP and configure it to use an EFS file system as the storage backend, then upload files using an SFTP client to store them on the EFS volume.

1. In the AWS Management Console, navigate to the EFS service.
2. Create a new file system. Select the same VPC in which you deploy Retool.
3. Upload files to the EFS volume using your data transfer method of choice.
4. In `fargate.yaml`, add the EFS volume as a parameter in the `Parameters` section.

```yaml title="fargate.yaml"
Parameters:
  ...

  EFS:
    Type: AWS::EFS::FileSystem::Id
    Description: Select an existing EFS volume to mount.
```

5. In `fargate.yaml`, add an `EFSMountTarget` to `Resources` section.

```yaml title="fargate.yaml"
Resources:
  EFSMountTarget:
    Type: AWS::EFS::MountTarget
    Properties:
      FileSystemId: !Ref 'EFS'
      SecurityGroups: [!Ref 'ALBSecurityGroup']
      SubnetId: !Select [0, !Ref 'SubnetId']
```

6. In `fargate.yaml`, add the volume to the `RetoolTask`.

```yaml title="fargate.yaml"
  RetoolTask:
    Type: AWS::ECS::TaskDefinition
    Properties:
        ...

      ContainerDefinitions:
        ...

        Volumes:
            - Name: efs-volume
            EFSVolumeConfiguration:
                FileSystemId: !Ref 'EFS'
        MountPoints:
          - SourceVolume: efs-volume
            ContainerPath: /efs
            ReadOnly: false  # Set to 'true' if you want read-only access
```

6. In the AWS Management Console, navigate to the CloudFormation service. Select the Retool stack.
7. Update the stack. Replace the current template by uploading the new version of `fargate.yaml`.
8. Submit changes, and wait for the stack to redeploy.

---

## Deploy Self-hosted Retool on AWS Fargate and ECS

import DocCardList from "@theme/DocCardList";

---

## Deploy Self-hosted Retool on AWS Fargate and ECS with Terraform

import TemporalOptions from "../../_partials/_temporal-options.mdx";
import TemporalConfigure from "../../_partials/_temporal-configure.mdx";
import SelfhostedLatest from "@site/src/components/SelfhostedLatest";
import CodeBlock from '@theme/CodeBlock';
import EncryptionKey from "../../_partials/_encryption-key.mdx";
import EnterpriseRequirement from "../../_partials/_enterprise-plan-requirement.mdx";

You can deploy Self-hosted Retool on ECS Fargate and EC2 with a Terraform module.

## Requirements

To deploy Self-hosted Retool on AWS Fargate and ECS, you need:

- A Retool license key, which you can obtain from the [Retool Self-hosted Portal](https://my.retool.com/) or your Retool account manager.
- An [AWS account](https://aws.amazon.com/marketplace/management/signin).
- An [ECS cluster](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/create-cluster-console-v2.html) with the Fargate launch type.

Retool recommends using the Retool-provided [Terraform module](https://github.com/tryretool/terraform-retool-modules/tree/main/modules/aws_ecs) for ECS deployments.

## 1. Update Terraform configuration

:::info Minimum requirements 

A [Retool-managed Temporal Cluster](../../concepts/temporal.mdx#compare-options) requires v3.6.15 or later.

:::

First, update your Terraform configuration to directly use the module. Next, set `ecs_retool_image` to the [Docker tag](https://hub.docker.com/r/tryretool/backend/tags) for the version of Retool to install, such as tryretool/backend:.

:::caution Avoid using `latest`

Specify the exact version to use, such as . This ensures you know exactly which version will be deployed.

:::

If you are not using Fargate, set `launch_type` to `EC2`. Retool recommends `t3.xlarge` instances for EC2-backed ECS as this avoids Elastic Network Interface (ENI) limits since each ECS Service requires an ENI.

Ensure that `workflows_enabled=true`.

```json title="Terraform configuration"
module "retool" {
  source = "git@github.com:tryretool/terraform-retool-modules.git//modules/aws_ecs"

  aws_region = ""
  vpc_id = ""
  subnet_ids = [
      "",
      ""
  ]
  ssh_key_name = ""
  retool_license_key = ""
  ecs_retool_image = ""
  launch_type = "FARGATE" | "EC2"
  // highlight-start
  workflows_enabled = true
  // highlight-end
  ...
}
```

### Configure Terraform for Temporal

Update your Terraform configuration to configure Temporal:

  

```json
module "retool" {
  ...
  workflows_enabled = true
  // highlight-start
  use_existing_temporal_cluster = true
  // temporal_cluster_config = 
  // highlight-end
  ...
}
```

```json
module "retool" {
  ...
  workflows_enabled = true
  // highlight-start
  use_existing_temporal_cluster = true
  temporal_cluster_config = 
  // highlight-end
  ...
}
```

:::info

Use the default values when configuring an existing Temporal Cluster.

:::

```json
module "retool" {
    ...
    workflows_enabled = false
    // highlight-start
    use_existing_temporal_cluster = false
    // temporal_cluster_config = 
    // highlight-end
    ...
}
```

## 2. Install module requirements

Run `terraform init` to install all requirements for the module.

## 3. Verify security settings additional input variables

Ensure that the default security settings in `security.tf` matches your specifications. If you need to restrict access further, you can configure ingress and egress rules into `container_egress_rules`, `container_ingress_rules`, `alb_egress_rules`, and `alb_ingress_rules`.

Check `variables.tf` for any other input variables that may be required.

## 4. Review and apply changes

Run `terraform plan` to view all planned changes to your account. Once complete, run `terraform apply` to apply the changes and deploy Self-hosted Retool.

A load balancer is then associated with the deployment and available in the AWS EC2 Console. The instance address should now be running Self-hosted Retool.

---

## Deploy Retool on Google Compute Engine

import Requirements from "../_partials/_requirements.mdx";
import DockerDownload from "../_partials/_docker_download.mdx";
import DockerInstall from "../_partials/_docker_install.mdx";
import DockerKey from "../_partials/_docker_encryption_key.mdx";
import DockerConfigure from "../_partials/_docker_configure.mdx";
import DockerUpdate from "../_partials/_update.mdx";
import TemporalOptions from "../_partials/_temporal-options.mdx";
import Production from "../_partials/_additional-steps.mdx";
import DockerStart from "../_partials/_docker_start.mdx";
import SelfhostedLatest from "@site/src/components/SelfhostedLatest";
import EnterpriseRequirement from "../_partials/_enterprise-plan-requirement.mdx";

You can deploy an instance of Self-hosted Retool on Google Compute Engine with [Docker Compose](https://docs.docker.com/compose/).

## Requirements

## 1. Create a Linux VM instance

Create a new Linux VM in the [Google Cloud console](https://console.cloud.google.com/) that meets the minimum requirements. Refer to the [Google Cloud documentation](https://cloud.google.com/compute/docs/create-linux-vm-instance) to learn how to create a new virtual machine.

| VM setting  | Description                                                                            |
| ----------- | -------------------------------------------------------------------------------------- |
| **Network** | Configure the VM to allow HTTP and HTTPS traffic.                                      |
| **Storage** | Specify **SSD persistent** with a size that meets or exceeds the minimum requirements. |

Once the VM is initialized, download the private key when prompted. Update the permissions of the key-pair to ensure it has the required permissions for your SSH client.

```shell
chmod 400 
```

## 2. Download Self-hosted Retool

GCP automatically runs the new virtual machine once created. Once the new Linux VM is ready, use the Google Cloud console to connect using SSH.

## 3. Install Docker dependencies

## 4. Back up encryption key

## 5. Configure deployment

## 6. Start the instance

" />

## Additional configuration

## Update your Google Compute Engine instance

---

## Deploy Retool on Kubernetes with Helm

import Requirements from "../../_partials/_kubernetes-requirements.mdx"
import Helm1 from "../../_partials/_helm1.mdx"
import Helm2 from "../../_partials/_helm2.mdx"
import Helm3 from "../../_partials/_helm3.mdx"
import TemporalOptions from "../../_partials/_temporal-options.mdx"
import EncryptionKey from "../../_partials/_encryption-key.mdx"
import Egress from "../../_partials/_egress.mdx"
import EnvVarsCloud from "../../_partials/_env-vars-cloud-helm.mdx"
import EnvVarsLocal from "../../_partials/_env-vars-local-helm.mdx"
import ExternalizeDb from "../../_partials/_externalize-db.mdx"
import LetsEncrypt from "../../_partials/_lets-encrypt.mdx"
import SelfhostedLatest from "@site/src/components/SelfhostedLatest";
import EnterpriseRequirement from "../../_partials/_enterprise-plan-requirement.mdx";

You can deploy Self-hosted Retool on Kubernetes with [Helm](https://helm.sh/) 3.3.1 or later.

## Requirements

## 1. Add the Retool Helm chart repository

## 2. Download Helm configuration file

## 3. Update Helm configuration

## 4. Install Self-hosted Retool

After updating the configuration, install Self-hosted Retool.

```shell
helm install my-retool retool/retool -f values.yaml
```

After installing Retool, run `kubectl get pods` to verify you have pods for the main service and `jobs-runner`. If you use the PostgreSQL subchart, there is also a `postgresql` pod. If you have enabled Workflows, there are also `workflow-worker` and `workflow-backend` pods.

```text title="Verify pods"
my-retool-7898474bbd-pr8n6               1/1     Running   1 (8h ago)   8h
my-retool-jobs-runner-74796ddd99-dd856   1/1     Running   0            8h
my-retool-postgresql-0                   1/1     Running   0            8h
```

Once the main service is running, verify the installation by port forwarding to `localhost`.

```shell
kubectl port-forward my-retool-7898474bbd-69zjt 3000:3000
```

You can then access Retool at `http://localhost:3000/`.

## Additional configuration

The following configuration steps are optional but strongly recommended for using Retool in a production environment.

:::note

Whenever you run `helm upgrade`, use the `--version` flag to specify the chart's version number. Otherwise, Helm upgrades to the latest chart version, which may cause compatibility issues. You can check the release version of your deployment with the command `helm list`.

:::

### Add environment variables

[Environment variables](https://docs.retool.com/reference/environment-variables) provide ways to configure a Retool instance. The `values.yaml` file has three locations to add [environment variables](../../reference/environment-variables/index.mdx).

| Object                 | Type                             |
| ---------------------- | -------------------------------- |
| `env`                  | Plain text key-value pairs.       |
| `environmentSecrets`   | Plain text or Kubernetes secrets. |
| `environmentVariables` | Plain text or Kubernetes secrets. |

:::caution

Do not store sensitive information, such as access tokens, in `env`. Use `environmentSecrets` or `environmentVariables` as they can populate environment variables from Kubernetes secrets.

:::

### Mount volumes

There are several use cases which require the use of [volumes](https://kubernetes.io/docs/concepts/storage/volumes/). For example, when configuring a [gRPC resource](../../../data-sources/guides/integrations/development/grpc.mdx), you need to mount a volume containing the protos files to the Retool deployment. Follow these instructions to create a persistent volume and copy files from your local machine to the volume.

#### 1. Enable PersistentVolumeClaim

The Helm chart defines a PersistentVolumeClaim (PVC) which is automatically mounted to the Retool pods, enabling Retool to access files within this volume. The PVC is disabled by default. To enable the `persistentVolumeClaim`, modify your `values.yaml` file:

```yaml
persistentVolumeClaim:
  enabled: true
  existingClaim: ""
```

If you have an existing PVC in your Kubernetes cluster to use, you can specify its name in `existingClaim`. Otherwise, leave `existingClaim` blank.

#### 2. Set security context

In a later step, you use [`kubectl cp`](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#cp) to copy files from your local machine to the Kubernetes cluster, which requires the pod to run with root privileges. Modify your deployment so the pods run as root by changing the `securityContext` in your `values.yaml` file:

```yaml
securityContext:
  enabled: true
  runAsUser: 0
```

Use `helm` to perform the upgrade and include the Helm chart version number. Retool requires version `6.1.1` or later.

```shell
helm upgrade -f values.yaml my-retool retool/retool --version 6.1.1
```

#### 3. Verify pods

Run `kubetcl get pods` to verify pods are running.

```text
my-retool-7898474bbd-pr8n6               1/1     Running   1 (8h ago)   8h
my-retool-jobs-runner-74796ddd99-dd856   1/1     Running   0            8h
my-retool-postgresql-0                   1/1     Running   0            8h
```

#### 4. Copy files

Next, copy the protos files from your local machine to the PVC. Note from `kubectl get pods` the three pods in the deployment: the main, `jobs-runner`, and `postgresql` containers. Identify the name of the main container.

Ensure you local machine has a folder named `protos` and run the following command, and replacing `my-retool-7c4c89798-fqbh7` with the name of your Retool container.

```shell
kubectl cp protos/ my-retool-7c4c89798-fqbh7:/retool_backend/pv-data/protos
```

#### 4. Set env

If you're configuring gRPC, you need to specify the location of the protos directory. In `values.yaml`, set the `PROTO_DIRECTORY_PATH` environment variable.

```yaml
env:
  PROTO_DIRECTORY_PATH: "/retool_backend/pv-data/protos"
```

#### 5. Reset security context

Revert the security context of your deployment back to a disabled state.

```yaml
securityContext:
  enabled: false
  runAsUser: 1000
```

Use `helm` to perform the upgrade and include the Helm chart version number. Retool requires version `6.1.1` or later.

```shell
helm upgrade -f values.yaml my-retool retool/retool --version 6.1.1
```

### Configure SSL

When configuring SSL, you can use Let's Encrypt to provision a certificate, or provide your own. See [Configure SSL and custom certificates](../../guides/certificates.mdx) for more detail on certificates.

#### 1. Install cert-manager

First, add the `jetstack` Helm repository if you haven't already.

```shell
helm repo add jetstack https://charts.jetstack.io
```

Next, run the following command to install `cert-manager`.

```shell
helm install \
cert-manager jetstack/cert-manager \
--namespace cert-manager \
--create-namespace \
--version v1.11.0 \
--set installCRDs=true --set ingressShim.defaultIssuerName=letsencrypt-prod \
--set ingressShim.defaultIssuerKind=ClusterIssuer \
--set ingressShim.defaultIssuerGroup=cert-manager.io
```

#### 6. Apply changes

After the pods restart, you can access the page in your browser using TLS.

## Update your Kubernetes instance

import Update from "../../_partials/_update-helm-retool.mdx"

---

## Deploy Self-hosted Retool on Kubernetes

You can deploy Self-hosted Retool on Kubernetes using the Helm package manager or manually configure manifests.

import DocCardList from "@theme/DocCardList";

---

## Deploy Retool on Kubernetes with manifests

import Requirements from "../../_partials/_kubernetes-requirements.mdx"
import TemporalConfigure from "../../_partials/_temporal-configure.mdx";
import TemporalTemplate from "../../_partials/_temporal-template.mdx";
import SelfhostedLatest from "@site/src/components/SelfhostedLatest";
import CodeBlock from '@theme/CodeBlock';
import PostgresConfig from "../../_partials/_remaining-postgresql-config.mdx"
import LetsEncrypt from "../../_partials/_lets-encrypt.mdx"
import ExternalizeDb from "../../_partials/_externalize-db.mdx"
import EnterpriseRequirement from "../../_partials/_enterprise-plan-requirement.mdx";

You can deploy Self-hosted Retool on Kubernetes using manually configured manifests. You can use this approach if you do not manage packages with [Helm](helm.mdx).

## Requirements

  

Self-hosted Retool with Workflows deployments on Kubernetes are configured using a [set of manifests](https://github.com/tryretool/retool-onpremise/tree/master/kubernetes). To retrieve a copy of the manifests, download the `retool-onpremise` repository to your local machine. Open the `kubernetes` directory in an IDE to follow along the steps below.

```shell
curl -L -O https://github.com/tryretool/retool-onpremise/archive/master.zip && unzip master.zip \
&& cd retool-onpremise-master/kubernetes
```

  
  

Self-hosted Retool with Workflows deployments on Kubernetes are configured using a [set of manifests](https://github.com/tryretool/retool-onpremise/tree/master/kubernetes). To retrieve a copy of the manifests, download the `retool-onpremise` repository to your local machine. Open the `kubernetes` directory in an IDE to follow along the steps below.

```shell
curl -L -O https://github.com/tryretool/retool-onpremise/archive/master.zip && unzip master.zip \
&& cd retool-onpremise-master/kubernetes
```

  
  

Self-hosted Retool with Workflows deployments on Kubernetes are configured using a [set of manifests](https://github.com/tryretool/retool-onpremise/tree/master/kubernetes). To retrieve a copy of the manifests, download the `retool-onpremise` repository to your local machine. Open the `kubernetes-with-temporal` directory in an IDE to follow along the steps below.

```
curl -L -O https://github.com/tryretool/retool-onpremise/archive/master.zip && unzip master.zip \
&& cd retool-onpremise-master/kubernetes-with-temporal
```

  

## 1. Configure version

:::info

Self-hosted Retool requires 3.6.14 or later for Retool-managed Temporal Cluster.

:::

Set the `image` value in the following files to the [Docker tag](https://hub.docker.com/r/tryretool/backend/tags) for the version of Retool to install, such as tryretool/backend:.

- `retool-container.yaml`
- `retool-jobs-runner.yaml`
- `retool-workflows-worker-container.yaml`
- `retool-workflows-backend-container.yaml`

In `retool-code-executor-container.yaml`, change the `image` tag to indicate the [version of Retool's code executor service](https://hub.docker.com/r/tryretool/code-executor-service/tags) to install. This must match the version of Retool for which you're deploying.

  {`image: tryretool/code-executor-service:`}{}

## 2. Update configuration

  

  
  

  
  

Copy `retool-temporal-secrets.template.yaml` to a new file named `retool-temporal-secrets.yaml`. This file sets the configuration options for Temporal in your deployment, and stores them as [Kubernetes secrets](https://kubernetes.io/docs/concepts/configuration/secret/). These values must be Base64-encoded.

```shell
cp retool-temporal-secrets.template.yaml retool-temporal-secrets.yaml
```

| Setting                  | Description                            |
| ------------------------ | -------------------------------------- |
| `data.postgres_password` | The same database password used above. |

 

## Additional configuration

The following configuration steps are optional but strongly recommended for using Retool in a production environment.

### Add environment variables

[Environment variables](https://docs.retool.com/reference/environment-variables) provide ways to configure a Retool instance.

#### 1. Update manifests

Configure environment variables in the following files:

- `retool-container.yaml`
- `retool-jobs-runner.yaml`
- `retool-workflows-worker-container.yaml`
- `retool-workflows-backend-container.yaml`

The following example configures the [`DBCONNECTOR_QUERY_TIMEOUT_MS`](https://docs.retool.com/self-hosted/reference/environment-variables/index.mdx#dbconnector_query_timeout_ms) variable, but this pattern applies to other [environment variables](https://docs.retool.com/reference/environment-variables) as well.

```yaml
env:
- name: DBCONNECTOR_QUERY_TIMEOUT_MS
  value: 360000
```

#### 2. Apply changes to the manifests

Use `kubectl` to apply manifest changes.

  

```shell
kubectl apply -f -R kubernetes
```

  
  

```shell
kubectl apply -f -R kubernetes
```

  
  

```shell
kubectl apply -f -R kubernetes-with-temporal
```

  

#### 3. Verify pods

Run `kubetcl get pods` to verify pods are running.

```shell
NAME                                     READY   STATUS    RESTARTS     AGE
api-76464f5576-vc5f4                     1/1     Running   1 (8h ago)   8h
jobs-runner-5cfb79cbfd-b49rd             1/1     Running   0            8h
postgres-69c485649c-lkjgc                1/1     Running   0            8h
...
```

### Mount volumes

There are several use cases which require the use of [volumes](https://kubernetes.io/docs/concepts/storage/volumes/). For example, when configuring a [gRPC resource](../../../data-sources/guides/integrations/development/grpc.mdx), you need to mount a volume containing the protos files to the Retool deployment. Follow these instructions to create a persistent volume and copy files from your local machine to the volume.

#### 1. Set security context

In a later step, you use [`kubectl cp`](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#cp) to copy files from your local machine to the Kubernetes cluster, which requires the pod to run with root privileges.

Modify your deployment so the pods run as root by adding the `securityContext` in the `retool-container.yaml` file:

```yaml
spec:
      securityContext:
        runAsUser: 0
        fsGroup: 2000
```

#### 2. Apply changes to the manifest

Use `kubectl` to apply manifest changes.

```shell
kubectl apply -f retool-container.yaml
```

#### 3. Verify pods

Run `kubectl get pods` to verify that pods are ready.

```shell
NAME                                     READY   STATUS    RESTARTS     AGE
api-76464f5576-vc5f4                     1/1     Running   1 (8h ago)   8h
jobs-runner-5cfb79cbfd-b49rd             1/1     Running   0            8h
postgres-69c485649c-lkjgc                1/1     Running   0            8h
...
```

#### 4. Copy protos files

Next, copy the protos files from your local machine to the PVC. Ensure you local machine has a folder named `protos` and run the following command. Replace `api-76464f5576-vc5f4` with the name of your main Retool container, retrieved from `kubectl get pods`.

```shell
kubectl cp protos/ api-76464f5576-vc5f4:/retool_backend/pv-data/protos
```

#### 5. Set directory path

If you're configuring gRPC, specify the location of the protos directory. In `retool-container.yaml`, set the `PROTO_DIRECTORY_PATH` environment variable.

```yaml
env:
- name: PROTO_DIRECTORY_PATH
  value: "/retool_backend/pv-data/protos"
```

#### 6. Reset security context

Reset the security context of your deployment by removing the `securityContext` field, or by defining a non-root user.

Apply changes to the manifest.

```shell
kubectl apply -f retool-container.yaml
```

### Configure SSL

When configuring SSL, you can use Let's Encrypt to provision a certificate, or provide your own. See [Configure SSL and custom certificates](../../guides/certificates.mdx) for more detail on certificates.

#### 1. Generate self-signed certificate

Generate a self-signed certificate and private key using `openssl`. Replace `KEY_FILE`, `CERT_FILE`, and `HOST` with your key file name, certificate file name, and hostname, or set environment variables naming each.

```shell
openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout ${KEY_FILE} -out ${CERT_FILE} -subj "/CN=${HOST}/O=${HOST}" -addext "subjectAltName = DNS:${HOST}"
```

#### 2. Create a TLS secret

Create a TLS secret using `kubectl`. Replace `KEY_FILE` and `CERT_FILE` with your key and certificate file names.

```shell
kubectl create secret tls ${CERT_NAME} --key ${KEY_FILE} --cert ${CERT_FILE}
```

#### 3. Install the Ingress-Nginx Controller

If you haven't already, install the [Nginx-Ingress Controller](https://kubernetes.github.io/ingress-nginx/deploy/#installation-guide) using the instructions for your environment. To confirm the installation was successful, run the following command. Its output should contain an entry for the **ingress-nginx-controller** pod.

```shell
kubectl get pods -n ingress-nginx
```

#### 4. Create an ingress resource

Create an ingress resource with the following manifest. Replace `retool.example.com` with your domain, and `testsecret-tls` with your TLS secret. See the [TLS section of the Kubernetes Ingress documentation](https://kubernetes.io/docs/concepts/services-networking/ingress/#tls) for more information.

If you haven't already, install the [Ingress-Nginx Controller](https://kubernetes.github.io/ingress-nginx/deploy/#installation-guide) using the instructions for your environment. To confirm the installation was successful, run the following command. Its output should contain an entry for the **ingress-nginx-controller** pod.

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: tls-example-ingress
  annotations:
    kubernetes.io/tls-acme: "true"
spec:
  ingressClassName: nginx
  tls:
    - hosts:
      - retool.example.com
  secretName: testsecret-tls
  rules:
  - host: retool.example.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
          name: api
          port:
            number: 3000
```

#### 1. Install cert-manager

Use `kubectl` to install [cert-manager](https://github.com/cert-manager/cert-manager).

```shell
kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.11.0/cert-manager.yam./l
```

#### 6. Apply changes to the manifests

Use `kubectl` to apply manifest changes. After the pods restart, you can access the page in your browser using TLS.

## Update your Kubernetes instance

Follow these instructions to update your Retool instance to a newer release version.

### 1. Back up your database

 If you use a managed database service, your database provider may have a feature to take snapshots or otherwise back up your database. If you use the PostgreSQL subchart, run the following command to export data from the PostgreSQL pod to a `.sql` file.

```shell
kubectl exec -it  -- bash -c 'pg_dump hammerhead_production --no-acl --no-owner --clean -U postgres' > retool_db_dump.sql
```

### 2. Select a new version

Set the `image` value in the following files to the [Docker tag](https://hub.docker.com/r/tryretool/backend/tags) for the version of Retool to install, such as tryretool/backend:.

- `retool-container.yaml`
- `retool-jobs-runner.yaml`
- `retool-workflows-worker-container.yaml`
- `retool-workflows-backend-container.yaml`

  {`image: tryretool/backend:`}{}

### 3. Apply changes to the manifests

Use `kubectl` to apply manifest changes.

  

```shell
kubectl apply -f -R kubernetes
```

  
  

```shell
kubectl apply -f -R kubernetes
```

  
  

```shell
kubectl apply -f -R kubernetes-with-temporal
```

  

### 4. Verify pods

Run `kubectl get pods` to verify that the update has completed.

```
NAME                                     READY   STATUS    RESTARTS     AGE
api-76464f5576-vc5f4                     1/1     Running   1 (8h ago)   8h
jobs-runner-5cfb79cbfd-b49rd             1/1     Running   0            8h
postgres-69c485649c-lkjgc                1/1     Running   0            8h
...
```

---

## Self-hosted Retool tutorials

import Tutorial from '/docs/_partials/_doctypes/_tutorial.mdx';
import EnterpriseRequirement from "./_partials/_enterprise-plan-requirement.mdx";

:::tip Learn more about self-hosted architecture

Read the [system architecture](concepts/architecture.mdx) guide to learn more about the containers, services, and dependencies for self-hosted deployment instances.

:::

---

## Catch-up commits in Source Control

In order to keep your branch up to date, Retool sometimes creates an automatic commit, called a catch-up commit, which keeps your branches up to date with the `main` branch. The commit has the following message:

```
This commit is automatically generated by Retool to update the current branch. 
You don't need to be concerned about it.
```

:::note

You can also use branch merging as an alternative to catch-up commits. Turn on branch merging in **Settings** > **Beta**. When branch merging is turned on, catch-up commits are disabled. Learn more about [branch merging](../guides/branch-merging.mdx).

:::

## Example scenario

The following scenario shows an example of when a catch-up commit is necessary:

1. Joe creates a branch `BranchA` in source control and edits a component `TextInput1`.
2. In a different branch `BranchB`, Emma edits `Chart1`, and the changes are merged to the `main` branch.
3. Joe opens `Chart1` on `BranchA` for the first time.
4. Retool creates a catch-up commit on `BranchA` that contains Emma's changes to `Chart1`.

In step 3 of this example, BranchA does not contain changes to `Chart1` that were made by Emma on `BranchB` and merged to the `main` branch. If the Joe continues to edit without the catch-up commit, he would see the app in an outdated state, and he would encounter merge conflicts when merging `BranchA` with `main`.

In a traditional software development process, this process is handled with a `git rebase`. Retool does not support rebasing, and instead performs a `git cherry-pick` to introduce the changes from `main` with an auto-generated commit.

## Disabling catch-up commits

If you want to ensure that developers in your organization retain complete control of changes within their feature branches, you can disable catch-up commits using the following steps:

:::warning

If you disable catch-up commits, users in your organization must manually, outside of Retool, rebase their branch and resolve conflicts in order to keep their branch up to date.

:::

1. Navigate to **Settings** > **Source Control** and click the **Edit Settings** button on the top right.
2. Toggle on the **Disable auto catch up commits** setting.

## Avoiding merge control issues

To avoid issues with catch-up commits and other merge control mechanisms, refer to Retool's [Merge conflict prevention strategies](../guides/branch-merging.mdx#merge-conflict-prevention-strategies).

---

## Multi-instance development with Source Control

Retool recommends starting app development in an instance representing a staging or development environment; however, an app can be created and protected from any instance of Retool connected to the remote repository (named `retool_source` in the diagram). This is useful if you have a particular resource that's only accessible from your production environment.

Retool also recommends using one branch instead of a "Git Flow” branching model. Since you have the fine-grain control to release each protected app independently at the cadence of your choosing, you can use a single, protected `main` branch that each instance points to.

If batching changes across multiple apps is a requirement, you should manually coordinate releases to synchronize updates after apps have the latest versions. If that is insufficient, you could also point your instances to other integration-like branches such as `staging` and `production` and manually cherry-pick and merge to batch and promote changes.

:::note

By default, releases are exclusive to the Retool instance in which they were created. Creating and publishing releases for an app are not captured in source control, and can be treated as a deploy mechanism. Learn more about [Release Management](../../apps/guides/app-management/releases-history.mdx).

For organizations that need to manage releases across multiple instances, Retool offers [multi-instance releases](../guides/multi-instance-releases.mdx), which enables you to publish different release versions of protected apps and workflows to different instances.

:::

---

## Toolscript

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

Toolscript is a JSX-style markup language built to serialize Retool apps protected using Source Control. Unlike its YAML predecessor, Toolscript is designed to be human reviewable.

Retool recommends you not modify Toolscript files directly and only [make changes](#edit-toolscript) when resolving merge conflicts.

:::info Toolscript availability

Toolscript is available on Retool Cloud and self-hosted Retool versions 3.6.0 and later. Organizations already using Source Control can [migrate YAML files to Toolscript](/changelog/yaml-serialization-deprecation).
Support for YAML will be [removed](/changelog/yaml-serialization-deprecation) in the Q2 2025 [stable release](../../releases/stable/index.mdx) of Self-hosted Retool. Organizations still using YAML serialization of these elements in Source Control must migrate to Toolscript prior to upgrading.

:::

## Syntax

Toolscript uses XML-like syntax to convey positioning and hierarchical information at-a-glance. It uses the `rsx` (Retool Scripting XML) file extension, or "Toolscript" for short.

Toolscript uses nesting to represent parent-child relationships. For example:

- Containers have nested `Header`, `Footer`, `Body` and `View` elements. Child components are nested inside these elements.
- Many components, including `Select` dropdowns and Button groups, have nested `Options`.
- Tables have nested `Columns`.

The ordering of components is based on their position on the canvas: top to bottom, then left to right. When component positions change—for example, a button is moved above another button—their order in the Toolscript file also changes.

## File structure

Toolscript code is split into multiple files for easier comprehension:

- Large groups of components are split into their own files.
- Code blocks are split into own files (e.g., `*.sql`, `*.js`).
- Minor position and size changes are separated from more substantial logical changes.

## Toolscript files

The `apps` directory contains the serialized app contents, split into the following files and directories. Some files and directories, such as `lib`, `src`, and `functions.rsx`, are not always present, depending on the app's structure.

```
app-name
└── .defaults.json
└── .positions
  └── .global_mobile_positions.json
  └── .global_positions.json
  └── .pageName1.positions.json
  └── .pageName2.positions.json
  └── .pageName1.mobilePositions.json
  └── .pageName2.mobilePositions.json
└── lib
  └── sqlQueryName.sql
  └── jsQueryName.js
└── src
  └── container1.rsx
└── functions.rsx
└── main.rsx
└── metadata.json
```

### JSON dotfiles

Toolscript makes use of JSON dotfiles.

- `.defaults.json` contains default component values at time of serialization.
- `.positions` contains one file for each page. Each page contains positioning information for components in the desktop layout.
- `.mobilePositions.json` contains positioning information for components in the mobile layout, if enabled.

Toolscript dotfiles are autogenerated and not designed to be human-readable.

### Core files

- `main.rsx` is the main entry point to the app.
- `functions.rsx` stores functions and queries.
- `metadata.json` contains information about the app version and flags.

### The `lib/` directory

Files in `lib` are extracted from functions and queries. These files contain the contents of the query. The query component has an attribute of the format `query={include("./lib/query1.sql", "string")}`.

### The `src/` directory

Files in `src` are extracted from certain components. They are named after the ID of the extracted component, e.g., `container1.rsx`.

## Edit Toolscript

:::warning

Review these best practices before you directly edit Toolscript files.

:::

Toolscript is a major improvement in readability from YAML, but it is not yet optimized for writing. While manually editing RSX files outside of Retool is possible, it is not currently recommended due to the lack of standard developer tooling, including linting, type-checking, and testing. However, editing library files locally in your IDE and committing the result to your Source Control repository can be a useful way to develop longer scripts and queries.

To provide feedback on your specific use cases for editing Toolscript, contact [support](/support).

### Toolscript elements

The following are recommendations for how to edit specific Toolscript elements.

  

```jsx
// "hello1" is a plugin name

```

Plugin names can be safely edited. However, all references must be renamed as well. This includes the relevant entry in the `.positions.json` file, as well as any other plugins that reference the plugin to be renamed with a Retool expression (e.g., `{{ hello1.value }}` ).

  
  

```jsx
// "Hi there!" is plugin content

```

Plugin content is safe to edit, provided the attribute does not begin with an underscore. Edited content must be the same type as the original type, and it must be well formed. Only simple scalar expressions are allowed (e.g., `{"hi" + "world"}` is not supported).

  
  

```jsx

```

Although it is safe to do so, import statements should not be manually edited because they are currently automatically generated by Retool. As such, any manual changes to imports will be lost the next time the app is exported or updated through Source Control.

Importing files from outside of the app root (e.g., `../other-directory/file`) is not supported.

  
  

```sql
-- lib/query1.sql --
SELECT * from table;
```

You can change the content of library files arbitrarily. If you rename a library file, you must change all import references to it in RSX files as well.

Note that Retool expressions (e.g., `{{ query1.value }}`) are likely not parsed as valid code in library files. Retool expressions prevent the code from being directly executed outside of Retool as well.

  
  

In general, file names correspond to the name of the root plugin or query contained in that file. To rename files, you should rename the corresponding element in the Retool UI to ensure that all dependencies are also renamed.

The name of the `main.rsx`, `functions.rsx`, and JSON metadata files are fixed and cannot be modified.

  

### IDE settings

If you open Toolscript files in an IDE, you can change the language settings for RSX files to React or JSX to enable basic syntax highlighting and auto-formatting.

For example, in VS Code, to change the language setting for RSX, open any RSX file and select **JavaScript (JSX)** on the bottom toolbar.

---

## Source Control concept guides

import Concept from '/docs/_partials/_doctypes/_concept.mdx';

:::tip Get started with self-hosted Retool

Follow a [tutorial](./tutorial/) to set up Source Control with your SCM provider.

:::

---

## Keep branches up to date with branch merging

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

From within the IDE of your app, module, workflow, or query, you can use branch merging to integrate changes from your default branch and resolve merge conflicts. While it's also possible to resolve conflicts through your source control provider's UI or the Git CLI, Retool recommends using the in-product branch merging, as it automatically checks for ToolScript validity.

Branch merging in Retool uses the `git merge` strategy. Read more in the [git documentation](https://git-scm.com/docs/git-merge).

:::note

Enable branch merging by navigating to **Settings** > **Beta**, and toggle on **Enable branch merging**.

:::

## Integrate changes from default branch

Branch merging is enabled when you are developing on a feature branch and have made a commit. When you're ready to update your branch, click the **Merge main into ``** button. Retool handles each of the following three scenarios:

- Your branch is already up to date, and there are no changes to merge.
- Your branch is out of date, and there are no conflicts between the default branch and your feature branch. Click **Commit merge** to update your branch.
- Your branch is out of date, and the changes on the default branch conflict with those on your feature branch. View and resolve the merge conflict from within the IDE. Retool checks that the updated Toolscript is valid. Click **Commit merge** to update your branch. Refer to [Toolscript-specific resolution strategies](#toolscript-specific-resolution-strategies).

export function BranchMerge() {
  return (
    
      
    
  )
}

## Toolscript-specific resolution strategies

:::note

Toolscript is available on Retool Cloud and self-hosted Retool versions 3.6.0 and later. See the [migration guide](/changelog/yaml-serialization-deprecation) to learn how to migrate your apps from YAML to Toolscript.

:::

If your branch has conflicts with the default branch, you may need to edit [Toolscript files](../concepts/toolscript.mdx). It is important to understand how Toolscript files are structured to resolve merge conflicts correctly. Malformed Toolscript files can result in failed Source Control deployments and prevent builders from pushing new commits.

  

Metadata files are located in `app/.metadata.json`. They hold metadata about the application, such as the Retool version the app was edited on and app-level settings.

If the conflict is in the version field, you should keep the later version number.

Most other fields in this file reference app-level settings. If two builders modify the same setting, keep only one valid change in the final commit. If two builders toggle different settings, it is safe to keep both settings.

  

  

Positions files are located in `app/.positions.json`. They encode information about the visual properties for each plugin (e.g., positioning on the canvas).

In this file, each JSON key corresponds to a component's name. As such, all JSON keys must be unique.

### Common causes

There are generally three causes for conflicts in this file.

#### Two builders repositioned the same components

```
>>>>>> main
```

In this case, each block in the conflict has the same JSON key. To maintain the component’s position in your branch, keep your block. Otherwise, keep the block from the main branch.

#### Two builders positioned components at the same location

Both changes modified the same location in `.positions.json`.

```
>>>>>> main
```

In this case, it is safe to keep both blocks.

If both of these causes happen (e.g., two builders repositioned the same components and added different components at the same location), review each conflict area and decide which strategy to apply. The `.positions.json` file is sorted alphabetically by key to help you identify duplicate entries.

  
  

App code is located in `app/main.rsx` and `app/src/*.rsx`. These files contain the Retool components in the app and the app’s overall structure.

### Common causes

There are generally three causes of conflicts in app source code.

#### Two builders edited the same component

In this case, you must only keep the “correct” changes.

#### Two builders added new components at the same location

In this case, it is safe to keep changes from both blocks, but you should pay attention to ordering. See [order of components in app conflicts](#order-of-components-in-app-conflicts).

#### Order of components in app conflicts

When resolving app conflicts, you must carefully consider where your changes should end up in the Toolscript file. The order of components is important, as it helps determine visual placement of the component on the Retool canvas.

In general, your changes can go before, after, or within the other builder’s changes. In the last case, if the other builder introduced an import statement, you might have to place your changes in a different file entirely.

In this example, your changes should go **after** the existing changes.

```jsx
// conflict

=======

>>>>>>> main

// after resolution

```

In this example, your changes should go **within** the existing changes.

```jsx
// conflict

=======

    
    
      
    

>>>>>>> main

// after resolution

    
    
      
      
    

```

In this example, your changes should go within a different file because another builder added an import statement.

```jsx
// conflict - main.rsx

=======

>>>>>>> main

// conflict - container.rsx

    
    
      
    

// after resolution - main.rsx

// after resolution - container.rsx

    
    
      
    

```

  
  

Library code is found in the `lib` directory. It contains user-written executable code, such as JS and SQL files. These are most often used in queries, transformers, and certain code-first components.

Since this code is entirely user-written, there is no Toolscript-specific reasoning or advice for merge conflicts in these files. You may find the section on [merge conflict prevention strategies](#merge-conflict-prevention-strategies) useful.

## Merge conflict prevention strategies

The development processes you use can help prevent merge conflicts from arising in the first place.

### Keep branches and pull-requests short-lived

Trunk-based development best practices recommend branches are used for short-term feature work and kept open for a week or less. The faster a pull request is reviewed and merged into the main branch, the less likely it is for conflicting changes to be merged in during the same period of time.

### Add test deployments to your CI pipeline

[Test deployments](test-deploy.mdx) allow you to programmatically validate a potential change to your Retool repository. You can add a test deployment check to you source control provider (GitHub, etc.) to prevent invalid changes from being merged.

### Use modules to divide work

Retool [modules](../../apps/guides/layout-structure/modules.mdx) are an excellent way to encapsulate a body of work, allowing one individual to develop on an isolated part of an app without affecting others. Before working on a complex app, it can be useful to plan what pieces of the app can be designed as reusable modules.

### Assign different responsibilities to builders

Dividing responsibilities among builders helps ensure that builders make changes in different parts of the codebase. For example, you can assign one builder to work on the executable pieces of the app (e.g., queries and transformers), while another builder works on the visual pieces of the app (e.g., headers, titles, and images). Since the former exclusively affects files in the `lib/` directory while the latter primarily affects files in the `src/` directory, the chances of a conflict are minimal.

---

## Create collaborative branches for app changes

By default, only branch owners can commit changes and merge pull requests on their branches. With collaborative branches, multiple users can commit changes and submit pull requests to protected apps or workflows.

## Create collaborative branches

Create your branch, then select **Allow collaboration** to allow other users in your organization to push changes to it.

## Share branches with collaborators

When you're on a collaborative branch, links copied from the **Share** modal include the branch name. Users sent these links can then push changes to your branch. All users can commit changes and push changes to collaborative branches, but only admins can rename, reset, disallow collaboration, or delete these branches.

## Remove collaboration

From the branch menu in the lower left of the IDE, you can disallow further collaboration.

---

## Manage Source Control branches

Using Source Control, you can:

- Edit multiple apps, modules, workflows, and queries on the same branch.
- Commit changes directly in the editor.
- Switch between branches and apps using the **Branch** menu.

## Multi-element branching

With _multi-element branching_, you can edit apps, modules, workflows, and Query Library queries on a single branch. Each commit contains changes for a single app, module, workflow, or query, but branches can contain commits across apps, modules, and queries. This allows you to combine your dependent changes into a single pull request, instead of creating and merging pull requests for each dependent module or query.

Branches must all be created from `main`.

## Branch menu

From the branch menu in the bottom left status bar, you can:

- View your commit log.
- Switch branches.
- Edit other apps and modules on the same branch.
- Create a pull request.
- Rename, reset, and delete your branch.

## Build apps on and off branches

:::note

When you open a new tab, you are always on the `main` branch.

:::

When you create a new app or module while you're on a local branch, you can create it on or off your branch.

When you select **Create on current branch**, the app or module is created locally on your branch and considered **In development**. Apps and modules in development are only visible to their creators on the local branch until they are merged into source control repositories. After you merge an **In development** app or module to your source control repository, it is visible to the rest of your organization. In development apps and modules are useful when you want to privately develop and iterate on apps before you share them widely.

When **Create on current branch** is not selected, the new app or module is not protected.

## Rebase branches

[Rebasing](https://git-scm.com/book/en/v2/Git-Branching-Rebasing) allows you to integrate changes from one branch to another. It's often used to update a development or feature branch with the latest changes from a more stable branch (e.g.,`main`).

If you need to update your Source Control branch, you can perform a rebase on a branch that you own using the following steps.

1. Ensure all changes are committed on the branch.
2. Rebase the branch within your SCM provider and resolve any merge conflicts.
3. In Retool's app editor, open the branch menu in the lower left and select **•••** > **Reset branch** to update the branch.

:::note

Source Control branches can only be rebased by the branch owner.

:::

## Automatically delete branches

Retool automatically deletes branches after changes are merged if the remote branch no longer exists and there are no uncommitted changes. It can take up to one hour for branches to be automatically deleted. This feature is enabled by default, but you can switch it off in `Settings > Source Control > Edit Settings`.

Otherwise, users can delete branches that they own directly from the branch menu in the app.

## Multi-instance

To preview a branch of an app pushed from another instance, create a new branch in your current instance, and select **Reset branch** in the status bar. Select the relevant branches in the modal to pull in the origin branch changes.

:::caution Do not add files manually

Do not manually add any ToolScript (`*.tsx`), YAML, JSON, or query (`*.sql`, `*.js*`) files to the Source Control repository. All changes to apps, workflows, queries, and resources must be done through the Retool interface. Manually adding these files can cause deploy failures.

Any other files (e.g., `README.md`) are skipped during deploys can be safely added to the repository.

:::

---

## Manage Source Control deployments

:::note Requirements

The Deployment Dashboard is available on [Self-hosted Retool](../../self-hosted/index.mdx) v2.97 or later. Source Control with GitHub and GitLab, including the Deployment Dashboard, is also available on Retool Cloud.

:::

Organizations that use [Source Control](../index.mdx)—a branch-based workflow for managing and deploying changes to Retool apps—can use the Deployment Dashboard to view the status and details of deployments, download deployment logs for further information, and manually deploy the latest changes.

## View Source Control deployment logs

The Deployment Dashboard contains the following details about the most recent deployments (up to 100) for your self-hosted instance.

| Detail       | Description                                                                               |
| ------------ | ----------------------------------------------------------------------------------------- |
| Status       | Whether the deployment was successful or failed.                                          |
| Commit       | Specific commit SHA on the main branch of the Source Control repository that is deployed. |
| Triggered by | Whether the deployment was triggered automatically by Retool or manually by a user.       |
| Started at   | Date and time that the deployment started.                                                |
| Duration     | Total time for the deployment to run.                                                     |
| Logs         | Downloadable log file for the deployment.                                                 |

## Source Control status

The Deployment Dashboard also includes details about your instance's Source Control configuration. You can review the current configuration, test the connection to the source control management (SCM) provider, or edit the configuration.

## Full and Partial deployments

The **Deploy** section displays the commit SHA that is currently deployed.

Admin users can manually trigger **Full deployments** by clicking **Deploy latest**. This syncs the latest state of all protected elements in your remote repository's main branch to Retool.

Retool uses the jobs runner to poll for changes in your remote repository's main branch every 10 seconds. If any changes are detected, Retool automatically kicks off a **Partial deployment** to sync updated elements to Retool.

---

## Migrate from YAML to Toolscript

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

:::warning

This migration is only necessary if your organization initially set up Source Control on self-hosted Retool 3.4.19 or earlier. You must complete this migration before upgrading your legacy deployment to a newer release.

No migration is required if you initially configured Source Control on self-hosted Retool 3.6.0 or later.

:::

To use ToolScript, you must perform a one-time migration of your existing YAML repositories. The entire migration takes approximately 15 minutes to complete, but may take longer for organizations with many protected apps and branches. It does not change the behavior of your apps and queries.

This migration is unidirectional and you cannot migrate from Toolscript back to YAML.

:::tip

If you have a multi-instance deployment, ensure you follow the steps to [migrate multiple instances](#multi-instance-procedure).

:::

## Migration overview

Retool attempts to migrate your main branch and recent feature branches to Toolscript from YAML. During this operation, all source control operations are locked in Retool.

On the main branch, all apps, modules, and resources are migrated. Retool also attempts to migrate all feature branches touched within the last two months, up to a maximum of 300 total. For recent feature branches, only apps and resources changed by the feature branch are migrated. Retool also attempts to delete all recent open branches which rename, move, or unprotect source control elements. These branches are not possible to migrate, but you can recreate them after the migration.

If migration is not possible for all branches, Retool does not push any remote changes, and instead prompts you to fix or delete certain branches. This failure is rare, and usually occurs if a branch has been manually edited outside of Retool and contains an invalid structure or YAML format.

The automatic migration does not currently support migrating workflows. Commits to protected workflows are still in YAML.

### Test runs

You cannot currently specify a single test branch to migrate using the Retool UI. When the migration begins, all remote branches are converted from YAML to Toolscript.

To dry run the migration, you must copy your entire Git repository to a new one, then configure your Source Control configuration on your Retool instance to use the new repository.

### App behavior

The Toolscript migration itself does not change how Retool stores apps, and therefore does not affect the behavior of apps. Similarly, the migration does not affect app releases, history, or queries.

Commits made by builders in Toolscript are functionally equivalent to YAML, with the exception that Toolscript omits default values to produce more readable diffs.
These default values may change across different versions of Retool, but should not lead to significant user experience changes.

## Requirements

To run the migration you must:

- Be on version **3.8.10** or later. See the [errors on earlier versions](#errors-on-versions-pre-3810) section if you're on a version between 3.6.0 and 3.8.10.
- Ensure that branch protection is **disabled** on your SCM provider. Retool requires access to push Toolscript conversion commits directly to your main branch. See [GitHub](https://docs.github.com/en/repositories/configuring-branches-and-merges-in-your-repository/managing-protected-branches/managing-a-branch-protection-rule#deleting-a-branch-protection-rule) and [GitLab](https://docs.gitlab.com/ee/user/project/protected_branches.html#allow-force-push-on-a-protected-branch) documentation to learn how to toggle these settings. You may re-enable branch protection after the migration is complete.
- Notify all Retool builders in your organization that source control operations are blocked during the migration.

If you run multiple instances, you must ensure your instances all use the same main branch to sync code.

## Run migration

To run the migration, go to **Settings > Source Control** and select **Get Toolscript**.

If the migration runs successfully, no additional input is necessary.
You can confirm a migration was successful by navigating to the main branch on your SCM provider. You should see a new commit entitled "Convert to ToolScript v2.0.0" that replaces `*.yml` files with `*.rsx` and other Toolscript files.
Additionally, the `.retool/protected-apps.yml` metadata file should be updated to read `2.0.0`.

If the migration returns an error, you can download logs for the given run from the Source Control settings page.

## Migration errors

Migration logs can help you identify errors which occurred during your migration. To resolve these errors, use one of the following options:

1. Revert or manually fix the changes introducing errors. Many issues are likely malformed YAML. See [troubleshooting](./troubleshooting.mdx#changes-and-environments-no-longer-in-sync) for more guidance.
2. Delete the remote and Retool branch. You can use the following command to delete the remote branch.

```
git push origin --delete yourfeaturebranch
```

To preserve your work, you can [export and import apps or modules](../../apps/guides/app-management/import-export.mdx) using JSON into a new branch after your migration.

When you've fixed or deleted the erroring branches, rerun the migration by selecting **Get Toolscript** on the Source Control settings page.

### Errors on versions pre-3.8.10

If you are migrating to Toolscript on a version earlier than 3.8.10, you may encounter additional migration errors in the following scenarios:

- **Empty branch migration**: If your migration failure logs contain the line `yourfeaturebranch has no changes when compared to yourmainbranch`, the migration has failed because one or more of your feature branches contain no changes to migrate. Upgrade to 3.8.10+ first, or delete these branches using the Git CLI.
- **SCM branch protection**: You may receive a false success message from Retool without a Toolscript conversion commit on your main branch if you have branch protection enabled on your SCM provider. To resolve this situation, click **Deploy Latest** on the Source Control settings page. This immediately unblocks builders and allows commits to be made in YAML. Next, turn off branch protection and upgrade to version 3.8.10+. You can then re-run the migration from the Source Control settings page.

Upgrading to 3.8.10+ is highly recommended to avoid these scenarios.

## Multi-instance procedure

If you deploy multiple instances of Retool connected by the same source control repository, you must follow special procedures to avoid downtime. The steps below assume you have two instances: development ("dev") and production ("prod"). If you do not have a prod instance, designate the instance that is more sensitive to downtime as the prod instance.

The recommended upgrade procedure depends on whether or not your instances sync from the same main Git branch, or use different branches:

:::warning
Each source control branch can contain Toolscript files or YAML files, but not both. As a result, all Retool instances connected by the same branch must be upgraded to support Toolscript at the same time.
:::

1. Confirm that all instances are already on version **3.8.10+** or later. You can choose to follow an incremental upgrade procedure, such as upgrading and verifying the dev instance first. The Toolscript migration only runs when manually triggered.
2. Choose a time during which no builders are using source control to begin the migration. The safest method to do this is to take all instances offline completely. If downtime is unacceptable, an announcement may suffice. Builders lose any commits or branches created during the migration.
3. Log in to the **dev** instance and run the migration from the Source Control settings page. If there are any errors, address them before moving on; your source control repository is not yet affected.
4. To confirm the migration, look for a successful deployment status in the Source Control settings page and a new conversion commit in your source control repository. The `.retool/protected-apps.yaml` file in your repository should also read `2.0.0`. If this is not the case, stop immediately and contact [Retool Support](/support).
5. After the **dev** migration succeeds, log in to the **prod** instance. Since the prod instance syncs from the same branch as dev, you do not need to perform the migration again. Click **Deploy latest** and confirm that the deployment status shows as healthy. The instance should automatically recognize the new Toolscript code.

1. Confirm that all instances are already on version **3.10.2+** or later. Support for different syncing branches is not available in versions 3.10.2 and earlier.
2. Choose a time during which no builders are using source control on the dev instance to begin the migration. The safest method to do this is to take the dev instance offline completely. If downtime is unacceptable, an announcement may suffice. Builders lose any commits or branches created during the migration.
3. Log in to the **dev** instance and click “Get Toolscript” on the Source Control settings page. In the advanced settings section, check the “Exclude certain branches” option and enter in the branches used by your other instances for syncing. For example, if your “prod” instance syncs from the “production” Git branch, add “production” to the exclusion list. Repeat this process for all instances connected by the same repository.
4. Start the migration. If there are any errors, address them before moving on; your source control repository is not yet affected. To confirm the migration, look for a successful deployment status in the Source Control settings page as well as a new conversion commit in your source control repository. The `.retool/protected-apps.yaml` file in your repository should also read `2.0.0`. If this is not the case, stop immediately and contact [Retool Support](/support).
5. All apps on your dev instance should now be in Toolscript, while your production instance still uses a YAML branch. You can test the Toolscript changes on your dev instance before repeating the above steps for your production instance. Before you migrate your production instance, you cannot promote apps from dev to production. If you need to transfer apps, you can export them as JSON from the dev instance and manually import them into your production instance.

## Migrate YAML manually

Though rare, some directories may remain in YAML after the Toolscript migration has completed. For example:

- A developer merged in a YAML feature branch that was not migrated because it exceeded the 2-month and 300 branch limit.
- A developer merged in a YAML feature branch while the Toolscript migration was running.

In these cases, your deployments may fail because there are both Toolscript and YAML format files in the repository. To resolve this situation:

1. Ensure that the `.retool/protected-apps.yaml` file on the main branch of your source control repository reads `2.0.0`. If not, the Toolscript migration has not ran successfully yet.
2. As a precaution, back up your app by [exporting it to JSON](../../apps/guides/app-management/import-export.mdx).
3. Delete the app folder containing YAML from your source control repository and push the change directly to your main branch.
4. Your app should now show as unprotected on your Retool instance. Protect the app through Retool again to generate the correct Toolscript and commit the change to your source control repository.

A similar procedure can be used to manually migrate an unmerged YAML pull request. These steps can only be executed by the pull request author.

1. Ensure that the `.retool/protected-apps.yaml` file on the main branch of your source control repository reads `2.0.0`. If not, the Toolscript migration has not ran successfully yet.
2. Go to the app changed in the pull request and [export it to JSON](../../apps/guides/app-management/import-export.mdx).
3. Start a new branch on the same app and import the JSON obtained in step 1.
4. Create a pull request on this new branch. The format should be Toolscript. You can now close the YAML pull request.

---

## Multi-instance releases

Organizations can manage the releases of [protected apps](./protect/apps.mdx) and [protected workflows](./protect/workflows.mdx) across multiple deployment instances. You can specify which release version of an app or workflow is available on each deployment that's configured with [Source Control](../index.mdx). This is particularly useful if you want to test a newer version on a staging or development instance before promoting to production.

You can also programmatically manage multi-instance releases and manifests using the [Retool API](../../api/index.mdx). Refer to the **Source Control** section of the Retool API reference for complete API documentation.

## Overview

Multi-instance releases makes use of release artifacts and manifests to manage app and workflow releases across instances.

- Each app or workflow release has its own artifact. This represents a snapshot of the element at the time of release. These are stored in the `dist/apps//.zip` or `dist/workflows//.zip` directories of the Source Control repository.
- Each instance has its own release manifest. Each manifest file contains a list of element UUIDs (apps and workflows) and the release version that is made available for the instance. These are stored in the `manifests/` directory of the Source Control repository.

```text title="Example repository structure"
.
├─ .retool/
│   └─ protected-apps.yaml
├─ apps/
│   ├─ app1
|   |   ├─ 0.1.0.zip
|   |   ├─ 0.2.0.zip
|   |   └─ ...
│   ├─ app2
│   └─ ...
├─ workflows/
│   ├─ workflow1
│   └─ ...
├─ dist/
│   ├─ apps/
│   │   ├─ app1-uuid
│   │   ├─ app2-uuid
│   │   └─ ...
│   └─ workflows/
│       ├─ workflow1-uuid
│       └─ ...
└─ manifests/
    ├─ dev.yaml
    └─ prod.yaml
```

As with protected apps and workflows, you do not directly modify files within the repository. You create and manage multi-instance releases using the Retool UI or, optionally, using the Retool API.

## Demo

Watch the following videos that demonstrate how to create and manage manifests and releases.

## Requirements

To use multi-instance releases:

- You must be using Source Control to protect apps and workflows.
- For Retool Cloud, multi-instance releases are available on all plans with Source Control enabled.
- For self-hosted Retool, each instance must be running version 3.252 or later.
- The Source Control configuration must be the same across all instances, such as source control provider, repository, and branch.

:::note
Multi-instance releases with workflows is enabled by default. To opt out, disable **Multi-instance releases: workflows support** in your organization's **Settings > Beta** page. 
:::

## 1. Create a manifest

Each instance needs its own manifest file stored in the `manifests/` directory of the Source Control repository. The manifest determines the version of apps and workflows that are published on the instance. You create and manage manifests in your organization's **Source Control** settings.

To create a manifest:

1. Navigate to your organization's **Settings > Source Control** page.
1. Click **Create manifest** in the **Releases** pane.
1. Enter a name to use for the manifest.
1. Click **Create branch with release manifest**. Retool then creates a branch and commits the new manifest to it.
1. Click **Open pull request** to start a new pull request.

export function CreateManifest() {
  return (
    
      
    
  )
}

## 2. Select the manifest for an instance

A manifest determines which app and workflow releases to publish on an instance. You assign each manifest to each instance. To configure an instance to use a specific manifest:

1. Sign in to a specific instance (e.g., `dev`).
1. Navigate to **Settings > Source Control**.
1. Click **Edit config** in the **Releases** pane on the right.
1. Select the manifest to associate with the instance (e.g., `dev`).

Once complete, the instance will then publish the release versions associated with the manifest. For example:

| Instance | Manifest |
| --- | --- |
| Development | `dev` |
| User testing | `uat` |
| Production | `prod` |

In the example above, apps and workflows defined in the `dev` manifest are published accordingly to the **Development** instance.

## 3. Create a release

To create a new release for an app, open the app in **View** mode—you cannot create a release whilst editing an app. For workflows, see [Version and publish workflows](../../workflows/guides/version-and-publish.mdx).

1. Click the **Releases** button in the status bar. Note that the button displays the release version currently open. If there have not been any previous releases, the app uses `latest` (current working version).
1. Click **Create new** to create a version for release. Retool uses [Semantic Versioning](https://semver.org/) and automatically increments the version number based on your selection of **Major**, **Minor**, or **Patch** versioning.
1. Click **Create release PR** to create a branch and pull request for the release.
1. Confirm that you want to create a branch and release artifact for the new release. Check that the version and description information is correct, then click **Create branch with release artifact**.
1. Click **Open pull request** to begin opening a PR with your source control provider.

export function CreateRelease() {
  return (
    
      
    
  )
}

The new release is only available once the pull request has merged and its changes deployed. Click the **Releases** button in the status bar once this has been completed to view app releases to see the new release available.

## Manage releases

There are two ways with which you can manage releases:

- View and manage the deployment of all app and workflow releases in the **Releases** tab of the **Source Control** settings page.
- View and manage the deployment of individual app or workflow releases in the **Releases and history** modal.

### View and manage all apps and workflows

You can manage multi-instance app and workflow releases and manifests from the **Source Control** settings page. The **Releases** tab is a graphical interface for managing all release manifests. It contains a list of all protected apps and workflows, and the release version deployed to each instance. Each column corresponds to each instance that uses multi-instance releases.

View and manage all apps and workflows.

To change the deployed release version of an app or workflow for any instance:

1. Click on the version number in the column and select the release to use. You can make multiple changes, if required.
1. Click **Review** to review and confirm the changes.
1. Click **Create pull request** to start a new pull request.

### View and manage an individual app or workflow and its releases

Similar to creating a new release, you can use the **Releases and history** modal to manage the release deployment across instances for both apps and workflows. To deploy a release:

1. Click **•••** to open the contextual menu for the release you want to deploy.
1. Select the instance in the **Publish release** sub-menu. All instances with a manifest are automatically listed.

### Patch a release with a hotfix

:::caution

Only one hotfix branch can be created for each `major.minor` release version at a time.

:::

You can create a _hotfix_ to perform a patch update of an app release. This process creates a collaborative hotfix branch based on the selected release for users to make changes. A hotfix enables you to patch any `major.minor` release version without needing to unprotect it first.

Once you complete a hotfix, a patch release is created and made available.

To create a hotfix branch:

1. Click the **Releases** button in the status bar.
1. Find the release to patch.
1. Click **•••** to open the contextual menu and select **Create hotfix**.

After you complete the necessary changes on the hotfix branch, create a new release:

1. Open the  **Releases and History** pane in the left toolbar.
1. Provide a description of the changes made on the hotfix branch and click **Create patch release PR**.
1. Confirm that you want to create a release artifact for the patch release.

export function PatchRelease() {
  return (
    
      
    
  )
}

---

## Protect agents with Source Control

:::note
To enable Source Control for Agents in version 3.284.0 or 3.284.1, reach out to your account manager. 

In version 3.284.2, Source Control for Agents is available by default, and admins can disable it in **Settings > Beta** by toggling the `AI Agents Source Control` feature flag. 
:::

Source Control for [agents](../../../agents/index.mdx) operates similarly to how it does for [apps](./apps.mdx), but with some key differences. 

- **Agents cannot be moved or renamed**. Protected agents and the folders in which they're located cannot be renamed or moved. You must unprotect agents before making name or location changes. Protected agents must have a unique name.
- **Agent triggers cannot be protected**. You can edit the trigger of a protected agent without creating a commit.
- **Evals and Datasets are incompatible**. You cannot access [evals](../../../agents/quickstart.mdx#evals) and [datasets](../../../agents/quickstart.mdx#datasets-and-test-cases) from a protected agent. 

This guide outlines how to make changes to a protected Retool agent and merge these changes into the `main` branch.

## Requirements

Before you begin, ensure [Source Control is configured](../../index.mdx) for your Retool instance. This guide uses GitHub, but Retool supports [multiple remote SCM providers](../../index.mdx#setup-quickstarts). You must be an admin to configure Source Control.

## 1. Protect the agent

In Retool, _protected_ agents are checked into remote source control repositories. You can protect an agent with Source Control from the  dropdown next to the agent name, or from the  dropdown on the [All agents](../../../agents/quickstart.mdx#all-agents) page. 

After reviewing the confirmation modal, click **Protect agent** and create a pull request. Once merged, your agent is protected.

export function ProtectAgents() {
  return (
    
      
    
  )
}

Your agent shows a badge to the right of the name indicating that it is protected. The protected badge will also show next to the agent name on the [All agents](../../../agents/quickstart#all-agents) page. 

:::note

An agent's name serves as a unique identifier when you use Source Control, so you can't rename a protected agent. To change the name of a protected agent, you must [unprotect](#4-remove-agent-protection) the agent, rename it, and re-protect it.

:::

## 2. Create a branch and commit your changes
You can still chat with and view the logs of a protected agent, but to edit an agent's [configuration](../../../agents/quickstart#configuration), you'll need to create a new branch. 

1. Click **Edit**. 
2. Select **Create new branch**. 
3. Give the branch a descriptive name for your changes. You can also select **Allow collaborators** to [allow other users](../collaborative-branches.mdx) to push changes to your branch.
4. Click **Create**. The branch on which you're editing appears in the top right, along with the commit log for the branch. Changes made on branches are local to the branch.
5. Make any necessary changes to your agent. 
6. Click the **Commit** button in the top right corner.
7. Add a commit message to describe the changes you made to the agent. 
8. Optionally, select **Review changes** to preview the changes in your commit.
9. Push your changes to GitHub by clicking **Commit to \**.

export function Commit() {
  return (
    
      
    
  )
}

## 3. Open a pull request and merge

After you commit all the changes you want to make, incorporate your changes back into the `main` branch.

1. Click branch name in the top right corner, and select **Create pull request**.
2. Notice that the description is already populated with a link to preview your changes on your branch. Make any necessary changes, and create the pull request.
3. Merge the changes into the `main` branch of your repository. The merge button label may differ depending on your repository's configuration for merging (e.g., **Rebase and merge** or **Squash and merge**). Confirm the merge if required by your organization. 
4. After a few seconds, your changes are merged into the `main` branch of the agent.

export function Pull() {
  return (
    
      
    
  )
}

## 4. Remove agent protection

You can remove protection for an agent at any time from the `main` branch. 

1. Ensure you are on the `main` branch. 
2. Click the  dropdown next to the agent name to open the contextual menu. 
3. Select **Remove protection** and confirm that you want to remove protection again. 
4. Click **Open a pull request** in GitHub.
5. Create and merge the pull request into `main` to unprotect your agent. 

export function Remove() {
  return (
    
      
    
  )
}

---

## Protect apps with Source Control

This guide outlines the end-to-end workflow required to make changes to a protected Retool app and merge these changes into the `main` branch.

## Requirements

Before you begin, ensure [Source Control is configured](../../index.mdx) for your Retool instance. This guide uses GitHub, but Retool supports [multiple remote SCM providers](../../index.mdx#setup-quickstarts). You must be an admin to configure Source Control.

## 1. Import the app

If you don't have existing Retool apps to edit, you can import the one used in this guide. First, download the [protected-applications-tutorial.json](https://gist.githubusercontent.com/kyle-retool/870978d09d16b6c83cb762fe0c6a866f/raw/a1de7c06d320ee4bd6ee50617fa98ea755d186e4/protected-applications-tutorial.json) file. Once it's saved, import it into Retool.

## 2. Protect the app

In Retool, _protected_ apps are apps checked into remote source control repositories. To protect your app, go to the app IDE and select **...** > **Protect app**.

Click **Protect application** on the confirmation modal. Follow the flow to open and merge the initial PR of the app's source code into the connected GitHub repository.

Your application now shows a badge and **Protected** below its name.

To rename or move an app, go to the home page and select **Rename** from the action menu. You must commit any renaming changes to your SCM provider before they take effect locally.

## 3. Create a branch and make changes

Click **Edit** and select **Create new branch**. Give the branch a descriptive name for your changes. You can also select **Make collaborative** to [allow other users](../collaborative-branches.mdx) to push changes to it.

After you create the branch, you're directed to the app IDE. The branch on which you're editing appears in the lower left, along with the commit log for the branch. Changes made on branches are local to the branch.

Edit your app. In this example, you can update the table's search filter to include searching by email. Update the `tableFilteredData` transformer to the following query.

```javascript
return formatDataAsArray({{getRows.data}}).filter((row)=> row.name.toLowerCase().includes({{nameAndEmailFilter.value}}) || row.email.toLowerCase().includes({{nameAndEmailFilter.value}}) )
```

Rename the placeholder text of the `nameFilter` to **Search by name and email**, and rename `nameFilter` to `nameAndEmailFilter`.

:::note

Images for protected apps are only stored in the database of the instance in which the app was developed. An image uploaded to the database for one app cannot be accessed by downstream environments.

To ensure that an image appears in all instances of your app, you can:

- Host the image on a public URL that is accessible from all apps, and use the **URL** option for the image source.
- Upload the image to the downstream database environments.

:::

## 4. Commit your changes

After you finish making changes, you need to commit them and push them to GitHub.

1. Click the **Commit** button in the top right corner.
2. Optionally, select **Review changes** to preview the changes in your commit.
3. Write a description of your change.
4. Push your changes to GitHub by clicking **Commit to \**.

## 5. Open a pull request

After you commit your changes, open a pull request to get your changes reviewed. Click branch name in the lower left corner, and select **Create pull request**.

Review any dependencies your app has on other protected objects, such as resources or modules. Click **Open pull request** to visit the pull request on GitHub.

Notice that the description is already populated with a link to preview your changes on your branch.

## 6. Merge changes

After you commit your changes, merge them into the main branch of your repository. The merge button label may differ depending on your repository's configuration for merging (e.g., **Rebase and merge** or **Squash and merge**).

After a few seconds, your changes appear in the main branch of the Retool application.

## Remove application protection

You can remove protection for an application at any time. In the application menu on the Apps page, select **Remove protection**, then confirm changes in the dialog box that appears.

---

## Protect queries with Source Control

:::note

Protected queries is available on Retool Cloud and self-hosted Retool version 3.6 or later.

:::

Using protected queries in Source Control, you can safely share queries in Query Library across multiple instances of Retool, similar to protected resources.

## Prerequisites

You must set up your [Source Control](../../index.mdx) provider to start using protected queries.

You also need to be able to protect underlying resources if you want to share queries that depend on resources across instances. See [protected resources](resources.mdx) for more.

## Protect queries

To protect a query and start tracking its changes, you need to merge an initial commit for the query to your remote repository.

### 1. Start protecting a query

You can start protecting your resource by selecting **Protect query** from the dropdown menu.

When you click **Protect query**, Retool creates a new branch on your SCM provider.

> Note that you will see a warning to protect the underlying resource if it is not protected yet. Protected queries will only work across different instances if their resources are also protected and shared.

### 2. Open a new pull request

After you click **Open pull request**, you’ll be redirected to your SCM provider to create an initial commit for the resource. This commit contains a ToolScript file with relevant details for your query.

### 3. Merge pull request

Query is not protected until your repository contains the files from your initial commit. After you merge this commit, the query syncs to all other instances.

## Edit protected queries

Use the following steps to make changes to protected queries.

### 1. Select a branch to edit

When you edit a protected query, you must select a branch to edit. You can either continue on the previously selected branch or create a new branch from the menu.

### 2. Commit your changes

Make your changes to the query and commit your changes by clicking on the **Commit** button on the top right corner. Note that you have to save your changes first before you can commit. If you have unsaved changes, the commit button will be disabled.

### 3. Open and merge a pull request

Once you've committed your changes, open a pull request to get your changes reviewed. Click branch name in the lower left corner, and select **Create pull request**.
You'll be redirected to your SCM provider to open a pull request. Once it's reviewed, you can merge the changes into the main branch of your repository.

After a few seconds, your changes appear in the main branch of the Retool application.

## Unprotect queries

You can unprotect a query by selecting **Unprotect query** from the dropdown menu.

A query must be unprotected before you can delete it.

---

## Protect resources with Source Control

Using protected resources in Source Control, you can safely replicate resource configurations across multiple instances of Retool, similar to protected applications. You can use protected resources with any of Retool's supported source control management (SCM) providers:

- [GitHub](../../tutorials/github.mdx)
- [GitLab](../../tutorials/gitlab.mdx)
- [AWS CodeCommit](../../tutorials/aws-codecommit.mdx)
- [Bitbucket](../../tutorials/bitbucket.mdx)
- [Azure Repos](../../tutorials/azure-repos.mdx)

On Retool Cloud and self-hosted Retool versions 3.6.0 and later, Retool uses ToolScript to serialize resources. On earlier versions of Retool, protected resource configurations are represented as YAML files.

## Prerequisites

Before you configure protected resources, you must set up your [Source Control](../../index.mdx) provider.

If your resources depend on secret values, set the secrets using one of the following:

- Secret [configuration variables](../../../org-users/guides/configuration/config-vars.mdx).
- Secrets manager integration, such as [AWS Secrets Manager](../../../self-hosted/guides/secrets/aws.mdx) or [HashiCorp Vault](../../../self-hosted/guides/secrets/hashicorp-vault.mdx).
- Environment variables with the [`RETOOL_EXPOSED`](../../../self-hosted/reference/environment-variables/index.mdx#retool_exposed_name) prefix.

### Resources in multiple instances

To differentiate resources across instances, set the same variable names with different values per environment. For example, given a resource with different resource URLs for development and prod—e.g., the development URL `dev-api.your-company.com` and prod `prod-api.your-company.com`—you can use the following setup. You'd define URLs in this example in config vars or secrets manager settings, or wherever you store environment variables.

| Type                                   | Example setting             | Example usage in resource config         |
| -------------------------------------- | --------------------------- | ---------------------------------------- |
| `RETOOL_EXPOSED` environment variables | `RETOOL_EXPOSED_YOUR_COMPANY_API_URL` | `%RETOOL_EXPOSED_YOUR_COMPANY_API_URL%`            |
| Config var                             | `your_company_api_url`                | `{{ environment.variables.your_company_api_url }}` |
| Value from secrets manager             | `your_company_api_url`                | `{{ secrets.your_company_api_url }}`               |

The same resource can reference `RETOOL_EXPOSED_YOUR_COMPANY_API_URL`, `{{ environment.variables.your_company_api_url }}`, and `{{ secrets.your_company_api_url }}`, and different URL values are injected for each instance.

## Protect resources

To protect a resource and start tracking its changes, you need to merge an initial commit for the resource to your remote repository.

### 1. Create a branch

You can start protecting your resource by selecting **Protect resource** from either:

- The **Resources** overview page (`/resources`).
- The individual **Edit resource** page.

When you click **Protect Resource**, Retool creates a new branch on your SCM provider.

### 2. Open a new pull request

After you click **Open pull request**, you’ll be redirected to your SCM provider to create an initial commit for the resource. This commit contains a YAML file with configuration details for your resource.

### 3. Merge pull request

Resources are not protected until your repository contains the resource YAML file from your initial commit. After you merge this commit, the resource syncs to all other instances.

## Edit protected resources

When you edit a protected resource, the **Resources** overview and the **Edit resource** pages display a warning that your resource has unmerged changes. This warning displays until you merge your changes to your remote repository.

To create a pull request, click the **Open PR** button next to the resource. Follow your source control workflow to merge the pull request. After it’s merged, you’ll see the resource in all your instances, with the resource updated as necessary.

To rename a resource, from the Resources overview page, select **Rename** next to the resource. You must commit any renaming changes to your SCM provider before they take effect locally.

## Unprotect resources

You can unprotect a resource from either:

- The **Resources** overview page (`/resources`).
- The individual **Edit resource** page.

A resource must be unprotected before you can delete it.

## Protected resources with multiple environments

Only the changes on the _production_ environment of a protected resource are tracked in source control, even if you use multiple environments. This is because multi-instance Retool deployments typically only use a single environment in their downstream (non-development) instances. If your setup uses another configuration, contact Retool Support.

---

## Protect themes with Source Control

Using protected themes in Source Control, you can safely replicate [organization-level theme configurations](../../../apps/guides/presentation-styling/themes.mdx) across multiple instances of Retool. You can use protected themes with any of Retool's supported source control management (SCM) providers:

- [GitHub](../../tutorials/github.mdx)
- [GitLab](../../tutorials/gitlab.mdx)
- [AWS CodeCommit](../../tutorials/aws-codecommit.mdx)
- [Bitbucket](../../tutorials/bitbucket.mdx)
- [Azure Repos](../../tutorials/azure-repos.mdx)

Protected themes work similarly to protected apps or resources, with a few key differences. Keep in mind the following considerations:

- _Themes cannot be deleted or renamed._ Protected themes cannot be renamed or deleted. You must unprotect themes before making deletions or name changes.
- _Changes are branchless._ Unlike with Retool apps, you do not create a branch from which to make changes. Instead, you create a pull request from the theme IDE after you make changes.

## Prerequisites

Before you configure protected themes, you must set up your [Source Control](../../index.mdx) provider.

## Protect themes

To protect a theme and start tracking its changes, you need to merge an initial commit for the theme to your remote repository. Complete the following steps.

1. Navigate to an organization-level theme and select **Protect theme** from the menu `•••`.
2. Confirm by clicking the **Protect theme** button. At this point Retool creates a new branch on your SCM provider.
3. Click the **Open pull request** button. You'll be redirected to your SCM provider to create an initial commit for the theme. This commit contains a JSON file with configuration details for your theme. Themes are not protected until your repository contains the JSON file from your initial commit.
4. Create the pull request and merge the commit. After you merge this commit, the theme syncs to all other instances.

The following example shows this process using GitHub as the SCM.

## Edit protected themes

When you edit a protected theme, you must click **Save** and click the **Open PR** button next to the theme to commit your changes. Follow your source control workflow to merge the pull request. After it’s merged, you’ll see the theme in all your instances, with the theme updated as necessary.

:::note

While protected themes are managed using source control, you do not create a separate branch on which to make changes.

:::

## Unprotect themes

Use the same process to unprotect a theme as you did to [protect it](#protect-themes).

A theme must be unprotected before you can delete it or rename it.

---

## Protect workflows with Source Control

This guide outlines how to use Source Control to protect workflows.

:::note

Protected workflows and the folders in which they're located cannot be renamed or moved. You must unprotect workflows before making name or location changes. Protected workflows must have a unique name.

:::

## Requirements

Before you begin, ensure [Source Control is configured](../../index.mdx) for your Retool instance. This guide uses GitHub, but Retool supports [multiple remote SCM providers](../../index.mdx#setup-quickstarts). You must be an admin to configure Source Control.

## 1. Protect the workflow

In Retool, _protected_ workflows are workflows checked into remote source control repositories. You can protect a workflow with Source Control in either the **Workflows** tab of your organization or the workflow IDE:

- **Workflows tab**: Click `•••` to open the contextual menu for the workflow you want to protect, then select **Protect workflow**.
- **Workflow IDE**: Click `•••` in the toolbar to open the contextual menu, then select **Protect workflow**.

After reviewing the confirmation modal, click **Protect workflow** and create a pull request. Once merged, your workflow is protected.

export function ProtectWorkflow() {
  return (
    
      
    
  )
}

Your workflow now shows a badge to the right of the name indicating that it is protected.

:::note

An workflow's name serves as a unique identifier when you use Source Control, so you can't rename a protected workflow. To change the name of a protected workflow, you must [unprotect](#remove-workflow-protection) the workflow, rename it, and re-protect it.

:::

## 3. Create a branch and make changes

Click **Edit** and select **Create new branch**. Give the branch a descriptive name for your changes. You can also select **Make collaborative** to [allow other users](../collaborative-branches.mdx) to push changes to it.

After you create the branch, you're directed to the workflow IDE. The branch on which you're editing appears in the lower left, along with the commit log for the branch. Changes made on branches are local to the branch.

Edit your workflow.

export function CreateBranch() {
  return (
    
      
    
  )
}

## 4. Commit your changes

After you finish making changes, you need to commit them and push them to GitHub.

1. Click the **Commit** button in the top right corner.
2. Write a description of your change.
3. Optionally, select **Review changes** to preview the changes in your commit.
4. Push your changes to GitHub by clicking **Commit to \**.

export function CommitChanges() {
  return (
    
      
    
  )
}

## 5. Open a pull request and merge

After you commit all the changes you want to make, incorporate your changes back into the `main` branch.

1. Click branch name in the lower left corner, and select **Create pull request**.
2. Review any dependencies your workflow has on other protected objects, such as resources. Click **Open pull request** to visit the pull request on GitHub.
3. Notice that the description is already populated with a link to preview your changes on your branch. Make any necessary changes, and create the pull request.
4. Merge the changes into the `main` branch of your repository. The merge button label may differ depending on your repository's configuration for merging (e.g., **Rebase and merge** or **Squash and merge**).
5. After a few seconds, your changes are merged into the `main` branch of the workflow. [Publish a release](../../../workflows/guides/version-and-publish.mdx) for your changes to be reflected in the workflow's live release.

export function MergeChanges() {
  return (
    
      
    
  )
}

## Multi-instance releases

If your organization manages multiple deployment instances (such as development, staging, and production), you can use [multi-instance releases](../multi-instance-releases.mdx) to control which version of a protected workflow is deployed to each instance.

With multi-instance releases, you can:

- Test new workflow versions on development or staging instances before promoting to production.
- Deploy different versions of workflows to different instances.
- Manage workflow releases across instances using release manifests.

:::note
Multi-instance releases with workflows is enabled by default. To opt out, disable **Multi-instance releases: workflows support** in your organization's **Settings > Beta** page. Learn more about [multi-instance releases](../multi-instance-releases.mdx).
:::

## Remove workflow protection

You can remove protection for a workflow at any time in either the **Workflows** tab of your organization or the workflow IDE:

- **Workflows tab**: Click `•••` to open the contextual menu for the workflow you want to protect, then select **Remove protection**.
- **Workflow IDE**: Click `•••` in the toolbar to open the contextual menu, then select **Unprotect workflow**. You can also choose to **Unprotect triggers** if you want to remove protection from your workflow triggers.

Confirm changes in the dialog box that appears.

---

## Test Source Control deployments

Test deployments serve as a method to confirm that a pull request can be successfully deployed to Retool. They perform a "dry run" of your changes, ensuring that the modifications can be applied to your Retool instance without encountering errors.

The following video shows an overview of how the test deployment process works:

In this guide, we’ll refer to a placeholder Retool organization at `https://exampleorg.retool.com`. Be sure to substitute this placeholder with the actual URL where your Retool instance is hosted. Additionally, replace `RETOOL_TEST_DEPLOY_API_KEY` with your access token.

## Create an access token

Complete the following steps to create an access token with permissions for test deployment:

1. Navigate to **Settings** > **Retool API** and click **Create new**.
2. Enter a name and description for your new access token.
3. Select the `Read` and `Test Deploy` scopes from the **Source Control** section.
4. Click **Create token** and save the API key.

## Using the Test Deploy endpoint

Use the [Test source control changes](../../api/test-source-control-changes.api.mdx) endpoint in the Retool API to check whether a commit can be successfully deployed. Pass the full commit SHA to the endpoint:

```bash
curl -X POST -H "Content-Type: application/json" \
  -H "Authorization: Bearer " \
  -d '{"deploy_params": {"commit_sha": ""}}' \
  http://exampleorg.retool.com/api/v2/source_control/test_deploy
```

## Add a CI check

You can also add a check that runs the test deploy as part of your continuous integration process.

This section includes an example that uses GitHub as the source control provider and Buildkite as the CI/CD provider, although the steps outlined here can be applied to any Git-based hosting service.

### Using Github Actions

Follow [GitHub's guide on storing information in variables](https://docs.github.com/en/actions/learn-github-actions/variables) to configure the `RETOOL_TEST_DEPLOY_API_KEY` environment variable on GitHub. The following code snippet shows an example of a workflow file

```yaml
on:
  pull_request:
    types: [opened, synchronize, reopened]

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Test Deploy Commit
        run: |
          COMMIT_SHA="${{ github.event.pull_request.head.sha }}"
          echo "Test deploying commit $COMMIT_SHA on https://exampleorg.retool.com/"
          response=$(curl -X POST -H "Content-Type: application/json" -H "Authorization: Bearer ${{ secrets.RETOOL_TEST_DEPLOY_API_KEY }}" -d "{\"deploy_params\": {\"commit_sha\": \"$COMMIT_SHA\"}}" https://exampleorg.retool.com/api/v2/source_control/test_deploy)
          echo "API Response:"
          echo "$response"
          if [[ $(echo $response | jq '.data.success') != "true" ]]; then
            echo "Test deployment failed"
            exit 1
          fi
```

### Using Buildkite

Follow Buildkite's [Managing pipeline secrets guide](https://buildkite.com/docs/pipelines/secrets) to set the `RETOOL_TEST_DEPLOY_API_KEY` environment variable on Buildkite. Add the following command to your `pipeline.yml` file.

```yaml title="pipeline.yml"
steps:
  - command: scripts/run_test_deploy.sh
```

Buildkite [recommends](https://buildkite.com/docs/pipelines/secrets#anti-pattern-referencing-secrets-in-your-pipeline-yaml) that you avoid directly referencing secrets in your `pipeline.yml` file. Instead, utilize a script stored in your repository for this purpose:

```bash title="scripts/run_test_deploy.sh"
#!/bin/bash
set -euo pipefail

COMMIT_SHA=$BUILDKITE_COMMIT
echo "Deploying commit SHA $COMMIT_SHA on https://exampleorg.retool.com/settings/api/v2/source_control/test_deploy"
response=$(curl -X POST -H "Content-Type: application/json" -H "Authorization: Bearer $RETOOL_TEST_DEPLOY_API_KEY" -d "{\"deploy_params\": {\"commit_sha\": \"$COMMIT_SHA\"}}" https://exampleorg.retool.com/settings/api/v2/source_control/test_deploy)
echo "API Response:"
echo "$response"
if [[ $(echo $response | jq '.data.success') != "true" ]]; then
  echo "Test deployment failed"
  exit 1
fi
```

---

## Troubleshoot Source Control issues

With Source Control, your Retool instance syncs and deploys changes made to the designated main branch of your Git repository. As an administrator, you can diagnose and troubleshoot most Source Control issues.

## Identify Source Control issues

Issues that arise with Source Control should be resolved quickly to minimize disruption. There are a number of methods available for identifying symptoms as you investigate the root cause.

### Deployment Dashboard

Use [Deployment Dashboard](./manage-deployment.mdx#source-control-status) to check the status of deployments and the SCM connection. Each deployment has either a successful or failed state. Failed deployments can indicate a potential issue with Source Control, such as malformed repository contents or an inconsistent Git history.

Kicking off a [full deployment](./manage-deployment.mdx#full-and-partial-deployments) by clicking **Deploy latest** updates all protected elements in your Retool instance to the latest state of your main branch. This overrides and can help fix failing intermediary partial deployments.

The SCM details area displays the current connection status. If the status is not **Connected**, this indicates that your Retool instance is not able to connect to your SCM provider. To resolve the connection, verify your SCM configuration by clicking **Edit config**, environment variables, and if using GitHub, your Base64-encoding of your private key.

### Changes and environments no longer in sync

There may be issues with Source Control if there is a mismatch between the current state of your Retool instance and the main branch of your Git repository. This can be apparent if protected apps, modules, or resources fail to update. When these issues occur, they can prevent newer changes from being deployed, resulting in the changes being overwritten. New objects cannot be protected return an error or indicate an `unmerged` status.

Similarly, if changes from one Retool instance are not in sync with others (e.g., `dev` to `prod`) then there may be an issue somewhere in the Source Control workflow.

### jobs-runner instability

If Source Control cannot successfully deploy changes, it may cause the [jobs-runner](../../self-hosted/concepts/architecture.mdx) container to continuously crash or restart. This container performs background tasks, such as Source Control syncing, and database migrations.

You can also monitor the status of the `jobs-runner` container using its health check endpoint: `http://[container_ip]:3003/api/checkJobsRunnerHealth`.

## Resolve common Source Control issues

For Source Control to operate:

- The Git repository and its contents must have a stable history and valid file contents.
- Both your Retool instance and your source control management (SCM) provider must be configured correctly.
- Retool must be able to connect to your SCM provider.

Any problems or disruptions that affect these dependencies can impact the operation of Source Control.

### Git repository and content

Retool instances periodically poll your Git repository for new commits and attempt to apply changes. If the integrity of the Git repository is affected, such as invalid or malformed data, your Retool instance may fail to deploy successfully.

#### Malformed data

Source Control breaks up applications into multiple YAML files to simplify code review and prevent merge conflicts. Invalid changes to YAML files can prevent successful deploys. Possible YAML issues include:

- **Invalid formatting**. Manually adding commits, or editing commits automatically generated by Retool, can introduce formatting errors (e.g., different whitespace or tab settings).

If there appears to be malformed data or invalid files, you need to identify which commits contain the malformed files.

First, identify the commit with malformed files. You can do this by either:

- Using the Deployment Dashboard to identify the commit of the first failing build.
- Reviewing recent commits in the Git history with the SCM provider. This may be the most recent commit if you're able to respond to the issue quickly.
- Reviewing the `jobs-runner` container logscontainer logs for lines with the terms `Target sha`, `SOURCE_CONTROL_DEPLOYMENT`, and `error`.

Next, revert or fix-forward the offending commit. You can revert the commit and push the reversion to your Git repository to roll back the change. To preserve the changes, you can fix-forward by correcting the error as a new commit.

Finally, run a full deployment. You can perform this using the Deployment Dashboard by clicking **Deploy latest**. Retool instances using Self-hosted Retool earlier than v2.97 must restart the `jobs-runner` container manually.

#### Inconsistent Git history

Retool requires a linear, append-only Git history, and tracks the latest commit SHA at all times. If the Git history is rewritten manually (e.g., `git push --force`, `git rebase -i`, or `git reset`), the commit currently tracked by Retool may no longer exist. Retool may attempt to open an invalid commit with the SCM provider, which will return an error.

If the Git history has been rewritten manually, one way to resolve this is to:

1. Export any apps as [JSON](../../apps/guides/app-management/import-export.mdx#export-apps) that cannot be pushed using the Retool UI.
2. Create a new branch in the Retool UI and import the exported JSON.
3. Retry the commit and push operations.
4. Verify that the generated pull request contains all relevant changes.

#### Unexpected files

The file system structure in the Git repository must match the expected directory structure of your Retool instance. Any unknown files added to the repository, or moving existing files to different locations unexpectedly, can cause deploys to fail. Non-YAML files that may be autogenerated by operating systems, such as `.DS_Store`, can also impact the repository's integrity.

If unexpected files have been added to the repository, remove them and commit the changes.

### Instance configuration

Retool uses [environment variables](../../self-hosted/reference/environment-variables/index.mdx) to configure deployments on self-hosted Retool. Any misconfigured environment variables can cause issues with your Retool instance.

#### SCM and repository connection

The Deployment Dashboard reflects the connection status to the SCM provider. If this reports a failed connection, check that the connection details are correct.

Source Control requires the full URL for some SCM providers. If you are using one of these SCM providers, make sure to include the full `http/https` URL.

#### Nested repositories

Some SCM providers support nested repositories (e.g., GitLab). If the path is incorrect, the Deployment Dashboard indicates a successful connection but Source Control is not syncing from the correct repository path. If you are using nested repositories, check the repository details use the full path.

### SCM configuration

Retool requires read and write permissions for branches, commits, and pull requests. Incorrect permissions can prevent Retool from creating new protected objects or editing existing ones. Refer to the [Source Control](../index.mdx) documentation for your SCM provider to learn what permissions are required and how to configure them.

#### Infrastructure instability

Infrastructure failures or instability can be caused by a misconfigured environment. There can be many reasons for this, but common root causes include:

- **Minimum resource requirements not met**. Each Retool instance requires 4+ CPU cores and 4GB+ of memory. As your organization grows, the number of commits or concurrent users increases, which requires more resources. If your Retool instances lack resources, the `jobs-runner` container performance degrades and can become unresponsive. When Retool detects that the `jobs-runner` container is not responsive, it can automatically restart the container in some deployment modes (e.g., Retool Kubernetes Helm chart).
- **Network firewall restrictions**. Retool requires an open connection directly to your SCM provider. If your firewall blocks these connections, Git operations may become unresponsive or time out. You can use the Deployment Dashboard to check the connection to your SCM provider by clicking **Test connection**.

### OAuth callback URL

If you see issues with the OAuth callback URL for protected resources, make sure:

1. The `BASE_DOMAIN` environment variable is persisted on both the `api` and `jobs-runner` containers.
2. Both the `api` and `jobs-runner` containers were rebooted.
3. The source control repo is redeployed through the `/settings/sourcecontrol`.

### Image display

Images for protected apps are only stored in the database of the instance in which the app was developed. An image uploaded to the database for one app cannot be accessed by downstream environments.

If an image does not appear where you expect it to in your protected app, you can:

- Host the image on a public URL that is accessible from all apps, and use the **URL** option for the image source.
- Upload the image to the downstream database environments.

---

## Source Control how-to guides

import Howto from '/docs/_partials/_doctypes/_howto.mdx';

:::tip Get started with Source Control

If you want to get started with Source Control at Retool:

- Read the [quickstart](./quickstart) to learn about the fundamental concepts.
- Follow a [tutorial](./tutorial/) to set up Source Control with an SCM provider.

:::

---

## Source Control documentation

Source Control allows organizations to manage changes to apps, workflows, resources, and themes using pull requests on remote source control management (SCM) providers, such as GitHub, GitLab, AWS CodeCommit, Bitbucket, and Azure Repos. Instead of making changes directly to an app, changes are made on a separate branch.

---

## Source Control quickstart

This guide serves as an introduction to Source Control. It covers many of the concepts and terminology you would come across when using version control to manage apps, workflows, and more. After reading this page, you should have a good understanding of the fundamentals for using Source Control.

## Introduction

Source Control enables organizations to manage changes using remote source control management (SCM) providers, such as GitHub, GitLab, AWS CodeCommit, Bitbucket, and Azure Repos. Using this distributed approach, your users can:

- Protect changes to apps, workflows, queries, resources, and themes.
- Work collaboratively on apps.
- Review changes using [Toolscript](concepts/toolscript.mdx)—a readable, JSX-like markup language.
- Sync changes across [multiple instances](concepts/multi-instance-development.mdx).

## Version control and protection

Source Control provides a distributed approach to managing your organization using a remote repository. Users can check in (protect) apps, workflows, queries, resources, and themes. Once protected, all changes are made on branches. Users can create multiple branches and work collaboratively on changes.

All of this occurs within Retool. Reviewers then use the source control provider (e.g., GitHub) to review the pull request. Once merged, Retool deploys the changes automatically.

## Monitor deployment status

The Deployment Dashboard provides details about recent deployments triggered by Source Control. It includes details about your instance's Source Control configuration.

As with any version control system, you can roll back changes by reverting to an earlier commit.

## Collaborate on app changes

[Collaborative branches](guides/collaborative-branches.mdx) enables multiple users to make app changes on the same branch.

## Get started

Set up Source Control using a supported SCM provider.

import DocCardList from "@theme/DocCardList";

---

## Source Control environment variables

import SourceControl from "@site/docs/self-hosted/reference/environment-variables/source-control.mdx";

---

## Source Control glossary

## A

## B

## C

## D

## E

## F

## G

## H

## I

## J

## K

## L

## M

## N

## O

## P

## Q

## R

## S

## T

## U

## V

## W

## X

## Y

## Z

---

## Organization and users reference

import Reference from '/docs/_partials/_doctypes/_reference.mdx';

:::tip Get started with your organization and users

If you are unfamiliar with managing your organization and want to get started, read the [quickstart](./quickstart) to learn about the fundamental concepts.

:::

---

## Configure Source Control with AWS CodeCommit

## Setup instructions

### Disable git syncing

If you've enabled [Git Syncing](../index.mdx), disable it:

- In your `docker.env` file, set `DISABLE_GIT_SYNCING=true` and `VERSION_CONTROL_LOCKED=false`.
- In the **Settings** > **Advanced** tab in Retool, remove the repository URL and branch name from your Git Syncing configuration.

### 1. Create a new IAM Role in your AWS account

Enter a name for the user and check the **Access key - Programmatic access** setting.

Next, select **Attach existing policies directly**, search for "codecommit", and select the **AWSCodeCommitFullAccess** policy name. This is the only permission required for this new user.

Save the **Access key ID** and **Secret access key** in a secure location locally. You'll use these as environment variables in step 3.

Go to the newly created user on your IAM console. Select the **Security credentials** tab, scroll to **HTTPS Git Credentials for AWS CodeCommit**, and click **Generate Credentials**. Download and save these credentials in a secure location. You'll use these HTTPS credentials as environment variables in step 3.

### 2. Create a new CodeCommit repository

Go to CodeCommit on your AWS console and create a new repository for Retool syncing. You can select any region of your preference.

Add a `README.md` file to this repository. The repository needs to contain at least one file to sync.

### 3. Configure AWS CodeCommit repository settings

Go to the [Source Control settings](https://login.retool.com/auth/login?source=docs&redirectOnLogin=settings/source-control), and select **Set up AWS CodeCommit**. Enter the following settings.

| **Setting**               | **Description**                                    | **Example**           |
| ------------------------- | -------------------------------------------------- | --------------------- |
| AWS CodeCommit Repository | The name of the CodeCommit repository.             | retool-apps           |
| AWS CodeCommit Branch     | The default branch for your CodeCommit repository. | main                  |
| AWS Region                | The region of the CodeCommit repository.           | us-east-1             |
| Access Key Id             | The **Access key ID** you generated in step 1.     | AKIAWS3BACWHP6QW6VB2  |
| Secret Access Key         | The **Secret access key** you generated in step 1. | loDJlwRetoolTYXOFbO   |
| HTTPS Username            | The HTTPS username you generated in step 1.        | retool-https-username |
| HTTPS Password            | The HTTPS password you generated in step 1.        | retool-https-password |

Set the following [environment variables](../../self-hosted/reference/environment-variables/index.mdx#source-control) on your Retool instance on the `api` and `jobs-runner` containers.

| **Variable name**                 | **Description**                                    | **Example value**     |
| --------------------------------- | -------------------------------------------------- | --------------------- |
| CODE_COMMIT_AWS_ACCESS_KEY_ID     | The **Access key ID** you generated in step 1.     | AKIAWS3BACWHP6QW6VB2  |
| CODE_COMMIT_AWS_SECRET_ACCESS_KEY | The **Secret access key** you generated in step 1. | loDJlwRetoolTYXOFbO   |
| CODE_COMMIT_AWS_DEFAULT_REGION    | The region of the CodeCommit repository.           | us-east-1             |
| CODE_COMMIT_REPOSITORY_NAME       | The name of the CodeCommit repository.             | retool-apps           |
| CODE_COMMIT_MAIN_BRANCH           | The default branch for your CodeCommit repository. | main                  |
| CODE_COMMIT_HTTPS_USERNAME        | The HTTPS username you generated in step 1.        | retool-https-username |
| CODE_COMMIT_HTTPS_PASSWORD        | The HTTPS password you generated in step 1.        | retool-https-password |

If you use your own [SSL certificates](../../self-hosted/guides/certificates.mdx), set the `SSL_CERT_FILE` and `NODE_EXTRA_CA_CERTS` environment variables on the `jobs-runner` and `api` containers to the path to your SSL certificate.

### 4. Verify your settings

After you set up your environment variables, visit the **Settings** > **Source Control** on your Retool instance.

If your environment is correctly configured, the page will show a **Deployment Dashboard**. Click **Test connection** under the **AWS CodeCommit** section to test your connection and confirm the sync works as expected.

If you don't see the Deployment Dashboard and your AWS CodeCommit commits, go back to step 3 and confirm your environment variables are correctly set.

You are now ready to use source control with AWS CodeCommit. Read the [source control getting started guide](../index.mdx) to learn more about source control workflows.

---

## Configure Source Control with Azure Repos

With Source Control with [Azure Repos](https://azure.microsoft.com/en-us/products/devops/repos), you can use pull requests on [Azure Repos](https://azure.microsoft.com/en-us/products/devops/repos#get-started) to manage changes to your Retool applications.

## Setup instructions

### Disable git syncing

If you've enabled [Git Syncing](../index.mdx), disable it:

- In your `docker.env` file, set `DISABLE_GIT_SYNCING=true` and `VERSION_CONTROL_LOCKED=false`.
- In the **Settings** > **Advanced** tab in Retool, remove the repository URL and branch name from your Git Syncing configuration.

### Prerequisites

This guide requires access to an Azure DevOps account with permissions to create repos and access tokens.

### 1. Create a new repository in Azure Repos

1. [Create or use an existing project under Azure Repos](https://learn.microsoft.com/en-us/azure/devops/organizations/projects/create-project?view=azure-devops&tabs=browser). Ensure its name does not contain any spaces.
2. [Create a new Git repository under Azure Repos](https://learn.microsoft.com/en-us/azure/devops/repos/git/create-new-repo?view=azure-devops) for your Retool apps. Ensure that it has a `README.md` file at the root level directory.

### 2. Create a personal access token

1. [Create an Azure Repos personal access token](https://learn.microsoft.com/en-us/azure/devops/organizations/accounts/use-personal-access-tokens-to-authenticate?view=azure-devops&tabs=Windows).
2. Under the **Code** section, check **Full** and **Status**. With this token, Retool will be able to programmatically manipulate your repository, generate pull requests, and see their statuses. Accordingly, use the most appropriate admin in your organization to generate it.

### 3. Configure Azure repository settings

Go to the [Source Control settings](https://login.retool.com/auth/login?source=docs&redirectOnLogin=settings/source-control), and select **Set up Azure Repos**. Enter the following settings.

| **Setting**           | **Description**                                                                                                                                                            | **Example**                                                |
| --------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------- |
| Azure Repository      | The repo name from step 1. Ensure this name does not contain any spaces.                                                                                                   | retool-apps                                                |
| Azure Organization    | The Azure DevOps organization.                                                                                                                                             | acme-co                                                    |
| Azure Branch          | Retool automatically tracks changes to this branch.                                                                                                                        | main                                                       |
| Azure Project         | The new or existing Azure DevOps project from step 1. Ensure its name does not contain any spaces.                                                                         | proj-retool                                                |
| Azure User            | The Azure Repos username.                                                                                                                                                  | retool                                                     |
| Azure URL             | Your base Azure URL. For Azure Cloud, this is always [http://dev.azure.com](http://dev.azure.com/). For Azure self-managed, this is the URL where your instance is hosted. | [https://azure.mycompany.com](https://azure.mycompany.com) |
| Personal Access Token | The Azure [project access tokens](https://docs.searchunify.com/Content/Content-Sources/Azure-Generate-Personal-Access-Token.htm) to authenticate to the Azure API.         | AKIAWS3BACWHP6QW6VB2                                       |
| Use Basic Auth        | Set this to true if you are using self-hosted Azure Repos.                                                                                                                 | true                                                       |

| **Variable**                        | **Description**                                                                                    | **Example**                                          |
| ----------------------------------- | -------------------------------------------------------------------------------------------------- | ---------------------------------------------------- |
| `AZURE_REPOS_USER`                  | The Azure Repos username                                                                           | retool                                               |
| `AZURE_REPOS_PERSONAL_ACCESS_TOKEN` | The personal access token generated previously                                                     | mpoqd2zy7jklzfbhmuzev46vbbcpkeeqminb4wcvwigsrldasdfa |
| `AZURE_REPOS_ORGANIZATION`          | The Azure DevOps organization                                                                      | acme-co                                              |
| `AZURE_REPOS_PROJECT`               | The new or existing Azure DevOps project from step 1. Ensure its name does not contain any spaces. | proj-retool                                          |
| `AZURE_REPOS_REPO`                  | The repo name from step 1. Ensure its name does not contain any spaces.                            | retool                                               |
| `AZURE_REPOS_MAIN_BRANCH`           | Retool automatically tracks changes to this branch                                                 | main                                                 |

If you use your own [SSL certificates](../../self-hosted/guides/certificates.mdx), set the `SSL_CERT_FILE` and `NODE_EXTRA_CA_CERTS` environment variables on the `jobs-runner` and `api` containers to the path to your SSL certificate.

### 4. Test your configuration

After you set up your environment variables, if you’re an admin on your Retool instance, you can visit **Settings** > **Source Control**.

If your Azure Repos environment is correctly configured, the page will show your Azure Repos commits in the **Deployment Dashboard** section. You can also click the **Test connection** button, which sends a request to test the connection.

If you don't see the **Deployment Dashboard** and your Azure Repos commits on **Settings** > **Source Control**, check that your environment variables are correctly configured.

## What's next?

You are now ready to use source control. Learn how to create branches and pull requests, merge changes, and use other source control features in the [getting started guide](../index.mdx).

---

## Configure Source Control with Bitbucket

You can use Source Control with [Bitbucket Cloud](https://bitbucket.org) to manage changes with pull requests.

:::note
Source Control does not currently support self-hosted [Bitbucket Data Center](https://www.atlassian.com/software/bitbucket/enterprise/data-center) instances.
:::

## Setup instructions

- In your `docker.env` file, set `DISABLE_GIT_SYNCING=true` and `VERSION_CONTROL_LOCKED=false`.
- In the **Settings** > **Advanced** tab in Retool, remove the repository URL and branch name from your Git Syncing configuration.

### Prerequisites

This guide requires access to a Bitbucket account with permissions to create workspaces and repositories.

### 1. Create a new Bitbucket workspace and repository

1. [Create a Bitbucket workspace](https://support.atlassian.com/bitbucket-cloud/docs/create-your-workspace/) for your Retool repository.
2. [Create a Git repository in Bitbucket](https://support.atlassian.com/bitbucket-cloud/docs/create-a-git-repository/) for your Retool apps.

### 2. Create an access token for the repository

1. [Create a Bitbucket access token for the repository](https://support.atlassian.com/bitbucket-cloud/docs/create-a-repository-access-token/).
2. Under **Scopes** > **Repositories**, select **Read**, **Write**, **Admin**, and **Delete**. This gives the access token the ability to access and modify the repository containing your Retool apps.

### 3. Configure Bitbucket repository settings

Go to the [Source Control settings](https://login.retool.com/auth/login?source=docs&redirectOnLogin=settings/source-control), and select **Set up Bitbucket**. Enter the following settings.

| **Setting**                  | **Description**                                                                                          | **Example**                     |
| ---------------------------- | -------------------------------------------------------------------------------------------------------- | ------------------------------- |
| Bitbucket Workspace          | The name of the workspace you created for the Retool repository. This variable is case-sensitive.        | `retool-workspace`              |
| Bitbucket Repository         | The repo name in step 2.                                                                                 | `retool-apps`                   |
| Bitbucket Branch             | Retool automatically tracks changes to this branch                                                       | `main`                          |
| Bitbucket URL                | The domain used to access your self-hosted Bitbucket instance.                                           | `https://bitbucket.org/`        |
| Bitbucket Enterprise API URL | The REST API route for your self-hosted Bitbucket instance. Defaults to `https://api.bitbucket.org/2.0`. | `https://api.bitbucket.org/2.0` |
| Bitbucket Access Token       | The access token you created.                                                                            | `loDJlwRetoolTYXOFbO`           |

Set the following [environment variables](../../self-hosted/reference/environment-variables/index.mdx#source-control) on your Retool instance on the `api` and `jobs-runner` containers.

| **Variable**            | **Description**                                                                           | **Example**         |
| ----------------------- | ----------------------------------------------------------------------------------------- | ------------------- |
| `BITBUCKET_TOKEN`       | The access token you generated in [step 2](#2-create-an-access-token-for-the-repository). | loDJlwRetoolTYXOFbO |
| `BITBUCKET_WORKSPACE`   | The workspace name in step 2. This variable is case-sensitive.                            | retool-space        |
| `BITBUCKET_REPO`        | The repo name in step 2                                                                   | retool-apps         |
| `BITBUCKET_MAIN_BRANCH` | Retool automatically tracks changes to this branch                                        | main                |

If you use your own [SSL certificates](../../self-hosted/guides/certificates.mdx), set the `SSL_CERT_FILE` and `NODE_EXTRA_CA_CERTS` environment variables on the `jobs-runner` and `api` containers to the path to your SSL certificate.

### 4. Test your configuration

After you set up your environment variables, if you’re an admin on your Retool instance, you can visit **Settings** > **Source Control**.

If your Bitbucket environment is correctly configured, the page will show your Bitbucket commits in the **Deployment Dashboard** section. You can also click the **Test connection** button, which sends a request to test the connection.

If you don't see the **Deployment Dashboard** and your Bitbucket commits on **Settings** > **Source Control**, check that your environment variables are correctly configured.

## What's next?

You are now ready to use source control. Learn how to create branches, pull requests, merging changes, and use other source control features in the [getting started guide](../index.mdx).

---

## Configure Source Control with GitHub

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

You can use Source Control with GitHub to manage changes using pull requests. You create a repository for Source Control to use, then configure a GitHub App for your Retool instance that commits, pushes, and pulls changes.

## Requirements

To configure Source Control with GitHub, you must have:

- Administrator permissions in your Retool organization.
- Permissions to [create an app](https://github.com/settings/apps/new) in GitHub.

## 1. Create a Git repository

:::warning

Use a new, dedicated Git repository. Source Control does not work with an existing [Git Syncing](../index.mdx) repository.

:::

To begin, [create a new repository](https://docs.github.com/en/free-pro-team@latest/github/getting-started-with-github/create-a-repo) for Source Control. Ensure it contains a **README.md** file and a `main` branch. Source Control uses this repository to store and track all changes.

If you have [multiple Retool instances](../concepts/multi-instance-development.mdx), use this same repository across all instances.

## 2. Create and install a GitHub App

[Create a GitHub App](https://github.com/settings/apps/new) with the following settings. Ensure this app is created by the same owner as the Git repository. Refer to [GitHub's guide](https://docs.github.com/en/developers/apps/creating-a-github-app) for more information.

If you have [multiple Retool instances](../concepts/multi-instance-development.mdx), use this same GitHub App across all instances.

| Setting                                                    | Value                                                       |
| ---------------------------------------------------------- | ----------------------------------------------------------- |
| **GitHub App name**                                        | The name of your GitHub App.                                |
| **Homepage URL**                                           | The URL of your GitHub App. This field is unused by Retool. |
| **Expire user authorization tokens**                       | Unchecked                                                   |
| **Request user authorization (OAuth) during installation** | Unchecked                                                   |
| **Webhook** > **Active**                                   | Unchecked                                                   |
| **Permissions** > **Contents**                             | Read and write                                              |
| **Permissions** > **Pull requests**                        | Read and write                                              |
| **Where can this GitHub App be installed?**                | Only on this account                                        |

### Install the GitHub App

After you create your GitHub App, it should appear in the [GitHub Apps section of your Developer Settings](https://github.com/settings/apps).

To install your GitHub App:

1. Click **Edit** next to your app to see its settings.
2. Click on **Install App**.
3. Click the **Install** button next to your organization.
4. Choose the **Only select repositories** option and select the repository created in the first section.
5. You’ll be redirected to the installation page. The number at the end of the URL is the installation ID. Save this for later.

```shell
https://github.com/settings/installations/:installation_id
```

### Save the app owner and app ID

On the same page, click on **App settings** underneath the GitHub App name. Save the **Owned by** and **App ID** fields for later.

## 3. Generate a private key

1. Navigate to the **Private Keys** section and click **Generate a private key**.
2. Download and save the `.pem` key. The filename should use the format `{github-app-name}.YYYY-MM-DD.private-key.pem`.
3. Base64-encode the contents of the file to use when configuring your instance. If you use Kubernetes Secrets, you must base64-encode this value twice:

```shell title="Base64-encode twice for Kubernetes Secrets"
base64 -i path/to/{github-app-name}.YYYY-MM-DD.private-key.pem > github-private-key.txt
```

## 4. Configure GitHub repository settings

Next, configure the GitHub repository in Retool.

Navigate to the [Source Control settings](https://login.retool.com/auth/login?source=docs&redirectOnLogin=settings/source-control) in Retool and select **Set up GitHub**.

Enter the settings using the details you saved when creating your GitHub app.

| Setting                   | Description                                                                                                                                                                                                                                             |
| ------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| GitHub owner              | The username or organization who owns the GitHub App, without the `@` prefix, e.g., `tryretool`.                                                                                                                                                        |
| GitHub repository         | The name of the repository you created to use with Retool.                                                                                                                                                                                              |
| GitHub branch             | The default branch, e.g., `main`.                                                                                                                                                                                                                       |
| GitHub Enterprise URL     | The domain used to access your self-hosted GitHub instance. If you use GitHub Cloud, you can leave this blank.                                                                                                                                          |
| GitHub Enterprise API URL | The [REST API route](https://docs.github.com/en/enterprise-server@2.21/rest/reference/enterprise-admin#endpoint-urls) for your self-hosted GitHub instance. Defaults to `https://[hostname]/api/v3`. If you use GitHub Cloud, you can leave this blank. |
| App ID                    | The [GitHub App ID](./github.mdx#save-the-app-owner-and-app-id).                                                                                                                                                                |
| Installation ID           | The [GitHub installation ID](./github.mdx#install-the-github-app). This can be found at the end of the installation URL.                                                                                                        |
| App Private Key           | The base64-encoded private key.                                                                                                                                                                                                                         |

:::note

You can choose to use a GitHub Personal Access Token for authentication instead of the GitHub app. To do so, navigate to **Settings** > **Beta**, and toggle on the **GitHub Personal Access Token** toggle. Return to the configuration page, and set **Config type** to **Personal Access Token**.

:::

Click **Test connection** to confirm your app is connected, then click **Save and deploy**.

Configure the following [Retool environment variables](../../self-hosted/reference/environment-variables/index.mdx) on the `api` and `jobs-runner` containers and then restart your containers.

| Environment variable         | Description                                                                                                  |
| ---------------------------- | ------------------------------------------------------------------------------------------------------------ |
| `GITHUB_APP_ID`              | The [GitHub App ID](#save-the-app-owner-and-app-id).                                                         |
| `GITHUB_APP_INSTALLATION_ID` | The [GitHub installation ID](#install-the-github-app). This can be found at the end of the installation URL. |
| `GITHUB_APP_PRIVATE_KEY`     | The base64-encoded private key.                                                                              |

If you use your own [SSL certificates](../../self-hosted/guides/certificates.mdx), set the `SSL_CERT_FILE` and `NODE_EXTRA_CA_CERTS` environment variables on the `jobs-runner` and `api` containers to the path to your SSL certificate.

Deployments using self-hosted Retool v2.91 or above can optionally prevent the instance from pushing changes to GitHub. To lock version control, set the [`VERSION_CONTROL_LOCKED` environment variable](../../self-hosted/reference/environment-variables/source-control.mdx#version_control_locked) to `true`. This is useful for creating a "read-only" production instance of Retool.

For v2.97 and later, navigate to the [Source Control settings](https://login.retool.com/auth/login?source=docs&redirectOnLogin=settings/source-control) and select **Set up GitHub**.

For v2.96 and earlier, navigate to the **Advanced** settings and select **Protected Applications**.

Enter the settings using the details you saved when creating your GitHub app.

| Setting                   | Required | Description                                                                                                                                                                                                                                             |
| ------------------------- | -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| GitHub owner              | Yes      | The username or organization who owns the GitHub App, without the `@` prefix, e.g., `tryretool`.                                                                                                                                                        |
| GitHub repository         | Yes      | The name of the repository you created to use with Retool.                                                                                                                                                                                              |
| GitHub branch             | Yes      | The default branch, e.g., `main`.                                                                                                                                                                                                                       |
| GitHub Enterprise URL     | No       | The domain used to access your self-hosted GitHub instance. If you use GitHub Cloud, you can leave this blank.                                                                                                                                          |
| GitHub Enterprise API URL | No       | The [REST API route](https://docs.github.com/en/enterprise-server@2.21/rest/reference/enterprise-admin#endpoint-urls) for your self-hosted GitHub instance. Defaults to `https://[hostname]/api/v3`. If you use GitHub Cloud, you can leave this blank. |

Click **Test connection** to confirm your app is connected, then click **Save and deploy**.

## Troubleshooting

The following errors are issues common to Source Control with GitHub. Refer to the guide to [resolve common Source Control issues](../guides/troubleshooting.mdx) to learn about other common errors.

### Internal Server Error

If the system time on the machine that Retool is running on is out of sync or has "drifted," Retool can have trouble authenticating with the GitHub API.

If you see `500 Internal Server Error` when making a commit on a branch, or see errors such as `'Issued at' claim ('iat') must be an Integer representing the time that the assertion was issued` in Retool API server logs, check that the system time where the Retool image is running is accurate. Restarting the system can solve this issue.

### Cookies must be enabled to use GitHub

This error occurs when the **GitHub Enterprise API URL** provided is not an API route. Check the URL provided and confirm that it is a GitHub API route.

### Unable to access GitHub

If your Retool instance is behind a firewall and cannot access the GitHub API, add `.github.com` to your allowlist to enable outbound requests.

---

## Configure Source Control with GitLab

You can use Source Control with GitLab to manage changes using pull requests. You create a repository for Source Control to use, then configure a GitLab project for your Retool instance that commits, pushes, and pulls changes.

Source Control requires the use of [GitLab project access tokens](https://docs.gitlab.com/ee/user/project/settings/project_access_tokens.html). See GitLab's documentation to verify you have access to these tokens.

## Prerequisites

Self-hosted Retool deployments that currently use [Git Syncing](../index.mdx) to sync with GitLab must disable this feature before switching to Source Control. To disable:

- Set `DISABLE_GIT_SYNCING=true` and `VERSION_CONTROL_LOCKED=false` in the `docker.env` file.
- Navigate to **Settings** > **Advanced**, then Remove the GitLab repository URL and branch name from your Git Syncing configuration.

## 1. Create a GitLab project

Create a new project on GitLab. This project repository stores the apps under Source Control from your Retool deployment. Use the following settings:

- Set the correct group under the **Project URL** dropdown.
- Select the **Initialize repository with a README** checkbox.

Next, follow GitLab's [Project access token](https://docs.gitlab.com/ee/user/project/settings/project_access_tokens.html) documentation to create an access token. Set the following scopes for the token:

- `api`
- `read_api`
- `read_repository`
- `write_repository`.

Set the role to `maintainer` or `developer`.

## 2. Configure settings in Retool

Configure the GitLab repository settings.

:::note
Ensure your GitLab domain contains an IPv6 (AAAA) DNS record to prevent server errors when Retool attempts to connect to your GitLab instance. 

You can confirm whether you have IPv6 configured by running:
```
dig  AAAA
```
If the output of the command is `ANSWER: 0`, then the IPv6 DNS record is missing. 
:::

Go to the [Source Control settings](https://login.retool.com/auth/login?source=docs&redirectOnLogin=settings/source-control), and select **Set up GitLab**. Enter the following settings.

| **Setting**          | **Description**                                                                                                                                                         | **Example**                                                  |
| -------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------ |
| GitLab URL           | Your base GitLab URL. On GitLab Cloud, this is always [https://gitlab.com](https://gitlab.com/). On GitLab self-managed, this is the URL where your instance is hosted. | [https://gitlab.mycompany.com](https://gitlab.mycompany.com) |
| Project access token | The GitLab [project access tokens](https://docs.gitlab.com/ee/user/project/settings/project_access_tokens.html) to authenticate to the GitLab API.                      | glpat-123xyzabc456                                           |
| GitLab project ID    | The numerical project ID for your GitLab project. Find this ID listed below the project's name on the project's homepage.                                               | 278964                                                       |
| GitLab branch        | The default branch for your GitLab project.                                                                                                                             | main                                                         |
| GitLab organization  | The name of your GitLab organization. This can be a username if the project is not part of an organization.                                                             | company, username, engineering, etc.                         |
| GitLab repository    | The name of the GitLab project.                                                                                                                                         | retool-apps                                                  |

Set the following environment variables on your `api` and `jobs-runner` containers.

| **Environment variable**      | **Description**                                                                                                                                    | **Example**        |
| ----------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------ |
| `GITLAB_PROJECT_ACCESS_TOKEN` | The GitLab [project access tokens](https://docs.gitlab.com/ee/user/project/settings/project_access_tokens.html) to authenticate to the GitLab API. | glpat-123xyzabc456 |

If you use your own [SSL certificates](../../self-hosted/guides/certificates.mdx), set the `SSL_CERT_FILE` and `NODE_EXTRA_CA_CERTS` environment variables on the `jobs-runner` and `api` containers to the path to your SSL certificate.

Go to the [Source Control settings](https://login.retool.com/auth/login?source=docs&redirectOnLogin=settings/source-control), and select **Set up GitLab**.

| **Setting**         | **Description**                                                                                                                                                           | **Example**                                                  |
| ------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------ |
| GitLab URL          | Your base GitLab URL. For GitLab Cloud, this is always [https://gitlab.com](https://gitlab.com/). For GitLab self-managed, this is the URL where your instance is hosted. | [https://gitlab.mycompany.com](https://gitlab.mycompany.com) |
| GitLab project ID   | The numerical project ID for your GitLab project. Find this ID listed below the project's name on the project's homepage.                                                 | 278964                                                       |
| GitLab branch       | The default branch for your GitLab project.                                                                                                                               | main                                                         |
| GitLab organization | The name of your GitLab organization. This can be a username if the project is not part of an organization.                                                               | company, username, engineering, etc.                         |
| GitLab repository   | The name of the GitLab project.                                                                                                                                           | retool-apps                                                  |

Set the following environment variables on your `api` and `jobs-runner` containers.

| **Environment variable**      | **Description**                                                                                                                                                           | **Example**                                                  |
| ----------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------ |
| `GITLAB_URL`                  | Your base GitLab URL. For GitLab Cloud, this is always [https://gitlab.com](https://gitlab.com/). For GitLab self-managed, this is the URL where your instance is hosted. | [https://gitlab.mycompany.com](https://gitlab.mycompany.com) |
| `GITLAB_PROJECT_ACCESS_TOKEN` | The GitLab [project access tokens](https://docs.gitlab.com/ee/user/project/settings/project_access_tokens.html) to authenticate to the GitLab API.                        | glpat-123xyzabc456                                           |
| `GITLAB_PROJECT_ID`           | The numerical project ID for your GitLab project. Find this ID listed below the project's name on the project's homepage.                                                 | 278964                                                       |
| `GITLAB_MAIN_BRANCH`          | The default branch for your GitLab project.                                                                                                                               | main                                                         |
| `GITLAB_ORGANIZATION_NAME`    | The name of your GitLab organization. This can be a username if the project is not part of an organization.                                                               | company, username, engineering, etc.                         |
| `GITLAB_REPOSITORY_NAME`      | The name of the GitLab project.                                                                                                                                           | retool-apps                                                  |
| `GITLAB_PROJECT_SLUG`         | The URL path to your GitLab project.                                                                                                                                      | retool/eng/retool-apps                                       |
| `VERSION_CONTROL_LOCKED`      | When set to `true`, the instance becomes a "read-only" instance and users cannot create or edit apps. Available on Retool versions 2.91 and later.                        | false                                                        |

If you use your own [SSL certificates](../../self-hosted/guides/certificates.mdx), set the `SSL_CERT_FILE` and `NODE_EXTRA_CA_CERTS` environment variables on the `jobs-runner` and `api` containers to the path to your SSL certificate.

Your Retool instance uses GitLab-specific environment variables to recreate the host URL for your GitLab project. You must provide values for either `GITLAB_ORGANIZATION_NAME` and `GITLAB_REPOSITORY_NAME`, or `GITLAB_PROJECT_SLUG`. For example, if your project URL is `https://gitlab.com/retool-source/gitlab-retool-dev`, you can set `GITLAB_ORGANIZATION_NAME=retool-source` and `GITLAB_REPOSITORY_NAME=gitlab-retool-dev`, or `GITLAB_PROJECT_SLUG=retool-source/gitlab-retool-dev`.

## 3. Verify GitLab settings

On self-hosted Retool versions 2.97 and later, go to the [Source Control settings page](https://login.retool.com/auth/login?source=docs&redirectOnLogin=settings/source-control) to verify your GitLab project is correctly configured. If you still see the **Set up GitLab** option, confirm your environment variables are set.

To confirm Retool can connect to your GitLab project, select **Test connection**.

On self-hosted Retool versions 2.96 and earlier, confirm GitLab is correctly set up by [protecting your first application](../guides/protect/apps.mdx).

## 4. Save your settings

Click **Save and deploy** to save your settings.

---

## Source Control tutorials

import Tutorial from '/docs/_partials/_doctypes/_tutorial.mdx';

:::tip Learn more about self-hosted architecture

Read the [system architecture](../self-hosted/concepts/architecture.mdx) guide to learn more about the containers, services, and dependencies for self-hosted deployment instances.

:::

---

## Enforce SSO

You can disable Retool's built-in authentication method (email address and password) and require that all users log in using SSO credentials.

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

:::danger Verify your SSO configuration is correct

Cloud-hosted Retool organizations must configure and test SSO before enabling this setting. Disabling Retool's standard authentication can lock all users out of your organization.

:::

Navigate to your organization's [Single Sign On (SSO)](https://login.retool.com/auth/login?source=docs&redirectOnLogin=settings/custom-sso) settings and toggle **Disable Login with Email and Password**.

Set the `DISABLE_USER_PASS_LOGIN` [environment variable](../../../self-hosted/reference/environment-variables/index.mdx#disable_user_pass_login) and restart your deployment.

---

## Restrict SSO domains

You can restrict SSO authentication so that only users with email addresses from these domains are allowed. Separate multiple domains with commas.

On self-hosted deployments, this setting also disables username and password login. It is set using the `RESTRICTED_DOMAIN` [environment variable](../../../self-hosted/reference/environment-variables/index.mdx#restricted_domain).

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

1. Navigate to your organization's [Single Sign On (SSO)](https://login.retool.com/auth/login?source=docs&redirectOnLogin=settings/custom-sso) settings.
2. Select your configured SSO provider.
3. Specify one or more domains as a comma-separated list.

1. Navigate to **Settings > Single Sign-on (SSO)**.
2. Select your configured SSO provider.
3. Specify one or more domains as a comma-separated list.

This setting [disables username and password login](enforce-sso.mdx). It is also set using the `RESTRICTED_DOMAIN` [environment variable](../../../self-hosted/reference/environment-variables/index.mdx#restricted_domain).

---

## Configure SSO session duration

SSO sessions have a one week duration. Once authenticated, a user can remain signed in for up to a week before they need to sign in again. If you need to restrict session durations further, you can reduce this to 12 hours.

Navigate to your organization's [Single Sign On (SSO)](https://login.retool.com/auth/login?source=docs&redirectOnLogin=settings/custom-sso) settings and toggle **Use short session**.

---

## Automatically trigger SSO authentication

Retool can automatically prompt users to sign in with SSO and begin the OAuth 2.0 or SAML authentication flow.

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

1. Navigate to your organization's [Single Sign On (SSO)](https://login.retool.com/auth/login?source=docs&redirectOnLogin=settings/custom-sso) settings.
2. Select your configured SSO provider.
3. Toggle the **Trigger Login Automatically** setting.

1. Navigate to **Settings > Single Sign-on (SSO)**.
2. Select your configured SSO provider.
3. Toggle the **Trigger Login Automatically** setting.

You can also set one of the `TRIGGER_OAUTH_2_SSO_LOGIN_AUTOMATICALLY` or `TRIGGER_SAML_LOGIN_AUTOMATICALLY` [environment variables](../../../self-hosted/reference/environment-variables/index.mdx#trigger_oauth_2_sso_login_automatically).

---

## Sync Google Groups

Organizations using Google Sign-in SSO that manage users with [Google Workspace](https://workspace.google.com/) can map Google Group memberships to Retool permission groups.

## Requirements

To configure Google Groups in Retool, you must have administrator access to your Google Workspace.

## 1. Set up Google as your SAML Identity Provider

To sync Google Groups to Retool, you must first set up Google as your SAML provider on Retool. If you already use Google SAML, you can skip ahead to [configure Retool to use your SAML app](#configure-retool-to-use-the-saml-app).

### Create a custom SAML app on Google

Follow the steps in Google's [instructions to create a custom SAML app](https://support.google.com/a/answer/6087519?hl=en) using the configuration below.

On the **Service provider details** screen, enter the following fields.

| Setting       | Value                                                                                                                                  |
| ------------- | -------------------------------------------------------------------------------------------------------------------------------------- |
| **ACS URL**   | On Retool Cloud, `https://your-company.retool.com/api/saml/login`. On self-hosted Retool,`https://retool.your-company.com/saml/login`. |
| **Entity ID** | `https://your-company.retool.com`                                                                                                      |

On the **Attribute mapping** screen, map your Google user details to the field names to show on Retool users. Under **App attributes**, include `email`, `firstName`, and `lastName`.

By default, Google turns off SAML apps. To turn on the app for all users, in **User access**, change the Service status to **On for everyone**.

### Configure Retool to use the SAML app

After creating your custom SAML app, you need to configure Retool to use it for SSO.

1. On Retool Cloud, go to **Settings > Single Sign-On (SSO)**. On self-hosted deployments, go to **Settings > Advanced**.
2. Copy the contents of the IdP Metadata file you downloaded when creating your SAML app and paste them into the **IdP Metadata XML** field.

3. Enable **JIT user provisioning** to allow Retool to automatically provision an account when users sign in for the first time using SAML. This step is optional, but recommended.

4. Set the `DOMAINS` environment variable to match the entity ID you set in your SAML settings. If you enabled JIT user provisioning, you also need to set the `DEFAULT_GROUP_FOR_DOMAINS` [environment variable](../../../self-hosted/reference/environment-variables/index.mdx#default_group_for_domains).

```
DOMAINS=retool.your-company.com
```

## 2. Set up Google Secure LDAP service

Retool uses the Google Secure LDAP Service to fetch a user's Google Group memberships to sync with Retool.

1. Log in to your Google Admin console.
2. Navigate to **Apps** > **LDAP** and click **Add LDAP client**.
3. Enter a client name in the setup wizard, then add the following permissions in the **Access permissions** settings. Retool recommends the following access scopes, but you can also limit to selected OUs and groups.

- Under **Verify user credentials**, select **Entire domain**.
- Under **Read user information**, select **Entire domain**.
- Toggle on **Read group information**.

4. Create the client and download the generated certificate bundle.

5. Switch the **Service status** to **On**.

### Configure Retool to use the LDAP service

Configure the following settings to retrieve Google Groups from your LDAP service.

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import SettingsOverride from "../../_settings-override.mdx";

On Retool Cloud and self-hosted Retool versions 3.16 and later, go to **Settings > Single Sign-On (SSO)**, select **Google LDAP** under **Group syncing**, and enter the following settings.

| **Setting**            | **Value**                     | **Description**                                       |
| ---------------------- | ----------------------------- | ----------------------------------------------------- |
| Server URL             | `ldaps://ldap.google.com:636` | The LDAP server URL for Google's Secure LDAP Service. |
| Server name            | `ldap.google.com`             | The LDAP server name.                                 |
| Base domain components | `dc=example,dc=com`           | Your organization's email domain in DC syntax.        |
| Server certificate     | _Encoded certificate_         | The certificate from the downloaded bundle.           |
| Server key             | _Encoded private key_         | The private key from the downloaded bundle.           |

On self-hosted Retool versions earlier than 3.16, add the following [environment variables](../../../self-hosted/reference/environment-variables/index.mdx#authentication) on your Retool instance.

| **Environment variable**      | **Value**                     | **Description**                                       |
| ----------------------------- | ----------------------------- | ----------------------------------------------------- |
| `LDAP_SERVER_URL`             | `ldaps://ldap.google.com:636` | The LDAP server URL for Google's Secure LDAP Service. |
| `LDAP_SERVER_NAME`            | `ldap.google.com`             | The LDAP server name.                                 |
| `LDAP_BASE_DOMAIN_COMPONENTS` | `dc=example,dc=com`           | Your organization's email domain in DC syntax.        |
| `LDAP_SERVER_CERTIFICATE`     | _Encoded certificate_         | The certificate from the downloaded bundle.           |
| `LDAP_SERVER_KEY`             | _Encoded private key_         | The private key from the downloaded bundle.           |
| `LDAP_SYNC_GROUP_CLAIMS`      | True                          | Enable the sync.                                      |

Your Google Workspace domain must use domain component (DC) syntax.

| **Email Domain**   | **Domain Component (DC) format** |
| ------------------ | -------------------------------- |
| `example.com`      | `dc=example,dc=com`              |
| `mail.company.com` | `dc=mail,dc=company,dc=com`      |

### Role mapping

import GroupsAdminWarning from "../../_groups_admin_warning.mdx";

Role mapping allows you to map group email names from Google Groups to group names on Retool. The `LDAP_ROLE_MAPPING` environment variable uses an arrow syntax for the mapping. For example, to map the group `retool-admins@yourcompany.com` to the default `Admin` group on Retool and `support@yourcompany.com` to a `Support` Retool group, you might set the following.

| **Setting**       | **Environment variable** | **Example value**                          |
| ----------------- | ------------------------ | ------------------------------------------ |
| LDAP Role Mapping | `LDAP_ROLE_MAPPING`      | retool-admins -> admin, support -> Support |

import RoleMappingCaseSensitivity from "../../_role-mapping-case-sensitivity.mdx";

Retool automatically creates the explicitly mapped groups on Retool if they don't already exist. If `LDAP_ROLE_MAPPING` is not set, Retool attempts to sync the user's group slugs with existing Retool groups.

On self-hosted deployments, when you first configure group syncing, it's useful to set the `LDAP_ROLE_MAPPING_DISABLED` environment variable to true. When true, Retool does not actually sync or create any new groups when a user logs in, but does show you logs for the steps it _would_ have performed. This allows you to debug your setup before actually changing groups for users.

## Troubleshoot group syncing

Use the following information to resolve common issues when configuring LDAP group syncing.

### Insufficient access rights

If you see an error indicating `Insufficient Access Rights`, ensure the LDAP service status is set to **On** in the Google Admin Console.

### Error configuring app for user

If you see an error which contains `app_not_configured_for_user`, ensure the LDAP service status is set to **On** in the Google Admin Console. Verify that you correctly set your [DOMAINS variable](#configure-retool-to-use-the-saml-app) and that it matches the [entity ID](#create-a-custom-saml-app-on-google) you previously set.

---

## Configure group syncing and role mapping

import GroupsAdminWarning from "../../_groups_admin_warning.mdx";

Retool can sync groups from your SSO provider for authorization. The approach you use depends on your configured SSO provider.

| Provider                                                                | Supported group sync methods                                                                                                     |
| ----------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------- |
| [Sign in with Google](../../tutorials/google/google-sign-in.mdx)       | [LDAP Google Group sync](google-groups.mdx)                                                              |
| [Google OIDC](../../tutorials/google/oidc.mdx)                         |                                                                                                                                  |
| [Okta OIDC](../../tutorials/okta/oidc.mdx)                             | [Role mapping](../../tutorials/okta/oidc.mdx#role-mapping-with-okta-group-claims)                                               |
| [OneLogin OIDC](../../tutorials/onelogin.mdx)                          | [Role mapping](../../tutorials/custom/oidc.mdx#role-mapping)                                                                    |
| [Auth0 OIDC](../../tutorials/auth0.mdx)                                | [Role mapping](../../tutorials/custom/oidc.mdx#role-mapping)                                                                    |
| [Microsoft Entra ID OIDC](../../tutorials/microsoft-entra-id/oidc.mdx) | [Role mapping](../../tutorials/microsoft-entra-id/oidc.mdx#optional-settings)                                                   |
| [Generic OIDC](../../tutorials/custom/oidc.mdx)                        | [Role mapping](../../tutorials/custom/oidc.mdx#role-mapping)                                                                    |
| [Okta SAML](../../tutorials/okta/saml.mdx)                             | [SAML group sync and role mapping](saml-group-sync.mdx), [SCIM provisioning](../scim-user-provisioning.mdx) |
| [OneLogin SAML](../../tutorials/custom/saml.mdx)                       | [SAML group sync and role mapping](saml-group-sync.mdx)                                                              |
| [Microsoft Entra ID SAML](../../tutorials/microsoft-entra-id/saml.mdx) | [SAML group sync and role mapping](saml-group-sync.mdx)                                                              |
| [Active Directory Federation Services SAML](../../tutorials/adfs.mdx)  | [SAML group sync and role mapping](saml-group-sync.mdx)                                                              |
| [Generic SAML](../../tutorials/custom/saml.mdx)                        | [SAML group sync and role mapping](saml-group-sync.mdx), [SCIM provisioning](../scim-user-provisioning.mdx) |

## Group sync

If your groups are named the same in your IdP and Retool, group syncing happens automatically when users log in. For example, if you have an OIDC group claim of **Engineers** and a Retool group named **Engineers**, the users in the OIDC group are automatically added to the Retool group on login.

Group syncing occurs when users log in, so if you change groups in your IdP, users need to log out and in again for changes to be reflected. OIDC groups are created in Retool automatically. You assign group membership in your IdP. Manual edits to group memberships are overwritten with IdP groups on subsequent logins, so manual editing is not recommended.

## Role mapping

To map the groups from your IDP to differently named groups in Retool, use role mapping. For example, if your LDAP/SAML group claim is **Admins** and in Retool the corresponding group is **RetoolAdmins**, you can map groups so members of the **Admins** group are added to the **RetoolAdmins** group on login.

Role mapping occurs when users log in, so if you change groups in your IdP, users need to log out and in again for changes to be reflected. OIDC groups are created in Retool automatically. Editing Retool group membership in Retool is disabled. You assign group membership in your IdP.

With [SCIM provisioning](../scim-user-provisioning.mdx), groups are pushed automatically from your IdP to Retool using API requests. This means you can push group membership on an automated schedule or manually from your IdP.

SCIM calls specific API endpoints to add users to groups, remove users from groups, and create groups.

SCIM matches groups by name, so user groups in your IdP and Retool need to have the same name. You can map a group name to one of Retool's 4 default groups (**Admin**, **Viewer**, **Editor**, **All Users**).

:::note

SCIM requires your Retool instance is open to API requests from your IdP. You should add your IdP's IP addresses to your instance’s allowlist.

:::

### Role mapping and Spaces

If you use [Retool Spaces](../../../org-users/tutorials/spaces.mdx), you may want to namespace your IdP groups by Space if they're in the same IdP instance. For example, if you have distinct engineering teams building apps in different spaces, Retool recommends splitting "Engineering" into "Engineering - Treasury" and "Engineering - Issuing" IdP groups for your Treasury and Issuing Spaces.

---

## Sync SAML group memberships

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

Retool supports syncing group memberships at the time of SAML login. This requires passing group membership for users to Retool in your SAML assertion. Retool parses these memberships and adds or removes users to the groups when a user logs in to Retool.

import GroupsAdminWarning from "../../_groups_admin_warning.mdx";

## Requirements

To use SAML group syncing, you must:

- Have [SAML SSO](../../tutorials/custom/saml.mdx) configured on Retool.
- Create Retool groups prior to syncing SAML groups. Retool groups are **not** created in the login flow.

:::note

Upon login, users are **removed** from any groups that do not have a corresponding IdP group. This includes users assigned to the Admin group. You should test this flow with a non-admin or test user.

:::

## 1. Include groups in your SAML application

Configure your SAML application to include group attributes in the SAML response.

### Okta

SAML Group Syncing directly matches the user groups by name, so Retool copies the naming convention you use in Okta.

In your Okta SAML application, configure the response to include Group Attributes. Set the group filter as desired. For example, you might set the name to `groups` and the regex filter to `.*` to include all of a user's groups.

See [Okta documentation](https://help.okta.com/en-us/Content/Topics/Apps/define-group-attribute-statements.htm) for more details about configuring Okta group attributes.

### Microsoft Entra ID

For Microsoft Entra ID, use [group claims](https://learn.microsoft.com/en-us/entra/identity/hybrid/connect/how-to-connect-fed-group-claims) to configure group attributes. When configuring group claims:

1. Set the group attribute name to `http://schemas.microsoft.com/ws/2008/06/identity/claims/groups` to use the Retool default.
1. Configure the group claim to [include the group display name for cloud-only groups](https://learn.microsoft.com/en-us/entra/identity/hybrid/connect/how-to-connect-fed-group-claims#emit-cloud-only-group-display-name-in-token). Set the **Source attribute** to **Cloud-only group display names**.

## 2. Update configuration

Add your SAML configuration to your Retool instance through environment variables or the settings page.

import SettingsOverride from "../../_settings-override.mdx";

On Retool Cloud and self-hosted Retool versions 3.16 and later, on the **Settings > Single Sign-On (SSO)** page, select **SAML Group Attribute** under **Sync Groups to Retool**. In **Groups attribute**, enter the attribute defined in your SAML assertion. Save your settings.

On self-hosted instances earlier than 3.16, configure the `SAML_SYNC_GROUP_CLAIMS` [environment variable](../../../self-hosted/reference/environment-variables/index.mdx#saml_sync_group_claims) to enable SAML group sync.

```
SAML_SYNC_GROUP_CLAIMS=true
```

Set the `SAML_GROUPS_ATTRIBUTE` environment variable to the group attribute defined in your SAML assertion. `SAML_GROUPS_ATTRIBUTE` defaults to `groups` if the environment variable is not set.

```
SAML_GROUPS_ATTRIBUTE="groups"
```

You must restart your Retool instance whenever you make changes to environment variables.

## 3. Role mapping

If your permission group names differ in Retool and your IdP, you can use role mapping to map your IdP groups to Retool groups. Role mapping is not necessary if your group names are the same, e.g., your admin group is named `admin` in both your IdP and Retool.

Roles are case sensitive. This means:

1. Roles set in your IdP that you specify in the following settings need to match exactly. For example, if you have a `Retool Admin` role in your IdP, you need to pass `Retool Admin`.
2. Roles within Retool are always lowercase. For example, if you have a `Retool Admin` role within your IdP, and you want to map it to Retool's `admin` role, you need to set it using `Retool Admin → admin`.

On Retool Cloud and self-hosted Retool versions 3.16 and later, from **Settings > Single Sign-On (SSO)** under **SAML Groups Attribute**, add role mapping as a comma-separated list to the **Roles mapping** field. For example, to map the group `retool-admins@yourcompany.com` to the default `Admin` group on Retool and `support@yourcompany.com` to a `Support` Retool group, you can set:

```
retool-admins -> admin, support -> Support
```

Members of the `retool-admin` group in your IdP are now automatically added to the `admin` group when they log in, and `support` members added to `Support`.

On self-hosted Retool, set the `LDAP_ROLE_MAPPING` [environment variable](../../../self-hosted/reference/environment-variables/index.mdx#ldap_role_mapping) to a comma-separated list of mapped groups. For example, to map the group `retool-admins@yourcompany.com` to the default `Admin` group on Retool and `support@yourcompany.com` to a `Support` Retool group, you can set:

```
LDAP_ROLE_MAPPING=retool-admins -> admin, support -> Support
```

Members of the `retool-admin` group in your IdP are now automatically added to the `admin` group when they log in, and `support` members added to `Support`.

You must restart your Retool instance whenever you make changes to environment variables.

## 4. Confirm group sync

You can test out your configuration by logging in from an incognito window.

On self-hosted instances, you can also confirm group syncing by reviewing the `api` container logs after users log in. The logs contain SAML group memberships for each user who has logged in.

```
api_1 | [SAML] - Received SAML Login Response, parsing...
api_1 | [SAML] - Validating response...
api_1 | [SAML] - Validated response, and received the following attributes {
api_1 | email: 'johndoe@retool.com',
api_1 | firstName: 'John',
api_1 | lastName: 'Doe',
api_1 | groups: [ 'samlgroup', 'Everyone', 'anothergroup' ]
api_1 | }
```

---

## Enable JIT user provisioning for SSO

JIT user provisioning is optional, but recommended. When you enable this setting, Retool provisions user accounts when users sign in over SSO for the first time. This saves time for admins, who then don't need to manually invite users to Retool. The identity provider is still the source of truth and determines which users have access to Retool. Users must also still be granted access in the identity provider before an account is created in Retool.

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

1. Navigate to your organization's [Single Sign On (SSO)](https://login.retool.com/auth/login?source=docs&redirectOnLogin=settings/custom-sso) settings.
2. Select your configured SSO provider.
3. Toggle **Enable JIT user provisioning**.

1. Navigate to **Settings > Single Sign-on (SSO)**.
2. Select your configured SSO provider.
3. Toggle **Enable JIT user provisioning**.

If you're setting up SSO with Google, you also need to set the `DEFAULT_GROUP_FOR_DOMAINS` [environment variable](../../self-hosted/reference/environment-variables/index.mdx#default_group_for_domains).

---

## Migrate from SAML to OIDC

You can use both [OpenID and SAML SSO methods](../index.mdx) to log users in to Retool. OIDC SSO has additional functionality you may want to enable based on your use case. For example, with OIDC, you can use ID tokens from your IdP for authentication in Retool resources.

On self-hosted instances, ensure you follow the order outlined in this guide. On Retool Cloud, you can update settings directly in **Settings > Single Sign-On (SSO)**.

:::note

To minimize downtime, apply all changes to environment variables at the same time. When you restart the Retool server, your instance immediately replaces the SAML-based SSO with the new OIDC-based SSO.

:::

## 1. Enable OIDC SSO

Use the configuration guides—[Okta](../tutorials/okta/oidc.mdx), [Google](../tutorials/google/oidc.mdx), [OneLogin](../tutorials/onelogin.mdx), or [another provider](../tutorials/custom/oidc.mdx)—to enable OIDC authentication on your instance. This involves creating an OIDC app for your Retool instance and setting `CUSTOM_OAUTH2_SSO_*` [environment variables](../../self-hosted/reference/environment-variables/index.mdx#authentication). You can set these variables in Retool under **Settings > Configuration variables**. Do not restart your Retool instance yet.

## 2. Remove SAML metadata

:::note

If you store SAML metadata in the Retool settings UI, ensure you added the OIDC configuration in the previous step. Settings stored in the UI are applied immediately.

:::

SAML IDP metadata is located in either the **Settings** > **Advanced** page in the Retool UI, or stored in the `SAML_IDP_METADATA` environment variable. Remove or comment out the metadata.

## 3. Restart your Retool instance

Restart your Retool instance and select **Login with SSO** to test your changes. If you cannot log in, comment out the `RESTRICTED_DOMAIN` environment variable to temporarily enable username and password logins. Confirm the rest of your environment variables are correctly set. You may also want to enable [JIT user provisioning](jit-provisioning.mdx).

---

## Provision users with SCIM

SCIM, or System for Cross-domain Identity Management, is the industry standard for automatically provisioning user accounts. It's useful when using a third-party SSO provider for authentication, such as Okta, because it allows you to automatically create, update, and deactivate user accounts in applications such as Retool.

Refer to the [SCIM reference](../../scim/index.mdx) to learn how to make requests to the SCIM endpoints Retool implements.

import GroupsAdminWarning from "../../sso/_groups_admin_warning.mdx";

## Requirements

You can use SCIM provisioning on Retool Cloud or self-hosted Retool versions **2.32.1** and later.

If you use Okta, follow the [configuration steps](#configuration-steps) to create an application. If you use another provider, see the documentation for your SSO provider to learn how to add Retool as an application.

If your Retool instance is behind a firewall and you use Okta, [add Okta's IP addresses to your allowlist](https://help.okta.com/en-us/Content/Topics/Security/ip-address-allow-listing.htm) so it can connect to Retool. Optionally, you can add a rule to your load balancer to only expose the needed paths: `/api/scim/v2/*`.

## SCIM server authentication

To use SCIM, you first add Retool as an application in your SSO provider. After you assign the application to a user, an account in Retool is automatically created. That happens because your SSO provider makes an API request to Retool and instructs Retool to create an account for your user.

To ensure accounts are only created by authorized users, Retool uses a **Bearer Token** authentication scheme. You define a secret that only Retool and your SSO provider know.

### Generate tokens in Retool

You can create API tokens with the **SCIM API** scope in the **API** settings for your organization.

import Tokens from '/docs/_partials/_tokens.mdx';

### Create tokens outside of Retool

Use the following instructions to set the `SCIM_AUTH_TOKEN` environment variable:

- For organizations on versions 3.4.0 or earlier, generate your own token and set it as the `SCIM_AUTH_TOKEN` token [environment variable](../../self-hosted/reference/environment-variables/#property-SCIM_AUTH_TOKEN). 
- For organizations on versions after 3.4.0, you can use one of the following options: 
  * Set `SCIM_AUTH_TOKEN` environment variable to the the same token that was generated in the UI.
  * Omit the `SCIM_AUTH_TOKEN` environment variable if the token was also generated in the UI.
  * Use the Retool API to [create an access token](../../api/create-an-access-token).

```
SCIM_AUTH_TOKEN=A_SECRET_TOKEN
```

:::warning 
The secret must be at least 10 characters long.

The SCIM API endpoints that Retool makes available are highly sensitive and should be protected. Use a long and secure secret token that nobody can guess.

:::

After creating your token, restart your Retool instance.

### Test your token

After creating your token, test it by opening `https://yourRetoolAppDomain/api/scim/v2/Schemas`. There, you should see an error that looks like this:

```
{"detail":"SCIM request not authorized","schemas":["urn:ietf:params:scim:api:messages:2.0:Error"]}
```

After that's been set, only requests to Retool's SCIM API with the header `Authorization: Bearer YOUR_SECRET_TOKEN` will be accepted.

## Microsoft Entra ID requirements

In Microsoft Entra ID, you must add `aadOptscim062020` to your **Tenant URL** for your requests to be SCIM 2.0 compliant and work in Retool. See the [Microsoft Entra ID documentation](https://learn.microsoft.com/en-us/azure/active-directory/app-provisioning/application-provisioning-config-problem-scim-compatibility#flags-to-alter-the-scim-behavior) for more.

## Okta-specific requirements

When using Okta as an SSO provider, the SCIM API offers the following features:

- **Create Users:** New or existing users in Okta are pushed to Retool as new users.
- **Update User Attributes:** Updates to user profiles in Okta are pushed to Retool.
- **Deactivate Users:** Users deactivated in Okta are automatically disabled in Retool. They are immediately logged out and do not count towards the billable user count. If a user is reactivated, they regain access to Retool and keep all previously specified access controls.
- **Importing Users:** Users that are created manually in Retool can be imported into Okta as Okta users.
- **Group Push:** Group Push lets you take existing Okta groups and their memberships and push them to Retool.

### Configuration steps

Before you begin, [create an access token](#scim-server-authentication).

1. In Okta, add the Retool application to your Okta account.

2. Enter your Retool domain in the following format: `YOUR.RETOOL.INSTANCE.COM`. For example, if you log into `https://YOUR.RETOOL.INSTANCE.COM/`, enter: YOUR.RETOOL.INSTANCE.COM”.

:::note

Do not include the `https://` prefix in the Retool domain—it is automatically included.

:::

3. Go to the **Provisioning** tab and click **Configure API Integration**.

4. Enable the **Enable API integration** setting, and enter your [Retool SCIM API access token](#scim-server-authentication).

5. Click **Test API credentials** to ensure the connection is working.

:::note

Do not include a `Bearer` prefix in the Auth Token as this is automatically included.

:::

6. Click **Save** to enable provisioning for the Retool app.

7. Activate the desired provisioning features. In the provisioning settings for the app, under **To App**, click **Edit** and enable **Create Users**, **Update User Attributes**, and **Deactivate Users**. Save your settings.

8. If you use [Retool user attributes](../../org-users/guides/user-management/user-attributes.mdx#assign-attribute-values-to-users) and want to connect Okta custom attributes to the **metadata** user attribute, set **External namespace** to **metadata** on the Okta custom attribute.

You can now start assigning users to the Retool app and they will be automatically created in Retool.

### Enable group push

If you're setting up Okta for the first time, you will get access to Group Push with the rest of the Okta SCIM features, and you can ignore the rest of this guide. If you've already set up Retool with Okta, you will have to re-authenticate your account to enable Group Push. To do this, follow these steps.

1. Log in to your Okta org as an Admin.
2. Open the Admin UI.
3. Open your Retool application instance.
4. Go to the **Provisioning** tab.
5. On the **Settings** sidebar, click **Integration**.
6. Click **Edit** and then **Test API Credentials**, and then click **Save**. If you've followed the **Configuration Steps** of this guide, your credentials should already be in the **Integration** section.

SCIM should now be enabled for your Retool instance.

### Push to default Retool groups

:::note

This feature is available on self-hosted Retool versions 2.94 and later.

:::

You cannot rename Retool's default groups using SCIM group mapping, but you can map your custom groups to the four default Retool groups (`admin`, `editor`, `viewer`, `All Users`). Okta is used as an example, but a similar process also works for other identity providers.

1. Follow instructions in [Okta](https://help.okta.com/en-us/content/topics/users-groups-profiles/usgp-import-users-app.htm) to import groups using the **Import Now** button. After importing, the four Retool default groups show in Okta as `Retool production - [group name]`. These groups are read-only in Okta.

2. To push custom Okta groups to Retool default groups, follow the [Okta instructions](https://help.okta.com/en-us/content/topics/users-groups-profiles/usgp-enable-group-push.htm). Check **Push group members immediately** if you want to immediately sync group memberships.

3. If you disabled the automatic push in step 2, you can manually push your groups. Confirm your group has a **Push Status** of **Active** in the **Push Groups** tab.

4. Log in to Retool and go to the **Users** page to verify your group members are synced.

---

## SSO how-to guides

import Howto from '/docs/_partials/_doctypes/_howto.mdx';

:::tip Get started with SSO

If you want to get started with SSO at Retool:

- Read the [quickstart](./quickstart) to learn about the fundamental concepts.
- Follow a [tutorial](./tutorial/) to set up an SSO provider.

:::

---

## SSO documentation

Single sign-on (SSO) is a user authentication tool that enables users to securely access multiple applications and services using one set of credentials. Rather than require users to create additional usernames and passwords for Retool, you can centralize logins to a single identity provider (IdP).

---

## SSO quickstart

This guide serves as an introduction to single sign-on (SSO). It covers many of the concepts and terminology you would come across when configuring and authenticating with SSO. After reading this page, you should have a good understanding of the fundamentals for using SSO to authenticate users.

## Introduction

SSO is a user authentication tool to securely access multiple applications and services using one set of credentials. Rather than require users to create additional usernames and passwords for Retool, you can centralize logins to a single identity provider (IdP). SSO is primarily used for authentication, though Retool also supports syncing groups for authorization.

## Requirements

Retool supports OpenID Connect (OIDC) and Security Assertion Markup Language (SAML) identity providers. Organizations can map IdP roles to Retool permission groups using OIDC role mapping or SAML group sync. Retool also supports LDAP Google Group sync when using Sign in with Google.

Setup tutorials are available for the following identity providers.

| Provider                                                                                                                       | Protocol                                                                                                 |
| ------------------------------------------------------------------------------------------------------------------------------ | -------------------------------------------------------------------------------------------------------- |
| [Active Directory Federation Services (AD FS)](https://learn.microsoft.com/en-us/windows-server/identity/ad-fs/ad-fs-overview) | [SAML](./tutorials/adfs.mdx)                                                                           |
| [Auth0](https://auth0.com/)                                                                                                    | [OIDC](./tutorials/auth0.mdx)                                                                          |
| [Google](https://cloud.google.com/architecture/identity/single-sign-on)                                                        | [OIDC](./tutorials/google/oidc.mdx) and [Sign In with Google](./tutorials/google/google-sign-in.mdx) |
| [Microsoft Entra ID](https://learn.microsoft.com/en-us/entra/fundamentals/whatis)                                              | [OIDC](./tutorials/microsoft-entra-id/oidc.mdx) and [SAML](./tutorials/microsoft-entra-id/saml.mdx)  |
| [Okta](https://www.okta.com/)                                                                                                  | [OIDC](./tutorials/okta/oidc.mdx) and [SAML](./tutorials/okta/saml.mdx)                              |
| [OneLogin](https://www.onelogin.com/)                                                                                          | [OIDC](./tutorials/onelogin.mdx)                                                                       |
| Other IdP providers                                                                                                            | [OIDC](./tutorials/custom/oidc.mdx) and [SAML](./tutorials/custom/saml.mdx)                          |

If your organization uses [Google Workspace](https://workspace.google.com/) and all users share the same domain, users can log in automatically to the same Retool organization.

## SSO authentication flow

The following steps illustrate the authentication flow between the IdP and Retool when a user signs in.

1. User navigates to a Retool organization URL.
2. Retool redirects the user to the identity provider to sign in.
3. The user signs in with their credentials.
4. The user confirms with the IdP that they want to sign in to Retool.
5. The user is redirected back to Retool.
6. Retool checks with the IdP to confirm the user is authenticated.
7. The IdP validates the authentication request.
8. The user successfully signs in and can access Retool.

## Enforce and restrict SSO

Retool includes support for enforcing SSO and disabling Retool's built-in authentication method. Organizations can also set session durations, restrict which email address domains are allowed, and trigger SSO automatically.

Each [Retool Space](../org-users/tutorials/spaces.mdx) can only have a single authentication method, and it's not possible to set the login method to _username and password_ for some users and _SSO_ for others within a single space. Refer to [Spaces and SSO](../org-users/tutorials/spaces.mdx#spaces-and-sso) for more information.

:::note

To provide multiple authentication methods, you could utilize multiple spaces. For example, create one space for SSO authentication and another space for username and password authentication. Sync both spaces via [Source Control](../source-control/index.mdx), maintaining the same apps and resources for both. Each space requires independent setup of users, permissions, and other settings.

:::

## Group syncing and user provisioning

---

## SSO environment variables

import Sso from "@site/docs/self-hosted/reference/environment-variables/authentication.mdx";

---

## SSO glossary

import SharedGlossary from '../../_partials/_glossary.mdx';

---

## Organization and users reference

import Reference from '/docs/_partials/_doctypes/_reference.mdx';

:::tip Get started with your organization and users

If you are unfamiliar with managing your organization and want to get started, read the [quickstart](./quickstart) to learn about the fundamental concepts.

:::

---

## Configure Active Directory Federation Services SAML SSO

import Test from "./_partials/_test-connection.mdx"

Use the following guide to integrate Retool with Active Directory Federation Services 3.0.

## 1. Create a relying party trust

Follow the [Relying Party Trust wizard](https://learn.microsoft.com/en-us/windows-server/identity/ad-fs/operations/create-a-relying-party-trust#to-create-a-claims-aware-relying-party-trust-manually) in Active Directory with the following settings.

1. In **Select Data Source**, select **Enter data about the relying party manually**.
2. In **Choose Profile**, select **AD FS profile**.
3. In **Configure Certificate**, do not upload a certificate.
4. In **Configure URL**, select **Enable support for SAML 2.0 WebSSO Protocol**. On Retool Cloud, enter `https://your-sso-url.retool/api/saml/login`. On self-hosted Retool, enter `https://your-sso-url.retool/saml/login`. Replace `your-sso-url` with your Retool single-sign on domain. This is often `retool.yourcompany.com`.
5. In **Configure Identifiers**, add your single-sign on domain without the protocol as a **Relying party trust identifier**. For example, use `retool.yourcompany.com` instead of `https://retool.yourcompany.com`.
6. Finish the wizard.

## 2. Send LDAP attributes as claims

Follow the steps to [send LDAP attributes as claims](https://learn.microsoft.com/en-us/windows-server/identity/ad-fs/operations/create-a-rule-to-send-ldap-attributes-as-claims).

1. On the **Choose rule type** page, select **Send LDAP Attributes as Claims**.
2. On the **Configure claim rule** page, choose **Active Directory** as the attribute store. Fill in the following settings.

| LDAP Attribute  | Outgoing Claim Type     |
| --------------- | ----------------------- |
| Email addresses | `email`                 |
| Email addresses | AD FS 1.x Email address |
| Given Name      | `firstName`             |
| Surname         | `lastName`              |

3. Select **Transform an Incoming Claim** and select the following settings.

| Setting                  | Value                   |
| ------------------------ | ----------------------- |
| Incoming claim type      | AD FS 1.x Email Address |
| Outgoing claim type      | Name ID                 |
| Outgoing claim ID format | Email                   |

4. Select **Pass through all claim values** and save the settings.

## 3. Configure Retool with IdP metadata

Export the metadata to an XML file from your IdP. There is usually a button to download this from your IdP dashboard. Additionally, you can often find this by navigating to `https://your.identityprovider.com/federationmetadata/2007-06/federationmetadata.xml`.`

Copy the entire XML file to your clipboard and log in to Retool as an admin user.

- **Self-hosted Retool**: Go to **Settings > Advanced**.
- **Retool Cloud**: Go to **Settings > Single Sign-On (SSO)**, select **SAML SSO**, and paste the XML file contents to the **Identity Provider Metadata** field.

## 4. Test the connection

---

## Configure Auth0 OIDC SSO

import Test from "./_partials/_test-connection.mdx"

Use this guide to configure Auth0 SSO with OpenID Connect (OIDC) on Retool. Once configured, users can log in to Retool with their Auth0 credentials.

## Requirements

To configure Auth0 SSO, you must:

- Have admin permissions on Retool Cloud or permissions to add environment variables on self-hosted Retool instances.
- Have permissions to create an OIDC application in Auth0.

## 1. Create a new Auth0 application

In Auth0, create a new application for Retool. Go to your application **Settings** and save the **Client ID** and **Client secret**.

Next, save the **OAuth Authorization URL** and **OAuth Token URL**. In Auth0, this is found in **Settings > Advanced Settings > Endpoints**.

Add `https://.retool.com/oauth2sso/callback` as the callback URL, replacing `` with your subdomain. In Auth0, the callback URL is set in **Settings > Application URIs**.

## 2. Configure settings in Retool

Configure your SSO settings in Retool.

import SettingsOverride from "../_settings-override.mdx";
import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

On Retool Cloud and self-hosted Retool versions 3.16 and later, enter settings on **Settings > Single Sign-On (SSO)**.

| Setting        | Example                                |
| -------------- | -------------------------------------- |
| Client ID      | yypLZ44LxEz0XlQZBu5k2Nq9XsdOv4f5       |
| Client secret  | xxxxxxxxxxxxxxxxxxxxxxxxxxxxx          |
| Scopes         | openid email profile offline_access    |
| Auth URL       | `https://retool.auth0.com/authorize`   |
| Token URL      | `https://retool.auth0.com/oauth/token` |
| Email key      | idToken.email                          |
| First name key | idToken.given_name                     |
| Last name key  | idToken.family_name                    |

On self-hosted Retool versions earlier than 3.16, configure the following [environment variables](../../self-hosted/reference/environment-variables/index.mdx#authentication) on your Retool instance.

| Environment variable                   | Example                                |
| -------------------------------------- | -------------------------------------- |
| `CUSTOM_OAUTH2_SSO_CLIENT_ID`          | `yypLZ44LxEz0XlQZBu5k2Nq9XsdOv4f5`     |
| `CUSTOM_OAUTH2_SSO_CLIENT_SECRET`      | `xxxxxxxxxxxxxxxxxxxxxxxxxxxxx`        |
| `CUSTOM_OAUTH2_SSO_SCOPES`             | `openid email profile offline_access`  |
| `CUSTOM_OAUTH2_SSO_AUTH_URL`           | `https://retool.auth0.com/authorize`   |
| `CUSTOM_OAUTH2_SSO_TOKEN_URL`          | `https://retool.auth0.com/oauth/token` |
| `CUSTOM_OAUTH2_SSO_JWT_EMAIL_KEY`      | `idToken.email`                        |
| `CUSTOM_OAUTH2_SSO_JWT_FIRST_NAME_KEY` | `idToken.given_name`                   |
| `CUSTOM_OAUTH2_SSO_JWT_LAST_NAME_KEY`  | `idToken.family_name`                  |

### Optional settings

To provide authorization to access resources when a user logs in with SSO, specify the API audience that corresponds to the resource as configured in Auth0. Find the API audience in the Auth0 UI under **Applications > APIs**. Set this value as the `CUSTOM_OAUTH2_SSO_AUDIENCE` environment variable in your Retool deployment, or in the **SSO Audience** field in the Retool UI.

:::warning

If you don't configure the `CUSTOM_OAUTH2_SSO_AUDIENCE` setting, Retool receives an opaque token, and you won't be able to use the `accessToken` to control access to components and resources.

:::

## 3. Test the connection

If you added environment variables, restart your Retool instance.

---

## Configure SSO with OIDC authentication

import Test from "../_partials/_test-connection.mdx"

Retool's OpenID integration uses the [Authorization Code Flow](https://auth0.com/docs/flows/authorization-code-flow). Retool, at minimum, expects either an ID token or access token to be a JSON Web Token (JWT) that contains the email of the authenticated user.

## Requirements

To configure SSO with OIDC, you need:

- The OAuth client ID for your application
- The OAuth client secret for your application
- A list of scopes to grant to Retool
- The authorization endpoint for your OpenID provider
- The token endpoint for your OpenID provider

You should confirm how your SSO provider formats its ID and access tokens. Retool attempts to decode these tokens as JWTs. You must provide Retool the path in the decoded JWT that corresponds with your identifying user information.

:::note

Some SSO providers don't return both an ID token and access token by default. You might need to provide additional metadata to obtain both tokens. See the provider-specific guides and generic process to [obtain a fat token](#thin-tokens-and-fat-tokens) for more details.

:::

### Required settings

Configure your SSO settings in Retool.

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import SettingsOverride from "../../_settings-override.mdx";

On Retool Cloud and self-hosted Retool versions 3.16 and later, enter settings on **Settings > Single Sign-On (SSO)**.

| Setting       | Example value                                            |
| ------------- | -------------------------------------------------------- |
| Client ID     | `XXXXXXXXXX`                                             |
| Client secret | `XXXXXXXXXX`                                             |
| Scopes        | `openid email offline_access profile`                    |
| Auth URL      | `https://yourcompany.idprovider.com/oauth2/v1/authorize` |
| Token URL     | `https://yourcompany.idprovider.com/oauth2/v1/token`     |
| Email key     | `idToken.email`                                          |

On self-hosted Retool versions earlier than 3.16, configure the following [environment variables](../../../self-hosted/reference/environment-variables/index.mdx#authentication) on your Retool instance.

| Environment variable                   | Example                                |
| -------------------------------------- | -------------------------------------- |
| `CUSTOM_OAUTH2_SSO_CLIENT_ID`          | yypLZ44LxEz0XlQZBu5k2Nq9XsdOv4f5       |
| `CUSTOM_OAUTH2_SSO_CLIENT_SECRET`      | xxxxxxxxxxxxxxxxxxxxxxxxxxxxx          |
| `CUSTOM_OAUTH2_SSO_SCOPES`             | openid email profile offline_access    |
| `CUSTOM_OAUTH2_SSO_AUTH_URL`           | `https://retool.auth0.com/authorize`   |
| `CUSTOM_OAUTH2_SSO_TOKEN_URL`          | `https://retool.auth0.com/oauth/token` |
| `CUSTOM_OAUTH2_SSO_JWT_EMAIL_KEY`      | idToken.email                          |
| `CUSTOM_OAUTH2_SSO_JWT_FIRST_NAME_KEY` | idToken.given_name                     |
| `CUSTOM_OAUTH2_SSO_JWT_LAST_NAME_KEY`  | idToken.family_name                    |

On self-hosted deployments, you should also set the `BASE_DOMAIN` environment variable to ensure links using your domain—for example, new user invitations and forgotten password resets—are correct. Retool's backend tries to determine the `BASE_DOMAIN` if it is not set, but it can be incorrect if your website uses a proxy.

```
BASE_DOMAIN=https://retool.yourcompany.com
```

## Configure SSO for your provider

Follow the configuration guides to set up SSO with OIDC for [Auth0](../auth0.mdx), [Google](../google/oidc.mdx), [Okta](../okta/oidc.mdx), or [Microsoft Entra ID](../microsoft-entra-id/oidc.mdx).

## Role mapping

import GroupsAdminWarning from "../../_groups_admin_warning.mdx";

You can also map the roles returned from the OpenID response to your Retool permission groups. Any Retool groups that are not specified in the role mapping are overwritten. Groups are created automatically in Retool when a user logs in.

The following example maps the `devops` and `support` roles to specific Retool permission groups.

| Setting      | Environment variable              | Example value                        |
| ------------ | --------------------------------- | ------------------------------------ |
| Roles key    | `CUSTOM_OAUTH2_SSO_JWT_ROLES_KEY` | `idToken.groups`                      |
| Role mapping | `CUSTOM_OAUTH2_SSO_ROLE_MAPPING`  | `devops -> admin, support -> viewer` |

After setting these environment variables, a user's groups sync the next time they log in to Retool over SSO.

import RoleMappingCaseSensitivity from "../../_role-mapping-case-sensitivity.mdx";

To disable role mapping, set `CUSTOM_OAUTH2_SSO_ROLE_MAPPING_DISABLED` to `true`.

### Examples

| Roles                 | Role mapping setting | Result                                                                                                                            |
| --------------------- | -------------------- | --------------------------------------------------------------------------------------------------------------------------------- |
| ["admin", "editor"]   | ""                   | The user is added to the "admin", "editor", and "All Users" groups.                                                               |
| \[]                   | ""                   | The user is added to the "All Users" group.                                                                                       |
| ["admin", "support"]  | ""                   | A new custom group called "support" is created. The user is added to the "admin", "support", and "All Users" groups.  |
| ["support", "devops"] | "devops -> editor"   | A new custom group called "support" is created. The user is added to the "editor", "support", and "All Users" groups. |

## Use authentication JWTs in resources

Using SSO with OIDC, you can reuse the tokens obtained throughout the SSO process in API calls you make from Retool to your backend services.

In the following example, `USER_OAUTH2_ACCESS_TOKEN` is replaced with the access token obtained in the auth flow, and `USER_OAUTH2_ID_TOKEN` is replaced with the ID token obtained in the auth flow.

:::note

If your OpenID Provider returned a `refresh token` in the initial login flow, Retool automatically uses it to refresh the access and ID tokens every two hours by default. You can set a custom refresh time using the `CUSTOM_OAUTH2_SSO_ACCESS_TOKEN_LIFESPAN_MINUTES` environment variable.

:::

## Reference JWT claims in Retool apps

You can use JWT claims returned by your SSO provider to personalize Retool apps or [control component permissions](../../../permissions/guides.mdx#hide-or-disable-components-for-users-and-groups). Retool automatically includes these claims as the values of the `current_user.metadata.idToken` and `current_user.metadata.accessToken` keys. Access them using curly braces anywhere in your Retool app: `{{current_user.metadata.idToken.picture}}`

### Custom claims

You can add custom claims following instructions from your IdP. See the guides to your IdP for instructions on where to add these claims. In Retool, custom claims are accessible in `current_user.metadata.`

## Thin tokens and fat tokens

Some OIDC identity providers, such as Okta, don't send all the claims associated with a user during the authentication flow. This is called a [thin token](https://developer.okta.com/docs/concepts/api-access-management/#tokens-and-scopes) and is used in place of a fat token, which returns all claims, for performance reasons. If your ID token is missing certain claims, you can tell Retool to make an additional request to a given endpoint for the fat token.

You can configure this endpoint in **Settings > Custom SSO > Fat token URL** on Retool Cloud, or using the `CUSTOM_OAUTH2_SSO_USERINFO_URL` environment variable on self-hosted deployments. For example, Okta uses the `/userinfo` endpoint.

```
CUSTOM_OAUTH2_SSO_USERINFO_URL=https://your-company.okta.com/oauth2/v1/userinfo
```

During the authentication flow, Retool replaces the thin token with the fat token returned from this endpoint.

## Test the connection

---

## Configure SSO with SAML authentication

import Test from "../_partials/_test-connection.mdx"

Retool Cloud and Self-hosted Retool deployments support [Okta](../okta/saml.mdx), [Microsoft Entra ID](../microsoft-entra-id/saml.mdx), [Active Directory Federation Services](../adfs.mdx), and other SAML SSO providers.

If you don't use Okta or Active Directory, use the following steps to configure your SAML identity provider service.

## 1. Set your Entity ID in Retool

By default, Retool uses the Entity ID `https://tryretool.com`.

Add the following [environment variable](../../../self-hosted/reference/environment-variables/index.mdx#domains) to your `docker.env` file, replacing `retool.yourcompany.com` with your domain. Note: adding a new environment variable requires restarting the container for it to take effect.

```
DOMAINS=retool.yourcompany.com
```

## 2. Configure your Identity Provider

You should reference the provided documentation from your identity provider to complete its setup. However, you will likely be asked to supply values for the **Sign on URL** and **Reply URL** fields. Use the following pattern, replacing `example.retool.com` with the **Entity ID** you supplied in step 1:

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

- Sign on URL: `https://example.retool.com/api/saml/login`
- Reply URL: `https://example.retool.com/api/saml/login`

- Sign on URL: `https://example.retool.com/saml/login`
- Reply URL: `https://example.retool.com/saml/login`

## 3. Match user attributes and claims

Retool requires exactly the following attributes to be asserted for each user on login:

- `email`: The identifier for a user
- `firstName`: The user's first name
- `lastName`: The user's last name

## 4. Assign users access to Retool

Use your identity provider to assign users to have access to login to Retool.

## 5. Configure Retool with the Identity Provider Metadata

Export the metadata to an XML file from your identity provider and copy it. There's usually a button to trigger a download from your IdP dashboard. Additionally, you can often find this data by navigating to `https://your.identityprovider.com/federationmetadata/2007-06/federationmetadata.xml`.

You can configure Retool with the IdP metadata in the dashboard for Retool Cloud, or with the [SAML IDP METADATA](https://docs.retool.com/sso/reference/environment-variables.mdx#saml_idp_metadata) environment variable on self-hosted deployments. To use the dashboard, log in to Retool as an admin user.

On Retool Cloud, go to **Settings > Single Sign-On (SSO)**, select **SAML SSO**, and paste the XML file contents to the **Identity Provider Metadata** field. On self-hosted deployments, this setting is on **Settings > Advanced**.

## 6. Test the connection

---

## Configure Sign in with Google

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

You can configure SSO using the [Sign in with Google](https://developers.google.com/identity/gsi/web/guides/overview) following this guide. This guide applies to Retool Cloud and self-hosted deployments.

:::note

Follow this guide to configure Sign-in with Google. Refer to the [Google SSO with OpenID Connect guide](oidc.mdx) to configure Google SSO using OIDC.

:::

## 1. Configure Google OAuth client

Navigate to the **Credentials** page of your [Google APIs console](https://console.developers.google.com/apis). Create or select your project.

Click **Create Credentials > OAuth client ID** to create a [Google OAuth client](https://developers.google.com/identity/gsi/web/guides/get-google-api-clientid). Use the following settings if you have a custom domain set on your organization.

| Setting name                  | Setting values                                                                                                                                                                                   |
| ----------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| Application type              | Web application                                                                                                                                                                                  |
| Authorized JavaScript origins | `https://.com`                                                                                                                                                                 |
| Authorized redirect URIs      | `https://.com/oauthcallback``https://.com/oauth``https://.com/oauthcallback/mobile` (for Retool Mobile only) |

If you are using Retool Cloud, you must also set the following authorized redirect URIs to enable Sign-in with Google:

- `https://login.retool.com/oauthcallback`
- `https://login.retool.com/oauthcallback/cli`
- `https://login.retool.com/oauth/oauthcallback`

If you are prompted to configure a consent screen, select **Internal** as the **User type**.

For more information on setup needed in the Google APIs console, refer to [Google's setup guide](https://developers.google.com/identity/gsi/web/guides/get-google-api-clientid).

## 2. Update settings in Retool

Click on your new OAuth application in the **Credentials** tab, and copy the **Client ID** and **Client secret**.

Visit **Settings > Custom SSO**, select Google SSO, and add your Client ID and Client Secret.

In your `docker.env` file, set your Client ID and Client Secret as the values of the `CLIENT_ID` and `CLIENT_SECRET` environment variables. Set the [BASE_DOMAIN](../../../self-hosted/reference/environment-variables/index.mdx#variable-BASE_DOMAIN) environment variable as well, so Google handles redirect requests correctly.

If you use [Kubernetes Secrets](https://kubernetes.io/docs/concepts/configuration/secret/), place the Base64-encoded version of these strings inside your Kubernetes secrets file instead of in `docker.env`.

```
CLIENT_ID={YOUR_GOOGLE_CLIENT_ID}
CLIENT_SECRET={YOUR_GOOGLE_CLIENT_SECRET}
```

To automatically provision users on sign-in, set the `DEFAULT_GROUP_FOR_DOMAINS` [environment variable](../../../self-hosted/reference/environment-variables/index.mdx#variable-DEFAULT_GROUP_FOR_DOMAINS).

```
DEFAULT_GROUP_FOR_DOMAINS=example1.org -> admin, example2.com -> viewer
```

If you want to restrict sign-in to SSO and remove the option for users to sign in with a username and password, add the `RESTRICTED_DOMAIN` environment variable.

```
RESTRICTED_DOMAIN=yourcompany.com
```

When setting `RESTRICTED_DOMAIN`, do not include the protocol or subdomain where you have Retool deployed. Only use `yourcompany.com`, which should match the email address users use to sign in. See the [environment variables](../../../self-hosted/reference/environment-variables/index.mdx#authentication) reference for more details.

Restart your Retool instance to reload the configuration and enable Google SSO. If you use Docker, you can restart the instance with `docker compose up`.

```
sudo docker compose up -d
```

---

## Configure Google OIDC SSO

:::note

Follow this guide to configure Google SSO using OpenID Connect (OIDC). Refer to the [Sign in with Google](google-sign-in.mdx) to configure SSO using Sign in with Google.

:::

## Requirements

To configure Google OIDC SSO, you must:

- Have admin permissions on Retool Cloud or permissions to add environment variables on self-hosted Retool instances.
- Have permissions to create a Google OAuth Client.

## 1. Create a Google OAuth Client ID

Go to your [Google Developer Console](https://developers.google.com/identity/gsi/web/guides/get-google-api-clientid) and create an **OAuth client ID**.

If you are asked to configure an OAuth consent screen, select **Internal**. Configure the app as a **Web application** and enter `https://retool.your-company.com/oauth2sso/callback` under **Authorized redirect URIs > URIs**.

Save your **Client ID** and **Client secret**.

## 2. Configure settings in Retool

:::note

Google requires the URL parameters `access_type=offline` and `prompt=consent` to obtain refresh tokens, so you should include these in your Auth URL variable.

:::

Configure SSO settings in Retool.

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import SettingsOverride from "../../_settings-override.mdx";

On Retool Cloud and self-hosted Retool versions 3.16 and later, enter settings on **Settings > Single Sign-On (SSO)**.

| Setting        | Example                                                                           |
| -------------- | --------------------------------------------------------------------------------- |
| Client ID      | 22222222222-dq62o6pidgmgrem34fb07klc8qa1308t.apps.googleusercontent.com           |
| Client secret  | xxxxxxxxxxxxxxxxxxxxxxxxxxxx                                                      |
| Scopes         | openid email profile https://www.googleapis.com/auth/userinfo.profile             |
| Auth URL       | `https://accounts.google.com/o/oauth2/v2/auth?access_type=offline&prompt=consent` |
| Token URL      | `https://oauth2.googleapis.com/token`                                             |
| Email key      | idToken.email                                                                     |
| First name key | idToken.given_name                                                                |
| Last name key  | idToken.family_name                                                               |

On self-hosted Retool versions earlier than 3.16, configure the following [environment variables](../../../self-hosted/reference/environment-variables/index.mdx#authentication).

| Environment variable                   | Example                                                                           |
| -------------------------------------- | --------------------------------------------------------------------------------- |
| `CUSTOM_OAUTH2_SSO_CLIENT_ID`          | `22222222222-dq62o6pidgmgrem34fb07klc8qa1308t.apps.googleusercontent.com`         |
| `CUSTOM_OAUTH2_SSO_CLIENT_SECRET`      | `xxxxxxxxxxxxxxxxxxxxxxxxxxxx`                                                    |
| `CUSTOM_OAUTH2_SSO_SCOPES`             | `openid email profile https://www.googleapis.com/auth/userinfo.profile`           |
| `CUSTOM_OAUTH2_SSO_AUTH_URL`           | `https://accounts.google.com/o/oauth2/v2/auth?access_type=offline&prompt=consent` |
| `CUSTOM_OAUTH2_SSO_TOKEN_URL`          | `https://oauth2.googleapis.com/token`                                             |
| `CUSTOM_OAUTH2_SSO_JWT_EMAIL_KEY`      | `idToken.email`                                                                   |
| `CUSTOM_OAUTH2_SSO_JWT_FIRST_NAME_KEY` | `idToken.given_name`                                                              |
| `CUSTOM_OAUTH2_SSO_JWT_LAST_NAME_KEY`  | `idToken.family_name`                                                             |

You can also configure an access token refresh time. Google's tokens expire after one hour. By default, Retool's integration refreshes tokens older than two hours. This means it's recommended to set `CUSTOM_OAUTH2_SSO_ACCESS_TOKEN_LIFESPAN_MINUTES` to refresh the tokens more frequently.

```
CUSTOM_OAUTH2_SSO_ACCESS_TOKEN_LIFESPAN_MINUTES=45
```

---

## Configure Microsoft Entra ID OIDC SSO

import Test from "../_partials/_test-connection.mdx"

To configure SSO with Microsoft Entra ID OIDC, you must:

- Have permission to create an Microsoft Entra ID Enterprise application.
- Have admin permissions on your Retool instance. For self-hosted deployments, you must also have the ability to configure environment variables.

## 1. Create an Microsoft Entra ID Enterprise application

To create an Microsoft Entra ID Enterprise application, follow the steps in [Azure's documentation](https://learn.microsoft.com/en-us/azure/active-directory/manage-apps/add-application-portal-setup-oidc-sso).

1. In the **Microsoft Entra ID portal**, add a new **Enterprise application**.

2. Retool is not listed in the Microsoft Entra ID Gallery, so select **Create your own application**.

3. Name the application.

4. Select **Register an application to integrate with Microsoft Entra ID (App you're developing)**.

5. Under **Supported account types**, select **Accounts in this organizational directory only (Default Directory Only - Single tenant)**.

6. Under **Redirect URI**, select **Web**. Enter `https://retool.yourcompany.com/oauth2sso/callback` under the path, replacing `retool.yourcompany.com` with your Retool instance domain. This specifies the path where Microsoft Entra ID redirects users after they complete authentication.

## 2. Configure secrets

1. In the settings for the new Retool enterprise application, select the **Single sign-on** menu. Select the **App registrations experience**.

2. Select the **Certifications & secrets** menu. Add a new client secret and set an expiration period. You must update your Retool deployment when the secret expires, so you should set the maximum allowable period to **24 months**.

3. Save this secret for use in a later step.

## 3. Configure claims

1. In the **Azure app registration experience**, select the **Token configuration** menu.

2. Select **Add optional claim** for the **ID token**. At a minimum, add the following claims:

- `acct`
- `email`
- `family_name`
- `given_name`

3. When you save the claims, **turn on the Microsoft Graph email, profile permissions**.

4. Optionally, specify additional claims to include for the **Access token**.

## 4. Configure optional group claims

You can optionally map Microsoft Entra ID groups to Retool groups to automatically assign users to groups when they authenticate using SSO. This requires adding group claims to the **ID token**.

1. In the **Azure app registration experience**, select the **Token configuration** menu.

2. Select **Add optional claim** for the **ID token**.

- In the claim, include the groups you want to map to Retool groups.
- Include the **Group ID** for **ID**, **Access**, and **SAML**.

## 5. Retrieve connection details

1. In the **Azure app registration experience**, select the **Overview** menu and select **Endpoints**.

2. Save the following fields:

- Application (client) ID
- OAuth 2.0 authorization endpoint (v2)
- OAuth 2.0 token endpoint (v2)

## 6. Configure settings in Retool

Configure your Microsoft Entra ID settings in Retool.

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import SettingsOverride from "../../_settings-override.mdx";

On Retool Cloud and self-hosted Retool versions 3.16 and later, enter settings on **Settings > Single Sign-On (SSO)**.

| Setting                       | Example                                                            |
| ----------------------------- | ------------------------------------------------------------------ |
| Client ID                     | `CLIENT_ID`                                                        |
| Client secret                 | `CLIENT_SECRET`                                                    |
| Scopes                        | `openid profile email offline_access`                              |
| Auth URL                      | `https://login.microsoftonline.com//oauth2/v2.0/authorize` |
| Token URL                     | `https://login.microsoftonline.com//oauth2/v2.0/token`     |
| Email key                     | `idToken.email`                                                    |
| User info URL (Fat token URL) | `https://yourcompany.idprovider.com/oauth2/v1/userinfo`            |

:::caution

For Microsoft Entra ID OIDC, leave **User info URL (Fat token URL)** unset.

:::

On self-hosted Retool versions earlier than 3.16, add the following [environment variables](../../../self-hosted/reference/environment-variables/index.mdx#authentication) to your Retool instance. Be sure to include the `BASE_DOMAIN` environment variable so links using your domain are correct. Retool's backend tries to determine the `BASE_DOMAIN` if it is not set, but it can be incorrect if your website uses a proxy.

| Environment variable              | Example                                                            |
| --------------------------------- | ------------------------------------------------------------------ |
| `CUSTOM_OAUTH2_SSO_CLIENT_ID`     | `CLIENT_ID`                                                        |
| `CUSTOM_OAUTH2_SSO_CLIENT_SECRET` | `CLIENT_SECRET`                                                    |
| `CUSTOM_OAUTH2_SSO_SCOPES`        | `openid profile email offline_access`                              |
| `CUSTOM_OAUTH2_SSO_AUTH_URL`      | `https://login.microsoftonline.com//oauth2/v2.0/authorize` |
| `CUSTOM_OAUTH2_SSO_TOKEN_URL`     | `https://login.microsoftonline.com//oauth2/v2.0/token`     |
| `CUSTOM_OAUTH2_SSO_JWT_EMAIL_KEY` | `idToken.email`                                                    |
| `CUSTOM_OAUTH2_SSO_USERINFO_URL`  | `https://yourcompany.idprovider.com/oauth2/v1/userinfo`            |
| `BASE_DOMAIN`                     | `https://retool.yourcompany.com`                                   |

See [thin tokens and fat tokens](../custom/oidc.mdx#thin-tokens-and-fat-tokens) for more detail on the **User Info URL** or `CUSTOM_OAUTH2_SSO_USERINFO_URL` [environment variable](../../reference/environment-variables.mdx#custom_oauth2_sso_userinfo_url).

### Optional settings

To pass the user's first name and last name to Retool, set the following settings.

| Setting        | Example               |
| -------------- | --------------------- |
| First name key | `idToken.given_name`  |
| Last name key  | `idToken.family_name` |

import GroupsAdminWarning from "../../_groups_admin_warning.mdx";

If you configured group claims, construct a [role mapping string](../custom/oidc.mdx#role-mapping) to map Microsoft Entra ID group object IDs to Retool group names. Find Microsoft Entra ID group object IDs in the **Azure Groups application**.

For example, given an Microsoft Entra ID group called `Retool Editors` with an object ID of `fd951-f454-4b7a`, use the mapping string `fd951-f454-4b7a -> editor` to assign its members to the Editor group in Retool.

To add role mapping, set the following environment variables in your Retool instance.

| Setting      | Example                     |
| ------------ | --------------------------- |
| Roles key    | `idToken.groups`             |
| Role mapping | `fd951-f454-4b7a -> editor` |

| Environment variable                   | Example               |
| -------------------------------------- | --------------------- |
| `CUSTOM_OAUTH2_SSO_JWT_FIRST_NAME_KEY` | `idToken.given_name`  |
| `CUSTOM_OAUTH2_SSO_JWT_LAST_NAME_KEY`  | `idToken.family_name` |

If you configured group claims, construct a [role mapping string](../custom/oidc.mdx#role-mapping) to map Microsoft Entra ID group object IDs to Retool group names. Find Microsoft Entra ID group object IDs in the **Azure Groups application**.

For example, given an Microsoft Entra ID group called `Retool Editors` with an object ID of `fd951-f454-4b7a`, use the mapping string `fd951-f454-4b7a -> editor` to assign its members to the Editor group in Retool.

To add role mapping, set the following environment variables in your Retool instance.

| Environment variable              | Example                     |
| --------------------------------- | --------------------------- |
| `CUSTOM_OAUTH2_SSO_JWT_ROLES_KEY` | `idToken.groups`            |
| `CUSTOM_OAUTH2_SSO_ROLE_MAPPING`  | `fd951-f454-4b7a -> editor` |

## 7. Test the connection

---

## Configure Microsoft Entra ID SAML SSO

import Test from "../_partials/_test-connection.mdx"

Follow these steps to configure SAML SSO with Microsoft Entra ID for your Retool instance.

## 1. Set your Entity ID in Retool

By default, Retool uses the Entity ID `https://tryretool.com`.

Add the following [environment variable](../../../self-hosted/reference/environment-variables/index.mdx#domains) to your `docker.env` file, replacing `yourcompany.retool.com` with your domain. Note: adding a new environment variable requires restarting the container for it to take effect.

```
DOMAINS=yourcompany.retool.com
```

## 2. Create an Microsoft Entra ID Enterprise application

In the **Microsoft Entra ID admin center**, add a new **Enterprise application**. Retool is not listed in the Microsoft Entra ID Gallery, so you must select **Create your own application**.

Name the application “Retool” and select **Integrate any other application you don’t find in the gallery (Non-gallery)**.

## 3. Assign users to the Retool application in Azure

For users to access Retool using Microsoft Entra ID SSO, they must:

- Be assigned to the application
- Have a First Name, Last Name, User Principal Name, and Email defined on their profile

Assign users to the Retool application and confirm their required attributes in the **Microsoft Entra ID admin center**.

## 4. Configure SAML settings in Azure

In the **Microsoft Entra ID admin center**, select the **Retool** Enterprise application. Set up single sign on for the Retool application, selecting **SAML** as the sign-on method. Use the following SAML settings, replacing `yourcompany.com` with your domain. Leave **Relay state** and **Logout URL** blank.

| Setting                                    | Value                                                                                                                                  |
| ------------------------------------------ | -------------------------------------------------------------------------------------------------------------------------------------- |
| Identifier (Entity ID)                     | `yourcompany.retool.com`                                                                                                               |
| Reply URL (Assertion Consumer Service URL) | On Retool Cloud, `https://your-company.retool.com/api/saml/login`. On self-hosted Retool, `https://retool.your-company.com/saml/login`. |
| Sign on URL                                | On Retool Cloud, `https://your-company.retool.com/api/saml/login`. On self-hosted Retool, `https://retool.your-company.com/saml/login`. |

Set the following attributes and claims.

| Setting                          | Value                    |
| -------------------------------- | ------------------------ |
| Unique User Identifier (Name ID) | `user.mail`              |
| `firstName`                      | `user.givenname`         |
| `lastName`                       | `user.surname`           |
| `email`                          | `user.userprincipalname` |

You must also edit each claim and clear the value for the **Namespace** field.

## 5. Import Azure Federation Metadata into Retool

On the same page you configured SAML settings in the **Microsoft Entra ID admin center**, download the **Federation Metadata** XML file (listed under the SAML Signing Certificate).

Open the XML file in a code editor and copy the contents to your clipboard. Once complete:

1. Navigate to **Settings > Single Sign-On (SSO)**.
2. Select **SAML SSO**.
3. Paste the XML file contents to the **Identity Provider Metadata** field.

## 6. Test the connection

---

## Configure Okta OIDC SSO

import Test from "../_partials/_test-connection.mdx"

To configure Okta OIDC SSO, you need:

- An Okta account with permissions to create an OIDC integration.
- The ability to set environment variables on self-hosted Retool instance, or admin permissions for Retool Cloud.

## 1. Create a new app integration

Follow the steps in Okta to [create a new OIDC integration](https://help.okta.com/en-us/Content/Topics/Apps/Apps_App_Integration_Wizard_OIDC.htm). Use the following settings, replacing `YOUR_RETOOL_DOMAIN` with your Retool instance.

| Setting                | Value                                           |
| ---------------------- | ----------------------------------------------- |
| Sign-on method         | OIDC - OpenID Connect                           |
| Application type       | Web Application                                 |
| Sign-in redirect URIs  | `https://YOUR_RETOOL_DOMAIN/oauth2sso/callback` |
| Sign-out redirect URIs | `https://YOUR_RETOOL_DOMAIN/api/logout`         |

To add a Retool tile in Okta, set the `TRIGGER_OAUTH_2_SSO_LOGIN_AUTOMATICALLY` environment variable to `true` or enable **Trigger login automatically** on **Settings > Single Sign-On (SSO)**. In Okta, use the following settings:

| Setting            | Value                                              |
| ------------------ | -------------------------------------------------- |
| Initiate login URI | `YOUR_RETOOL_DOMAIN`                               |
| Login initiated by | Either Okta or App                                 |
| Login flow         | Redirect to app to initiate login (OIDC Compliant) |

## 2. Configure settings in Retool

Configure your SSO settings in Retool.

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

import SettingsOverride from "../../_settings-override.mdx";

On Retool Cloud and self-hosted Retool versions 3.16 and later, enter settings on **Settings > Single Sign-On (SSO)**. Depending on your setup, you might not need to configure all of these values. If you aren't sure where to find token and auth URLs, try using the [/.well-known/openid-configuration](https://developer.okta.com/docs/reference/api/oidc/#well-known-openid-configuration) endpoint.

| Setting        | Example                                                                  |
| -------------- | ------------------------------------------------------------------------ |
| Client ID      | `CLIENT_ID`                                                              |
| Client secret  | `CLIENT_SECRET`                                                          |
| Scopes         | `openid email offline_access profile`                                    |
| Fat token URL  | `https://yourcompany.okta.com/oauth2/YOUR_AUTH_SERVER_NAME/v1/userinfo`  |
| Auth URL       | `https://yourcompany.okta.com/oauth2/YOUR_AUTH_SERVER_NAME/v1/authorize` |
| Token URL      | `https://yourcompany.okta.com/oauth2/YOUR_AUTH_SERVER_NAME/v1/token`     |
| Email key      | `idToken.email`                                                          |
| First name key | `idToken.given_name`                                                     |
| Last name key  | `idToken.family_name`                                                    |

After you save your settings, you can log in using Okta SSO. You can test out your configuration by logging in from an incognito window.

On self-hosted Retool versions earlier than 3.16, configure the following [environment variables](../../../self-hosted/reference/environment-variables/index.mdx#authentication) on your Retool instance.

| Environment variable                   | Example                                                                  |
| -------------------------------------- | ------------------------------------------------------------------------ |
| `CUSTOM_OAUTH2_SSO_CLIENT_ID`          | `CLIENT_ID`                                                              |
| `CUSTOM_OAUTH2_SSO_CLIENT_SECRET`      | `CLIENT_SECRET`                                                          |
| `CUSTOM_OAUTH2_SSO_SCOPES`             | `openid email offline_access profile`                                    |
| `CUSTOM_OAUTH2_SSO_USERINFO_URL`       | `https://yourcompany.okta.com/oauth2/YOUR_AUTH_SERVER_NAME/v1/userinfo`  |
| `CUSTOM_OAUTH2_SSO_AUTH_URL`           | `https://yourcompany.okta.com/oauth2/YOUR_AUTH_SERVER_NAME/v1/authorize` |
| `CUSTOM_OAUTH2_SSO_TOKEN_URL`          | `https://yourcompany.okta.com/oauth2/YOUR_AUTH_SERVER_NAME/v1/token`     |
| `CUSTOM_OAUTH2_SSO_JWT_EMAIL_KEY`      | `idToken.email`                                                          |
| `CUSTOM_OAUTH2_SSO_JWT_FIRST_NAME_KEY` | `idToken.given_name`                                                     |
| `CUSTOM_OAUTH2_SSO_JWT_LAST_NAME_KEY`  | `idToken.family_name`                                                    |

You can also configure an access token refresh time using the `CUSTOM_OAUTH2_SSO_ACCESS_TOKEN_LIFESPAN_MINUTES` environment variable.

You should also set the `BASE_DOMAIN` environment variable to ensure links using your domain are correct. Retool's backend tries to determine the `BASE_DOMAIN` if it is not set, but it can be incorrect if your website uses a proxy.

```
BASE_DOMAIN=https://retool.yourcompany.com
```

After you restart your Retool instance, you can log in using Okta SSO. You can test out your configuration by logging in from an incognito window.

## Role mapping with Okta Group Claims

import GroupsAdminWarning from "../../_groups_admin_warning.mdx";

Use the following instructions to automatically map your Okta groups with Retool permission groups when a user logs in.

### 1. Create a new scope

Follow the instructions in Okta to create a new [API access scope](https://help.okta.com/en-us/Content/Topics/Security/api-config-scopes.htm) for your authorization server.

### 2. Create a new claim

Follow the instructions in Okta to [create a new claim](https://help.okta.com/en-us/Content/Topics/Security/api-config-claims.htm) and name it `groups`.

In the **Add claim** form, select **ID Token** and **Always** in the dropdown. In the **Value type** section, select **Groups**.

You can add an optional **Filter** to limit the groups to sync.

In the **Scopes** section, add in the API access scope you previously created.

#### Custom claims

To send custom Okta attributes—for example, employee number or department—to Retool, you can configure [custom claims in Okta](https://support.okta.com/help/s/article/How-to-add-custom-attributes-of-user-profile-as-claims-in-token).

1. Add attributes to the Retool profile from **Profile editor** > **Add attributes**, and from **Profile editor** > **Mappings**, map them to the correct fields.
2. Add claims to the authorization server. You may want to limit the scope of these claims.
3. To confirm your custom attributes were correctly added, you can preview a sample token from **Security** > **API** > **Default** > **Preview** in Okta.
4. When you next log in to Retool using SSO, you can view attributes in `current_user.metadata.userInfoResponse`.

### 3. Add additional settings

On Retool Cloud and self-hosted Retool versions 3.16 and later, enter settings on **Settings > Single Sign-on (SSO)**. Add the `groups` scope to the **Scopes** fields.

Specify the roles key—for example, `idToken.groups` —in the **Roles key** field.

Specify any additional remapping in the **Role mapping** field. For example, `Retool devops->admin` maps members of the "Retool devops" group to Retool admins.

On self-hosted Retool versions earlier than 3.16, use [environment variables](../../../self-hosted/reference/environment-variables/index.mdx) to configure additional settings.

Add the `groups` scope to the `CUSTOM_OAUTH2_SSO_SCOPES` environment variable.

```
CUSTOM_OAUTH2_SSO_SCOPES=openid email profile offline_access groups
```

Specify that the groups can be read in the `idToken`.

```
CUSTOM_OAUTH2_SSO_JWT_ROLES_KEY=idToken.groups
```

Specify any additional remapping. The following example maps members of the "Retool devops" group to Retool admins.

```
CUSTOM_OAUTH2_SSO_ROLE_MAPPING=Retool devops -> admin
```

import RoleMappingCaseSensitivity from "../../_role-mapping-case-sensitivity.mdx";

You can also now use `USER_OAUTH2_ACCESS_TOKEN` and `USER_OAUTH2_ID_TOKEN` as [authentication in resources](../custom/oidc.mdx#use-authentication-jwts-in-resources).

## 3. Test the connection

---

## Configure Okta SAML SSO

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import Test from "../_partials/_test-connection.mdx"

To configure Okta SAML SSO, you must:

- Be in **Admin** mode in Okta.
- Have group names that match exactly between Okta and SAML.
- Have admin permissions in Retool.
- For organizations on Retool Cloud, the ability to create a custom SAML application.

## Configuration

1. In your Okta admin dashboard, click **Add Application**.
2. Search for `Retool` and follow the wizard.
3. Navigate to the Okta application you created. Click on the **Sign On** tab, then **Actions > View IdP Metadata** in the **SAML Signing Certificates** section.
4. Save the page as an XML file. Consult Okta's documentation to confirm how to [view the IdP metadata](https://support.okta.com/help/s/article/Location-to-download-Okta-IDP-XML-metadata-for-a-SAML-app-in-the-new-Admin-User-Interface?language=en_US).
5. Copy the contents of the XML file and log in to your Retool instance. Go to the **Single-Sign On (SSO) > Custom SSO** settings, select **SAML SSO**, and paste the XML file contents to the **Identity Provider Metadata** field.
6. If not set already, [assign your app to your user](https://help.okta.com/en-us/content/topics/provisioning/lcm/lcm-assign-app-user.htm) in Okta.

1. Create a [custom SAML application](https://help.okta.com/oag/en-us/Content/Topics/Access-Gateway/add-app-saml-pass-thru-add-okta.htm) in Okta. Use the following settings.

| Setting                     | Value                              |
| --------------------------- | ---------------------------------- |
| Single sign-on URL          | `/api/saml/login` |
| Audience URI (SP Entity ID) | `your-org-domain-without-https`    |
| `firstName` attribute       | `user.firstName`                   |
| `lastName` attribute        | `user.lastName`                    |
| `email` attribute           | `user.email`                       |

2. In the **Feedback** tab, check **I'm a software vendor. I'd like to integrate my app with Okta**.
3. In your app's settings, go to the **Sign On** tab. Under **SAML Signing Certificates** > **SHA-2**, click **Actions** > **View IdP metadata**.
4. Copy the contents of the XML file and log in to Retool. Go to the [Single-Sign On (SSO) settings](https://login.retool.com/auth/login?source=docs&redirectOnLogin=settings/custom-sso), select **SAML SSO**, and paste the XML file contents to the **Identity Provider Metadata** field.
5. On the same page, enter `firstName` and `lastName` in the **Attributes** section.
6. In your Okta app under **Assignments**, assign users or groups to your app.

## Test the connection

---

## Configure OneLogin OIDC SSO

import Test from "./_partials/_test-connection.mdx"

Use this guide to configure OneLogin SSO with OpenID Connect (OIDC) on Retool. Once configured, users can log in to Retool with their OneLogin credentials.

## Requirements

To configure OneLogin SSO, you must:

- Have permissions to add environment variables to your Retool instance.
- Have permissions to create an OIDC application in OneLogin.

## 1. Create an OIDC application in OneLogin

Follow the steps in the [OneLogin OpenID Connect Customer Connector guide](https://onelogin.service-now.com/support?id=kb_article&sys_id=ed442c25db46255057fac24505961975&kb_category=93e869b0db185340d5505eea4b961934) to create a new OIDC application. Use the following settings.

### Configuration page

On the **Configuration** page, under **Redirect URIs**, enter `https:///oauth2sso/callback`.

### Parameters page

On the **Parameters** page, select **Configured by admin** under **Credentials**. In this section, you can add custom claims—for example, `user_id`.

### SSO page

On the **SSO** page, select **Web** as the **Application type**. Select **POST** as the **Token endpoint**.

Save the **Client ID** and **Client secret** to use in Retool.

## 2. Update Retool settings

Configure SSO settings in Retool.

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import SettingsOverride from "../_settings-override.mdx";

On Retool Cloud and self-hosted Retool versions 3.16 and later, enter settings on **Settings > Single Sign-On (SSO)**. Retrieve the values for **Client ID** and **Client secret** from the **SSO** page in OneLogin.

| Setting        | Example                                            |
| -------------- | -------------------------------------------------- |
| Client ID      | `CLIENTID`                                         |
| Client secret  | `CLIENTSECRET`                                     |
| Scopes         | `openid email profile groups params`               |
| Auth URL       | `https://ONELOGINDOMAIN.onelogin.com/oidc/2/auth`  |
| Token URL      | `https://ONELOGINDOMAIN.onelogin.com/oidc/2/token` |
| Email key      | `idToken.email`                                    |
| First name key | `idToken.given_name`                               |
| Last name key  | `idToken.family_name`                              |
| Roles key      | `idToken.groups`                                   |
| Role mapping   | `devops -> admin, support -> viewer`               |

On self-hosted Retool versions earlier than 3.16, configure the following [environment variables](../../self-hosted/reference/environment-variables/index.mdx#authentication) on your Retool instance.

Retrieve the values for `CUSTOM_OAUTH2_SSO_CLIENT_ID` and `CUSTOM_OAUTH2_SSO_CLIENT_SECRET` from the **SSO** page in OneLogin. Replace `ONELOGINDOMAIN` with your OneLogin domain.

| Environment variable                   | Example                                            |
| -------------------------------------- | -------------------------------------------------- |
| `CUSTOM_OAUTH2_SSO_CLIENT_ID`          | `CLIENTID`                                         |
| `CUSTOM_OAUTH2_SSO_CLIENT_SECRET`      | `CLIENTSECRET`                                     |
| `CUSTOM_OAUTH2_SSO_SCOPES`             | `openid email profile groups params`               |
| `CUSTOM_OAUTH2_SSO_AUTH_URL`           | `https://ONELOGINDOMAIN.onelogin.com/oidc/2/auth`  |
| `CUSTOM_OAUTH2_SSO_TOKEN_URL`          | `https://ONELOGINDOMAIN.onelogin.com/oidc/2/token` |
| `CUSTOM_OAUTH2_SSO_JWT_EMAIL_KEY`      | `idToken.email`                                    |
| `CUSTOM_OAUTH2_SSO_JWT_FIRST_NAME_KEY` | `idToken.given_name`                               |
| `CUSTOM_OAUTH2_SSO_JWT_LAST_NAME_KEY`  | `idToken.family_name`                              |
| `CUSTOM_OAUTH2_SSO_JWT_ROLES_KEY`      | `idToken.groups`                                    |
| `CUSTOM_OAUTH2_SSO_ROLE_MAPPING`       | `devops -> admin, support -> viewer`               |

You should also set the `BASE_DOMAIN` environment variable to ensure links using your domain are correct. Retool's backend tries to determine the `BASE_DOMAIN` if it is not set, but it can be incorrect if your website uses a proxy.

```
BASE_DOMAIN=https://retool.yourcompany.com
```

## 3. Test the connection

---

## SSO tutorials

import Tutorial from '/docs/_partials/_doctypes/_tutorial.mdx';

:::tip Learn more about SSO

Read the [quickstart](./quickstart.mdx) guide to learn more about using single-sign on (SSO) with your Retool organization.

:::

---

## Versioned documentation

Retool provides multiple versions of product documentation. The version you use depends on whether your Retool organization is cloud-hosted or self-hosted, and the release channel for your self-hosted deployment.

## Available versions

import Stable from './releases/_partials/_stable.mdx';
import Edge from './releases/_partials/_edge.mdx';

## Cloud and Edge release documentation

**Cloud and Edge** is the default version of Retool's documentation. It reflects the current product state for Retool Cloud and the latest Edge channel release of self-hosted Retool.

## Stable release documentation

---

## Agentic workflows

import Shared from '/docs/_shared/_agentic-workflows.mdx';

---

## Workflow performance best practices

Workflow performance issues can be difficult to replicate, especially when they involve external factors. The following best practices can help avoid problems and reduce the need to debug workflows. Refer to documentation on [limits](./limits.mdx) for details on configurations and limitations around timeout, memory, and cpu at the block and Workflow level.

:::info Query best practices

Refer to the [best practices guide for queries](../../queries/concepts/best-practices.mdx) to learn more about writing performant queries for your data.

:::

Queries that retrieve large amounts of data impact workflow performance. The more data a workflow query requests, the longer it can take for the resource to complete the operation.

Where possible, write queries that return only the results that the workflow needs (e.g., use API pagination and `WHERE` SQL query clauses).

To avoid timeouts, cpu throttling and out-of-memory errors, build separate workflows to perform specific tasks instead of a single workflow that performs them together.

Workflows are [rate-limited](limits.mdx) and have a minimum interval of one minute if triggered via a [schedule trigger](../guides/triggers/schedule.mdx). Additionally, a workflow must also complete its current run—regardless of success or failure—before it can be triggered again using a schedule trigger.

Whether you [schedule](../guides/triggers/schedule.mdx) a workflow to run automatically or trigger it using a [webhook](../guides/triggers/webhooks.mdx) event, make sure that the workflow triggers only when it should run. This also helps reduce the amount of interactions a workflow has with your data source, which can reduce operational costs.

Workflows that work with large datasets can run into [memory or time limits](./limits.mdx). Retool recommends performing load tests on production workflows to ensure that you don't encounter any issues. This is especially important with variably-sized datasets, in which looping or returning data from a code block might fluctuate in load size. Test out your workflow with a larger dataset than expected to ensure that you won't encounter any resource or time constraints.

Make sure you're aggregating metrics across all services, especially `workflows-backend`, `worker`, and `code-executor` pods. If you notice high memory or CPU usage, scale the service vertically or horizontally. To reduce congestion in queued workflows, consider scaling up workers and/or increasing the `WORKFLOW_TEMPORAL_CONCURRENT_TASKS_LIMIT` and `WORKFLOW_TEMPORAL_CONCURRENT_ACTIVITIES_LIMIT` [environment variables](../reference/environment-variables.mdx) to higher values (such as 100). Also, ensure your Temporal deployment is scaled appropriately to support increased traffic.

---

## Workflow IDE

The workflow IDE is the interface you use to build workflows. It is made up of four primary areas:

- [Canvas](#canvas) - Arrange blocks and build your workflow.
- [Left panel](#left-panel) - Add blocks and functions, configure triggers, and configure code libraries.
- [Status bar](#status-bar) - Select an environment and debug workflow runs.
- [Toolbar](#toolbar) - Rename, run, and publish a workflow.

## Canvas

The _canvas_ is the main area of the IDE and is where you build workflows. You add [blocks](../quickstart.mdx) to the canvas that perform specific actions. You can move blocks around using drag-and-drop to position them anywhere on the canvas.

### Navigation controls

The canvas has no size constraints and you can add as many blocks as you need. There are a number of controls to navigate the workflow:

#### Pan

import Minimapsvg from "/img/icons/workflows/minimap.svg";
import Minimapclosesvg from "/img/icons/workflows/minimap-close.svg";

Click and drag anywhere on the canvas to move (pan) around the workflow. You can also pan around the canvas using the minimap at the lower-right corner. The visible area is highlighted—click and drag to move it around.

The  **Minimap** also adjusts when changing the zoom level. Click  to collapse the minimap.

#### Zoom

You can zoom in and out of the canvas to show more content in the visible area. There are multiple ways to adjust the zoom:

- Use the **Zoom** controls in the lower-right of the canvas.
- Mod + or Mod -.
- Mod + Mouse scroll.
- Pinch-to-zoom with a trackpad.

You can quickly return the zoom level to 100% by double-clicking on any area of the canvas or clicking on the zoom level.

#### Fit to screen

import Fitviewsvg from "/img/icons/workflows/fit-view.svg";

Click  **Fit view** to automatically adjust the zoom level to view the entirety of the canvas.

### Layout controls

import Autolayoutsvg from "/img/icons/workflows/autolayout.svg";
import Commentssvg from "/img/icons/workflows/comment.svg";
import Expandsvg from "/img/icons/workflows/expand-all.svg";
import Collapsesvg from "/img/icons/workflows/collapse-all.svg";

You can adjust the layout of blocks on the canvas using the available layout controls:

| Layout control                                             | Description                                                                   |
| ---------------------------------------------------------- | ----------------------------------------------------------------------------- |
|  **Autolayout**    | Automatically arrange blocks on the canvas.                                   |
|  **Expand all**        | Expand all blocks.                                                            |
|  **Collapse all**    | Collapse all blocks.                                                          |
|  **Toggle comments** | Show or hide [block comments](../quickstart.mdx#comments). |

### View controls

import Graphsvg from "/img/icons/workflows/graph-view.svg";
import Treesvg from "/img/icons/workflows/tree-view.svg";

Use the  **Graph view** and  **Tree view** controls at the top-center of the canvas to switch between the standard or vertical view of the workflow.

## Left panel

import Addblocksvg from "/img/icons/workflows/add-block.svg";
import Outlinesvg from "/img/icons/workflows/outline.svg";
import Functionssvg from "/img/icons/workflows/functions.svg";
import Triggerssvg from "/img/icons/workflows/triggers.svg";
import Librariessvg from "/img/icons/workflows/libraries.svg";

The left panel contains a set of tabs to configure functionality of a workflow.

### Blocks

The  **Blocks** tab is one method for [adding blocks](../guides/blocks/blocks.mdx#add-blocks-from-the-toolbar-or-contextual-menu) to the canvas. 

### Outline

import Tabsvg from "/img/icons/workflows/tab.svg";
import Splitviewsvg from "/img/icons/workflows/splitview.svg";

The  **Outline** tab displays a list of all blocks in the workflow. You can click on each block to show it in the canvas. As with blocks on the canvas, blocks in the **Outline** section include an icon that reflects their function.

#### Split view

You can select a block to open it in _split view_, making it easier to edit blocks with complex code. Click  **Split view** in the toolbar to show or hide the split view pane.

:::tip Open blocks in split view

Click  **Open in tab** in the toolbar of any block to open it in split view.

:::

### Functions

The  **Functions** tab is where you configure [Function blocks](../guides/functions.mdx)—reusable blocks that can be called by other blocks. Function blocks don't appear on the canvas due to their purpose and are managed in this area of the panel.

### Triggers

The  **Triggers** tab is where you configure [webhook](../guides/triggers/webhooks.mdx) and [schedule](../guides/triggers/schedule.mdx) triggers to automatically run workflows.

### Libraries

The  **Libraries** tab enables you to use custom [JavaScript](../guides/blocks/code/javascript.mdx) or [Python](../guides/blocks/code/python.mdx) libraries within a workflow. You can select which libraries to use, customize their configuration, and view documentation.

### Releases

The  **Releases** tab allows you to view and create releases. You can also view your workflow's release history, and revert to previous versions.

## Status bar

The status bar contains environment options, run history, and debugging tools. Workflows can run using data sources set up in different [environments](../../org-users/guides/configuration/environments.mdx), such as production and staging. You can select the environment in which a workflow runs from the environment select input on the right of the status bar area.

:::note Configure multiple environments

Multiple environments are available to Retool organizations on [paid plans](https://retool.com/pricing/) and you must configure environment settings for each resource.

:::

import Historysvg from "/img/icons/workflows/runhistory.svg";

The  **Run History** section displays [run logs](workflows/quickstart.mdx#review-and-debug-runs) for a workflow and contains debugging tools, should you need to [troubleshoot a workflow](workflows/quickstart.mdx).

export function Status() {
  return (
    
      
    
  )
}

## Toolbar

import Runsvg from "/img/icons/workflows/run-with-previous.svg";

The _toolbar_ at the top of the IDE contains controls to rename, create or edit the [README](../guides/create-workflows-readme), run, and publish a workflow release.

Use the  **Run** and **Publish release** buttons to run a workflow or [release and publish it](../quickstart.mdx#publishing) it to run automatically.

export function Publish() {
  return (
    
      
    
  )
}

---

## Workflow limits

Retool imposes certain limits on workflow runs and workflow block runs.

## Workflow run limits
A workflow run is a complete execution of a workflow through a trigger (e.g. app, schedule, webhook, Retool Event) or by manually running the workflow in the workflow IDE.

### Timeout

Retool limits the length of time a workflow run can remain in execution before it is automatically terminated.

For asynchronous workflow runs, the timeout is 30 hours. For asynchronous workflows with User Task or Wait blocks, the timeout is unlimited. Individual Wait blocks are limited to a maximum of 60 days.

For synchronous workflows runs, the timeout is 15 minutes up to executing the first webhook Response block. The remainder of the workflow follows the *asynchronous* timeout.

### Memory and CPU

A workflow run can use up to 2.5GB in memory, and 1 vCPU.

A workflow run has no memory and CPU limits by default. To configure limits, set environment variable [`WORKFLOW_MONITOR_PROCESS_ENABLED`](https://docs.retool.com/self-hosted/reference/environment-variables/code-executor#variable-WORKFLOW_MONITOR_PROCESS_ENABLED) to `true` and constrain the memory and CPU usage of the workflow via [`WORKFLOW_MEMORY_LIMIT_MBS`](https://docs.retool.com/self-hosted/reference/environment-variables/code-executor#variable-WORKFLOW_MEMORY_LIMIT_MBS) and [`WORKFLOW_CPU_LIMIT`](https://docs.retool.com/self-hosted/reference/environment-variables/code-executor#variable-WORKFLOW_CPU_LIMIT) respectively.

### Logs

A workflow run has no limits on log generation or storage.

A workflow run can generate and store a maximum of 10MB of logs, after which logs will be truncated.

### Rate limits

*Workflow concurrency* is how many of the same workflow can be actively running within a 15 minute period. If a workflow reaches the concurrency limit, one of the runs must complete (whether successful or not) before another can start.

*Workflow burst limit* is how many runs of the same workflow can be triggered within a 10 second period.

Workflow concurrency is 100, and burst limit is 200.

Workflow concurrency and burst limit are not limited by default and can be configured via environment variables.

### Concurrent external requests

Retool limits the number of in-flight outbound requests to 50 at a time from a single workflow. Self-hosted customers can change this value by changing the `WORKFLOW_REQUEST_CONCURRENCY_LIMIT` [environment variable](../reference/environment-variables.mdx).

### Triggers

#### App triggers
Workflows triggered via an app are not limited by the 2 minute query timeout on cloud or [`DBCONNECTOR_QUERY_TIMEOUT_MS`](../../self-hosted/reference/environment-variables#variable-DBCONNECTOR_QUERY_TIMEOUT_MS) on self-hosted. If there is no webhook response block, the workflow is enqueued for asynchronous execution and responds immediately to the Retool frontend. If there is a webhook response block, the workflow waits to execute all the blocks until the first webhook Response block, respond back to the Retool frontend, and then enqueue the rest of the execution to happen asynchronously.

:::note

On self-hosted instances, any network middlewares (load balancers, proxies, etc.) outside of Retool's control that surround the `MAIN_BACKEND` and `CODE_EXECUTOR` may interfere with long running network requests.

:::

#### Schedule triggers

Workflows triggered via schedule support a minimum interval of one minute. Each workflow must complete its run (whether successful or not) before another run can start. For example, a workflow that takes two minutes to complete can only be triggered every two minutes.

Workflows triggered at intervals via schedule have additional jitter to reduce spikes in queue time and smooth out the load on the system. Jitter is calculated with the following equation: `random(0, min(6 minutes, 10% of the interval))`. For example, a workflow with a 1 hour interval will have a jitter of `random(0, 6 minutes)` and a workflow with a 10 minute interval will have a jitter of `random(0, 1 minute)`. On self-hosted instances, this behavior can be disabled in the Beta settings, by turning off `Enable jitter on cron Workflows.`.

#### Workflow block triggers

Synchronous workflows triggered from another workflow have a timeout of 3 minutes.

## Block limits

Limits covered in this section apply to individual blocks that make up a workflow. These limits apply when blocks are run individually via the workflows editor and when they are run as part of a workflow run.

### Resource blocks

The default timeout is 10 seconds and is configurable with block settings.

For asynchronous workflow runs, resource blocks can run up to 10 minutes. For synchronous workflows runs, resource blocks can run up to 2 minutes.

The default timeout is 10 seconds and is configurable with block settings.

For asynchronous workflows runs, Resource query blocks can run up to 24 days. For synchronous workflows runs, Resource query blocks can run up to 2 minutes.

:::note

**AI Action** blocks have a maximum timeout of 120 seconds. If your call takes longer than 120 seconds, you can instead call the AI provider directly via REST API, which doesn’t have this restriction.

:::

### Code blocks

The default timeout is 10 seconds and is configurable with block settings up to 10 minutes.

The default timeout is 10 seconds and is configurable with block settings up to 24 days.

### Loop blocks

[Loop blocks](../guides/blocks/logic/loop.mdx) can run indefinitely (up to the workflow run timeout), but each iteration has a default of 10 seconds and can run up to 2 minutes.

[Legacy Loop blocks](../guides/blocks/logic/loop-legacy.mdx) have a default of 10 seconds and can run up to 15 minutes, including all iterations.

### Workflow blocks

The default timeout is 10 seconds and is configurable with block settings up to 3 minutes.

---

## Workflow run logs

:::tip

You can use [Ask AI](../../queries/concepts/ask.mdx) to debug JavaScript, SQL, or GraphQL queries using AI-powered debugging.

:::

Retool logs every successful and failed run of a workflow. Click **Run history** in the status bar to debug workflows. 

## Run history

The **Run history** panel contains a list of recent runs, each with their date, time, their status. You can then view the status of each block to see where a failure may have occurred.

Run logs can help troubleshoot problems with queries, such as malformed SQL statements or invalid JavaScript. You can filter log entries by start or end time, by block name, and by **error**, **success**, or **info**. You can also  download JSON data from the **JSON** tab for use in other tool

Keep in mind that queries are considered successful if they didn't return an error. A workflow cannot determine if its actions produced the results you expected.

## Retention period

Admins can enable and update the retention period for **Run History** data from **Settings** > **Advanced** > **Workflows: Enable Data Retention**. The default retention period is 30 days. The maximum retention period is 90 days for Retool Cloud and 365 days for Self-hosted Retool.

---

## Workflows concept guides

import Concept from '/docs/_partials/_doctypes/_concept.mdx';

:::tip Get started with workflows

If you are unfamiliar with Retool Workflows and want to get started: 

- Read the [quickstart](./quickstart) to learn about the fundamental concepts.
- Follow a [tutorial](./tutorial/) to build your first workflow.

:::

---

## Use Invoke Agent blocks in Retool Workflows



---

## Create agentic workflows with the Invoke Agent block

import Connectsvg from "/img/icon-packs/bold/interface-geometric-circle-alternate.svg";

Use the **Invoke Agent** block to trigger a Retool Agent from a workflow. Invoking an agent from a workflow creates an agentic workflow. Refer to the [conceptual guide on agentic workflows](../../../concepts/agentic-workflows.mdx) for more information.

:::note

Some tools require user approval or authentication to execute. These tools are not available in agentic workflows.

:::

This guide provides instructions on how to invoke an agent and retrieve its results. Click the following link to download a sample workflow in JSON form and [import it as a new workflow](../../import-and-export.mdx). Configure the workflow to call your own agent.

  Sample Workflow

## Prerequisites

Before you create an agentic workflow, you must first create an agent. Refer to the [Retool Agents tutorial](../../../../agents/tutorials/agents-tutorial.mdx) for more information.

## Invoke agent

Complete the following steps to add and configure an **Invoke Agent** block:

1. Click and drag  to create a new, connected block.
2. Select **Invoke Agent** as the type of block.
3. Set **Agent** to the agent you want to call.

## Select the return type
The time period it takes to receive a result from an agent can vary widely based on a variety of factors, including the model used, the number of tools called, and the type of reasoning performed. If you need to use the outcome of your agent call in the workflow, you can get the results either synchronously, or asynchronously, by selecting the **Return type**. 

* The **Result (sync)** type is the default setting. This returns the direct result of the agent's output. 
* The **Run state (async)** type returns the `agentRunId`, `agentId`, and `status` only. It does not include the output of the agent. 

:::note
To enable **Result (sync)** for Agents in self-hosted Retool version 3.284.0 or 3.284.1, reach out to your account manager. 

In version 3.284.2, **Result (sync)** for Agents is available by default, and admins can disable it in **Settings > Beta** by toggling the `Agent blocks in workflows sync mode` feature flag. 
:::

export function ArcadeEmbed() {
  return (
    
      
    
  )
}

You can then transform the data returned with a [Code](../../blocks/code/) block, a [Filter](../../blocks/filter) block, or any other action you may want to take within the workflow.  

## Handle responses

Finally, set your workflow up to gracefully handle success and failure.

To return a successful response:

1. Click and drag  to create a new, connected block.
2. Chose the  type.
3. Set the **Status code** to **200**.

To handle a failure:

1. Right-click on the canvas to create a block that is not connected to the rest of the control flow. 
2. Chose the **Response** type.
3. Click the **•••** menu and select **Add global error handler**. This setting configures the block as an error handler that applies to the full workflow.
4. Set the **Status code** to `400`.
5. Paste the following code (or something similar) in the **Return body** field:
    ```json
    workflowContext.currentRun.error
    ```

Test out your workflow by clicking the  button before you publish it.

## Add triggers

Like any other workflow, you can add [triggers](../../../guides/triggers/index.mdx) to run your agentic workflow. Note that if you create a webhook trigger, anyone with access to the webhook will be able to trigger your agent.

## Configure block settings

Refer to the [Wait block reference](../../../reference/objects/block/agent.mdx) for information about the block's settings.

---

## Poll an agent's logs from the Invoke Agent block

import Connectsvg from "/img/icon-packs/bold/interface-geometric-circle-alternate.svg";

You can view the results of the agent's output with the [Result (sync)](../../blocks/agent/invoke-agent#select-the-return-type) type. Or, you can poll an agent from an **Invoke Agent** block to retrieve log information or an agent's response with the **Run state (async)** type.  

## Invoke agent

Complete the following steps to add and configure an **Invoke Agent** block:

1. Click and drag  to create a new, connected block.
2. Select **Invoke Agent** as the type of block.
3. Set **Agent** to the agent you want to call.

## Multi-step functions in agentic workflows

You can write a [multi-step function](../../functions.mdx) to retrieve the agent's response. 

1. Create a new function, and name it `getAgentLogs`.
2. Add two parameters: `agentRunId` and `agentId`.
3. Set the **Type** to **Multi-step**. Click the **Edit function** button to navigate to the multi-step function control flow.
4. Click and drag  to create a new, connected block.
5. Select **Invoke Agent** as the type of block. Name the block `requestAgentLogs`.
6. Set the **Agent** to the agent you want to call.
7. Set the **Return type** to **Run state (async)**. 
7. Choose **JSON** as the **Input Mode** and set the **Agent Inputs** to the following:

  ```json
  { 
    "action": "getLogs", 
    "agentRunId": {{ params.agentRunId }} 
  }
  ```
9. Add a  block with a **Status code** of `200` and return the following: `requestAgentLogs.data`.

The multi-step function
 

## Poll the agent for results

Once you've created a multi-step function, you can poll the agent logs for results. There's no need to do this if you are simply using the workflow to trigger the agent invocation.

1. Click and drag  to create a new, connected block.
2. Select the  block type, and name the block `pollForAgentLogs`.
3. Paste in the following JavaScript code snippet to populate your block:

  ```javascript
  // Defines the polling interval (500ms), the max number of attempts (30), and the statuses that indicate the agent is still running (PENDING, IN_PROGRESS).
  const SLEEP_DURATION_IN_MS = 500;
  const MAX_ITERATIONS = 30;
  const AGENT_PENDING_STATUSES = ["PENDING", "IN_PROGRESS"];

  // A utility function that returns a promise which resolves after 500ms (used for pausing between polls).
  const sleep = () => new Promise(resolve => setTimeout(resolve, SLEEP_DURATION_IN_MS));

  // Extracts the agentId and agentRunId from the invokeAgent block. Initializes latestAgentStatus as "PENDING". latestAgentLogs will store the last retrieved logs, and iterations tracks the number of attempts.
  const { agentId, agentRunId } = invokeAgent.data;
  let latestAgentStatus = "PENDING"; // Initial assumption
  let latestAgentLogs;
  let iterations = 1;

  // Keeps polling as long as the agent is in a pending state and hasn’t exceeded the maximum attempts.
  while (AGENT_PENDING_STATUSES.includes(latestAgentStatus) && iterations 
Polling for agent results

---

## Interact with AI models with the AI action block

The AI action block enables you to leverage Retool AI in workflows. You can write queries that instruct [AI models](../../../data-sources/concepts/models.mdx) to perform different actions, such as generating text or chat responses.

import Aiactionsvg from "/img/icons/workflows/ai-action.svg";

To interact with AI in a workflow, add an  **AI Action** block to the canvas.

## Available actions

Workflows supports the following AI actions:

- [Generate text](../../../queries/guides/ai/text.mdx)
- [Generate chat response](../../../queries/guides/ai/chat.mdx)
- [Generate image](../../../queries/guides/ai/image.mdx)

Refer to these guides to learn how you can write AI action queries.

## Configure block settings

Refer to the [AI Action block reference](../../reference/objects/block/ai-action.mdx) for information about the block's settings.

---

## Assemble workflow blocks

import Addsvg from "/img/icons/workflows/add-block.svg";
import Connectsvg from "/img/icon-packs/bold/interface-geometric-circle-alternate.svg";
import Removesvg from "/img/icons/workflows/remove.svg";
import Runsvg from "/img/icons/workflows/run.svg";
import Startsvg from "/img/icons/workflows/blocks/start.svg";

A workflow contains [blocks](../../quickstart.mdx) that execute actions, such as [resource queries](resource-query.mdx) or [AI actions](ai-action.mdx). Each block connects to another along the workflow's control flow—the connecting line that begins at the  **startTrigger** block—and executes sequentially. Each block must be part of the control flow to execute during a run.

## Connect and disconnect blocks

Click and drag  to create a new, connected block. The **Add block** contextual menu appears from which you select the type of block to add. If you already have two blocks you wish to connect, click and drag from one block to the other.

To disconnect blocks, hover the cursor over the connecting line and click . Any blocks that are not in the control flow (i.e., no connecting line) do not run automatically and display a warning if they are not connected.

## Add blocks from the toolbar or contextual menu

:::info Blocks not connected by default

Blocks you add to the canvas from the  **Blocks** tab or contextual menu are not automatically connected. You must add them to the control flow by connecting them to another block.

:::

Click  in the left panel to open the **Blocks** tab, then drag a block type to the canvas. You can also right-click anywhere on the canvas to display the **Add block** contextual menu.

## Duplicate a block

import Duplicatesvg from "/img/icons/workflows/duplicate.svg";

Click ••• on an existing block and select  **Duplicate**. This duplicates the block's state and any connections to or from it.

## Execute blocks

import Runprevioussvg from "/img/icons/workflows/run-with-previous.svg";

Click  in a block's toolbar to run it individually. The block uses results passed from the previous block in the control flow. The block returns an error if there is no data received from a previous block.

You can also run all previous blocks in the control flow when running a block. Click ••• and select  **Run with previous blocks**. This effectively runs the workflow but stops once it reaches the current block.

---

## Assemble code blocks in Retool Workflows



---

## Execute JavaScript with the Code block

import Codesvg from "/img/icons/workflows/blocks/code.svg";

[JavaScript](../../../../queries/quickstart.mdx) is the primary method for manipulating and transforming data in Retool. Use  **Code** blocks to write custom JavaScript code that can transform data and perform complex logic. You can also use popular [JavaScript libraries](#use-javascript-libraries) to further extend the functionality of workflows.

## Add a JavaScript Code block

To use JavaScript in a workflow, add a  Code block to the canvas and select **JavaScript**.

## Write and execute JavaScript code

import Branchsvg from "/img/icons/workflows/blocks/branch.svg";
import Filtersvg from "/img/icons/workflows/blocks/filter.svg";

You can build complex logic or manipulate data using JavaScript methods like `map()`. For example, you could transform an array of customer records using `map()`:

```javascript title="Map"
const data = query1.data;

return data.map((customer) => ({
  fullName: customer.name,
  emailAddress: customer.email,
}));
```

In general, Retool recommends you visually construct conditional statements with  [Branch](../logic/branch.mdx) blocks or filter query results using  [Filter](../logic/filter.mdx) blocks.

JavaScript Code blocks can also call [functions](../../functions.mdx)—reusable blocks that operate outside the workflow control flow. Functions allow your workflow to perform actions only when required and can receive parameters to use.

## Use JavaScript libraries

Retool includes support for a selection of popular JavaScript libraries which you can use in a workflow. You can browse and add libraries, configure their imports, and use them in your workflow.

### Preloaded libraries

import PreloadedLibraries from "/docs/_shared/_libraries/_preloaded-libraries.mdx";

### Built-in libraries

import BuiltIn from "/docs/_shared/_libraries/_built-in-libraries.mdx";

### Add custom libraries

If the library that you want to use is not available as a preloaded or built-in library, you can import packages from `npm`.

:::caution

Retool automatically tries to use [NsJail](https://github.com/google/nsjail) to sandbox the creation of execution environments for custom libraries. NsJail requires [privileged](https://docs.docker.com/reference/cli/docker/container/run/#privileged) container access. While NsJail [is not required](/changelog/workflow-libaries-without-nsjail) to use custom libraries, it is strongly recommended. 

Privileged mode is not supported by ECS/Fargate deployments. To make use of custom libraries, you must either:

- Migrate to an ECS/EC2 deployment or another supported deployment framework.
- Host the [code-executor](../../../../self-hosted/concepts/architecture#code-executor) service in a separate "jailed" cluster that can run containers in privileged mode on ECS/EC2 or another supported deployment framework. You then configure the [`CODE_EXECUTOR_INGRESS_DOMAIN`](../../../../self-hosted/reference/environment-variables/workflows.mdx#variable-code_executor_ingress_domain) environment variable to communicate with the `code-executor` service over `http` or `https`.

:::

Both Cloud and self-hosted organizations can import *public* packages from `npm`. Self-hosted organizations can also import *private* packages from `npm`. 

### Use libraries in a workflow

You can reference libraries using [JavaScript Code blocks](javascript.mdx) or as inline JavaScript in other blocks using `{{ }}`. You can also use `require()` to include libraries directly within JavaScript Code blocks.

For example, you could use [marked](https://marked.js.org/) to convert Markdown into HTML. This can be useful to generate reports and send them as HTML-formatted rich emails.

```javascript
return marked.parse(query1.data.message);
```

#### Add a public npm package

As with typical Node.js development, you provide a set of libraries to use in a `package.json` file. Retool makes this file available through the Workflow editor. To populate it, navigate to the **Libraries** tab, click **+**, then select **Modify package.json**.

```txt title="package.json"
{
    "dependencies": { 
        "lodash": "4.17.21", 
        "numbro": "2.1.0", 
        "papaparse": "5.3.2", 
        "moment-timezone": "0.5.23",
        "uuid": "3.4.0"
    }
}
```

#### Add a private npm registry

:::caution Requirements

Private npm registries are only supported for organizations using self-hosted Retool on versions 3.36+. You must also configure the [code-executor](../../../../self-hosted/concepts/architecture.mdx#code-executor) service in order to use private npm registries.

:::

Configuring a private npm registry requires setting some environment variables in the code executor service: `NPM_REGISTRIES` and `NPM_REGISTRY_AUTH_LINES`.

`NPM_REGISTRIES` is a comma-separated list of domains, and each entry uses either the `@scope:url` or `url` format.

```
# Support both npm and internal registries based on scope

NPM_REGISTRIES=@mycompany:https://npm.mycompany.com,@supplierco:https://npm.supplierco.com

# Only use internal registry

NPM_REGISTRIES=https://npm.mycompany.com
```

`NPM_REGISTRY_AUTH_LINES` is a comma-separated list of lines to append to a `.npmrc` file. This file is used to authenticate into the configured npm registries and is only required if your npm registry requires authentication. See the [npm documentation](https://docs.npmjs.com/cli/v9/configuring-npm/npmrc#auth-related-configuration) for details on the format.

```
# Authentication for the Github Package repository

NPM_REGISTRY_AUTH_LINES=//npm.pkg.github.com/:_authToken=
```

Once the code executor is configured, you can install packages through the **Modify package.json** option in the Workflows editor.

```txt title="package.json"
{
    "dependencies": { 
        "@mycompany/internal-library": "1.0.0", 
    }
}
```

## Configure block settings

Refer to the [Code block reference](../../../reference/objects/block/code.mdx) for information about the block's settings.

---

## Execute Python with the Code block

import Codesvg from "/img/icons/workflows/blocks/code.svg";

Use  **Code** blocks to write custom Python code that can transform data and perform complex logic. You can also use popular [Python libraries](#available-libraries) to further extend the functionality of workflows.

:::info

To use Python code blocks on self-hosted deployments, you must have the **code-executor** [container](../../../../self-hosted/concepts/architecture.mdx) configured.

:::

`{{ }}` curly braces around embedded expressions are not required in Python.

## Add a Python Code block

To use Python in a workflow, add a Code block to the canvas and select **Python**.

## Write and execute Python code

The Python code editor has much of the same features as the JavaScript editor, such as autocomplete and syntax highlighting. For example, you can transform an array of records in a similar manner to `map()` with JavaScript:

```python
data = query1.data
return [{
   "fullName": customer['name'],
   "emailAddress": customer['email']
} for customer in data]
```

## Python limitations

import Loopsvg from "/img/icons/workflows/blocks/loop.svg";
import Filtersvg from "/img/icons/workflows/blocks/filter.svg";

[JavaScript](../../../../queries/quickstart.mdx) is the primary method for manipulating and transforming data in Retool. To maintain interoperability with other blocks, Python does not support:

- Function block calls or triggering queries.
- Usage within  [Loop](../logic/loop.mdx) and  [Filter](../logic/filter.mdx) blocks.
- Data output in types other than serialized JSON.
- User-imported Python libraries.

## Use Python libraries

Retool supports many popular libraries, and you can import custom libraries from [PyPI](https://pypi.org/).

### Built-in libraries

Workflows includes built-in support for many popular libraries. This enables you to extend the functionality of workflows beyond data transformation. 

To use a built-in Python library:

1. Open the **Libraries** tab, and click **+**. 
2. Select **Add Python library**.
3. Search for the libraries you want to include, and toggle the checkbox to make it available.
4. Click **Add selected libraries**.

export function PythonLibrary() {
  return (
    
      
    
  )
}

You can browse through all built-in libraries below. Some libraries are only available on self-hosted deployments.

### Add custom libraries

:::caution

Retool automatically tries to use [NsJail](https://github.com/google/nsjail) to sandbox the creation of execution environments for custom libraries. NsJail requires [privileged](https://docs.docker.com/reference/cli/docker/container/run/#privileged) container access. While NsJail [is not required](/changelog/workflow-libaries-without-nsjail) to use custom libraries, it is strongly recommended. 

Privileged mode is not supported by ECS/Fargate deployments. To make use of custom libraries, you must either:

- Migrate to an ECS/EC2 deployment or another supported deployment framework.
- Host the [code-executor](../../../../self-hosted/concepts/architecture.mdx#code-executor) service in a separate "jailed" cluster that can run containers in privileged mode on ECS/EC2 or another supported deployment framework. You then configure the [`CODE_EXECUTOR_INGRESS_DOMAIN`](../../../../self-hosted/reference/environment-variables/workflows.mdx#variable-code_executor_ingress_domain) environment variable to communicate with the `code-executor` service over `http` or `https`.

:::

Both Cloud and self-hosted organizations can import public packages from PyPI. Self-hosted organizations can also import private packages from PyPI.

#### Add a public PyPI repository

As with typical Python development, you provide a list of libraries to use in a `requirements.txt` file. Retool makes this available through the Workflow editor. To populate it, navigate to the **Libraries** tab, click **+**, then select **Modify requirements.txt**.

```txt title="requirements.txt"
bson==0.5.10
numpy==1.24.1
pandas==1.5.2
```

export function Public() {
  return (
    
      
    
  )
}

#### Add a private PyPI respository

:::caution Requirements

Private PyPI repositories are only available on self-hosted deployments that have a configured [code-executor](../../../../self-hosted/concepts/architecture.mdx#code-executor) service.

:::

Configuring a private PyPI repository requires setting of two environment variables in the code executor deployment: `PYPI_REPOSITORIES` and `TRUSTED_HOSTS`.

- `PYPI_REPOSITORIES` is a comma-separated list of domains, and each entry is the same format as [index-url flag in pip](https://pip.pypa.io/en/stable/cli/pip_install/#cmdoption-0). The default value is [https://pypi.org/simple](https://pypi.org/simple). Some configurations are below:
- `TRUSTED_HOSTS` is a comma-separated list of domains, and each entry is a domain name, similar to the [trusted-host flag in pip](https://pip.pypa.io/en/stable/cli/pip/#cmdoption-trusted-host). This allows for authentication through pip and may not be required in most circumstances.

```
PYPI_REPOSITORIES=https://pypi.org/simple,https://repository.example.com/simple
TRUSTED_HOSTS=pypi.org,repository.example.com
```

```
PYPI_REPOSITORIES=https://repository.example.com/simple
TRUSTED_HOSTS=repository.example.com
```

Once configured, you can install packages through the **Modify requirements.txt** option in the Workflows editor using the same steps listed in the [Add a public PyPI repository](#add-a-public-pypi-repository) section.

```txt title="requirements.txt"
my_internal_library==0.1.0
```

## Configure block settings

Refer to the [Code block reference](../../../reference/objects/block/code.mdx) for information about the block's settings.

---

## Perform conditional logic with the Branch block

import Branchsvg from "/img/icons/workflows/blocks/branch.svg";

Instead of writing [if...else](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/if...else) statements in JavaScript, you can use  **Branch blocks** to visually build conditional statements that control different connected blocks. This is useful for breaking out complex JavaScript logic into more manageable blocks.

A Branch block evaluates the data it receives from a connected block using the defined condition. If the condition evaluates as a truthy value, the workflow follows the control flow for the **If** statement. If not, it follows the control flow for the **Else** statement.

## Use a Branch block

For example, you could build a workflow that alerts your shipping department if the number of unshipped orders exceeds a certain threshold, such as `query1.data.length > 2`.

You can add multiple branches as **Else if** statements to visually build out complex conditional logic. As you test your workflow, the condition that evaluates as `true` is highlighted in green.

Each conditional statement has its own connector so you can connect different blocks and define separate control flows for each outcome.

## Configure block settings

Refer to the [Branch block reference](../../../reference/objects/block/branch.mdx) for information about the block's settings.

---

## Filter data with the Filter block

Filter blocks enable you to write logic to perform actions with a specific subset of data. If an item evaluates as `true`, the Filter block includes it in the data it returns.

:::warning Apply filters to queries first

Optimize your queries to filter data and return only the results you need first, such as `LIMIT` or `WHERE` clauses for SQL databases or pagination for API requests.

:::

Filter blocks function similar to [Loop blocks](loop.mdx) and iterate through the query you select from the **Iterable** dropdown. Set the **Filter Expression** to a condition that evaluates as `true`, using `value` and `index` to reference evaluated items and their indexes.

For example, you can use a Filter block to return a list of customers with an email that includes `github`.

## Configure block settings

Refer to the [Filter block reference](../../../reference/objects/block/filter.mdx) for information about the block's settings.

---

## Assemble logic blocks in Retool Workflows



---

## Iterate through data with the Loop block

:::info Try out the new Loop block

A [new version of the Loop block](./loop.mdx) is currently in beta.

:::

import Loopsvg from "/img/icons/workflows/blocks/loop.svg";

A  **Loop** block contains an embedded block which runs for each evaluated item in an array. You use `value` and `index` to reference evaluated items and their indexes.

For example, you can automate a welcome email to new customers and customize the message for each recipient, using values like `{{ value.email }}` and `{{ value.name }}`.

## Loop models

The default mode for Loop blocks is **GUI**. This mode automatically configures the loop to iterate through the query data you select from the **Loop input** dropdown. If you require more complex loop logic, use **Code**. This allows you to configure the JavaScript code used by the Loop block. You must specify the query data through which to loop using `value` or `index`.

The _lambda_ operation is run on each item in the loop input. Operations are generally [resource queries](../../../../queries/quickstart.mdx#resource-queries) but you can also write custom JavaScript.

## Configure block settings

:::note Retry settings per iteration or loop

Toggle **Retry per iteration** or **Retry entire loop** to configure retry settings for the query that runs for each item or the loop itself.

:::

import Blocksettings from "../../../reference/objects/block/_settings/_settings.mdx";
import Timeoutsettings from "../../../reference/objects/block/_settings/_timeout.mdx";
import Retrysettings from "../../../reference/objects/block/_settings/_retry.mdx";
import Intervalsettings from "../../../reference/objects/block/_settings/_interval.mdx";
import Exponentialsettings from "../../../reference/objects/block/_settings/_exponential.mdx";
import Finallysettings from "../../../reference/objects/block/_settings/_finally.mdx";
import Coefficientsettings from "../../../reference/objects/block/_settings/_coefficient.mdx";
import Maxintervalsettings from "../../../reference/objects/block/_settings/_max_interval.mdx";

---

## Loop block

A  **Loop block** contains an embedded block which runs for each evaluated item in an array. You use `value` and `index` to reference evaluated items and their indexes.

For example, you can automate a welcome email to new customers and customize the message for each recipient, using values like `{{ value.email }}` and `{{ value.name }}`.

## Configure execution mode

Loop blocks support different modes for processing loop iterations:

- **Parallel**: Executes all iterations simultaneously.
- **Sequential**: Executes each iteration one at a time.
- **Batch**: Combines parallel and sequential modes to execute a parallel iterations in batches.

Within a Loop block, set the **Execution mode** to the mode you want to use.

:::tip

The **Sequential** or **Batch** modes include an optional delay between iterations. This can help prevent API rate limits if the workflow needs loop through a large number of iterations.

:::

### Parallel

**Parallel** mode processes all iterations concurrently. For example, a Loop block that iterates through a list of users to update their information makes the same API request simultaneously.

Parallel loops complete more quickly than sequential or batched loops, resulting in shorter run times. Parallel loops are best for processing small amounts of data. Looping through large datasets can result in API limits or degraded service of your data source.

### Sequential

**Sequential** mode processes each iteration sequentially. Each iteration must complete before the next one starts. For example, a Loop block that iterates through a list of users to update their information makes the same API request one at a time.

If you want to add a delay between sequential iterations, set **Iteration delay (ms)** to the desired amount of time.

Sequential loops take longer to process as each iteration must complete before the next one begins. This is especially useful if you're using APIs with strict rate limits or need to make the minimum amount of changes per iteration.

### Batch

**Batch** mode runs a number of iterations in parallel, waiting for all to complete before moving to the next batch. Update **Batch size** to specify how many iterations should run per batch (default is `10`).

If you want to add a delay between batched iterations, set **Batch delay (ms)** to the desired amount of time.

For example, a Loop block that iterates through a list of users to get their information performs parallel loops in batches. The following diagram illustrates a loop where each batch contains two items.

Batched loops are a combination of parallel and sequential loops. You can find the right balance between concurrent iterations and the delay between each batch for speed and effectiveness.

## Configure block settings

Refer to the [Loop block reference](../../../reference/objects/block/loop.mdx) for information about the block's settings.

---

## Query resources with the Resource query block

:::tip

Learn more about Retool's built-in [API](../../../data-sources/guides/integrations/index.mdx) and [database](../../../data-sources/guides/integrations/index.mdx) integrations, and how to [connect your own data sources](../../../data-sources/index.mdx).

:::

You can add Resource query blocks to workflows that enable you to write [queries](../../../queries/quickstart.mdx#resource-queries) that interact with the resources in your Retool organization, such as SQL databases or APIs.

The available options in a Resource query block depend upon the selected resource. For example, if you select a PostgreSQL database then you can write SQL statements or use **GUI** mode to [construct queries that write or modify data](../../../queries/guides/sql/writes.mdx).

:::warning OAuth resources and workflows

If your resource uses OAuth, make sure **Share credentials between users** is enabled on the resource configuration page. This ensures workflows run automatically.

:::

## Configure block settings

Refer to the [Resource query block reference](../../reference/objects/block/resource-query.mdx) for information about the block's settings.

---

## Respond to webhook events with the Response block

import Responsesvg from "/img/icons/workflows/blocks/response.svg";

Use  **Response** blocks to configure custom responses to [webhook events](../triggers/webhooks.mdx) that trigger workflows. This block returns data to the origin along with a specified HTTP status code.

Webhook-triggered workflows without a Response block immediately respond to the origin. Workflows with a Response block do not respond until this block runs, returning the specified data and HTTP status code.

:::tip Workflows with a Response block are synchronous
The Response block is for use in workflows that provide a timely response to a webhook event. There is a 120-second timeout per block when triggering synchronous workflows.
:::

## Add a Response block

To respond to webhooks, add a  **Response** block to the canvas.

For example, you could use a workflow to look up customer details based on their email, which is returned in the webhook response. You can specify the HTTP **status code** and a JSON **response body** to return, which can include any data from the workflow. The demo below illustrates a brief example of this. 

## Respond differently based on conditions

You can add multiple Response blocks to return different responses based on certain conditions. For example, if there are no results when attempting to look up a customer by email, a different response block could return an error message and status code.

You can also configure a Response block to act as [global error handler](workflows/quickstart.mdx), which runs if an error occurs in a workflow.

## Configure block settings

Refer to the [Response block reference](../../reference/objects/block/response.mdx) for information about the block's settings.

---

## Run another workflow with the Workflow block

import Workflowsvg from "/img/icons/workflows/blocks/workflow.svg";

The  **Workflow** block passes data from the current workflow to another. This is useful for reducing complexity as it enables you to:

- Break down workflows into more manageable functions that perform specific actions (e.g., perform multiple API requests).
- Reuse the same actions across multiple workflows, reducing the amount of duplication across similar workflows (e.g., transform and store data in [Retool Vectors](../../../data-sources/guides/vectors/embeddings.mdx)).

The Workflow block triggers the specified workflow, passing the provided data for it to use. Once run, the specified workflow returns the data back to the current workflow for it to continue.

export function RunWorkflow() {
  return (
    
      
    
  );
}

## Add a Workflow block

:::tip Retool Workflow resource

The Workflow block is powered by the Retool Workflow resource. You can also use this resource in web and mobile apps to run workflows.

:::

To run another workflow, add a  **Workflow** block to the canvas. You then select the workflow to run and specify the execution mode:

| Run Until    | Description                                                                                                               |
| ------------ | ------------------------------------------------------------------------------------------------------------------------- |
| **Finished** | The current workflow execution is paused until the triggered workflow run has completed.                                  |
| **Queued**   | The current workflow execution continues and the triggered workflow run is queued. Both workflows may run simultaneously. |

Specify the parameters to pass into the workflow:

| Parameters | Description                                                                                                               |
| ---------- | ------------------------------------------------------------------------------------------------------------------------- |
| **Raw**    | Reference raw data. This can be any value, such as a string or all JSON data from a previous block (e.g., `query1.data`). |
| **JSON**   | Create a set of key-value pairs using input fields.                                                                       |
| **None**   | Do not pass any data.                                                                                                     |

You do not have to pass any data to the specified workflow. For example, you may want to run a workflow that retrieves data for your primary workflow to then process.

## Run the specified workflow

import Responsesvg from "/img/icons/workflows/blocks/response.svg";

Workflows run from within a workflow operate in a similar way as a [webhook-triggered](../triggers/webhooks.mdx) workflow. When run, data passed from the primary workflow is made available on `startTrigger.data`. You must include a  [Response](response.mdx) block in the workflow to be run—this returns data back to the primary workflow.

## Configure block settings

Refer to the [Workflow block reference](../../reference/objects/block/run-workflow.mdx) for information about the block's settings.

---

## Pause workflow execution with the Wait block

import Wait from "/img/icons/workflows/blocks/wait.svg";

Use the  **Wait** block to pause workflow execution for a specified amount of time. This block is useful for creating a single process that might need to take several hours, days, or weeks. For example, you could use the Wait block to:

- Grant a temporary access token, and revoke it after 24 hours.
- Send abandoned cart emails 1 hour after a customer leaves the website, and again after two days.
- Add a delay between several API calls in a loop to avoid hitting rate limits.

export function ArcadeEmbed() {
  return (
    
      
    
  )
}

Define the duration of the Wait in seconds, minutes, hours, or days. You can use a number or a JavaScript expression that evaluates to a number to define the duration. The maximum wait duration is 60 days.

:::note

Workflows with Wait blocks are still subject to [timeouts](../../concepts/limits.mdx#timeout). For asynchronous workflow runs with Wait blocks, the timeout is 60 days. For synchronous workflows runs, the timeout is 15 minutes up to executing the first webhook Response block. The remainder of the workflow follows the *asynchronous* timeout.

:::

After the Wait block finishes executing, the workflow continues execution of the blocks downstream. Wait blocks only pause execution for blocks that are directly downstream, and they not do not affect blocks that are executed in parallel.

## Configure block settings

Refer to the [Wait block reference](../../reference/objects/block/wait.mdx) for information about the block's settings.

---

## Create a README file with workflows

:::note

This feature is available on Retool Cloud and will be available in subsequent releases of self-hosted Retool. Reach out to your account manager to enable README for workflows. 

:::

You can create a README from the workflow IDE to help clarify important information about your workflow for collaborators. For example, if a workflow requires certain permissions on a resource, or if it's only scheduled to run once a week. 

## Create a README

To add a README to your workflow, click the title of the workflow and add your README content to the **Editor README** field. GitHub-flavored markdown is supported. 

Click the **Preview** link to view the README content in HTML. 

export function WFRM() {
  return (
    
      
    
  )
}

READMEs are visible from the **Edit workflow details** dialog box, in workflows JSON exports, and in a markdown file from Source Control. 

## View a README for a protected workflow

README files can also be viewed from workflows protected with Source Control. 

:::note
For more detailed information about Source Control, refer to [Protect workflows with Source Control](../../source-control/guides/protect/workflows.mdx).    
:::

Once you've [created the README](#create-a-readme) in the workflows IDE, protect the workflow, and create and merge the pull request to view the `README.md` file in your repository. 

export function WFRMSC() {
  return (
    
      
    
  )
}

---

## Configure workflow error handlers

As you build workflows of increasing complexity that interact with more data sources, it's important to handle errors and debug unexpected behavior effectively. You can configure blocks to function as error handlers and perform actions should any errors occur during the run.

## Supported block types

You can configure the following block types to operate as _global error handlers_ that execute if an error occurs anywhere during a workflow run. Note that workflows continue to run even after an error is triggered.

- [Resource query](blocks/resource-query.mdx)
- [AI action](blocks/ai-action.mdx)
- [JavaScript](blocks/code/javascript.mdx) or [Python](blocks/code/python.mdx) Code
- [Loop](blocks/logic/loop.mdx)
- [Response](blocks/response.mdx)

## Configure a block to be an error handler

To configure a block for error handling, click ••• and select **Add global error handler**. Error handlers do not need to be part of the control flow and will execute if the workflow detects an error.

## Retry failures automatically

For more granular error handling, you can configure error handlers to automatically execute again. This allows your workflow to automatically retry failed blocks with a specified schedule. Setting an exponential backoff can be especially useful for retrying blocks that query rate-limited APIs or data sources.

To configure retry settings, select **Settings** on the block. See the block settings, e.g., [Resource query settings](./blocks/resource-query.mdx#configure-block-settings), to learn more.

## Retrieve the workflow error details

You can reference [workflowContext](../reference/objects/workflowcontext.mdx) anywhere in your workflow to include workflow details. For example, you can get the workflow name using `{{ workflowContext.name }}`. This can be useful for distinguishing between workflows that send notifications or including details about when the workflow's actions were last completed.

If a workflow fails, Retool makes the error information available at `workflowContext.currentRun.error`. You can use this when configuring an error handler to log errors from the current run. For example, a Response block can return a `500` status with the error message.

## Review and debug runs

:::tip

You can use [Ask AI](../../queries/concepts/ask.mdx) to debug JavaScript, SQL, or GraphQL queries using AI-powered debugging.

:::

Retool logs every successful and failed run of a workflow. Click **Run history** in the status bar to debug workflows. The **Run history** panel contains a list of recent runs, each with their date, time, their status. You can then view the status of each block to see where a failure may have occurred.

Run logs can help troubleshoot problems with queries, such as malformed SQL statements or invalid JavaScript. You can filter log entries to show only **error**, **success**, or **info** entries. Keep in mind that queries are considered successful if they didn't return an error. A workflow cannot determine if its actions produced the results you expected.

Admins can enable and update the retention period for **Run History** data from **Settings** > **Advanced** > **Workflows: Enable Data Retention**. The default retention period is 30 days, and the maximum retention period is 90 days.

## Monitor usage with run logs

Retool calculates [workflow usage and billing](/support/billing-usage/workflows) based on _runs_. You can view information about workflow runs by reviewing the logs.

---

## Create functions to reuse queries and logic in workflows

*Functions* enable you to create reusable queries or complex logic. You can call functions anywhere in a workflow as function blocks, using JavaScript, or within a [Loop](./blocks/logic/loop.mdx) block. Functions support optional parameters and have access to the global workflow scope.

## Single-step and multi-step functions

You can choose whether a function is *single-step* or *multi-step*. The type you choose depends on the complexity or functionality required.

- **Single-step**: The function contains a single query that runs with optional parameters when called. Single-step functions are useful for simple logic, such as retrieving database records or transforming results.
- **Multi-step**: The function operates as a self-contained workflow with optional parameters. It has its own control flow and is assembled in the same way as its parent workflow. It supports most available block types, including logic and response blocks, and emits block-level logs. Multi-step functions are useful for complex operations with many steps.

:::note

Multi-step functions do not support [user task blocks](./user-tasks.mdx).

:::

## 1. Add a function

import Functionssvg from "/img/icons/workflows/functions.svg";
import Codesvg from "/img/icons/workflows/blocks/code.svg";

First, click  **Functions** in the left panel, then create a function. Then, configure the function. 

1. Define any optional parameters to pass into a function when called. Click **+ Add parameter** and set the parameter name. You can optionally provide a test value that is used only when the function is tested.
2. Select whether to use a single-step or multi-step function type.

:::danger 

Changing a function from multi-step to single-step permanently deletes the multi-step function logic.

:::

export function CreateFunction() {
  return (
    
      
    
  )
}

## 2. Configure function logic

The **Query** section contains the query or code that runs when the function is called. You can select a resource to query, **Run JS Code** or **Run Python Code** to execute JavaScript or Python code, or **Retool Workflow** to trigger another workflow.

For example, you could create a function that sends a trial expiration notification to customers when the trial is three days and one day from expiration. Instead of adding two separate blocks to send emails, you can create a single function and reuse it. The workflow first filters the customer data to determine which trials expire in 24 hours or in three days, then calls the same function. The function receives the customer's name and email address as parameters, along with either `tomorrow` or the trial expiration date.

Configure the resource or code that the function runs when called. 

A multi-step function has its own blocks and control flow. Click **Edit function** to edit the function and assemble its blocks. You can also call other functions from within multi-step functions.

When you edit the function, the canvas switches to **Function** mode so you can assemble the function's blocks directly on the canvas. When in this mode, the canvas background is blue. Click **Return to workflow** at any time to go back to the workflow.

For example, you could create a function that sends a trial expiration notification to customers when the trial is three days and one day from expiration. In the single-step function example, the workflow contained the logic to determine which trials expired in 24 hours and in three days. With a multi-step function, the workflow can be streamlined by offloading the logic to the function. 

A multi-step function with branched logic.

The customer data is passed as the function parameter, and the multi-step workflow handles the remaining logic. Since there is already a single-step function to send emails, the multi-step function can reference it in the same way as the workflow. As a result, the workflow only needs to call the multi-step function after retrieving the customer data.

:::tip 

Logs for multi-step functions are available in the **Run history** panel. These block-level logs are nested under whichever block or loop iteration called the function.

:::

By default, multi-step functions return the results of their final block to their parent workflow. These results can be accessed by referencing the `.data` property of the block that invoked the multi-step function.

## 4. Test the function

Click **▶︎ Test** to run the function. If your function makes use of parameters, any test values you provided are used.

## 5. Call the function from the workflow

import Addsvg from "/img/icons/workflows/add-block.svg";

You can call a function using the following methods:

-  Using the **Function** block to the workflow.
-  Within a JavaScript [Code](./blocks/code/javascript.mdx) block.
-  As the loop runner for a [Loop](./blocks/logic/loop.mdx) block.

:::note

Loop blocks and Function blocks that call multi-step functions do not support custom timeouts. Instead, these blocks use a total timeout that is calculated by adding the timeouts of each block in the multi-step function.

If a timeout is necessary for a multi-step function, you can call the function within a Code blocks and set a timeout on the Code block itself.

The [workflow timeout](../concepts/limits.mdx#timeout) always takes precedence over timeouts set within blocks or functions.

:::

Click  in the left panel to open the **Blocks** tab, then drag the **Function** block type to the canvas. You can also right-click anywhere on the canvas to display the **Add block** contextual menu.

If you defined any parameters for the selected function, the block displays input fields for you to populate. You can then reference any data using `{{ }}` expressions, such as `{{ getCustomersOnTrial.data }}`. 

A streamlined workflow using a multi-step function.

You can call a function from a JavaScript Code block using `await` and the function name. For example:

```javascript
const email = getUsers.data[0].email;
const name = getUsers.data[0].name;

await function1(name, email);
```

Loop blocks can call a function so that it is used for every loop iteration. Set the **Loop runner** to the desired function and use `{{value}}` or `{{index}}` to reference evaluated items in parameters.

A Loop block that calls a function.

The Function block returns its output back to the block from which it was called, allowing the output to be used in the rest of the workflow.

The [Run History menu](../concepts/logs.mdx#run-history) panel shows the workflow run. Click multi-step functions to expand them and see the run logs of the blocks within them.

Run History that includes a multi-step function.

## Convert a group of blocks to a multi-step function

You can convert a group of blocks within an existing workflow to a multi-step function. First, press and hold shift while click-and-dragging on the canvas to select a group of blocks. Next, right-click on the selection area and click **Create function**.

Convert a group of blocks to a function.

The selected blocks are then replaced in the workflow by a Function block that references the newly created function.

---

## Generate a workflow using Retool AI

import RocketSvg from '/img/icon-packs/line/shopping-business-startup.svg';
import Default from "/docs/_shared/_ai-default-model.mdx"

You can use AI to generate a fully functional workflow without the need to build it manually. You provide some instructions and Retool assembles the required blocks with any necessary logic. You can also select a database resource and provide context about table schema.

AI-generated workflows support: 

- Schedule or webhook triggers to automatically run the workflow.
- Resource query blocks that interact with data sources, such as SQL databases.
- JavaScript code that transform data.
- Slack and Retool Email queries that can send notifications. 
- Webhook response blocks to send data as webhook events.

## Generate a new workflow

:::caution Generating with AI overwrites the current workflow

Generating a workflow with AI overwrites any existing workflow blocks and logic you may have already created.

:::

Click  **Get started** in the left panel and select **Generate with AI**. 

Retool provides a selection of sample prompts for you to get started. click **Give example** to cycle through different examples. 

AI-generated workflows are not published automatically. Review and test the workflow to ensure it functions correctly.

## Generate with a resource

You can specify a connected database resource, such as [PostgreSQL](../../data-sources/guides/integrations/database/postgresql.mdx) or [BigQuery](../../data-sources/guides/integrations/database/bigquery.mdx). Click the **Generate with a Resource** dropdown, select the resource to use, then select the tables to reference.

Selecting multiple tables enables you to generate workflows that may require using data spread across different locations. For example, if you want to generate a daily report about inventory at a specific warehouse using its address, including relevant tables allows Retool to generate a workflow that looks up the warehouse ID and filter the inventory data. 

## Generated workflow notifications

You can specify Slack or email in the AI instructions if you want a workflow to send notifications. AI-generated workflows can add Resource query blocks for Slack and Retool Email automatically. If you do not have a Slack resource, you must connect one before you can send Slack notifications. 

## Generated workflow triggers

You can include instructions for triggering a workflow on a schedule or in response to a webhook. Provide details about the triggers and Retool generates a workflow with them automatically configured.

Webhook trigger instructions can also include details about any parameters to use. For example, you could generate a workflow to send a customer survey only if the webhook event contains `"approved": true`.

---

## Import and export workflows

You can import and export workflows to share them across your organization. Importing and exporting is also useful for copying workflows between cloud and self-hosted Retool instances.

The JSON export of a workflow contains its blocks, queries, etc. After importing a workflow, verify that blocks, queries, and their resources are correctly configured.

:::info Import into a different organization

If you export a workflow and import it into a different Retool organization, you must create any required [resources](../../data-sources/quickstarts/resources.mdx).

:::

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

To import a workflow:

- **From the Workflows page**: Click **Create new** and select **From JSON**.
- **In the workflow IDE**: Click **•••** and select **Import from JSON**.

To export a workflow, either:

- **From the Workflows page**: Click **•••** and select **Export and download**.
- **In the workflow IDE**: Click **•••** and select **Export to JSON**.

When you export a workflow, a JSON file is downloaded by your browser.

---

## Report app errors using Retool Events

In addition to built-in support for [reporting app errors](../../../apps/guides/observability/error-reporting.mdx) to Datadog or Sentry, you can use [Retool Events](../retool-events.mdx) to build workflows that automatically trigger whenever an app error occurs. This can be useful for automatically notifying third-party observability providers.

A workflow to send app errors to Sentry using a JavaScript SDK.

## Add a workflow for the event

First, navigate to the  settings in your organization. Click **Add a workflow** to select or create a workflow for the **Report App Errors** event.

  Add a workflow for the **Report App Errors** event.

You can download an example workflow for Datadog, Rollbar, or Sentry as a JSON file and [import it as a new workflow](../import-and-export.mdx). Each workflow contains sample error data for you to use during testing.

## Transform error data

The [App Error](../../../apps/guides/observability/error-reporting.mdx#error-types) event contains detailed information about the error. Observability providers require data to be in a particular shape. You can use the **Code** block within a workflow to transform the error data into a suitable payload before using a [Resource query](../blocks/resource-query.mdx) block to send it.

The following app error example uses JavaScript to transform the error into a digestible format for Datadog.

```json title="App error example" showLineNumbers
{
  "errors": [
    {
      "id": "50f1ffbf-58e7-44f1-9a6b-5bed45fee232",
      "timestamp": 18,
      "origin": "runtime",
      "appUuid": "91e36cb2-2d20-11ef-9a6c-378c1a9d5665",
      "callstack": [
        {
          "type": "error",
          "message": "workflow error",
          "lineNumber": 2,
          "id": "0/transformerRun-1718685005587-0/transformerFailure-1718685005588-1/error-1718685005588-2",
          "timestamp": 1718685005588
        },
        {
          "type": "transformerFailure",
          "transformerId": "transformer1",
          "id": "0/transformerRun-1718685005587-0/transformerFailure-1718685005588-1",
          "timestamp": 1718685005588
        },
        {
          "type": "transformerRun",
          "transformerId": "transformer1",
          "id": "0/transformerRun-1718685005587-0",
          "timestamp": 1718685005587
        },
        { "type": "loadEvent", "id": "0", "timestamp": 1718685005587 }
      ],
      "tags": {}
    }
  ]
}
```

```js title="Transform data" showLineNumbers
console.log("errors", startTrigger.data.errors);

const errors = [];

for (const error of startTrigger.data.errors) {
  errors.push({
    timestamp: error.timestamp,
    ddsource: error.origin,
    status: "error",
    ddtags: JSON.stringify(error.tags),
    service: "retool-error-monitor",
    message: error.errorMessage,
    error: {
      stack: error.callstack.map((node) => node.message).join("\n"),
      message: error.errorMessage,
      type: error.origin,
    },
    ...error.tags,
    callstack: error.callstack,
  });
}
return JSON.stringify(errors);
```

```js title="Result" showLineNumbers
[
  {
    timestamp: 18,
    ddsource: "runtime",
    status: "error",
    ddtags: "{}",
    service: "retool-error-monitor",
    error: { stack: "workflow error\n\n\n", type: "runtime" },
    callstack: [
      {
        type: "error",
        message: "workflow error",
        lineNumber: 2,
        id: "0/transformerRun-1718685005587-0/transformerFailure-1718685005588-1/error-1718685005588-2",
        timestamp: 1718685005588,
      },
      {
        type: "transformerFailure",
        transformerId: "transformer1",
        id: "0/transformerRun-1718685005587-0/transformerFailure-1718685005588-1",
        timestamp: 1718685005588,
      },
      {
        type: "transformerRun",
        transformerId: "transformer1",
        id: "0/transformerRun-1718685005587-0",
        timestamp: 1718685005587,
      },
      { type: "loadEvent", id: "0", timestamp: 1718685005587 },
    ],
  },
];
```

## Send errors to an observability provider

Observability providers typically receive error logs using an API or SDK. The method you use depends on the provider.

- Using an API (e.g., Datadog or Rollbar): Create a resource that's configured with the necessary settings. You can then select this resource in the workflow.
- Using a JavaScript SDK (e.g., Sentry): If necessary, use [configuration variables](../../../org-users/guides/configuration/config-vars.mdx) to store secret keys. You can then reference them when using custom [JavaScript](../blocks/code/javascript.mdx#add-a-library) or [Python](../blocks/code/python.mdx#add-custom-libraries) libraries to send app errors without exposing sensitive information in the workflow.

You can send app errors to most observability providers with an API or SDK. The following examples explain how to send errors to Datadog, Rollbar, and Sentry.

Add a **Resource query** block to the workflow and select the **REST API** resource. To send error logs, use the **POST /api/v2/logs** endpoint, add your Datadog API Key to the header, and provide the transformed data as the raw body in the request.

  A Resource query block to send app errors to Datadog.

First, create a resource for the [Rollbar API](https://docs.rollbar.com/reference/getting-started-1) using the [REST API](../../../data-sources/guides/integrations/api/rest.mdx) integration. You then configure the resource with the Rollbar API base URL (`https://api.rollbar.com/api/1`) and a `X-Rollbar-Access-Token` header with a valid access token.

  Rollbar resource configuration.

Next, add a **Resource query** block to the workflow and select the Rollbar resource. To send error logs, specify the `/item` API endpoint and and provide the transformed data as the raw body in the request.

You can use Sentry's JavaScript SDK to send app error logs by adding the **@sentry/node** [custom JavaScript library](../blocks/code/javascript.mdx#use-javascript-libraries) to the workflow. Once added, you can write JavaScript code that uses the SDK.

To add the SDK:

1. Open the **Libraries** tab.
2. Click **≠** and select **Add JavaScript library**.
3. Select the **@sentry/node** library.
4. Click **Add selected libraries**.

Once you add the SDK, you need to include it in the workflow's setup scripts. This enables the SDK for use in the worfklow. Navigate to the **Settings** tab and select **JavaScript configuration**. Add the requirement for **@sentry/node**:

```js
const Sentry = require("@sentry/node");
```

You can then add a **Code** block to the workflow and write the script to sends app errors to Sentry.

The Sentry SDK uses a [Data Source Name](https://docs.sentry.io/concepts/key-terms/dsn-explainer/) (DSN) to identify the source of reported logs. While this does not need to be kept secret, you should still store it in a configuration variable. You can then reference it across multiple workflows, should it be necessary, which makes it easier to manage and update.

## Publish the workflow

Once you create a workflow, you must [publish](../version-and-publish.mdx) it to begin automatically sending app error reports to providers. Whenever you make changes to a workflow, you must also publish those changes for them to take effect.

After publishing the workflow, create an app and perform actions that would cause an error. For example:

- Write an invalid query that fails to run.
- Create a test resource, reference it in the app in a query, then delete the resource.

---

## Observability



---

## Workflow observability and error reporting

import Observability from "../../../_shared/_observability.mdx";
import Filtering from "../../../_shared/_filtering-routing.mdx";

## Run log and error types

Datadog categorizes errors into `info`, `warn`, or `error` logs. Sentry reports only `error` logs.

## Run log and error tags

Tags can be used to filter, categorize, or route errors to different owners using the following format: `tag:value`.

| Datadog Tag              | Details                                                                                 | Example                                |
| ------------------------ | --------------------------------------------------------------------------------------- | -------------------------------------- |
| `blockName`              | The name of block run.                                                                  | `errorCodeBlock`                       |
| `blockType`              | The type of block run.                                                                  | `code`                                 |
| `duration`               | The duration of the run in seconds.                                                     | `6.821332`                             |
| `endTimestamp`           | The end timestamp in UTC milliseconds.                                                  | `1746058640525`                        |
| `environmentId`          | The environment ID.                                                                     | `production`                           |
| `error`                  | The error or event.                                                                     | `Error: Example error (line1)`         |
| `eventType`              | The workflow action taken (`WORKFLOW_RUN_START`, `BLOCK_RUN_END`, etc).                 | `BLOCK_RUN_END`                        |
| `multiStepFunctionId`    | The ID of a multi-step function used in a block or workflow.                            | `35bf8cf3-5000-4f93-81d1-af23po5k24d3` |
| `multiStepFunctionName`  | The name of a multi-step function used in a block or workflow.                          | `function2`                            |
| `multiStepFunctionRunId` | The ID of multi-step function run of a block or workflow.                               | `30117fb3-9720-4c0a-927c-a54994c72cd0` |
| `organizationId`         | The organization ID.                                                                    | `1`                                    |
| `release`                | The Retool version.                                                                     | `3.198.0`                              |
| `runStatus`              | The status for block and workflow runs (`SUCCESS`, `FAILURE`, `NOT_ENOUGH_TIME`, etc).  | `FAILURE`                              |
| `startTimestamp`         | The start timestamp in UTC milliseconds.                                                | `1746058958620`             |
| `status`                 | The status for the run (`info`, `error`, or `warn`).                                    | `error`                                |
| `triggerType`            | The method in which the workflow was triggered (`manual`, `scheduled`, `webhook`, etc). | `manual`                               |
| `workflowId`             | The workflow ID.                                                                        | `4634f898-97b1-4be5-bc73-c417d90b00be` |
| `workflowName`           | The worflow name.                                                                       | `Workflow Name`                        |
| `workflowRunId`          | The workflow run ID.                                                                    | `6ccaaa77-ca91-8fd9-5ca38-ec41d524m32` |

| Sentry Tag            | Details                                                                                 | Example                                |
| --------------------- | --------------------------------------------------------------------------------------- | -------------------------------------- |
| `blockName`           | The name of the block.                                                                  | `errorCodeBlock`                       |
| `blockType`           | The type of block.                                                                      | `code`                                 |
| `environment`         | The environment ID.                                                                     | `production`                           |
| `eventType`           | The workflow action taken (`WORKFLOW_RUN_START`, `BLOCK_RUN_END`, etc).                 | `BLOCK_RUN_END`                        |
| `level`               | The type of log.                                                                        | `error`                                |
| `multiStepFunctionId` | The ID of a multi-step function used in a block or workflow.                            | `35bf8cf3-5000-4f93-81d1-af23po5k24d3` |
| `release`             | The Retool version.                                                                     | `3.198.0`                              |
| `runtime`             | The runtime version.                                                                    | `node v20.18.1`                        |
| `runtime.name`        | The runtime name.                                                                       | `node`                                 |
| `server_name`         | The server name.                                                                        | `MacBook-H1TTF4FRWR`                   |
| `triggerType`         | The method in which the workflow was triggered (`manual`, `scheduled`, `webhook`, etc). | `manual`                               |
| `workflowId`          | The workflow ID.                                                                        | `4634f898-97b1-4be5-bc73-c417d90b00be` |
| `workflowName`        | The worflow name.                                                                       | `Workflow Name`                        |
| `workflowRunId`       | The workflow run ID.                                                                    | `6ccaaa77-ca91-8fd9-5ca38-ec41d524m32` |

---

## Trigger workflows with Retool Events

:::info

You must be an admin to configure Retool Events. Access to the workflows triggered by Retool Events is determined by existing [workflow permissions](../../permissions/guides.mdx).

:::

With [Retool Events](../reference/retool-events.mdx), organization admins can build workflows that run automatically in response to certain events in Retool. When an event is triggered, any associated workflows with pre-defined parameters are triggered.

You can even [configure branding options](../../org-users/concepts/branding.mdx) to replace Retool's built-in email notifications with workflows that send custom transactional emails with a reply-to address at your domain. When doing so, you should set up appropriate alerts as error handlers in your workflows.

## Configure Retool Event workflows

Navigate to the [Retool Events](https://login.retool.com/auth/login?source=docs&redirectOnLogin=settings/events) settings in your organization. From here, you can browse available events and add workflows that trigger in response to them.

| Event                                   | Description                                                                                                                                                                           |
| --------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Password Reset Required**             | Triggered when a user requests their password reset.                                                                                                                                  |
| **Report App Errors**                   | Triggered whenever an app error is reported.                                                                                                                                          |
| **User Invited**                        | Triggered whenever a user is invited to your organization.                                                                                                                            |
| **User Created**                        | Triggered whenever a new user is added to your organization. Does not trigger on user invites or access requests, until the user accepts and/or is approved to join the organization. |
| **User Requested Access**               | Triggered whenever a user requests access to your organization.                                                                                                                       |
| **Source Control Deployment Completed** | Triggered whenever a source control deployment is completed.                                                                                                                          |
| **Login Attempted**                     | Triggered when users attempt to log in. Runs after a user is authenticated, but before they complete the login process.                                                               |

Click **Add a workflow** to select or create a workflow that runs whenever the respective event is triggered. If you add a new workflow, Retool creates one using a starter template for common use cases related to the event.

export function AddWorkflow() {
  return (
    
      
    
  );
}

### Reference event properties

Retool Event-triggered workflows display the related event in the **Enabled triggers** of the [Start block](../quickstart.mdx). These triggers are only available when you add workflows from the Retool Events settings page.

Data for the event is made available from the Start block. You can reference this anywhere in the workflow using `{{ startTrigger.data }}`. This contains different properties depending on the event type.

Refer to the [Retool Events reference](../reference/retool-events.mdx) to learn about the available properties for each event type.

### Configure workflow actions

Many Retool lifecycle events are related to organization and user administration, so workflows triggered from Retool Events often involve sending emails. The **User Invited** template is pre-populated with a [Resource query block](./blocks/resource-query.mdx) using Retool Email, but you can configure this to use SendGrid or another email provider.

The `sendUserInvite` block of the **User Invited Template** sends an email to the user invited to Retool, using the `invitedUserEmail` parameter as the **To** address. The email's body also contains links to the `inviteLink` parameter. When you construct your email blocks and templates, ensure you use the provided parameters to direct your users to the correct actions.

#### Login Attempted response structure

When using the Login Attempted event to trigger a workflow, you can use one of the following three redirect variables, which trigger custom redirect behavior upon successful authentication.

A response with `logoutErrorMessage` prevents a user from logging in and navigates the user back to the login page with the given error message displayed.

A response with `appId` redirects the user to a Retool app, identified by either a custom URL slug or the app's ID.

A response with `url` logs in the user and redirects them to a URL.

Using these redirects overrides any default landing page redirects set for the user’s permissions groups.

:::note

If your workflow involves sending emails, remember to disable Retool's default emails. Navigate to **Settings** > **Branding**. Select the appropriate email from the dropdown, and click **Manage**. Check the **Disable the Retool-managed email** setting.

:::

### Configure error handlers for failed events

To ensure workflows run as expected, you can configure [error handlers](./error-handlers.mdx). This enables you to perform additional actions, such as receive a notification, if an error occurs and the workflow could not complete successfully.

#### Handling errors for Login Attempted workflows

If a global error handler is not enabled in the login workflow and a failure occurs, users will still be able to log into their Retool accounts, but any configured redirects will not be applied. To ensure proper handling of failures, Retool recommends enabling a [global error handler](./error-handlers.mdx#configure-a-block-to-be-an-error-handler) in the login workflow. This handler determines the behavior when a failure occurs.

If the error handler response includes an `appId` or `url`, users will still be able to log in, and the error handler’s redirect will be applied.

If it is critical for the workflow to succeed in order for users to log in, you can return a `logoutErrorMessage` upon failure. This prevents users from logging in if the workflow encounters an error. However, this should only be used if the workflow contains security-critical logic, as it can easily lead to locking out all users.

---

## Configure triggers in Retool Workflows



---

## Trigger workflows with queries

You can trigger a workflow using messages polled from [Amazon SQS](../../../data-sources/guides/integrations/streaming/amazon-sqs.mdx) or [Kafka](../../../data-sources/guides/integrations/streaming/kafka.mdx) streaming services. Query triggers poll a topic or queue on a configured interval and trigger a workflow run for each message retrieved.

## Add a query trigger

import Startsvg from "/img/icons/workflows/blocks/start.svg";
import Triggerssvg from "/img/icons/workflows/triggers.svg";

To add a trigger, click the  **startTrigger** block or open the  **Triggers** tab in the left panel.

You can create multiple query triggers to poll for messages from different queues and at different intervals, in addition to using a [webhook](./webhooks.mdx) or [schedule](./schedule.mdx) trigger. The highest frequency at which you can poll for messages is once per minute.

If you use an Amazon SQS resource, the **Action type** is automatically set to **Receive messages from a queue**. For a Kafka resource, the **Action type** is automatically set to **Consume messages from a topic**.

## Set polling options

Expand the **Advanced Settings** section to configure how often you want Retool to poll for new messages. You can schedule polling using **Interval** mode to specify the frequency using a set of options. For more granularity, use **Cron** mode to provide [cron syntax](https://en.wikipedia.org/wiki/Cron).

### Configure querying on an interval

Use the **Schedule** option to configure a Retool to poll for messages periodically. You can configure a schedule that triggers every `n` minutes, hours, days, weeks, or months.

### Configure querying on a cron schedule

:::tip Cron examples
Check out some [examples](https://crontab.guru/examples.html) to learn more about cron syntax.
:::

Retool Workflows supports [cron syntax](https://en.wikipedia.org/wiki/Cron) when configuring a query trigger. The bottom of the **Advanced Settings** section displays a human-readable version of the values you provide. You can also hover the cursor over the label for each input to display a tooltip with syntax reference.

## Configure workflow run behavior

Workflows function differently depending on whether you use them with Amazon SQS or Kafka.

- Retool ensures that each unique message is used by only one workflow run at a time. Two workflows cannot action on the same message at the same time.
- Query triggers can receive up to 20 SQS messages at one time, and Retool triggers a unique workflow run per message. The workflow runs execute in parallel.
- Because SQS supports only one consumer group per queue, you cannot have more than one workflow consuming from the same SQS queue.

- Retool ensures that each unique message is used by only one workflow run at a time. Two workflows cannot action on the same message at the same time.
- Query triggers can consume up to 100 Kafka messages at one time, and Retool triggers a unique workflow run per message. The workflow runs execute in parallel.
- Because Kafka supports multiple consumer groups, you can have multiple workflows consuming from the same Kafka topic. Each query trigger must specify a distinct consumer group.

### Conclude the workflow run

At the end of each workflow run, you must mark the message as deleted (Amazon SQS) or committed (Kafka) to prevent it from being retrieved by the next query trigger. Complete the following steps to ensure that each message is consumed only once.

1. Add a resource query block to your workflow that accesses your Amazon SQS resource.
2. Set the **Action type** to `Delete a message from a queue`.
3. Set the **Queue** to the same queue that you defined in the query trigger.
4. Set the **Receipt Handle** to `{{startTrigger.data.receiptHandle}}`.

1. Add a resource query block to your workflow that accesses your Kafka resource.
2. Set the **Action type** to `Commit messages in a topic`.
3. Set the **Topic Name** and **Consumer Group** to the same topic name and consumer group that you defined in the query trigger.
4. Set the **Partition** to `{{startTrigger.data.partition}}`.
5. Set the **Offset** to ` {{startTrigger.data.offset}}`.

---

## Trigger workflows periodically

You can add _schedule_ triggers that run workflows automatically at regular intervals. You schedule workflows using **Interval** mode to specify the frequency using a set of options. For more granularity, use **Cron** mode to provide [cron syntax](https://en.wikipedia.org/wiki/Cron). You can also specify a timezone so that the workflow schedule runs based on local time.

## Add a schedule trigger

import Startsvg from "/img/icons/workflows/blocks/start.svg";
import Triggerssvg from "/img/icons/workflows/triggers.svg";

To add a trigger, click the  **startTrigger** block or open the  **Triggers** tab in the left panel.

You can create multiple schedule triggers to run workflows at different intervals, in addition to using a [webhook](webhooks.mdx) trigger.

## Configure an interval schedule

Add a **Schedule** trigger to configure a workflow to run periodically. You can configure a schedule that triggers every `n` minutes, hours, days, weeks, or months.

## Configure a cron schedule

:::tip Cron examples
Check out some [examples](https://crontab.guru/examples.html) to learn more about cron syntax.
:::

Retool Workflows supports [cron syntax](https://en.wikipedia.org/wiki/Cron) when configuring a schedule. The block displays a human-readable version of the values you provide. You can also hover the cursor over the label for each input to display a tooltip with syntax reference.

---

## Trigger workflows with webhooks

You can add _webhook_ triggers that run workflows automatically whenever it receives a webhook event, such as a service monitoring alert or when a payment is received. The workflow can reference data in the event's JSON payload in the same way as other block data. If necessary, you can also configure a workflow to respond to webhook events using the **Response** block, returning data back to the webhook origin.

## Add a webhook trigger

import Startsvg from "/img/icons/workflows/blocks/start.svg";
import Triggerssvg from "/img/icons/workflows/triggers.svg";

To add a trigger, click the  **startTrigger** block or open the  **Triggers** tab in the left panel.

export function CreateTrigger() {
  return (
    
      
    
  )
}

### Create webhook alias and path parameters

Use the **Alias** setting to create a custom URL path for your webhook trigger. The resulting webhook URL is formatted as `https://{domain}/url/{alias}`. For example: `https://example.retool.com/url/test-webhook`. Enable the **Public** setting if you want it to be possible to call your webhook URL without the API key.

You can also configure your custom URL path to include dynamic path parameters. This allows you to capture variable data directly from the request path and pass it to the workflow as input. Reference path parameters using `startTrigger.pathParams`.

For example, you could set **Alias** to `/orders/:id/status`. A user would send a request to `https://example.retool.com/url/my-custom-alias/orders/12345/status`. The path parameter `:id` is dynamically resolved to `12345`, and this value is then passed to the workflow as part of the execution input.

Dynamic path parameters have a few limitations that you must keep in mind:

- Only required, string parameters are supported. No wildcard parameters.
- Paths much be unique. For example, Retool disallows the creation of `/orders/:id` if `/orders/:status` already exists.
- Do not use duplicate parameter names, such as `/orders/:id/status/:id`.
- The first segment of the alias must be static.
- Do not include trailing slashes.

## Test headers and parameters

Use the **Test Headers**, **Test Path Parameters** and **Test JSON Parameters** settings in the Trigger block of your workflow to test your trigger without needing to manually call the endpoint.

You can reference the `startTrigger.headers`, `startTrigger.pathParams`, and `startTrigger.data` properties in the rest of your workflow.

Test headers and parameters are used only for manual runs. For actual runs triggered via webhook, real data is used instead.

## Send a webhook event

:::danger Do not publicize endpoint URLs

Any request sent to the specified endpoint will trigger the workflow. Do not share or publicize this information.

:::

Copy the endpoint URL and use it as the webhook event destination to trigger webhook events. Webhook events sent to the workflow endpoint must use `Content-Type: application/json`. A JSON payload is optional.

You can also copy the provided cURL command to send an event as you build and test your workflow.

```shell title="Example cURL command"
curl -X POST --url "https://api.retool.com/v1/workflows/43rewfs-7da9-ddgfet32-fddfr3-43rewf344gre/startTrigger" --data '{"hello":"world"}' -H 'Content-Type: application/json' -H 'X-Workflow-Api-Key: retool_wk_fdsedgf3t4t3grg34354656'
```

### Authenticate webhook events

You can authenticate webhook events by using one of the following in the request:

- The `X-Workflow-Api-Key` header.
- The `workflowApiKey` query parameter.

Retool recommends using `X-Workflow-Api-Key` header unless your intended usage only supports query parameters (e.g., third-party integrations). Be wary when including the secret API key as a query parameter as it can be logged since it is part of the URL.

## Retrieve event payload

Workflows can read data from a webhook event's JSON payload (e.g., error message or confirmation number) and make it available to your workflow. The following example of a Stripe event that occurs when a [Setup Intent](https://docs.stripe.com/api/setup_intents) is created. This event payload includes details about the event, including the Setup Intent's properties.

```json title="Stripe event"
{
  "id": "evt_1NG8Du2eZvKYlo2CUI79vXWy",
  "object": "event",
  "api_version": "2019-02-19",
  "created": 1686089970,
  "data": {
    "object": {
      "id": "seti_1NG8Du2eZvKYlo2C9XMqbR0x",
      "object": "setup_intent",
      "application": null,
      "automatic_payment_methods": null,
      "cancellation_reason": null,
      "client_secret": "seti_1NG8Du2eZvKYlo2C9XMqbR0x_secret_O2CdhLwGFh2Aej7bCY7qp8jlIuyR8DJ",
      "created": 1686089970,
      "customer": null,
      "description": null,
      "flow_directions": null,
      "last_setup_error": null,
      "latest_attempt": null,
      "livemode": false,
      "mandate": null,
      "metadata": {},
      "next_action": null,
      "on_behalf_of": null,
      "payment_method": "pm_1NG8Du2eZvKYlo2CYzzldNr7",
      "payment_method_options": {
        "acss_debit": {
          "currency": "cad",
          "mandate_options": {
            "interval_description": "First day of every month",
            "payment_schedule": "interval",
            "transaction_type": "personal"
          },
          "verification_method": "automatic"
        }
      },
      "payment_method_types": [
        "acss_debit"
      ],
      "single_use_mandate": null,
      "status": "requires_confirmation",
      "usage": "off_session"
    }
  },
  "livemode": false,
  "pending_webhooks": 0,
  "request": {
    "id": null,
    "idempotency_key": null
  },
  "type": "setup_intent.created"
}
```

You can then reference event properties anywhere in your workflows with the `startTrigger.data` object. For the example above, you can reference the Setup Intent ID within the payload using `{{ startTrigger.data.data.object.id }}`, which is `seti_1NG8Du2eZvKYlo2C9XMqbR0x`.

## Rotating API Key

To rotate the API key, click the **Rotate** button from the webhook trigger panel. This action generates a new API key and immediately invalidates the previous one. Update any callsites with the new API key to continue triggering the workflow successfully. 

Key rotation is immediate and the previous key will no longer work. Depending on your use case, it may take time to update your services and integrations, which can cause downtime. Since each workflow has a unique API key, an alternative approach is to duplicate an existing workflow and update your services or integrations to use it. 
 1. Navigate to your organization's list of workflows.
 1. Click *•••*  and select **Duplicate workflow**.
 1. Deploy the duplicated workflow. 
 
 Update all services and integrations to use the new workflow. Once completed, you can safely delete the old workflow.

 ### Best practices for key rotation

To minimize disruption during webhook API key rotation, especially in enterprise and multi-instance environments, follow these best practices:
- **Plan for manual rotation:** A developer or admin must click **Rotate** in production currently. In multi-instance deployment, developers may not have production access. Teams should explicitly define who is responsible for rotating keys. 
- **Avoid breaking dependencies:** Duplicating or moving workflows can break app or workflow triggers, UUID-based references, and git history.
- **Keep external webhooks thin:** Use webhook workflows only as entry points and forward requests to internal, triggered workflows.
- **Adopt clear naming conventions:** Distinguish between external and internal workflows (e.g., name the workflow `External Webhook: My Key Action`), and use aliases to keep external URLs stable.
- **Validate end-to-end:** After rotation, confirm all triggers and downstream workflows still function correctly.

---

## Configure user tasks

User Tasks enable you to build human-in-the-loop workflows that require a user to take action before the workflow proceeds. The **User Task** block pauses a workflow and creates a user task within the organization. Users then review and action tasks using Retool apps. Only when a user submits task completion using a Retool app does the workflow containing the user task block resume.

Workflows containing a User Task block provide context data for a user task which is accessible from the Retool app. When actioned, the user task can provide output data back to the workflow.

## Create user tasks from a workflow

:::info Provision use access to the associated app

User groups assigned to a user task must also have use access to the associated app where the user tasks are exposed to users. If not, users cannot use the app to complete user tasks.

:::

To create user tasks, add the **User Task** block to the control flow of a workflow. You then configure the following block fields:

| Setting          | Description                                                          |
| ---------------- | -------------------------------------------------------------------- |
| **Assign To**  | The users or groups that can action user tasks created by this workflow. |
| **App**          | The Retool app with which to review and action tasks.                |
| **Task Context** | Additional data from the workflow to include with the user task.     |
| **Expiry Time (days)** | The length of time after which the task expires. |

The User Task block.

All user tasks initially have `status` of `pending`. This changes to `submitted` once a user actions the task. When the User Task block runs, no further blocks along the control flow run until the task is actioned.

### Set user task assignments

:::info

User task permissions are optional. If unset, any user in the organization can view and action the user task.

:::

You can specify which users and [permission groups](../../permissions/guides/configure-permission-groups) are allowed to action tasks created by the User Task block. This is useful for restricting processes to a particular set of users, such as only allowing the finance team to administer refund requests.

Select a user or permission group.

You can also dynamically assign user tasks to users and groups using conditional logic. Click  for the **Assignments** field and then specify custom JavaScript logic to dynamically evaluate assignments.

:::caution

If your organization uses Source Control and has multiple instances of self-hosted Retool, ensure that user emails and group names are the same across instances.

:::

When dynamically assigning tasks, the **Assignments** field expects an `assignment` object with the following properties.

export const userAssignmentObject = {
  email: {},
  name: {
    "description": "The user name."
  },
  type: {
    "setting": "",
    "type": "enum",
        "values": [
      {
        "description": "The user to assign.",
        "value": "user"
      },
      {
        "description": "The group to assign.",
        "value": "group"
      },
    ],
    "description": "The assignment type."
  },
};

export const groupAssignmentObject = {
  name: {
    "description": "The group name."
  },
  type: {
    "setting": "",
    "type": "enum",
        "values": [
      {
        "description": "The user to assign.",
        "value": "user"
      },
      {
        "description": "The group to assign.",
        "value": "group"
      },
    ],
    "description": "The assignment type."
  },
};

The [retoolContext](../../apps/reference/objects/retoolcontext.mdx) global object contains `groups` and `users` properties with the necessary information.

```json
if (getCaseload.data >= 5) {
  return retoolContext.users['jenny@example.com']
} else {
  return retoolContext.users['admin@example.com']
}
```

The [retoolContext](../../apps/reference/objects/retoolcontext.mdx) global object contains `groups` and `users` properties with the necessary information.

```json
if (getCaseload.data >= 5) {
  return retoolContext.groups['Operations']
} else {
  return retoolContext.groups['Escalation Team']
}
```

Dynamically assign users or permission groups.

You can also use a combination of users and groups when determining assignment.

```json title="Group and user assigmment"
if (getCaseload.data >= 5) {
  return [retoolContext.users['jenny@example.com'], retoolContext.groups['Operations']]
} else {
  return [retoolContext.users['admin@example.com'],retoolContext.groups['Escalation Team']
}
```

### Create the user tasks app

:::info Use the same permissions for the workflow and app

Workflows that create user tasks and their associated apps must both use the same permission groups. If not, users cannot use the app to action user tasks.

:::

You create a Retool app from the User Task block for users to action tasks. Once you add a **User Task** block, click **Create User Task** to create a task review app using the default template. This starter app includes basic functionality for managing user tasks. If you have **Edit** or **Own** permissions to app folders, you can create your app within any of those folders. The app inherits any folder-level permissions, if set.

You can run the User Task block as you build and test your workflow. When manually run, the Workflow:

- Displays a modal in the Workflows IDE that contains the Retool app.
- Creates a test user task for testing the workflow and app whilst it runs.

### Provide task context

The User Task block can include additional data to use as context for the user task (e.g., order details). You can reference this data within Retool apps from a task's `context.result.data` property to populate component values, reference in queries, etc.

Task context is evaluated as JavaScript and must either reference or return a valid value (e.g., `startTrigger.data`).

### Set task expiration

Use the **Expiry Time** field to specify length of time, in days, after which the task automatically expires. If no value is provided, the task does not expire. When a task expires, its `status` automatically updates to `expired`. Use integer or float numbers to specify the duration, such as `1` or `1.5`.

After the task runs, you can reference the `expiryMetadata` property of the User Task block to reference expiration details. For example, to send a time-sensitive [notification](#send-new-task-notifications). `expiryMetadata` is an object with the following properties.

export const expiryMetadata = {
  "expiryTimeMs": {
    "description": "The time, in milliseconds, until expiration.",
    "type": "number"
  },
  "endDateEpochMs": {
    "description": "The end date, in milliseconds since the UNIX epoch.",
    "type": "number"
  },
  type: {
    "setting": "",
    "description": "The expiration type."
  },
};

Within an app, you can reference a task's `expiresAt` property to retrieve expiration details.

### Specify task admins

Users in the permission groups you select can review and action tasks using the Retool app. You can optionally specify **Task admin** permission groups in the block's **Settings** which allow those users to manage the tasks in the [Tasks Console](#manage-tasks-with-the-tasks-console).

### Send new task notifications

import Bell from "/img/icon-packs/bold/interface-alert-alarm-bell-2.svg";

The User Task block includes an additional connection to trigger another block when it creates a user task. Click  and select a block to use. For example, you could add a **Resource query** block to send messages using Retool Email, Slack, etc.

When the User Task block creates a task, it generates a direct URL for the Retool app with a reference to a unique task ID in a URL parameter. You can reference the `taskURL` property when sending notifications so that users can navigate directly to app and view the newly created task.

Send a Slack notification when a new task is created.

## Review and action user tasks from an app

:::tip

Retool organizations on the Enterprise plan can use the [Retool API](../../api/index.mdx) to programmatically manage tasks.

:::

The starter app you create from the User Task block includes basic functionality for reviewing and actioning user tasks. You can modify the starter app based on your needs.

### Write queries to interact with user tasks

Queries interact with user tasks within Retool apps. The user tasks app created by the workflow is preloaded with queries to get user tasks created by the workflow, get details of a specific task, and mark the user task as `submitted`.

The starter app includes `getUserTasks`, `getSingleUserTask`, and `submitUserTask` queries for you to use. To create these queries yourself:

1. Open the **Code** tab.
2. Create a **Resource query**.
3. Select the **User Action** resource.
4. Select the **User Task** type.

There are three actions from which you can choose when querying user tasks.

The **Get All User Tasks** action retrieves a list of all user tasks for which the current user has access. You can specify the following options:

| Option               | Description                                                                                                            |
| -------------------- | ---------------------------------------------------------------------------------------------------------------------- |
| **Workflow**         | The workflow that created the user task.                                                                               |
| **User task**        | The name of the User Task block within the workflow. A workflow can create user tasks using multiple User Task blocks. |
| **Status**           | The task status.                                                                                                       |
| **Created After**    | User tasks created after the specified date.                                                                           |
| **Created Before**   | User tasks created before the specified date                                                                           |
| **Submitted After**  | User tasks actioned as submitted after the specified date.                                                             |
| **Submitted Before** | User tasks actioned as submitted before the specified date.                                                            |
| **Next Token**       | The next token from the previous API response. This is used for pagination for an arbitrary number of tasks.           |

Use the **Get User Task** action to retrieve a specific user task using the provided task ID. When you run a workflow containing User Task blocks, the `taskURL` of the associated block includes the the user Task ID as a URL parameter (`urlparams.hash.userTaskId`) to direct a user to that specific task.

You can specify the following options:

| Option           | Description                          |
| ---------------- | ------------------------------------ |
| **User Task ID** | The ID of the user task to retrieve. |

Use the **Submit User Task** action to mark the user task as `submitted`. The workflow resumes its run and receives any specified output from the app.

You can specify the following options:

| Option           | Description                             |
| ---------------- | --------------------------------------- |
| **User Task ID** | The ID of the user task to action.      |
| **Task Output**  | A value that is passed to the workflow. |

Use the **Reassign User Task** action to reassign the task to a different permission group.

You can specify the following options:

| Option           | Description                                           |
| ---------------- | ----------------------------------------------------- |
| **User Task ID** | The ID of the user task to action.                    |
| **Reassign To**  | A list of permission groups for which you can assign. |

Use the **Cancel User Task** action to cancel the task. Canceled tasks have a status of `canceled`.

You can specify the following options:

| Option                  | Description                             |
| ----------------------- | --------------------------------------- |
| **User Task ID**        | The ID of the user task to action.      |
| **Cancellation Reason** | The reason for canceling the user task. |

### Task context and output

Each user task has state. A user task's `context` property contains the information provided by the workflow, such as the task context, which you can reference anywhere in the app.

The **Complete User Task** action includes an optional output that is saved to `output`. This data is passed back to the workflow to use as it resumes.

You can build workflows with conditional logic that perform different actions based on this output. For example, you can use the **Branch** block to determine whether to reimburse an expense based on whether the output contains `"approved": true` or `"approved": false`.

## Manage tasks with the Tasks Console

:::info Action tasks using Retool apps

The Tasks Console cannot be used to action user tasks. Use a [Retool app](#select-the-review-app) to review and action user tasks.

:::

The **Tasks** tab of the organization contains the **Tasks Console**. From here, users can search for tasks, view task details, change the assigned permission group, or cancel tasks.

Admins can view all tasks across the organization. Task admins—users in permission groups specified in the User Task block settings—can only view tasks for which they are designated as task admins. All other users cannot access the Tasks Console.

### View task information

The Tasks Console displays a table of all user tasks. Each column corresponds to a property of the User Task object. To view more details about a specific task, click **>** to expand the row.

### Cancel a task

User tasks are initially created with a `pending` status. Tasks that are no longer required can be canceled by clicking **Cancel Task**.

### Reassign a task

Click **Reassign Task** to change the permission groups for a specific user task. As with [User Task block permissions](#set-permissions), you can select users and permission groups from a list or dynamically assign them.

## User task storage for self-hosted deployments

Retool stores all data related to user tasks, including user task context and outputs, in your deployment's externalized `postgres` database.

---

## Version and publish workflows

You must publish a workflow before it can run automatically using a [schedule](triggers/schedule.mdx) or with [webhooks](triggers/webhooks.mdx). The workflow IDE automatically saves changes to your workflow but you must publish them to take effect. This allows you to build a new workflow, or make changes to an existing one, without disruption.

When you publish a workflow, Retool creates a versioned release. Each release of a workflow has its own version number and reflects the workflow's state at that specific point in time. Only the published version is used by Retool. This allows you to safely test and build changes without disruption.

:::info Current working version
Any changes you make to a Retool workflow are automatically saved to the current working version. This version contains any changes that have not yet been published.
:::

## Publish a workflow release

Click **Publish release** in the toolbar to create and publish a new version of the workflow. Retool uses [Semantic Versioning](https://semver.org/) and automatically increments the version number based on your selection of **Major**, **Minor**, or **Patch** versioning.

:::note

For [protected workflows](../../source-control/guides/protect/workflows.mdx), create a new release from the  **Releases** tab in the left-hand menu.

:::

:::info Multi-instance releases

If you're using [multi-instance releases](../../source-control/guides/multi-instance-releases.mdx), you can manage different release versions of protected workflows across multiple deployment instances. This allows you to test newer versions on development or staging instances before promoting to production.

:::

import Workflowsvg from "/img/icons/workflows/blocks/workflow.svg";

If your workflow [calls another workflow](./blocks/run-workflow.mdx) using a  **Workflow** block, you can also choose to publish changes to the referenced workflow.

export function Publish() {
  return (
    
      
    
  )
}

## Manage releases

The  **Releases** tab contains a list of every published version of a workflow. The currently published version includes a **Live** tag.

| Property       | Description                                |
| :------------- | :----------------------------------------- |
| Version number | The version number (e.g., `1.0.2`).        |
| Description    | The description of the version.            |
| Author         | The Retool user who published the version. |
| Publish date   | When the version was last published.       |

## Unpublish a release
:::note

This feature is currently rolling out on Retool Cloud and will be available in subsequent releases of self-hosted Retool. Reach out to your account manager to enable unpublish for workflows.

:::

To unpublish a published release, click the **•••** menu of the **Live** release in the  **Releases** tab, and select **Unpublish release**. Until a new release is published, the latest save shown on the canvas will be live to users. 

export function Unpublish() {
  return (
    
      
    
  )
}

:::note
Published releases on [protected workflows](../../source-control/guides/protect/workflows.mdx) can also be unpublished. When unpublishing a release on a protected workflow, the latest saved version on the main branch will be live to users.
:::

## Preview a release

From the **Releases** tab, click the **•••** menu and select **Preview release** to preview it in the workflow IDE.

## Publish an existing release

You can publish an existing version of a workflow at any time. Open the **•••** menu for the version to publish, then select **Publish release**.

If you want to remove any releases and are certain they are no longer needed, you can also delete them permanently.

## Revert to a previous release

You can revert the current working version of your app to the state from a previous version. All changes since this version are discarded but still remain in the history. This does not affect any other releases and doesn't change the published release.

This is useful if you've made a series of changes in the current working version but want to revert the app to an earlier point.

---

## Workflows how-to guides

import Howto from '/docs/_partials/_doctypes/_howto.mdx';

:::tip Get started with workflows

If you are unfamiliar with Retool Workflows and want to get started: 

- Read the [quickstart](./quickstart) to learn about the fundamental concepts.
- Follow a [tutorial](./tutorial/) to build your first workflows.

:::

---

## Retool Workflows documentation

[Retool Workflows](https://retool.com/products/workflows) enables you to build complex automations that interact with your data sources. Connect pre-built query blocks together that can interact with resources, transform data, and run additional logic. Trigger workflows automatically with custom schedules or using webhook events.

---

## Retool Workflows quickstart

import Filtersvg from "/img/icons/workflows/blocks/filter.svg";
import Startsvg from "/img/icons/workflows/blocks/start.svg";
import Querysvg from "/img/icons/workflows/blocks/resource-query.svg";
import Branchsvg from "/img/icons/workflows/blocks/branch.svg";

This guide serves as an introduction to [Retool Workflows](https://retool.com/products/workflows). It covers many of the concepts and terminology you would come across as you build workflows to automate tasks. After reading this page, you should have a good understanding of the fundamentals for building workflows.

## Introduction

A workflow is an automation that interacts with your data sources. It contains a series of connected pre-built _blocks_ that interact with resources, transform data, and run additional logic. Each workflow runs automatically using a schedule or triggered with webhook events.

## Assemble blocks that interact with data {#blocks}

import Browsers from '/docs/_shared/_supported-browsers.mdx';

Workflows are comprised of _blocks_. A block is a type of [query](../queries/quickstart.mdx#resource-queries) that interacts with data (e.g., querying a database) or performs an action (e.g., execute JavaScript code). Blocks are modular and have internal state—you can reference block properties in any subsequent block. For example, a block named `findUser` can be referenced using `findUser.data`.

You drag and drop blocks in the [workflow IDE](concepts/ide.mdx), then configure them to interact with data or perform actions. You connect blocks together to define the control flow which determines the order that each block executes. Blocks can reference the results of previous blocks that have already executed, passing along the results to the next block.

## Set the order of operation {#control-flow}

Blocks connect together and execute sequentially during a run. This defines the order of operation and flow of data, known as the control flow. The connecting line between blocks visually represents the control flow, which can be a single path or branch to perform parallel operations.

Any block that is part of the control flow is executed during a workflow run, beginning with the  **startTrigger** block.

:::note

Blocks that have two connected inputs are executed after *both* inputs complete execution.

:::

## Use JavaScript to connect blocks together

You can [write JavaScript](../queries/quickstart.mdx) almost anywhere in a workflow using `{{ }}`. Each block can access data from any other block that has already executed. For example, the `getDataFromGithub`  [Resource query](guides/blocks/resource-query.mdx) retrieves data which the `processData` block uses. The output from `processData` is then used to run the `upsertToPostgres` block to update a database.

The control flow is not limited to a single path. A block can output data to multiple blocks that perform parallel actions, creating multiple paths. The  [Branch](guides/blocks/logic/branch.mdx) block can also perform conditional logic that outputs different results along different paths.

The following example illustrates a workflow that retrieves a list of customers. It then iterates through the list of customers to check whether they were a sales lead. If they were, it notifies the Sales team. If not, it sends the customer a welcome email.

You can always reference a previous block that is not currently part of the same control flow path. The workflow IDE automatically connects the blocks together and displays the connecting line.

## Call functions outside the control flow

Functions are reusable blocks that run in a headless state. They operate outside of the control flow and do not appear on the canvas. You call a function from [JavaScript](guides/blocks/code/javascript.mdx) Code blocks which can pass data as parameters. This reduces the need for query duplication and enables you to perform certain tasks only when necessary.

## Trigger workflows automatically

Workflows automatically run based on _trigger_ conditions. You can configure a workflow to run at a regular [schedule](guides/triggers/schedule.mdx) or in response to [webhook events](guides/triggers/webhooks.mdx).

### Schedules

You can add multiple schedule triggers to a workflow so that it runs at different intervals. This makes it possible to run workflows at different times that cannot be expressed as a simple repeating schedule. For example, you can create multiple triggers to schedule a workflow to run at 9am every Monday, 11pm every Wednesday, and 3am on the first day of the month.

Schedule triggers also support _cron_ syntax, which enables you to define a schedule with more granularity. For example, you can schedule a workflow to trigger at 9.30am every Monday, Wednesday, and Friday, but only between January and September:

| Cron         | Value   | Description                         |
| ------------ | ------- | ----------------------------------- |
| Minutes      | `30`    | 30 minutes past the hour.           |
| Hours        | `9`     | 9am.                                |
| Day of month | `*`     | Any day of the month.               |
| Month        | `1-9`   | Only January to September.          |
| Day of week  | `1,3,5` | Only Monday, Wednesday, and Friday. |

### Webhooks

Workflows can run in response to _webhook events_, such as a payment notification from [Stripe](../data-sources/guides/integrations/finance/stripe.mdx) or an incident alert from PagerDuty. Each workflow has a unique webhook endpoint URL with which to receive webhook events. You use this URL when configuring webhook notifications from other services.

```shell title="Example cURL command"
curl -X POST --url "https://api.retool.com/v1/workflows/43rewfs-7da9-ddgfet32-fddfr3-43rewf344gre/startTrigger?workflowApiKey=retool_wk_fdsedgf3t4t3grg34354656" --data '{"hello":"world"}' -H 'Content-Type: application/json'
```

Workflows can read data from a webhook event's JSON payload (e.g., error message or confirmation number) and make it available to your workflow. This makes it possible for workflows to process received data, such as logging new orders to a database.

### Publishing

You must publish a workflow release before it can run automatically using a [schedule](guides/triggers/schedule.mdx) or with [webhooks](guides/triggers/webhooks.mdx). The [workflow IDE](concepts/ide.mdx) automatically saves changes to your workflow but you must publish them to take effect. This allows you to build a new workflow, or make changes to an existing one, without disruption.

When you publish a workflow, Retool creates a versioned release. Each release of a workflow has its own version number and reflects the workflow's state at that specific point in time. Only the published version is used by Retool. This allows you to safely test and build changes without disruption.

## Review run logs

Retool logs every successful and failed run of a workflow. The **Run history** panel contains a list of recent runs, each with their date, time, their status. You can then view the status of each block to see where a failure may have occurred.

Run logs can help troubleshoot problems with queries, such as malformed SQL statements or invalid JavaScript. You can filter log entries to show only **error**, **success**, or **info** entries. Keep in mind that queries are considered successful if they didn't return an error. A workflow cannot determine if its actions produced the results you expected.

## Error handling

Retool enables you to configure blocks to be [global error handlers](workflows/quickstart.mdx#configure-error-handling) that run whenever an error occurs, such as sending a Slack notification. These blocks do not have to be part of the control flow to run in the event of an error.

---

## Retool Workflows environment variables

Use environment variables to configure Retool Workflows for self-hosted deployments.

## Code executor

import CodeExecutor from "@site/docs/self-hosted/reference/environment-variables/code-executor.mdx";

import Workflows from "@site/docs/self-hosted/reference/environment-variables/workflows.mdx";

## Workflows

---

## Workflows glossary

import SharedGlossary from '../../_partials/_glossary.mdx';

---

## Workflow IDE keyboard shortcuts

Use Retool's built-in keyboard shortcuts to quickly perform certain actions or control the interface.

---

## The Invoke Agent block

## Properties

## Settings

import Blocksettings from "./_settings/_settings.mdx";
import Timeoutsettings from "./_settings/_timeout.mdx";
import Retrysettings from "./_settings/_retry.mdx";
import Intervalsettings from "./_settings/_interval.mdx";
import Exponentialsettings from "./_settings/_exponential.mdx";
import Finallysettings from "./_settings/_finally.mdx";
import Coefficientsettings from "./_settings/_coefficient.mdx";
import Maxintervalsettings from "./_settings/_max_interval.mdx";

---

## The AI Action block

## Properties

## Settings

import Blocksettings from "./_settings/_settings.mdx";
import Timeoutsettings from "./_settings/_timeout.mdx";
import Retrysettings from "./_settings/_retry.mdx";
import Intervalsettings from "./_settings/_interval.mdx";
import Exponentialsettings from "./_settings/_exponential.mdx";
import Finallysettings from "./_settings/_finally.mdx";
import Coefficientsettings from "./_settings/_coefficient.mdx";
import Maxintervalsettings from "./_settings/_max_interval.mdx";

---

## The Branch block

## Properties

## Settings

import Blocksettings from "./_settings/_settings.mdx";
import Timeoutsettings from "./_settings/_timeout.mdx";

---

## The Code block

## Properties

## Settings

import Blocksettings from "./_settings/_settings.mdx";
import Timeoutsettings from "./_settings/_timeout.mdx";
import Retrysettings from "./_settings/_retry.mdx";
import Intervalsettings from "./_settings/_interval.mdx";
import Exponentialsettings from "./_settings/_exponential.mdx";
import Finallysettings from "./_settings/_finally.mdx";
import Coefficientsettings from "./_settings/_coefficient.mdx";
import Maxintervalsettings from "./_settings/_max_interval.mdx";

---

## The Filter block

## Properties

## Settings

import Blocksettings from "./_settings/_settings.mdx";
import Timeoutsettings from "./_settings/_timeout.mdx";

---

## Block objects



---

## The Loop block

## Properties

## Settings

import Blocksettings from "./_settings/_settings.mdx";
import Timeoutsettings from "./_settings/_timeout.mdx";
import Retrysettings from "./_settings/_retry.mdx";
import Intervalsettings from "./_settings/_interval.mdx";
import Exponentialsettings from "./_settings/_exponential.mdx";
import Finallysettings from "./_settings/_finally.mdx";
import Coefficientsettings from "./_settings/_coefficient.mdx";
import Maxintervalsettings from "./_settings/_max_interval.mdx";

---

## The Resource query block

## Properties

## Settings

import Blocksettings from "./_settings/_settings.mdx";
import Timeoutsettings from "./_settings/_timeout.mdx";
import Retrysettings from "./_settings/_retry.mdx";
import Intervalsettings from "./_settings/_interval.mdx";
import Exponentialsettings from "./_settings/_exponential.mdx";
import Finallysettings from "./_settings/_finally.mdx";
import Coefficientsettings from "./_settings/_coefficient.mdx";
import Maxintervalsettings from "./_settings/_max_interval.mdx";

---

## The Response block

## Properties

## Settings

import Blocksettings from "./_settings/_settings.mdx";
import Timeoutsettings from "./_settings/_timeout.mdx";
import Retrysettings from "./_settings/_retry.mdx";
import Intervalsettings from "./_settings/_interval.mdx";
import Exponentialsettings from "./_settings/_exponential.mdx";
import Finallysettings from "./_settings/_finally.mdx";
import Coefficientsettings from "./_settings/_coefficient.mdx";
import Maxintervalsettings from "./_settings/_max_interval.mdx";

---

## The Workflow block

## Properties

## Settings

import Blocksettings from "./_settings/_settings.mdx";
import Timeoutsettings from "./_settings/_timeout.mdx";
import Retrysettings from "./_settings/_retry.mdx";
import Intervalsettings from "./_settings/_interval.mdx";
import Exponentialsettings from "./_settings/_exponential.mdx";
import Finallysettings from "./_settings/_finally.mdx";
import Coefficientsettings from "./_settings/_coefficient.mdx";
import Maxintervalsettings from "./_settings/_max_interval.mdx";

---

## The Wait block

## Properties

## Settings

import Blocksettings from "./_settings/_settings.mdx";
import Retrysettings from "./_settings/_retry.mdx";
import Intervalsettings from "./_settings/_interval.mdx";
import Exponentialsettings from "./_settings/_exponential.mdx";
import Finallysettings from "./_settings/_finally.mdx";
import Coefficientsettings from "./_settings/_coefficient.mdx";
import Maxintervalsettings from "./_settings/_max_interval.mdx";

---

## The Current User object

You can reference the `current_user` object when a workflow is manually run from the workflow IDE or triggered from an app by a user. The evaluated `current_user` in workflows is an admin in your organization's instance or space. This differs from apps and agents, where the `current_user` is evaluated as the current, logged-in user. Workflows are always run as an admin role to ensure that when workflows are run without access to the current, logged-in user (such as when triggered by schedule or webhook), sufficient access to any resource on the control flow is guaranteed.

## Run workflow as the current user

There is a public beta feature that allows your organization to run workflows as the logged-in user when workflows are manually run from the workflow IDE or triggered from an app by a user. Please be aware that, even with this beta feature activated, any workflow invoked via a webhook, query, or app trigger or by another workflow still assigns `current_user` as an admin user.

:::note

To set the `current_user` to `null` on automatic workflow run, reach out to your account manager.

:::

## Properties

---

## The Start Trigger object

You can reference the `startTrigger` object when a workflow is manually run from the workflow IDE or [triggered with a webhook](../../guides/triggers/webhooks.mdx). `startTrigger` is `null` when a workflow is configured to use a schedule trigger.

## Properties

---

## The Workflow Context object

## Properties

---

## Retool Events reference

Use Retool Events to build workflows that run whenever certain events occur within your organization. Event payloads contain properties with information related to the event. You can reference these within Retool Event-related workflows to perform actions or send notifications automatically.

[Learn more](../guides/retool-events.mdx) about setting up Retool Events.

## Password reset required

A user must reset their password.

## Source Control deployment completed

Source Control has completed a deployment.

## User created

A user was created.

## User invited

A user was invited to join the organization.

## User requested access

A user requested access to join the organization.

## Login attempted

A user attempted to log in. This event runs after a user has been authenticated, but before they complete the login process.

---

## Retool Workflows reference

import Reference from '/docs/_partials/_doctypes/_reference.mdx';

---

## Retool Workflows tutorial

[Retool Workflows](./index.mdx) enables you to build, schedule, and monitor jobs, alerts, and ETL tasks. You can automate processes without the need for user interaction and take action based on conditions.

This guide explains how to build a workflow that performs a weekly check for new features added in the [latest edge release](../releases/edge/index.mdx) of Retool. If new features have been added, the workflow sends a notification using [Retool Email](../data-sources/quickstarts/retool-email.mdx). You can also trigger the workflow to check at any time with a webhook event.

## 1. Create a new workflow

Sign in to your Retool organization, select the **Workflows** tab in the navigation bar, then click **Create new > Workflow**.

A workflow's name is initially set to `My First Workflow - Name`. Click the name of this workflow in the toolbar and set it to `Subscribe to the Retool Release Notes`.

## 2. Configure triggers

import Triggerssvg from '/img/icons/workflows/triggers.svg';

You can trigger workflows on a [schedule](./guides/triggers/schedule.mdx), by sending a [webhook event](./guides/triggers/webhooks.mdx), or by polling a streaming service with a [query trigger](./guides/triggers/query.mdx). This workflow uses two types of triggers:

- A schedule trigger to run every week.
- A webhook trigger to manually run the workflow. This allows you to run the workflow at any time.

Click **Edit triggers** in the **startTrigger** block to open the **Triggers** tab.

### Create schedule

First, enable the **Schedule** trigger. Configure it to run every Friday at 5 PM, then click **Save changes**.

### Configure webhooks

Next, enable the **Webhook** trigger.

## 3. Fetch release notes

import Connectsvg from '/img/icon-packs/bold/interface-geometric-circle-alternate.svg';
import Startsvg from '/img/icons/workflows/blocks/start.svg';
import Resourcequerysvg from '/img/icons/workflows/blocks/resource-query.svg';
import Runsvg from '/img/icons/workflows/run.svg';

Workflows are comprised of [blocks](./guides/blocks/blocks.mdx) that perform specific actions, such as interacting with data or performing custom logic. You connect blocks together to define their control flow, which represents the order of operation in which they run.

This workflow uses the [Resource query](./guides/blocks/resource-query.mdx) block. You would primarily use this to query [resources](../data-sources/quickstarts/resources.mdx)—data sources you've connected to Retool—but you can also use it to interact with APIs and fetch JSON data with the **REST API** resource.

Retool releases a [new edge release](../releases/index.mdx) for self-hosted deployments every week and publishes the corresponding [release notes](../releases/edge/index.mdx). You can use the [JSON feed](https://docs.retool.com/data/releases/edge.json) of the edge release notes to subscribe to notifications. In this section, you'll subscribe to the release notes and get a list of everything in the `added` category for the most recent release.

Click and drag  from the  **startTrigger** block to create a new block, then select the  **Resource query** block type. Click on the block name and change it to `fetchPosts`.

This block defaults to the **REST API** resource with a **GET** action type. Specify the JSON feed in the **URL** field.

```url title="JSON feed"
https://docs.retool.com/data/releases/edge.json
```

Click  **Run** to retrieve the JSON feed data. The JSON feed contains an array of objects, `items`, that contain information about each release.

Next, add a JavaScript **Code** block that gets the most recent post. Click or drag from  to create a new **Code** block. Name this block `fetchLatest`, and copy and paste `return _.first(Object.values(fetchPosts.data));` to return the most recent post.

Finally, add one more JavaScript **Code** block that returns an array of every change in the `added` category. Title this block `fetchAdded`, and paste `return fetchLatest.data.versions[0].added` into the code block.

## 4. Check for added functionality

Use the **Branch block** to perform different actions based on whether the input value meets a truthy condition. Branch blocks allow you to create two different paths for a workflow to take, depending on whether the condition evaluates as `true` or `false`. In this case, the workflow needs to check if the most recent release notes contain any features labeled `added`.

First, click or drag  from `fetchAdded` to add a **Branch** block, then rename it to `containsAdded`. In the **If** statement, specify the following condition: `fetchAdded.data.length`. This condition evaluates to `true` if there are any features in the `added` array.

## 5. Summarize changes using AI

You can leverage AI in workflows to perform actions, such as summarizing text or generating images. This workflow uses an AI action to generate a summary of changes.

Click and drag  from the **If** statement in `containsAdded` to add an **AI action** block, then rename it to `summarizeChanges`. Select the **Generate text** action and instruct the AI model to generate a summary.

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

```text title="Instructions"
{{ fetchAdded.data }} contains a list of features that Retool added this week. Write me a summary of the added features. Link to the latest edge release notes at https://docs.retool.com/releases/edge for more information.
```

:::info Differences in generated AI content

AI-generated content may differ from the example below.

:::

```text title="Generated summary"

This week, Retool introduced several new features and enhancements:

1. **Typography Enhancements**: New rebrand fonts were added, alongside newly created typography components specifically for the sign-in page.
2. **NFC Tag Support**: Users can now read and write NFC tags within the platform.
3. **Semgrep Testing Support**: The platform now supports testing for writing `semgrep` rules.
4. **Action Mirroring**: Functionality was added to support mirroring actions that affect the app template.
5. **Global Split Pane Rendering**: Children of a global split pane can now be rendered across all pages.
6. **Cypress Enhancements**: New tabs have been added to the Cypress testing editor for improved usability.
7. **Global Component Tree Update**: A split pane feature was added to the global component tree.
8. **SSO Test Connection Management**: Users can now open the SSO test connection page in a new tab.
9. **Session-Specific State Management**: The platform now retains session-specific state variables like `current_user` and `viewport` during test generation.
10. **App Template Copying**: New support for copying app templates to mirror after slice loads was introduced.
11. **Enhanced App Testing UI**: A new user interface for app testing has been implemented, featuring expanded value code editors for query mocks and preconditions.
12. **Database Archiving Safeguards**: Safeguards have been integrated for Retool Database archiving processes.

For detailed information on these features, please check the [latest edge release notes](https://docs.retool.com/releases/edge).

```

## 6. Send an email notification

:::tip Use other notification methods

You can connect many communication platforms and services to Retool, such as [Slack](../data-sources/guides/integrations/messaging/slack.mdx), [Twilio](../data-sources/guides/integrations/messaging/twilio.mdx), [SendGrid](../data-sources/guides/integrations/messaging/sendgrid.mdx), and [Microsoft Teams](../data-sources/guides/integrations/messaging/microsoft-teams.mdx).

:::

Finally, the workflow must send an email with:

- The Self-hosted Retool version number.
- The AI-generated summary.

You can use [Retool Email](../data-sources/quickstarts/retool-email.mdx) to send emails without any extra configuration. Click and drag  from the AI action block to add a new Resource query block, then rename it to `sendEmail`. Configure the block with the following values:

| Property    | Value                                                              |
| ----------- | ------------------------------------------------------------------ |
| **To**      | The email address to receive the notification.                     |
| **Subject** | `Retool Self-hosted version {{ Object.keys(fetchPosts.data)[0] }}` |

Finally, set **Body** to **Markdown** mode, and include the summary:

```text title="Message body"
{{ summarizeChanges.data }}
```

import Runprevioussvg from '/img/icons/workflows/run-with-previous.svg';

Next, create a new Retool Email block that sends an email if there are no changes in the `added` category. Click and drag  from the `Else` branch of the `containsAdded` block. Set the same **To** and **Subject** field, and include a summary stating that nothing was added this week: `Retool did not add any features in this week's release.`

## 7. Add an error handler

import AddBlocksvg from '/img/icons/workflows/add-block.svg';
import Errorsvg from '/img/icons/workflows/global-error-handler.svg';

If an error occurs at any point in the workflow, it will fail and you won't receive your weekly update email. Set up a [global error handler](./guides/error-handlers) that sends you an email if something goes wrong. You can use various types of block types as error handlers—in this example, you'll use a **Resource query** block to send an email.

Open the Blocks  menu and drag the **Resource query**  block onto the canvas. The block does not need to be connected to other blocks. Rename the block `errorHandler`.

Click the ••• menu and select  **Add global error handler**. Next, change the resource type to **Retool Email**, and configure the block to send an email that tells the recipient that the workflow failed.

## 8. Test and publish the workflow

Now that the workflow is complete, you can manually run it to test. Click  **Run** in the toolbar to run the workflow. You can also test the workflow by calling the webhook trigger. To do so, open the  **Triggers** tab and select the **Webhook** trigger. Click **Copy > Copy as cURL** to copy a cURL command to run in the CLI.

Run the command to trigger the workflow:

```curl title="Example cURL command
curl -X POST --url "https://api.retool.com/v1/workflows/090bb051-1534-4279-b863-35gfk8223/startTrigger" \
-H 'Content-Type: application/json' \
-H 'X-Workflow-Api-Key: retool_wk_xxxxxxxx'
```

Workflows run automatically once published. If you want to test the schedule trigger and receive notifications automatically, click **Publish release** in the toolbar.

## Wrap up

At this point, you have successfully created a workflow that will keep you informed about the features that Retool adds in every week's edge release.

To continue learning about workflows, explore the guides for other common features:

- [Retool Events](./guides/retool-events.mdx)
- [Loops](./guides/blocks/logic/loop.mdx)
- [Webhook responses](./guides/blocks/response.mdx)
- [Best practices](./concepts/best-practices.mdx)
